---

title: Hierarchical database report generation with automated query generation for placeholders
abstract: A computerized method, implemented in at least one processor, for automatically generating a report, the method including, receiving, by the at least one processor, a document that includes placeholders arranged in a layout, reading, by the at least one processor, the placeholders, mapping, by the at least one processor, the placeholders to respective executable queries, executing, by the at least one processor, a search of a database using the executable queries to retrieve information from the database, mapping, by the at least one processor, the information from the database to the layout, and generating an updated document that includes the information retrieved from the database arranged in a layout defined by the layout of the placeholders.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09646004&OS=09646004&RS=09646004
owner: SOFTWARE AG
number: 09646004
owner_city: Darmstadt
owner_country: DE
publication_date: 20140115
---
At least some of the embodiments of the subject matter disclosed herein relate to the field of user interfaces and databases.

Current application systems typically work with large amounts of structured data usually stored in databases. Accessing this data can be costly and complicated typically requiring a skilled user even to perform simple tasks. For example information contained in a database can be included in a report that is generated using JavaScript. However this typically requires intimate knowledge of the JavaScript language to obtain the desired report. Alternatively pre programmed report types can be distributed with the database but this approach can be inflexible and typically does not permit the user any ability to customize the report. Reports can also be generated using specialized design tools but such tools typically require some knowledge of the internal data structures in order to create the appropriate query.

A computerized method implemented in at least one processor for automatically generating a report the method including receiving by the at least one processor a document that includes placeholders arranged in a layout reading by the at least one processor the placeholders mapping by the at least one processor the placeholders to respective executable queries executing by the at least one processor a search of a database using the executable queries to retrieve information from the database mapping by the at least one processor the information from the database to the layout and generating an updated document that includes the information retrieved from the database arranged in a layout defined by the layout of the placeholders.

Various aspects of the disclosed subject matter can provide one or more of the following capabilities. A user can design a custom report with desired formatting more easily than with prior techniques. A user can design a report template with desired formatting using placeholders in a document. A database report template can be designed using a word processing application. A report template can contain arbitrary placeholders that are mapped to database queries. A data mapper can scan the report template to extract placeholders. A user or other role can interactively map assign correlate placeholders to database queries. A data mapper can be used to link placeholders to appropriate queries. The data retrieved from database queries can replace placeholders in a completed report. These and other capabilities of the disclosed subject matter will be more fully understood after a review of the following figures detailed description and claims.

Embodiments of the subject matter disclosed herein can provide techniques to generate a completed report from a report template that includes human readable placeholders instead of actual database queries. For example using a word processing program a user can design a report template that includes desired formatting. Included in the report template are human readable placeholders that represent places where the user wishes to insert information that is stored in a database. A data mapper can scan the report template for placeholders and provide an interface allowing the placeholders to be mapped to executable queries which are then executed against a database to retrieve the desired information. The retrieved information then replaces the placeholders in the report template to generate a completed report. Typically the data retrieved from the database will be presented according to the formatting of the report template. Other embodiments are within the scope of the disclosed subject matter.

Database systems are powerful tools that allow people and or companies to dynamically store and use vast quantities of information. While powerful database systems can be difficult to use because they require the operator to have specific knowledge about how the database is configured and implemented. For example a programmer typically should be familiar with the structure of the database the protocol used to access the database and the operation of the program that ultimately receives the data from the database.

Typically when a user wishes to access information in the database the user will execute a query. After executing the query a report can be generated that includes the information requested by the query. In general reports can be generated using either predefined templates provided by database access software or by an administrator with intimate knowledge of the database itself. However defining a query and the format of the finished report can be difficult for those who do not have specific knowledge about for example the structure and content of the database.

Thus in some embodiments of the subject matter disclosed herein a user can be provided with techniques for defining a report using a word processing application without requiring intimate knowledge about how the database is structured and or functions. For example a user can design a report template that contains the desired formatting structure and layout using MICROSOFT WORD. The user can also include one or more placeholders in the report template that are later used to retrieve information from the database and automatically populate the report template to create a completed report. In this way the user can avoid working with unfamiliar tools or inflexible queries while defining the desired report layout in a standard word processing tool.

In some embodiments the system can be arranged in a split role architecture. For example a template developer e.g. a user can use arbitrary names for placeholders in a report template. Then at a later step the semantic for corresponding database queries can be added by for example another role e.g. another individual entity or system . The original user that created the report template is not required to know about the queries used to access the database and or the structure of the database itself e.g. the user does not need to know about any parent child relationships that may exist and can use his or her own words to define what the result should be . Thus in this exemplary architecture another role e.g. an administrator can determine what the template designer intended with the placeholder name. In other words the process of creating a report template and corresponding queries can be split into two phases one where a report template is created by a user that lacks knowledge about the database and query structure and another phase where the report template is mapped to individual queries based on the placeholders e.g. by someone with knowledge about the database .

The resulting query can have varying complexity e.g. not only top down . For example given an employee database with the following name address and position information 

Referring to an exemplary computer system that can be configured to implement the functionality described herein is shown. The system includes client computers a server a database all of which can be connected to a network . The client can be configured to provide a data mapper and a word processing application . While shows the data mapper as part of the client e.g. as shown in client this is not required. For example the data mapper can be remote to the client can be included in the server and or can be included in the word processing application if desired.

The clients can be for example local remote or a combination thereof to the server . The clients can be for example interactive smart phones tablet devices PDAs desktop computers laptop computers servers other computers or other devices coupled via a wireless or wired connection to network . The clients can receive data from user input a database a file a web service and or an application programming interface. The clients can utilize programs such as the word processing application for the creation editing and presentation of database report templates. The clients can also utilize data mapper to assign data queries to placeholders. The clients however can also provide many other programs that can be used with the techniques described herein e.g. spreadsheet programs presentation programs e mail programs .

In some embodiments the client can be designated as a design time client e.g. client and or as a run time client e.g. client although this distinction is not required. In this embodiment the run time client can omit the data mapper as shown in . For example the run time client can display and or generate a completed report using previously mapped report templates and or placeholders thereby allowing the omission of the data mapper .

The network can be a local area network LAN a wide area network WAN the Internet cellular network satellite network or other networks that permit communication between the clients the server and other devices communicatively coupled to network . The network can further include one or any number of the exemplary types of networks mentioned above operating as a stand alone network or in cooperation with each other. The network can utilize one or more protocols of one or more clients or servers to which they are communicatively coupled. The network can translate to or from other protocols to one or more protocols of network devices. Although the network is depicted as one network it should be appreciated that in some embodiments the network can comprise a plurality of interconnected networks.

The server can be for example an application server a backup platform an archival platform a media server an e mail server a document management platform an enterprise search server a combination of one or more of the foregoing or another platform communicatively coupled to the network . The server can also include mapping data for the processing of placeholders and a report output generator for generating a completed report. The server can also utilize database for storage and retrieval of data via database queries. The server can be a host such as an application server which can process data traveling between the clients and other devices communicatively coupled to the network . While the mapping data and the report output generator are shown in as part of the server this is not required. The mapping data and or report output generator can be located elsewhere e.g. in the client if desired. The mapping data along with the report template can be considered the report definition.

The data mapper can be an interactive component that maps and or allows a user to map data queries to placeholders. For example the data mapper can communicate with word processing application to receive a report template or portions thereof . The data mapper can search the report template for placeholders and then present the identified placeholders to a user. The user can then map correlate those placeholders to corresponding queries having the proper syntax. Ultimately the query generated from the data mapper can be executed on the database to retrieve the information desired by the creator of the report template. The data mapper is described more fully below.

The word processing application can be a typical word processing program such as MICROSOFT WORD LIBRE OFFICE WRITER WORDPAD OPEN OFFICE WRITER and or APPLE PAGES. Using the word processing application a user can create a report template in the form of a document e.g. a MICROSOFT WORD document . The document includes placeholders that are ultimately provided to the data mapper . The report template can be a formatted document set to appear as a completed database report with placeholders taking the place of completed database queries. The word processing application can also generate and provide a finished report to the user although at least some of this functionality is typically provided by other components such as the report output generator .

While the word processing application is primarily described as a word processing program this is not required and other types of applications can be used to generate report templates and finished reports. For example the techniques described herein can also be used with other types of programs such as spreadsheets generated using MICROSOFT EXCEL presentations created using MICROSOFT POWERPOINT e mails created using an e mail client web pages text messages instant messages social media posts e.g. FACEBOOK posts etc.

The mapping data can be information related to the database that is generated as a result of a prior mapping operation. For example after a placeholder is mapped to a proper query for extracting data from the database this information can be stored as mapping data . The mapping data can be generated by for example the data mapper . In some embodiments the mapping data can include a user defined mapping along with a corresponding report template or vice versa . The mapping data can be used at a later time to repeatedly create one or more completed reports without having to create a new mapping each time. Additional details about this process are described below. While the mapping data is shown in as being part of the server this is not required and the mapping data can be located elsewhere e.g. on the client . Lastly the mapping data can be stored one by one e.g. a single placeholder mapped to a single query as an entire report e.g. all of the placeholders in a report template and the corresponding queries and or a combination of the same.

The report output generator can be configured to generate a completed report from a report template. For example the report output generator can receive a report template cause the execution of database queries using the mapping data to retrieve information corresponding to the placeholders and substitute the retrieved information into the report template to produce a completed report. In other words the report output generator can convert a report template into a completed report by retrieving the necessary information to substitute in place of the placeholders. The report output generator can then provide the completed report to for example the word processor for display and or to a memory for storage.

The report output generator can be run contemporaneously with the data mapper or can be run at a later time using previously established mapping data. This can be enabled by an architecture that is divided up into design time and run time phases. For example i a report template can be created placeholders can be mapped and completed report can be generated all in one session and or ii a report template can be created placeholders can be mapped and a completed report can be generated in different sessions. While the report output generator is shown in as a separate block it can also be included as part of another component e.g. it can be part of the word processing application .

Referring also to an exemplary mode of operation of the data mapper using the ARIS platform provided by SOFTWARE AGof Darmstadt Germany is shown. In this embodiment the process can be thought of as involving two phases a design time phase and a run time phase although the use of different phases is not required .

During the design time phase the data mapper can receive a report template from the word processing application that includes placeholders an exemplary report template is shown in . The report template can be imported into the data mapper which can analyze the report template to identify all of the placeholders therein and an associated hierarchy of the placeholders.

Each of the extracted placeholders can be displayed to the user or another role in one or more formats. For example in some embodiments the data mapper displays the extracted placeholders in a tree format that represents the hierarchy associated with the placeholders an example of this is described below with respect to . Using the display the user or another role can interactively assign map data queries to each of the placeholders in the report template e.g. a formal query definition to be executed can be mapped to each placeholder . In the example of the queries can be generated Script API calls and or ARIS queries although other queries are possible. Further details of the mapping process are described below with respect to for example .

As part of the process of assigning mapping data queries to the placeholders the data mapper can use internal data structure knowledge to display possible query selections. For example the internal data structure knowledge can include application specific knowledge such as how data elements are connected e.g. structure and which query possibilities are available e.g. in this ARIS specific example which ARIS metamodels and query options are available . Each of the mappings can be stored as mapping data e.g. on the server .

During the run time phase which occurs after the design time phase the report output generator reads a report template to identify the placeholders therein. The report output generator then retrieves the corresponding mapping data e.g. from mapping data for the placeholders in the report template. Using the mapping data the report output generator causes the corresponding queries to be executed in the database . The placeholders in the report template can then be replaced with the information retrieved using the queries to generate a completed report. The report output generator can then store the completed report for later use e.g. in a memory in the client and or the server . In general the completed report can be a document with the same content and formatting of report template where the placeholders have been replaced by the resulting output of the database queries the placeholders are intended to represent. The format of the output report can advantageously be arbitrarily defined by the user prior to execution of any database queries.

Referring to an exemplary report template created using MICROSOFT WORD is shown. In this example document is an embodiment the report template described above. The document can be arbitrarily formatted by the user and can include a number of placeholders e.g. placeholders and . Examples of the placeholders shown in include etc. Preferably the placeholders are placed near descriptive titles of the referenced data e.g. is next to Creation Date .

Placeholders within the document can be almost any words or phrases set off by the characters. In one sense placeholders can be thought of as a character sequence that is later replaced with data. For example a user can create a placeholder that represents a date of creation of a particular element of the database . The user could name the placeholder descriptively with the string CreationDate. The string could then be defined as a placeholder by placing it inside the special characters . In this example the placeholder could be inserted into the document as . Although this example refers to the characters characters other than or merge fields can be used to set off placeholders. Because placeholders are typically mapped to database queries by the data mapper in later process placeholders can have arbitrary names that are independent of any structure used by the database .

In another aspect placeholders can refer to database query results which are lists of items or they can refer to simple data output.

A region can be a part of the document template that is enclosed in matching start and end placeholders e.g. and . For example the space between placeholder i.e. and placeholder i.e. can be considered a region in the document . Regions can also be nested within one another. For example the region between placeholders and is nested within and can be considered a child of the region defined between placeholders and . In one sense a region can refer to a query that returns a list of elements.

By contrast the placeholder refers to simple data output. Simple data output placeholders can be identified by the lack of a corresponding placeholder. Simple data output placeholders can return either i simple data that replaces the placeholder and uses its formatting in the completed report or ii list data that is to be filled into the completed report in linewise fashion using the existing line formatting of the document . Placeholders that relate to simple data output can be represented by an arbitrary word that is descriptive of the data output it relates to. For example the placeholder Time which refers to simple data output can be represented in the report template as although this is not required.

The placeholders in the document can be arranged in a hierarchical configuration where one placeholder is a parent or child of another. The hierarchy can include multiple levels. For example in ProcessModels i.e. placeholder is a higher level than Functions i.e. placeholder which is a higher level than Name i.e. placeholder . Stated differently the Name placeholder is a child of the Functions placeholder which is a child of the ProcessModels placeholder. Likewise the ProcessModels placeholder is a parent of the Functions placeholder which is a parent of the Name placeholder. Placeholders can have multiple children and or parents. All placeholders except the highest level placeholder are typically children of at least one other placeholder. The highest placeholder can be related to the topmost query and can be known as the toplevel placeholder which is typically mapped to the toplevel query. The parent child relationship between two placeholders can affect the mapping process as described more below.

Referring to an exemplary completed report generated from the document is shown represent a four page report with part A shown in and part B shown in . The completed report represents exemplary results of the process of i creating the document ii mapping placeholders to queries using the data mapper and iii executing the corresponding queries to create the completed report. The query results e.g. and can replace placeholders originally in document . Results and represent the name of a queried model e.g. myModel1 . Result represents the date of creation of myModel1 e.g. Oct. 15 2013 . Result represents the functions executed in the parent model myModel1 e.g. myFunction1 and myFunction2 . Result represents a graphical image of the model. thus collectively provide the output report for a single report template where the placeholder ProcessModels referred to two models e.g. myModel1 and myModel2 .

Referring to an exemplary interface for mapping and or defining queries corresponding to the placeholders in the document is shown. show the interface at two different times as the mapping process advances is later in time than . In some embodiments while the user who created the original report template need not have any knowledge of how the database is structured such knowledge can be beneficial to the user or other role that creates the mapping. For example the user role responsible for completing the mapping can know how data is structured in the database e.g. how metamodel information is structured in ARIS .

In the left pane of the interface typically each placeholder in the document will have a corresponding row. All placeholders extracted from document are typically presented in a hierarchical tree format that is extracted from the document . For example a user can easily tell that Name is a child of Functions in from the structure of the tree e.g. because Name is under Functions and slightly indented . The hierarchical structure can be used to restrict the possible queries selectable for individual placeholders as described more fully below. As a user works on a particular placeholder the corresponding row in the interface can be highlighted e.g. highlight .

The hierarchical tree in the left pane of can be created by extracting placeholders iteratively from document . In one embodiment the system can detect regions in the template corresponding to placeholders. For example upon finding a first placeholder the system checks whether there is another placeholder somewhere in the template with the same name ending with the  End phrase. If that placeholder is found the process can be repeated for all placeholders between the two located Start and End placeholders e.g. representing a lower level of nesting in the tree . If the  End placeholder is not found the placeholder can be added to the current level of the tree. After the above stage is completed the system can then continue searching in the same manner until the end of the document is reached.

In the center pane the user or another role can define a query for each line of the hierarchical tree e.g. for each placeholder . As shown in this can be done via SELECT clauses but this is not required and other clauses can be used. For example the user can define a query corresponding to ProcessModels in field .

The choice of queries available in the center pane can depend on the placeholder itself and or the placeholder s parents grandparents great grandparents etc. if any . For example the available queries for each placeholder will typically respect the constraint of a result data type of the parent. can be useful in describing this concept further. are transition diagrams that represent a query of a type i general ii Model to Object list and iii Model to Attribute list .

Referring to the general embodiment in a generic query definition is shown. Using this generic case each query typically has a SourceDataType and a corresponding TargetDataType. The SourceDataType of each child query will typically match be inherited and or be constrained by the TargetDataType of its parent. shows a specific example of the generic case an ARIS query. In the query definition is All persons working on IT systems used in this process. The query has a SourceDataType of Model that is inherited from its parent and or defined by the report template itself and a TargetDataType of Object definition with a further type of person. shows yet another specific example of the generic case an ARIS report query with a query based on concatenation of Report API calls. In the query definition is Model Attributes. The query definition has a SourceDataType of Model that is inherited from its parent and or defined by the report template itself and a TargetDataType of Attribute. 

In other words queries can have a data type that they start with e.g. an input and can return a result of a certain data type e.g. an output . If a query returns a list of a certain type A the mapping of its children if any can have A as a defined input and can be executed for each element of the list generated from the parent query.

Turning back to how placeholders are mapped to queries in the interface if a user or another role wants to assign a data query to the placeholder ProcessModels the user can define and or describe the corresponding query in the center pane . The corresponding query defines how to obtain the desired data from the database . In this example since ProcessModels is at the topmost level of hierarchal tree this placeholder can be referred to as a top level placeholder and the resulting query can be referred to as a top level query. Because the top level placeholder has no parent the SourceDataType of the corresponding query can be defined by and or inherited from the document itself e.g. this information can be embedded in metadata of the document . For example when a user creates the document the user can associate one or more types with it such as model. Accordingly when the user maps a corresponding query for ProcessModels all available queries for the type model can be available to the user in the field . In other words model can be inherited from the document as the SourceDataType of the corresponding ProcessModels query because ProcessModels is the top level placeholder.

Continuing this example the query corresponding to ProcessModels can be defined as all models in the database which describe processes. Models can be thought of as describing processes when they have a type that indicates that they describe processes. This results in the following top level query 

Continuing the example when defining the query to be assigned to Functions the user can select from all queries that have a process model as an input. In this example the user selects a query that extracts objects typed as Function from the input data 

Since the placeholder ProcessModels in this example corresponds to a region the inner layout of this region can be repeated for each element of the result e.g. a list of models in a completed report. Thus the inner queries can refer to each single element of the resulting list. For example the database can contain one model of subtype A one model of subtype B and no models of subtype C. The result of this top level query would then return two different models. The completed report would then repeat the entire layout of the report template for all content between the ProcessModels and ProcessModels End placeholders for each of these two models. An example of this is illustrated in . The query resulting from the ProcessModels placeholder resulted in myModel1 and myModel2 thus the entire the completed report includes the layout corresponding to ProcessModels twice e.g. beginning at result and then again at result .

The right pane shows a sample read only preview of the document . As a user selects a particular placeholder in the interface i.e. ProcessModels in the corresponding portions of the document can be highlighted e.g. highlighting .

In some embodiments the user maps queries to placeholders in a top down manner e.g. from a the top level placeholder to the lowest level child since the result of a parent query is typically needed as input data for a child query although this is not required.

Referring to this figure is a continuation of except that the user is now working on the mapping of AttributeList. For example by comparing it can be seen that AttributeList is now highlighted with the highlight rather than ProcessModels and the corresponding portion of the right pane is highlighted with corresponding highlight . Referring to center pane a query corresponding to AttributeList is shown 

If a user presses any of the . . . buttons shown in the user can define select the corresponding query interactively via a dialog window. For example referring to an exemplary dialog window generated using ARIS is shown.

In operation referring to with further reference to an exemplary process for creating a report template mapping placeholders to associated queries and generating a completed report includes the stages shown. The process may be altered e.g. by having stages added removed altered or rearranged.

At stage the user can select the word processing application and create a report template. The word processing application can include any application that the user is comfortable with. After starting the word processing application the user can open an existing document or create a new document. For example referring to a screen shot of an exemplary embodiment of the disclosed subject matter shows a document which is an embodiment of the report template being created in MICROSOFT WORD.

At stage the user can insert placeholders into the document in the desired format. For example referring still to the user can insert placeholders e.g. placeholders and into the document being arranged and configured as desired e.g. location orientation font size etc. . A placeholder can be an arbitrary string of text created by the user as a temporary designation to refer to a desired query to the database. The placeholder can be used to allow a user to design the format of an output report query from a database. The placeholder can eventually be mapped to a corresponding query in the data mapper . The placeholders can generally be named with an arbitrary designation that the designer can understand refers to the intended query to the database.

The placeholders in the document are preferably formatted to appear in the desired location in the completed report. For example the placeholder can be placed directly below the heading CREATED ON to generate a report that places query responses in an easy to read customizable format. In another example the user can create the placeholder next to the text MODEL NAME to generate a report that places the name of the model being used in an easy to read customizable format. The user can create an arbitrary number of placeholders to refer to queries to the database and each placeholder can be formatted to create a report template that is later converted into the completed report during the run time phase. Thus the placeholders can advantageously be chosen without knowing the structure of the underlying database.

At stage the data mapper receives the document e.g. at a receiving module . In one embodiment the data mapper can be included as a part of an ARIS client application although this is not required and the data mapper can be a standalone application or program. The data mapper scans the document for placeholders and presents the user with a data mapping interface . The scanning of the document can be performed by a reading module that can be part of the data mapper .

At stage the user can map each placeholder in the document to a corresponding query using the interface e.g. using a first mapping module . If desired this stage can be performed by another role such as an administrator with knowledge of the database. The user can be provided with a hierarchal tree of the used placeholders in the interface . The tree can then be used to map each placeholder to a corresponding query. In some embodiments the queries can be either generated Script API calls and or ARIS Queries. For example a mapped query for the document placeholder can be SELECT ALL Attribute FROM Model . The queries can be executed against the database to retrieve data. The queries can be executed by for example a search module that can query the database .

At stage a completed report is generated using the document and the information retrieved from the database . In one embodiment the completed reported is generated by report output generator . The results of the queries can replace the placeholders in the document to create the completed report. For example in an embodiment that uses ARIS this stage can be accomplished by providing tools inside ARIS to link ARIS data to document placeholders. The completed report can be free of placeholders as they are replaced with the results of executed queries to the database . This stage can be performed by for example a second mapping module and an updating module.

Stages and can generally be grouped into a design time process e.g. in and stage can be part of a run time process e.g. in although this is not required. For example a template can be initialized e.g. defined and mapped during design time . Then at a later time the report template along with previously generated mapping data can be used repeatedly to create one or many reports without having to remap the placeholders. Thus in some embodiments a user does not need to create a mapping each time the user wants to generate a completed report as long as the placeholders in the report template have not been changed. This can ease the process of ensuring that a completed report is synchronized with the latest data in the database .

The placeholder can stand for text representing a Model for example the model name or for the beginning of a region. It can be interpreted as the beginning of a region when there is a corresponding end placeholder e.g. in the report template. If regions are nested it can be assumed the user has given the different regions distinguishable names.

One can also access the length and index of the results of queried data if the result is a list using the following syntax 

Index and length can also be used to create conditional statements within the report template. These conditional statements can allow the user to define report behavior in the template without knowing certain characteristics of the underlying database. For example the following conditional block can be added to the report template 

A further example this can be seen by comparing the document and the completed report. The document includes a cell that includes the following placeholders 

Finally the placeholder can be used to cause cells inside of a table to be horizontally and or vertically merged within the report template. For example this placeholder can be used to merge adjacent rows of cells with the same content such that the table in can be formatted as shown in .

In some embodiments low level field formatting such as date or number can be ignored by the system because query results can be assumed to know how to transform themselves into the appropriate text. This text can be formatted exactly as the field is formatted in the template e.g. bold italic or font size .

In some embodiments images can use a special handling as image formatting can be performed in a template on an image itself. For example a user can insert a dummy image placeholder into the document and maintain the property alternative text as placeholder name. The user can format the image as desired e.g. size border or text flow . In the completed report the image placeholder can be replaced with an actual image e.g. image .

A potential problem when one uses word processing templates which are to be filled with data is ensuring that template and data are in sync. This problem can occur when the report template is updated. For example the synchronization issue can arise if the user revises the placeholders in the report template. The data mapper can offer easy synchronization between the current version of the template and the mapped data. For example report templates can be checked to make sure that corresponding mapping data is still up to date assuming the report template has been previously mapped . In circumstances where placeholders have been added the user can be presented with the data mapper to map the newly added placeholders. In circumstances where placeholders have been removed or are no longer used these placeholders can be ignored during runtime when the completed report is generated.

In some embodiments the data mapper can be part of an ARIS client application produced by SoftwareAG of Darmstadt Germany. In this example when the user wants to define a new report the user can select a template from his or her file system which is then imported into ARTS. The next view presented to the user can be similar to that shown in . A possible advantage of including the data mapper in ARIS is for example that functionalities already exist to define ARIS specific queries e.g. as shown in .

The subject matter described herein can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structural means disclosed in this specification and structural equivalents thereof or in combinations of them. The subject matter described herein can be implemented as one or more computer program products such as one or more computer programs tangibly embodied in an information carrier e.g. in a machine readable storage device or embodied in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers . A computer program also known as a program software software application or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file. A program can be stored in a portion of a file that holds other programs or data in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification including the method steps of the subject matter described herein can be performed by one or more programmable processors executing one or more computer programs to perform functions of the subject matter described herein by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus of the subject matter described herein can be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processor of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and optical disks e.g. CD and DVD disks . The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

The description herein describes network elements computers and or components of a system and method for providing a bundled product and or service along with an insurance policy that can include one or more modules. As used herein the term module refers to computing software firmware hardware and or various combinations thereof. At a minimum however Modules are not to be interpreted as software that is not implemented on hardware firmware or recorded on a non transitory processor readable recordable storage medium i.e. modules are not software per se . Indeed module is to be interpreted to always include at least some physical non transitory hardware such as a part of a processor or computer. Two different modules can share the same physical hardware e.g. two different modules can use the same processor and network interface . The modules described herein can be combined integrated separated and or duplicated to support various applications. Also a function described herein as being performed at a particular module can be performed at one or more other modules and or by one or more other devices instead of or in addition to the function performed at the particular module. Further the modules can be implemented across multiple devices and or other components local or remote to one another.

Additionally the modules can be moved from one device and added to another device and or can be included in both devices. To provide for interaction with a user the subject matter described herein can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well. For example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The subject matter described herein can be implemented in a computing system that includes a back end component e.g. a data server a middleware component e.g. an application server or a front end component e.g. a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the subject matter described herein or any combination of such back end middleware and front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

