---

title: Serial interpolation for secure membership testing and matching in a secret-split archive
abstract: The various technologies presented herein relate to analyzing a plurality of shares stored at a plurality of repositories to determine whether a secret from which the shares were formed matches a term in a query. A threshold number of shares are formed with a generating polynomial operating on the secret. A process of serially interpolating the threshold number of shares can be conducted whereby a contribution of a first share is determined, a contribution of a second share is determined while seeded with the contribution of the first share, etc. A value of a final share in the threshold number of shares can be determined and compared with the search term. In the event of the value of the final share and the search term matching, the search term matches the secret in the file from which the shares are formed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514326&OS=09514326&RS=09514326
owner: Sandia Corporation
number: 09514326
owner_city: Albuquerque
owner_country: US
publication_date: 20141014
---
This application claims priority to U.S. Provisional Patent Application No. 61 891 318 filed on Oct. 15 2013 entitled SERIAL INTERPOLATION TO ENABLE SECURE MATCHING IN A SECRET SPLIT ARCHIVE the entirety of which is incorporated herein by reference.

This invention was developed under contract DE AC04 94AL85000 between Sandia Corporation and the U.S. Department of Energy. The U.S. Government has certain rights in this invention.

Solutions for data archival e.g. long term data archival based on secret sharing offer a way to store data that is resilient to insider threats and able to operate securely even while parts of an archival system are compromised. In such an architecture a file d can be split into a plurality of shares d d that are distributed across a plurality of repositories to create a secure data archive. Each repository can be configured to store a single share e.g. any of d d created from the single file d. Accordingly the data e.g. contents of the file d in its initial form is most secure when it remains split up into each of the shares that are spread out across the repositories.

The data once more becomes vulnerable when an entity requires reassembly of the data from the respective shares whereby the shares are reassembled at a single location. For example an entity having access to a single device at which the shares are reassembled can then access the data in its totality e.g. to perform a search. However an entity with malicious intent can access the data in such a configuration as well as a disgruntled employee who may later wish to distribute the data to expose the type of data stored and accordingly raise awareness e.g. public awareness of what sort of data is being collected.

A specific set of data may require long term archival in a very secure manner whereby storage of the data is to be in accordance with a particular legislation e.g. for example the data is medical information pertaining to one or more individuals and the data is to be stored long term in accordance with a government legislation. While an encryption technology may be deemed secure at the time of archival of the data there is a possibility of the encryption technology being subsequently breached and accordingly the data can then be accessed. Such breach of encryption technology can result from a long term attack on the single device whereby the attack can utilize unlimited computing power and or storage.

Accordingly in comparison with conventional technologies of storing data on a single archive device and securing the data by utilizing encryption applying authorization and or authentication technologies etc. storage of data as shares across a plurality of repositories requires the development of technologies and systems to minimize data vulnerability e.g. when a user is to query the data to analyze one or more items in the data.

The following is a brief summary of subject matter that is described in greater detail herein. This summary is not intended to be limiting as to the scope of the claims.

Various exemplary embodiments presented herein relate to determining whether a term in a query is included in a file whereby the term can be considered directed towards a secret included in the file. The file can be split into a plurality of sibling shares d d whereby the shares can be distributed between a plurality of repositories. In an embodiment no repository stores more than one sibling share.

In order to split the file the file s data can be treated as a sequence of binary words e.g. 16 bit 32 bit 64 bit etc. having a particular value S. Each word in the file can be split in accordance with a generating polynomial p x where the polynomial p x can be generated such that the value S of the secret is located at p 0 . Other points having respective x and y coordinates on the polynomial p x can be determined e.g. based on values of x such that each determined x and y coordinate pair can be assigned to each of the shares d d and each repository in the polynomial p x .

A query Q can be generated whereby the query is directed towards determining which file s in the archive which have been shared across the plurality of repositories begin with a given term in the query Q e.g. is the term equal to S In another embodiment the secret S can be located anywhere in the file. Hence the secret S can be a first term e.g. first word in the file a last term or a term located somewhere in the content of the file e.g. 128word in a third chapter .

Based upon how the splitting of the file was configured a threshold number T of repositories and respective shares can be queried from the total number N of repositories being utilized and storing sibling shares whereby T N.

During execution of the query a Lagrange interpolating polynomial can be generated in a serial manner for each of the repositories in the T repositories. Owing to the interpolation process being serial a first polynomial can be generated for the first repository a second polynomial can be generated for the second repository wherein the second polynomial is based at least in part on a value of the first polynomial etc. The serial interpolation continues until the final repository is encountered whereby a final interpolating polynomial can be generated based at least in part on the previously generated polynomial e.g. the second polynomial and values ascribed to the final repository.

The value at p 0 of the final interpolating polynomial can be compared with the search term in the query. In the event of a determination p 0 the search term a notification can be generated indicating that the term in the query equates to the secret S in the file. In the event of a determination that p 0 the search term a notification can be generated indicating that the term in the query was not found in the file.

In an embodiment a client component can be utilized to generate the query and further to control construction of the final interpolating polynomial based upon the interpolation operations being conducted across the plurality of repositories. In another embodiment a custodian can be located at each of the repositories to facilitate interaction with the client component e.g. transmission of messages and instructions therebetween determination of a contribution of a share stored at a repository coupled to the custodian and further to enable interaction between a repository and at least one other repository.

In an embodiment the client component can additively perturb an interim value s generated during the interpolating operation s with a nonce whereby the nonce is known only to the client component. Utilizing the nonce can ensure that any custodians involved in the query have no knowledge of the search term in the query and or the result.

As previously mentioned the querying of the repositories and the respective custodians by the client component is performed such that each contribution of a share can be determined at the repository e.g. by the repository custodian on which the share is stored and accordingly no reassembly of the shares is required at a single location. Hence secure storage of data is enabled based upon the file being split into shares but the shares do not have to undergo reassembly.

The various embodiments presented herein can also be utilized to securely determine set membership without revealing a list of items in the set or an item being sought in the set. For example to enable maintaining a list of names securely. Each name e.g. NA . . . NZ can be split into n shares e.g. NA. . . NA which are distributed across N repositories e.g. by polynomial splitting . A query Q can be generated to determine if a specific name is in this list. Such an approach can ensure that the N repositories holding the shares do not have any knowledge of the names contained in the list but a query can be executed to enable a membership to be determined

The above summary presents a simplified summary in order to provide a basic understanding of some aspects of the systems and or methods discussed herein. This summary is not an extensive overview of the systems and or methods discussed herein. It is not intended to identify key critical elements or to delineate the scope of such systems and or methods. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Various technologies pertaining to querying data that is partitioned across a plurality of repositories are now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of one or more aspects. It may be evident however that such aspect s may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing one or more aspects.

Moreover the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from the context the phrase X employs A or B is intended to mean any of the natural inclusive permutations. That is the phrase X employs A or B is satisfied by any of the following instances X employs A X employs B or X employs both A and B. In addition the articles a and an as used in this application and the appended claims should generally be construed to mean one or more unless specified otherwise or clear from the context to be directed to a singular form. Additionally as used herein the term exemplary is intended to mean serving as an illustration or example of something and is not intended to indicate a preference.

Throughout the following description the following terms and definitions will be utilized with regard to the various embodiments presented herein 

Share The output from running secret sharing on a block of data in a file d to be stored in the archive. For example a 3 5 sharing scheme would accept a file d and generate a data set comprising five shares d d. d can be reconstructed based upon reassembly of any three shares in d d. In another example a sharing scheme of 6 10 would receive a file d and generate a data set comprising ten shares d dfrom d. In this example d can be reconstructed based upon reassembly of any six shares in d d. It is to be appreciated that any ratio of minimum shares for reconstruction versus a total number of shares can be utilized e.g. T N whereby T equals the minimum number of shares required to enable file d to be reconstructed further described below and N is the total number of shares formed from d which can be considered to be the number of repositories in an archival system as further described below . T and N are positive integers greater than 1 and T N.

Threshold T A number of shares required to recover an original secret S whereby the secret is included in the file d and shared amongst the various data shares. In the 3 5 example above any 3 shares found across 5 repositories are able to reconstruct file d or a secret S contained therein.

Sibling Share A share is a sibling of another share if they are both generated from the same file d e.g. a same block of data . Typically to minimize a risk of reassembly of a file d only one sibling share is stored on each repository.

Repository A computer system or component e.g. a server memory system etc. configured to store and or house one or more shares. Typically to minimize a risk of reconstruction of an initial file d only one sibling share is stored on each repository. As further described herein each repository in an archival system can be located remotely from any other repository e.g. the repositories are different data centers remotely located across a geographic region e.g. the USA . In another embodiment the respective repositories can be different computing devices which are co located in a building e.g. a hospital . In a further embodiment the respective repositories can be separate logical partitions on a computing device. In another embodiment the respective repositories can be cloud storage components local and or remote storage components or a combination thereof.

Custodian A component configured to manage a repository. Per the various embodiments presented herein a custodian typically manages no more than a single repository. Each respective custodian can be configured to control authentication of an entity e.g. a database administrator a client component and accordingly control access to the one or more shares stored at the respective repository.

Archive A collection of all N repositories that together create an archival system for archiving and operating on data e.g. sensitive data in a file s .

Client A computing device connected to the archival system whereby the client is connected via a separate connection to each of the repositories and or repository custodian s .

As previously mentioned sharing a file across a plurality of repositories can improve secure storage of data but the file becomes vulnerable when the file is reassembled at a single location with the reassembled file being generated based upon acquisition of the respective shares on a single computing device. The various embodiments presented herein are directed towards querying a plurality of shares at their respective locations e.g. serially through a plurality of repositories without having to acquire two or more of the shares e.g. at a single location.

It is to be noted that in the various equations presented herein terms highlighted by bolded text indicate the terms are vectors.

The archival system can include a plurality of repositories e.g. repository 1 repository repository 2 repository repository 3 repository repository 4 repository repository 5 repository . . . repository n repository . For the sake of understanding only six repositories are shown in e.g. repositories 1 n where n is a positive integer greater than one however any number of repositories can be utilized in accordance with the various embodiments presented herein. As mentioned above in an exemplary embodiment the repositories can be server computing devices that are coupled to a network e.g. the Internet an intranet etc. .

Further as shown in each of the repositories can include a custodian component. For example repository 1 includes custodian component repository 2 includes custodian component repository 3 includes custodian component repository 4 includes custodian component repository 5 includes custodian component and repository n includes custodian component . As previously mentioned each custodian component can be configured to manage a respective repository. It is to be noted that in the following description the terms repository and custodian are used interchangeably whereby when a repository x is presented as performing such operations as sending calculating receiving identifying matching etc. those actions can also be considered to be being performed by the respective custodian x located at the particular repository x and vice versa.

In an embodiment a file d can be split into a plurality of shares d d whereby each share can be stored on a respective custodian as shown in . For example repository 1 includes d repository 2 includes d repository 3 includes d repository 4 includes d repository 5 includes d and repository n includes d. The file can comprise a secret s S or sensitive data e.g. whereby archiving of the file at the archival system can be in accordance with a legislation or security schema. The archival system can further include additional files which can also be split into a respective plurality of shares not shown which can also be stored at the repositories 1 n. It is to be appreciated that different files e.g. any of files can be split into different numbers of shares. In an embodiment the file can be split into a plurality of shares d din accordance with a cryptographic algorithm e.g. polynomial encoding such as Shamir Secret Sharing.

Further a client component can be included in the archival system whereby the client component can be utilized to access and or interact with one or more of the custodians and or repositories 1 n. A network can be included in the archive system to enable communication between any of the client component the custodians and or repositories 1 n. While not shown as well as the network connecting the client component to the respective repositories and custodians the network can also be connected from one repository to another to enable communication between the respective repositories and the custodians.

It is to be appreciated that the various embodiments presented herein relate to querying of a plurality of repositories between which a file e.g. file has been split and shared. Accordingly during the splitting operation the T N ratio has been utilized hence if a query is to be conducted upon the shares d dby the client component the values T and N are known to the client component a priori in accordance with the T N ratio schema utilized to split the file d and hence the client component is presumed to have access to at least T repositories that include a share e.g. any of d d of the file d. For example each of the N repositories may require a password to access data therein and the user of the client component can have knowledge of passwords needed to access at least T of the N repositories.

In an embodiment file d can be split into the plurality of shares d d whereby the splitting can be performed in conjunction with a share generating polynomial p x . In a further embodiment the generating polynomial p x can be of the order T 1 where as previously mentioned T is a threshold of which the various embodiments presented herein can be based. As described further in an embodiment vector notation can be utilized to indicate operation on one or more terms at once.

During the splitting of d into shares d d a respective identifier for each share d dcan be assigned to each of the shares d dto enable determination of which shares were generated from d and accordingly which shares stored across a plurality of repositories are sibling shares.

Further for each secret S e.g. a word term string substring etc. in each of the files a value for the secret S can be generated. For example the secret can be a word that can be converted to a bit string e.g. a 16 a 32 or a 64 bit string and the generating polynomial p x can be configured such that the secret S is located at p 0 of the generating polynomial p x . Accordingly each share e.g. each of d d formed from the secret S can include a value of a point e.g. relative to x on a curve formed by the generating polynomial p x as further described herein. Hence for each share an x and y pair of coordinates can be ascribed whereby each x y pair can be considered to be a contribution of the respective x y pair to the generating polynomial p x having the secret S located at p 0 .

In a scenario whereby a plurality of files are to be split and shared the generating polynomial p x can be generated for each word in the plurality of files whereby the client component can cycle through each file d generating a unique generating polynomial p x and points on the polynomial for each word in each of the files . The x y points on each respective generating polynomial can then be appended to respective separate shares d d creating N shares to encode data included in each original file .

Accordingly as further described below a process of interpolation can be performed to facilitate determining whether shares e.g. shares d dfor file stored at a plurality of repositories e.g. repositories are sibling shares and hence as part of the determination process the sibling shares can be queried without having to reassemble the sibling shares at a single location. The interpolation process can be performed serially across the repositories such that when a first interpolating polynomial is determined the value s of the first interpolating polynomial can be forwarded for incorporation into a derivation of a subsequent interpolating polynomial. Based upon the interpolation process a determination can be made as to whether a final interpolating polynomial p x formed by the contribution of the respective shares and their respective interpolating polynomials has a value at p 0 that equals a term in a query Q and accordingly a secret S. As further described below in an embodiment a nonce value v can be added such that when a determination is being made as to whether a final interpolating polynomial p x has a value at p 0 that equals a term in a query Q and accordingly a secret S the value of the nonce is accounted for e.g. p 0 nonce term in the query Q.

where ais a randomly generated coefficient vector for i 1 . . . T 1. A particular share e.g. any of shares d d in a particular repository k e.g. any of repositories can be represented as 2 

where k is a positive integer having a value of 1 to n. As mentioned a nonce v can be utilized to add randomness to a query Q. In an embodiment v can be scalar and thus addition with v can be interpreted as 1 3 

a set of n terms that will be used in a query can be denoted as . . . . The n terms can be seeded with the nonce v such that a repository is unable to determine the terms being sought in the query Q or portion thereof.

Further to enable obscuration of whether a particular match has been found a set can contain fake search terms. By utilizing one or more fake search terms after the result of a matching has been determined only the client component will know if the significant term s e.g. S of the query Q was found.

a plurality of messages m that can be passed between the client component and the repositories 1 n. The mmessages can include several pieces of information 

a query number q which can be utilized to index the query Q upon which the respective messages are based. For example qidentifies a first query from a second query q and from a subsequent query e.g. q 

The messages can also include the set of x coordinates of the T repositories that will be used in a query x x . . . x.

message m utilized during initiation of a query Q and can specify the repositories to be used in a reconstruction of file d. For example with a 3 5 operation message mcan indicate which three repositories are to be utilized from the available repositories 1 n 

message tilde over m includes a search term s that is sent from the client component directly to the final repository used in a search of the share located at the final repository e.g. d and

message m includes the results of a search performed at a particular repository that is sent from that particular repository back to the client component .

In an embodiment subsequent to the distribution of the shares d dacross a plurality of repositories 1 n in the archival system the plurality of repositories 1 n can be queried to determine whether a plurality of shares d dstored at the repositories 1 n are generated from a file d that contains a particular word term string etc. For example a query can be executed at the client component as to whether a name e.g. John is the first word in the file d from which the shares d dwere generated such that John is the secret S in the file d. Accordingly do any of the respective shares stored at the repositories contribute to enable a determination that a file e.g. or any of files has the word John as the initial word in the file It is to be appreciated that while the exemplary embodiment is directed to identifying a first word in a file the query can be performed on any string or substring located at any position in the files for example a number string that is the 127term in a file. As previously mentioned the query can be performed without having to reassemble of any of the files from their respective shares.

In a further embodiment as previously mentioned the client component can utilize a nonce v such that when a repository is queried e.g. the last or final repository search during the query a custodian located at the final repository can be prevented from knowing the term that is being sought in a query and also any secret s in the file d.

To facilitate understanding in the following example matching can be performed on a first word in each file based upon a contribution of shares generated from each of the files e.g. a required number of shares in shares d dfor file d . It is to be appreciated that the algorithm can be expanded to a broader search across the shares and also for longer strings. Continuing the previous exemplary ratio of 3 5 the file has been split into five shares e.g. d d whereby a share is stored in one of the respective five repositories e.g. rep 1 rep 5 . Accordingly in this example T 3.

The archival system e.g. the client component or another storage controlling component can store a secret of a file as a y intercept of a generating polynomial such that a particular secret Sin the file d p 0 . To facilitate one or more operations on the secret stored in file d that is now spread across the data shares d d without actually reassembling the data d the client component can utilize Lagrange interpolating polynomials whereby the Lagrange interpolating polynomials can be built serially across the T repositories . In mathematical terms an algorithm can be utilized that computes a y intercept of an interpolating polynomial by summing contributions from a number of Lagrange polynomials in a serial fashion. As mentioned the client component can additively perturb the interpolating polynomial s with a nonce.

Hence given a set of T points x p x . . . x p x the generating polynomial p x of order T 1 can be reconstructed as 4 

In the case of interpolation across a plurality of repositories it is assumed that the list of repositories to be used to find a match e.g. a list of the x with a term in a query Q is known to all of the repositories that are to be involved in the query operation. Furthermore data included at each repository d p x is assumed to be private and known only to the repository e.g. respective repositories that owns the data e.g. respective data shares d d . Accordingly all of the repositories e.g. respective repositories can compute any of the respective interpolating polynomials L x but only repository i e.g. a single repository in the repositories has access to or knows d p x . Hence by distributing each share of a secret having a value S across the specified repositories it is possible to serially calculate the secret S p 0 . For example in order to serialize a reconstruction across three repositories T 3 a distributed reassembly of a given secret S can be performed per Eqn. 6 below. To enable the distributed reassembly of a given secret S each of the repositories can execute a respective interpolating polynomial as indicated in Eqn. 6 whereby as previously mentioned any functions performed at the repositories can be based upon instructions generated by the client component 

whereby a process of serially interpolating the threshold number of shares can be conducted a contribution of a first share can be determined a contribution of a second share can be determined while seeded with the contribution of the first share etc. A contribution of a final share can be determined while seeded with the contribution of the previous share. It is to be noted that evaluation of the polynomial is being performed for x 0 thus the numerators in Eqn. 6 can simplify to a product of two negative numbers.

In a first embodiment each of the respective Lagrange interpolating polynomial formulas can be stored at each repository and can be accessed by the respective custodian located at each repository such that when a custodian calculates the Lagrange interpolating polynomial for the share stored at the repository e.g. per an instruction from the client component the Lagrange interpolating polynomial formula is readily available. In another embodiment the respective Lagrange interpolating polynomial formula can be forwarded to each repository as part of the messaging undertaken between the client component and the respective custodian as further described herein.

STEP A query Q can be initiated at the client component whereby the query Q has an index q. The query includes a term e.g. a search term . In the example presented herein the query comprises John and the system is configured to determine if a file e.g. any of files includes such term.

As previously described file d has been split amongst N repositories in accordance with a threshold T. In this example the client component is provided with information a priori indicating T for the file d. In the example presented in T 3. In the example presented in repositories 1 2 and 3 are selected hence x x and xin the subsequently described messages are related to repositories 1 2 and 3 respectively. Based upon the foregoing a first message m is generated by the client component in accordance with search criteria of the query Q e.g. does the name John appear as a first term in a file The first message m is sent to repository 1 wherein the first message can also include an instruction generated by the client component for the custodian at the repository 1 to calculate the contribution of share dto the file d. The first message mcan request that repository 1 transfer a contribution of the share dthat is stored at the repository 1 to the client component whereby the contribution of the share dis directed to the interpolation operation e.g. as performed by custodian . It is to be appreciated that a plurality of shares not shown can be stored at repository 1 whereby each share is generated from a respective file and their respective contribution to the first message mcan also be returned to the client component .

wherein the calculation operation is based on the share s generated from the file and also files when more than one share is stored at the repository 1 that is stored at the repository 1 and its respective contribution to a first word in file and also files when more than one share is stored at the repository 1 . Upon performing the calculation the custodian component can send a second message tilde over m to the client component whereby the second message can comprise tilde over m q tilde over x x x .

STEP a random nonce value v is generated by the client component to additively perturb the query Q. Further the client component can compute to include v hence 

Subsequently the client component can send a third message m to the repository 2 whereby the third message m q x x x . The vector now represents the first term of the interpolation for the first word in file d additively masked with the nonce v. As previously mentioned v is only known by the client component . The third message can also include an instruction generated by the client component for the custodian at the repository 2 to calculate the contribution of share dto the file d and further when the contribution of share dhas been determined to forward the contribution to the next repository being queried e.g. repository 3.

STEP client component further forwards the terms of the query Q additively perturbed by the same nonce v in a fourth message q . . . to repository 3. Hence if it is desired that a list of all files d whose first word matches John is obtained a 32 bit value of John is generated the nonce v is added and the resultant value is utilized as the search term in the query Q. As previously mentioned utilizing the nonce prevents the client component from revealing terms in the query Q to repository 3. Additionally if the client component wishes to obfuscate the term for which a match is being sought and ultimately found additional terms can be added to the query by the client component . The fourth message can also include an instruction generated by the client component for the custodian at the repository 3 to calculate the contribution of share dto the file d.

STEP the custodian located at repository 2 can calculate a portion of the interpolation associated with content in repository 2 such that 

As previously mentioned the values for x e.g. for the list of repositories are globally known values about the repositories. The value p x corresponds to the contribution of the share dto the first word in file d. Based on such information repository 2 can calculate . Further the custodian can transmit a fifth message m q x x x to the repository 3 e.g. in accordance with the instruction from the client component .

STEP the custodian located at repository 3 can calculate a final contribution to the interpolation per 

Further the custodian can compare entries in 3 to the one or more search term s in the fourth message q . . . received from the client component in step . A sixth message m q fid . . . fid containing identities of the matching share s is returned to the client component .

STEP The sixth message is received at the client component . In response to receiving an indication of a match from the repository 3 e.g. the final repository the client component can generate a notification that the term John was found as the first term in the file d based upon the contributions of d d out of d d . The notification can be presented on a display device not shown communicatively coupled to the client component . Further the notification can be transmitted by the client component to any device communicatively coupled to the client component whereby the notification can be an email an alert etc.

To demonstrate the above methodology the following example is presented. A secret is a combination to a safe that has been set by a person e.g. named Christine. For example the combination 854 is included in the file d. Christine requires that the file d is kept secret from any two people of their five colleagues. But Christine also wants to ensure that in an emergency any three of the five colleagues can combine their information to open Christine s safe. To do so Christine encodes the combination d 854 into N 5 shares e.g. d d and requires that a threshold of T 3 shares can be utilized to recover the secret whereby each of Christine s co workers are given a share e.g. any of d d . To enable Christine to do this a random generating polynomial of degree two can be generated since any three points e.g. based upon T 3 can uniquely identify a second order polynomial. A random generating polynomial can be 27653 such that given d 854 854 27653. 12 

Accordingly it is desired to verify that the safe combination is 854. For simplicity it is assumed that the repositories 1 n take their index as their x coordinate e.g. x . Christine s safe combination 854 is encoded as the value of the generating polynomial curve at x 0. Shares d dcan now be created by generating points along polynomial curve at positions other than 0 namely for the 5 respective shares and repositories 

By combining any three of these points e.g. any three of the five shares Christine s colleagues can solve an interpolating polynomial and recover the combination. However with only two shares there are as many polynomials as there are possible values for file d all equally likely.

A query Q can be generated at the client component such that the query Q is directed towards the three repositories 1 3 and 5 in accord with T 3 . Further a nonce can be generated by the client component e.g. v 400. The client component can further generate an index q and a search term of 854 v 854 400 1254. The client component then sends a first message m q 1 3 5 to the repository 1.

In response to receiving the first message mfrom the client component custodian located at repository 1 reviews a share s dstored at the repository 1 computes tilde over by first computing 

The custodian then sends a second message tilde over m q tilde over 2218.125 1 3 5 back to the client component .

The client component adds the nonce v 400 to acute over to obtain 2618.125 and forwards a third message m q 2218.125 1 3 5 on to repository 3. The client component sends a fourth message tilde over m q 1254 containing the nonced search term to the repository 5.

Accordingly the custodian generates and sends a fifth message mto the repository 5 whereby m q 80.625 1 3 5 .

The custodian at the repository 5 can then compare the resulting with the search term in the fourth message tilde over m provided by the client component where 1254 to determine if there is a match. In this example the custodian determines that yes . Based upon the positive affirmation the custodian sends a positive notification or result to the client component verifying the combination of contributions from shares d dmatches John to the client component . In response to receiving the notification the client component can provide indication of the positive result e.g. via a display device a data transmission etc.

The various embodiments presented herein assumes T 1 e.g. 2 repositories in the example above repositories can be compromised without a secret in the file d being identified. If repositories 1 and 3 in the example above are compromised information at the repositories 1 and 3 can be colluded to enable determination of the nonce v. However the repositories 1 and 3 do not have the contribution of repository 5 to the interpolation or the search term sent to repository 5 hence repositories 1 and 3 or the associated custodians and are unable to determine either the secret in the file d or a search term forming the query Q. Further based on the example above if an adversary has access to repository 5 and one of the other two repositories e.g. either of repository 1 or repository 3 the adversary is unable to determine the nonce as they only have one side of the insertion of the nonce.

Per the various embodiments presented herein as the threshold of the system is increased to four or more e.g. T 4 a situation can occur whereby two repositories have been compromised and hence can be utilized by an adversary to determine the nonce v and further the two compromised repositories can be colluded with a third repository to capture the final state. illustrates an example of this attack as further described below .

In situations in which it is required that an archival system can operate with more than two compromised repositories the requirement can be met to resist the previously described attack of T 4 by the client component continuing to inject nonces serially into the interpolation process. An algorithm also referred to as a generalized matching algorithm that addresses a requirement for the archival system to operate with more than two repositories compromised e.g. support T 1 compromised repositories for any T N archive for any values of T 4 is now presented.

In an embodiment the client component must add a nonce after interaction with the first repository and then after interaction with every subsequent two repositories to ensure data protection with T 1 repositories is not compromised. The algorithm detailed below assumes that the T repositories that will be used in the query are the first T repositories e.g. repositories through . It is to be noted that any contributions denoted with a tilde are those contributions for which the value of the nonce could be determined by j 1 collaborating repositories hence these contributions are also the tilded messages sent back to the client component for additional nonces.

3 Client component sends message m q x . . . x to the repository 1 e.g. to custodian at repository 1 .

As previously mentioned above two properly placed and colluding repositories can determine a nonce added by the client component . The following is a detailed discussion for such a scenario.

The generalized matching algorithm as previously presented can be utilized to address an adversary attempting to determine a nonce by utilizing two colluding repositories. To facilitate understanding of utilization of the generalized matching algorithm a first scenario is presented in where an attack is conducted without utilizing the generalized matching algorithm. Further a second scenario is presented in whereby the approach of nonce addition is presented.

With reference to if an adversary has access to two repositories on both sides of the addition of a nonce by the client component it is possible for the adversary to determine the value of the nonce. If the adversary also owns e.g. has access to a final repository over which a query Q is to be conducted it is possible for the adversary to uncover both the secret in the file d and the one or more search terms included in the query Q.

STEP The client component initiates a query Q and in response to receiving Q repository 1 returns its contribution to the client component whereby tilde over 0 .

In the event of an adversary having compromised repositories 1 2 and 4 of the example presented in the adversary knows the data stored on repository 1 p x and is able to see the incoming message mthat was sent to repository 2 where m q x x x x . The values of Lare computable as it is assumed that the adversary knows the xof all of the repositories involved in the query Q. Thus the adversary is able to determine the value of the nonce v 0 .

With the nonce v discovered the adversary is able to compute the secret in the file d by observing the message received at repository 4 from repository 3 m q x x x x such that 0 0 

Per the foregoing the methodology presented in can only support up to 2 compromised repositories. For cases where data protection is desired with more than two repositories compromised the generalized matching algorithm e.g. based upon Algorithm 1 can be utilized.

Step The client component initiates a query Q generates an index q and further identifies a number of repositories e.g. x . . . x over which to perform the query. The client component forwards a first message mto the repository 1 whereby m q x . . . x .

STEP In response to receiving the first message m at repository 1 the custodian component calculates its contribution tilde over 0 .

Upon performing the calculation the custodian component can send a second message tilde over m to the client component whereby the second message can comprise of tilde over m q tilde over x x x .

STEP in response to receiving the second message at the repository 2 the custodian component computes 0 

STEP in response to receiving the fourth message at the repository 3 the custodian component computes tilde over 0 

STEP in response to receiving the fifth message the client component computes whereby the term includes a second nonce v tilde over 

STEP Further the client component sends the nonced search term information v as a seventh message to repository 4 for matching.

STEP In response to receiving the sixth message and the nonced search term information in the seventh message at repository 4 custodian computes 0 .

The difference between the example presented in and the example presented in is that the second nonce v is not discoverable with the information provided in . Per the adversary is still able to exploit knowledge of repositories 1 and 2 in order to discover v. However there is not sufficient information for the adversary to discover the secret data or the query Q information in this scenario 0 0 19 and likewise . 20 

For the example scenario presented in the adversary is unable to recover the secret or the true value of the query with any certainty. Accordingly the information theoretic security of the file d is maintained by the addition of a second nonce e.g. v.

In an aspect the matching algorithm presented herein in enables a final repository e.g. Rep 3 of and Rep 4 of to identify which files have the same prefix e.g. which files have a first word John . To address such a scenario the client component can vary the nonce used across the values in . For example the client component can select ten nonces and randomly assign a different nonce to each entry in to inhibit the final repository from determining files with matching prefixes. Such an approach can also require additional search terms for each nonce used. Accordingly this approach has a minor possibility for false positive results. It is to be noted that such an approach is just one possible solution and the foregoing is not limited to this approach.

While the various embodiments presented herein provide strong protection s for data privacy and integrity there can be a significant practical overhead in the various data communications undertaken during operation of the various embodiments. For example the vectors for could contain share prefixes for each file in the archival system . While this is tractable for prefix matching in a generalized search case e.g. for a substring at a particular location in any of files this would effectively transfer a vector the size of the entire archive as many as T 1 times. For use cases with small amounts of critical data this could be acceptable but can be a practical limitation. Maintaining one repository locally with the client component is one approach to mitigate a portion of the communications overhead. In a 3 5 based archival system this approach could significantly reduce the network communications.

As well as prefix matching the various embodiments presented herein can be utilized for secure and resilient set membership testing without a list of items in the set being revealed. For set membership testing a set of data e.g. a list of names NA . . . NZ in a file can be split into n shares e.g. NA. . . NA which are distributed across an archive of N repositories e.g. shared across the entirety of repositories 1 6 . In an aspect each file can correspond to an item that is a member of that set e.g. a name of a patient in a hospital a name of a confidential informant etc. . In such an embodiment no single repository would ever hold the complete set but the list could easily be queried to confirm whether a given name is a member of the set. For example a client e.g. client component can perform a query Q as to whether John is a member of the set whereby the query can be performed in a manner similar to the prefix search as previously described. Accordingly a set membership can be securely verified without having to share the entire membership list with any one individual a single location or a single repository.

In addition to prefix matching the various embodiments presented herein are also applicable to reassembly e.g. serial reassembly of a specific file e.g. any of files in the archival system . Algorithm 2 below presents an embodiment to enable a file to be reassembled. In this embodiment a vector utilized to pass around data represents one or more intermediate states for the reassembly of the original file e.g. any of files as opposed to enabling determination of prefix data for each share e.g. any of d d in a repository e.g. any of repository . Accordingly in the embodiment represented by algorithm 2 the vector p x represents the sequence of data points in the share held on repository j for a given file f. Additionally a unique nonce is required for each word in a file and accordingly a nonce can now be represented as a vector v .

Algorithm 2 enables the serial reassembly of files within an archival system . It utilizes nonces known to the client component and messages between repositories to reduce the need to communicate raw share data across the archival system back to the client component . As previously mentioned setting up one repository locally can improve performance. While not impervious the approach presented in algorithm 2 provides significant difficulties for a man in the middle type attack.

As previously described the various embodiments presented herein detail prefix matching across an archive. It is to be appreciated that the methodology of prefix matching can be expanded to matching strings in any position in a file. While an overhead for such an embodiment may become burdensome for cases in which data protection is critical and there is a strong need for resilience to insider threat such overhead may be warranted. Further the various embodiments presented herein can utilize serial interpolation for file reassembly. These algorithms provide novel capabilities while maintaining information theoretic levels of data protections.

As long term digital archives become favored distributed archives can provide both the reliability and security needed. In such an archival system the data is most secure when it is left at rest in the repositories. By utilizing serial interpolation as described herein data can remain secure as it is at rest in the exemplary archival systems and methods presented herein.

The various embodiments presented above can be utilized in a plurality of scenarios. Such scenarios can include a situation whereby a doctor is visiting a hospital and desires to know if a particular patient is at the hospital. Accordingly the doctor can undergo required authentication authorization and access control AAA to enable their interaction with the archival system and further to access the client component . Upon satisfaction of any AAA requirement in force at the hospital the doctor can perform a query for any of the patients name a hospital name etc. to identify if the patient is at the hospital. The various repositories can be located at various locations e.g. data center hospitals etc. and by logging in on at the client component located at hospital X the search can be constrained such that only repositories pertaining to hospital X and its patients is searched. Based upon a patient name match being found the doctor can be informed that the patient has been admitted to the hospital.

In an aspect a technician at the hospital may want to obtain data about the patient. However the hospital may have a requirement such that no technicians can have single access to patient data and accordingly the technician has to access the client component concurrent with access by a second technician.

In another example scenario a company may be a Fortune 500 company and desires to keep its finances exposed to as few people as possible. The company has a corporate budget office which amongst other activities generates quarterly reports. However the company believes that there is at least one person in their corporate office who is also employed by a competitor. The financial data can be shared across a plurality of repositories but only people who are trusted employees can access the client component and accordingly perform queries on the financial data. Hence during ongoing operation of the company hourly daily weekly etc. budgets can be generated without exposing the current financial state of the company. The only finances that are exposed to any non trusted employees is at the end of each quarter.

In another example scenario the repositories can be a plurality of devices that are communicatively coupled together or a plurality of partitions on a shared storage device . Accordingly a person can generate a file e.g. a word processing document an image a spreadsheet etc. whereby the file can undergo splitting into a plurality of shares as previously described. The shares can be distributed across the plurality of devices and or the storage partitions. The next time the person wishes to work on the file the file can be reassembled from the plurality of shares whereby upon completing the work the latest version of the file can be once again split into a plurality of shares. Hence if one of the plurality of devices is a portable computing device e.g. a laptop computer a tablet pc etc. and the person has the portable computing device stolen or is lost the person does not have to be concerned about any shares formed from sensitive data being stored on the computing device as it is not possible for the thief or other party to reassemble the file comprising the sensitive data from the single shared stored on the computing device. The person can still reassemble the file from the other devices in the plurality of devices.

Referring now to a high level illustration of an exemplary computing device that can be used in accordance with the systems and methodologies disclosed herein is illustrated. For instance the computing device may be utilized to query a plurality of shares without having to reassemble the shares. For example computing device can operate as a client component . Further the computing device can be utilized to operate as a custodian component s e.g. any of custodians . The computing device includes at least one processor that executes instructions that are stored in a memory . The instructions may be for instance instructions for implementing functionality described as being carried out by one or more components discussed above or instructions for implementing one or more of the methods described above. The processor may access the memory by way of a system bus . In addition to storing executable instructions the memory may also store operating parameters required operating parameters and so forth.

The computing device additionally includes a data store that is accessible by the processor by way of the system bus . The data store may include executable instructions operating parameters required operating parameters etc. The computing device also includes an input interface that allows external devices to communicate with the computing device . For instance the input interface may be used to receive instructions from an external computer device from a user etc. The computing device also includes an output interface that interfaces the computing device with one or more external devices. For example the computing device may display text images etc. by way of the output interface .

Additionally while illustrated as a single system it is to be understood that the computing device may be a distributed system. Thus for instance several devices may be in communication by way of a network connection and may collectively perform tasks described as being performed by the computing device .

As used herein the terms component and system are intended to encompass computer readable data storage that is configured with computer executable instructions that cause certain functionality to be performed when executed by a processor. The computer executable instructions may include a routine a function or the like. It is also to be understood that a component or system may be localized on a single device or distributed across several devices. The terms component and system are also intended to encompass hardware configured to cause certain functionality to be performed where such hardware can include but is not limited to including Field programmable Gate Arrays FPGAs Application specific Integrated Circuits ASICs Application specific Standard Products ASSPs System on a chip systems SOCs Complex Programmable Logic Devices CPLDs etc.

Various functions described herein can be implemented in hardware software or any combination thereof. If implemented in software the functions can be stored on or transmitted over as one or more instructions or code on a computer readable medium. Computer readable media includes computer readable storage media. A computer readable storage media can be any available storage media that can be accessed by a computer. By way of example and not limitation such computer readable storage media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein include compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc BD where disks usually reproduce data magnetically and discs usually reproduce data optically with lasers. Further a propagated signal is not included within the scope of computer readable storage media. Computer readable media also includes communication media including any medium that facilitates transfer of a computer program from one place to another. A connection for instance can be a communication medium. For example if the software is transmitted from a website server or other remote source using a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared radio and microwave then the coaxial cable fiber optic cable twisted pair DSL or wireless technologies such as infrared radio and microwave are included in the definition of communication medium. Combinations of the above should also be included within the scope of computer readable media.

What has been described above includes examples of one or more embodiments. It is of course not possible to describe every conceivable modification and alteration of the above structures or methodologies for purposes of describing the aforementioned aspects but one of ordinary skill in the art can recognize that many further modifications and permutations of various aspects are possible. Accordingly the described aspects are intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the details description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

