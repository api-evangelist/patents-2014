---

title: System level memory leak detection
abstract: A method for detecting memory leaks with an administrative client begins by transmitting to all of the processes running on at least one computing device, a first command to return memory track information. The administrative client receives memory track information from each of the processes, and combines them into a first system wide memory allocation. The administrative client transmits an instruction to run a test case process, and then transmits, to each of the processes, a second command to return memory track information. The administrative client receives the second set of memory track information and combines it to generate a second system wide memory allocation. To generate a list of potential memory leaks originating from the test case process, the administrative client compares the first system wide memory allocation with the second system wide memory allocation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09558055&OS=09558055&RS=09558055
owner: Cisco Technology, Inc.
number: 09558055
owner_city: San Jose
owner_country: US
publication_date: 20140219
---
Memory leaks are caused by processes with source code which allocates a memory segment but fails to de allocate the memory segment after use. This leaves the memory segment unavailable to be accessed by the running code and reduces the amount of memory that can be used in the system. If memory leaks continue being produced without being detected eventually the process may run out of memory and crash the system. In embedded systems processes typically communicate with each other. Due to this intercommunication an operation in one process may lead to a memory leak in another process.

An administrative client begins a method for detecting memory leaks by transmitting to a plurality of processes running on at least one computing device a first command to return an indication of a memory allocation by each of the plurality of processes. The administrative client receives a first plurality of indications of memory allocation corresponding to the plurality of processes and combines them into a first system wide memory allocation. The administrative client then transmits an instruction to run a test case process on the at least one computing device and then transmits to the plurality of processes a second command to return an indication of a memory allocation. The administrative client receives the second plurality of indications of memory allocation corresponding to the plurality of processes and combining them to generate a second system wide memory allocation. To generate a list of potential memory leaks originating from the test case process the administrative client compares the first system wide memory allocation with the second system wide memory allocation.

The following description is directed to techniques for detecting memory leaks on a system wide basis. The approach described herein provides the capability to detect memory leaks for all of the processes in a system. This may help software engineers capture all of the memory leaks particularly in examples where one test case process leads to memory leaks in other processes. One example described herein involves detecting memory leaks in processes running on network line cards but any system with multiple processes running across multiple devices may benefit from the consolidated memory leak detection as described herein.

Referring to a memory leak detection system comprises an administrative client and a plurality of M computing devices A B through M. In one example the computing devices A through M may be network line cards. Line card A comprises processor A working memory A and storage memory A. Similarly line card B comprises processor B working memory B and storage memory B. Further line card M comprises processor M working memory M and storage memory M. Operating System OS A is run by processor A on line card A. OS A comprises a plurality of N processes A A through A N . Each of the processes A calls a library A for memory tracking according to techniques described hereinafter. Similarly OS B and OS M are run by processors B and M on line cards B and M. Processes B B through B N and M M through M N run on OS B and M respectively.

In one example devices A through M may be identical line cards as depicted in . Alternatively devices A through M may include varying types of computing devices including line cards embedded systems servers desktop computers laptop computers mobile cellular phones tablet computers etc. The connection between administrative client and devices A through M may be any type of network e.g. any combination of Internet intranet local area network LAN wide area network WAN wired network wireless network etc. that connects computing devices. In another example client may be connected directly to one or more of devices A through M. The administrative client may be in one form a virtual machine process running in a data center.

Referring now to an example of one process for tracking memory allocations is shown. Process invokes multiple libraries through K as well as the library for memory tracking. Each library is allocated a memory segment in memory heap of process . In one example library overwrites the typical memory allocation and de allocation function to invoke the original allocation and de allocation Application Programming Interfaces APIs as well as track the size of allocated and de allocated memory. The new memory allocation API tracks the memory allocations with an additional parameter which is a user defined tag. In one example the user defined tag specifies a memory type that may be associated with a specific part of the source code of a process. The new API library e.g. library overrides the original memory allocation and de allocation functions.

Referring now to a simplified block diagram of administrative client is shown. Client includes a processor to process instructions relevant to detecting memory leaks in the system memory to store a variety of data and software instructions e.g. instructions sent to processes in other computing devices dumped sets of memory allocations from other computing devices etc. . The administrative client device also includes a network interface unit e.g. card to communicate with other devices. The administrative client device may also include a user interface unit s in the form of a keyboard mouse and or a touchscreen user interface to allow for a user to interface with the client device. Memory may comprise read only memory ROM random access memory RAM magnetic disk storage media devices optical storage media devices flash memory devices electrical optical or other physical tangible e.g. non transitory memory storage devices. The processor is for example a microprocessor or microcontroller that executes instructions for implementing the processes described herein. Thus in general the memory may comprise one or more tangible non transitory computer readable storage media e.g. a memory device encoded with software comprising computer executable instructions and when the software is executed by the processor it is operable to perform the operations described herein.

Referring now to a diagram of the memory tracking data collected by each process is shown. All of the processes A through M N track each memory allocation and de allocation call at step . Tracking the memory calls results in an indication of the memory allocation for each process . The indication of memory allocations are dumped back to the administrative client at step . All of the individual indications are collected into a set of the memory allocations that describe the memory allocation of all of the devices A through M. In one example the new library provides the API to dump the memory indications for a specific process to a file. The memory indications may include entries in a data structure that describe a process identifier process ID the user defined memory type and the number of allocated bytes of memory. Each process A through M N listens for and or detects a predetermined Inter Process Communication IPC message that serves as a trigger to dump the memory indications .

In another example an indication is created for each allocation of memory and that indication is erased when the corresponding segment of memory is de allocated. In a further example a debugger may use the memory type entry from the list of potential memory leaks to pinpoint specific portions of source code that may have caused the memory leak.

Referring now to operations for one example of a process to detect memory leaks is shown. In step an administrative client transmits a command e.g. an IPC message to all of the processes in all of the devices. The command instructs each process to dump its tracked memory allocation information. The administrative client receives the dumped memory allocation information from each of the processes in the entire system at step . In step the administrative client collects the individual memory track information from each process into a first system wide memory allocation that may serve as a benchmark memory allocation for any further test cases to be executed. In one example the system wide memory allocation comprises a directory including all of the files dumped from each of the processes in the system.

In step the administrative client transmits an instruction to run a test case process to determine if the test case process causes any memory leaks. After running the test case at step the administrative client again transmits to all of the processes the command to dump all of the memory allocation information. The administrative client receives a second set of dumped memory allocation information at step . The second set of dumped memory allocation information is combined in step to form a second system wide memory allocation. If the test case does not need to be run again as determined in step then the administrative client compares the first and second system wide memory allocations to generate memory leak candidates.

In one example the test case may be run again e.g. to improve the accuracy of the list of memory leak candidates and the administrative client returns from step to step and transmits the instruction to run the test case again. Users may specify a number of iterations to run the test case process with the administrative client obtaining a system wide memory allocation between each successive iteration. In another example the memory indications may be stored and compared as binary data structures. Alternatively the memory indications may be stored and compared as ASCII data structures.

In some examples the commands to dump the memory indications from each process may be given from a command line interface such as debug process memory usage iteration . In this example the option iteration provides a user with the option run a test case process a number times. While running the debug process in one shell the test case process is run times in a separate shell. After each time the test case is run the debug process captures the system wide memory allocation. Increasing the number of iterations may provide a more accurate report of memory leaks at the expense of a longer process in getting the report.

Referring now to a specific example of a memory leak detection process is shown including the data results from each process step. After process starts all of the processes in the system dump their respective memory track information in step . This generates a first set of dumped memory track information. After the initial dump of memory track information the test case is run at step . After the test case is run all of the processes again dump their respective memory track information in step . This generates a second set of dumped memory track information. In step the first and second sets of dumped memory track information are compared to generate a first memory track difference set . Each entry in the first memory track difference set may be a memory leak.

In order to refine the list of potential memory leaks the test case may be run again. After the test case is run a second time at step each of the processes in the system dumps their respective memory track information at step . This generates a third set of dumped memory track information. At step the second set and third set of dumped memory track information are compared and a second set of memory track differences is generated. Each entry in the second memory track difference set may also be a memory leak. In step the first memory track difference set and the second memory track difference set are compared generating a refined set of memory leak candidates. In one example the two memory track difference sets and are compared by a logical AND operation and entries that are not present in both sets and are removed from the list of potential memory leaks.

In one example an entry on the list of potential memory leaks may not be an actual memory leak. One specific example may be found in creating a global link list. In this example for each execution of the test case a new node is allocated and added to the global link list. If the node number of the global link list reaches a predetermined maximum number and stops increasing then this is not a memory leak. However this memory allocation may be included in the list of potential memory leaks until the test case is run the predetermined number of times and the global link list stops increasing or until the source code is inspected and it is determined that the memory increase is expected.

In summary the techniques presented herein allow each process to save its memory usage information e.g. in the form of data sets of process ID memory type allocated bytes . When a user executes the memory leak detection tool an IPC message is sent to all of the processes in the system and each of the processes dumps its respective memory usage information. If the user dumps the memory usage information before and after a test case process is executed then comparison of the memory usage before and after retrieves any increase in memory allocation. The user may run the test again and get a second set of increased memory allocations. Comparing the two sets of increased memory allocations finds the entries with the same process ID and memory type and labels these entries as potential memory leaks.

In one example embodiment a method comprises transmitting to a plurality of processes running on at least one computing device a first command to return an indication of a memory allocation by each of the plurality of processes. Each of the plurality of processes is associated with a process identifier. The method further comprises receiving a first plurality of indications of memory allocation corresponding to the plurality of processes. Combining the first plurality of indications of memory allocation generates a first system wide memory allocation. The method continues with transmitting an instruction to run a test case process on the at least one computing device and transmitting to the plurality of processes a second command to return an indication of a memory allocation by each of the plurality of processes. After receiving a second plurality of indications of memory allocation corresponding to the plurality of processes the method comprises combining the second plurality of indications of memory allocation to generate a second system wide memory allocation. The method continues with comparing the first system wide memory allocation to the second system wide memory allocation to generate a list of potential memory leaks originating from the test case process.

In another example embodiment an administrative client comprises an interface configured to communicate with at least one computing device and a processor. The processor is configured to generate for transmission via the interface to a plurality of processes running on the at least one computing device a first command to return an indication of a memory allocation by each of the plurality of processes. Each of the plurality of processes is associated with a process identifier. The processor is further configured to receive through the interface a first plurality of indications of memory allocation corresponding to the plurality of processes. The processor of the administrative client combines the first plurality of indications of memory allocation to generate a first system wide memory allocation. The processor is further configured to generate for transmission via the interface an instruction to run a test case process on the at least one computing device and generating for transmission via the interface to the plurality of processes a second command to return an indication of a memory allocation by each of the plurality of processes. After the processor of the administrative client receives through the interface a second plurality of indications of memory allocation corresponding to the plurality of processes it combines the second plurality of indications of memory allocation to generate a second system wide memory allocation. The processor then compares the first system wide memory allocation to the second system wide memory allocation to generate a list of potential memory leaks originating from the test case process.

In yet another example embodiment a system comprises a plurality of computing devices and an administrative client. The administrative client is configured to transmit to a plurality of processes running on the plurality of computing devices a first command to return an indication of a memory allocation by each of the plurality of processes. Each of the plurality of processes is associated with a process identifier. The administrative client is further configured to receive a first plurality of indications of memory allocation corresponding to the plurality of processes and combines the first plurality of indications of memory allocation to generate a first system wide memory allocation. The administrative client is configured to transmit an instruction to run a test case process on at least one of the plurality of computing devices. After the test case process is run the administrative client is configured to transmit to the plurality of processes a second command to return an indication of memory allocation by each of the plurality of processes. The administrative client is then configured to receive a second plurality of indications of memory allocation corresponding to the plurality of processes and combine the second plurality of indications of memory allocation to generate a second system wide memory allocation. The administrative client is further configured to compare the first system wide allocation to the second system wide memory allocation to generate a list of potential memory leaks originating from the test case process.

The above description is intended by way of example only. Various modifications and structural changes may be made therein without departing from the scope of the concepts described herein and within the scope and range of equivalents of the claims.

