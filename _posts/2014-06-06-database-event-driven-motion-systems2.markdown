---

title: Database event driven motion systems
abstract: A data collection system for distributing data from at least one target asset to at least one software application, comprising a machine platform and a data routing system. The machine platform stores data associated with the at least one target asset. The data routing system collects data from the machine platform. The data routing system operates in a pass through mode and a data processing mode. In the pass through mode, data is passed from the at least one target asset to the at least one software application without modification. In the data processing mode, the data routing system generates modified data based on the data stored by the machine platform and sends the modified data to the at least one software application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09588510&OS=09588510&RS=09588510
owner: Automation Middleware Solutions, Inc.
number: 09588510
owner_city: Marshall
owner_country: US
publication_date: 20140606
---
This application U.S. patent application Ser. No. 14 298 567 filed Jun. 6 2014 is a continuation of U.S. patent application Ser. No. 13 232 877 filed Sep. 14 2011 now abandoned.

U.S. patent application Ser. No. 13 232 877 is a continuation of U.S. patent application Ser. No. 12 557 722 filed Sep. 11 2009 now U.S. Pat. No. 8 027 349 which issued on Sep. 27 2011.

U.S. patent application Ser. No. 12 557 722 is a continuation of U.S. patent application Ser. No. 11 583 233 filed Oct. 18 2006 now abandoned.

U.S. patent application Ser. No. 11 583 233 claims priority benefit of U.S. Provisional Patent Application Ser. No. 60 727 901 filed Oct. 18 2005.

U.S. patent application Ser. No. 11 583 233 is also a continuation in part of U.S. patent application Ser. No. 11 505 056 filed Aug. 15 2006 now abandoned.

U.S. patent application Ser. No. 11 505 056 claims priority benefit of U.S. Provisional Patent Application Ser. No. 60 708 699 filed Aug. 15 2005.

U.S. patent application Ser. No. 11 583 233 is also a continuation in part of U.S. patent application Ser. No. 10 844 025 filed May 12 2004 now abandoned.

U.S. patent application Ser. No. 10 844 025 claims priority benefit of U.S. Provisional Patent Application Ser. No. 60 506 104 filed Sep. 25 2003.

U.S. patent application Ser. No. 11 505 056 is also a continuation in part of U.S. patent application Ser. No. 10 991 905 filed Nov. 17 2004 now abandoned.

U.S. patent application Ser. No. 10 991 905 claims priority benefit of U.S. Provisional Patent Application Ser. No. 60 520 918 filed Nov. 17 2003.

The present invention relates to computer systems for collecting data from one or more disparate data sources and distributing the collected data to one or more disparate data destinations and distributing software commands from one or more command sources to one or more command targets.

The present invention is used in the context of collecting and distributing data and control commands in the context of motion control machines or devices. The present application uses the term routing to refer to the process of both collecting data from data origins and distributing data to data destinations. The terms data and data items are used herein to refer to numeric binary or string data generated in an analog or digital format. Data is typically generated by machines devices or the like forming part of a larger working environment. The term machine as used herein refers to a physical asset used to perform a predetermined task. The term device is typically applied to a machine with a relatively small footprint.

The data origin or origins thus may be formed by any machine or device mobile or not that stores data and which is either directly controlled by humans through a user interface or automatically controlled via a computer based system. However the present invention is of particular significance in the context of a working environment defined by a motion control system and that application of the present invention will be described in detail below. The present invention may have broader application to other working environments however and the scope of the present invention should be determined by the claims appended hereto and not the following detailed description.

A motion control system typically comprises a plurality of motion control machines or devices each programmed to perform an individual task. The motion control system is configured to coordinate the individual tasks so that the motion control system itself performs a combined task. In the context of motion control systems control commands are transmitted to motion control devices such as computer numeric control CNC systems general motion control GMC automation systems and hardware independent data engines for motion control systems. The term command target will be used to refer to any destination motion control device or machine or any location on device or machine that can carry out a command using command data as described herein. In some situations these control commands come from a variety of sources which will be referred to herein as command sources.

Each motion control machine or device comprises a controller that generates and or stores data indicative of the state of the machine or device at a particular point in time. Typically some or all of this data changes because the state of the machine changes as the machine performs its individual task.

The data generated and or stored by the motion control machines and or devices of a motion control system can be used to optimize the performance of one or more of the individual machines as well as the entire motion control system. The data destinations where the data is sent can thus take any one or more of a number of forms including a database system a plant floor process management system software used to optimize overall production flow other software systems and or another data routing system as described herein.

The collection and distribution of the data and control commands associated with individual motion control machines is however complicated by several factors. The sheer volume of data can overwhelm the ability of the data destination to store and or process the data collected. In addition the data origins and data destination may employ different unique or proprietary hardware and software systems that utilize different data acquisition commands data formats and data transmission protocols.

The need thus exists for data routing systems and methods that organize the distribution of control commands form a variety of types of command sources to a variety of types of command targets facilitate the collection of data from diverse data origins and facilitate the subsequent distribution of data to diverse data destinations.

The present invention may be embodied as a data collection system for distributing data from at least one target asset to at least one software application comprising a machine platform and a data routing system. The machine platform stores data associated with the at least one target asset. The data routing system collects data from the machine platform. The data routing system operates in a pass through mode and a data processing mode. In the pass through mode data is passed from the at least one target asset to the at least one software application without modification. In the data processing mode the data routing system generates modified data based on the data stored by the machine platform and sends the modified data to the at least one software application.

Referring initially to of the drawing depicted therein is a data routing system constructed in accordance with and embodying the principles of the present invention. The data routing system is used to route data or data items collected from data origins to one or more data destinations .

As described above the terms data and data items will be used herein to refer to numeric binary or string data values collected in an analog or digital format from a data origin . Examples of data types that represent data or data items as defined herein include ADDRESS ARRAY BIT BYTE WORD DWORD LONG REAL DOUBLE FLOAT BINARY BLOB STRUCTURE STRING and ASCII STRING.

The data origins are machines devices or the like forming part of a larger working environment. The working environment is not a part of the present invention and thus will not be described herein beyond what is necessary for a complete understanding of the invention. The terms machine as used herein refers to a physical asset used to perform a predetermined task. The term device is typically applied to a machine with a relatively small footprint.

Examples of machines as defined herein include a CNC mill used to shape metal a pick n place machine used to position parts on a circuit board a robotic machine used to perform surgery a medical data input device i.e. blood glucose meter asthma meter etc a gaming device a robotic toy an animatronics figure a robotic machine used to deliver goods to a warehouse or to people an automobile a truck or farm vehicle a boat or ship an airplane a jet a helicopter a spacecraft and or a hardware or software based control system within a personal computer or even just a persona

I computer or hand held computer itself. The data origin or origins thus may be formed by any machine or device mobile or not that stores data and which is either directly controlled by humans through a user interface or automatically controlled via a computer based system.

As shown in the data collected by the data routing system is delivered to one or more data destinations . The data destinations can take on many forms and serve many functions but a primary function of the data destinations is to use the data collected from the machines in the working environment to optimize operation of the individual machines and the overall working environment.

The example data routing system is a software system that comprises a data input module group an optional data cache module group and a data output module group . The term module as used herein refers to a binary block of computer logic that contains functions objects components ActiveX components .NET source HTML XML and or other computer code that can be executed in real time or in script form. Several examples of a module include an executable EXE a dynamic link library DLL an OLE component or set of components housed within a DLL or EXE an ActiveX Control an HTML or XML based Control a VB script source file a Java Serverlet Java Control Java Object .NET Package etc.

The data input module group data cache module group and data output module group typically run on a processor forming part of a computer system but may be configured to operate across several discrete processors forming part of one or more computer systems.

The data routing system operates basically as follows. The data input module group communicates with one or more data origins to obtain data indicative of a state or condition of the machine or device forming each of the data origins . If used the data cache module group temporarily or persistently stores the data collected by the data input module group . The data output module group determines the conditions under which data collected by the data input module group stored in the data cache module group is sent to one or more of the data destinations . The data output module group optionally also determines the format in which data is sent to the data destination and or the method of transporting the data to the data destination .

The example data input module group comprises a data collection component and one or more data source components . The term component as used herein refers to a logical organization of computer commands designed to perform an operation or set of operations. Examples of components include OLE components ActiveX controls HTML or XML based controls HTML or XML based objects .NET objects C objects C function set Visual Basic objects and the like. A component may operate on a single processor or may be distributed across a plurality of processors.

The data collection component associates all of the data collected with the data origins from which the data was collected. The data collection component may be connected directly to one or more of the data origins or may be connected to one or more of the data origins through the data source components as shown. If the data collection component is connected directly to a data origin the data collection component and the data origin must be pre configured to work with each other and the data collection component is considered data origin independent whereas the data source component is considered data origin dependent. However if the data collection component communicates directly with a data origin it then becomes data origin dependent.

Preferably however one or more data source components are provided to allow the data collection component to operate in a data origin independent manner. In this case the example data source components are each associated with one or more of the data origins . The data source components collect data from a particular data origin or class of data origins and pass this data to the data collection component in a predetermined format. The data source components may run entirely on the same processor or processors as the data routing system entirely on a processor or processors associated with the data origin or on processors associated with both the data routing system and the data origin . Although optional the use of the data source components is preferred to isolate the data collection component from the operational details of each of the data origins .

The data input module group may collect data from the data origins by one or more of a number of methods. For example the data source components and or data collection component may read register values on the machine or device read shared memory provided by the machine or device send commands to the machine or device for which a data response is given containing the data requested read variables provided by the machine or device read and write to variables in a sequence necessary to produce data values query data using a proprietary or standard data protocol call a function provided by the machine or device build and send a command based on a protocol used to communicate with the machine or device for which a data response is provided by the machine or device from which the data is extracted and or the like.

The optional data cache module group comprises a data store component and at least one data cache . The data collection component passes data to the data store component the data store component stores this data in one or more of the data caches . The data caches may be temporary or volatile memory devices such as RAM or may be permanent or persistent memory such as a hard drive or database system. The data store component further retrieves data from the appropriate data cache as necessary. If the data cache module is not used data collected by the data collection component is passed directly to the data output module group in real time.

The data output module comprises a data output component . As mentioned the data output component may receive data directly from the data collection component . However if the data cache module is used the data output component may direct the data store component to read data stored in one or more of the data caches and transfer the stored data to the data output component .

The data output module group further comprises one or more data transport components . Each of the data transport components defines or is associated with a method or system of transporting data from the data output component to one or more of the data destinations . The data output component selects an appropriate one of the data transport components for each data element based on the data destination to which the data element is to be sent.

Optionally the data output module group further comprises a data formatter component . The data formatter component contains logic templates or the like for arranging data elements in a format appropriate for one or more of the data destinations . The data formatter component allows the data destinations to be implemented in a machine or device independent manner by obviating the need for the data destinations to process data elements in the format generated by the data origins .

The data output module group further optionally comprises an inference engine component . If used the inference engine component helps the data output component to determine the data destination or destinations where each data element is set. The inference engine component may further assist the data output component to make the determination of which data is to be output if any and or which data transport component to use and or whether the data formatter component is to be used.

The data routing system of the present invention thus collects data from one or more data origins and routes this data to one or more data destinations . The use of the data routing system allows the data destination or destinations to operate independent of the implementation details of the data origin or origins . In addition the data routing system can be configured to be independent of the data destination through the use of the data transport components and data formatter components .

Turning now to of the drawing depicted therein is a data routing system of the present invention. The example data routing system operates in the same basic manner as the data routing system described above but is optimized to operate in a working environment defined by a motion control system.

The example motion system as defined in U.S. Pat. No. 5 691 897 but other motion systems may be used instead or in addition. As will be described in further detail below the motion system defines or is associated with one or more application programming interfaces. The motion system is not per se part of the present invention and will not be described herein beyond what is necessary for a complete understanding of the present invention.

The data destinations may use the data delivered by the data routing system for a variety of purposes. A primary function of the data destinations is to optimize and or monitor the operation of the machines and or devices forming the motion control system that the motion services or other software used by the data sources communicate with. The data destinations can thus take any one or more of a number of forms including a database system a plant floor process management system software used to optimize overall production flow or other software systems and or another data routing system as described herein.

The example data routing system is connected to the data destination through a network . The network is a combination of hardware and software architectures that forms a link between two or more computer systems. Examples of network architectures include a packet based network a streaming based network broadcast based network or peer to peer based network. Examples of networks that may be used as the network include a TCP IP network the Internet an Intranet a wireless network using WiFi a wireless network using radio waves and or other light based signals and the like.

The software components making up the example data routing system may be organized into three module groups a data input module group a data cache module group and a data output module group . The data input module group data cache module group and data output module group typically run on a processor forming part of a computer system but may be configured to operate across several discrete processors forming part of one or more computer systems connected by a computer network.

The data input module group comprises a data collection component and a plurality of data source components and . The data cache module group comprises a data store component and one or more data cache components . The data output module group comprises a data output component one or more data transport components a data formatter component and an inference engine component .

The data collection component is responsible for collecting data from the machine asset and routing all data collected to the data cache module group . The data collection component is responsible for managing one or more data source components for which data is collected and route the data collected to the data cache module group .

The data source components and communicate with the motion system . Each data source communicates with the motion system using whatever means are available including to the use of application programming interfaces API and associated with the motion system using API provided by a motion system vendor or using network or other communication protocols. The example data source component is configured to receive data from the API s and while the example data source component is configured to receive data from the API

The example data collection component manages one or more data source components and is responsible for routing the data collected to the data store component of the data cache module . Optionally each data collection component may communicate directly to the motion system without the need for an intermediary data source component . However the use of the data source component allows for code reuse as the data collection component may then implement all common functionality thus making each data source component extremely thin and easy to build and maintain. In addition the use of each data source components allows the data collection component itself to be independent of each data origin with which each data source component communicates to collect data.

Each data source component is responsible for mapping the data collected from the data source i.e. XMC API XMC CNC API Protocol Server or proprietary data source into the format expected by the data collection component and ultimately the data store component . The main goal of the data source components is to provide a consistent interface to the data origin thereby freeing the client from the details of the data origin and allowing all data source components to act and operate in the same manner from the perspective of the data collection component .

The data cache module group caches the data received so that it may later be analyzed or otherwise processed. In particular the data store component manages one or more data caches and is responsible for storing all data received and giving access to all data stored. Optionally each data store component could cache all data received directly without the need for an intermediary data cache . However the use of the data cache or caches allows for code reuse and also allows the data store component to remain independent of any caching technologies used by each data cache component . The data store component may then implement all common functionality thus making each data cache module also extremely thin and easy to build and maintain.

The terms primary data cache and secondary data cache may be used to refer to one or more of the data caches depending upon whether certain features of the data cache module are implemented and or used as will be discussed in detail below. The suffix a is used in to designate a primary data cache and the suffix b is used to designate a secondary data cache.

Each data cache stores data in a data target such as a database on a hard drive RAM memory or another persistent or volatile storage medium. The term data target is used herein to refer to any device or machine or location on a device or machine that can produce data as defined herein. The main purpose of the data caches is to provide a consistent interface to the data storage medium used so that the caches appear to be the same to the user thus freeing the client of any details handling various caching mechanisms.

The data output module group is responsible for sending the data collected by the data input module group and or stored by the data cache module group to the data destination . The data output component manages the other components forming the data output module namely the data transport components the data formatter component and the inference engine component .

More specifically the data output component is responsible for sending data to one or more data destinations . As generally described above the data destination may be an enterprise data management system an artificial intelligence system a plant floor process management system software used to optimize overall production flow another data routing system such as the systems and described herein and or other software systems used to optimize and or monitor how the overall factory operates based on how each machine making up the factory runs.

The inference engine component is responsible for mapping the data elements received from the data input module group or data cache module group through the data output component to the data destinations to which the data elements are to be sent. The data transport component defines which data elements are to be sent to which data destination . When performing this mapping the inference engine component also optionally provides a set of rules and or other criteria that are used to determine whether or not each output defined by the data transport component should fire . For example the inference engine component may use one or more of the following logic systems artificial intelligence systems fuzzy logic algorithms neural network pattern matching genetic algorithms expert system logic and or other computer based decision making and or pattern matching based systems to determine when a given set of one or more data elements should be sent out. In the simplest case an identity transform may be used which causes all data inputs received to be sent out as matching data outputs.

The data formatter component is used to format all or portions of the data set to be transported to the data destinations . For example the data formatter component may be used to format data output by the inference engine component into a certain XML schema or other proprietary data format.

The data transport component is responsible for sending the data to the ultimate data destination including an enterprise database an enterprise software system or even another data routing system such as the data routing system .

Referring still to also depicted therein is a data manager that allows the user to manage operation of the data routing system . The data manager controls access to property pages exposed or generated by user interface components associated with the components and . Property pages may also be exposed or generated by user interface components associated with the components and . In particular the example data routing system comprises data collector property pages data store property pages data output property pages data transport property pages data formatter property pages and inference engine property pages . As will be described in further detail below the property pages and allow the user to initialize configure and control the components and respectively.

In the following discussion and in the drawings the property pages and also refer to the user interface components associated with these property pages. The property pages and and other interface elements are separated from the components and in the system to optimize the overall system flexibility and facilitate evolution toward new and future user interface technologies such as HTML based web user interface SOAP XML based interfaces Microsoft .NET based interfaces etc. Optionally however the components and could directly expose property pages and other user interface elements.

Referring now to the interactions of the components and property pages forming the data input module group data cache module group and data output module group will now be described in further detail in the various scenarios required to implement the functions of the example data routing system .

Before using the data routing system the system must first be initialized. During initialization all components are started and configured with their initial settings. Initializing the system involves configuring the data routing system so that it knows what data to collect where to collect it from how to process the data collected and where to send the processed data. Once initialized the system is ready to begin collecting storing and processing machine and or device data.

The initialization process includes to levels. First the overall data routing system must be configured by connecting one or more data collection components data and one or more data output components to the data store component . Once connected the components making up each of the data input module data output module and data cache module groups must next be configured.

The data manager of the data routing system next uses the data store property pages paired with the data store component . The data store property pages query the data store component for all entries in the data output module group category or optionally queries for each entry directly using the OLE Component Categories and displays each entry visually in the property page .

Next after the user selects which data output module or systems to activate the list of active data output components associated with the selected data output module or systems is sent back to the data store component so that it may use the active components. The data store component could optionally query a separate configuration component used to select the active data output modules to use later when processing data to be output. Additionally the activation of each active component may optionally be activated programmatically instead of by the user.

During its initialization the data store component creates an instance of each activated data output component so that the data store component can send data update events to each upon receiving new cache data.

Similar to the configuration of the data output module group the data store property pages query the data input module group for a list of supported data collection components . Optionally the data store component may query the data collection components of the data input module group and display each these data collection components visually so that the user can activate all components that are appropriate for collecting data.

Once selected visually by the user the active list of one or more data collection components is sent to the data store component . Optionally the data store component could query a separate configuration component used to select the active data output modules to use later when processing data to be output. Additionally the activation of each component may optionally be activated programmatically instead of by the user.

During initialization the data store component creates an instance of each active data collection component .

Once the main components data store component data collection component and data output component of the data output module are configured the user or configuration program must configure the components used by each of the systems and . The main configuration task for the data collection component is that of selecting the data source components and the data items supplied by each from which data is to be collected. The process of configuring the components used by the systems and will now be described with reference to .

The following steps take place when configuring the data collection component and related components.

Second the data collector property pages are used to configure the data collection component . Optionally all configuration may be done programmatically by another software module.

Each of the data collector property pages queries the Data Source OLE Category of components to see what data source components are available. Optionally the data collection component may be queried for the list of all data source components available.

A visual list of available data source components is next constructed thus allowing the user to select which data source component or components to use when collecting data. Optionally the data collection component could directly talk to the data source components however such direct communication would reduce code reuse as the data collection component allows each data source component to be very thin making these components easy to build and maintain.

Finally after the user selects the data source components to use a list of active data source components is passed to the data collection component which then creates an instance of each selected component.

Optionally each data source component may use an associated property page not shown that allows the user to visually or software to programmatically configure and select the data inputs from which data is to be collected by each data source component . Each data collector component may also define a set of data inputs that the user may configure and select however this it not optimal as the data source components allow each data collector component to remain independent of how each data origin actually works i.e. the data items they provide and how the data for each data item is actually collected.

Referring now to the following steps take place when configuring the data cache module group which includes the data store component thereof. Configuring the data store component requires the selecting of the data cache to use. When caching data there are three main methods that may be employed 1 cache all data to memory only 2 cache all data to a persistent storage such as a database or 3 a mixture where data is initially cached to memory and then rolled over into the persistent store at certain intervals or after a specified amount of data has been collected. All three models are utilized by the data cache module group of the data routing system where only one method is necessary to build a picture of the overall state of the data origin at a given moment in time.

In a first step shown in the data manager of the data routing system is used to configure the data store component and associated components using the embedded data store property page . As described above the data store component can be configured to implement all user aspects that it needed to edit and otherwise allow the user interact with the data and configuration managed by the component. However separating the user interface from the component in a parallel component has several advantages that allow for easily adopting future user interface based technologies such as HTML Windows .NET and thin client. For these reasons the user interface has optionally been separated from the main logic making up the data store component . As generally described above this same design organization is used throughout the entire system by all components having an associated property page.

The data store property page component queries the data store component for the list of data cache components that are available and displays the list visually. The list of available components may optionally be provided programmatically by a separate component used for configuration. As an additional option the data store property page may directly query the Cache Category of components in the OLE Component Category.

From the data store property page the user visually selects the specific data cache components to use and the specific caching strategy to employ single caching or roll over where data from one cache is rolled over to another cache based on certain criteria such as an interval of time or a data cache data threshold being met . The selected data cache components and strategy selected by the user are transferred to the data store component which then stores the settings.

Each data output component and associated components act as a data output pipeline where data follows a set of steps that determines what data will be output what format that data will be output in and where the data will be sent. Referring now to of the drawing depicted therein are the steps that take place when configuring the data output component and its related components.

First the data manager is used to configure the various aspects of the data output component and its associated components.

When configuring the data output component the data output property page parallel component acquires the list of inference engine components data formatter components and data transport components that are available. Once the list of data transport data formatter and inference engine components and is acquired a visual display of the list is created on the data output property page so that the user can select one or more of the components and from the list as appropriate for their application.

To obtain this list of components the data output property page may either query the data output component or directly query the OLE Category for each of the data transport component data formatter component and inference engine component . If the data output component is queried for the list of available components in each category the data output component in turn may then internally query a pre configured list or the OLE components falling into each respective OLE Category for the data transport component data formatter component and inference engine component .

After the user selects one or more data transport components one or more data formatter components and one or more inference engine components the list of components to activate is sent to the data output component which stores the component information as its active components and then creates an instance of each component.

Next each data transport component is queried for its list of supported outputs. The list of supported data outputs is then passed to the inference engine component or components selected.

Next the data output component queries the data store component for its list of supported data items usually stored in the data cache components and previously selected when configuring the data collection component . The list of supported input data items is then passed to the inference engine component or components selected.

When the inference engine component or components have both the inputs and outputs available the user may optionally configure rules or other criteria used to determine when each output is fired based on the input data received. As examples one or more of a set of Fuzzy Logic rules a previously trained Neural Network pattern a Genetic Algorithm fitness Expert System logic or other custom logic may be used to determine when certain outputs are sent through the data output pipeline to the data destination.

In addition the data formatter component or components may also be configured to output data in data formats supported by each data destination . For example a data formatter component may be used to output data items received in a certain proprietary schema. However the data formatter component would need to be configured so that it would know how to match the data items received to the proprietary schema. This step in the configuration process would allow the user or another software program to make this configuration.

And finally the data transport component or components would need to be configured so that they could properly send data received to the end data targets that it supported. For example a data transport component configured to use TCP IP may need to have target TCP IP addresses configured or TCP IP ports configured telling the component where to send the data.

Once initialized the data routing system is ready to start collecting data and storing all data collected as previously configured. depict the interactions that take place when collecting data.

First each data source component either polls for data or receives previously configured events from its data origination. For example when using the motion system or a Protocol Server as the data origin events may be received telling the data source component that new data is available.

Upon receiving a data update event the data source component fires an event to its respective parent data collection component .

Upon receiving its event the data collection component then fires an event to the data store component .

Upon receiving each data update event the data store component uses the active caching component or components to store the data. Optionally the data cache module may employ a roll over strategy in which data received is passed to one or more data cache modules after a certain criteria is met such as in interval of time passing or a data caching threshold being met.

After caching the data the data store component fires a data update event to any data output component or components connected to the data store system .

Upon receiving the data update event the data output component may optionally query the data store component for more data if needed to gain a full description of the current state of the machines forming the motion system .

All data input information is then passed to the inference engine component for processing. Upon receiving the data the inference engine component runs its preconfigured rule set against the data set received and produces the output if any that is eligible to be sent to the data destinations . If the inference engine component employs a dynamic model of the data its internal model may alter itself based on the input data received. For example an inference engine component that uses a neural network may learn from the data by changing the neural network s weights based on the data input values received.

If data is eligible to be output and a data formatter component is used the output data received from the inference engine component is then sent to the data formatter component . Upon receiving the data the data formatter component transforms the data received into the supported output data format and passes the new output data back to the data output component .

The formatted data is then passed to the data transport component or components to be transported or sent to the data destinations . If a data formatter component is not used the raw data format output from the inference engine component is used and passed directly to any active data transport component . Upon receiving the output data the active data transport component or components send the data to their respective data destinations . For example a TCP IP transport would packetize the data into TCP IP packets and send the data stream to a preconfigured TCP IP address port. Alternatively a wireless transport may broadcast the data out on a pre configured frequency.

Referring now to of the drawing depicted therein is a relationship among the interface windows and dialogs that form the property pages used to configure the example data routing system . The data manager presents to the user a main window that is used to access the data property pages and used to configure all settings of the data collection component data store component and data output component forming up the system .

The example main window presented by the data manager to configure each of the main components and is shown in . In particular the main page of the data manager acts as a control panel that allows the user to configure and monitor how data flows from each data source to the eventual data destination .

Each of the user interface elements of the main page on the data manager will now be described with reference to .

A Configure button allows the user to configure the overall system by building up the overall data transfer pipeline. This option is only available when running the application as an Administrator on the system.

A Start button starts monitoring the data source components and feeds the data received through the system .

A Stop button stops monitoring the data source components and shuts down the entire monitoring process.

A Close button closes the monitoring application window but does not close the application. Since the application runs as a system tray application you must exit the application by right clicking on the system tray icon.

A Status window visually shows the overall configuration and status of the system including all nodes making up the data input module data store system and data output module .

The following sections describe how to build and configure the overall system using examples of the various property pages and .

Referring initially to depicted therein is a configuration dialog window that is associated with the data manager . The configuration dialog window allows a user to build the overall data routing system . The user interface elements making up the configuration dialog window are as follows.

An Add Data Collector . . . button displays a dialog containing a list of all data collection components available to the system. Once selected the selected data collection components are added to the system . The data collection components are connected to the data store component so that data events are sent to the data store component each time data items are received by each of the data collection components from their respective various data source components .

An Add Data Output . . . button displays a dialog containing a list of all data output modules available to the system. Once selected the data output modules are added to the system. Each data output module manages a data pipeline that may involve inference rules or other decision making technology that tell when to fire each data output.

A Delete button removes a module from the list of components making up the overall data routing system .

A Load button loads the components of a previously saved data routing system from a persistent storage medium such as a file or database.

A Save button saves the current data routing system to a persistent storage medium such as a file or database.

A Node control contains the current modules making up the data routing system including data collection components data store components and data output components .

A Settings property page displays a property page corresponding to the currently selected node in the node list. The property page allows the user to configure the settings specific to the node selected.

Examples of interface elements that may be used to implement the property pages and as well as other related property pages will now be described with reference to . The Delete Load Save and Close interface elements depicted in apply to the Node Control on the left part of each figure not shown and will not be described in detail below.

An example of the data collector property page is depicted in of the drawing. The data collector property page allows a user to configure the components such as the data collection components and or data source components of the data input module group .

A Data Sources list box contains a list of all data source components available to the system. The list of available data source components is acquired by either directly enumerating the Data Source OLE Category of components or by querying the data collection component for all data source components that it knows about.

A Select button adds the currently selected item in the list of data source components to the currently selected data output module in the main node list.

A Target Scan Rate edit field allows the user to input a global scan rate that applies to all data source components that may be controlled using a global scan rate.

A data source property page is depicted in . The data source property page allows the user to select the data items made available by each data source component . The selected data items are then fed into the data store component and eventually on into the selected inference engine component . The following user interface elements make up the data source property page .

A Data Items list box contains a list of all data items made available by each data source component . The user must enable the data items that they want to monitor in their system. The list of available data items is acquired by browsing a particular data source component .

A Scan Rate edit box allows the user to enter the scan rate to use for this specific data source which may be different from the global scan rate . If no scan rate is entered the default global scan rate is used when appropriate.

A data store property page depicted in is used to configure the data store component by selecting and configuring the data cache or caches used and the specific caching strategies for each. The following user interface elements make up the data store property page .

A Data Caches list box contains a list of all data caches available to the system . The list of available data caches may be acquired either by directly enumerating the data cache OLE Category of components or by querying the data store component for a list of active data caches .

A Select button adds the currently selected item in the Data Caches list box to the currently selected data store component in the master node list.

Referring now to depicted therein is a data cache property page that allows the user to configure the specific caching strategy to be used by each data cache . The following user interface elements make up the data cache property page .

An Enable data roll over check box allows the user to enable disable data roll over. When enabled data placed in a particular data cache can roll over into another or secondary data cache upon meeting certain criteria specified by other of the user interface elements forming the data cache property page .

An After reaching cache data threshold of radio button if selected determines that roll over occurs when a certain number of bytes are cached in the primary data cache assuming that data cache roll over is also enabled by check box . A caching threshold data field allows the user to specify the data cache threshold. After reaching the roll over threshold level all data currently in the primary data cache is copied to the secondary data cache

An After time interval of radio button when selected determines that roll over occurs at specifically set time intervals again assuming that data cache roll over is enabled by check box . A time interval data field allows the user to specify the duration of the time interval. Upon the expiration of each time interval all data in the primary data cache is automatically copied over to the secondary data cache and then removed from the primary cache

A Roll over to list box contains a list of data caches that can be used as secondary caches . The primary cache rolls data over to the secondary cache selected by pressing a Select button

Referring now to the data output property page is depicted therein in further detail. The data output property page is used to configure the data output module by selecting the data transport components data formatter component and inference engine component that are to make up the data output pipeline. The following user interface elements make up the data output property page .

An Interface Engines list box contains a list of all inference engine component or components that are available to the system . A first Select button allows one or more of the inference engine components to be selected. As generally described above each inference engine component is responsible for mapping input values to output values and determining when each data element should actually be sent to the data destination .

A Data Formatters list box contains a list of all data formatter components that are available to the system . A second Select button allows one or more of the data formatter components to be selected. Each data formatter component is responsible for transforming data input into another data format that is output as output data.

A Data Transports list box contains a list of all data transport components that are available to the system . A third Select button allows one or more of the data transport components to be selected. Each data transport component is responsible for sending the data received to the ultimate data destination such as an enterprise database analysis system another data routing system or the like.

The inference engine property page will now be described in further detail with reference to . The inference engine property page is used to configure the settings defining how the inference engine component actually works. The inference engine component maps inputs received to expected outputs defined by the data transport component . When mapping inputs to outputs the inference engine component optionally uses decision logic to determine whether or not each output should fire i.e. be sent on to one or more data transport component based on the inputs received. The user interface elements making up the inference engine property page are as follows.

An Input Data Items list box contains a list of all data inputs received from the data input module via the data store component . An Output Data Items list box contains a list of all data outputs received from the data output module via the data transport component . A Rule Map list box contains a list of rules that define how to map the received data inputs to the outputs.

In this sample inference engine component the user drags items from the Input Data Items list box into the inputs making up the rule map as listed in the Rule Map list box . The rule map associated with each of the items in the Input Data Items list box defines when to fire output to each defined output.

An example data formatter property page is depicted in . The data formatter property page allows the user to configure how the final data output is actually formatted. For example the example property page depicted in illustrate how to map data outputs into an XML schema. The following user interface elements make up the data formatter property page .

An XML Schema Map control contains an editable XML Schema that allows a user to drag an output data item into different portions of the schema essentially linking the data item to that portion of the XML schema. When linked the final XML data file is built by using the XML schema and then placing data from each output data item into the slots where they are linked into the XML schema.

An Output Data Items List list box contains a list of all data outputs available as defined by the data output module via the data transport component or components .

Depicted in is an example of a data transport property page . The data transport property page allows the user to configure the specific settings of each data transport component used to communicate with the data destination or destinations . The example property page depicted in is an example property page for a data transport component that communicates across a TCP IP based wire based or wireless network. The data transport property page employs the following user interface elements.

A Target TCP IP Address edit field allows the user to enter the target TCP IP address of the machine or machines forming destinations where data is to be sent.

A Target TCP IP Port edit field allows the user to specify a set of one or more TCP IP ports to use on the target TCP IP address.

A Use UDB Broadcasting radio button directs the transport to broadcast the output data using the UDP broadcasting protocol and ignore the target TCP IP address as data will be sent to all machines forming data destinations on the network .

A Use Peer to Peer Messaging radio button directs the transport to use a peer to peer messaging protocol such as the one used with Windows Instant Messenger where data is sent immediately to the target machine forming the data destination and may optionally be displayed in an Instant Messenger viewing application such as Windows Messenger.

A Use Data Streaming radio button directs the transport to use a data streaming technology where the data outputs are streamed to the target s in a manner similar to that of a streaming music or video source. Optionally the data outputs may also be interleaved into an existing music video or other data streaming data source.

A Use Virtual Private Networking Tunneling radio button directs the transport to use a tunneling technology where the data packets making up the output data are embedded within another packet type optionally encrypted and secured and then sent to the target over another protocol such as HTTP or in this case the PPTP or L2TP protocol. SOAP or XML messaging is another manner of tunneling where the data is placed within a SOAP or XML envelope and then sent over to the output target using the SOAP or other XML messaging protocol.

A Use SMTP E Mail Format radio button directs the transport to package the output data sets into an e mail format and sends it to the target. Further configuration may be required to actually setup a specific e mail address for the recipient.

A Use SNMP Format radio button directs the transport to use the SNMP transport to communicate with the output target.

An Enable Data Encryption check box enables data encryption such that the data is encrypted before transmission. A Use Kerberos Security check box enables Kerberos security. A Use 128 bit Encryption check box enables 128 bit encryption for the output data packets.

An Enable Transmission Timeout check box enables transmission time out on each communication with the target. When enabled the sender only waits for an amount of time specified in a data field for a response from the data destination after which response data received from the target is ignored.

The example data routing system is a modular system made up of a set of components as generally described above. In this case each component is based on a component technology such as OLE COM technology defined by Microsoft Corporation.

Optionally each component uses a separate parallel ActiveX component to implement all user interface aspects of the main component also as generally described above. Each ActiveX component may be implemented either within the main component module or separately in its own module. Bundling each object within one module is not required as they may be located at any location i.e. across a network and so forth but doing so may optimize all communication between modules. How and where components are implemented is more of a logistical decision because once components are built and deployed to the field it is difficult to update a single component if all components are implemented within a single DLL or EXE module.

The IXMCDirect interface depicted in is used for most communications between components of the data routing system . The IXMCDirect interface is made up of the following functions which are specified in standard OLE COM IDL format.

More detailed descriptions of each of the methods implemented by objects implementing the example IXMCDirect interface are described below.

The IXMCDirect GetProperty method is used to query the property corresponding to the property name pszPropName . Each component defines the properties that it supports. The following table summarizes the GetProperty method implemented by the example IXMCDirect interface 

The IXMCDirect SetProperty method is used to set a property in the component corresponding to the pszPropName property. For the set of properties supported by the component see the specific component description. The following table summarizes the SetProperty method implemented by the example IXMCDirect interface 

The IXMCDirect InvokeMethod method is used to call a specific method implemented by the component. For more information on the methods supported see the description of the specific component. The following table summarizes the InvokeMethod method implemented by the example IXMCDirect interface 

This methods supported by each component making up the system will now be described. Initially the general methods supported by the majority of the components forming the system will be first be described the methods supported by each individual component will then be discussed.

The XMC DE BROWSE GET COUNT general method returns the number of data items in the browse set supported by the component and is described in the following table.

The XMC DE BROWSE GET ITEMS general method returns the number of data items in the browse set supported by the component and is described in the following table 

The XMC DE SYSTEM CONNECT CMPNT general method is used to connect one server to another so that they may interact with one another and is described in the following table 

The XMC DE SYSTEM DISCONNECT CMPNT general method is used to disconnect one server from another so that they stop interacting with one another and is described in the following table 

The XMC DE DATA PROCESS general method is called by a client to process data where a data set is input processed in some way by the server and then the resulting data is returned as output. The XMC DE DATA PROCESS method is described in the following table 

The XMC DE DATA PROCESS CONFIGURE general method is used to configure what type of data is returned when processing a given data item. For example in the server may be configured to return the minimal amount of data on each read i.e. just the data item value or the server may be requested to return more substantial data. The XMC DE DATA PROCESS CONFIGURE method is described in the following table 

The XMC DE DATA READ general method is called by a client application to poll for data from the server and is defined in the following table 

The XMC DE DATA READ CONFIGURE general method is used to configure what type of data is returned when reading a given data item. For example the server may be configured to return the minimal amount of data on each read i.e. just the data item value or the server may be requested to return more substantial data. The following table defines the XMC DE DATA READ CONFIGURE method 

The XMC DE DATA WRITE general method is used to write data to a server and is described in the following table 

The XMC DE EVENT ENABLE general method enables disables a previously subscribed data item in the subscription list maintained by the server. Only enabled subscriptions actually fire. The XMC DE EVENT ENABLE method is defined in the following table 

This XMC DE EVENT RECEIVE DATA general method is called by the server and implemented by the client when each subscribed event fires and is described in the following table 

The XMC DE EVENT RECEIVE DATA CONFIGURE general method is used to configure what type of data is returned on each event that is fired. For example in the server may be configured to send the minimal amount of data on each event i.e. subscription cookie and data item value or the server may be requested to return more substantial data. The XMC DE EVENT RECEIVE DATA CONFIGURE method is defined in the following table 

The XMC DE EVENT SUBSCRIBE general method subscribes to a given data item activating the event interface when the subscription criteria are met for the data item. All subscribing components use the IXMCDirect interface to receive events received from the server for which they are subscribed. The XMC DE EVENT SUBSCRIBE method is described in the following table 

The XMC DE EVENT UNSUBSCRIBE general method removes a previously subscribed data item from the subscription list maintained by the server and is defined in the following table 

The XMC DE SYSTEM INITIALIZEHW general method is used to initialize any hardware systems associated with the component and is defined in the following table 

The XMC DE SYSTEM SHUTDOWNHW general method is used to shutdown any hardware systems associated with the component and is defined by the following table 

The following discussion will define which of the general methods implemented are implemented by particular components of the system .

The data collection component implements the general methods described above as indicated in the following table 

The following special notes apply to some of the general methods implemented by the data collection component .

The following component types are valid for the XMC DE SYSTEM CONNECT CMPNT method as implemented by the data collection component the XMC DE CMPNT TYPE XMCDSRC which specifies a data source component .

The following component types are valid for the XMC DE SYSTEM DISCONNECT CMPNT method as implemented by the data collection component XMC DE CMPNT TYPE XMCDSRC which specifies an data source component .

The data source component implements the general methods described above as indicated in the following table 

The data store component implements the general methods described above as indicated in the following table 

The following special notes apply to each of the general methods implemented by the data store component .

The following component types are valid for the XMC DE SYSTEM CONNECT CMPNT method on the data store component 

The following component types are valid for the XMC DE SYSTEM DISCONNECT CMPNT method as implemented by the data store component 

The data store component implements the general methods described above as indicated in the following table 

The data output component implements the general methods described above as indicated in the following table 

The following special notes methods apply to the general methods as implemented by the data output component .

The following component types are valid for the XMC DE SYSTEM CONNECT CMPNT as implemented by the data output component 

The following component types are valid for the XMC DE SYSTEM DISCONNECT CMPNT as implemented by the data output component 

The inference engine component implements the general methods described above as indicated in the following table 

The data formatter component implements the general methods described above as indicated in the following table 

The data transport component implements the general methods described above as indicated in the following table 

All methods exposed by each component in the example data routing system use a standard parameter set to describe data used to set and query properties as well as to invoke methods. The standard parameters are in the following format 

Each element in the rgData array corresponds to a parameter with the first element in the array corresponding to the first parameter.

The XMC PARAM DATA structure can contain either a numerical or a string value and is defined as follows 

The adt member of the XMC PARAM DATA structure describes the data contained within the XMC PARAM DATA structure. The values are described below 

When querying and setting boolean TRUE FALSE values any non zero value is considered TRUE whereas a zero value is considered FALSE.

As described herein the data routing system is designed to collect data from one or more data origins perform some decision logic on the data collected and then send the data to one or more data destinations based on the outcome of the decision logic run on the data inputs.

For example data inputs may be data items describing the current state of a machine tool automobile or other machine as shown in . The decision logic would then use these data inputs to determine the overall health or efficiency of the machine. Data outputs would be used to describe the machine s health or efficiency. This model thus operates as a data router where data is routed from one or more input to one or more output based on the decision logic run on the inputs. Typically this model is used to cook down a wide array of data inputs that are very detailed in nature to a more general set of data outputs that describe the overall performance state or behavior of the machine.

However this overall model can easily run in the reverse where the data input and output roles are reversed. In such an example as generally shown in the inputs are general in nature and then decision logic is used to determine the specific detailed outputs necessary to carry out a given behavior or action or to enter a given state.

For example using the latter model a general input to a machine tool may be something like mill a pocket at a certain point. The decision logic in turn would then figure out all of the necessary tools feedrate spindlerate and moves necessary to create the pocket on the part. Once determined the decision logic would output the values as a set of detailed output values such as the specific feedrate the specific spindlerate and the move profile to use. Each output would then be sent directly to the machine controller hardware that actually ran the servo algorithms to move the tool and cut the part.

In another example general inputs may be used to direct the path for which a car airplane ship or other mobile machine moved to a given destination. For example a general set of instructions would make up the inputs such as follow road x to intersection y turn left at intersection y drive to house b . The decision logic in this example would then be used to determine how to drive along road x making sure to track the right hand side of the road by following the yellow or white lines painted on the road decision logic would determine when the intersection sought had been reached how to negotiate the turn and drive to house b . When making each of these decisions the decision logic system would more than likely require additional more detailed input from sensor systems. Each output could then take a more detailed form such as the speed that the car or other mobile should drive and the steering adjustments needed to track and follow the desired path on the selected road.

The present invention relates to systems and methods for processing various types of commands transmitted between one or more command sources and one or more command targets forming part of a larger command system. The present invention is of particular significance when the command system is part of a motion control system and that application will be referred to on occasion below. As used herein the term command refers to information that allows an operation to be executed on a command target.

The present invention may be implemented using any one or more of a number of different system designs. A self contained system of the present invention will be described below with reference to . The self contained system describes a command processor component that implements all command processing functionality within a single component. A modular design will be described with reference to . The modular design describes a command processor system made up of the command processor component and one or more command execution components. The example self contained and modular designs are described below with reference to a module interaction description and a set of use cases that describe how the modules interact with one another when carrying out common operations.

In the present application the term module is used to refer to a binary block of computer logic that contains functions objects components ActiveX components .NET source HTML XML and or other computer code that can be executed in real time or in script form. Several examples of a module include an executable EXE a dynamic link library DLL an OLE component or set of components housed within a DLL or EXE an ActiveX Control an HTML or XML based Control a VB script source file a Java Serverlet Java Control Java Object .NET Package etc. The term component as used herein refers to a logical organization of computer logic designed to perform a set of operations. Several examples of a component are an OLE Component an ActiveX Control an HTML or XML based Control an HTML or XML based object a .NET object a Visual Basic based object etc.

Referring now to of the drawing depicted therein at is a command processing system constructed in accordance with the principles of a self contained system of the present invention. The self contained system comprises a command processor implemented such that all command processing takes place within a single component. The self contained system may allow for faster command processing than command processing systems using alternative designs.

The command processor is designed to run as an individual COM Component either in a stand alone manner under COM . In the context of a motion system the command processor may be designed to operate under a Windows NT Service application for providing motion services e.g. XMC Service . When run under COM the command processor may receive commands in various forms including SOAP simple object architecture protocol Web Services COM method calls and by monitoring a section of shared memory for command requests. Various other command input methods may also employed.

The example command processing system comprises the command processor component one or more command source components and one or more command target components . The example command sources are each associated with a service client . The example command processing system further comprises a command service module and a command service configuration and status module configuration and status module . In some situations the command processing system may further comprise an event component .

The example command processor receives runs and responds to commands received through first and second areas and of shared memory in the system . The command processor may optionally run as a COM component that services SOAP or other Web Service requests directly or via COM . The command processor may optionally communicate with the command target components across a network depending on the overall system architecture. As used herein the term network refers to a link between two or more computer systems and may be in the form of a packet based network a streaming based network broadcast based network or peer to peer based network. Several network examples include a TCP IP network the Internet an Intranet a wireless network using WiFi a wireless network using radio waves and or other light based signals etc.

If the sent commands relate to a command operation that must run as a set of commands or not at all the command processor may employ command framing to ensure that the commands are run as a set. U.S. Pat. No. 6 480 896 to the present Applicant describes a system of command framing in the context of a motion control system.

The example service clients are thin service components associated with specific clients or types of clients that interface with the shared memory used to communicate command requests to the command processor . Each service client may also relay input to the command processor by receiving commands via some other protocol such as TCP IP SOAP Messaging or the like that is transferred either locally or across a network. Once received the command is then converted into the appropriate shared memory format to direct the command processor that a new command is ready for processing. Optionally the service client may communicate either locally or across a network using OLE COM interface methods of the command processor . This method is typically not as fast but can allow for architectural flexibility.

In the context of a motion control system the command sources may be formed by an application programming interface for motion systems e.g. XMC API a system for processing data e.g. XMC Data Router and or other clients

The command targets are sets of components used to monitor devices or machines. Each of the command targets may be created for particular device or machine or class of devices or machines. The terms device or machine as used herein refer to a physical asset used to perform a specified task. For example a machine may be a CNC Mill used to shape metal a pick n place machine used to position parts on a circuit board a robotic machine used to perform surgery a medical data input device used to collect the vitals from a human being i.e. blood glucose meter asthma meter etc a gaming device used when playing a game a robotic toy an animatronics figure a robotic machine used to deliver goods to a warehouse or to people an automobile truck or farm vehicle a boat or ship that maneuvers in water a airplane jet helicopter and or spacecraft. Basically any self powered machine or device mobile or not that is either directly controlled by humans or automatically controlled via a computer based system.

In the context of a motion control system the command targets may be formed by a system of transmitting data to a motion system data engine e.g. XMCDE Data Engine system a system for automating control of a CNC motion system CNC control system e.g. XMC CNC Automation system and or a system for automating control of a GMC motion system GMC control system e.g. XMC GMC Automation system .

The configuration and status module allows the user to configure the service and gain status on how the application is running. The example command service module is a very thin Windows NT Service that optionally hosts the command processor thereby allowing the command processor to run even while the current user is not logged into the system.

The event component sends event data received from one of the data sources formed by the target components to one or more listening client components associated with the command sources . The term data as used herein refers to any numeric or string data values collected from a target machine or device in an analog or digital format that is made compatible for computer systems. Examples of data types that represent data items include BIT BYTE WORD DWORD LONG REAL DOUBLE FLOAT STRING ASCII STRING. Data may be collected from data sources using various methods such as reading register values on the data source reading shared memory provided by the data source sending commands to the data source for which a data response is given containing the data requested reading variables provided by the data source reading and writing to variables in a sequence necessary to produce data values querying data using a proprietary or standard data protocol and or calling a function provided by the target data source.

As shown in the example command processor comprises several C objects and Windows NT threads that interact with one another to route the commands received to the appropriate target components that ultimately carry out the specifics of the command requested. In particular the example command processor comprises a reception thread and one or more command threads .

The reception thread is responsible for receiving commands placed in the shared memory . The reception thread continually scans the shared memory for new commands triggered by the use of global events.

In the context of a motion control system the command threads are of two types where a first command thread processes commands associated with the data engine and the second command thread processes commands associated with the CNC motion system and the GMC motion system

The reception thread comprises a ConfigMgr object a DataMgr object and a QueueMgr object . The ConfigMgr object accesses configuration information placed in the shared memory area by the configuration and status module . The DataMgr pulls commands from the memory area shared with the service clients . The example QueueMgr object manages one or more priority queues servicing the command threads .

The command threads each comprise a StatusMgr object a QueueMgr object and a CommandMgr object . The StatusMgr object is manages and updates the status area of the shared memory used by the configuration and status module . The status information managed and updated by the StatusMgr object may be displayed to provide a user with visual feedback on what the command threads are actually doing at each point in time as well as the number of elements in the command queues. The CommandMgr object carries out each command by calling the appropriate target components .

The interaction of the objects threads and components forming the command processor will now be described in several common use cases. The following use cases will be described below Initialization System Start Command Processing First Command Thread Command Processing Second Command Thread Receiving Data and Receiving Events. The steps making up each use case are described in the order in which they occur.

Referring now to the Initialization use case will first be described. Initialization takes place when an application such as the command services application first starts up and loads the command processor . During this process each of the threads are started and all C objects are initialized.

The following steps take place when initializing the command processor . In step the application hosting the command processor such as the XMC Windows NT Service or COM DLLHOST starts up. In step the host application creates the component forming the command processor . When first created the component forming the command processor creates and starts the reception thread in step . In step ConfigMgr DataMgr and QueueMgr objects and used by the reception thread are created and initialized.

In step the second command thread is created and started. In step an instance of the StatusMgr object is created and initialized. Once created this component may be used to update status information on the overall initialization process. In step instances of the QueueMgr and CommandMgr objects and are created and initialized. In step the CommandMgr object creates an instance of its associated target component

In step the command thread or threads are created and started. In step an instance of the StatusMgr object is created and initialized allowing status information on the initialization progress of the command thread to be set. In step an instance of the CommandMgr and QueueMgr objects and used by the thread are created and initialized.

At step the CommandMgr creates an instance of the command targets and . In the context of a motion control system a multi system configuration may optionally use separate threads to process CNC and GMC commands respectively.

After completing the initialization the reception thread places itself in the paused state so that it will not process any commands until resumed. At this point the command processor is initialized and ready to be started.

Once initialized the reception thread must be resumed from its paused state prior to use of the system . No commands are processed until the reception thread is resumed.

Referring now to the following steps occur when starting the command processor . In step the hosting command service application calls a method on the command processor component to start the command processing. In step upon receiving the start call the command processor component resumes the reception thread causing the DataMgr object to first query for any configuration changes.

In step the DataMgr object queries the ConfigMgr object for any configuration changes such as a new priority for the reception thread etc. The ConfigMgr object queries the configuration shared memory for any settings. Once started as shown at step the DataMgr object resumes normal operation and continually checks for new commands in the shared memory.

At this point all commands received are processed normally. The following sections describe how two of the main command types are processed namely the example command threads and

Referring first to depicted therein is the processing implemented by the second type of command thread . In general all commands associated with the command target are processed are routed to the first command target . Examples of the commands sent to the command target are Start or Pause and these commands will be referred to as first type commands.

The following steps occur when processing commands destined for the command target . In step the command source calls the service client requesting that a given first type command be run. As generally discussed above some commands may be initiated by the host itself a user interface application or even a protocol listener used to convert and route command requests using the service client

In step the service client packages the command into an area within the shared memory area specifically allocated for that instance of the service client . Within the command processor the reception thread is continually monitoring the shared memory for new commands as shown in step . Upon detecting a new command the DataMgr object extracts the command information from the shared memory area .

In step the DataMgr object passes the command information to the QueueMgr object . In step the QueueMgr object packages the command information into a queue command element and places the command in the priority queue . The element may be placed at a location in the queue based on the element s priority so that high priority commands are processed sooner than low priority commands.

Within the command threads the QueueMgr object implicitly receives the queued command i.e. it is the same queue accessed in the reception thread as shown in step .

As shown in step the CommandMgr object which continually checks for new commands to run in the command thread detects a new command and pulls it from the QueueMgr object . And finally in step the CommandMgr object directs the command to the command target component which carries out the requested command.

At this point the command is complete. However the mechanism just described does not allow notification back to the service client that requested the command. This type of command is known as a broadcasted command where the command is sent without sending back status on the results of the command carried out.

As shown in the first command thread operates in a manner similar to that of the second command thread except that commands routed through the first command thread are routed to one of the command targets and instead of the command target

In step the service client calls the Service Thin Client requesting to run a given first type command. Again some commands may be initiated by the host itself a user interface application or even a protocol listener used to convert and route command requests using the service client .

In step the service client packages the command into the area within the shared memory area specifically allocated for that instance of the service client

Within the command processor the reception thread is continually monitoring the shared memory for new commands as shown in step . Upon detecting a new command the DataMgr object extracts the command information from the shared memory.

As shown in step the DataMgr object passes the command information to the QueueMgr object . At step the QueueMgr object packages the command information into a queue command element and places the command in the priority queue . The element may be placed at a location in the queue based on the elements priority so that high priority commands are processed sooner than low priority commands.

As shown at step within the command thread the QueueMgr object implicitly receives the queued command i.e. it is the same queue accessed in the reception thread .

At step the CommandMgr object which continually checks for new commands to run in the command thread detects a new command and pulls it from the QueueMgr object

And finally at step the CommandMgr object directs the command to the command target component and or which carries out the requested command.

At this point the command is complete. Again no notification is sent back to the service client who requested the command. This example command is known as a broadcasted command where the command is sent without sending back status on the results of the command carried out.

While running the command processor often it is important to display visual feedback on what the command processor is actually doing. For example the user may want to know whether the command processor is currently processing a command or how many commands are in the various command queues. The use case illustrated in illustrates how such user feedback can be attained while running the command processor .

In a step the StatusMgr objects and collect status information while each of the command threads and run. All status information is saved to the status configuration shared memory area .

In step each application requesting status information reads the shared memory area where the status information was placed.

The service client that requested a command be run will want or need feedback on the results of the command and in many cases data that results from running the command. The use case depicted in describes how feedback data may be returned to service clients .

In step the service client places the command into the shared memory area . Included with the command information is the name of the global event for which the service client is waiting and which should be set by the command processor upon completion of the command.

As shown in step upon receiving the command the DataMgr object extracts the command information from the shared memory area including the name of the global event. At step all command information is passed to the QueueMgr object .

As shown at step the QueueMgr object packages the command information into a command element that is then placed within the appropriate command priority queue and or

In step the CommandMgr objects within the command threads detect the command by querying the QueueMgr object . In step the QueueMgr objects return the command element or elements to the CommandMgr objects .

In step the CommandMgr objects run the command by delegating it to the appropriate command target . Upon completion of the command the CommandMgr objects update the shared memory referenced by the command element with the return result and any data returned by the command targets . Once all data is updated the CommandMgr objects set the global event referenced by the command element notifying other components of the command processor that execution of the command is complete.

In step the event that the service client is waiting on is released thus freeing the service client to continue with the data placed in the shared memory area back in step . At this point the command processing for the command is complete.

In some cases it is desirable for the service client to receive unsolicited updates when certain events occur. depicts the situation in which the service client receives updates upon the occurrence of certain events. To receive events the event component is accessible by the command client and the command target . In addition the service client calls a command source to subscribe to the event. Once subscribed the event is fired to the service client when the event condition is met. The following steps occur when events are sent back to the service client .

In a first step when the event condition is met the component that is the source of the event fires the event using the event component . In step the event component sends the global event to all instances of the event component . In step the instance of the event component used by the service client picks up the event and calls an event handler on the service client . At this point the event routing has completed.

Referring now to a modular design of a command processing system of the present invention will now be described. The command processing system comprises command processor . The command processing system is more scaleable than the command processing system described above in that it can support any type of command without requiring any changes within the command processor .

In general two component types interact with one another to process commands received the command processor and a number of command execution components that will be described in further detail below. As with the system described above the system transfers commands between one or more command sources and one or more command targets . Each command source is associated with a service client . The system further comprises a command services module and a configuration and status module . The system further defines shared memory areas and and

To process commands the command processor routes each command received to an appropriate command execution component designated to handle the type of command received.

Optionally each of the command execution components may be given a global priority that dictates how and when the command processor sends commands thereto. For example shows how three different types of commands associated with three types of command targets and may be supported. The design is specifically intended to support many different kinds of commands including commands not yet defined by the command implementer of the command processor and or commands defined by a third party. The design of the command processing system thus allows for supporting many different types of commands without requiring changes in the overall command processor architecture. Another advantage of the design of the command processing system is that this design allows for the deployment of new command types to the field where the command processor is already in use.

The service client functions as an interface between a shared memory area and is used to communicate command requests to the command processor . The service clients may also be used to relay input to the command processor by receiving command via some other protocol such as TCP IP SOAP Messaging etc. that is transferred either locally or across a network. Once received the command is then converted into the appropriate shared memory format to direct the command processor that a new command is ready for processing. Optionally the service client may communicate either locally or across a network using the OLE COM interface methods of the components forming the command processor . This method is not as fast but can allow for architectural flexibility.

The command processor component receives and delegates each command to the appropriate command execution component . The command processor component may also run optionally as a COM component that services SOAP or other Web Service requests either directly or via COM . Optionally the command processor may communicate with the command execution components across a network.

Command execution components are responsible for running the set of commands associated with the component. For example individual command execution components and run commands that are destined for the target component and respectively. Optionally each individual command execution component may run as a COM component. Again this may not optimize system speed but can provide desirable architectural flexibility.

The command execution components may support using Artificial Intelligence to break down generic commands into a set of more complex commands used to carry out a task. As used herein the term artificial intelligence refers to algorithms such as Neural Networks Genetic Algorithms Fuzzy Logic Expert Systems combinations of all listed and other computer based decision making and pattern matching based systems. For example a generic command may state to lift up a box. This command would then be broken down into the sequence of moves given the current position of a loader arm necessary to pick up the box. The command execution component may use Artificial Intelligence to do such a breakdown.

When communicating to the target component the command execution component may do so either locally or across a network depending on the overall system architecture. In the event that the commands sent contain a critical operation that must run as a set of commands or not at all the command processor may employ a form of command framing as generally described above.

The example command service component is a very thin Windows NT Service that optionally hosts the command processor thus allowing the command processor to run even while the current user is not logged into the system. It should be noted that future versions may not need this service as COM supports running components as a services. Since the command processor component optionally supports COM it may also be run as a service in COM .

The configuration and status module application allows the user to configure the command processor and various command execution components and obtain status on how each component is running.

The command targets are or may be similar to the command targets described above and the command targets will not be described again herein beyond what is necessary for a complete understanding of the present invention.

Like the event component described above the event component sends event data received from one of the various command targets to one or more listening service clients .

The details of the example command processor will now be described in detail. The example command processor comprises several C objects and a Windows NT thread that interact with one another to route the commands received to the appropriate command execution component .

The command process comprises a reception thread that receives commands placed in the shared memory area . The thread continually scans for new commands in the shared memory area . The new commands may be triggered by the use of global events.

The following example objects are C objects used to implement portions of the command processor . A ConfigMgr object pulls configuration information set in the shared memory area by the configuration and status module . A DataMgr object pulls commands stored by the service client in the shared memory area .

The command execution components will now be described in further detail. Within the command execution component several C objects and a Windows NT thread interact with one another to run the commands received.

Each command execution component comprises a command thread . The command threads process commands destined for the command target that supports the command set associated with the command execution component .

The following C objects are used to implement portions of the command execution component . A QueueMgr object is responsible for managing the various priority queues servicing the command threads .

A StatusMgr object manages and updates the status area of the shared memory used by the configuration and status module . The status information updated is used to allow visual feedback on the state of the command threads as well as the number of elements in the command queues .

The interaction of the objects threads and components of the command processing system will now be described in reference to several common use cases that take place on the command processor during normal use. The following use cases will be described in detail below Initialization Command Processing Receiving Events and Updating Status.

As shown in when initializing the system the following steps take place. In step before actually starting the initialization of the component the user may optionally change the configuration of the component using the configuration and status application which allows the user to configure the command processor and or all command execution components .

At step when actually initializing the component the command target optionally a DLLHOST used when run as a COM server creates the command processor component and directs it to initialize itself.

At step when created the command processor creates the reception thread and runs it. Within the reception thread the ConfigMgr is initialized at step . At step the reception thread initializes the DataMgr object .

During its initialization the DataMgr object queries the ConfigMgr object for settings previously made by the user. For example the list of command execution components installed is queried.

At step the DataMgr object then creates each command execution component . When created each command execution component creates its command thread and starts running it at step . Within the command thread the StatusMgr QueueMgr and CommandMgr objects are next initialized at step .

Upon completion of the command execution component creation at step the DataMgr object within the reception thread of the command processor sends a command to the command execution component directing the execution component to initialize itself.

At step the initialization command is received by the QueueMgr object in the command execution component . At step the QueueMgr object immediately places the command received into the command queue .

Within the command thread of the command execution component at step the CommandMgr object queries the QueueMgr object for any new commands and pulls the initialize command from the queue previously placed in the queue in step above .

The CommandMgr object creates the appropriate command target at step which runs the commands in the set associated with the specific command execution component . The command target is also directed to initialize itself making it ready to process commands. Upon completing the initialization the CommandMgr unlocks the Windows Event associated with the command signifying that the command has been completed.

Referring back to the DataMgr object within the reception thread in the command processor component the DataMgr object detects that the command has been completed and prepares to run more commands as shown at step .

The creation process in which the command processor and command execution components are created and the initialization process may optionally be separated. In this case a specific command is first created and then a specific initialize command is then sent to the command processor directing it to prepare for receiving commands. In such a situation the command processor could block wait until the initialization command completed and then return the results of the initialization back to the configuration and status application or other host such as DLLHOST or a service client using DLLHOST .

At this point the command processor is running and ready to process commands from the service client or clients .

Referring now to the following steps take place when processing a given command. In step the service client software calls the service client directing it to run a given command.

In the step the service client then places the command information into the shared memory area designated by the command processor for the specific instance of the service client this designation occurs when first creating the service client . Optionally the service client then waits for the command processor to signal that the event has completed. This signaling occurs either through information passed through the shared memory or with a global synchronization object like a Windows NT Event object.

In step the DataMgr object of the reception thread in the command processor detects that a command is ready in the shared memory . The command information is extracted from the shared memory .

Upon receiving the command information the information is routed to the QueueMgr which then places the command information into the command queue at step . Optionally the command information is placed into the queue at a location specified by the command priority. For example a high priority command may be placed at the beginning of the queue i.e. pulled off the queue first whereas a low priority command may be placed at the end of the queue i.e. pulled off the queue last .

In step the CommandMgr within the command thread queries the QueueMgr for any commands that may exist and if one does exist pulls the command from the front of the command queue .

The command is then run at step by passing the command to the command target used to run the command. For example second type command might be passed to the second command target

At step upon completion of the command the CommandMgr copies all return data into the shared memory and then either toggles information in the shared memory associated with the command or signals a synchronization object such as a Windows NT Event to signify that the command has completed.

In step the service client detects that the command has completed and picks up any return data placed in the shared memory and returns it to the command source .

Referring now to the following steps occur when the service client receives unsolicited events from the command target .

When the event condition is met the event condition being previously configured the command target fires the event using the event component as shown in step . In step the event component fires the event to all listening components including other instances of the event component . In step the instance of the event component used by the service client picks up the event and routes it to the service client . The service client then routes the event information to the command source .

Referring now to the following steps take place when updating status information while the command processor component and command execution component process commands.

In step during each loop within each command execution component status information is continuously updated using the StatusMgr object . For example the number of commands in the command queue may be set in the status shared memory .

The configuration and status module is then able to pick up the information from the shared memory and display it to the user thus notifying the user of the status of each command execution module and optionally command processor components. Optionally a separate thread may be used to monitor status information so as to not slow down or otherwise interfere with the command thread.

As generally described above the example command processor is a modular system made up of a set of components i.e. each component is based on a component technology such as OLE COM from Microsoft Corporation . Optionally each component uses a separate parallel ActiveX component to implement all user interface aspects of the main component. Each ActiveX component may be implemented either within the main component module or separately in its own module. Bundling each object within one module is not required as the objects may be located at any location i.e. across a network and so forth but doing so may optimize communication between modules. The exact location of the components in any given implementation of the present invention is merely a logistical decision. Once components are built and deployed it is difficult to update a single component if all components are implemented within a single DLL or EXE module.

As shown in the example components forming the command processor implement at a minimum a single interface the IXMCDirect interface. Optionally components that receive events from other components can implement the IXMCDirectSink interface as well.

OLE Categories are used to determine how many components fall into a certain group of components. Currently the following categories are used 

The IXMCDirect interface is used for most communications between all components making up the command processor Technology. The following methods make up this interface as specified in the standard OLE COM IDL format 

This method is used to query the property corresponding to the property name pszPropName . Each component defines the properties that it supports.

This method is used to set a property in the component corresponding to the pszPropName property. For the set of properties supported by the component see the specific component description.

This method is used to call a specific method implemented by the component. For more information on the methods supported see the description of the specific component.

The IXMCDirectSink interface is an event reception point on which one component can send event data to another. The component implementing this interface is the event receiver. The event source calls the interface passing to it event data.

This method is called by the event source and passed the event data in a SAFEARRAY form for easy marshalling across process boundaries.

This method is called by the event source when an error occurs and passed the event error data in a SAFEARRAY form for easy marshalling across process boundaries.

The methods supported by each component making up the system will now be described. In particular the methods supported by the majority of the components will be described below. For the specific list of methods supported by each component see the section describing each component.

This method is used to disconnect one server to another so that they stop interacting with one another.

This method is used to configure what type of data is returned when processing a given data item. For example in the server may be configured to return the minimal amount of data on each read i.e. just the data item value or the server may be requested to return more substantial data.

This method enables disables a previously subscribed data item in the subscription list maintained by the server. Only enabled subscriptions actually fire.

This method is called by the server and implemented by the service client when each subscribed event fires.

This method is used to configure what type of data is returned on each event that is fired. For example in the server may be configured to send the minimal amount of data on each event i.e. subscription cookie and data item value or the server may be requested to return more substantial data.

This method subscribes to a given data item activating the event interface when the subscription criteria are met for the data item. In the example system all unsubscribing components must use the IXMCDirect interface to receive events received from the server for which they are subscribed.

This method removes a previously subscribed data item from the subscription list maintained by the server.

The command execution components implement the following general methods listed in the general component methods section above.

The definitions of all special types used by the methods and properties of each component making up the command processor system will now be described.

All methods exposed by each component in the example system use a standard parameters set to describe data used to set and query properties as well as invoke methods. The standard parameters are in the following format 

Each element in the rgData array corresponds to a parameter with the first element in the array corresponding to the first parameter.

The XMC PARAM DATA structure can contain either a numerical or a string value and is defined as follows 

The adt member of the XMC PARAM DATA structure describes the data contained within the XMC PARAM DATA structure. The values are described below 

When querying and setting boolean TRUE FALSE values any non zero value is considered TRUE whereas a zero value is considered FALSE.

The command processor of the present invention may be used on more than just motion based devices and machines although the present invention is of particular significance in that environment. The principles of the present invention may also be used to send commands to medical devices where each command directs the medical device to carry out a set of operations. It may also be used to send commands to farming equipment heavy machinery such as tractors excavators bulldozers cranes semi trucks automobiles drilling equipment water craft such as submersibles boats and ships airplanes including jets spacecraft satellites and any other kind of mobile device or machine that moves on land water or within the air or space.

The technology implemented by the present invention may be used to send commands in the following environments 

The term command data as used herein refer to any numeric or string data values used to describe the command and parameters describing how to perform the command. For example BIT BYTE WORD DWORD LONG REAL DOUBLE FLOAT STRING ASCII STRING are a few command data types that represent commands and or command parameters. Command data may eventually be sent to the command target by writing register values on the command target writing to shared memory provided by the command target sending commands to the command target for which a data response is given containing the data requested writing to variables provided by the command target reading and writing to variables in a sequence necessary to carry out the commanded operation using a proprietary or standard data protocol calling a function provided by the command target etc.

Referring now to of the drawing depicted therein is an example data routing system constructed in accordance with and embodying the principles of the present invention. The example data routing system comprises a data engine a data source a data transport and a protocol server .

The example data routing system is designed to operate in a first implementation in conjunction with a machine platform a database server platform and an event system as shown in . The data example routing system also operates in a second implementation in conjunction with a database client and a command processor as shown in .

The data engine is configured to manage the overall data routing system . The data source forms an input to the data router system by providing a link to the data source such as the machine platform . The example data source provides this link using OLE Automation interfaces. The data transport forms an output of the data router system that sends data to a data target such as the database server platform . The protocol server receives events from the event system each time a record is entered into the database server platform .

The example machine platform is connected to or incorporates a target machine and is configured to unify the data of and access to the target machine. Within the example machine platform is an event thread pool is used to send data to outbound targets such as data source of the data routing system . The example machine platform also incorporate an optional motion event component such as that described in the Applicants U.S. Pat. No. 5 691 897. The contents of the 897 patent is included herein by reference.

The example server platform incorporates or is formed by a Microsoft SQL server that defines a data router database . The data router database is configured with a number of tables including a States table that contains all state updates made by the data router system as will be described in further detail herein. The States table also includes an INSERT trigger that fires each time a record is inserted into the table.

The event system comprises a database event and a system event . In the example data router database when the INSERT trigger fires the database event is called and thus notified of the newly inserted data. The example database event is the XMCSQLEVT event which is a Com event as implemented by the example database .

The database event uses the system event to notify any outside application such as the protocol server of data updates made to the States table within the data router database . In particular the example protocol server receives through the event system events from the database event each time a record is inserted into the States table. Upon receiving each event the protocol server updates an internal cache for the data item.

When outside clients of the protocol server read the data item the data from the cache is served up to the client. In addition the example protocol server may also browse the data router database for all assets states and sub states to create an address space that reflects the data within the tables defined by the data router database .

The protocol server depicted in is presented simply as an illustration of one example of how the data routing system may be configured. The example protocol server relies on tables and triggers from within data router database and need not configured based on any upstream software that places data within those tables.

Turning now to of the drawing depicted therein are a number of use cases illustrating sequences of steps that are performed by one or more of the modules making up the data routing system and the machine platform server platform event system database client and or command processor . In particular the following use cases are described initialization of the overall system how the data items provided by the server are browsed how the data updates are made on the server how clients of the server read and receive data and an alternative configuration of the data routing system that uses data router database to command a motion system associated with the machine platform to perform one or more actions.

Referring initially to of the drawing an example of the process of initializing the data routing system is depicted therein. The initialization process is a two step process. First the data router database is initialized as shown in . Second protocol server is initialized as shown in .

In the example data routing system the data router database is initialized before the protocol server is initialized.

The following steps take place when initializing the example data router database . First a software application portion of the data routing system is used to initialize the database by configuring the data transport and directing the data transport to initialize the data router database by using for example an XML data file that describes all assets states and sub states that are to be loaded into the database. Second during this process data transport creates all tables and creates an INSERT Trigger on the States table that calls the XMC SQL Event Class each time a record is inserted into the States table. When the data router database is initialized the database is ready for use by the protocol server .

The protocol server is initialized each time a client application creates an instance of the server to use. illustrates one example of the process of initializing the protocol server . The following steps are performed when the protocol server is initialized. First the protocol server browses the Assets table to receive a list of all assets as well as the StateTagsView to receive a list of all states and their sub states. The protocol server uses the list of all assets and list of all states and their sub states to build the address space of the protocol server .

Second the protocol server subscribes to the event class associated with the database event defined by the event system . The example protocol server subscribes to the late bound XMC SQL Event Class provided by the COM Event System. At this point the protocol server is ready to use. In the example described herein an internal item tree used when browsing items is built during the first step of the process of initializing the protocol server .

Referring now to of the drawing a browsing process implemented by the data routing system will now be described. Browsing is the process if viewing and walking the list of items exposed by the protocol server . More specifically browsing is the process of either visually selecting items from a tree of items browsed or programmatically selecting one or more items from the tree. In addition browsing may involve walking the tree items. For example when searching for a given item a program may iteratively look at each item while it determines if each is the item the program is looking for.

The example item tree used by the process illustrated in is made up of asset names at the top level states at the next level and sub states at the last leaf level. An example of the item tree is set forth below 

During the browsing process each of the elements making up the item tree are retrieved from the data router database . In the example system depicted in the Assets are loaded from the Assets table and the State and Sub States are retrieved from the StateTagsView view.

The following step takes place when browsing items exposed by the protocol server . The protocol server walks the browse tree that was previously built when initializing the server by querying the Assets table and StateTagsView view. Browsing the items allows an application to select which data items are to be monitored.

Referring now to of the drawing depicted therein is the data update process. Data updates are received by the protocol server each time a record is inserted into the States table of the data router database . In the example depicted in upon the completion of each insert the database calls the database event XMC SQL Event Class which routes an event to the protocol server protocol server XMC SQL OPC Server via the system event COM Event System .

The following steps occur when data updates are processed by the system. First a data event is fired by one of the threads in the event thread pool provided by the motion event component of the machine platform . The motion event component may be as described in copending U.S. patent application Ser. Nos. 11 067 327 and 11 375 502. The contents of the 327 and 502 applications are incorporated herein by reference.

Second the data source receives the event and passes the information up to the data engine . Third the data engine runs the data associated with the received event through a set of rules that determine whether the data should be sent to the data transport . In the example data engine if the rule determines that the data should sent and an identity type is used in the rule the raw data is sent to the data transport . Using an identity type in a data router rule set directs the data router to pass the actual data along with each rule that fires.

Third upon receiving the data the data transport inserts the data along with the raw data into the States table and an ExtraInfo tables within the data router database . Upon completing the INSERT operation into the States table the data router database then fires and Insert Trigger OnInsertTrigger . In this particular implementation Insert Triggers use Microsoft SQL Server and may not run correctly from within the MSDE environment.

Fifth the OnInsertTrigger calls the database event XMCSQLEVT COM Event Class within its stored procedure. The Asset State Sub State raw data and time stamp of the INSERT trigger are all passed to the event class.

Sixth the event system COM routes the database event XMC SQL Event Class event to the protocol server which has already subscribed to such events during its initialization process. Upon receiving the event the protocol server stores the data received in its data cache for the item. It should be noted that data updates do not directly trigger updating clients of the protocol server but instead continually refresh its internal data cache of data items.

Turning now to of the drawing the process of reading data will be described in further detail. The data reading process is carried out by each client. The client can read data Data directly or using updates via an event that fires periodically. In either case data is transferred during this process from the protocol server to the client application. As shown in when reading data data is served to the client application either via a periodic update when data changes or when the client directly asks for the data.

Referring now to of the drawing the process of commanding a motion system using the data routing system will now be described. The implementation of the invention described with reference to describe the process of reading data from a motion system. However the architecture of the data routing system of the present invention may be used to command a motion system to perform one or more actions.

As described above the data routing system is used in conjunction with the client application and command processor in . The client application is a software application component module script web page or the like that determines a series of motion steps to be carried out. The command processor generates commands that carry out the series of motion step defined by the client application . The command processor may be implemented using the command processor described in U.S. patent application Ser. No. 10 991 905 which is included by reference herein in its entirety.

To process command via database input the following steps occur. First the database client inserts commands into the Command table found within the data router database . Second when inserted all inserted command information including the command and its parameters and optionally the return data routing location such as a table where return data is to be placed is sent to the XMCSQLEVT COM Event Class to fire. Third the COM Event System fires the late coupled events LCE to any subscribers that may exist.

Fourth the XMCSQLEVT COM Event Class supports the IXMCaSQLEvent interface which is called on all subscribers to the event class each time the event fires. Upon receiving the events the command processor processes the events by sending the commands to the target motion system s designated to receive the commands. Note there are several way t the command processor may deliver the commands to target motion systems The command processor may send the commands to motion systems specified in the event parameters or the command system may send the commands to motion systems pre configured in the command processor to receive specific or all events or the command processor may broadcast the events to all motion systems connected to it.

Sixth upon receiving the command s each motion system carries out the commands using the command all of its parameter data. If data is to be returned the return data is sent back to the command processor who then in turn routes the data back to the routing target. Optionally the data router may be used to return information as well.

The system described in this document is a very modular system made up of a set of components. For example each component may be based on a component technology such as OLE COM from Microsoft Corporation. Detailed descriptions of the interfaces of the example components used for communication between the various pieces making up the system are set forth below.

Upon receiving an insert instruction into a designated table i.e. the States table in the data router database or a Command table in the command processor database a pre configured event trigger is fired by the data router database that sends the inserted data to the database event XMCSQLEVT module . In the example described herein the event trigger calls the module s IXMCaSQLEvent interface. The example IXMCaSQLEvent interface will be described in further detail below.

The IXMCaSQLEvent interface is used by server platform to send event information to any subscribers of the XMC SQL Event Class.

This method sends event data to each subscriber in a form where each parameter is broken into a separate string for convenience.

A number of technologies may be used to implement the data routing system or in conjunction with the data routing system . The machine platform may be implemented by incorporate or be connected to a motion system as described in one or more of the following U.S. patents the contents of which are incorporated herein by reference U.S. Pat. Nos. 5 691 897 5 867 385 6 480 896 6 513 058 and 6 885 898.

The data router may be implemented by incorporate or be connected to a data router system as described in one or more of the following U.S. patent application the contents of which are incorporated herein by reference Ser. No. 10 844 025.

The command processor may be implemented by incorporate or be connected to a motion system as described in one or more of the following U.S. patent application the contents of which are incorporated herein by reference Ser. No. 10 991 905.

OPC technology along with its formal specifications forms an example of a protocol for implementing the Protocol Server. OPC is a software technology used to connect to various enterprise systems in the industrial automation market such as MES systems machine monitoring systems and the like. Traditionally this technology has been used to connect PLC and sensor data to such systems. Combining XMC with OPC provides an elegant way to connect machine tool and motion control data into these systems as well. For more information on OPC see www.opcfoundation.org.

The Microsoft SQL Database Server and related technologies may be used to implement the server platform . The Microsoft SQL Database Server documentation which is available online contains specific information on how INSERT Triggers work and how one may call an external COM or COM component.

The event system may be implemented using the COM Event System. The COM Event System provides support for decoupled events. When decoupled events are supported both the data publisher and the data subscriber are independent of one another. Decoupled events are otherwise known as a loosely coupled event LCE . COM Events are just one of the many COM Services used by each of the components making up the system. For example since the example protocol server is a COM Application it automatically takes advantage of object pooling and message queue communications provided by COM .

The Microsoft COM Component Object Model describes the component model that all components described within the example system are based upon.

Referring now to of the drawing depicted therein is an example data collection system constructed in accordance with and embodying the principles of the present invention. The example data collection system comprises a connectivity server layer configured to collect data from at least one hardware device or asset through a machine platform . In the example data collection system the data collected by the connectivity server layer is distributed to a back office system layer .

The connectivity server layer comprises a data routing system and a protocol server . The back office system layer comprises at least one enterprise software system . The assets form a machine layer and the machine platform or platforms form a platform layer .

The data routing system uses application called Enterprise Manager to configure run and monitor a server technology that runs behind the scenes called the Enterprise Server. The Enterprise Server is the technology that actually collects data from the hardware device or asset in an intelligent manner. The enterprise software system and the Enterprise Server form the data collection system .

The machine intelligence offered by the data routing system allows better data collection that shows how a machine asset is operating. This machine intelligence infers the current state of the machine asset based on the state of given inputs and then sends the resulting outputs to a desired data target for later analysis based on predefined rules. Alternatively data inputs read from each asset may be sent directly up to the enterprise software for direct analysis at that level.

There are several ways the data collection system may be used to monitor assets. The following discusses each of the configuration options that are available.

In the data collection system is illustrated in the context of collecting data from a single asset . illustrates how the data routing system is used along with the machine platform to connect an enterprise software system to receive data from the machine asset .

A low cost computer server PC may be used to run the software making up the data collection system . In the example system the data routing system is a software layer that routes data from each individual asset to various up stream enterprise software systems . The protocol server provides connectivity to data items processed by the data routing system using a protocol specification such as may be developed by a standards body or other company or group.

The machine platform is a controller neutral layer used for all controller communication that defines a universal API and variable model. Using the universal API and variable model of the machine platform data items easily flow from the target control of the asset to the data routing system for further routing to the enterprise software system . Typically the single instance model is only used in environments where a dedicated computer is available for each asset that is to be monitored.

In situations where a PC is not dedicated to the target control system the data collection system may be implemented using a multi asset connectivity model as shown at in . The multi asset model allows for the connectivity server to communicate with two or more machine assets and route all data received from the group to one or more enterprise software systems .

The example multi asset data collection system employs the data routing system protocol server and enterprise software as described above. In addition the example machine assets are identified as machine control industry products such as a GE Fanuc asset Siemens asset Okuma asset and a Mazak asset . Each of the assets connects to the data routing system through an associated machine platform and

By using multiple instances of the machine platform the data routing system is capable of managing connectivity with a wide range of machine assets . Because the machine platforms are controller neutral all of the example assets may be handled in the same manner by the data routing system .

The example data collection systems and illustrate that these systems are capable of communicating to one or more target controllers or assets . As shown at in a data collection system of the present invention is also flexible enough to communicate with multiple enterprise software systems forming part of the back office system layer .

In particular the data routing system may be configured to connect to multiple enterprise software systems as well. The example data collection system employs the data routing system protocol server and enterprise software as described above. Again the data routing system collects data from the GE Fanuc asset Siemens asset Okuma asset and a Mazak asset through the associated machine platform and . In addition the data routing system is capable of communicating with first second and third enterprise software systems and either directly or through the protocol server .

The enterprise software systems may include enterprise software systems such as the systems and that communicate with the data routing system through the protocol server referred to as protocol clients enterprise software systems such as the system that directly program to the data routing system referred to as custom clients and or enterprise software systems such as the system formed by an external database such as Microsoft SQL.

As described above a data collection system of the present invention such as the data collection systems and are designed to route data from one or more discrete motion based assets to one or more enterprise software systems . The example data collection systems and employ a layered architecture comprising the connectivity server layer the back office layer the hardware layer and the machine platform layer . During the process of routing data from the assets to the enterprise software systems a general data flow takes place through this layered architecture.

Each of the layers and has a specific purpose and the purposes of these layers will be described below in the context of .

The hardware layer is the lowest layer. The target systems or assets define this hardware layer . As shown at step in the target systems or assets produce the raw machine data describing the state of the machine or asset at any given point in time. For example a machine used on the factory floor may produce machine state data whereas an RFID tag global positioning locator or combination of the two may produce the location and identification of a given asset at a point in time. As another example a vehicle boat or plane may produce data about its operating state in addition to its location etc.

Each asset is associated with a driver designed to work with a specific target system or asset . In particular as shown at step each driver implements the target specific communication protocols target specific language and or uses the target specific application programming interface API to collect the data from the target system or asset . For example a target system may be a control system used to run a machine on the factory floor. Alternatively the target system may be a GPS locator or RFID tag attached to an asset or the target system may be a control system within a vehicle boat airplane or other asset . In any of these examples the driver is configured at least to collect data its associated target system .

The machine platform may be a motion server that as shown at step makes all data received universal by providing a consistent programming interface and data model to up stream software.

In the connectivity server layer the data routing system is configured to collect data from multiple assets through multiple instances of the machine platforms such as one or more motion servers as shown at step . The data routing system further maps all data items received by the data routing system from each asset to designer defined tags as shown at step . This model allows the designer to decide what data tags will make up their overall system thus allowing the overall architecture to better fit each enterprises needs.

Also in the connectivity layer the protocol server provides access as shown at step A to all data router data items defined above to any client application of the protocol server such as one or more of the enterprise software systems as described above. In addition as shown at step B data items may be provided in a data router specific model so that custom enterprise applications may access the data item without using the protocol server .

In the back office layer the enterprise software systems provide data analysis and storage of all data received as shown at step .

Internally the data routing system performs two tasks as it manages the data pipeline first the data routing system collects data from a set of assets and second the data routing system then maps the data items to data tags that are sent along with the data to each enterprise software system .

To route data from the assets to the enterprise software system the data routing system employs user definable rules that map one or more inputs to one or more outputs as generally shown in . By default each rule is configured to implement a pass through that allows the raw data and data item to pass through to the enterprise software system .

Alternatively each data item may also be fed into a set of rules that allow combining data items and adding intelligence to each data item that fires. When a data output fires associated actions take place. For example when a data output fires it may send the raw data its tag and any associated data such as special codes etc to the target enterprise software system . Optionally the data outputs may fire based on the evaluation of the rules associated with each output. Rules are evaluated against data inputs received from the machine platform .

Referring now to the data collection system allows the user to add and configure the inputs outputs and rules that direct which outputs are to fire. The multi layered software architecture implemented by the data collection system allows for easily expandable controller connectivity that may take place independent of the details of any of the enterprise software systems . Simple plug n play drivers may be added at a later date to already deployed systems in the field thus making overall factory roll outs easy to deploy over time.

The data collection system uses a consistent interface between each layer in the architecture above where each layer has its own individual purpose as described in detail elsewhere. The data routing system is a very modular component based system that allows for collecting data from various data sources and routing them to various data targets. Optionally the data routing system allows for the user to combine data items and set rules that dictate when data items fire. All data items may be easily configured using an XML configuration file that specifies all data items data sub items and assets in the system.

The protocol server may be configured to provide connectivity to the data router data items via data tags that are defined with the data router s XML configuration file. This model allows each system designer to easily configure their system and the data tags that make up their system in a way that best suits their needs.

As shown in the machine platform layer may be configured with a MOTION.NET software system and motion administrator that provide programmatic access to the motion server . With this software layer the user can program to the motion server using virtually any language such as the Microsoft .NET languages Java C and Visual Basic 6.0. The data collection system thus uses a component based model that is intuitive and easy to program.

The example motion administrator allows the user to configure each instance of the motion server select the target control or asset used and configure all configuration items specific to the control selected.

The example motion server provides a universal access point to the underlying target controller. The example server may be run as a Windows NT Service as a serviced component or stand alone yet each instance is used to communicate with only one target controller. Using thread process and reentrancy synchronization the example motion server allows multiple instances to be run simultaneously to facilitate communication with multiple control systems.

Each driver is responsible for implementing all asset specific logic necessary to communicate with the asset to read data from write data to and cause actions on the underlying system.

The hardware device or asset may optionally embody a control system and take the form of one or more of the following 

In the case of a mobile asset the data may be stored by the asset for subsequent uploading or a mobile communications system may be used between any two or more of the layers described above.

One of ordinary skill in the art will recognize that the present invention may be embodied in forms other than those described above. The scope of the invention should be determined by the following claims and not the foregoing detailed description of the example embodiments.

