---

title: Hybrid parallelization strategies for machine learning programs on top of MapReduce
abstract: Hybrid parallelization strategies for machine learning programs on top of MapReduce are provided. In one embodiment, a method of and computer program product for parallel execution of machine learning programs are provided. Program code is received. The program code contains at least one parallel for statement having a plurality of iterations. A parallel execution plan is determined for the program code. According to the parallel execution plan, the plurality of iterations is partitioned into a plurality of tasks. Each task comprises at least one iteration. The iterations of each task are independent.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09286044&OS=09286044&RS=09286044
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09286044
owner_city: Armonk
owner_country: US
publication_date: 20140627
---
Embodiments of the present invention relate to parallel execution of machine learning programs and more specifically to hybrid parallelization strategies for machine learning programs on top of MapReduce.

According to one embodiment of the present invention a method of and computer program product for parallel execution of machine learning programs are provided. Program code is received. The program code contains at least one parallel for statement having a plurality of iterations. A parallel execution plan is determined for the program code. According to the parallel execution plan the plurality of iterations is partitioned into a plurality of tasks. Each task comprises at least one iteration. The iterations of each task are independent.

Large scale analytics on top of MapReduce MR is becoming more and more important for many organizations in order to gain value from huge amounts of collected data. Declarative machine learning ML on top of MapReduce MR may exploit data parallelism. The data parallel MR paradigm does not inherently support task parallelism. However many use cases in machine learning such as descriptive statistics cross validation or ensemble learning would benefit from task parallelism. Moreover requiring the user to choose a task parallelization strategy upfront i.e. an appropriate large scale algorithm implementation is often difficult in ad hoc analysis scenarios. Given a variety of use cases and workloads there is a strong need for different execution strategies and automatic optimization.

According to various embodiments of the present disclosure a systematic approach for combining task and data parallelism for large scale machine learning on top of MapReduce is provided. A dedicated ParFOR parallel for construct is employed such as may be used in high performance computing HPC . Optimal parallel execution plans are automatically created during runtime. The present disclosure includes methods for a complementary ParFOR runtime strategies on top of map reduce b access aware data partitioning and data locality c a memory and time based cost model for arbitrary ML programs and d an optimization framework for finding the optimal parallel execution plan of a ParFOR ML program including a heuristic optimizer as one embodiment of this general optimization framework.

Large scale data analytics has become an integral part of online services e commerce social media enterprise data management system management and scientific applications physics biology astronomy in order to gain value from huge amounts of collected data. Finding interesting unknown facts and patterns often requires analysis of a full data set instead of applying sampling techniques. This challenge may be addressed by leveraging parallel programming paradigms such as MapReduce MR its open source implementation Hadoop or more general data flow abstractions. These frameworks enable large scale fault tolerant and cost effective parallelization on commodity hardware. Furthermore high level languages may be used in order to overcome the complexity of multiple MR jobs per query. Examples of such languages include Jaql Pig and Hive each of which may compile queries to MR jobs. Thus these languages may provide low programming effort and good out of the box performance.

In addition to analyzing big data large scale analytics is driven by the increasing need for advanced analytics beyond traditional aggregation queries in terms of machine learning ML and content analysis. These analytics range from descriptive statistics to data mining techniques such as clustering classification association rule mining and forecasting. Typical applications are log and sales analysis recommendations and user classifications. While statistical tools such as R and Matlab may provide analysis libraries they are not designed for distributed computing on big data. Integrating such tools into higher level languages requires that the user to choose a parallelization strategy i.e. an appropriate large scale algorithm implementation upfront which is often difficult in ad hoc analysis scenarios.

SystemML enables declarative machine learning. Complex ML algorithms are expressed in a high level language including linear algebra operators called DML Declarative Machine learning Language and finally compiled to programs of MR jobs. This is comparable to high level languages such as Jaql Pig and Hive but domain specific for machine learning. Advantages of this approach include flexible specification of large scale ML algorithms and automatic cost based optimization.

An ML system on top of MapReduce faces the following two challenges. First for small datasets MR performance is often orders of magnitude worse than parallel in memory computation. The reasons include distributed operator implementations distributed local file system I O and MR framework overhead. Second the data parallel MR paradigm does not inherently support task parallelism for compute intensive workloads. However there are many use cases such as descriptive statistics cross validation or ensemble learning that would strongly benefit from task parallelism. One challenge is to provide efficiency and scalability for the full spectrum from many small to few very large tasks. Both problems of in memory computations and task parallelism are inter related due to memory constraints and can be jointly solved in a generic cost based optimization framework according to embodiments of the present disclosure.

With reference now to an exemplary SystemML Architecture according to embodiments of the present disclosure is shown. ML algorithms are expressed in a high level language with R like syntax the Declarative Machine learning Language DML . DML scripts are parsed to an internal representation of hierarchically structured statement blocks and statements where statement blocks are defined by the program structure. Each statement block is then compiled into DAGs of high level operators HOPs low level operators LOPs and finally to runtime plans of executable program blocks and instructions . At each step of this compilation process different optimizations are applied. Examples include constant folding propagation common subexpression elimination CSE operator ordering operator selection recompilation decisions and piggybacking packing multiple instructions into a single MR job . At runtime level the control program executes the hierarchy of program blocks and instructions. Instructions are either CP control program instructions that are locally executed in memory of the master process or MR instructions that are executed as part of generic MR jobs on a MapReduce cluster such as Hadoop submitted via MR job instructions. MR instructions work on blocks of the overall matrix. The exchange of intermediate results between MR jobs and CP instructions is done via file exchange over the distributed file system e.g. HDFS . A multi level buffer pool controls this exchange and in memory matrices. During runtime there are again several optimizations including decisions on dense sparse matrix block representations and dynamic recompilation.

In an example illustrating an execution model according to an embodiment of the present disclosure Pearson s Correlation Coefficient is computed r co X Y where X and Y are two mx1 vectors . In DML the two datasets are read from HDFS and the standard deviations are computed via the square root of the second central moment the covariance of X Y is computed and finally the correlation coefficient is written to HDFS. An exemplary script is provided at Inset 1.

Referring to since this script is parsed to a single statement block a single HOP DAG is created. For example the statement r cov X Y sigmaX sigmaY is compiled to three binary operators e.g. b b cov b as part of this DAG . On LOP level an execution strategy per operator is decided upon. If X and Y fit in memory those three HOPs may be compiled into a partial LOP DAG of BinaryCP CoVariance and BinaryCP . Otherwise the HOP b cov would be compiled to a LOP chain of CombineBinary aligns blocks of X and Y and CoVariance computes covariance incrementally . Finally a program block of executable CP MR instructions is created in which multiple MR instructions are packed into shared MR jobs. At runtime this program is sequentially executed with materialized intermediates between instructions.

This execution model exploits data parallelism via MR instructions whenever useful but results in a serial execution of independent tasks such as independent iterations. Hybrid ParFOR parallelization strategies are therefore provided herein for combining both task and data parallelism.

An exemplary taxonomy of task parallel ML programs is provided in Table 1. This taxonomy provides a basis for reasoning about classes of use cases. In this context data parallelism refers to operator or DAG level parallelization i.e. executing an operation on blocks of matrices in parallel. In contrast task parallelism refers to program level parallelization i.e. executing a complex ML program on iterations in parallel. The taxonomy of Table 1 employs two perspectives model and data oriented. First the model oriented perspective describes the ML algorithm specific statistical model. Multiple independent models inherently exhibit large potential for task parallelism. Examples are cross validation CV or ensemble learning EL . There are also many use cases of single composable models i.e. decomposable problems and aggregation of submodels that benefit from task parallelism. Example classes are 1 algorithms in statistical query model SQM summation form 2 partitioned matrix factorization via alternating least squares ALS expectation maximization EM or stochastic gradient decent SGD and 3 tree based algorithms like decision trees or Cascade support vector machines SVMs . Second the data oriented view describes the data access characteristics of iterations which may use disjoint overlapping or all data. Those data categories define applicable optimizations such as partitioning disjoint overlapping and memoization sharing overlapping all .

At the language level ParFOR is provided as a high level DML primitive for task parallelism. To assist in the below discussion of its parallel execution and optimization strategies a running example of a task parallel DML script is provided.

Inset 2 provides an extension of the correlation script of Inset 1 providing parallel correlation computation for all n n 1 2 pairs of columns of an m n input matrix D. It will be appreciated that this use case is analogous to cases involving more complex bivariate statistics.

The outer ParFOR loop iterates from 1 to n 1 and computes for the first column. Due to symmetry of r the inner loop only iterates from i 1 to n in order to compute rfor all pairs of columns. Below R i j v and v D i are referred to as left and right indexing respectively. The result is an upper triangular matrix R.

Given a variety of use cases and workloads there is a strong need for different parallel execution strategies. For example if there are many small pairs distributed in memory computation may be preferable but if there are few very large pairs scalable data parallel computation may be more important. Additional challenges of this example include 1 a triangular nested loop structure 2 a column wise data access on unordered data and 3 a bivariate all to all data shuffling pattern. Thus complex ParFOR programs and ad hoc data analysis with unknown input characteristics require automatic optimization.

Given a ParFOR body denoted prog a ParFOR predicate p a b z with lower bound a upper bound b and increment z as well as a cluster configuration cc find a parallel execution plan that minimizes the execution time T with Equation 1 where k is the degree of parallelism m is the memory consumption and ck cm being constraints. Note that the predicate p defines N b a 1 z iterations where a single iteration executes prog exactly once for a specific value of the index variable and prog p must create correct results min prog m cm Equation 1

In order to guarantee result correctness for parallel execution a loop dependency analysis is applied. Extended HPC compiler techniques are employed. For ensuring determinism and independence the existence of any inter iteration loop carried dependencies is disproved. A candidate based algorithm is applied based on the conceptual framework of linear functions. First a set of dependency candidates C is collected where a candidate c C is defined as a write to a non local variable. Second each candidate c C is checked via a sequence of tests scalar constant equals GCD Banerjee against all written and read variables of the ParFOR body. If independence for c cannot be proved it is added to C . For range set indexing artificial index variables and bounds are introduced according to the given range. By combining this into the linear function the existing tests can be transparently applied. Third if C there is no loop carried dependency and the test succeeds otherwise an error is raised.

The spectrum of use cases is supported with complementary ParFOR parallelization strategies. They all adhere to the conceptual master worker pattern iterations are logically grouped to tasks W k parallel workers execute those tasks and finally worker results are merged.

Task partitioning groups iterations to tasks with the contradictory objectives of 1 low task communication overhead via few tasks and 2 good load balance via many tasks . For example on MapReduce task setup can take seconds. However many tasks may be required to exploit large clusters. Load balancing is crucial because the most time consuming worker determines the overall execution time. A task w W may be modeled as a logical group of one or many sequentially executed iterations with task size l w where all iterations of one task are executed sequentially. Additionally W is defined as a set of disjoint tasks that exactly cover predicate p.

Fixed size task partitioning creates tasks with constant size l cl which represents a tradeoff between communication overhead and load balancing One extreme is na ve task partitioning with minimal task sizes of l 1 that leads to very good load balance but high communication overhead. Another extreme is static task partitioning with maximal task sizes of l N k that leads to very low communication overhead but potentially poor load balance.

Additionally in some embodiments a factoring self scheduling algorithm from the area of HPC is applied. Waves of exponentially decaying task sizes are used in order to achieve low communication overhead via large tasks at the beginning but good load balance via few small tasks at the end. Factoring computes the task size li for the next wave of k tasks based on remaining iterations as shown in Equation 2 with x 2 as suggested for unknown variability. As an example N 101 and k 4 results in a sequence of 13 13 13 13 7 7 7 7 3 3 3 3 2 2 2 2 1 iterations. For specific scenarios this may be extended constrained C C Factoring that additionally imposes either a minimum constraint l max l cmin e.g. for reduced communication overhead or a maximum constraint l min l cmax e.g. for upper bounded memory usage . Regarding communication overhead it is noteworthy that increases only logarithmically in N with O k logN k .

Factoring differs from guided self scheduling as used in OpenMP in executing waves of tasks with equal size which is more robust and naturally fits the MR execution model.

For task communication and execution set and range tasks are supported. Set tasks contain one or many values of the index variable while range tasks encode a sequence of values via a from to increment triple for compression if l 3.

With reference to embodiments of the present embodiment include LOCAL ParFOR ParFOR L execution as a first runtime strategy. This runtime strategy addresses the need for generality in terms of task parallelism for arbitrary body programs and arbitrary data sizes. This strategy exploits multicore parallelism by executing tasks concurrently as local threads within the JVM of control program e.g. SystemML s control program . This enables parallel execution within a single node with very low overhead and its generality allows arbitrary instructions and nested parallelism in the ParFOR body.

Local Parallel Workers are continuously running threads that execute one task and internally one iteration at a time until no more tasks are available in the task queue. Each worker gets a deep copy of the ParFOR body i.e. program blocks and instructions with unique file names and a shallow copy of the symbol table in order to ensure isolated intermediate results. Due to shared address space and copy on write semantics in SystemML in some embodiments a shallow copy of the symbol table is sufficient i.e. input matrices need not be copied. Every write then creates a new variable and replaces the reference to the shared variable within the worker local symbol table.

Task Scheduling assigns tasks to workers and is important for reducing wait times. The single task queue for all tasks of a ParFOR is a self scheduling approach. Since workers dequeue the next task whenever they finished a task temporal gaps between task execution are very low. The pull based task scheduling also leads to a good load balance which still depends on task partitioning because it determines the scheduling granularity. Finally this approach reduces the communication and scheduling overhead to a single synchronized dequeue operation per task.

In some embodiments Dynamic Recompilation re optimizes HOP DAGs during runtime according to the actual matrix characteristics. This enables handling of initial unknowns. ParFOR L includes two extensions First we evenly divide the context memory budget among the k worker threads. Second there is the danger of lock contention on the single HOP DAG. Hence we create deep copies of relevant DAGs for each worker and thus enable concurrent recompilation.

In order to complement the generality of local parallelism ParFOR L as described above with distributed in memory computation a second runtime strategy is provided REMOTE ParFOR ParFOR R . In ParFOR R ParFOR itself is executed as a single MR job and its body is executed as in memory CP instructions distributed on all nodes of the cluster. This ensures scalability for large or compute intensive problems.

The runtime architecture of ParFOR R according to embodiments of the present disclosure is shown in . First task partitioning is performed and the task sequence is serialized into a task file on HDFS. Second all dirty i.e. not up to date required input matrices are exported to HDFS. Third the ParFOR program body i.e. program blocks instructions and referenced DML external functions a shallow copy of the symbol table and internal configurations are serialized and stored in the MR job configuration. Fourth the MR job is submitted and its successful execution is awaited. Result matrices of individual tasks are directly written to HDFS but varname filename tuples are collected in the job output. This ensures output flexibility with fault tolerance. Fifth results are aggregated .

ParFOR R is a map only MR job whose input is the task file with one ParFOR task per line. In some embodiments the NLineInputFormat is used in order to initiate one map task per ParFOR task. The number of map tasks is therefore directly controlled via task partitioning where k is equal to the number of map slots in the cluster.

Remote Parallel Workers behave like local workers except for realizing the MR mapper interface. The worker is initialized by parsing the serialized program and creating program blocks instructions and a symbol table with unique file names. On each map the given task is parsed the program is executed for all iterations of that task and result variables are written to HDFS. If JVM reuse is enabled workers are reused in order to reuse cached input matrices and pre aggregate results. Finally MR instructions nested MR jobs are not allowed inside a remote worker because this incurs the danger of deadlocks if all map slots are occupied by ParFOR.

In some embodiments task scheduling is handed over to a MapReduce scheduler e.g. the Hadoop scheduler . The scheduler provides global scheduling for 1 the task and data parallel jobs as well as 2 other MR based applications on a shared cluster. This approach provides MR functionality such as fault tolerance data locality and an existing eco system. In some embodiments default schedulers such as fifo capacity and fair schedulers may be used. In other embodiments custom schedulers may be used. Since Hadoop sorts and executes input splits by decreasing size in some embodiments we ensure the order of the ParFOR tasks by padding range tasks with leading zeros to a constant size of log b 1 where b refers to the upper bound b of the ParFOR predicate p.

The generality of ParFOR allows the combination of parallel execution models as needed. Exemplary hybrid parallelization strategies are illustrated in where hybrid refers to combing 1 task and data parallelism 2 in memory and MR computation and 3 multi core and cluster parallelism.

Referring to a parallelization strategy for Parallel MR jobs according to an embodiment of the present disclosure is illustrated. If the ParFOR body contains operations on large data in memory operations cannot be run via ParFOR R. However ParFOR L exploits multi core parallelism for CP and MR job instructions and hence can run parallel MR jobs . This is beneficial for latency hiding and full resource exploitation. In the example of a 10 5 matrix D i.e. 10 pairs of 2 8 GB each two nested ParFOR L instance would be run. Thus MR jobs for indexing covariance and central moment of all pairs run in parallel. The best configuration e.g. number of reducers depends on the ParFOR degree of parallelism k and additional piggybacking opportunities across iterations may be possible.

Referring to a parallelization strategy for mixed nested parallelism according to embodiments of the present disclosure is illustrated. In the case of nested ParFOR where only the outer contains an MR job instruction ParFOR R may be used for the inner. This leads to parallel ParFOR MR jobs in parallel to the MR jobs from the outer. If there are only CP instructions a ParFOR R may be used for the outer. Within those map tasks multi threaded ParFOR L may additionally be used for the inner to exploit all resources.

The hybrid parallelization schemes presented in are exemplary. Alternative hybrid strategies may be adopted without departing from the present disclosure. Hybrid strategies provide the flexibility of creating efficient execution plans for complex ML algorithms.

After local or remote execution all worker results are consolidated which contributes to usability and performance. Result variables are the dependency candidates C i.e. updated non local matrices. Independence implies that worker results are disjoint. Two scenarios may be distinguished in both of which the original result matrix R still exists due to copy on write. First if R is empty copying all non zero values from all workers into the final result is all that is necessary. Second if R is non empty copying all zero and non zero values that differ from the original ones must be copied. One example is distributed matrix factorization where subblocks may be we iteratively modified in parallel. These two cases are referred to as being with and without compare.

In various embodiments of the present disclosure aggregation may be performed according to several schemes 1 local in memory 2 local file based or 3 parallel remote result aggregation. Local in memory pins R into memory creates the compare matrix if necessary and merges all worker results one at a time. This can be done in parallel and lock free if R is dense otherwise merging may be performed serially. Local file based uses a virtual staging file of directly accessible blocks which can be viewed as a radix sort of blocks. This out of core algorithm maps worker result blocks and potentially compare blocks to that structure and finally merges one result block at a time. Parallel remote uses a dedicated MR job whose inputs are the worker results and if necessary the compare matrix. Mappers then tag blocks as data or compare while reducers get the compare block and then merge one block at a time.

The above described runtime already provides high efficiency for compute intensive workloads. According to various embodiments of the present disclosure various additional runtime optimizations may be employed for very large input matrices.

For large matrices i.e. if the memory consumption of an operation exceeds the memory budget of the master node that operation is executed as an MR instruction in order to ensure robustness. In this case ParFOR R cannot be executed and so at least one MR job is executed per iteration and thus potentially many MR jobs that repeatedly scan the entire data. While there may often be very large input matrices individual ParFOR iterations work only on rows columns or blocks of moderate size. In those scenarios the MR job for repeated indexed access is one of the most expensive operations. To optimize such scenarios several strategies are adopted 1 to transparently partition the input matrix according to the access pattern and 2 to rewrite the body to direct indexed access of partitions.

Data partitioning is only applied for read only matrices and pure row or column wise access patterns. This ensures that no operation other than indexed access is affected. For each input matrix D all accesses in the ParFOR body are recursively analyzed. If there is a common row wise or column wise pattern this becomes the partitioning scheme. D is then partitioned accordingly into directly accessible files and index accesses are recompiled with a forced execution depending on the partition size.

According to various embodiments partitioning may be performed as local file based or parallel remote partitioning both of which create one SequenceFile per partition. Local file based is a two phase out of core algorithm that reads the input appends blocks to a partitioned staging file and finally creates a partitioned matrix. Parallel remote is a dedicated MR job where mappers do the partitioning on a block level and reducers write partitions. For high performance of partitioning and read block wise partitioning groups of rows or columns is also supported with a block size according to the HDFS block size.

Since ParFOR R uses a task file as the input Hadoop cannot co locate relevant map tasks to the input matrices or partitions. This leads to unnecessary data transfer because especially on large clusters data local access become unlikely.

Referring to exemplary Locality Reporting for X D i is illustrated. Location information of relevant matrices and partitions per logical task is explicitly provided in order to enable data locality. This is provided for the largest partitioned input matrix that is accessed via the iteration variable. A dedicated input format e.g. a specialized NLineInputFormat and input split e.g. a specialized FileSplit are used. Whenever splits are requested from this input format the matrix partitioning information is analyzed and a wrapper split is created around each original file split. Instead of reporting the location of the small task file splits 1 the logical task one per split is parsed 2 locations of all related partition files are determined 3 frequencies are counted and 4 the top k frequent nodes are reported as locations. Since Hadoop treats all reported locations equally in some embodiments only the hosts with top 1 frequency are reported as shown in . For range tasks heuristic analysis is performed only of locations of the first and last iteration because locality is examined serially before job submission.

During initial compilation important matrix characteristics and the ParFOR problem size N might be unknown. In some embodiments ParFOR optimization is therefore applied as a second optimization phase at runtime for each top level ParFOR. The plan representation and related optimization problem may be defined in terms of a plan tree.

A Plan Tree P is a tree of nodes n with height h modeling ParFOR and its body prog. Inner nodes are program blocks and refer to an unordered set of child nodes c n where edges represent containment relationships. Leaf nodes are operations. Nodes have a node type nt an execution type et a degree of parallelism k and specific attributes A. P spans a non empty set of execution contexts where the root node r P and specific et define a context with memory cmand parallelism ckconstraints. Shared resources are global constraints.

Referring to a plan tree structure may be used to represent arbitrary ParFOR programs. shows the plan tree P of a running example Inner nodes refer to ParFOR and generic program blocks leaf nodes refer to operations HOPs in this case . The root node defines the context of the master process with its constraints e.g. the max JVM size . Since the nested ParFOR has et MR there is a second context of the map task process. There exists a mapping from nodes in P to HOP DAGs and runtime plans.

The plan tree optimization problem may be defined in terms of the plan tree. Given an initial plan tree P which is assumed to be the optimal sequential plan per program block transform P into a semantically equivalent plan tree P that is optimal w.r.t. Equation 3. min circumflex over Equation 3

Thus the goal is to minimize the execution time of the plan tree s root node circumflex over T r P under the hard constraints of maximum total memory consumption circumflex over M r ec and maximum total parallelism K r ec per execution context ec. Valid transformations are node operator selection et node configuration changes k A and structural changes of P.

In contrast to alternative query optimization P covers 1 a complex ML program with control flow linear algebra operators task and data parallelism which require dedicate rewrites and cost modeling and 2 hard constraints which require dedicated search strategies and cost estimation.

The plan tree optimization problem is a multiple knapsack problem with multiple constraints which is known to be NP hard. Its specific properties are a variable hierarchy of items and knapsacks as well as multiple variable capacity constraints. In detail n is an item and circumflex over T n is the item value. Each context ec defines a knapsack with constraints emand ck. P with defines the item and knapsack hierarchies where multiple knapsacks share common constraints e.g. cluster parallelism .

As a precondition for optimization a cost model and accurate estimates are required. According to objective there are different requirements on those estimates. A soft constraint is imposed on execution time. However worst case estimates for memory and parallelism are necessary to guarantee those hard constraints This is important for preventing out of memory situations. Furthermore the analytical cost model should allow costing arbitrary plan alternatives.

Memory estimation for leaf nodes of a plan tree works on HOP DAGs. Estimates are provided for CP operations as well as block computations in MR. For each DAG a bottom up approach of recursively propagating matrix characteristics and estimating memory is used.

Matrix characteristics for memory estimates include the matrix dimensions d dand the matrix sparsity d. For worst case memory estimates worst case estimates for those characteristics are also required. Fortunately many operators of linear algebra e.g. matrix multiplication allow to exactly infer their output dimensions. Inferring the sparsity is more difficult due to potential skew but there are for example sparsity preserving operations such as s X s 0 NaN . Finally for unknown characteristics it is assumed that d d and d 1.

Based on worst case matrix characteristics which have been propagated through the DAG the output memory circumflex over M out n and operation memory circumflex over M n may be computed according to Equation 4 where dense matrices are double arrays and sparse matrices use compressed rows of column index value pairs. This estimate reflects the runtime model of CP instructions that pin all inputs and outputs in memory. Hence the memory estimate is the sum of all input intermediate depending on intra operation parallelism k and output sizes.

The worst case memory estimate of a leaf node of P is then defined as the operation memory estimate circumflex over M n of its mapped HOP if et CP and as a constant Mif et MR because then it is executed in a separate context.

To make an accurate estimate of time for leaf nodes of a plan tree runtime properties of operators must be taken into account. Thus the below detailed approach leverages offline performance profiling of runtime instructions performed once for a cluster configuration.

Performance profiling measures circumflex over T of all relevant instructions Op for a set of variables where we vary one variable at a time. Different execution types and matrix representations are modeled as different instructions. Polynomial regression models are created as cost functions C v for each v Op combination. The profile is the set of C v for all .

Scaling one dimensional cost functions makes a fundamental independence assumption which is important for efficient profiling but can lead to low accuracy. Correction terms based on ratios of number of floating point operations are therefore used e.g. for matrix shape adjustments. This correction enables high accuracy due to a shape dependent asymptotic behavior. For example consider a matrix multiplication AB where each matrix has 10cells i.e. 8 MB. Multiplying two 1 000 1 000 matrices requires 2 GFlop while a dot product of 10 1 vectors requires only 2 MFlop i.e. a relative difference of 10. Thus scaled cost functions allow the accurate estimation of time even for different behavior of dense sparse operations.

Referring to time estimates are depicted according to embodiments of the present disclosure. Assume a query Q with q 700 000 q 1 000 q 700 and q 0.7 for CP dense transpose self matrix multiplication XX. Further assume cost functions for datasize f d and sparsity f s created with squared matrices and defaults d 500 000 and d 0.5. First fis picked as the leading dimension yielding f q 325 ms. Then it is scaled to circumflex over T q q circumflex over T q f q f d 438 ms as shown in . Then a correction is performed circumflex over T circumflex over T q q corr Q yielding circumflex over T 366 ms. Finally the time estimates are assigned from mapped HOPs and instructions to plan tree leaf nodes again.

Memory and time estimates for arbitrary complex programs may be determined by aggregating leaf node estimates. The worst case estimate of memory consumption for a ParFOR node is computed with Equation 6 as the number of workers times the most memory consuming operation since those operations are executed sequentially.

The memory estimate for all other inner nodes for while if func and generic is circumflex over M n maxcircumflex over M c . One challenge is to incorporate shared reads into memory estimates in order to prevent large overestimation. This is done by splitting circumflex over M into shared circumflex over M and non shared circumflex over M parts and scaling circumflex over M by the number of consumers.

Average case time estimates are similarly aggregated as the sum of child node time estimates due to sequential execution. In detail the time estimates are given by Equation 7. Since circumflex over N cannot be determines for while and unknown for parfor it is estimated as a constant circumflex over N Nthere. This reflects at least that the body is likely executed multiple times. Furthermore the time estimate of an if is a weighted sum because only one branch is executed at a time.

Finally total parallelism is also aggregated with K n k maxK c . For excluding remote parallelism K n 1 if et MR.

According to embodiments of the present disclosure algorithms are provided for finding optimal parallel execution plans. Due to the large search space a spectrum of optimizers is provided with different complexity. Each optimizer is characterized by 1 the used cost model 2 the rewrites that define the search space and 3 the search strategy. In the following a default heuristic optimizer and requirements for more advanced optimizers are provided.

An heuristic optimizer according to embodiments of the present disclosure uses a time and memory based cost model without shared reads heuristic high impact rewrites and a transformation based search strategy with global optimization scope. The time based cost model enables accurate estimates but requires a pre created profile. If no profile exists a memory based cost model is used and instead of time estimates additional heuristic including that local in memory computations require less time than their MR alternatives.

The search space is defined by a variety of ParFOR specific heuristic rewrites. These include rewrites regarding ParFOR parallelization strategies and rewrites exploiting repeated parallel iteration execution. Examples for ParFOR centric rewrites include operator selection such as selecting the ParFOR execution type et CP MR i.e. ParFOR L vs ParFOR R task partitioning and result aggregation methods. Example configuration changes include choosing the degree of parallelism k and task sizes. Structural plan changes include artificial nested ParFOR for multi threaded map tasks unfolding ParFOR in recursive functions and changing ParFOR to for. Second examples for iteration aware rewrites include operator selection like data partitioning where the partitioning format partitioning method and execution type are chosen et of left and right indexing. Example configuration changes include choosing matrices for co location and changing the partition replication factor r. Most of these rewrites need to take the entire plan tree P into account.

A transformation based top down search strategy may be used that transforms P and its mapped program into P . This follows the fundamental heuristic to apply available parallelism as high as possible in the plan tree to cover more operations and reduce synchronization. This approach uses a well defined rewrite order. First data flow rewrites are applied that change the memory estimates of P. This includes data and result partitioning because related indexed reads writes are potentially recompiled to in memory operations. Second a recursive decision is made starting at the root of P on ParFOR execution type and degree of parallelism. Based on memory constraints and estimates the maximum parallelism to apply per level can be directly computed. Third for all subtrees rooted by ParFOR execution type specific rewrites are applied. For ParFOR L this includes task partitioner and recompilation budget while for ParFOR R this includes data colocation replication factors nested ParFOR and task partitioner. Fourth result merge strategies are decided on recursive functions are handled and unnecessary ParFOR are recompiled to for. The majority of rewrites has a complexity of with exceptions of up to . This strategy finds the optimal plan according to the heuristically restricted search space but guarantees all constraints of .

Referring now to a schematic of an example of a computing node is shown. Computing node is only one example of a suitable computing node and is not intended to suggest any limitation as to the scope of use or functionality of embodiments of the invention described herein. Regardless computing node is capable of being implemented and or performing any of the functionality set forth hereinabove.

In computing node there is a computer system server which is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with computer system server include but are not limited to personal computer systems server computer systems thin clients thick clients handheld or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputer systems mainframe computer systems and distributed cloud computing environments that include any of the above systems or devices and the like.

Computer system server may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types. Computer system server may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

As shown in computer system server in computing node is shown in the form of a general purpose computing device. The components of computer system server may include but are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to processor .

Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus.

Computer system server typically includes a variety of computer system readable media. Such media may be any available media that is accessible by computer system server and it includes both volatile and non volatile media removable and non removable media.

System memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . Computer system server may further include other removable non removable volatile non volatile computer system storage media. By way of example only storage system can be provided for reading from and writing to a non removable non volatile magnetic media not shown and typically called a hard drive . Although not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to bus by one or more data media interfaces. As will be further depicted and described below memory may include at least one program product having a set e.g. at least one of program modules that are configured to carry out the functions of embodiments of the invention.

Program utility having a set at least one of program modules may be stored in memory by way of example and not limitation as well as an operating system one or more application programs other program modules and program data. Each of the operating system one or more application programs other program modules and program data or some combination thereof may include an implementation of a networking environment. Program modules generally carry out the functions and or methodologies of embodiments of the invention as described herein.

Computer system server may also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with computer system server and or any devices e.g. network card modem etc. that enable computer system server to communicate with one or more other computing devices. Such communication can occur via Input Output I O interfaces . Still yet computer system server can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted network adapter communicates with the other components of computer system server via bus . It should be understood that although not shown other hardware and or software components could be used in conjunction with computer system server . Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems etc.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

The descriptions of the various embodiments of the present invention have been presented for purposes of illustration but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to best explain the principles of the embodiments the practical application or technical improvement over technologies found in the marketplace or to enable others of ordinary skill in the art to understand the embodiments disclosed herein.

