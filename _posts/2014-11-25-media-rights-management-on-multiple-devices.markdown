---

title: Media rights management on multiple devices
abstract: Media rights are managed to include not just device authentication, but to include elements of user, device, and service authorization. A user can play media on a mobile device, continue playing the media on a desktop computer, and subsequently move to a large screen television and media rights are automatically identified to provide the most appropriate authorized content. This allows an authorized user to seamlessly access different forms of the same content on a variety of authenticated devices using the same digital rights management mechanisms.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09223944&OS=09223944&RS=09223944
owner: MobiTV, Inc.
number: 09223944
owner_city: Emeryville
owner_country: US
publication_date: 20141125
---
The present application is a continuation of and claims priority to U.S. patent application Ser. No. 13 220 435 titled MEDIA RIGHTS MANAGEMENT ON MULTIPLE DEVICES filed Aug. 29 2011 which claims the benefit of priority under 35 U.S.C. 119 e to U.S. Provisional Application No. 61 378 189 titled MEDIA RIGHTS MANAGEMENT ON MULTIPLE DEVICES filed Aug. 30 2010 the entirety of which is incorporated in its entirety by this reference for all purposes.

Rights management for television or video services commonly relies on device or regional authentication. A set top box may be authorized to receive a particular set of channels. Different viewers using the same set top box can all view those channels regardless of what the set top box is connected to. In other examples a user may enter a name and password to get access to particular downloadable content. The content can then be viewed on any number of computer systems and devices.

However mechanisms for managing media rights across devices are limited. Consequently it is desirable to provide improved mechanisms for media rights management.

Reference will now be made in detail to some specific examples of the invention including the best modes contemplated by the inventors for carrying out the invention. Examples of these specific embodiments are illustrated in the accompanying drawings. While the invention is described in conjunction with these specific embodiments it will be understood that it is not intended to limit the invention to the described embodiments. On the contrary it is intended to cover alternatives modifications and equivalents as may be included within the spirit and scope of the invention as defined by the appended claims.

For example the techniques of the present invention will be described in the context of a particular type of encoding. However it should be noted that the techniques of the present invention apply to a wide variety of encoding mechanisms. In the following description numerous specific details are set forth in order to provide a thorough understanding of the present invention. Particular example embodiments of the present invention may be implemented without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present invention.

Various techniques and mechanisms of the present invention will sometimes be described in singular form for clarity. However it should be noted that some embodiments include multiple iterations of a technique or multiple instantiations of a mechanism unless noted otherwise. For example a system uses a processor in a variety of contexts. However it will be appreciated that a system can use multiple processors while remaining within the scope of the present invention unless otherwise noted. Furthermore the techniques and mechanisms of the present invention will sometimes describe a connection between two entities. It should be noted that a connection between two entities does not necessarily mean a direct unimpeded connection as a variety of other entities may reside between the two entities. For example a processor may be connected to memory but it will be appreciated that a variety of bridges and controllers may reside between the processor and memory. Consequently a connection does not necessarily mean a direct unimpeded connection unless otherwise noted.

Media rights are managed to include not just device authentication but to include elements of user device and service authorization. A user can play media on a mobile device continue playing the media on a desktop computer and subsequently move to a large screen television and media rights are automatically identified to provide the most appropriate authorized content. This allows an authorized user to seamlessly access different forms of the same content on a variety of authenticated devices using the same digital rights management mechanisms.

Rights management for conventional for television or video services is typically limited to device authentication or regional authentication. A set top box is authenticated to receive certain channel packages. A digital video disc DVD player is authenticated to play DVDs for a particular region. A television receives broadcasts of games that are not under black out for the region. However it is recognized right management can be more fine tuned than rough rights management using device or regional authentication. For example a user watching a program on a single user mobile device may want to seamlessly continue watching the program on a multiple user large screen television that may or may not reside in the same geographic region. Conventional authentication and media rights management mechanisms do not efficiently handle authentication and authorization across multiple disparate devices in a variety of locations some of which may be shared by multiple users.

According to various embodiments user authorization and device authentication are separated. In particular embodiments a user is authorized on multiple devices or multiple devices may be registered so that user impact is minimal. On a multiple user device such as a set top box a user can log in for every session or for as long as the device is operating. A particular pin or password may be used on a set top box for the user to access personalized content or content particular to the user.

In particular embodiments content is managed so that there is an identification of what the user is authorized to view on what devices at what quality levels and when. In some examples a user may be authorized to view an entire channel package in low resolution but only particular channels in high resolution. In other examples a user may be authorized to view a particular program on a personalized device such as a mobile phone or a computer but not on a multiple user device such as a set top box. In still other examples a user may be allowed to view a program for a week on a large screen television using WiFi but forever on a mobile device. In yet other examples a user may be able to access a ringtone version of a piece of media content but not a full version of the content.

According to various embodiments a user may have unlimited access to all content across all devices but only when the user is in the vicinity of the device based on mobile device location data. In particular embodiments authorizing a service includes keeping track of what products channel packages content packages media programs etc. that the user has purchased or rented and for how many devices simultaneously. In some examples content may be authorized only if the device is located in a particular area and black outs could be managed by limiting content in certain locations but allowing the same content when a mobile device moves to another region. Black outs could also be managed by allowing payment for viewing in a region under black out restrictions.

According to various embodiments the same digital rights management DRM technology is used on all platforms. In particular embodiments content is purchased with a particular level of rights. The content purchased is associated with fields that identify the level of rights for the user. In particular embodiments a user may have purchased a television program at a particular quality level and resolution for viewing on up to two devices simultaneously forever. In another example a user may have purchased a movie at all quality levels for viewing on any one authenticated device.

A variety of mechanisms are used to deliver media streams to devices. In particular examples a client establishes a session such as a Real Time Streaming Protocol RTSP session. A server computer receives a connection for a media stream establishes a session and provides a media stream to a client device. The media stream includes packets encapsulating frames such as MPEG 4 frames. The MPEG 4 frames themselves may be key frames or differential frames. The specific encapsulation methodology used by the server depends on the type of content the format of that content the format of the payload and the application and transmission protocols being used to send the data. After the client device receives the media stream the client device decapsulates the packets to obtain the MPEG frames and decodes the MPEG frames to obtain the actual media data.

Conventional MPEG 4 files require that a player parse the entire header before any of the data can be decoded. Parsing the entire header can take a notable amount of time particularly on devices with limited network and processing resources. Consequently the techniques and mechanisms of the present invention provide a fragmented MPEG 4 framework that allows playback upon receiving a first MPEG 4 file fragment. A second MPEG 4 file fragment can be requested using information included in the first MPEG 4 file fragment. According to various embodiments the second MPEG 4 file fragment requested may be a fragment corresponding to a higher or lower bit rate stream than the stream associated with the first file fragment.

MPEG 4 is an extensible container format that does not have a fixed structure for describing media types. Instead MPEG 4 has an object hierarchy that allows custom structures to be defined for each format. The format description is stored in the sample description stsd box for each stream. The sample description box may include information that may not be known until all data has been encoded. For example the sample description box may include an average bit rate that is not known prior to encoding.

According to various embodiments MPEG 4 files are fragmented so that a live stream can be recorded and played back in a close to live manner. MPEG 4 files can be created without having to wait until all content is written to prepare the movie headers. To allow for MPEG 4 fragmentation without out of band signaling a box structure is provided to include synchronization information end of file information and chapter information. According to various embodiments synchronization information is used to synchronize audio and video when playback entails starting in the middle of a stream. End of file information signals when the current program or file is over. This may include information to continue streaming the next program or file. Chapter information may be used for video on demand content that is broken up into chapters possibly separated by advertisement slots.

TCP is more widely used than UDP and networking technologies including switch load balancer and network card technologies are more developed for TCP than for UDP. Consequently techniques and mechanisms are provided for delivering fragmented live media over TCP. Sequence information is also maintained and or modified to allow seamless client device operation. Timing and sequence information in a media stream is preserved.

Requests are exposed as separate files to clients and files should playback on players that handle fragmented MPEG 4. Live or near live video on demand VOD and digital video record DVR content can all be handled using fragmentation.

According to various embodiments playback stoppage is detected at a content server or fragmentation server. In some examples a device sends a playback stoppage request. In other examples a content server detects that a subsequent fragment request has not been received. The content server maintains user information and media stream position information. In some examples the content server also maintains device information and quality or bit rate data. When a request for a fragment or a resume request is received from the same device or from a different device associated with the same user the content server identifies bit rate and the media stream along with the appropriate fragment to send to the user. The fragment may correspond to media data transmitted in the past as a live feed and may no longer be live but the user is able to continue viewing the media stream in a seamless manner at a resolution appropriate for a current viewing device.

The request from the device may include a bit rate and resolution or a content server may identify an appropriate bit rate and resolution using device information. A resume request along with a desired bit rate may also be received from a different device associated with a user. Fragments maintained at a content server may be used to respond to requests from numerous users on a variety of devices requesting playback of media streams at different points in time and at different quality levels. According to various embodiments fragments can be maintained once at different quality levels and cached efficiently even though a variety of disparate requests for the same or different media streams will be received.

The fragment server provides the caching layer with fragments for clients. The design philosophy behind the client server API minimizes round trips and reduces complexity as much as possible when it comes to delivery of the media data to the client . The fragment server provides live streams and or DVR configurations.

The fragment controller is connected to application servers and controls the fragmentation of live channel streams. The fragmentation controller optionally integrates guide data to drive the recordings for a global network DVR. In particular embodiments the fragment controller embeds logic around the recording to simplify the fragment writer component. According to various embodiments the fragment controller will run on the same host as the fragment writer . In particular embodiments the fragment controller instantiates instances of the fragment writer and manages high availability.

According to various embodiments the client uses a media component that requests fragmented MPEG 4 files allows trick play and manages bandwidth adaptation. The client communicates with the application services associated with HTTP proxy to get guides and present the user with the recorded content available.

The fragment server provides the caching layer with fragments for clients. The design philosophy behind the client server API minimizes round trips and reduces complexity as much as possible when it comes to delivery of the media data to the client . The fragment server provides VoD content.

According to various embodiments the client uses a media component that requests fragmented MPEG 4 files allows trick play and manages bandwidth adaptation. The client communicates with the application services associated with HTTP proxy to get guides and present the user with the recorded content available.

According to various embodiments the fragment writer command line arguments are the SDP file of the channel to record the start time end time name of the current and next output files. The fragment writer listens to RTP traffic from the live video encoders and rewrites the media data to disk as fragmented MPEG 4. According to various embodiments media data is written as fragmented MPEG 4 as defined in MPEG 4 part 12 ISO IEC 14496 12 . Each broadcast show is written to disk as a separate file indicated by the show ID derived from EPG . Clients include the show ID as part of the channel name when requesting to view a prerecorded show. The fragment writer consumes each of the different encodings and stores them as a different MPEG 4 fragment.

In particular embodiments the fragment writer writes the RTP data for a particular encoding and the show ID field to a single file. Inside that file there is metadata information that describes the entire file MOOV blocks . Atoms are stored as groups of MOOF MDAT pairs to allow a show to be saved as a single file. At the end of the file there is random access information that can be used to enable a client to perform bandwidth adaptation and trick play functionality.

According to various embodiments the fragment writer includes an option which encrypts fragments to ensure stream security during the recording process. The fragment writer will request an encoding key from the license manager. The keys used are similar to that done for DRM. The encoding format is slightly different where MOOF is encoded. The encryption occurs once so that it does not create prohibitive costs during delivery to clients.

The fragment server responds to HTTP requests for content. According to various embodiments it provides APIs that can be used by clients to get necessary headers required to decode the video seek to any desired time frame within the fragment and APIs to watch channels live. Effectively live channels are served from the most recently written fragments for the show on that channel. The fragment server returns the media header necessary for initializing decoders particular fragments and the random access block to clients. According to various embodiments the APIs supported allow for optimization where the metadata header information is returned to the client along with the first fragment. The fragment writer creates a series of fragments within the file. When a client requests a stream it makes requests for each of these fragments and the fragment server reads the portion of the file pertaining to that fragment and returns it to the client.

According to various embodiments the fragment server uses a REST API that is cache friendly so that most requests made to the fragment server can be cached. The fragment server uses cache control headers and ETag headers to provide the proper hints to caches. This API also provides the ability to understand where a particular user stopped playing and to start play from that point providing the capability for pause on one device and resume on another .

http HOSTNAME frag CHANNEL BITRATE ID COMMAND ARG e.g. http frag.hosttv.com frag 1 H8QVGAH264 1270059632.mp4 fragment 42. According to various embodiments the channel name will be the same as the backend channel name that is used as the channel portion of the SDP file. VoD uses a channel name of vod . The BITRATE should follow the BITRATE RESOLUTION identifier scheme used for RTP streams. The ID is dynamically assigned. For live streams this may be the UNIX timestamp for DVR this will be a unique ID for the show for VoD this will be the asset ID. The ID is optional and not included in LIVE command requests. The command and argument are used to indicate the exact command desired and any arguments. For example to request chunk this portion would be fragment 42 .

The URL format makes the requests content delivery network CDN friendly because the fragments will never change after this point so two separate clients watching the same stream can be serviced using a cache. In particular the headend architecture leverages this to avoid too many dynamic requests arriving at the Fragment Server by using an HTTP proxy at the head end to cache requests.

According to various embodiments the fragment controller is a daemon that runs on the fragmenter and manages the fragment writer processes. We propose that it uses a configured filter that is executed by the Fragment Controller to generate the list of broadcasts to be recorded. This filter integrates with external components such as a guide server to determine which shows to record and the broadcast ID to use.

According to various embodiments the client includes an application logic component and a media rendering component. The application logic component presents the UI for the user and also communicates to the front end server to get shows that are available for the user and to authenticate. As part of this process the server returns URLs to media assets that are passed to the media rendering component.

In particular embodiments the client relies on the fact that each fragment in a fragmented MP4 file has a sequence number. Using this knowledge and a well defined URL structure for communicating with the server the client requests fragments individually as if it was reading separate files from the server simply by requesting urls for files associated with increasing sequence numbers. In some embodiments the client can request files corresponding to higher or lower bit rate streams depending on device and network resources.

Since each file contains the information needed to create the URL for the next file no special playlist files are needed and all actions startup channel change seeking can be performed with a single HTTP request. After each fragment is downloaded the client assesses among other things the size of the fragment and the time needed to download it in order to determine if downshifting is needed or if there is enough bandwidth available to request a higher bit rate.

Because each request to the server looks like a request to a separate file the response to requests can be cached in any HTTP Proxy or be distributed over any HTTP based CDN.

The fragment may be cached for a short period of time at caching layer . The mediakit identifies the fragment number and determines whether resources are sufficient to play the fragment. In some examples resources such as processing or bandwidth resources are insufficient. The fragment may not have been received quickly enough or the device may be having trouble decoding the fragment with sufficient speed. Consequently the mediakit may request a next fragment having a different data rate. In some instances the mediakit may request a next fragment having a higher data rate. According to various embodiments the fragment server maintains fragments for different quality of service streams with timing synchronization information to allow for timing accurate playback.

The mediakit requests a next fragment using information from the received fragment. According to various embodiments the next fragment for the media stream may be maintained on a different server may have a different bit rate or may require different authorization. Caching layer determines that the next fragment is not in cache and forwards the request to fragment server . The fragment server sends the fragment to caching layer and the fragment is cached for a short period of time. The fragment is then sent to mediakit .

According to various embodiments synchronization information is used to synchronize audio and video when playback entails starting in the middle of a stream. End of file information signals when the current program or file is over. This may include information to continue streaming the next program or file. Chapter information may be used for video on demand content that is broken up into chapters possibly separated by advertisement slots.

At the transmitted fragment is maintained in cache for a limited period of time. At a request for a subsequent fragment is received. According to various embodiments the subsequent fragment a fragment number directly related to the fragment previously transmitted. In some examples the client device may request a different bit rate or may request the same bit rate. At it is determined if a fragment with the appropriate fragment number is available in cache. Otherwise the bit rate and fragment number are determined in order to obtain the appropriate fragment at . In some examples the fragment number is one greater than the fragment number for the previous fragment transmitted.

In some examples the client device may request a significantly different fragment number corresponding to a different time index. This allows a client device to not only quality shift by requesting a different bit rate but time shift as well by requesting a prior segment already transmitted previously. According to various embodiments a current fragment for the media stream is obtained and sent with a fragment number and a box structure supporting synchronization information chapter information and end of file information at .

According to various embodiments synchronization information is used to synchronize audio and video when playback entails starting in the middle of a stream. End of file information signals when the current program or file is over. This may include information to continue streaming the next program or file. Chapter information may be used for video on demand content that is broken up into chapters possibly separated by advertisement slots.

At playback stoppage is identified. Playback stoppage may be identified by a client device request to stop playback. In other embodiments playback stoppage may be identified when a content server does not receive a request for additional media fragments within a predetermined period of time from the client device. In still other embodiments playback stoppage may be identified when a content server does not receive an appropriate acknowledgement from a client device. At user and media position information is maintained. In some embodiments bit rate version device and other quality and location information can be maintained.

At a request for a subsequent media fragment is received from a user. According to various embodiments the request is received from a different device or may be received over network conditions that now support a different bit rate. At the user device and bit rate authorized are identified. According to various embodiments user and media position information is obtained. At the fragment with a subsequent fragment number corresponding to the maintained media position information is sent with a box structure supporting synchronization information chapter information and end of file information. In some examples not all synchronization information chapter information and end of file information needs to be sent. In some examples the box structure may only include synchronization information while supporting but not including other types of information.

Particular examples of interfaces supports include Ethernet interfaces frame relay interfaces cable interfaces DSL interfaces token ring interfaces and the like. In addition various very high speed interfaces may be provided such as fast Ethernet interfaces Gigabit Ethernet interfaces ATM interfaces HSSI interfaces POS interfaces FDDI interfaces and the like. Generally these interfaces may include ports appropriate for communication with the appropriate media. In some cases they may also include an independent processor and in some instances volatile RAM. The independent processors may control such communications intensive tasks as packet switching media control and management.

According to various embodiments the system is a fragment server that also includes a transceiver streaming buffers and a program guide database. The fragment server may also be associated with subscription management logging and report generation and monitoring capabilities. In particular embodiments functionality for allowing operation with mobile devices such as cellular phones operating in a particular cellular network and providing subscription management. According to various embodiments an authentication module verifies the identity of devices including mobile devices. A logging and report generation module tracks mobile device requests and associated responses. A monitor system allows an administrator to view usage patterns and system availability. According to various embodiments the fragment server handles requests and responses for media content related transactions while a separate streaming server provides the actual media streams.

Although a particular fragment server is described it should be recognized that a variety of alternative configurations are possible. For example some modules such as a report and logging module and a monitor may not be needed on every server. Alternatively the modules may be implemented on another device connected to the server. In another example the server may not include an interface to an abstract buy engine and may in fact include the abstract buy engine itself. A variety of configurations are possible.

In the foregoing specification the invention has been described with reference to specific embodiments. However one of ordinary skill in the art appreciates that various modifications and changes can be made without departing from the scope of the invention as set forth in the claims below. Accordingly the specification and figures are to be regarded in an illustrative rather than a restrictive sense and all such modifications are intended to be included within the scope of invention.

