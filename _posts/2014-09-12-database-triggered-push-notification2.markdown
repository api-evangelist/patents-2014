---

title: Database triggered push notification
abstract: Systems and methods of database triggered push notification are disclosed. In one aspect, data from a database entity is cached in response to executing user service request at a client session, where the service request involves information from the database entity. In response to caching the data from the database entity, the client session subscribing to a messaging channel dedicated to the database entity. In another aspect, a message is generated as a result of invoking a trigger by an operation in the database entity. In yet another aspect, the message is transported by the messaging channel to the subscribed client session to invoke refresh of the cached data. A push notification is sent to the client in response to the message.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09654576&OS=09654576&RS=09654576
owner: SAP SE
number: 09654576
owner_city: Walldorf
owner_country: DE
publication_date: 20140912
---
One of the current trends in business applications is the demand to manage data which is rapidly increasing in both volume and complexity e.g. the so called Big Data environments. At the same time enterprises look for opportunities to simplify and make their operations more efficient. The modernization of the information systems is a crucial factor. The adoption of new technologies such as in memory databases mobile business applications cloud computing etc. offer the means for improving business processes and overall enterprise efficiency which also helps to introduce new services to customers lower costs and ensure competitive advantage by better market positioning.

One way to improve and simplify the management of voluminous and complex data is to work with subsets or snapshots of data focusing on select database entities. Such entities could be different structures tables views etc. which are read from a database and stored in a cache e.g. in operative memory as application context. Furthermore most of the resource consuming calculations could take place directly within the databases e.g. as a stored procedure which is especially efficient for in memory database solutions. Additionally the cached data and the actions applied on the data can be displayed using user interfaces of lightweight client applications on various network enabled client devices.

As the database entities can change dynamically the cached and displayed data should be frequently refreshed to minimize any risks to data consistency e.g. caused by stored database calculations various operations on the cached data etc. Usually the cached database entities are re checked re read as frequently as reasonable and feasible wherein the smaller intervals between refreshing the cached data lowers the risk for data inconsistency but increases system load.

Embodiments of techniques for database triggered push notification are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the ideas presented can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

The server system and the database may provide various enterprise services to local or remote users requesting and or consuming the services through client systems . Such services may include business applications such as Enterprise Resource Planning ERP Customer Relationship Management CRM various data analytics applications etc. The services could be provided as on premise solutions e.g. within the enterprise information systems landscape at client systems and . Alternatively or in addition the services could be provided as cloud based services e.g. via cloud infrastructure at client systems and where server system and or database may be configured as cloud based infrastructure.

In one embodiment a user operating at one or more of client systems interacts with at least one user interface UI UI UI and or UI provided by a corresponding client application browser client app browser and or client app respectively . The UIs and may provide users with access to information and functionalities of server system . Generally some UIs e.g. and can be provided or generated by client applications e.g. and specifically built for rendering and handling UIs to enable a predefined set of services. Other UIs e.g. and can be implemented as extensions or plug ins to more general client applications such as internet browsers e.g. and . Sometimes such applications or application extensions providing specific UIs are referred to as UI agents.

A UI agent or may include functionalities for connecting to server system and or database in addition to rendering the corresponding UI or on a display device of the client system or . For example the UI agent may handle setting up a dedicated communication connection between the UI agent e.g. or and the target server system e.g. and authenticating a user to the server system e.g. . In some environments setting up such a UI communication connection may include the generation of a corresponding proxy session at the server system for executing the functions requested through the UI agent or . In these proxies are illustrated with sessions and which correspond and may be dedicated to UI agents and respectively. Such sessions may be also referred to as UI sessions.

Application sessions and may correspond to UI agents generated by specifically built client applications and respectively while HTTP from Hypertext Transfer Protocol sessions and may be generated for UI agents built in browsers and respectively according to one embodiment. Sessions specific to cloud clients may be generated as well e.g. and . In one embodiment when a client UI agent is instantiated the instantiation of a corresponding UI session at the server system is requested to handle the functionalities associated with servicing user requests such as displaying data executing business transactions etc.

When a specific service or services are requested by a user is associated with accessing data e.g. stored at database information pertinent to the service may be cached at a particular session handling the requests. Thus the requests could be executed much faster especially in Big Data scenarios as the cache is usually stored in volatile memory and provides context for the session operations. Often the same database DB entities e.g. DB entity may be referred to and hence cached by more than one sessions corresponding to more than one concurrent UI agents. Thus the caching also improves the concurrent access to data but also creates a risk of inconsistency if the common data is altered by one or more of the sessions. To minimize this risk and to avoid unnecessary synchronization of the cached data with the database a database triggered push notification mechanism is implemented according to one embodiment.

According to this mechanism when a DB entity e.g. is altered for example in response to an operation related to a user request such as create read update and delete CRUD data a message could be sent to DB messaging channel . In one embodiment the message may be generated or triggered e.g. by a database trigger as a result of the change in DB entity and pushed to the DB messaging channel via common DB interface that handles the communication between the server system and the database . Then the message may be forwarded e.g. by the DB messaging channel to one or more of the sessions that are caching data from DB entity as a notification that some data stored in DB entity have been altered and hence the cached data may no longer be consistent. In response to the notification that the data may no longer be consistent the sessions may invoke a refresh of the cached data as necessary.

At at least one trigger is defined for a database entity with at least one corresponding messaging channel. In one embodiment the trigger could be defined as database entity trigger according to the database engine functionality to react to a specific operation or operations executed at the database entity. In one embodiment the trigger may generate a message in response to the operation and send the message to the corresponding messaging channel e.g. as an inbound message.

At one or more UI sessions are instantiated at the application server where the UI sessions correspond to one or more client applications. In one embodiment a session may be instantiated in response to a user request. The user request may invoke a specific UI at a screen of a client launch a specific server operation e.g. service request trigger a transaction etc. At at least one of the instantiated UI sessions may subscribe to a database messaging channel. Such a subscription may be a result of reading data from a database entity corresponding to the database messaging channel. The UI session may initially retrieve data from the database entity before or after the subscription to the messaging channel and submit the data to a cache e.g. to cache the initial data for improving the performance and flexibility e.g. in answering other similar user requests. In one embodiment the subscription may be a result of caching the data.

At a trigger defined for the database entity is invoked e.g. by execution of a predefined DB operation. The operation may be related to creating reading updating or deleting data CRUD operations in the database entity e.g. a record or records in a database table. The execution of such operation according to conditions in the trigger s definition may lead to the generation and submission of one or more inbound messages to the corresponding messaging channel at . In one embodiment at least one message of the one or more inbound messages includes metadata for the executed database operation or action. The metadata may include identification information of the requestor of the change e.g. session name identification information of the database entity e.g. table name type and or definition of the executed operation etc.

Process continues at with sending one or more outbound messages from the database messaging channel to the subscriber at least one UI sessions. In one embodiment the messaging framework generates and pushes out the one or more outbound messages in response to receiving the one or more inbound messages. In one embodiment at least one of the one or more outbound messages includes at least a part of the metadata. For example at least the type of the executed DB operation is communicated to the at least one UI session.

Upon receiving an outbound message at a UI session the data cached from the database entity is partially or fully reread e.g. refreshed or re uploaded in the cache from the database entity at . In one embodiment the re reading of data depends on the metadata communicated by the received outbound message. For example if the type of DB operation is READ no rereading is necessary. Furthermore only the affected data elements e.g. records fields etc. of the database entity as identified by the DB operation definition may be refreshed in the UI session s cache. When data from the database entity is presented to one or more users e.g. fully or partially displayed on at least one client device in a UI corresponding to the UI session the refreshed data is pushed to the at least one client application at .

By following process it could be ensured that when a database entity is updated data previously cached from the database entity will be refreshed to avoid inconsistency. Such a refresh runs when triggered by relevant database operation or operations which effectively minimizes system load.

In one embodiment a UI agent may directly subscribe to the database messaging channel and receive a notification directly bypassing any existing UI session. The messaging channel is open for receiving subscriptions by various types of system objects including UI sessions and connections e.g. WebSocket communication channel over TCP IP transmission control protocol Internet protocol connections . Such connections can be bound connected like a pipe in Unix operating systems to the database messaging channel. In this case a database messaging dispatcher will send notification not to a session but via the provided connection to the UI agent directly. Some data may be cached in the UI agent e.g. at client systems and not in the server system e.g. .

The presented browser UI could be based on various Web based application technologies for providing client UIs either alternatively or in combination with browser UI . The AppGUI e.g. the client application graphical UI may represent specially developed client applications for providing rich client interface to business applications. Both types of UI applications browser UI and AppGUI when instantiated e.g. in response to user requests trigger the instantiation of the corresponding HTTP session and AppGUI session respectively e.g. at application server hosting the services provided via browser UI and AppGUI .

The database messaging channel may represent a proprietary or vendor provided messaging infrastructure built in the application server . In one embodiment the messaging infrastructure supports push messaging and may generate a separate messaging channel for a number of database entities. The database messaging channels could be generated in the database layer of the application server . In one embodiment the database layer provides interface between the application server and at least one external database e.g. database . The database messaging channel may represent a database messaging channel dispatcher or broker routing the database messages between the database entities and their corresponding messaging channels. In and database may represent a single database entity e.g. and database messaging channel may represent messaging channel dedicated to database entity .

In the example diagram illustrated in and client applications browser UI and AppGUI may run in parallel and apply changes to the same database entities i.e. to database table . The affected database entity may be used to calculate business content represent results etc. according to the requests routed through the respective user agents browser UI and AppGUI . As illustrated two or more clients may be active simultaneously one in AppGUI reach user agent and another in browser UI applications. To an active user agent e.g. AppGUI and or browser UI a dedicated application server session containing application context may be instantiated e.g. AppGUI session and HTTP session . Both client applications or agents may execute business transactions which access the same database entity e.g. database table .

As illustrated in the example at stage the execution of a transaction e.g. transaction xyz is requested at AppGUI which requires reading and calculating data stored in database e.g. in . The request for execution of transaction xyz is transferred for handling to AppGUI session at the application server . At stage the AppGUI session accesses database to read the required content of and to apply the necessary calculations. The communication between AppGUI session and database may be handled by the database interface layer of the application server according to one embodiment.

Further at stage a database trigger associated with may be activated as well as the database messaging channel dedicated to the database entity if not being activated already e.g. by another process. The activation of the messaging channel cold mean its instantiation within the application server messaging framework. In one embodiment the database trigger could be predefined e.g. when the database entity is created. The database trigger executes when invoked by a specified operation or operations applied to the database entity according to the definition e.g. one or more of the Create Read Update Delete CRUD actions. At stage business data containing or resulting from the data read from the database entity e.g. is sent to AppGUI user agent for displaying on a screen or presenting otherwise.

Stages generally repeat the process described with respect to stages . An execution of application e.g. abc is invoked at HTTP session based on a user request submitted at browser UI application stage . Similarly to transaction xyz the execution of application abc requires access to database e.g. database entity to read data stage . The database trigger and the corresponding database messaging channel e.g. 

In both stages and the content of database entity is read and cached either completely or partially in the associated sessions AppGUI session and HTTP session . At stages and the application sessions subscribe to database messaging channel e.g. that is dedicated to the database entity. The subscription is required to get a notification by the messaging framework database messaging channel as soon as any changes are applied to the database entity as illustrated with stages in .

For example based on business logic underlying AppGUI UI agent application and the represented screens a user is able to update screen elements. For example the user may place a purchase order in an ERP application by manipulating screen input fields of the UI stage . That manipulation leads to updates to database and more specifically to updates of the content of database entity stage . As a result the activated trigger executes and a message is sent to the corresponding database message channel in the database message channel infrastructure . In one embodiment the database messaging channels could be realized as application objects with transport capabilities and a number of specific properties e.g. identification access rights interface methods etc. . The channel may represent an instance of such an object providing interface to the trigger associated with the database entity to submit a message. The message may transport metadata for the executed operation.

At stage the database message channel may represent the active messaging channels and a dispatcher or broker of the messaging framework of the application server that gets the message submitted by the trigger to channel and pushes a notification to the application sessions previously subscribed with the channel to receive such notifications AppGUI session and HTTP session . In one embodiment the database message channel dispatcher checks to identify the active consumers of messaging channel and sends a message to the consumers. The message may include at least partially the metadata submitted by the database trigger.

In response to the broadcasted message from the database messaging channel the AppGUI session and HTTP session may check whether re calculation of the business data based on the content of the updated is required stage . The check may be based on the metadata transported by the notification message. In the presented example since the update is a result of the operations executed at the AppGUI session no refresh or re calculation of the cached data is necessary. However HTTP session rereads data with applied changes from database entity at database and recalculates the results based on the updates stage . The output business data based on the updates is sent to browser UI to update the information presented to the user e.g. in the displayed UI screens stage .

The database triggered push notification helps establishing a low level event driven mechanism tied directly to the database entities that ensures data consistency. Besides updating the display of data as illustrated with and the mechanism could be used to ensure data consistency in other scenarios. For example with the help of the database triggered push notification using database messaging channels an efficient optimistic locking could be emulated. Such optimistic locking could prevent various issues with executing database transactions requested by concurrent clients especially when the clients are built on different technologies. Also by using the database triggered push notification repeated database lock checks could be avoided.

Currently there are two mechanisms for locking database resources during updates. One is a pessimistic database lock mechanism where a database resource is locked in advance e.g. by a UI session to guarantee exclusive access during database operations mainly during updates . The second mechanism optimistic locking does not set exclusive access to a requested database resource but instead the application repeatedly checks or validates whether the data to be updated was not previously modified by another process e.g. concurrent sessions . The repeated checks could be replaced by the event based notification. The lock collision events can be raised based on the database messaging channel mechanism as soon as the data entity of interest e.g. locked by the emulated optimistic lock is accessed by another session. The emulation of such a locking mechanism has an additional advantage of integrating systems that are based on different locking infrastructure.

Process continues at where a check is performed at the notified active UI sessions to determine whether there is a client transaction currently executing that involves data from the updated data entity. If there is such a transaction or transactions they are canceled at in response to the push message. At the cached data is reread from the updated database entity in response to the push message notification. Further the execution of one or more client transaction may continue using the refreshed cached data at . Following the described process no additional verification is necessary before committing a transaction at a shared database entity. In case of an update all the currently executed transactions involving the updated data are canceled based on a push notification according to one embodiment.

The client systems and the server system nodes communicating via network may define a number of different computer system environments. Structures with similar functionalities could be found in software products developed by various software vendors. Alternative embodiments may utilize other kinds of computer system architectures.

The involved client systems may have similar or different structures where one or more of the illustrated modules are replicated. One or more users may operate within one or more instances of user interface UI client of one or more of client systems . Different users may exclusively access different instances of the UI client within a same client system .

In one embodiment any of client systems may execute a standalone client application e.g. client engine to interact with the backend server system . Alternatively an intermediate layer may be downloaded to any of the client systems as an extension of a running Internet browser. Such intermediate layer may be also illustrated as client engine . The standalone client application and the intermediate layer may have similar components and functionality. Client engine takes responsibility for rendering the necessary client functionality and also for communicating with server systems via network when necessary.

The client engine includes UI client instances or sessions that may also embed into a browser integrated framework. The UI client may be a part of any popular browser integrated framework e.g. Silverlight provided by Microsoft Corp Flex provided by Adobe Systems Inc. JavaFX originally developed by Sun Microsystems Inc. etc. In one embodiment the client engine and UI client respectively may be desktop application for example a .NET application rendering a UI through a Windows Prosecution Foundation WPF system. The UI client accesses the necessary business data at the backend through remote access layer via network . In one embodiment no dedicated UI server or client programs are needed. The communication with the backend may include extracting storing and updating data. The data may be transported to repositories especially when backend implements a number of server nodes in separate computer system environments.

In one embodiment users generate services requests at UI client . UI components module instantiates one or more appropriate graphical user interface GUI screens or controls in response to the user request. The behavior of the UI components could be managed by controller . The controller makes sure that all instantiated controls in the UI components are initialized. The controller is also responsible for the execution of any configured operation triggered by events corresponding to the instantiated controls. In case when some of the operations involve execution of script segments the controller may trigger the execution of these scripts via scripts module . In one embodiment scripts module is a frontend scripting engine. Analytics module may be used for frontend data processing when necessary.

In one embodiment the backend utilizes presentation layer to connect to the Internet and or to other public or private networks and to provide access for the UI client sessions to underlying business functions and data structures. For example the presentation layer may generate the UI object model underlying the UI controls instantiated in the UI components module at the client systems . In one embodiment presentation layer may be part of the server runtime . The presentation layer may instantiate a separate application server session corresponding to one or more of the active UI client sessions not illustrated .

The server runtime provides environment where one or more software applications are executed. For example the applications may provide a number of business services for the users where various operation requests related to the business services are created at client systems . The requests are translated to corresponding process tasks performed by the applications executed in server runtime .

In one embodiment the server runtime includes backend controller for one or more UI client sessions to handle the requested UI components e.g. when a UI client session triggers an initialization of a UI component for the first time. The backend controller may manage the collaboration between the requested UI components and one or more underlying business objects e.g. via the corresponding application server session. System services in the server runtime may be used to administer the characteristics of the server runtime e.g. its engine parameters the user access to one or more components the processes execution the communication with other runtime environments like external systems databases etc. In one embodiment system services may also provide deployment setup and change management of software components. The database layer handling the communication with the database entities and the database messaging channels framework may be provided as system service .

Metadata repository may be the place where metadata about the computer programs deployed in the server system is preserved according to one embodiment. There are different kinds of metadata that could be maintained by the metadata repository . For example the repository keeps the description of the business objects underlying the applications . In one embodiment metadata repository keeps description of the available UI components and the relationships between them as designed.

Repository engine could manage the metadata and the collaboration with the server runtime at one hand and with various service providers at the other hand. The service providers may render services and or corresponding UI components to the backend as defined in the metadata. The service providers are available via service provider interfaces and can be either internal or external to the backend . In one embodiment backend services adaptation represents a layer that helps to adjust the designed UI or rendered UI components to a set of normalized business objects available at the server system . In one embodiment the messaging infrastructure implemented in backend system and used for database triggered push notification may be provided by service provider . The service provider interfaces could be used for communication with the repository .

In a multi server system environment e.g. in a cluster of more than one server system nodes repository may be used to persist different kinds of common data including programming code business data data dictionaries etc. e.g. DB entities and references . In one embodiment one or more different repositories may be assigned to different computer system environments defined in the computer system landscape .

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the presented embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limiting to the precise forms disclosed. While specific embodiments and examples are described herein for illustrative purposes various equivalent modifications are possible as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope of the specification is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

