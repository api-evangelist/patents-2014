---

title: Technologies for preventing hook-skipping attacks using processor virtualization features
abstract: Technologies for monitoring system API calls include a computing device with hardware virtualization support. The computing device establishes a default memory view and a security memory view to define physical memory maps and permissions. The computing device executes an application in the default memory view and executes a default inline hook in response to a call to an API function. The default inline hook switches to the security memory view using hardware support without causing a virtual machine exit. The security inline hook calls a security callback function to validate the API function call in the security memory view. Hook-skipping attacks may be prevented by padding the default inline hook with no-operation instructions, by designating memory pages of the API function as non-executable in the default memory view, or by designating memory pages of the application as non-executable in the security memory view. Other embodiments are described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454676&OS=09454676&RS=09454676
owner: Intel Corporation
number: 09454676
owner_city: Santa Clara
owner_country: US
publication_date: 20140627
---
Application software typically performs tasks by calling shared library functions provided by an operating system or other operating environment through one or more application programming interfaces APIs . Similarly malicious software malware may call system APIs to cause crashes copy protected data or perform other malicious activities. Thus security software may monitor system API calls to detect malware mitigate damage caused by malware and perform other security tasks. Security software may monitor API calls by installing one or more inline hooks on the system API. An inline hook is a segment of code that replaces a part of a system API function typically the first few instructions of the system API function causing the inline hook to be executed whenever the system API function is invoked. The inline hook may in turn redirect program execution to security software that may perform validation checks remove malware or perform other security checks. Typical inline hooks are installed within the virtual address space of an application process and thus may be easily overwritten or otherwise circumvented by malware. For example hook skipping attacks may simply jump to a location within the system API function that is located past the inline hook.

Typical computer processors include hardware support for virtualization features. Software virtualization includes transparently executing one or more guest operating systems from within a host operating system or VMM. Hardware virtualization features may include an extended privilege model hardware assisted support for virtual memory addressing support for extended memory permissions and other virtualization features.

While the concepts of the present disclosure are susceptible to various modifications and alternative forms specific embodiments thereof have been shown by way of example in the drawings and will be described herein in detail. It should be understood however that there is no intent to limit the concepts of the present disclosure to the particular forms disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives consistent with the present disclosure and the appended claims.

References in the specification to one embodiment an embodiment an illustrative embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may or may not necessarily include that particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to effect such feature structure or characteristic in connection with other embodiments whether or not explicitly described. Additionally it should be appreciated that items included in a list in the form of at least one A B and C can mean A B C A and B A and C B and C or A B and C . Similarly items listed in the form of at least one of A B or C can mean A B C A and B A and C B and C or A B and C .

The disclosed embodiments may be implemented in some cases in hardware firmware software or any combination thereof. The disclosed embodiments may also be implemented as instructions carried by or stored on a transitory or non transitory machine readable e.g. computer readable storage medium which may be read and executed by one or more processors. A machine readable storage medium may be embodied as any storage device mechanism or other physical structure for storing or transmitting information in a form readable by a machine e.g. a volatile or non volatile memory a media disc or other media device .

In the drawings some structural or method features may be shown in specific arrangements and or orderings. However it should be appreciated that such specific arrangements and or orderings may not be required. Rather in some embodiments such features may be arranged in a different manner and or order than shown in the illustrative figures. Additionally the inclusion of a structural or method feature in a particular figure is not meant to imply that such feature is required in all embodiments and in some embodiments may not be included or may be combined with other features.

Referring now to an illustrative computing device for monitoring API function calls includes a processor an I O subsystem a memory and a data storage device . In use as described below the computing device is configured to support multiple views of memory using hardware assisted extended page table support. In particular the computing device establishes a default untrusted view and a trusted security view. To monitor an API function the computing device installs two different inline hooks into the default view and the security view respectively. The application executes in the default view. Upon invocation of the API function the inline hook of the default memory view switches to the security view using a hardware assisted fast view switching instruction. No exit to a virtual machine monitor VMM is required to switch memory views. In the security memory view the computing device invokes a security function that may perform security checks or other security functions prior to executing the API function. After completing the security function the computing device switches back to the default view and returns to the calling application. Using the two different memory views allows the computing device to prevent hook skipping attacks for example by enforcing restrictive memory permissions in the default memory view. By using fast view switching instructions the computing device may monitor calls to the API function without incurring the overhead associated with switching to a VMM.

The computing device may be embodied as any type of device capable of monitoring API function calls and otherwise performing the functions described herein. For example the computing device may be embodied as without limitation a laptop computer a notebook computer a tablet computer a smartphone a mobile computing device a wearable computing device a computer a desktop computer a workstation a server computer a distributed computing system a multiprocessor system a consumer electronic device a smart appliance and or any other computing device capable of monitoring API function calls. As shown in the illustrative computing device includes the processor the I O subsystem the memory and the data storage device . Of course the computing device may include other or additional components such as those commonly found in a tablet computer e.g. various input output devices in other embodiments. Additionally in some embodiments one or more of the illustrative components may be incorporated in or otherwise form a portion of another component. For example the memory or portions thereof may be incorporated in the processor in some embodiments.

The processor may be embodied as any type of processor capable of performing the functions described herein. For example the processor may be embodied as a single or multi core processor s digital signal processor microcontroller or other processor or processing controlling circuit. The processor includes hardware based hardware assisted or hardware accelerated support for virtualization. In particular the processor includes virtual machine extensions VMX support extended page table EPT support and fast view switch FVS support . The VMX support supports virtualized execution of operating systems by providing two modes of execution VMX root mode and VMX non root mode. The VMX root mode allows executing software to have broad control of the computing device and its hardware resources. Conversely a hypervisor virtual machine monitor VMM or host operating system OS may execute in VMX root mode. The VMX non root mode restricts access to certain hardware instructions while still implementing the ordinary ring privilege system of the processor . One or more guest OSs may execute in the VMX non root mode. Those guest OSs may execute in ring zero similar to being executed without virtualization. The execution of certain hardware instructions and certain other system events may trigger hardware assisted transitions to VMX root mode. Those hardware assisted transitions are known as virtual machine exits or VMExits. Upon encountering a VMExit the processor may switch context from the guest OS to the VMM in order to handle the VMExit. Thus VMExits may impose a performance penalty on virtualized code. The VMX support may be embodied as for example Intel VT x technology.

The EPT support supports hardware assisted second level page address translation. For nonvirtualized workloads or when operating in VMX root mode the processor may provide hardware assisted translation between virtual memory addresses also known as linear addresses to physical memory addresses. The processor may translate memory addresses using one or more page table structures stored in the memory and managed by a host operating system hypervisor or VMM. For virtualized workloads or when operating in VMX non root mode the processor supports hardware assisted translation between virtual memory addresses used for example by applications executing within a guest OS to guest physical memory addresses. A guest OS may maintain one or more page table structures in the memory to manage the translation to guest physical memory addresses. However a guest physical memory address may not correspond to an actual physical memory address within the memory . The EPT support provides hardware assisted translation between guest physical memory addresses to physical memory addresses. The EPT support may translate memory addresses using one or more extended page table structures stored in the memory and managed by the VMM hypervisor or host OS. Without the EPT support translation between guest physical memory addresses and physical memory addresses may require one or more VMExits. The EPT support also supports associating access permissions with each guest physical page and or physical page e.g. read write and or execute permissions . Permissions violations which may be known as EPT violations may generate VMExits that allow the host OS hypervisor or VMM to handle the EPT violation. Additionally or alternatively in some embodiments permissions violations may generate a virtualization exception that may be handled by a guest OS. The EPT support may be embodied as for example Intel VT x technology.

The FVS support allows the processor to quickly and atomically switch between several memory views without requiring a VMExit to VMX root mode. A memory view includes the guest physical page mapping and associated permissions defined by an EPT and thus may correspond one to one with an EPT. The FVS support may support switching memory views by changing a pointer within an in memory virtual machine control structure VMCS to point to a different EPT structure. In some embodiments the FVS support may allow software in VMX non root mode to select one of several memory views that have been predefined by software executing within the VMX root mode. Accordingly the FVS support may allow a guest OS or software executing within the guest OS to switch between memory views without requiring a potentially expensive context switch to the VMM hypervisor or host OS. The FVS support may be embodied as a specialized processor instruction such as the VMFUNC instruction supported by certain Intel processors.

The memory may be embodied as any type of volatile or non volatile memory or data storage capable of performing the functions described herein. In operation the memory may store various data and software used during operation of the computing device such operating systems applications programs libraries and drivers. The memory may be subdivided into fixed sized segments known as pages. Each page may include for example bytes of data. The memory further includes a guest page table and one or more extended page tables EPTs . The guest page table stores mappings between virtual memory pages and guest physical memory pages. As described above the guest page table may be used by the processor to translate between virtual memory addresses and guest physical memory addresses. Each EPT stores mappings between guest physical memory pages and physical memory pages. As described above each EPT may be used by the EPT support of the processor to translate between guest physical memory addresses and physical memory addresses. Each EPT also includes access permissions e.g. read write and or execute for each guest physical page. The illustrative computing device includes two EPTs however in other embodiments the computing device may establish more or fewer EPTs . Both the guest page table and the EPTs may be embodied as one or more in memory data structures such as arrays lists associative arrays nested or hierarchical arrays or other data structures.

The memory is communicatively coupled to the processor via the I O subsystem which may be embodied as circuitry and or components to facilitate input output operations with the processor the memory and other components of the computing device . For example the I O subsystem may be embodied as or otherwise include memory controller hubs input output control hubs firmware devices communication links i.e. point to point links bus links wires cables light guides printed circuit board traces etc. and or other components and subsystems to facilitate the input output operations. In some embodiments the I O subsystem may form a portion of a system on a chip SoC and be incorporated along with the processor the memory and other components of the computing device on a single integrated circuit chip.

The data storage device may be embodied as any type of device or devices configured for short term or long term storage of data such as for example memory devices and circuits memory cards hard disk drives solid state drives or other data storage devices. In some embodiments the computing device may also include one or more peripheral devices . The peripheral devices may include any number of additional input output devices interface devices and or other peripheral devices. For example in some embodiments the peripheral devices may include a display touch screen graphics circuitry keyboard mouse speaker system and or other input output devices interface devices and or peripheral devices.

Referring now to in the illustrative embodiment the computing device establishes an environment during operation. The illustrative embodiment includes a VMX root module and a VMX non root module . The various modules of the environment may be embodied as hardware firmware software or a combination thereof.

The VMX root module is configured to execute in VMX root mode using the VMX support of the processor and thereby manage the EPTs . In particular the VMX root module is configured to manage an EPT that defines the default memory view and an EPT that defines the security memory view. The VMX root module may be embodied as a virtual machine monitor VMM a hypervisor a host operating system OS or any other control structure of the computing device that may execute in VMX root mode. The VMX root module establishes a view management module and an access violation module .

The view management module is configured to manage the default view EPT and the security view EPT . In particular the view management module is configured to establish the guest physical page to physical page mappings included in the EPTs . The view management module is also configured to manage the permissions associated with the guest physical pages stored in the EPTs . In some embodiments the view management module may be configured to install one or more inline hooks into the memory pages of an API function as described below.

The access violation module is configured to handle EPT violations that are generated from within the VMX non root module . As described further below EPT violations are generated when a memory access not allowed by the current EPT is attempted from VMX non root mode. Thus EPT violations may correspond to hook skipping attacks or other security violations. The access violation module may perform any security operation in response to EPT violations such as reporting violations logging violations or attempting to remediate violations. The access violation module may include a VMExit handler that is executed in response to EPT violations.

The VMX non root module is configured to execute in VMX non root mode using the VMX support of the processor . Thus the VMX non root module may access the memory through the guest page table . The VMX non root module may be embodied as a guest operating system OS a host OS executing in VMX non root mode or any other control structure of the computing device that may execute in VMX non root mode. The VMX non root mode establishes an application an API module and a security module .

The application may be embodied as any computer program executable by the computing device including a native binary application a managed bytecode application an interpreted application or a scripted application. The application may be embodied as untrusted or user provided code and thus may attempt malicious activities. The API module may be embodied as any computer program or program library that may be executed by the computing device including a dynamic link library DLL shared library a bytecode archive or a script library. The API module includes an API function that is exposed for use by the application . The API function allows the application to request services software resources hardware resources or to perform any task provided by the API module . In many embodiments the API function may expose critical functionality sensitive data or other important features of the computing device . Thus the API function may be targeted by malware such as a malicious application .

The security module is configured to monitor calls to the API function and prevent attacks by malicious software such as a malicious application . In particular the security module is configured to execute a default inline hook using the default memory view in response to a call to the API function from the application . The security module is further configured to switch to the security memory view using the FVS support of the processor and continue executing a security inline hook . The security module is also configured to call a security callback from the security inline hook using the security memory view. The security callback may be embodied as an anti malware function or other security function that validates the call from the application to the API function and calls the API function if validated. The security module is further configured to switch back to the default memory view using the FVS support of the processor after completion of the security callback .

Although the environment is illustrated as including a single application API module and API function it should be understood that in some embodiments the computing device may monitor multiple applications API modules and or API functions . For example an API module may include several API functions and corresponding inline hooks may be installed for each API function . Similarly the computing device may monitor several applications that each access an API function included in an API module and so on.

Referring now to in use the computing device may execute a method for preparing to monitor calls to the API function . The method may be executed in VMX root mode for example by a VMM a hypervisor or a host OS and thus may have full access to the computing device including the EPTs . The method begins in block in which the computing device loads the process space for the application . The computing device may load the application into the memory and prepare virtual page mappings for the application . In particular because application may be loaded in the VMX non root mode the computing device may update the guest page table with appropriate mappings between virtual memory pages used by the application to guest physical memory pages used by the VMX non root mode for example by a guest OS. Similarly in block the computing device loads an API library including the API function to be monitored into the process space of the application and in block the computing device loads a monitoring library including the security callback into the process space of the application . Both the API library and the monitoring library may be embodied as any dynamic link library DLL shared library loadable module static library or other code module that may be executed by the computing device . The API library and or the monitoring library may be statically or dynamically linked to the application or may be injected into the application at runtime.

Referring now to the schematic diagram illustrates one potential embodiment of the process space of the application after loading the application the API library and the monitoring library. Block illustrates the virtual memory layout of the process space of the application . As shown the image of the application itself is located at a virtual page the API function is located at a virtual page and the security callback is located at a virtual page . Block illustrates the guest physical memory layout of the process space of the application . As shown the image of the application is located at a guest physical page the API function is located at a guest physical page and the security callback is located at a guest physical page . The guest page table maps between the virtual pages of the virtual memory to the guest physical pages of the guest physical memory . In the illustrative example the guest page table initially maps the virtual page to the guest physical page the virtual page to the guest physical page and the virtual page to the guest physical page .

Referring back to in block the computing device installs an inline hook by modifying the API function . In some embodiments the computing device may install the default inline hook or the security inline hook . The computing device may use any technique to install the inline hook. For example the computing device may overwrite the first part of the API function with the inline hook. In block the computing device may create a new guest physical page to include the hooked API function . The new guest physical page may be created for example using a copy on write function of the guest OS of the computing device . In that example the new guest physical page may be created in response to an attempt to modify memory page including the API function . After creating in the new guest physical page in block the computing device may modify the guest page table to address the guest physical page including the newly installed inline hook. Although described as being included in a single virtual and or guest physical page it should be understood that the installed inline hook may encompass several pages.

Referring back to the schematic diagram also illustrates the process space of the application after the default inline hook has been installed. As shown the default inline hook is included in a guest physical page . The guest physical page may be created for example by copying the guest physical page and modifying the API function to install the default inline hook . As illustrated the guest page table has been modified to change the mapping of the virtual page from the guest physical page to the guest physical page . Thus after modifying the guest page table any accesses from the application to the virtual page which originally mapped to the API function are translated to the guest physical page containing the default inline hook .

Referring back to in block the computing device establishes a default memory view using the EPT also known as the default view EPT . The computing device establishes the default memory view by setting the guest physical page to physical page mappings of the default view EPT and by setting appropriate permissions for the guest physical pages. For the application the API function and the security callback the computing device may map guest physical pages to the corresponding physical pages. In block the computing device maps the guest physical page of the hooked API function to the physical page including the default inline hook . As described above the virtual page including the API function may be mapped to a guest physical page including a hooked copy of the API function . Thus in the default view EPT that guest physical page is mapped to the physical page in the memory containing the default inline hook . In block the computing device may set the permissions of the guest physical page including the application to be readable writeable and executable. In block the computing device may set the permissions of the guest physical page including the default inline hook to be readable not writeable and executable. In block the computing device may set the permissions of the guest physical page including the original API function to be read only that is readable not writeable and not executable. In block the computing device may set the permissions of the guest physical page including the security callback to be read only that is readable not writeable and not executable.

Referring back to the schematic diagram further illustrates the default memory view provided by the default view EPT . As shown the memory includes the application located at a physical page the default inline hook located at a physical page the API function located at a physical page and the security callback located at a physical page . The memory further includes the security inline hook located at a physical page . The security inline hook may be created by the computing device in the physical memory for example by copying and modifying the physical page that includes the original API function . The default view EPT maps between the guest physical pages of the guest physical memory to the physical pages of the memory . In the illustrative example the default view EPT maps the guest physical page to the physical page the guest physical page to the physical page the guest physical page to the physical page and the guest physical page to the physical page . Therefore a request from the application to access the virtual page which originally included the API function may be translated to the guest physical page and then to the physical page that includes the default inline hook . Note that the default view EPT does not map any guest physical page to the physical page . Thus the physical page including the security inline hook may not be accessible to any software executed in the VMX non root mode by the computing device .

Still referring to as shown the default view EPT also includes permissions for each guest physical page to physical page mapping. In the illustrative example the guest physical pages that include the API function and the security callback respectively may not be modified or executed by software in VMX non root mode. Additionally the guest physical page that includes the default inline hook may be executed but may not be modified by software in VMX non root mode.

Referring back to after setting up the default view EPT in block the computing device establishes a security memory view using the EPT also known as the security view EPT . The computing device establishes the security memory view by setting the guest physical page to physical page mappings of the security view EPT and by setting appropriate permissions for the guest physical pages. Similar to the default view EPT for the application the API function and the security callback the computing device may map guest physical pages to the corresponding physical pages. In block the computing device maps the guest physical page of the hooked API function to the physical page including the security inline hook . As described above the virtual page including the API function may be mapped to a guest physical page including a hooked copy of the API function . Thus in the security view EPT that guest physical page is mapped to the physical page in the memory containing the security inline hook . In block the computing device may set the permissions of the guest physical page including the application to be read only that is readable not writeable and not executable. In block the computing device may set the permissions of the guest physical page including the security inline hook to be readable not writeable and executable. In block the computing device may set the permissions of the guest physical page including the original API function to be readable not writeable and executable. In block the computing device may set the permissions of the guest physical page including the security callback to be readable not writeable and executable.

Referring now to the schematic diagram illustrates the security memory view provided by the security view EPT . As shown the virtual memory the guest physical memory and the physical memory are laid out similarly to the diagram of . However in contrast to the default memory view in the security memory view the security view EPT maps between the guest physical pages of the guest physical memory to the physical pages of the memory . In the illustrative example the security view EPT maps the guest physical page to the physical page the guest physical page to the physical page the guest physical page to the physical page and the guest physical page to the physical page . Therefore a request from the application to access the virtual page which originally included the API function may be translated to the guest physical page and then to the physical page that includes the security inline hook . Note that the security view EPT does not map any guest physical page to the physical page . Thus the physical page including the default inline hook may not be accessible to any software executed in the VMX non root mode by the computing device .

Still referring to as shown the security view EPT also includes permissions for each guest physical page to physical page mapping. In the illustrative example the guest physical page that includes the application may not be executed or modified by software in VMX non root mode. Additionally the guest physical pages that include the API function the security inline hook and the security callback respectively may be executed but may not be modified by software in the VMX non root mode.

Referring back to after establishing both the default memory view and the security memory view in block the computing device sets the current memory view to the default memory view. To select the current memory view the computing device may use any technique to activate or otherwise select the default view EPT . For example the computing device may set a pointer in a virtual machine control structure VMCS to point to the default view EPT . In some embodiments the computing device may execute a specialized processor instruction such as VMFUNC to activate the default view EPT

In block the computing device executes the application and monitors calls to the API function . The computing device executes the application in the VMX non root mode. Thus all memory accesses of the application may be made using the EPT support of the processor . To monitor the calls to the API function the computing device may execute a method as described below in connection with . After executing the application the method loops back to block in which the computing device may continue monitoring calls to the API function .

Referring now to in use the computing device may execute a method for monitoring calls to the API function . The method may be executed in the VMX non root mode for example by a guest OS or by the host OS and thus may have limited access to the computing device including limited access to the EPTs . The method begins in block in which the computing device monitors for a call to the API function from the application . The computing device may use any technique for monitoring for a function call. For example in some embodiments the computing device may passively monitor for calls to the API function by waiting for the application to execute a call or jump instruction to the entry point of the API function . In other embodiments the computing device may actively monitor a virtual function or message dispatch system of the computing device . In block the computing device determines whether a call to the API function has been encountered. If not the method loops back to block to continue monitoring for calls to the API function . If a call to the API function has been encountered the method advances to block .

In block the computing device executes the default inline hook using the default memory view. In other words the computing device executes code of the default inline hook using the guest physical page mappings and permissions specified by the default view EPT . The computing device may execute instructions of the default inline hook that have been installed at the starting virtual memory location originally occupied by the API function .

In block the computing device switches to the security memory view using the FVS support of the processor without generating a VMExit. In other words the computing device switches to executing code using the guest physical page mappings and permissions specified by the security view EPT . As described above the computing device may switch to the security memory view using a specialized processor instruction such as VMFUNC. That processor instruction may be include in the default inline hook .

In block after switching to the security memory view the computing device continues executing the security inline hook in the security memory view. Because the computing device switched to the security memory view during execution of the default inline hook execution of the security inline hook may proceed with a processor instruction located at the next virtual address. In other words the virtual address of an instruction pointer register may be incremented as normal but because the computing device has switched to the security view EPT the physical memory page associated with that virtual address and thus the actual instruction executed for that virtual address may change.

In block the computing device calls the security callback . Thus the security callback is executed using the security memory view. In block the computing device validates the call to the API function using the security callback . In block the computing device determines whether the call to the API function is valid. The security callback may perform any validation authentication authorization auditing logging or other security process to determine whether the call to the API function is valid. For example the computing device may validate the identity of the calling application evaluate arguments or other parameters used to call the API function or perform other security operations. If the call to the API function is valid the method branches to block described below. If the call is invalid the method branches to block .

In block the computing device returns execution to the security inline hook . The computing device does not call or otherwise execute the API function . The computing device may return to the security inline hook using stack manipulation or other technique to simulate a return from a function call. The computing device may also report a security violation terminate the application attempt to clean the application or perform any other security option in response to the call to the API function being invalid not shown . After returning to the security inline hook the method advances to block described below.

Referring back to block if the call to the API function is valid the method branches to block in which the computing device executes the original API function . The computing device may use any method to execute the API function such as executing a processor instruction to call the API function . The API function continues to execute in the security memory view. After completing execution of the API function in block the computing device returns to the security inline hook . After returning to the security inline hook the method advances to block .

In block the computing device switches to the default memory view using the FVS support of the processor without generating a VMExit. In other words the computing device switches to executing code using the guest physical page mappings and permissions specified by the default view EPT . As described above the computing device may switch to the default memory view using a specialized processor instruction such as VMFUNC. That processor instruction may be include in the security inline hook .

In block after switching to the default memory view the computing device continues executing the default inline hook in the default memory view. Because the computing device switched to the default memory view during execution of the security inline hook execution of the default inline hook may proceed with a processor instruction located at the next virtual address. In other words the virtual address of the instruction pointer register may be incremented as normal but because the computing device has switched to the default view EPT the physical memory page associated with that virtual address and thus the actual instruction executed for that virtual address may change. In block the computing device may execute one or more NOP instructions in the default inline hook . In some embodiments the default inline hook may be padded with NOP instructions in order to match the in memory size or layout of the API function . In block the computing device returns to the calling application . The computing device for example may execute a return instruction used to return from a subroutine call. After returning to the application the method loops back to block to continue monitoring for calls to the API function .

Referring now to the diagram illustrates pseudocode for one potential embodiment of the default inline hook and the security inline hook . Pseudocode illustrates one possible embodiment of the default inline hook . As shown the default inline hook may include instruction to perform a fast view switch to the security memory view followed NOP instructions through and finished with instruction to return to the calling application . In some embodiments the default inline hook may also include an instruction such as VMCALL to trigger a VMExit or otherwise call a hypervisor in order to signal a potential attack scenario. As described above the default inline hook may be padded with NOP instructions to be the same size or layout as the API function . Pseudocode illustrates one embodiment of the security inline hook . As shown the security inline hook may include instruction to switch to the security memory view instruction to call the security callback instruction to switch back to the default memory view and instruction to return.

In use the processor begins execution of the default inline hook with the instruction which switches the processor to the security memory view. After execution of the instruction the processor proceeds to execute the instruction . However because the processor has switched to the security view EPT the processor executes the instruction from the security inline hook not from the default inline hook . Thus the processor executes the instruction which calls the security callback . As described above the security callback performs security operations and may call the original API function . After the security callback returns to the security inline hook the processor executes the instruction which causes the processor to switch back to the default memory view. After execution of the instruction the processor proceeds to execute the instruction . Because the processor has switched to the default view EPT the processor executes the instruction from the default inline hook which is a NOP instruction. As shown the processor continues to execute NOP instructions within the default inline hook until executing the instruction which returns to the application . Additionally or alternatively in some embodiments the processor may execute a VMCALL instruction not shown to signal an attack to the hypervisor.

Referring now to in use the computing device may execute a method for preventing or handling hook skipping attacks. The method may be executed in the VMX non root mode for example by a guest OS or by the host OS and thus may have limited access to the computing device including limited access to the EPTs . The method begins in block in which the computing device executes the application in the default memory view. In other words the computing device executes the application in VMX non root mode using the default view EPT . In some embodiments the application may include untrusted arbitrary code selected for execution by a user of the computing device . Thus the application may intentionally or inadvertently attempt malicious activity. In particular the application may include malicious code that attempts to skip the inline hooks and execute the API function directly. Depending on the particular hook skipping attack attempted execution of the method may proceed to any of blocks described below.

As one example of a hook skipping attack in block the computing device jumps to an address within the API function beyond the entry point of the API function . For example a malicious application may jump to an address that is a few instructions beyond the beginning of the API function in an attempt to skip over any inline hooks installed in the API function . In block the computing device executes one or more no operation instructions from within the default inline hook in response to jumping to the address within the API function . In block the computing device returns to the calling application . The method loops back to block to continue executing the application in the default memory view. Thus the API function may not be executed in response to the jump to the address within the API function .

To illustrate how this hook skipping attack is handled refer to the diagram of which illustrates the default memory view. As shown the application may access the API function through the virtual page . Thus a malicious application may jump to an internal address within the API function by jumping to an address within the virtual page . As shown the guest page table and the default view EPT map the virtual page to the guest physical page and the physical page respectively. Thus a jump by the application to an internal location within the API function in the virtual page is mapped to a jump to a location within the default inline hook in the physical page . As shown by the pseudocode of instruction is the only valid entry point of the default inline hook the rest of the instructions of the default inline hook are NOPs followed by a return instruction. Therefore if the application jumps into the interior of the default inline hook e.g. jumps to instruction the computing device merely executes a series of NOPs before returning to the application .

Referring back to as another example of a hook skipping attack in block the computing device may switch to the security memory view from within the application . For example a malicious application may execute a processor instruction such as VMFUNC to switch to the security memory view. The processor may successfully switch to the security memory view. In block the computing device attempts to execute the next instruction from the application . In a hook skipping attack the next instruction may typically attempt to call the API function directly without monitoring by the security callback . However as described above the security view EPT defines the guest physical page including the application to be read only and not executable. For example referring to the security view EPT marks the guest physical page that is mapped to the physical page that includes the application as read only and not executable. Thus the attempt to execute the next instruction in the application generates an EPT violation and execution of the method branches ahead to block .

In block the computing device generates a VMExit in response to the EPT violation. As described above the VMExit causes the computing device to switch context to the VMX root mode. The computing device may call a VMExit handler in response to the VMExit. In block the computing device handles the EPT violation in VMX root mode. For example the EPT violation may be handled by the VMM hypervisor or host OS of the computing device . To handle the EPT violation the computing device may for example terminate the application report a security violation log a security violation initiate a malware scan or perform any other appropriate security operation. After handling the EPT violation the method may be completed. Although illustrated as generating a VMExit that may be handled by the VMM it should be understood that in some embodiments the permissions violation may generate a virtualization exception that is handled by a guest OS or the host OS.

Referring now to block in another example of a hook skipping attack the computing device may map a new virtual page to the guest physical page that includes the original API function . For example referring again to a malicious application may create a new virtual page in the virtual memory that is mapped to the guest physical page in the guest physical memory . The application may accomplish this by manipulating the guest page table or using any other technique. In block the computing device calls the API function using an address within the newly mapped virtual page. As described above that virtual address is translated using the guest OS page table into a guest physical address for the API function . Because the default memory view is active the guest physical page that includes the original API function is marked as read only and not executable. For example referring again to the original API function is included in the guest physical page which is marked in the default view EPT to be read only. Therefore the attempt to call the API function generates an EPT violation and execution of the method branches ahead to block as described above.

Referring now to block in another example of a hook skipping attack the computing device may attempt to modify code within the security callback . For example a malicious application may attempt to modify the security callback to alter or avoid security checks. However the default view EPT marks the guest physical page including the security callback as read only and the security view EPT marks the guest physical page including the security callback as readable and executable but not writable. For example as shown in the guest physical page is marked by the default view EPT to be read only and as shown in the guest physical page is marked by the security view EPT to be read execute only. Therefore the attempt to modify the security callback generates an EPT violation and execution of the method branches ahead to block as described above.

Illustrative examples of the technologies disclosed herein are provided below. An embodiment of the technologies may include any one or more and any combination of the examples described below.

Example 1 includes a computing device for monitoring an application programming interface API the computing device comprising a view management module to i establish a default memory view wherein the default memory view defines a first physical memory map of the computing device and a first set of memory permissions and ii establish a security memory view wherein the security memory view defines a second physical memory map of the computing device and a second set of memory permissions and a security module to execute a default inline hook with the default memory view in response to a call of an API function from an application switch to the security memory view without a virtual machine exit event in response to execution of the default inline hook execute a security inline hook with the security memory view in response to a switch to the security memory view and call an anti malware callback function in response to execution of the security inline hook.

Example 2 includes the subject matter of Example 1 and wherein the security module is further to switch to the default memory view without a virtual machine exit event in response to a call of the anti malware callback function and return to the application in response to a switch to the default memory view.

Example 3 includes the subject matter of any of Examples 1 and 2 and wherein the anti malware callback function is to call the API function in response to a validation of the call of the API function from the application.

Example 4 includes the subject matter of any of Examples 1 3 and wherein the anti malware callback function is further to return to the security inline hook without a call of the API function in response to a failure to validate the call of the API function from the application.

Example 5 includes the subject matter of any of Examples 1 4 and wherein the first physical memory map of the default memory view maps a guest physical memory page that includes the API function to a first physical page that includes the default inline hook and the second physical memory map of the security memory view maps the guest physical memory page that includes the API function to a second physical page that includes the security inline hook.

Example 6 includes the subject matter of any of Examples 1 5 and wherein the first set of memory permissions of the default memory view comprises a read permission a write permission and an execute permission for a first guest physical memory page that includes the application a read permission and an execute permission for a second guest physical memory page that includes the default inline hook a read permission for a third guest physical memory page that includes the API function and a read permission for a fourth guest physical memory page that includes the anti malware callback function.

Example 7 includes the subject matter of any of Examples 1 6 and wherein the second set of memory permissions of the security memory view comprises a read permission for the first guest physical memory page that includes the application a read permission and an execute permission for the second guest physical memory page that includes the security inline hook a read permission and an execute permission for the third guest physical memory page that includes the API function and a read permission and an execute permission for the fourth guest physical memory page that includes the anti malware callback function.

Example 8 includes the subject matter of any of Examples 1 7 and wherein to establish the default memory view comprises to define the default memory view with one or more extended page tables of the computing device and to establish the security memory view comprises to define the security memory view with one or more extended page tables of the computing device.

Example 9 includes the subject matter of any of Examples 1 8 and wherein to switch to the security memory view comprises to execute a first processor instruction to switch to the security memory view.

Example 10 includes the subject matter of any of Examples 1 9 and wherein the first processor instruction comprises a processor instruction to change an extended page table pointer of the computing device.

Example 11 includes the subject matter of any of Examples 1 10 and wherein the default inline hook comprises a first processor instruction located at a first guest physical address the first processor instruction to switch to the security memory view the security inline hook comprises a second processor instruction located at a second guest physical address located immediately adjacent to the first guest physical address the second processor instruction to call the anti malware callback function and the security module is further to i execute the first processor instruction and ii execute the second processor instruction immediately after execution of the first processor instruction.

Example 12 includes the subject matter of any of Examples 1 11 and wherein the security inline hook further comprises a third processor instruction located at a third guest physical address the third processor instruction to switch to the default memory view the default inline hook further comprises a fourth processor instruction located at a fourth guest physical address located immediately adjacent to the third guest physical address the security module is further to i execute the third processor instruction and ii execute the fourth processor instruction immediately after execution of the third processor instruction and in response to a switch to the default memory view.

Example 13 includes the subject matter of any of Examples 1 12 and wherein the fourth processor instruction comprises a no operation instruction.

Example 14 includes the subject matter of any of Examples 1 13 and wherein the view management module is further to modify prior to the execution of the default inline hook a guest physical page that includes the API function to install the default inline hook.

Example 15 includes a method for monitoring an application programming interface API the method comprising executing by a computing device a default inline hook using a default memory view in response to an application calling an API function wherein the default memory view defines a first physical memory map of the computing device and a first set of memory permissions switching by the computing device to a security memory view without causing a virtual machine exit event in response to executing the default inline hook wherein the security memory view defines a second physical memory map of the computing device and a second set of memory permissions executing by the computing device a security inline hook using the security memory view in response to switching to the security memory view and calling by the computing device an anti malware callback function in response to executing the security inline hook.

Example 16 includes the subject matter of Examples 15 and further comprising switching by the computing device to the default memory view without causing a virtual machine exit event in response to calling the anti malware callback function and returning by the computing device to the application in response to switching to the default memory view.

Example 17 includes the subject matter of any of Examples 15 and 16 and wherein the anti malware callback function is to call the API function in response to validating the application calling the API function.

Example 18 includes the subject matter of any of Examples 15 17 and wherein the anti malware callback function is to return to the security inline hook without calling the API function in response to failing to validate the application calling the API function.

Example 19 includes the subject matter of any of Examples 15 18 and further comprising defining by the computing device the first physical memory map of the default memory view to map a guest physical memory page including the API function to a first physical page including the default inline hook and defining by the computing device the second physical memory map of the security memory view to map the guest physical memory page including the API function to a second physical page including the security inline hook.

Example 20 includes the subject matter of any of Examples 15 19 and further comprising defining by the computing device the first set of memory permissions of the default memory view to allow a first guest physical memory page including the application to be readable writable and executable a second guest physical memory page including the default inline hook to be readable not writeable and executable a third guest physical memory page including the API function to be readable not writeable and not executable and a fourth guest physical memory page including the anti malware callback function to be readable not writeable and not executable.

Example 21 includes the subject matter of any of Examples 15 20 and further comprising defining by the computing device the second set of memory permissions of the security memory view to allow the first guest physical memory page including the application to be readable not writable and not executable the second guest physical memory page including the security inline hook to be readable not writeable and executable the third guest physical memory page including the API function to be readable not writeable and executable and the fourth guest physical memory page including the anti malware callback function to be readable not writeable and executable.

Example 22 includes the subject matter of any of Examples 15 21 and further comprising defining by the computing device the default memory view using one or more extended page tables of the computing device and defining by the computing device the security memory view using one or more extended page tables of the computing device.

Example 23 includes the subject matter of any of Examples 15 22 and wherein switching to the security memory view comprises executing a first processor instruction to switch to the security memory view.

Example 24 includes the subject matter of any of Examples 15 23 and wherein executing the first processor instruction comprises executing a processor instruction to change an extended page table pointer of the computing device.

Example 25 includes the subject matter of any of Examples 15 24 and wherein switching to the security memory view comprises executing a first processor instruction wherein the first processor instruction is located within the default inline hook at a first guest physical address and calling the anti malware callback function comprises executing a second processor instruction immediately after executing the first processor instruction wherein the second processor instruction is located within the security inline hook at a second guest physical address located immediately adjacent to the first guest physical address.

Example 26 includes the subject matter of any of Examples 15 25 and further comprising switching by the computing device to the default memory view without causing a virtual machine exit event in response to calling the anti malware callback function wherein switching to the default memory view comprises executing a third processor instruction wherein the third processor instruction is located within the security inline hook at a third guest physical address and executing by the computing device a fourth processor instruction immediately after executing the third processor instruction and in response to switching to the default memory view wherein the fourth processor instruction is located within the default inline hook at a fourth guest physical address located immediately adjacent to the third guest physical address.

Example 27 includes the subject matter of any of Examples 15 26 and wherein the fourth processor instruction comprises a no operation instruction.

Example 28 includes the subject matter of any of Examples 15 27 and further comprising modifying by the computing device prior to executing the default inline hook a guest physical page including the API function to install the default inline hook.

Example 29 includes a computing device comprising a processor and a memory having stored therein a plurality of instructions that when executed by the processor cause the computing device to perform the method of any of Examples 15 28.

Example 30 includes one or more machine readable storage media comprising a plurality of instructions stored thereon that in response to being executed result in a computing device performing the method of any of Examples 15 28.

Example 31 includes a computing device comprising means for performing the method of any of Examples 15 28.

Example 32 includes a computing device for monitoring an application programming interface API the computing device comprising means for executing a default inline hook using a default memory view in response to an application calling an API function wherein the default memory view defines a first physical memory map of the computing device and a first set of memory permissions means for switching to a security memory view without causing a virtual machine exit event in response to executing the default inline hook wherein the security memory view defines a second physical memory map of the computing device and a second set of memory permissions means for executing a security inline hook using the security memory view in response to switching to the security memory view and means for calling an anti malware callback function in response to executing the security inline hook.

Example 33 includes the subject matter of Example 32 and further comprising means for switching to the default memory view without causing a virtual machine exit event in response to calling the anti malware callback function and means for returning to the application in response to switching to the default memory view.

Example 34 includes the subject matter of any of Examples 32 and 33 and wherein the anti malware callback function is to call the API function in response to validating the application calling the API function.

Example 35 includes the subject matter of any of Examples 32 34 and wherein the anti malware callback function is to return to the security inline hook without calling the API function in response to failing to validate the application calling the API function.

Example 36 includes the subject matter of any of Examples 32 35 and further comprising means for defining the first physical memory map of the default memory view to map a guest physical memory page including the API function to a first physical page including the default inline hook and means for defining the second physical memory map of the security memory view to map the guest physical memory page including the API function to a second physical page including the security inline hook.

Example 37 includes the subject matter of any of Examples 32 36 and further comprising means for defining the first set of memory permissions of the default memory view to allow a first guest physical memory page including the application to be readable writable and executable a second guest physical memory page including the default inline hook to be readable not writeable and executable a third guest physical memory page including the API function to be readable not writeable and not executable and a fourth guest physical memory page including the anti malware callback function to be readable not writeable and not executable.

Example 38 includes the subject matter of any of Examples 32 37 and further comprising means for defining the second set of memory permissions of the security memory view to allow the first guest physical memory page including the application to be readable not writable and not executable the second guest physical memory page including the security inline hook to be readable not writeable and executable the third guest physical memory page including the API function to be readable not writeable and executable and the fourth guest physical memory page including the anti malware callback function to be readable not writeable and executable.

Example 39 includes the subject matter of any of Examples 32 38 and further comprising means for defining the default memory view using one or more extended page tables of the computing device and means for defining the security memory view using one or more extended page tables of the computing device.

Example 40 includes the subject matter of any of Examples 32 39 and wherein the means for switching to the security memory view comprises means for executing a first processor instruction to switch to the security memory view.

Example 41 includes the subject matter of any of Examples 32 40 and wherein the means for executing the first processor instruction comprises means for executing a processor instruction to change an extended page table pointer of the computing device.

Example 42 includes the subject matter of any of Examples 32 41 and wherein the means for switching to the security memory view comprises means for executing a first processor instruction wherein the first processor instruction is located within the default inline hook at a first guest physical address and the means for calling the anti malware callback function comprises means for executing a second processor instruction immediately after executing the first processor instruction wherein the second processor instruction is located within the security inline hook at a second guest physical address located immediately adjacent to the first guest physical address.

Example 43 includes the subject matter of any of Examples 32 42 and further comprising means for switching to the default memory view without causing a virtual machine exit event in response to calling the anti malware callback function wherein switching to the default memory view comprises executing a third processor instruction wherein the third processor instruction is located within the security inline hook at a third guest physical address and means for executing a fourth processor instruction immediately after executing the third processor instruction and in response to switching to the default memory view wherein the fourth processor instruction is located within the default inline hook at a fourth guest physical address located immediately adjacent to the third guest physical address.

Example 44 includes the subject matter of any of Examples 32 43 and wherein the fourth processor instruction comprises a no operation instruction.

Example 45 includes the subject matter of any of Examples 32 44 and further comprising means for modifying prior to executing the default inline hook a guest physical page including the API function to install the default inline hook.

