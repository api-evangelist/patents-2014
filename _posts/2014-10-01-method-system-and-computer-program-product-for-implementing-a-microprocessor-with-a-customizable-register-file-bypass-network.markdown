---

title: Method, system, and computer program product for implementing a microprocessor with a customizable register file bypass network
abstract: Methods and systems for implementing a microprocessor with a selective register file bypass network are disclosed. Late bypasses are removed from a register file bypass network of a microprocessor design. One or more late bypasses are then added back to the register file bypass network based at least in part upon the results of analyzing a plurality of instructions that are to be processed in an instruction pipeline of the microprocessor. An electronic design for at least the register file bypass network is then generated with these one or more late bypasses that are added to the register file bypass network. Without incurring additional hardware or cost for the microprocessor design, one or more bypasses in the register file bypass network may be optionally shared among multiple free-riders, and an entire port stage may also be optionally bypassed to another port stage based upon one or more criteria.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09250900&OS=09250900&RS=09250900
owner: Cadence Design Systems, Inc.
number: 09250900
owner_city: San Jose
owner_country: US
publication_date: 20141001
---
This application is related to U.S. Pat. No. 7 036 106 filed on Feb. 17 2000 and entitled AUTOMATED PROCESSOR GENERATION SYSTEM FOR DESIGNING A CONFIGURABLE PROCESSOR AND METHOD FOR THE SAME U.S. Pat. No. 6 477 697 filed on May 28 1999 and entitled ADDING COMPLEX INSTRUCTION EXTENSIONS DEFINED IN A STANDARDIZED LANGUAGE TO A MICROPROCESSOR DESIGN TO PRODUCE A CONFIGURABLE DEFINITION OF A TARGET INSTRUCTION SET AND HDL DESCRIPTION OF CIRCUITRY NECESSARY TO IMPLEMENT THE INSTRUCTION SET AND DEVELOPMENT AND VERIFICATION TOOLS FOR THE INSTRUCTION SET and U.S. Pat. No. 6 477 683 filed on Feb. 5 1999 and entitled AUTOMATED PROCESSOR GENERATION SYSTEM FOR DESIGNING A CONFIGURABLE PROCESSOR AND METHOD FOR THE SAME . The entire contents of the three aforementioned U.S. patents are hereby expressly incorporated by reference in their entirety for all purposes.

A portion of the disclosure of this patent document includes material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The instruction set architecture ISA of a microprocessor usually defines registers that correspond to entries in a register file and are used to stage data between various memory modules and functional modules of the microprocessor. Modern microprocessors may include a register bypass network that provides additional data paths to for example forward results that have not been committed or to eliminate data hazards in the pipelines. Some conventional microprocessor designs use a full bypass network such that a piece of data generated in a specific cycle from a register file write port becomes available at one or more register file read ports in the next cycle and thus may result in a reduced number of read after write stalls between instructions that write to a register and a subsequent instruction that reads the same register. Although a full bypass network may reduce the number of clock cycles when executing the same program a full bypass network may exhibit several disadvantages when compared to a partial bypass network. Therefore there exists a need for a method system and computer program product for implementing a microprocessor with a selective register file bypass network.

Disclosed are method s system s and article s of manufacture for implementing a microprocessor with a selective register file bypass network. Some embodiments are directed at a method for implementing a microprocessor with a selective register file bypass network. In some embodiments the method may remove late bypasses from a register file bypass network of a microprocessor design automatically add one or more late bypasses to the register file bypass network based at least in part upon analysis results of a plurality of instructions to be executed by the microprocessor and generating an electronic design for at least the register file bypass network with the one or more late bypasses that are automatically added to the register file bypass network.

In some of these embodiments the method that removes late bypasses from the register file bypass network may further automatically add one or more early bypasses to electronic design automatically transmit information that includes the one or more early bypasses and indicates that the electronic design includes no late bypasses by using a register file specification with a compiler or a register file generation module automatically add stall logic in response to the information indicating that the electronic design includes no late bypasses and automatically generate or modifying the electronic design to include no bypasses by using at least the information with the register file generation module. A register file generation module may perform the register file generation functions separately from and independent of the compiler in some embodiments. In some other embodiments the compiler may include the register file generation module as a sub module in the compiler and perform the register file generation functions.

In some of these immediately preceding embodiments the method that removes late bypasses from the register file bypass network may further add a first cycle or relaxing timing requirements for a removed late bypass route by converting the removed bypass route to at least a first instruction pipeline stage to an early bypass of a second instruction pipeline stage wherein the first instruction pipeline stage precedes the second instruction pipeline stage. In addition or in the alternative the method that removes late bypasses from the register file bypass network may further add a second cycle to one or more output operands of at least some of the plurality of instructions wherein the one or more output operands correspond to one or more late bypasses of the late bypasses that have been removed.

In some embodiments where the method automatically adds one or more late bypasses to the register file bypass network the method may further identify a first granularity level for specifying the one or more late bypasses and share a first bypass specification for specifying a first bypass of the one or more late bypasses with at least another bypass wherein the one or more late bypasses comprise multiple late bypasses that further include the at least another bypass. In some of these embodiments the method may determine a plurality of requirements for a first port stage of a register file of the microprocessor based at least in part upon the first bypass specification wherein the first port stage includes a write port stage elaborate the first bypass specification at the first granularity level to include information of one or more slot indices and map one or more operands to one or more ports of the register file.

In addition or in the alternative for a first bypass in the first bypass specification the method may connect a first operation operand negation of an operation output kill and an opcode decode to respective signal sources determine whether or not a first operation argument is bypassed to a second operation argument in one bypass of the one or more late bypasses to generate determination results and modify the electronic design based at least in part upon the determination results.

In some embodiments the method may further share at least one bypass of the one or more late bypasses among a plurality of free riders. Free riders may include for example Instructions instruction sequences operands port stages or the data therein wherein the data in these instructions instruction sequences operands or port stages may be bypassed without having or requiring any bypass specifications. In some of these embodiments the method that shares the at least one bypass may further identify a first set of instructions in a semantic from the plurality of instructions in a slot index that writes to output operands and associate the first set of instructions with a control signal while reusing the output operands and same enable signals for the some instructions. In addition or in the alternative the method that shares the at least one bypass may identify a second set of instructions that read from a first port stage bypass the second set of instructions to a first operand in the first port stage by using a first bypass of the one or more late bypasses that are automatically added to the register file bypass network and share the first bypass with one or more other operands in the first port stage by indicating information about the first bypass to the one or more other operands in the first port stage. The method that shares the at least one bypass may further optionally determine whether a first set of instructions in a semantic or a second set of instructions that read from a first port stage benefits from the at least one bypass to generate determination results and determine whether or not the at least one bypass is software visible based at least in part upon the determination results.

In some embodiments the method may further optionally bypass a first port stage in the instruction pipeline of the microprocessor to a second port stage by using at least one bypass of the one or more late bypasses. In some of these embodiments the method that optionally bypasses the first port stage to the second port stage may further identify a first port bypass in the one or more late bypasses from the first port stage to the second port stage identify write port data and multiple signals for the first port stage and transmit information or data concerning the first port bypass to a register file generation module.

In addition or in the alternative the method that optionally bypasses the first port stage to the second port stage may further convert the first port bypass into an operand bypass that bypasses a first operand to a second operand and transmit information concerning the operand bypass to one or more software tools for the one or more software tools to perform their respective functions. Optionally the method in some of these embodiments may further determining whether a set of instructions benefits from the first port bypass to generate determination results and determine whether or not the first port bypass is visible by the one or more software tools based at least in part upon the determination results.

Some embodiments are directed at a hardware module or system that may be invoked to perform any of the methods processes or sub processes disclosed herein. The hardware system may include for example one or more compilers register file generation module free rider module and or bypass removal and addition module etc. that function in conjunction with various sub systems of one or more computing systems to perform their respective functions in some embodiments. It shall be noted that in some embodiments the functions of the complier and those of the register file generation module may be performed by a single module such as the compiler. For example the compiler may also perform the register file generation function in these embodiments. Therefore the term register file generation module may also refer to the compiler throughout this application unless otherwise specifically distinguished. The hardware system may further include one or more forms of non transitory machine readable storage media or devices to temporarily or persistently store various types of data or information such as various constructs bypass specifications generated hardware designs one or more generated software tools one or more simulation verification or modeling tools dynamically link libraries etc.

At least one of these aforementioned modules works in conjunction with at least one processor executing one or more threads of execution and or the non transitory machine readable storage media or devices of a computing system to perform various acts described in this application and thus enhances the functionality and capability of a computing system e.g. a general purpose computing system and enables a computing system to perform functions that would not otherwise be possible without various embodiments described herein. Some illustrative modules or components of the hardware system may be found in the System Architecture Overview section below.

Some embodiments are directed at an article of manufacture that includes a non transitory machine accessible storage medium having stored thereupon a sequence of instructions which when executed by at least one processor or at least one processor core causes the at least one processor or the at least one processor core to perform any of the methods processes or sub processes disclosed herein. Some illustrative forms of the non transitory machine readable storage media may also be found in the System Architecture Overview section below.

More details of various aspects of the methods systems or articles of manufacture for implementing a microprocessor with a selective register file bypass network are described below.

Various embodiments of the invention are directed to methods systems and articles of manufacture for implementing a microprocessor with a selective register file bypass network. Other objects features and advantages of the invention are described in the detailed description figures and claims.

Various embodiments will now be described in detail with reference to the drawings which are provided as illustrative examples of the invention so as to enable those skilled in the art to practice the invention. Notably the figures and the examples below are not meant to limit the scope of various embodiments described in this Application. Where certain elements of the present invention may be partially or fully implemented using known components or methods or processes only those portions of such known components or methods or processes that are necessary for an understanding of the present invention will be described and the detailed descriptions of other portions of such known components or methods or processes will be omitted so as not to obscure the invention. Further various embodiments encompass present and future known equivalents to the components referred to herein by way of illustration.

Disclosed are method s system s and article s of manufacture for implementing a microprocessor with a selective register file bypass network in one or more embodiments. In one or more embodiments illustrates an illustrative high level schematic block diagrams for implementing a microprocessor with a selective register file bypass network and may comprise one or more computing systems such as a general purpose computer described in the System Architecture Overview section to implement one or more special proposes.

In some embodiments the one or more computing systems may invoke various system resources such as the processor s or processor core s memory disks etc. The one or more computing systems may also initiate or interact with other computing systems to access various resources that may comprise a floorplanner a global routing engine and or a detail routing engine a layout editor a design rule checker a verification engine etc. The one or more computing systems may further write to and read from a local or remote volatile or non volatile computer accessible storage that stores thereupon data or information such as but not limited to one or more databases such as schematic design database s or physical design database s electronic circuit design specification database s various statistics various data rule decks various design rules constraints etc. or other information or data that may be used to facilitate the performance of various functions to achieve the intended purposes.

In some embodiments the one or more computing systems may either directly or indirectly through various resources to invoke various software hardware modules or combinations thereof that may comprises one or more programming language and or construct modules including for example the register file construct the instruction extension language construct etc. to declare new register file to implement the microprocessor design or a portion thereof to analyze sharing and or dependency among instructions to generate save and restore sequences of a co processor to declare instructions as intrinsic functions to generate the instruction set architecture ISA description etc.

The various software hardware modules or combinations thereof may further include one or more compiler modules including for example an instruction set extension compiler and a C C compiler etc. to declare some or all instructions as intrinsic functions to declare the number of read and or write ports to create conventional programming language definitions e.g. definitions in C C etc. conventional programming languages of intrinsics for new instructions e.g. user specified instructions as functions. The one or more compiler modules may further generate and or analyze dependency among some instructions to generate the save and restore sequences for a co processor and to derive or generate physical and or schematic implementation of microprocessor designs either alone or in conjunction with one or more other modules.

In addition or in the alternative the one or more compiler modules may generate the instruction set architecture ISA description and the objects e.g. PERL objects for obtaining the ISA and pipeline information for user specified instructions to translate implementation semantics into HDL hardware description language of the register file the interlock bypass routes core interfaces exceptions etc. for subsequent verification of the implementation semantics etc.

In various embodiments the terms instruction set extension compiler and compiler may be used interchangeably to refer to a compiler unless otherwise explicitly specified. An instruction set extension compiler may generate for example instruction decoding logic logic for expanding instructions in user applications logic for simulating instructions Verilog HDL or Hardware Description Language for hardware designs various scripts to for example optimize a processor design etc. Another type of compiler e.g. C C compiler in of uses the information generated by an instruction set extension compiler and may also be referred to as a C compiler unless otherwise specifically specified.

The various software hardware modules or combinations thereof may further includes one or more register file generation modules to generate the register file with the corresponding hardware design software design test bench design electronic design automation tool scripts or code etc. for the microprocessor design with the desired or required register file bypass network one or more free rider modules to identify and share a bypass route among a plurality of operands and or to identify and bypass from a first port to a second port one or more bypass removal and addition modules to remove some bypass routes and to selectively add back at least one of the removed bypass routes.

In some of these illustrated embodiments the source description includes a single source description that comprises designer specified extensions or customizations of a microprocessor design and drives the generation of the hardware designs the software tools and the modeling and verification code or scripts as well as the simulation modeling or verification environments of various simulation verification or modeling tools . A system on a chip SOC or a part thereof may include for example a digital signal processor DSP a data plane processor DPU or a part of a DSP or a DPU. A dataplane processor is a microprocessor that may be implemented on a semiconductor substrate e.g. a single crystal silicon wafer and include a central processing unit CPU a processor core or any part thereof as well as some custom logic e.g. task specific differentiating or direct point to point interface s etc. and or one or more DSPs.

A compiler may be used to generate the dynamic linking libraries or dynamic link libraries or DLL and or module and process the source description with before the source description file is sent to the processor generation module to generate the processor generation output with the new custom or designer specified instructions new execution units etc. without requiring the processor generation output to be re linked or re compiled. The compiler may support both a hardware description language HDL and a general high level programming language e.g. C or C programming language . For example the compiler may explore and verity the implementations of the microprocessor architecture or a part thereof before the source description file is sent to the processor generation module to generate the processor generation output which comprises one or more of the software tools the hardware RTL register transfer level designs and or various models and verification modules .

For instance the compiler may generate one or more dynamic link libraries including for example software DLLs for one or more other compilers assemblers dissemblers and or profilers e.g. a performance profiler or a code profiler and may process the source description in order for the processor generation module to produce one or more software tools with the source description . As another example the compiler may generate one or more dynamic link libraries DLLs including for example shared code or data from one or more DLLs and or the hardware RTL or other hardware design at one or more other abstraction levels for the microprocessor design or a portion thereof e.g. the intermediate or final bypass network of a microprocessor design .

The one or more DLLs may include for example various source code e.g. Verilog code for the hardware design synthesis scripts or code for use in hardware design or estimates etc. As another example the compiler may invoke one or more dynamic link libraries including for example shared code or data from one or more DLLs for modeling and verification to model simulate verify or otherwise analyze various hardware design or software tools associated with the microprocessor design. The one or more DLLs may include for example simulation or verification functions and environment for the implementations of some or all instructions test vectors test program code or scripts from the test vectors formal verification scripts etc.

In some embodiments where the instruction set extension compiler includes a hybrid compiler supporting both a hardware description language HDL and a general high level programming language e.g. C or C programming language the general description of such a compiler is described in U.S. Pat. No. 7 036 106 the content of which is hereby incorporated by reference in its entirety for all purposes. More details about the flows of implementing a microprocessor design that includes a selective bypass network will be described below with reference to . In various embodiments various modules are integrated together to automatically generate various components described in . For example various modules are integrated together for the compiler to elaborate the source description to automatically generate the dynamic linking libraries and or modules which may be further used together with the designer specified configuration inputs to automatically generate the software tools the hardware designs and the modeling simulation and simulation modules without human intervention.

The source description B may be processed by compiler B e.g. compiler in generating a plurality of DLLs or modules B before the source description B is forwarded to the processor generation module B for creating various process generator output. The processor generator output may include for example the hardware design portion B including the designs of a microprocessor or a portion thereof RTL B e.g. the RTL design of the microprocessor or a portion thereof and or the code program or scripts collectively code B for implementing the hardware designs at various abstraction levels. In some embodiments the RTL design may be further processed via various electronic design automation EDA tools to determine the designs of the microprocessor or a portion thereof at one or more other abstraction levels.

In some other embodiments the code B may be used on various EDA tools to implement the designs of the microprocessor. For example a synthesis tool may be invoked to perform synthesis at B for the RTL design a place and route tool may be invoked to perform placement and routing B for the synthesized design to generate a layout a verification engine or DRC design rule checking tool may perform various verifications or design rule checks B on the layout chip integration B may be further performed for the design and the signed off design may be forwarded to tapeout B for manufacturing.

The processor generator output may also include output for modeling and expansion suit B. The modeling and expansion suit B may include the system design and design methodology support B which automatically generates a software development tool chain. For example the processor generator B may process the source description B with the designer specified configuration inputs B to automatically generate the code that drives one or more simulators and or sets up the simulation environments B the processor generator B may also automatically generate the code that drives one or more emulators and or sets up the emulation environments B or the processor generator B may further automatically generate the code that drives one or more software hardware co simulations and or sets up the environments therefor B in some embodiments.

The software development tool chain automatically generated by the system design and design methodology support B may further include for example an integrated development environment IDE including a base environment and an extensible plugin system for customizing the base environment. The integrated development environment may be used to develop applications such as those compilers simulators emulators assemblers profilers linkers debuggers etc. in B and B.

The modeling and expansion suit B may further include one or more design expansion tools B that may include for example one or more compilers B e.g. a vectorizing C C compiler for parallelization etc. other program code B such as assembler linker debugger debug probes performance or code profiler etc. and the supporting libraries B. The one or more compilers B may be used to generate for example microprocessor configurations from a standard programming language code such as C or C code. The design expansion tools B may also include instruction set simulator e.g. a pipeline modeled cycle accurate instruction set simulator various application programming interfaces APIs for various simulators emulators compilers etc.

The schematic flow diagram illustrated in may further include an optimization loop B to optimize various aspects of the microprocessor design while accounting for the source description B and the designer specified configuration input B. For example the optimization loop may include various processor optimization modules and corresponding environment B to compile B and generate the executables B for the corresponding source code B of various algorithms functions instruction extensions functional units execution units etc. These executables B may be executed and profiled B with one or more code profilers and or one or more performance profilers on a microprocessor simulation model e.g. an instruction set simulator or ISS that simulates the behavior of the microprocessor of design interest based on the instructions read and the internal variables or states representing the microprocessor s registers.

Based on the profiling or simulation results of the microprocessor simulation model with the executables B of the source code B one or more new extensions and or one or more new configurations may be developed or determined at B to meet the targeted or desired tasks applications instructions and or performance objectives for the microprocessor design of interest. These one or more new extensions and or one or more new configurations may be forwarded to the source description B and or the designer specified configuration input B of the input B for the processor generation module B to generate the processor generator output B B and or B. In some embodiments the optimization loop B may perform for example algorithm performance optimization instruction set optimization power optimization microprocessor area and or speed optimization etc. for the microprocessor design of interest.

In these embodiments illustrated in the processor generator B may receive the source description B and the designer specified configuration input B to automatically generate various program code models libraries environments etc. that may be further used to custom tailor the microprocessor design to an exact fit for the targeted or desired tasks applications instructions and or performance objectives. In various embodiments various modules are integrated together to automatically generate various components described in . For example various modules are integrated together for the compiler B to elaborate the source description B to automatically generate the dynamic linking libraries and or modules B which may be further used together with the designer specified configuration inputs B to automatically invoke the processor generator B to generate various modules code information or data in the processor generator module B the modeling and expansion suit B and the optimization loop B without human intervention.

An early bypass includes the bypass route that is devised to forward data to an execution stage of the instruction pipeline of the microprocessor and a late bypass includes the bypass route that is devised to forward data to another execution stage that is located after the current execution stage in the execution pipeline. Generally both the cycle count and frequency increase as the late bypasses are removed as illustrated in .

In some embodiments the method or system may add an optional keyword in the register file construct to inform the compiler e.g. compiler to remove all late bypasses for the register file bypass network. In response the compiler may pass an optional argument to the register file generator e.g. the register file generator to inform that the register file bypass network does not have late bypasses. The register file generator which may be a part of the compiler e.g. reference character of or B of may then remove all late bypasses in the register file in some embodiments or generate the register file without having any late bypasses in some other embodiments at .

In some of these embodiments illustrated in the method or system may further determine whether early bypasses exist in all non first stage read pipeline. If it is determined that at least some of the early bypasses do not exist in the non first stage read pipeline the method or system may further ensure that early bypasses are added back to all non first stage read pipeline in some of these embodiments. In these embodiments the early bypasses for the first stage of the read pipeline already exist and are not removed by the actions at and thus no changes are needed. In addition or in the alternative the stall logic may become more complex due to the removal of late bypasses from the register file bypass network in some embodiments. The method or system may add one or more additional stall conditions in response to the removal of late bypasses at .

One of the advantages of these embodiments illustrated in is that because the late bypass to the all stages of a read port are removed timing may be improved and routing congestion may be alleviated. The first stage of a read port may often be timing critical and late bypasses to a lot of stages may cause routing congestion due to the locations of these routes and also the total number of these late bypasses. This advantage is especially apparent for higher frequency designs or for register file ports each containing one read port stage. In some embodiments the method or system may convert late bypasses to other stages into early bypasses of the following stage in the instruction pipeline. In these embodiments these bypass routes still exist in the design but are delayed a cycle with relaxed timing requirements.

At the method or system may selectively add one or more bypasses to the register file bypass network of a microprocessor design. In some of these embodiments illustrated in the method or system selectively adds the minimum number of bypasses to the register file bypass network. In addition or in the alternative the method or system may automatically add one or more bypasses to the register file bypass network based at least in part upon analysis results of a plurality of instructions to be executed by the microprocessor.

For example the method or system may analyze the plurality of instructions and selectively identify and add a bypass route that bypasses a first operation to a second operation in some embodiments. The method or system may analyze the plurality of instructions and selectively identify and add a bypass route that bypasses a first operand to a second operand in some other embodiments. Yet in some other embodiments the method or system may analyze the plurality of instructions and selectively identify and add a bypass route that bypasses a first port stage to a second port stage. A bypass may be specified in a bypass specification e.g. source description of or B of in a format understood by the compiler e.g. the instruction set extension compiler of or the compiler B of so that the compiler may elaborate the bypass specification and map the operands to the corresponding ports and to generate the hardware design for the bypass specification.

In some embodiments the method or system may use an instruction group for bypass specification. One of the advantages of using an instruction group is to avoid specifying many bypass constructs on the same bypass routes. An instruction group may be declared by designers or users in some embodiments and one or more default instruction groups may also be automatically defined or provided by the method or system. An instruction group may be declared or created by using the following illustrative syntax 

In a bypass specification the method or system may use the name of the instruction group in place of the identification of an opcode or operation as provided in other illustrative examples described in this application. For example the instruction group described immediately above may reference the name of the corresponding instruction group instead of the opcode or operation for a plurality of instructions sharing a bypass as long as the operand or operation argument in the plurality of instructions have the same use stage and def stage and the plurality of instructions associated with the instruction group have the same operand or operation argument and are declared in the same slot index.

It shall be noted that although the specification contains some illustrative code that is expressed in a specific programming language various embodiments described in this application may also perform their respective functions to achieve their respective purposes when the illustrative code is expressed in one or more other programming languages. Therefore the representation of the illustrative code in a particular programming language having specific syntactical requirements shall not be considered as limiting the scope of the claims or the scope of various embodiments described in this Disclosure.

In addition or in the alternative the method or system may also revise or create a pertinent section of code for an electronic design automation tool to associate a register file with a group that includes one destination of a bypass. The method or system may further associate the same group with multiple instructions if the method or system determines that these multiple instructions have the same bypass destination in some of these embodiments regardless of whether or not these multiple instructions have the same bypass source or different bypass sources. In one embodiment the method or system may identify the total number of read port stages as the maximum number of groups.

An opcode or operation code may include the portion of a machine language instruction that specifies the operation to be performed in some embodiments. In these embodiments the specifications and format of opcodes may be specified in the ISA of the microprocessor of interest. The method or system may also define the complex types for opcodes from multiple basic types to support selective bypasses.

In some embodiments where the compiler e.g. the C C compiler in of may not have the slotting information e.g. instruction slotting information used for deciding which of the next instructions may be issued or for steering an instruction to a proper functional or execution unit for the operations when scheduling the operations the appropriate granularity for specifying a bypass may include the tuple operation argument operation argument to ensure accurate read after write delay information even though the appropriate granularity to specify the bypass on the hardware side may include the tuple pair operation argument slot index operation argument slot index . It shall be noted that in these embodiments one bypass specification may correspond to multiple bypasses. For example if a bypass is specified as regbypass oper1 arg1 oper2 arg2 in the complier where oper1 is referenced in two slot indices 0 1 and oper2 is referenced in two slot indices 1 2 . The aforementioned bypass specification indicates four bypasses from slot index 0 to slot index 1 from slot index 0 to slot index 2 from slot index 1 to slot index 1 and from slot index 1 to slot index 2 .

Further the following simplified illustrative construct regbypass construct may be used for a bypass specification 

In the above illustrative simplified construct regbypass denotes a keyword or identification for a bypass specification and is followed by two tuples. The first tuple opeartiton1 arg1 or opcode1 operand1 specifies the source of the bypass arg1 of operation1 or operand1 of the instruction opcode1 . The second tuple opeartiton2 arg2 or opcode2 operand2 specifies the destination of the bypass arg2 of operation2 or operand2 of the instruction opcode2 .

In some of these embodiments where the compiler e.g. the C C compiler in of may not have the slotting information e.g. instruction slotting information used for deciding which of the next instructions may be issued or for steering an instruction to a proper functional or execution unit for the operations when scheduling the operations or where the compiler may require that the bypasses be slot index independent the libraries for the instruction set architecture ISA hereinafter ISA libraries may need to be modified so that the compiler may be informed of the late bypasses. The ISA libraries may be written out by the instruction set extension compiler e.g. the compiler of or compiler B of and may be used to retrieve instruction information including for example encodings operands etc. in some embodiments.

In some of these embodiments the compiler e.g. an instruction set extension compiler in may also write out the opcode array for some or all instructions when the compiler writes out the ISA libraries. The ISA libraries written out by this compiler may be merged with existing ISA libraries in some embodiments. After the merger of ISA libraries the method or system reads and processes only the latest or last written out ISA library components and ignores all previous versions of the corresponding ISA library components.

In some embodiments the ISA libraries may be modified include one or more functions in the ISA libraries interface to indicate whether the register file construct includes the no bypass attribute. In addition or in the alternative the ISA libraries may be modified to include one or more function in the ISA libraries interface to indicate whether the delay between two instruction sequences from the source operand to the destination operand needs to be reduced by one cycle. When the compiler e.g. the instruction set extension compiler of or compiler B of receives the construct illustrated above the compiler may still convert the above construct into a more detailed construct including the slot indices. For example the compiler may convert the above simplified illustrative example into the following more detailed construct 

The method or system may further ensure that the hardware description module e.g. a Verilog module of the compiler e.g. compiler of or B of includes proper arguments for each write port stage and read port stage of a register file. For example the method or system may include the following arguments for each bypass whose source comes from a write port stage wr data C wr def C wr wen C wr  data C wr  def C and wr  wen C . In these arguments indicates a write port indicates a write stage in the write port and wr data C indicates the data written to the register file in stage of write port . In addition wr def C denotes a one bit signal defined in the decode stage to indicate whether the instruction in the decode stage writes to the stage of the write port and wr wen C indicates whether the write to stage of write port actually happens. Similarly wr  data C wr  def C and wr  wen C denote the data signal def signal and enable signal for the bypass route . The compiler may transmit the following information to the register file generator for the illustrative construct provided above 

In the above illustrative code passed from the compiler to the register file generator the entry NAME s indicates a unique identifier used in the hardware description module interface the entry WIDTH d indicates the width of the bypass and may be used for register file views the entry FROM s indicates the write port name of the source the entry FROM STAGE d indicates the write port stage of the source of the bypass the entry TO s indicates the read port name of the destination of the bypass the entry TO STAGE d indicates the read port stage of the destination of the bypass.

In the aforementioned example the compiler e.g. the instruction set extension compiler of or the compiler B of may connect various output operands negation of the output operation kill or opcode decode to corresponding arguments so that the compiler may elaborate the bypass specification and map the operands to the corresponding ports and to generate the hardware design for the bypass specification. For example the compiler may connect the operation output operand to wr  data C connect the negation of the operation output kill to wr  wen C and connect the opcode decode to wr  def C. In the aforementioned example illustrated above denotes the register file port name denotes the bypass identification number e.g. a group number and denotes the register file port stage number.

Once the compiler receives and elaborates the bypass specification the compiler sends the compiled information or data to the register file generator that in turn generates among other things dedicated hardware design components for the bypass specification in these embodiments. For example the register file generator creates the selective late bypasses by replacing wr data C wr wen

In these embodiments the register file generator creates the one or more specified bypasses in the register file bypass network rather than creating a full bypass network. In some of these embodiments the compiler groups multiple operations that share one bypass from one write port to one read port by passing one or more former operation arguments to the one or more corresponding latter operation arguments. In addition or in the alternative the source destination delay of the operations in an operation pair that is bypassed may be reduced by one cycle from the previous calculation if there is no late bypass. In some of the immediately preceding embodiments the compiler groups all operations that share one bypass from one write port to one read port.

In some of these embodiments the compiler may not attempt to reduce the hardware design components or leverage the free riders such that the implementation and automatic generation of the hardware designs for the bypass network is straightforward although these embodiments may achieve such intended purposes at a slight expense of having additional software or hardware elements. In these embodiments the method or system may provide one or more options including leveraging the free riders to the designer to better balance between the ease of automatic generation of various hardware designs and software tools and the expenses of having additional software code or hardware designs.

In some embodiments where multiple output operands in a write port stage are bypassed to the same read port stage the compiler e.g. compiler of or compiler B of multiplexes the data such that at most one bypass is created for each write port stage and read port stage pair. At the method or system may optionally share one or more existing bypasses among a plurality of instructions. The plurality of instructions may include those sharing a semantic output in some embodiments. In these embodiments the bypass for one instruction on the output may also be used to bypass one or more other instructions sharing the semantic output without additional hardware or cost. In addition or in the alternative data in some instructions or instruction sequences may be bypassed without having or requiring any bypass specifications and such instructions instruction sequences operands port stages or the data therein are generally referred to as free riders in this application. A semantic describes the hardware that implements an operation while an operation block describes the behavior of the operation. A semantic may be used to implement more than one operations in some embodiments.

In addition or in the alternative the bypass specified to one operand in a port stage may be shared with one or more other operands in the port stage. In some of these embodiments a user specifies the bypass and the bypass specified to one operand in a port stage may be shared with all the other operands in the port stage without incurring additional hardware or cost. One of the advantages of supporting free riders is the reduction in the need for explicit bypass specifications at least for some instructions instruction sequences or operands. In some of these embodiments explicit bypass specification is required only for the bypasses required by software applications. Additionally or alternatively some instructions rarely appear in software applications and thus may not be justified to have their dedicated bypass specifications. If a bypass has already been specified for another instruction these instructions may share the already specified bypass at no additional hardware or cost if it is desirable to do so. Furthermore providing the option to share one or more already specified bypasses for these instructions alleviates and turn the hard bypass constraints into soft bypass constraints which impose relatively lower impact on frequency such that these bypasses for these instructions may be safely removed when designers place the instructions to one or more new slots and thus impose additional hardware or cost for the corresponding bypasses .

In terms of hardware designs one of the advantages of supporting free riders is that some or all instructions sharing the same output operand in a semantic may share a bypass. In some embodiments where an operand is defined only in a semantic the control signal includes the def signal of the operand and thus requires no new signals. In these embodiments where multiple operands in one write port stage share the same bypass routes the control signal may be obtained by performing the logical disjunction or of the operand def signals without the need for omitting one or two instructions to achieve the same purposes. A def signal or def statement instructs the compiler e.g. the compiler in or compiler B in that the output of an instruction must be defined by the end of a pipeline stage in some embodiments. In addition or in the alternative the hardware design is more efficient and simpler to bypass multiple or even all operands in a port stage if a bypass already exists to the read port stage due to one operand because the compiler e.g. compiler of or B of needs only to generate the rd use C signal which is required regardless of whether or not a bypass exists and pipe down the signal to the following instruction pipeline stages. Therefore additional hardware and cost in terms of area on the die may be avoided.

To support free riders the method or system may use the compiler e.g. the compiler in or the compiler B in to determine the free riders and generate the control logic accordingly in some embodiments. In some of these embodiments where a plurality of instructions share a semantic output the method or system may simply identify the data value for the output operand and the enable signal both of which already exist and include the plurality of instructions in the control signal e.g. the control signal wr  def C . In addition or in the alternative the compiler may determine the free riders by identifying the instructions in the semantic in a slot index that writes to the output operands.

In some of these embodiments of bypassing to one operand in a port stage the compiler may use a signal e.g. the rd use C signal to indicate that the bypass is to all operands in the port stage. In addition or in the alternative the compiler may determine the free riders by identifying some or all instructions that read from the port stage. In some of the embodiments illustrated in the compiler may further determine whether or not a free rider determined by the compiler benefit from the bypass in all slot indices. If the determination is affirmation the method or system may make the bypass visible to software applications. Otherwise the bypass will be rendered a software invisible bypass.

At the method or system may further optionally bypass an entire write port stage to a read port stage in some embodiments. In these embodiments the method or system needs not generate and pass dedicated data enable signals and def signals to the register file generation module. Rather the method or system may use the data enable signals and the def signals for the write port stage. In addition the method or system needs not generate the def pipeline stage and may use the def pipeline stage for the write port. The need for a separate multiplexer for the data enable signals and def signals may also be obviated when an entire port is bypassed. In some embodiments where a port is bypassed the method or system may use the output of a four to one multiplexer instead of creating a new three to one multiplexer that may increase the load of input signals and further delay the four to one multiplexer.

The method or system may use the following illustrative construct to specify the bypass from port to port regbypass . In some embodiments where both the port bypass and operand bypass co exist the port bypass takes precedence and the method or system may ignore the operand bypass. In some other embodiments the method or system may determine whether all operands in a port stage are bypassed to another port stage. If the determination is affirmative the compiler e.g. the compiler of or compiler B of may create a port bypass for the port stage and pass the port bypass to the register file generator to generate the hardware design.

In these embodiments where the method or system determines to bypass a write port stage to a read port stage the method or system may use the compiler to pass the original write port data the enable signals and the def signals in the bypass to the register file generation module without passing the bypass data e.g. we data C the enable signals e.g. wr wen C and the def signals e.g. wr def C separately to the register file generation module. In some of these embodiments the compiler may pass the following information or data to the register file generator 

In the above example WIDTH d denotes the width of the bypass and may be needed for register file views FROM s denotes the write port name of the source FROM STAGE d denotes the write port stage of the source TO s denotes the read port name of the destination and TO STAGE d denotes the read port stage of the destination. In those embodiments where the write port stage is bypassed the NAME s indicating the identification of the write port stage is ignored.

The process or module A may pass an argument no late bypass to the register file generator to inform the generator that the register file does not have late bypasses in some embodiments. At A the register file generator removes all late bypasses from the register file bypass network in some embodiments or generates the register file bypass network without late bypasses in some other embodiments. The register file generator may further add one or more early bypasses to the register file network at A. In some of these embodiments illustrated in the process or module may further determine whether early bypasses exist in all non first stage read pipeline. If it is determined that at least some of the early bypasses do not exist in the non first stage read pipeline the method or system may further ensure that early bypasses are added back to all non first stage read pipeline in some of these embodiments.

In these embodiments the early bypasses for the first stage of the read pipeline already exist and are not removed by the actions and thus no changes are needed. Additional stall logic may be added in response to the removal of the late bypasses at A. The stall logic may become more complex due to the removal of late bypasses from the register file bypass network in some embodiments. The method or system may thus add one or more additional stall conditions in response to the removal of late bypasses. At A the process or module may delay a cycle or relax one or more timing requirements or constraints for one or more late bypass routes by converting late bypasses to other stages into early bypasses of the following stage in the instruction pipeline. In these embodiments these bypass routes still exist in the design but are delayed a cycle with relaxed timing requirements. At A the process or module may add a cycle to the output operands of the register file whose late bypasses are removed.

In some embodiments where the compiler may not have the slotting information e.g. instruction slotting information used for deciding which of the next instructions may be issued or for steering an instruction to a proper functional or execution unit for the operations when scheduling the operations the appropriate granularity level for specifying a bypass may include the tuple operation argument operation argument to ensure accurate read after write delay information even though the appropriate granularity level to specify the bypass on the hardware side may include the tuple pair operation argument slot index operation argument slot index .

At B the process or module may identify a bypass specification that corresponds to multiple bypasses in the register file and use the bypass specification for these multiple bypasses without having to create or use more than one bypass specification for the multiple bypasses in some embodiments. As an illustrative example if a bypass is specified as regbypass oper1 arg1 oper2 arg2 in the complier where oper1 is referenced in two slot indices 0 1 and oper2 is referenced in two slot indices 1 2 . The aforementioned bypass specification indicates four bypasses from slot index 0 to slot index 1 from slot index 0 to slot index 2 from slot index 1 to slot index 1 and from slot index 1 to slot index 2 . In this illustrative example the process or module may use the bypass specification for the four bypasses indicated above. An illustrative bypass specification and register file bypass construct are provided above with reference to reference numeral of .

At the compiler may elaborate the two tuple in the bypass specification which includes the tuple operation argument operation argument to include the corresponding slot index information in the two tuple. That is the compiler elaborates the two tuple of a bypass specification into operation argument slot index operation argument slot index that represents the appropriate granularity level on the hardware side to ensure accurate read after write delay information. The compiler e.g. the compiler in or compiler B in may further map one or more operands to one or more ports at B.

The process or module may further invoke the compiler to group a plurality of operations that share one bypass from one write port stage to one read port stage at B in some embodiments. By grouping the plurality of operations sharing the same bypass the compiler may thus generate the information or data for the bypass network and forward the information or data to the processor generator e.g. the processor generator of or B of to generate the hardware design for the bypass network with the bypass shared among the plurality of operations in these embodiments.

At B the process or module may further invoke the compiler to pass information of the register file to the register file generator. For example the compiler may transmit the following information to the register file generator as described above with reference to reference numeral of 

The description of reference numerals B B and B illustrates the tasks or acts for the hardware designs e.g. hardware design of . At B the process or module may invoke the compiler e.g. the compiler in or compiler B in to pass the information of the register file to the register file generator to generate dedicated hardware design for each bypass specification. In these illustrated embodiments the process or module may or may not take advantage of free riders when generating the dedicated hardware design. More details about free riders are described above with reference to reference numeral of .

In generating the hardware design the compiler e.g. the instruction set extension compiler may connect the operation output operand the negation of operation kill and the opcode decode. For example the compiler may further connect an operation output operand to wr data C connect the negation of the operation to the operation output kill to wr  wen C and connect the opcode decode to wr  def C at B. In the above signals denotes the register file port name denotes the bypass identification number e.g. group number and denotes the register file port stage number. The compiler may then generate the hardware design for the late bypass routes at B.

The description of reference numerals B B B and B illustrate the tasks or acts for the software tools for implementing a microprocessor with a selective register file bypass network. The process or module may further identify or determine one or more requirements for a write port stage at B. In some of these illustrated embodiments the one or more requirements may include for example the following arguments for each bypass whose source comes from a write port stage wr data C wr def C wr wen C wr  data C wr  def C and wr  wen C . In some embodiments where the process or module determines that one or more aforementioned arguments are missing the process or module B may invoke the compiler of or B of to add these one or more missing arguments to a write port stage of a register file.

The process or module may further determine whether the first operation argument is bypassed to a second operation argument in one bypass route at B. In some embodiments where it is determined that the first operation argument is determined at B not to be bypassed to the second operation argument the first operation argument to second operation argument delay is unchanged at B. The process or module may invoke the compiler e.g. the instruction set extension compiler to pass the information or data of the bypass network to the processor generator or more specifically the register file generation module therein which in turn generates among other things the hardware design for the bypass network with selective bypasses as identified or determined above.

If it is determined that a first operation argument of a first operation may be bypassed to a second operation argument of a second operation in one bypass route at B the process or module may then bypass the first operation argument to the second operation argument in a plurality of bypasses at B. In these embodiments if a former operation argument is bypassed to a latter operation argument in one bypass route the former operation argument is bypassed to the later operation argument in the plurality of bypass routes.

In some of these illustrated embodiments the register file generation module generates the bypass network by using the specified bypass information or data in the read port instead of the original data without the bypass specification. In these embodiments once the compiler receives and elaborates the bypass specification and sends the compiled information or data to the register file generator the register file generator uses the information passed from the compiler to generate among other things dedicated hardware design components for the bypass specification in these embodiments. For example the register file generator may generate the late bypasses by replacing the original data value for the output operand the enable signal and the def signal such as wr data C wr wen

In some of these embodiments the process or module D may invoke the compiler to specify the same bypass for all the instructions sharing the same semantic output. In sharing a bypass among a plurality of instructions within the context of the same semantic the process or module may further identify and examine a plurality of instructions in the semantic in a slot index that writes to the output operands at D and generate the control logic accordingly at D. In some of these embodiments where the plurality of instructions share the same semantic the compiler may include the plurality of instructions in or associate the plurality of instructions with the control signal e.g. wr  def C at D because the output operand and the enable signal are already available. In these embodiments the same data value for the output and the enable signal for the output operand may be used for the plurality of instructions.

Actions D through D describe some illustrative optional approach for bypassing to an operand in a port stage. At D the process or module may optionally identify a plurality of instructions reading from a port stage. In some of these illustrated embodiments the process or module may invoke the compiler to elaborate or calculate the plurality of instructions that read from the port stage of interest. The process or module may further bypass to an operand in the port stage using an identified bypass at D and indicate the bypass to one or more other operands in the read port stage at D such that these one or more other operands in the port stage may also share the identified bypass.

In these illustrated embodiments the process or module may utilize a bypass route that already exists to one port stage due to one operand in one or more other operands in the port stage with no additional cost or hardware because the compiler e.g. the compiler of or the compiler B of needs to generate the control signal e.g. rd use C signal which is required whether or not a bypass exists to indicate the same bypass to these one or more other operands in the port stage. In these embodiments the compiler generates the control signal and pipe down the control signal to the following instruction pipeline stages without incurring any additional hardware cost e.g. additional area on silicon etc. 

At D the process or module may check whether the instructions determined above may take advantage of the bypass in some or all slot indices by determining whether the instructions identified or determined at D and or D may take advantage of the bypass route in some or all slot indices. If it is determined that the instructions identified or determined at D and or D may take advantage of the bypass route in some or all slot indices the process or module may render the bypass route software visible at D. Otherwise the process or module may render the bypass route software invisible at D.

In these illustrated embodiments the process or module may invoke the compiler e.g. the compiler of or compiler B of to identify a bypass from a first port stage to a second port stage at E and identify the write port data the enable signal and the def signal of the first port at E. The process or module may further create a construct to bypass from the first port to the second port at E. In some of these embodiments the process or module may invoke the compiler to pass code and one or more arguments to the register file generation module to generate the hardware design for the register file including the register file bypass network at E. For example the following construct may be generated to specify a bypass from a write port stage to a read port stage 

In the above illustrative construct the specification indicates the port stage to be bypassed from and the specification indicates the port stage to be bypassed to.

In some embodiments where the method or system determines to bypass a write port stage to a read port stage the method or system may invoke the compiler to pass the original write port data the enable signals and the def signals in the bypass to the register file generation module without passing the bypass data e.g. we data C the enable signals e.g. wr wen C and the def signals e.g. wr def C separately to the register file generation module. In some of these embodiments the compiler may pass the following bypass information or data to the register file generation module to generate the hardware design for the at least a part of the register file as described in reference numeral of 

In the above illustrative information or data passed from the compiler to the register file generation module the compiler adds the PORT BYPASS argument to the bypass specification.

In some of these illustrated embodiments the process or module may invoke the same compiler to convert the port to port bypass from a first port stage to a second port stage into an operand to operand bypass at E and pass the operand to operand bypass information to one or more tools e.g. the one or more tools or of or the tools B B or B of at E to perform their respective functions. The process or module may further optionally check some pertinent instructions to determine whether these pertinent instructions take advantage of the bypass identified at E or E.

At E the process or module may invoke the compiler to determine whether or not the pertinent instructions take advantage of the identified port to port bypass or the converted operand to operand bypass. In some of these embodiments where the process or module determines that these pertinent instructions do take advantage of the bypass in some or all slot indices the process or module may render the bypass route software visible at E. Otherwise the process or module may render the bypass route software invisible at E.

The full bypass network also includes additional multiplexers for late bypasses . Moreover Op n in represents operations of n cycle latency. For example Op 1 represents operations of 1 cycle latency Op 2 represents operations of 2 cycle latency and Op 3 represents operations of 3 cycle latency. Reference numerals represents the commit point and the schematic level traces represents late bypasses of the simplified register file bypass network.

According to one embodiment computer system performs specific operations by one or more processor or processor cores executing one or more sequences of one or more instructions contained in system memory . Such instructions may be read into system memory from another computer readable usable storage medium such as static storage device or disk drive . In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and or software. In one embodiment the term logic shall mean any combination of software or hardware that is used to implement all or part of the invention.

Various actions or processes as described in the preceding paragraphs may be performed by using one or more processors one or more processor cores or combination thereof where the one or more processors one or more processor cores or combination thereof executes one or more threads. For example the act of specifying various net or terminal sets or the act or module of performing verification or simulation etc. may be performed by one or more processors one or more processor cores or combination thereof. In one embodiment the parasitic extraction current solving current density computation and current or current density verification is done in memory as layout objects or nets are created or modified.

The term computer readable storage medium or computer usable storage medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as disk drive . Volatile media includes dynamic memory such as system memory . Common forms of computer readable storage media includes for example electromechanical disk drives such as a floppy disk a flexible disk or a hard disk a flash based RAM based such as SRAM DRAM SDRAM DDR MRAM etc. or any other solid state drives SSD magnetic tape any other magnetic or magneto optical medium CD ROM any other optical medium any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge or any other medium from which a computer can read.

In an embodiment of the invention execution of the sequences of instructions to practice the invention is performed by a single computer system . According to other embodiments of the invention two or more computer systems coupled by communication link e.g. LAN PTSN or wireless network may perform the sequence of instructions required to practice the invention in coordination with one another.

Computer system may transmit and receive messages data and instructions including program i.e. application code through communication link and communication interface . Received program code may be executed by processor as it is received and or stored in disk drive or other non volatile storage for later execution. In an embodiment the computer system operates in conjunction with a data storage system e.g. a data storage system that includes a database that is readily accessible by the computer system . The computer system communicates with the data storage system through a data interface . A data interface which is coupled to the bus e.g. memory bus system bus data bus etc. transmits and receives electrical electromagnetic or optical signals that include data streams representing various types of signal information e.g. instructions messages and data. In embodiments of the invention the functions of the data interface may be performed by the communication interface .

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. For example the above described process flows are described with reference to a particular ordering of process actions. However the ordering of many of the described process actions may be changed without affecting the scope or operation of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense.

