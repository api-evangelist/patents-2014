---

title: Methods and systems for run-time hardware configuration change management
abstract: This disclosure relates to systems and methods for reconfiguring hardware at run-time. In multi-tasking environments, applications may depend on specific hardware configurations for their execution. The run-time hardware configuration change management API can receive hardware configuration requests from applications, accept or deny configuration requests, arbitrate conflicting configuration requests, and apply configuration requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483282&OS=09483282&RS=09483282
owner: Altera Corporation
number: 09483282
owner_city: San Jose
owner_country: US
publication_date: 20140530
---
An embedded computer generally refers to a computer system that performs a dedicated function. Such systems often have to satisfy real time computing requirements. From a hardware standpoint most embedded computers are not reconfigurable i.e. the set of features is fixed and cannot be changed at run time which is the time during which a program is running.

One configuration for implementing embedded systems is a system on a chip SoC which may be an integrated circuit integrating all components of a computer such as digital analog mixed signal and radio frequency functions on a single chip substrate. SoCs may be implemented using an application specific integrated circuit ASIC or a field programmable gate array FPGA . In particular an FPGA is field programmable i.e. it is an integrated circuit designed to be configured by a user after it has been manufactured. This aspect of FPGAs opens up the possibility of reconfiguring the hardware of embedded systems at run time.

However an operating system OS running on embedded computers generally expects the hardware configuration of the embedded computer to be fixed and is not designed to manage configuring and or reconfiguring hardware that changes over time. While an OS may be able to arbitrate the use of fixed hardware the OS may not be capable of handling configuring and or reconfiguring hardware that changes over time. Therefore it would be desirable to have a framework that enables applications to request a specific hardware configuration of the embedded computer and that can manage the SoCs resources.

To address the above and other shortcomings within the art the present disclosure provides methods and systems for enabling applications to request a specific hardware configuration of the embedded computer and managing the SoC resources.

In accordance with the present invention there is provided a method for configuring hardware circuitry at run time. The method includes receiving at a management module a first request for configuring the hardware circuitry at run time from a first application and a second request for configuring the hardware circuitry at run time. The management module may identify a conflict between the first request and the second request and select one of the first request and the second request for configuring the hardware circuitry at run time. The hardware circuitry may be configured at run time using the selected one of the first request and the second request.

To provide an overall understanding of the invention certain illustrative embodiments will now be described. However it will be understood by one of ordinary skill in the art that the systems and methods described herein may be adapted and modified as is appropriate for the application being addressed and that the systems and methods described herein may be employed in other suitable applications and that such other additions and modifications will not depart from the scope hereof.

The integration of FPGAs with SoCs enables run time configuration and reconfiguration of embedded hardware components. For example hardware components that may be configured or reconfigured at run time may be any components of the FPGA.

An exemplary use case of such configuration and or reconfiguration of embedded hardware is the following Two applications are running on an embedded computer. The first application is a video application which requires video processing hardware for optimal operation the second application is an encryption decryption application which requires corresponding hardware acceleration for optimal operation. The first and the second applications thus require two different embedded hardware configurations for optimal operation. The FPGA of the embedded computer is capable of being configured to provide the hardware acceleration desired by both applications. Applications may accordingly request a certain configuration of the embedded hardware.

A configuration of the embedded hardware may be characterized by any one of or a combination of an FPGA bitstream a set of device drivers a description of the hardware and a memory map. Accordingly an application requesting a desired configuration and or reconfiguration of embedded hardware may specify its request via any one of or a combination of an FPGA bitstream a set of device drivers a description of the hardware and a memory map. An FPGA bitstream may be a functional definition of the FPGA. It may be received from an off chip source. A device driver may be a computer program that operates or controls a particular type of device attached to a computer. A memory map may be a data structure that indicates how computer memory is laid out.

Some FPGAs support partial reconfiguration which is the process of changing a portion of reconfigurable hardware circuitry while the other part is still operating. An FPGA may be partially reconfigured by loading a partial reconfiguration bitstream onto the FPGA. However FPGAs that support partial reconfiguration are typically not capable of handling configuration and or reconfiguration requests from multiple applications at run time. In order to support partial reconfiguration at run time a framework to control reconfiguration requests received from various applications may be advantageous. Referring back to the example described above it may additionally be advantageous for such a framework to be able to arbitrate reconfiguration requests received from various applications.

Operating systems e.g. Linux do not provide an application programming interface API that enables concurrent users or applications to request a configuration and or reconfiguration of embedded hardware at run time. Arbitration of concurrent requests for configuration and or reconfiguration of embedded hardware at run time is also not supported.

In some embodiments at least some components of run time hardware configuration change management architecture may be located on an integrated circuit an application specific integrated circuit ASIC an application specific standard product ASSP a Programmable Logic Device PLD a Field Programmable Gate Array FPGA a full custom chip or a dedicated chip. It should also be understood that the run time hardware configuration change management architecture may be located on a combination of devices such as a FPGA and an ASIC and or may include additional stand alone circuit components.

In some embodiments run time hardware configuration change management architecture may be implemented as an API of the OS of the embedded computer. The psuedo code below may provide an exemplary description of the API.

The run time hardware configuration change management API may receive hardware configuration requests from applications accept or deny configuration requests arbitrate conflicting configuration requests and apply configuration requests as described in greater detail below.

An OS generally separates virtual memory into user space and kernel space. User space refers to the memory area where all application software and some drivers execute. Kernel space refers to the memory area that is restricted to running privileged kernel and most device drivers.

Run time hardware configuration change management architecture may be an API implemented in the OS of an embedded computer. Run time hardware configuration change management architecture may include FPGA management module and kernel space module . FPGA management module may reside in user space and may interface with applications and and kernel space module . Kernel space module may reside in kernel space and may interface with the embedded hardware such as FPGA to be configured and or reconfigured at run time.

Applications and which may reside in user space are merely illustrative. In practice FPGA management module may interface with more or fewer applications than shown in . Each of applications and may have corresponding priorities and security privileges which may determine when if at all their requests for configuration and or reconfiguration of embedded hardware may be granted. Such functionality is described in greater detail in connection with FPGA management module below.

Applications and may transmit configuration and or reconfiguration requests associated with FPGA to FPGA module . Configuration and or reconfiguration requests may be in the form of bitstreams for FPGA . Configuration and or reconfiguration requests made by applications and may be blocking or non blocking interface calls to the API.

FPGA management module may include application interface bit stream management module device tree management module configuration module and FPGA interface .

Application interface may receive requests for configuration and or reconfiguration of embedded hardware from applications and directed to the API implementing run time hardware configuration change management architecture . Application interface may be communicatively coupled to bitstream management module and device tree management module .

Application interface may parse the requests for configuration and or reconfiguration of embedded hardware received from applications and . For example the configuration and or reconfiguration requests received from applications and may be received in respective containers. Application interface may parse each container to extract the bitstreams corresponding to the requests for configuration and or reconfiguration of embedded hardware received from applications and .

Application interface may provide additional features associated with APIs such as supporting synchronous calls to the API or asynchronous calls to the API. Application interface may also support blocking and non blocking interface functionality of the API. Application interface may rely on bitstream management module for supporting such functionality as described in greater detail below in connection with bitstream management module .

For example to support a blocking interface call to the API application interface may suspend or block the application that transmitted a request to configure and or reconfigure embedded hardware to the API if the embedded hardware configuration requested by the application is unavailable. When the requested embedded hardware configuration becomes available the requesting application may be woken up and be scheduled according to its priority or security privileges. If an application makes a non blocking interface call to the API and the embedded hardware configuration requested by the application is unavailable the requesting application may give up and try making the request again later. Thus application interface may not suspend the requesting application if the application make a non blocking interface call to the API.

Bitstream management module may analyze and check bitstreams for FPGA extracted by application interface from requests for configuration and or reconfiguration of embedded hardware received from applications and . Bitstream management module may be communicatively coupled to application interface FPGA interface and pin constraints module . The following checks may be performed by bit stream management module in any suitable order.

First it may be determined whether a received bitstream is valid for FPGA . For example it may be determined whether a received bitstream satisfies requirements for being loaded onto the embedded hardware.

Second a received bitstream may be analyzed to determine which resources of the embedded hardware e.g. FPGA are being requested for configuration and or reconfiguration. The resources of the embedded hardware currently available i.e. resources not in current use and resources of the embedded hardware currently unavailable i.e. resources already in use may additionally be determined. Such information by be determined via device tree management module as described in greater detail below in connection with device tree management module . Information regarding the resources of the embedded hardware currently available may also be available for display or listing to the user.

Resources of the embedded hardware requested for configuration and or reconfiguration by a received bitstream may be compared to the resources of the embedded hardware currently available. Blocking and non blocking interface functionality of the API may be supported on the basis of such a comparison. For example the requesting application may be blocked till the embedded hardware configuration requested by the application is available or instructed to try re making the request at a later time if the embedded hardware configuration requested by the application is unavailable.

Third it may be determined whether a received bitstream is appropriate for the board on which the embedded hardware is implemented. In particular it may be determined whether a received bitstream matches a board implementing the embedded hardware. For example electrical characteristics such as pin constraints of the board corresponding to the requested configuration may be determined from a received bitstream. The electrical characteristics determined from a received bitstream may be matched to the electrical characteristics of the board implementing the embedded hardware whose configuration and or reconfiguration is requested. The electrical characteristics of the board may be determined via pin constraints module residing in kernel space module as described in greater detail below in connection with pin constraints module .

Bit stream management module may manage security privileges associated with received requests for configuring and or reconfiguring embedded hardware. For example security privileges may be assigned on a per application or a per user basis or a combination of both.

If security privileges are assigned on a per application basis a data structure such as a list may be maintained of applications that can or cannot make requests for configuring and or reconfiguring embedded hardware. For example a black list and a white list of applications may be maintained where applications appearing on the black list cannot make requests for configuring and or reconfiguring embedded hardware while applications appearing on the white list can make requests for configuring and or reconfiguring embedded hardware.

If security privileges are assigned on a per user basis security privileges may be assigned to users in a manner similar to the assignment of security privileges to applications as described above. Security privileges may also be assigned on the basis of groups of users rather than individual users. For example a data structure such as a list may be maintained of certain users or groups of users that can or cannot make requests for configuring and or reconfiguring embedded hardware. As an example Alice and Bob may be allowed to make requests for configuring and or reconfiguring embedded hardware while Charlie and David may not be allowed to make requests for configuring and or reconfiguring embedded hardware. Any of Alice Bob Charlie and David may be future users of the embedded hardware.

Security privileges may additionally and or alternatively be assigned on the basis of device drivers associated with received requests for configuring and or reconfiguring embedded hardware. For example an application may be prevented from making requests for configuring and or reconfiguring embedded hardware if the application requests a configuration of the embedded hardware that is recognized as requiring the use of a device driver that is known to be unstable e.g. belongs to a black list of Linux device drivers.

Bitstream management module may manage priorities associated with requests for configuring and or reconfiguring embedded hardware received from applications. Similar to security privileges priorities may be assigned on a per application or a per user basis or a combination of both.

If priorities are assigned on a per application basis a data structure such as a list may be maintained of the priorities of applications that can make requests for configuring and or reconfiguring embedded hardware. For example requests for configuring and or reconfiguring embedded hardware received from applications with higher priorities may be processed before requests for configuring and or reconfiguring embedded hardware received from applications with lower priorities.

If priorities are assigned on a per user basis a data structure such as a list may be maintained of the priorities corresponding to users that can make requests for configuring and or reconfiguring embedded hardware. For example requests for configuring and or reconfiguring embedded hardware received from users with higher priorities may be processed before requests for configuring and or reconfiguring embedded hardware received from users with lower priorities.

Bitstream management module may arbitrate conflicts between requests for configuring and or reconfiguring embedded hardware received from different applications. Referring back to the example described above if a first application which is a video application requests a configuration of the embedded hardware that provides video processing acceleration and a second application which is an encryption decryption application requests a configuration of the embedded hardware that provides encryption decryption acceleration then the respective requests received from the first and the second applications may be in conflict because the configuration of the embedded hardware required for video processing acceleration may be different than the configuration of the embedded hardware required for encryption decryption acceleration. One skilled in the art will appreciate that more than two applications may make conflicting requests for configuring and or reconfiguring embedded hardware.

Conflicting requests for configuring and or reconfiguring embedded hardware may be arbitrated based on security privileges priorities or any suitable combination thereof. For example arbitration may be based on priorities of the requesting applications. Referring back to the above example if the video application has a higher priority than the encryption decryption application then the configuration of the embedded hardware requested by the video application may be made available before the configuration of the embedded hardware requested by the encryption decryption application. If more than two applications made conflicting requests then the requests for configuration and or reconfiguration of the embedded hardware may be handled in an order corresponding to the priority of the application making the request. For example the request for configuration and or reconfiguration of the embedded hardware received from the application with highest priority may be handled first and the request for configuration and or reconfiguration of the embedded hardware received from the application with lowest priority may be handled last.

For example arbitration may be based on security privileges of the requesting applications where the security privileges are assigned on a per application basis. Referring back to the above example if the video application is on a white list and the encryption decryption application is on a black list then the configuration of the embedded hardware requested by the video application may be made available and the configuration of the embedded hardware requested by the encryption decryption application may not be made available.

Similarly arbitration may be based on security privileges of the requesting applications where the security privileges are assigned on a per user basis. Referring back to the above example if the video application is being operated by a user allowed to request configuration and or reconfiguration of the embedded hardware and the encryption decryption application is being operated by a user who is not allowed to request configuration and or reconfiguration of the embedded hardware then the configuration of the embedded hardware requested by the video application may be made available and the configuration of the embedded hardware requested by the encryption decryption application may not be made available.

Arbitration may also be based on a combination of security privileges assigned on a per application basis and a per user basis. Referring back to the above example if the video application is on a white list and the encryption decryption application is being operated by a user who is not allowed to request configuration and or reconfiguration of the embedded hardware then the configuration of the embedded hardware requested by the video application may be made available and the configuration of the embedded hardware requested by the encryption decryption application may not be made available.

Additional suitable factors such as unstable device drivers associated with requests for configuring and or reconfiguring embedded hardware may also be used to arbitrate conflicts.

Arbitration may not be required if requests for configuring and or reconfiguring embedded hardware received from different applications do not conflict. For example if a first application which is a video application requests a configuration of the embedded hardware that provides video processing acceleration and a second application which is an image application requests a configuration of the embedded hardware that provides image processing acceleration then the respective requests received from the first and the second applications may not be in conflict because the configuration of the embedded hardware required for video processing acceleration may not be different than the configuration of the embedded hardware required for image processing acceleration. In such cases the embedded hardware may be configured based on the configuration requested by the application whose request was received first. The configuration of the embedded hardware may not need to be changed to accommodate the request of the second application. One skilled in the art will appreciate that more than two applications may make non conflicting requests for configuring and or reconfiguring embedded hardware.

Device tree management module may manage dynamic device tree module of kernel module which is described in greater detail below in connection with kernel module . Device tree management module may be communicatively coupled to application interface bitstream management module dynamic device tree of kernel module and device tree of FPGA . Device tree management module may further manage the dynamics of the hardware of the embedded computer. The device tree of the embedded computer may be dynamic because the embedded hardware of the embedded computer is reconfigurable. Device tree management module may indicate changes additions or removals to the configuration of the embedded hardware as discerned by bitstream management module from a bitstream received from an application to dynamic device tree of kernel module . For example if based on analysis of a bitstream received by bitstream management module bitstream management module indicates that certain look up tables LUTs of FPGA should be reconfigured to logic array blocks LABs then device tree management module may pass this information on to dynamic device tree of kernel module .

Configuration module may provide an administration interface to FPGA management module . This administration interface may be accessible by users. Configuration module may define security rules and exceptions as described in greater detail above in connection with application interface . Configuration module may also be used to log the operation of FPGA management module . For example configuration module may log what resources are being used by FPGA .

FPGA interface may be communicatively coupled to bitstream management module and FPGA programming module of kernel module . Bitstream management module may provide instructions to FPGA programming module of kernel module via FPGA interface .

Kernel module may include dynamic device tree module pin constraints module and FPGA programming module .

Dynamic device tree module may describe the hardware in the embedded computer. The OS may use this data to find and register hardware in the embedded computer. Dynamic device tree module may be a data structure in the form of a tree of named nodes and corresponding properties. For example dynamic device tree module may describe the number and type of processors serial interfaces memory addresses and size of RAM. It may additionally describe the embedded hardware such as what type of FPGA is included in the embedded computer and what components are in the FPGA.

Device tree management module may further manage the dynamics of the device of the embedded computer. The device tree of the embedded computer may be dynamic because the embedded hardware of the embedded computer is reconfigurable. Dynamic device tree module may be communicatively coupled to device tree management module of FPGA management module .

Pin constraints module may be communicatively coupled to bitstream management module of FPGA management module . Pin constraints module may determine electrical characteristics such as pin constraints of the board on which the embedded hardware such as FPGA may be implemented. Such electrical characteristics may be used by bitstream management module of FPGA management module to determine whether a received bitstream matches a board implementing the embedded hardware.

FPGA programming module may be communicatively coupled to FPGA and FPGA interface of FPGA management module . FPGA programming module may perform the configuration and or reconfiguration of the embedded hardware such as FPGA upon receiving instructions from FPGA management module to do so after completion of the analysis of a received bitstream by bitstream management module of FPGA management module as described above in connection with bitstream management module . FPGA programming module may configure and or reconfigure FPGA by uploading a bitstream received from bitstream management module to FPGA . FPGA programming module may additionally handle programming device drivers specific to FPGA .

FPGA denotes the embedded hardware to be configured and or reconfigured by a bitstream received from applications or . In an embodiment FPGA may be any reconfigurable integrated circuit such as a PLD or an FPGA.

At a first request to configure and or reconfigure circuitry may be received from a first application. For example a video processing application may transmit a request to the API to configure and or reconfigure embedded hardware such as FPGA of of the embedded computer to provide video acceleration components. Such a request may be received by the API in a substantially similar manner as described above in connection with .

At a second request to configure and or reconfigure circuitry may be received from a second application. For example an encryption decryption application may transmit a request to the API to configure and or reconfigure embedded hardware such as FPGA of of the embedded computer to provide encryption decryption acceleration components. Such a request may be received by the API in a substantially similar manner as described above in connection with .

At the first and the second received requests may be analyzed to determine the resources of the circuitry requested by each of the first request and the second request. For example as described above in connection with FPGA management module of the bitstreams corresponding to the requests for configuration and or reconfiguration of the embedded hardware received from applications may be processed and checked by bitstream management module of . The received bitstreams may be processed to determine whether the bitstreams are valid for the embedded hardware e.g. FPGA of whether the bitstreams are appropriate for the board on which the embedded hardware is implemented and to check what resources of the embedded hardware are being requested.

At a determination may be made as to whether there is a conflict between the first request and the second request. FPGA management module may make this determination in a substantially similar manner as described above in connection with FPGA management module . In response to a determination that there is a conflict between the first and the second requests the process proceeds to otherwise the process proceeds to .

At either the first request or the second request for reconfiguring the circuitry may be selected for processing. For example as described above in connection with FPGA management module of the embedded hardware may be configured based on the configuration requested by the application whose request was received first. The configuration of the embedded hardware may then need not be changed to accommodate the second request. Alternatively embedded hardware may be configured based on the configuration requested by the application whose request was received second. The configuration of the embedded hardware may then need not be changed to accommodate the first request.

At the conflict between the first request and the second request may be arbitrated to select a request for reconfiguring the circuitry. Arbitration of the conflict may proceed in a manner substantially similar to the description of arbitration described above in connection with FPGA management module of .

At the circuitry may be reconfigured using the selected request. Configuration and or reconfiguration of the embedded hardware may be substantially similar to the description of kernel module of .

The following are some exemplary use cases of the applicability of run time hardware configuration change management architecture of .

A reconfigurable computer. Devices such as FPGA s may ably assist a central processing unit CPU on applications such as video processing image processing encryption decryption among many others. For example an FPGA may provide suitable video processing hardware acceleration desired by a video processing application suitable image processing hardware acceleration desired by a image processing application and suitable encryption decryption hardware acceleration desired by a encryption decryption application. However it may not be possible for an FPGA to hold all the hardware required by all of these applications. Instead it may be better to reconfigure the FPGA on demand.

In multitasking and multi user operating systems such as UNIX Linux it is required the applications request hardware configurations because conflicting requests may be issued. The run time hardware configuration change management architecture framework described herein provides a solution to this problem. An inspection of a bitstream received from a requesting application may make certain that the resources requested by a bitstream are available from the FPGA. An application requesting a configuration that conflicts with a current resource status of the FPGA may either be set to sleep i.e. blocked or asked to request the configuration again later relying on the blocking and non blocking features of the API.

Resource Reservation. For example a system may need to check certificates at all times. For efficiency such checking may be best done by an FPGA. This means the FPGA resources may need to be locked or reserved specifically for checking certificates. The run time hardware configuration change management architecture may enable this via application priority management by setting the priority of the certificate management application to be high the system will never remove or evict the certificate management application from using the FPGA resources. Only a privileged user may be able to evict the certificate management application from using the FPGA resources.

Reconfiguration of devices in the field. For example consider mobile phone cell towers and the multitude of mobile devices are spread in the field. The telecommunication service provider may issue a new configuration bitstream drivers or device tree for mobile phone towers. The new configuration may be picked up by an update application running on the mobile phone towers. The down time of mobile phone towers may be minimized since restarting the entire system may not be required.

The run time hardware configuration change management architecture may provide protection against hackers. On open operating systems security is very important. Accordingly the run time hardware configuration change management architecture provides security privileges on a per user and per application basis. The run time hardware configuration change management architecture may also manage a black list of drivers that are known to be problematic.

System could be used in a wide variety of applications such as computer networking data networking instrumentation video processing digital signal processing or any other application where the advantage of using programmable or reprogrammable logic is desirable. Circuit can be used to perform a variety of different logic functions. For example circuit can be configured as a processor or controller that works in cooperation with processor . Circuit may also be used as an arbiter for arbitrating access to a shared resource in system . In yet another example circuit can be configured as an interface between processor and one of the other components in system . It should be noted that system is only exemplary and that the true scope and spirit of the invention should be indicated by the following claims.

Although components in the above disclosure are described as being connected with one another they may instead be connected to one another possibly via other components in between them. It will be understood that the foregoing are only illustrative of the principles of the invention and that various modifications can be made by those skilled in the art without departing from the scope and spirit of the invention. One skilled in the art will appreciate that the present invention can be practiced by other than the described embodiments which are presented for purposes of illustration and not of limitation and the present invention is limited only by the claims that follow.

