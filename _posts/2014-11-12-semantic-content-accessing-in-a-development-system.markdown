---

title: Semantic content accessing in a development system
abstract: A development system comprises, in one example, a development module configured to receive user development inputs to develop elements of a computer system. The elements comprise types modeled in the computer system. The development system comprises a user interface module configured to generate a user interface display with user input mechanisms that receive a user search query for searching the elements of the computer system. The development system comprises a search module configured to identify a type-based search parameter for the user search query and to obtain a set of search results by performing an element search based on the user search query and the type-based search parameter.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09377999&OS=09377999&RS=09377999
owner: Micosoft Technology Licensing, LLC
number: 09377999
owner_city: Redmond
owner_country: US
publication_date: 20141112
---
The present application is based on and claims the benefit of U.S. provisional patent application Ser. No. 62 006 662 filed Jun. 2 2014 the content of which is hereby incorporated by reference in its entirety.

Computer programs are developed on various development tools. For example many software developers use interactive or integrated development environments IDEs in order to develop software. The developers use an IDE in order to develop models of types within a computer system and in order to customize those models.

An exemplary interactive development environment includes a plurality of different tools so that developers can develop and test the code that needs to be developed and in order to customize a computer system as desired. By way of example an IDE may include a source code editor one or more build automation tools and a debugger that allow computer programmers to develop software. Some IDEs illustratively include a compiler an interpreter or both. They may include a version control system and various tools to simplify the construction of graphical user interfaces. They can also include a class browser an object browser and a class hierarchy diagram for use with object oriented software development. Thus developers can use IDEs to generate the code and metadata along with customizations to code and metadata which may be utilized in developing a system for use in a given organization. For example a developer can work with source code and metadata files which relate to application elements. One application can require creating or changing both metadata and code that consumes the metadata in various ways.

In generating or customizing software using an IDE the application developer models specific concepts which may be represented as types within an application and where necessary writes code. Large applications for which developers often use IDEs can include thousands of different types.

By way of example some computer systems include business systems such as enterprise resource planning ERP systems customer relations management CRM systems line of business LOB systems among others. These types of computer systems often have many thousands of different types that are modeled and customized. By way of example some such business systems often have thousands of different forms alone not to mention many other types.

Business systems are not the only types of computer systems that have a large number of types. For instance gaming systems or a wide variety of other types of systems often also have many thousands of different types that are modeled in the software system.

The discussion above is merely provided for general background information and is not intended to be used as an aid in determining the scope of the claimed subject matter.

During software development a developer searches for elements to facilitate the development process. A search architecture allows a developer to search for metadata and code that meet certain criteria. The search architecture leverages semantic element information to return results that are relevant to the developer s query.

A development system comprises in one example a development module configured to receive user development inputs to develop elements of a computer system. The elements comprise types modeled in the computer system. The development system comprises a user interface module configured to generate a user interface display with user input mechanisms that receive a user search query for searching the elements of the computer system. The development system comprises a search module configured to identify a type based search parameter for the user search query and to obtain a set of search results by performing an element search based on the user search query and the type based search parameter.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The claimed subject matter is not limited to implementations that solve any or all disadvantages noted in the background.

In the illustrated example a model store stores the metadata and code corresponding to various different types of application elements e.g. types and is accessible for instance by system and a search component code generator . A type refers to an abstraction representing concepts modeled in a system. For instance in a business system element types can include forms entities classes tables menu items security roles and or permissions to name a few. In one example table objects contain metadata and code for persisting application data in a database. In another example form objects contain metadata and code to describe information content to be displayed in various devices for application users to consume information and interact with the application.

In one example when utilizing development functionality to develop application elements developer is presented with an integrated or IDE view for coding the application elements . One simplified example is shown in Table 1 below for illustration.

In this manner code and metadata being authored by developer to develop application elements is presented in a first format for example in a code editor view that provides a user friendly interface for coding the application elements . However while developer views and authors the code and metadata in the first format interactive development system maintains and operates on a source code representation of the developed application elements in a second format that is different than the first format. In one example a serialized representation comprising code and metadata is maintained by system for each element. The second format is machine readable and amenable to execution by system . In one example but not by limitation model store comprises a file system that stores the source code representations as XML files. The metadata and code XMLs comprise serialized element structures each with its own type. Table 2 below shows an example XML file that corresponds to the integrated view shown in Table 1 

In the above example the metadata and code are serialized into one XML file. That is snippets of code i.e. unstructured strings and metadata i.e. structured sets of properties and values are interspersed in the XML file. However one skilled in the art understands that other formats can be utilized.

Developer can interact with interactive development system either through a separate developer device such as a personal computer a tablet another mobile device etc. or directly. Developer can also interact with system over a network e.g. remotely . Developer is shown interacting directly e.g. locally with system in for the sake of example only.

Interactive development system in one example includes a processor and user interface module . User interface module generates user interface displays with user input mechanisms for interaction by developer . Developer interacts with user input mechanisms in order to control and manipulate interactive development system . In one example developer can do this to implement development functionality as well as to use a search module and a navigation module . System can include other items as well.

Developer can use existing code and metadata in model store or generate new code and metadata or a combination of existing and new code and metadata. In doing so existing elements in model store may be changed or deleted and new elements may be added. To facilitate development the developer may desire a search of model store to find elements of interest. For instance developer may desire to locate a particular element to customize within the application.

However due in part to the size of the codebase which is often quite large it can be difficult to find elements that meet certain developer search criteria. One searching implementation relies on building an index ahead of time against which the developer query is executed. For example there are crawlers that navigate content and build indexes which are then used to search. In the case of a development platform once an element is changed or added the index becomes out of date. Further given the size of the codebase rebuilding the index repeatedly takes a great deal of time.

In the illustrated example semantic search architecture obtains search results by using search module to semantically search model taking into account the elements names types and or properties. The search is semantic in that it leverages an understanding of the structure of the element types and a meaning of the element types and the properties within those element types. As discussed in further detail below the particular structure of the element types can be relevant to searching the elements of model store . By way of illustration but not by limitation each element type has a particular structure of properties methods and or computations that define runtime behavior for elements of that element type. For example a table element type can include a name e.g. customer table and a set of properties that identify attributes for a customer e.g. customer ID address etc. . Also in this example the table element type can include a method for computing a value for the customer and or a method for displaying the value.

Before describing the overall operation of architecture in more detail a brief overview will be provided. In one example search module comprises a search engine that receives a user search query defining search criteria in the form of one or more tokens. The tokens define search parameters and can include one or more characters forming a string or term. The search engine parses the search query from developer to identify a semantic search parameter or constraint and executes the search query against model store to obtain a set of search results that are provided to developer . In one example executing the query comprises matching the one or more tokens against properties and or methods in the application elements.

The semantic search parameter can be explicitly provided in the search query itself or can be implied or derived from the search query. For instance in the example described below with respect to developer enters a search query of 

Here the semantic search parameter identified from the query comprises a type based constraint. That is the developer desires elements that are of the element type table have a method with a name matching the token insert and a source property with a value matching the token crosscompany . While embodiments are herein discussed in the context of type based constraints it noted that other semantic search parameters or constraints can be used.

In the illustrated example to perform the search search module accesses a search component store that stores a plurality of search components i.e. search components and that have been generated by a search component code generator . One example of generating search components using search component code generator is discussed in further detail below with respect to . Briefly search component code generator includes a processor configured to generate a search component for each different element type modeled in model store . Each search component is generated for a particular one of the element types. In this manner each search component is specific to the structure of the particular element type for which it was generated. In one example search components are generated and stored in store for all possible element types that can be used by developer . For instance in one example a pre defined set of element types are available to developer and any new element types are added to system through an update to system .

Search module uses the type based search constraints from the search query to identify one or more of the search components from search component store to be used to return a list of results from the elements in model store . One example of searching model store using the search components is discussed in further detail below with respect to . Briefly search module identifies a corresponding search component for each type based search constraint. In the above example search module identifies the search component i.e. search component or that was generated for the table element type. The identified search component is instantiated for each element in model store having the table element type to identify elements that match the method name and property values in the search query. The search module aggregates search results obtained from the instantiated search component. Navigation module facilitates user navigation of the search results.

Search architecture thus leverages semantic information regarding the application elements in performing a search of model store without having to build or maintain an index ahead of time. This may reduce processing load and time and memory requirements in executing the search functionality in the development system and may improve search result relevancy to the user s query.

For sake of illustration in the example of for each different type of application element architecture maintains a specific search components that is configured to search the existing elements of model store of that element type. However those search components are also able to search any new elements added by developer to model store regardless of the type i.e. all element types have a pre defined search component or the specific properties of the new element. Conversely in the case of an indexed search system adding the new elements to the model store would require that the index be updated to include the new elements.

For sake of further illustration assume that model store includes two different element types i.e. a table element type and a form element type . A first search component is generated for element type and a second search component is generated for element type . In the example of code generator only needs to be run once for each element type. In this manner once search components and have been generated code generator does not need to regenerate or modify them even if existing elements of types and are modified in model store and or new elements of types and are added in model store .

Search component is instantiated when search module searches for elements of type and search component is instantiated when search module searches for elements of type . In one example when both element types and are being searched search components and can operate in parallel to reduce the search time. It is noted that while only two element types and type based search components are shown in any number of element types and semantic search components can be implemented.

While model store and search component store are illustrated in as being separate from interactive development system it is noted that model store and or search component store can be part of interactive development system . However due to bandwidth and latency considerations in some implementations model store and search component store can be maintained on a same computing system although this is just one example. In this manner while the search requests and results may be sent over a network search architecture does not require transmission of the model store . Again this is just one example of an architecture.

Also shows a variety of different functional blocks. It will be noted that the blocks can be consolidated so that more functionality is performed by each block or they can be divided so that the functionality is further distributed.

It should also be noted that the above discussion has shown a number of data stores including model store and search component store . While these are shown as two independent data stores they could also be formed within a single data store. In addition the data in those data stores can be stored in multiple additional data stores as well. Also the data stores can be local to the environments agents modules and or components that access them or they can be remote therefrom and accessible by those environments agents modules and or components. Similarly some can be local while others are remote.

In the illustrated example processors and comprise computer processors with associated memory and timing circuitry not separately shown . They are a functional part of the agent or environment to which they belong and are illustratively activated by and facilitate the functionality of other items in that environment or agent.

Method can be initiated periodically and or in response to a condition or event. For example method can be initiated in response to an update to system that adds or modifies the element types that are supported by system . In another example method can be initiated in response to an input from developer e.g. by selecting a control such as open close save etc. on user interface .

At step search component code generator accesses model store and determines at step whether there are any new element types for which to generate a type based search component. In one example search component code generator analyzes some e.g. the most recent changes and additions or all of the elements in model store and compares those elements against existing or known element types i.e. types and . For instance search component code generator identifies elements that have been changed or added by developer .

If a new element type is identified search component code generator analyzes the structure of the new element type at step to generate a type based search component for the new element type at step . In one example search component code generator parses the structure of the new element type into any subtypes and determines what properties the type and or subtypes contain any child element types what element types derive from the element type and an implementation for property getters of the element type. Each property getter defines a function for retrieving a property of the element type for example based on the location of the property in the element type and or relationships to other properties. In one example search component code generator generates different property getter code to search different portions of the element type structure. For instance one piece of the code can search methods in a given portion of the element and one piece of the code can look at controls etc. With respect to the customer table element type example discussed above one property getter could be configured to return the customer ID property and another property getter could be configured to return the address property.

Each search component is configured to follow a defined element pattern e.g. a pattern of child elements properties methods etc. which is based on the element type for which the search component is generated. For example but not by limitation in element types and have different patterns of child elements from one another. Search component is configured to call search method s to examine and return values of the child elements associated with element type and search component is configured to call search method s to examine and return values of the child elements associate with element type .

By way of example one metadata element comprises a tree data structure and is defined by a name and a metadata element type. The metadata element type is further defined by a set of properties with each property defined by a name and a type of a property value. The type of property value can be for example but not by limitation primitive convertible to a string YesNo Date Tags etc. . Such property is referred to as a simple property . Another type of property value is a metadata element type containing child metadata elements. Such property can be referred to as a node property . Root metadata elements are elements that are stored directly in metadata storage and do not have any parents. Child metadata elements are elements that are contained in some of the other element node property. A metadata path comprises a string that uniquely identifies the metadata element and facilitates locating the metadata element. In one example the form of the path is 

At step the generated semantic search component is stored in search component store . If any additional new element types are identified at step steps and are repeated for the new element type s .

Block provides an interface to interactive development system . Through block search module receives a search query that is provided to a query parser at block . The query provides one or more search criteria that define filter s and can have any suitable syntax or grammar.

As illustrated above and shown in one example of user search criteria is element name which can specify one string or a set of strings. An element is considered to meet this criteria if the element s name contains at least one of the strings. Each comma separated value can be an acceptable element name. In one example element name is the default filter. Thus if a search query includes a single token it is assumed to be the element name. In this example if no type based constraint is identified the search architecture can instantiate the search components for all available element types.

Another example criteria is element type which can specify one element type or a set of element types. An element is considered to meet this criteria if it is of one of the specified types. Each comma separated value can be a name of one of the element types i.e. table class field . The search query can specify both root and subtypes as a value. In one example filtering logic can be as follows 

Another example criteria is element property which can specify a set of key value pairs property s name property s value . An element is considered to meet the criteria if for each pair it is true that a the element contains a simple property with the specified name and b this property s value converted to a string contains the specified value. Each comma separated value can be in the form property name property value.

At block one or more type based search components e.g. component and or are instantiated based on identified element type s . For example this can be performed by accessing type information for example from type based search component store at block based on the type filter criteria from parser block . Block provides information about the element type s including but not limited to what properties the type s contain the types of child elements of the element type what element types are derived from the element type and implementation of property getters for the element type.

In one example block uses type information provided by block to process the search options in order to accord types criteria with property criteria. If the search criteria includes one or more properties using type information block can filter out all element types that cannot contain the searched properties.

For each element type to be searched the corresponding type based search component is instantiated in accordance with the code generated by code generator .

At block references to elements in model store are obtained according to the search criteria from block and the semantic search components instantiated at block . For example metadata element references can facilitate getting a root element s name quick operation that is not connected with storage access and or loading the element relatively long operation connected with storage access .

At block the element references obtained at block are prioritized into chunks based on for example the specified criteria of the element s name or other heuristics. For instance a root element having a name that contains any of the searched names would be processed before root elements that do not contain the name.

Block processes specific elements in model store to determine if they meet the search criteria. In one example an element is considered to meet the search criteria if the element s type is one of the required types specified at block the element s name contains one of the required names or a part thereof and for each pair property s name property s value specified by search criteria it is true that the element contains a property with such a name and this property s value contains the specified property s value.

In one example block obtains an element predicate function or other information from block which is used to determine whether an element meets search criteria. Block creates a predicate function for each of the element types provided by using information from block . For example block provides the element types to block and receives information on implementation of property getters for each element type.

If an element in model store meets the search criteria the result is provided to the developer through interface block .

At step a development surface is displayed for example using user interface display . At step a search input is received and at step the search input is parsed to identify search criteria. Examples of search criteria include but are not limited to type based constraints method names and property values. Search module then searches model store for elements that meet the search criteria.

At step one or more type based search components are identified and instantiated to search the model store . For example as discussed above with respect to a type based search constraint can be explicitly defined in the search input. In another example a type based search constraint can be inferred from the tokens provide in the search input. For instance for a property value provided in the search input step can determine which element types have the corresponding property.

Then the one or more type based search components are instantiated by search module to search the elements in model store based on the search query. In one example a separate instantiation of a search component is created for each element of the corresponding element type.

The instantiated search component s are used to search the elements in model store at step and at step identify elements that meet the criteria identified from step . As discussed above in one example the search components can search serialized representations e.g. XML files of the elements rather than directly searching the elements developed by developer .

By way of example but not by limitation while searching a serialized representation of an element in model store a search component identifies a portion of the element that meet the search criteria by finding references e.g. line and column number positions to the corresponding elements in the serialized representations. The search component can distinguish the code from the metadata and for a match identified in the serialized representation computes the position in the code as if it searched the integrated code view that is presented to the developer. Thus from the perspective of developer the search module searches and returns results within the code editor and or metadata editor views rather than the serialized representation.

In one example the search component reads the element converts it to an object oriented expression and applies its property getters to identify and match a property against a property based search criteria from the search query. The search component converts the matched property into a corresponding path that uniquely identifies the property inside the object. For example the path comprises a uniform resource identifier URI which can be a metadata path as discussed above.

At step the results are returned as a set of links that indicate element matches to the search criteria. For example the search component identifies an element match by returning the corresponding URI to an aggregator component of search module . The aggregator URI s are provided to user interface module for presentation to developer .

At step a selection by developer of a particular URI is received for example through user interaction such as a mouse click or other user input. Navigation module decodes the selected URI to identify the corresponding element location. In one example the URI comprises a reference to a distinct property e.g. source crosscompany where selection of the URI opens a metadata editor at the location identify by the URI. In another example the URI comprises a reference to a method body that includes a value where selection of the URI opens a code editor.

In one example the search results are obtained and displayed asynchronously. This is represented in by arrow . That is as the instantiated semantic search components identify an element that meets the search criteria at step a URI for the identified element is displayed to the developer while the search continues in the background.

User interface display includes a code editor view that receives developer inputs to author application elements and a semantic search interface that receives a developer search query. By way of example the following search query has been entered in element 

Using the example syntax described with respect to the search query specifies a type filter of table a method name filter of insert and a property name filter of crosscompany . Search module instantiates the type based search component corresponding to a table type. The search query can be executed asynchronously which populates a results window with search results URIs as they are obtained. That is the search can begin by displaying one or more search result URIs in window and then add additional search result URIs to window as they are obtained. In this manner developer can continue to interact with user interface display for example by clicking a desired URI to direct view to the corresponding search result while the search continues to run in the background to return any additional results. In the illustrated example each URI includes label information and location information that identifies an element and a location of the element.

In one example the search capability of search module is exposed as an application programming interface API along with an object model that is independent of the search query syntax. Using the API a search operation can be invoked as a service on a network that can be consumed remotely from any of a plurality of different devices e.g. subject to access rights and security . The parameters for the search API are objects in the object model and not a query string to confirm to a syntax. Thus the search query syntax is decoupled from the searcher.

By way of example a class diagram for the object model can include a plurality of different classes with each class defining one or more semantic search constraints and methods to be called for searching and examining corresponding elements. Examples of semantic search constraints defined by the object model classes include but are not limited to type constraints property constraints code constraints and name constraints.

In one example a different syntax can be provided depending on the device from which the search is initiated. For instance from a developer desktop computer with a larger form factor screen the developer can be allowed to enter a query string in a formal syntax. On the other hand from a mobile device with a smaller form factor entry in the formal syntax may be more difficult for the developer. The search architecture can be configured to facilitate query entry in a simpler form. For example when using a mobile device or the like the developer can be presented with controls having predefined search functions such as a button assigned to a specific set of search constraints e.g. a specific type based search .

The present discussion has mentioned processors and servers. In one example the processors and servers include computer processors with associated memory and timing circuitry not separately shown. They are functional parts of the systems or devices to which they belong and are activated by and facilitate the functionality of the other modules components and or items in those systems.

Also a number of user interface displays have been discussed. They can take a wide variety of different forms and can have a wide variety of different user actuatable input mechanisms disposed thereon. For instance the user actuatable input mechanisms can be text boxes check boxes icons links drop down menus search boxes etc. They can also be actuated in a wide variety of different ways. For instance they can be actuated using a point and click device such as a track ball or mouse . They can be actuated using hardware buttons switches a joystick or keyboard thumb switches or thumb pads etc. They can also be actuated using a virtual keyboard or other virtual actuators. In addition where the screen on which they are displayed is a touch sensitive screen they can be actuated using touch gestures. Also where the device that displays them has speech recognition components they can be actuated using speech commands.

A number of data stores have also been discussed. It will be noted they can each be broken into multiple data stores. All can be local to the systems accessing them all can be remote or some can be local while others are remote. All of these configurations are contemplated herein.

Also the figures show a number of blocks with functionality ascribed to each block. It will be noted that fewer blocks can be used so the functionality is performed by fewer components. Also more blocks can be used with the functionality distributed among more components.

The description is intended to include both public cloud computing and private cloud computing. Cloud computing both public and private provides substantially seamless pooling of resources as well as a reduced need to manage and configure underlying hardware infrastructure.

A public cloud is managed by a vendor and typically supports multiple consumers using the same infrastructure. Also a public cloud as opposed to a private cloud can free up the end users from managing the hardware. A private cloud may be managed by the organization itself and the infrastructure is typically not shared with other organizations. The organization still maintains the hardware to some extent such as installations and repairs etc.

In the example shown in some items are similar to those shown in and they are similarly numbered. specifically shows that interactive development system model store search component store and search component code generator can be located in cloud which can be public private or a combination where portions are public while others are private . Therefore developer uses a user device to access those systems through cloud .

It will also be noted that architecture or portions of it can be disposed on a wide variety of different devices. Some of those devices include servers desktop computers laptop computers tablet computers or other mobile devices such as palm top computers cell phones smart phones multimedia players personal digital assistants etc.

In other examples applications or systems are received on a removable Secure Digital SD card that is connected to a SD card interface . SD card interface and communication links communicate with a processor which can also embody processors from along a bus that is also connected to memory and input output I O components as well as clock and location system .

I O components in one example are provided to facilitate input and output operations. I O components for various examples of the device can include input components such as buttons touch sensors multi touch sensors optical or video sensors voice sensors touch screens proximity sensors microphones tilt sensors and gravity switches and output components such as a display device a speaker and or a printer port. Other I O components can be used as well.

Clock comprises a real time clock component that outputs a time and date. It can also provide timing functions for processor .

Location system includes a component that outputs a current geographical location of device . This can include for instance a global positioning system GPS receiver a LORAN system a dead reckoning system a cellular triangulation system or other positioning system. It can also include for example mapping software or navigation software that generates desired maps navigation routes and other geographic functions.

Memory stores operating system network settings applications application configuration settings data store communication drivers and communication configuration settings . It can also store a client system which can be part or all of architecture . Memory can include all types of tangible volatile and non volatile computer readable memory devices. It can also include computer storage media described below . Memory stores computer readable instructions that when executed by processor cause the processor to perform computer implemented steps or functions according to the instructions. Processor can be activated by other modules or components to facilitate their functionality as well.

Examples of the network settings include things such as proxy information Internet connection information and mappings. Application configuration settings include settings that tailor the application for a specific enterprise or user. Communication configuration settings provide parameters for communicating with other computers and include items such as GPRS parameters SMS parameters connection user names and passwords.

Applications can be applications that have previously been stored on the device or applications that are installed during use although these can be part of operating system or hosted external to device as well.

The mobile device of is a personal digital assistant PDA or a multimedia player or a tablet computing device etc. hereinafter referred to as PDA . PDA includes an inductive screen that senses the position of a stylus or other pointers such as a user s finger when the stylus is positioned over the screen. This allows the user to select highlight and move items on the screen as well as draw and write. PDA also includes a number of user input keys or buttons such as button which allow the user to scroll through menu options or other display options which are displayed on display and allow the user to change applications or select user input functions without contacting display . Although not shown PDA can include an internal antenna and an infrared transmitter receiver that allow for wireless communication with other computers as well as connection ports that allow for hardware connections to other computing devices. Such hardware connections are typically made through a cradle that connects to the other computer through a serial or USB port. As such these connections are non network connections. In one example mobile device also includes a SD card slot that accepts a SD card .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media is different from and does not include a modulated data signal or carrier wave. It includes hardware storage media including both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

Alternatively or in addition the functionality described herein can be performed at least in part by one or more hardware logic components. For example and without limitation types of hardware logic components that can be used include Field programmable Gate Arrays FPGAs Program specific Integrated Circuits ASICs Program specific Standard Products ASSPs System on a chip systems SOCs Complex Programmable Logic Devices CPLDs etc.

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A visual display or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

It should also be noted that the different embodiments described herein can be combined in different ways. That is parts of one or more embodiments can be combined with parts of one or more other embodiments. All of this is contemplated herein.

Example 1 is a development system comprising a development module configured to receive user development inputs to develop elements of a computer system. The elements comprise types modeled in the computer system. The development system comprises a user interface module configured to generate a user interface display with user input mechanisms that receive a user search query for searching the elements of the computer system. The development system comprises a search module configured to identify a type based search parameter for the user search query and to obtain a set of search results by performing an element search based on the user search query and the type based search parameter.

Example 2 is the development system of any or all previous examples wherein the development module is part of an interactive development environment IDE .

Example 3 is the development system of any or all previous examples wherein the user is a developer and the elements of the computer system comprise application elements that are customized by the developer.

Example 4 is the development system of any or all previous examples wherein the type based search parameter identifies a particular element type selected from the types modeled in the computer system and the search is constrained to elements having the particular element type.

Example 5 is the development system of any or all previous examples wherein the user search query includes a character string and the particular element type.

Example 6 is the development system of any or all previous examples wherein the set of search results comprise elements of the particular element type that have property values that match the character string.

Example 7 is the development system of any or all previous examples wherein the elements of the computer system comprise a plurality of different types each type having a set of properties and methods that define run time behavior for elements of that element type. The system further comprises a search component store that stores a plurality of search components each search component corresponding to a given one of the different types and being configured to facilitate a search of the set of properties and methods for elements of the given type.

Example 8 is the development system of any or all previous examples wherein the search module is configured to identify a search component from the search component store that corresponds to the particular element type identify each of a plurality of elements of the computer system that has the particular element type and to search the identified elements based on the user search query using the identified search component.

Example 9 is the development system of any or all previous examples wherein the identified search component is instantiated for each of the plurality of identified elements having the particular element type and the search module is configured to obtain the set of search results by aggregating search results from the plurality of instantiated search components and to display the aggregated search results in the user interface display.

Example 10 is the development system of any or all previous examples wherein the set of search results are obtained and displayed asynchronously.

Example 11 is the development system of any or all previous examples and further comprising a model store that stores for each of the elements a serialized representation of the element comprising code and metadata of the element. The search module is configured to perform the element search by accessing the serialized representations in the model store.

Example 12 is the development system of any or all previous examples wherein the search module is configured to identify a particular serialized representation in the model store corresponding to a given one of the elements based on the type based search parameter and to search the particular serialized representation based on the user search query.

Example 13 is the development system of any or all previous examples wherein the search module is configured to identify a portion of the given element from the particular serialized representation that matches the user search query and to identify path information that uniquely identifies the portion of the given element.

Example 14 is the development system of any or all previous examples wherein the path information comprises a uniform resource identifier URI the user interface module being configured to generate a user selectable representation of the URI that is selectable to present the portion of the given element in an editor user interface.

Example 15 is a development system comprising a data store that models a plurality of different element types a development module configured to receive developer inputs and to develop application elements of the different element types based on the developer inputs and a search component generator configured to generate a different search component for each of the element types modeled in the data store. The development system also comprises a search component store configured to store the search components generated by the search component generator for the plurality of element types. Each search component is configured to search the developed application elements of a given one of the element types.

Example 16 is the development system of any or all previous examples wherein the search component generator is configured to generate each search component by analyzing a structure of a given one of the element types and generating corresponding search functions based on the structure of the given element type.

Example 17 is the development system of any or all previous examples wherein the structure of the given element type is defined by a set of properties and methods that define runtime behavior of elements having the given element type.

Example 18 is the development system of any or all previous examples and further comprising a search module configured to receive a search query having at least one search term identify a type based search parameter for the search query and identify one of the search components from the search component store based on the type based search parameter. The identified search component is instantiated to search one or more of the application elements based on the search term.

Example 19 is a computer implemented method of developing a computer system. The method comprises receiving development user inputs for developing elements of the computer system the computer system comprising a plurality of different element types each element type being defined by a property structure for elements of the element type. The method comprises generating a search interface display that receives a user search query to search the elements of the computer system obtaining search results by performing a search of the elements of the computer system based on the user search query and a semantic search constraint that is based on the property structures of the elements of a computer system and generating a results display that displays the search results.

Example 20 is the computer implemented method of any or all previous examples and further comprising accessing a data store that models a plurality of different element types and for each different element type generating a corresponding type based search component based on a property structure of the element type. The method comprises using at least one of the generated type based search components that is selected based on the semantic search constraint to search the data store based on the user search query.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims and other equivalent features and acts are intended to be within the scope of the claims.

