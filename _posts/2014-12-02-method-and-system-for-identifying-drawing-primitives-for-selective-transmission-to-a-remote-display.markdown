---

title: Method and system for identifying drawing primitives for selective transmission to a remote display
abstract: Remote desktop servers include a display encoder that maintains a secondary framebuffer that contains display data to be encoded and transmitted to a remote client display and a list of display primitives effectuating updated display data in the secondary framebuffer. The display encoder submits requests to receive the list of drawing primitives to a video adapter driver that receives and tracks drawing primitives that, when executed, update a primary framebuffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09448760&OS=09448760&RS=09448760
owner: VMware, Inc.
number: 09448760
owner_city: Palo Alto
owner_country: US
publication_date: 20141202
---
This application is a continuation of U.S. patent application Ser. No. 12 428 949 filed on Apr. 23 2009 which issued as U.S. Pat. No. 8 902 242 the entirety of which is hereby incorporated by reference herein.

The present invention is related to U.S. patent application entitled Method and System for Copying a Framebuffer for Transmission to a Remote Display Ser. No. 12 428 971 and filed on the same day as the present application which is hereby incorporated by reference.

Current operating systems typically include a graphical drawing interface layer that is accessed by applications in order to render drawings on a display such as a monitor. The graphical drawing interface layer provides applications an application programming interface API for drawings and converts drawing requests by such applications into a set of drawing commands that it then provides to a video adapter driver. The video adapter driver in turn receives the drawing commands translates them into video adapter specific drawing primitives and forwards them to a video adapter e.g. graphics card integrated video chipset etc. . The video adapter receives the drawing primitives and immediately processes them or alternatively stores them in a First In First Out FIFO queue for sequential execution to update a framebuffer in the video adapter that is used to generate and transmit a video signal to a coupled external display. One example of such a graphical drawing interface layer is the Graphical Device Interface GDI of the Microsoft Windows operating system OS which is implemented as a number of user level and kernel level dynamically linked libraries accessible through the Windows OS.

With the rise of technologies such as server based computing SBC and virtual desktop infrastructure VDI organizations are able to replace traditional personal computers PCs with instances of desktops that are hosted on remote desktop servers or virtual machines running thereon in a data center. A thin client application installed on a user s terminal connects to a remote desktop server that transmits a graphical user interface of an operating system session for rendering on the display of the user s terminal One example of such a remote desktop server system is Virtual Network Computing VNC which utilizes the Remote Framebuffer RFB protocol to transmit framebuffers which contain the values for every pixel to be displayed on a screen from the remote desktop server to the client. In order to reduce the amount of display data relating to the graphical user interface that is transmitted to the thin client application the remote desktop server may retain a second copy of the framebuffer that reflects a prior state of the framebuffer. This second copy enables the remote desktop server to compare a prior state and current state of the framebuffer in order to identify display data differences to encode to reduce network transmission bandwidth and subsequently transmit onto the network to the thin client application.

However transmitting the display data differences onto the network to the thin client application can deteriorate performance of both the remote desktop server and the thin client application due to the computing overhead needed to encode the display data differences at the remote desktop server and subsequently decode them at the thin client application. As a general example to continually transmit data from an entire framebuffer that supports a resolution of 1920 1200 and color depth of 24 bits per pixel onto the network at a rate of 60 times per second would require transmission of over 3.09 gigabits per second. Even assuming that display data differences rather than an entire framebuffer can be identified and further compressed through encoding techniques prior to transmission significant network bandwidth may still be required.

One or more embodiments of the present invention provide methods in a server having a primary framebuffer for storing display data and a display encoder that uses a secondary framebuffer for transmitting display data to a remote client terminal for reducing an amount of display data to be transmitted to the remote client terminal. In one such method a queue comprising a list of completed drawing primitives is updated upon execution of drawing primitives into the primary framebuffer. The display encoder requests a list of drawing primitives that corresponds to updated display data in the secondary framebuffer and the requested list of drawing primitives is extracted from the queue and provided to the display encoder. Upon receipt of the requested list of drawing primitives the display encoder is able to selectively transmit to the remote client terminal a drawing primitive in the requested list over updated display data in the secondary framebuffer corresponding to the drawing primitive depending upon a bandwidth usage assessment.

In one embodiment each entry in the queue comprises a sequence number and a drawing primitive and the received request includes a sequence number corresponding to a last drawing primitive to update display data in the secondary framebuffer. In such an embodiment the extracting step comprises identifying each entry in the queue including a sequence number up to and including the sequence number of the request.

A virtualization software layer also referred to hereinafter as hypervisor is installed on top of hardware platform . Hypervisor supports virtual machine execution space within which multiple virtual machines VMs may be concurrently instantiated and executed. In one embodiment each VM supports a different user who is remotely connected from a different client terminal. For each of VMs hypervisor manages a corresponding virtual hardware platform i.e. virtual hardware platforms that includes emulated hardware implemented in software such as CPU RAM hard drive NIC and video adapter . Emulated video adapter allocates and maintains a framebuffer which is a portion of memory used by video adapter that holds a buffer of the pixel values from which a video display i.e. frame is refreshed and a First In First Out FIFO queue which is a portion of memory used by video adapter that holds a list of drawing primitives that are used to update framebuffer . In one embodiment FIFO queue is a shared memory buffer that is accessed and shared between video adapter and video adapter driver .

Virtual hardware platform may function as an equivalent of a standard x86 hardware architecture such that any x86 supported operating system e.g. Microsoft Windows Linux Solaris x86 NetWare FreeBSD etc. may be installed as guest operating system OS to execute applications for an instantiated virtual machine e.g. VM . Applications that require drawing on a display submit drawing requests through an API offered by graphical drawing interface layer e.g. Microsoft Windows GDI in one embodiment which in turn converts the drawing requests into drawing commands and transmits the drawing commands to a video adapter driver in device driver layer . As shown in the embodiment of video adapter driver allocates and maintains its own FIFO queue to keep track of drawing primitives as well as a data structure referred to hereinafter as a blitmap data structure that keeps track of potentially changed regions of framebuffer of video adapter . Further details on the implementation and usage of blitmap data structures are detailed later in this Detailed Description. Device driver layer includes additional device drivers such as NIC driver that interact with emulated devices in virtual hardware platform e.g. virtual NIC etc. as if such emulated devices were the actual physical devices of hardware platform . Hypervisor is generally responsible for taking requests from device drivers in device driver layer that are received by emulated devices in virtual platform and translating the requests into corresponding requests for real device drivers in a physical device driver layer of hypervisor that communicates with real devices in hardware platform .

In order to transmit graphical user interfaces to the display of a remote client terminal VM further includes a display encoder that interacts with video adapter driver e.g. through an API to obtain data from framebuffer for encoding e.g. to reduce network transmission bandwidth and subsequent transmission onto the network through NIC driver e.g. through virtual NIC and ultimately through physical NIC . Display encoder allocates and maintains a secondary framebuffer for storing data received from framebuffer its own blitmap data structure hereinafter referred to as encoder blitmap data structure for identifying changed regions in secondary framebuffer and its own FIFO queue for tracking drawing primitives whose execution resulted in the changed regions in secondary framebuffer . In one embodiment display encoder continuously polls video adapter driver e.g. 30 or 60 times a second for example to copy changes made in framebuffer to secondary framebuffer to transmit to the remote client terminal.

Those with ordinary skill in the art will recognize that the various terms layers and categorizations used to describe the virtualization components in may be referred to differently without departing from their functionality or the spirit of the invention. For example virtual hardware platforms may be considered to be part of virtual machine monitors VMM which implement the virtual system support needed to coordinate operations between hypervisor and corresponding VMs . Alternatively virtual hardware platforms may also be considered to be separate from VMMs and VMMs may be considered to be separate from hypervisor . One example of hypervisor that may be used in an embodiment of the invention is included as a component of VMware s ESX product which is commercially available from VMware Inc. of Palo Alto Calif. It should further be recognized that embodiments of the invention may be practiced in other virtualized computer systems such as hosted virtual machine systems where the hypervisor is implemented on top of an operating system.

According to the embodiment of in step during its execution application i.e. one of applications running on guest OS accesses the API of graphical drawing interface layer e.g. GDI in Microsoft Windows to submit drawing requests to a screen for example to update its graphical user interface in response to a user action. In step through guest OS graphical drawing interface layer receives the drawing requests and converts them into drawing commands that are understood by video adapter driver . In step graphical drawing interface layer transmits the drawing commands to video adapter driver . In step video adapter driver receives the drawing commands and marks entries of driver blitmap data structure to indicate that at least a portion of pixel values in regions of framebuffer corresponding to the marked entries of driver blitmap data structure will be updated as a result of executing the drawing commands. In one embodiment video adapter driver calculates or otherwise determines an area within framebuffer such as a rectangle of minimum size that encompasses the pixels that will be updated as a result of executing the drawing commands i.e. also referred to herein as a bounding box . Video adapter driver is then able to identify and mark all blitmap entries in driver blitmap data structure corresponding to regions of framebuffer that include pixel values in the determined area. In step video adapter driver converts the drawing commands to device specific drawing primitives and in step inserts the device specific drawing primitives into its FIFO queue accordingly incrementing the free entry pointer of FIFO queue . In step video adapter driver then inserts the drawing primitives into FIFO queue e.g. in an embodiment where FIFO queue is shared between video adapter driver and video adapter and accordingly increments the free entry pointer of FIFO queue . In step video adapter updates framebuffer in accordance with the drawing primitives in FIFO queue when they are ready to be acted upon. Specifically in step once video adapter completes executing a drawing primitive it increments the current entry pointer of its FIFO queue and in step notifies video adapter driver to increment the current entry pointer of FIFO queue which video adapter driver does in step .

According to the embodiment of display encoder is a process running on guest OS which continually polls e.g. 30 or 60 times a second for example video adapter driver to obtain data in framebuffer of video adapter to encode and transmit onto the network e.g. through NIC driver for receipt by a remote client terminal. In step display encoder via an API routine exposed to it by video adapter driver issues a framebuffer update request to video adapter driver and passes to video adapter driver a memory reference e.g. pointer to secondary framebuffer to enable video adapter driver to directly modify secondary framebuffer . In step video adapter driver receives the framebuffer update request and in step it traverses driver blitmap data structure to identify marked blitmap entries that correspond to regions of framebuffer that have changed since the previous framebuffer update request from display encoder due to drawing requests from applications as described in . If in step a current blitmap entry is marked then in step video adapter driver requests the corresponding region i.e. the pixel values in the region of framebuffer from video adapter . In step video adapter receives the request and transmits the requested region of framebuffer to video adapter driver .

In step video adapter driver receives the requested region of framebuffer and in step compares the pixel values in the received requested region of framebuffer to the pixel values of the corresponding region in secondary framebuffer which reflects a previous state of the framebuffer upon completion of the response of video adapter driver to the previous framebuffer update request from display encoder . This comparison step enables video adapter driver to identify possible inefficiencies resulting from visually redundant transmissions of drawing requests by applications as described in . For example perhaps due a lack of focus on optimizing drawing related aspects of their functionality some applications may issue drawing requests in step of that redundantly redraw their entire graphical user interface even if only a small region of the graphical user interface was actually modified by the application. Such drawing requests cause entries in driver blitmap data structure to be marked in step of even if the corresponding framebuffer regions of the marked blitmap entries need not be updated with new pixel values i.e. the regions correspond to parts of the graphical user interface that are not actually modified . With such marked blitmap entries comparison step will reveal that the regions of framebuffer and secondary framebuffer corresponding to the marked blitmap entries are the same since the pixel values of such regions did not change due to visually redundant drawing requests submitted by applications in step after completion of video adapter driver s response to the previous framebuffer update request from display encoder .

As such in step if comparison step indicates that the regions of framebuffer and secondary framebuffer are the same then in step video adapter driver trims driver blitmap data structure by clearing the marked blitmap entry to indicate that no actual pixel values were changed in the corresponding region of framebuffer since completion of video adapter driver s response to the previous framebuffer update request from display encoder . depicts an example of trimming a blitmap data structure according to one embodiment of the invention. illustrates a 88 72 pixel block of framebuffer . Each subdivided block such as represents an 8 8 pixel region that corresponds to a blitmap entry in driver blitmap data structure . As depicted in an application has issued drawing requests pursuant to step of in order to draw a smiley face as depicted in pixel block . However the drawing requests issued by the application inefficiently request that the entirety of pixel block gets redrawn rather than just requesting the drawing of the specific pixels of the smiley face itself. As such each of the blitmap entries in a corresponding 11 9 blitmap block of driver blitmap data structure are marked by video adapter driver pursuant to step of such as marked blitmap entry . However when display encoder issues a framebuffer update request to video adapter driver as described herein in relation to video adapter driver is able to trim blitmap block thereby creating blitmap block by clearing blitmap entries such as unmarked blitmap whose corresponding regions in framebuffer were not actually changed i.e. did not contain a smiley face modified pixel pursuant to step of .

Returning to if however in step the comparison step indicates that the regions of framebuffer and secondary framebuffer are different i.e. actual pixel values in the region of framebuffer have changed as a result of drawing requests of applications in step since completing the response to the previous framebuffer update request from display encoder then in step video adapter driver copies the pixel values in the region of framebuffer to the corresponding region of secondary framebuffer to properly reflect in secondary framebuffer the changed pixel values in the region of framebuffer . In step if video adapter driver has not completed traversing driver blitmap data structure the flow returns to step . If in step video adapter driver has completed traversing driver blitmap data structure then in step video adapter driver provides a copy of driver blitmap data structure to display encoder which becomes and is referred to herein as encoder blitmap data structure . To the extent that marked blitmap entries were cleared in driver blitmap data structure in step encoder blitmap data structure reflects a more optimized view of regions in secondary framebuffer that have actual changed pixel values. In step video adapter driver clears all the marked blitmap entries in driver blitmap data structure in preparation for receiving a subsequent framebuffer update request from display encoder . In step video adapter driver provides to display encoder the sequence number of the last drawing primitive in FIFO queue to have been executed into framebuffer upon issuance of the framebuffer update request in step indicating to display encoder that it has completed its response to the framebuffer update request issued in step . In the FIFO queue embodiment of for example the sequence number provided to display encoder in step is 96 which represents the queue entry immediately before the queue entry pointed to by current entry pointer .

Upon completion of video adapter driver s response to framebuffer update request issued by display encoder in step secondary framebuffer contains all changed pixel values resulting from drawing requests from applications from step of since the completed response to the previous framebuffer update request from display encoder and encoder blitmap data structure contains marked blitmap entries that indicate which regions within secondary framebuffer contain such changed pixel values.

With such information in step display encoder can traverse encoder blitmap data structure for marked blitmap entries and extract only those regions in secondary framebuffer that correspond to such marked blitmap entries for encoding and transmission to a remote client display. However in one embodiment display encoder can further reduce the amount of bandwidth required to transmit changes to framebuffer to the remote client display by selectively transmitting drawing primitives that describe changes made to framebuffer rather than transmitting the actual corresponding display data changes that are reflected in secondary framebuffer . illustrates one example of bandwidth savings by transmitting a drawing primitive to a remote client display rather than transmitting corresponding display data changes made to the framebuffer. Block represents an 88 72 pixel block of framebuffer . Each subdivided block such as represents an 8 8 pixel region that corresponds to a blitmap entry in driver blitmap data structure . As depicted in video adapter is about to execute a copy drawing primitive of a queue entry in FIFO queue to copy an existing rectangle to another region of pixel block i.e. similar to queue entry of . Upon executing drawing primitive pixel block of framebuffer is transformed into pixel block i.e. the rectangle has been copied to the new region of the pixel block .

Similarly in accordance with step of driver blitmap data structure is also updated as illustrated by blitmap data structure block . While equation reveals that transmitting the changed display data in framebuffer to a remote client terminal would involve transmitting about 3840 bytes in uncompressed format equation reveals that transmitting the drawing primitive itself would involve transmitting only about 24 bytes i.e. wherein the remote client terminal would execute the received drawing primitive to obtain the display data . Furthermore while compression encoding techniques can reduce the amount of display data transmitted even an optimal compression technique that reduces the size of the uncompressed format by a factor of for example 100 would still require transmission 38.4 bytes which remains larger than the 24 byte drawing primitive. Another benefit is reduced CPU time. For example while it may be possible to use display compression display data to a size as small or even smaller than the corresponding display primitive transmitting the display primitive requires significantly less CPU time then the necessary compression algorithm.

In step display encoder receives the sequence number transmitted by video adapter driver upon completion of a framebuffer update request in step of . In step display encoder then transmits the sequence number and a memory reference to FIFO queue to video adapter driver in a request for a list of drawing primitives relating to the updated display data contained in secondary framebuffer received in step . When video adapter driver receives the request in step it determines in step those queue entries of its FIFO queue that have sequence numbers up to and including the sequence number received in the request and copies those queue entries into FIFO queue for access by display encoder . For example in one embodiment FIFO queue of video adapter driver is updated according to the steps of i.e. steps and and is implemented in a manner similar to FIFO queue of and video adapter driver further stores a copy of a prior sequence number that was transmitted to display encoder in step of for the framebuffer update request immediately prior to the current framebuffer update request that resulted in the issuance of the drawing primitives list request of step by display encoder . This prior sequence number represents the sequence number of the last drawing primitive in FIFO queue that was utilized to update framebuffer in the framebuffer update request immediately prior to the current framebuffer update request. As such those drawing primitives in queue entries of FIFO queue having sequence numbers subsequent to this sequence number and up to and including the sequence number received in step represent the display primitives that updated display data copied to secondary framebuffer in step of . In such an embodiment video adapter driver copies the queue entries of these display primitives from its FIFO queue to FIFO queue in step . In step video adapter driver then clears or otherwise removes these queue entries from its own FIFO queue and notifies display encoder that is has completed responding to the drawing primitives list request from step .

It should be recognized that alternative embodiments may utilize a different implementation of FIFO queue that is updated in manner different from the process of . For example in one alternative embodiment drawing primitives are not inserted into FIFO queue in step . Rather only drawing primitives that have been completed by video adapter in step are inserted into FIFO queue . Specifically step is modified such that video adapter transmits the completed drawing primitives to video adapter driver which then inserts them into its FIFO queue . In such an embodiment FIFO queue can be implemented as a simple vector buffer and does not need a free entry pointer or current entry pointer . Specifically all the entries from the beginning of FIFO queue up to the requested sequence number are provided to display encoder in step and in step the remaining entries are shifted to the beginning of FIFO queue after removal of the provided entries in step .

After step display encoder has access to updated display data in secondary framebuffer an encoder blitmap data structure that indicates which regions of secondary framebuffer include updated display data and a FIFO queue that includes a list of drawing primitives that effectuated the updated display data in secondary framebuffer . As such display encoder is able to determine the more efficient method of propagating display data changes to a remote client terminal between transmitting the updated display data itself or transmitting the data primitives effectuating the updated display data. For example returning to the embodiment of in step display encoder reviews the list of drawing primitives in FIFO queue to identify isolated drawing primitives that draw into framebuffer regions that are not drawn into by other drawing primitives in FIFO queue . In step if transmitting an identified drawing primitive is faster than transmitting the amount of display data affected by such drawing primitive then in step display encoder clears those blitmap entries in encoder blitmap data structure corresponding to the regions of framebuffer affected by the drawing primitive and in step transmits the drawing primitive to the remote client terminal. If in step display encoder determines that it is more efficient to transmit the display data rather than the identified drawing primitive then in step display encoder transmits the display data in secondary framebuffer i.e. in accordance with the marked entries in encoder blitmap data structure . It should be recognized that various methods may be utilized by display encoder to determine in step whether to transmit updated display data or corresponding drawing primitives to the remote client terminal consistent with the teachings herein. For example in one embodiment display encoder compares the amount of display data affected by a drawing primitive identified in step to the size of the drawing primitive itself. In an alternative embodiment certain display primitives e.g. copy or fill drawing primitives for example are assumed to be more efficient to transmit that the affected display data. It should be recognized that any number of heuristics may be used to determine whether to send the drawing primitive or the affected display data consistent with the teachings herein.

It should be recognized that various modifications and changes may be made to the specific embodiments described herein without departing from the broader spirit and scope of the invention as set forth in the appended claims. For example although depicts an embodiment where display encoder and video adapter driver run in a virtual machine that communicates with a virtual video adapter in a hypervisor it should be recognized that embodiments of the invention may be deployed in any remote desktop server architecture including non virtual machine based computing architectures. Furthermore rather than having display encoder and virtual video adapter as software components of the server alternative embodiments may utilize hardware components for each or either of them. Similarly it should be recognized that alternative embodiments may not require any virtual video adapter. Instead in such alternative embodiments for example video adapter driver may allocate and manage framebuffer and FIFO queue itself. Similarly it should be recognized that FIFO queue may not be required in alternative embodiments. Instead in such alternative embodiments display encoder is able to directly access FIFO queue of video adapter driver for example through its own read pointers. It should be similarly recognized that various other data structures and buffers described herein can be allocated and maintained by alternative system components without departing from the spirit of the invention. For example rather than having display encoder allocate and maintain secondary framebuffer and pass a memory reference to video adapter driver as detailed in step of video adapter driver may allocate and maintain secondary framebuffer as well as encoder blitmap data structure and provide memory reference access to display encoder in an alternative embodiment. Additionally it should be recognized that some of the functionality and steps performed by video adapter driver as described herein can be implemented in a separate extension or component to a pre existing or standard video adapter driver i.e. display encoder may communicate with such a separate extension to the video adapter driver rather than the pre existing video adapter driver itself . Similarly it should be recognized that alternative embodiments may vary the amount and types of data exchanged between system components as described herein or utilize known optimization techniques without departing from the spirit of the invention. For example rather than having display encoder transmit a sequence number to video adapter driver in step of an alternative embodiment in an alternative embodiment video adapter driver internally keeps track of the previous drawing primitives that it has provided to display encoder in prior iterations of step such that it is able to provide the relevant drawing primitive to display encoder without needing a sequence number. Additionally rather than providing a copy of driver blitmap data structure as encoder blitmap data structure in step of an alternative embodiment may provide only relevant portions of driver blitmap data structure to display encoder or otherwise utilize an alternative data structure to provide such relevant portions of driver blitmap data structure to display encoder . Similarly an alternative embodiment may not have a FIFO queue in video adapter driver but rather request FIFO queue entries from FIFO queue through video adapter . Similarly rather than or in addition to having display encoder continuously poll video adapter driver in alternative embodiments video adapter driver can trigger an interrupt to display encoder upon step of to notify display encoder of receipt of a drawing primitive that has updated framebuffer . In this manner display encoder need not issue continuous requests to video adapter driver for example if the framebuffer is not changing.

The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present invention have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

In addition while described virtualization methods have generally assumed that virtual machines present interfaces consistent with a particular hardware system persons of ordinary skill in the art will recognize that the methods described may be used in conjunction with virtualizations that do not correspond directly to any particular hardware system. Virtualization systems in accordance with the various embodiments implemented as hosted embodiments non hosted embodiments or as embodiments that tend to blur distinctions between the two are all envisioned. Furthermore various virtualization operations may be wholly or partially implemented in hardware. For example a hardware implementation may employ a look up table for modification of storage access requests to secure non disk data.

Many variations modifications additions and improvements are possible regardless of the degree of virtualization. The virtualization software can therefore include components of a host console or guest operating system that performs virtualization functions. Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claims s .

