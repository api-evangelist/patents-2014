---

title: Integrated circuit defect detection and repair
abstract: In accordance with the present description, a device includes an internal defect detection and repair circuit which includes a self-test logic circuit built in within the device and a self-repair logic circuit also built in within the device. In one embodiment, the built in self-test logic circuit may be configured to automatically identify defective memory cells in a memory. Upon identifying one or more defective memory cells, the built in self-repair logic circuit may be configured to automatically repair the defective memory cells by replacing defective cells with spare cells within the memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09548137&OS=09548137&RS=09548137
owner: INTEL CORPORATION
number: 09548137
owner_city: Santa Clara
owner_country: US
publication_date: 20140630
---
The present invention relates generally to devices having memory with built in self test functionality.

Integrated circuit devices such as random access memories RAMs usually undergo device verification testing during manufacture. Typically such verification tests are designed to detect both static and dynamic defects in a memory array. Static defects include for example open circuit and short circuit defects in the integrated circuit device. Dynamic defects include defects such as weak pull up or pull down transistors that create timing sensitive defects. Defects which have been identified in a memory may be repaired by issuing commands to the device to replace defective memory cells with spare memory cells placed on the device for that purpose. Such replacement is typically achieved by opening and closing fuses within the memory array.

A specialized integrated circuit device tester is normally employed to perform manufacturing verification tests. Such testing apparatus is typically controlled by a human operator or automation system using a computer executing test software. To test a memory device test patterns of various memory addresses memory commands and test data may be read from the computer memory or otherwise generated and applied via the device tester to the devices under test. Typically the devices under test are on a semiconductor wafer or may be on a die cut from the wafer.

Test data read from the devices in response to applied test patterns is compared by the external tester software to expected results to identify defects. Defects in memory devices identified in this manner may in some instances be repaired by issuing commands to the device containing a memory defect. For example in some memory circuits a row of memory cells containing a defective memory cell may be replaced by spare row of memory cells.

Some integrated circuit devices have built in self test BIST circuitry. For example an integrated circuit memory array may contain circuitry to perform a standard static random access memory SRAM 13N March test algorithm on the memory array. A state machine is typically used to generate the 13N March test algorithm along with circuitry to sample data output and to generate a signature of the results. The signature is then compared against an expected value to determine whether defects exist in the memory array.

Unfortunately these known BIST routines have often been limited to applying a fixed test sequence on the memory array. As the process of manufacturing such a memory array evolves manufacturing test engineers typically develop improved strategies for detecting both static and dynamic defects in the memory array.

Moreover such improved strategies for detecting defects have typically been applied to testing that occurs while the device is placed in an expensive integrated circuit device tester. Therefore engineers have frequently been unable to achieve the benefits of improved test strategies without the use of an expensive tester or without redesigning the integrated circuit device. Because of the advances in memory technology and particularly in the area of narrow high speed buses which typically run at speeds in the GHz range for use with dynamic random access memory devices DRAMs it is very expensive to obtain a high speed tester capable of testing a memory module or a memory component at such high operating frequencies. Therefore the added use of expensive high speed hardware testers increases the overall manufacturing cost of these memory modules and memory components.

As explained in greater detail below the memory controller includes an internal defect detection and repair circuit which includes a self test logic circuit built in within the device and a self repair logic circuit also built in within the device . The built in self test logic circuit may be configured to automatically identify defective memory cells in the memory . Upon identifying one or more defective memory cells the built in self repair logic circuit may be configured to automatically repair the defective memory cells by replacing defective cells with spare cells within the memory . The memory die may be included in the same package as the logic die having the self test logic circuit the self repair logic circuit . Alternatively the memory die could be outside the package of the logic die on top of the logic die adjacent to the logic die or on a plug in module such as a dual in line memory module DIMM .

As used herein the term automated includes fully automated in which once stress testing of the device is initiated the test and repair operations of the device proceed through repair of at least one memory location without any user intervention. Also the term automated includes substantially automated in which once stress testing of the device is initiated the test and repair operations of the device proceed through repair of at least one memory location with limited user intervention. However most of the test and repair operations proceed without any user intervention. In some embodiments at least 50 at least 75 or at least 95 of the test and repair operations proceed without any user intervention.

In the illustrated embodiment the memory controller is disposed on a semiconductor die within the device and the internal self test logic circuit and the internal self repair logic circuit of the circuit are disposed on the same die of the memory controller . Thus although the internal self test logic circuit and the internal self repair logic circuit are depicted as built in to the memory controller it is appreciated that the internal self test logic circuit and the internal self repair logic circuit may be built in to other circuits of the computer architecture device .

As explained in greater detail below the internal self test logic circuit is capable of generating a wide range of test patterns for testing the memory . Moreover in some embodiments the test patterns generated by the internal self test logic circuit may be readily modified as conditions warrant. In one embodiment the generated pattern of data may be selected to be a function of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written. As explained in greater detail below a variety of data patterns may be readily generated as a function of memory addresses including inverting data in a striped pattern or a checkerboard pattern or other pattern for example depending upon the selected memory address based function.

In another embodiment bit positions of the generated pattern of data may be selectively rotated and the rotation of a generated pattern of data may be selectively repeated a selectable number of times for all memory cell addresses of the memory cells in which the generated pattern of data is to be written. In still another embodiment the generated pattern of data may be selected to be a function of a periodic pattern of memory address offsets to the memory addresses of the memory cells in which the generated pattern of data is to be written. An address offset generator may in response to a memory address offset instruction also referred to as an offset address instruction generates a periodic pattern of memory address offsets as a function of a period. As explained below an address offset generator may be configured to generate periodic address offsets for inverting data in a diagonal pattern of memory cells for example as a function of the number of rows or the number of columns of memory region under test.

If the internal defect detection and repair circuit is located on the same die as the memory cells the defect detection and repair circuit may be activated to test for and repair memory defects during the manufacture process at the wafer or die level but also after semiconductor components have been assembled and packaged. If the defect detection and repair circuit is located on a separate die such as a logic device the defect detection and repair circuit may be used to test the memory device or devices after the memory has been connected to a device containing the defect detection and repair circuit. Further it is appreciated that in some embodiments the internal defect detection and repair circuit may be activated to test for and repair memory defects should a memory failure occur after the device has been packaged in a housing and sold to consumers. Thus the internal defect detection and repair circuit may interrupt normal memory transactions between the processor and memory to conduct memory test and repair operations.

The computer architecture device may further include storage e.g. a non volatile storage such as magnetic disk drives optical disk drives a tape drive flash memory etc. . The storage may comprise an internal storage device or an attached or network accessible storage. Programs in the storage are loaded into the memory and executed by the processor in a manner known in the art. The computer architecture device further includes a network controller or adapter to enable communication with a network such as an Ethernet a Fiber Channel Arbitrated Loop etc. Further the architecture may in certain embodiments include a video controller to render information on a display monitor where the video controller may be embodied on a video card or integrated on integrated circuit components mounted on a motherboard or other substrate. An input device is used to provide user input to the processor and may include a keyboard mouse pen stylus microphone touch sensitive display screen input pins sockets or any other activation or input mechanism known in the art. An output device is capable of rendering information transmitted from the processor or other component such as a display monitor printer storage output pins sockets etc. The network adapter may embodied on a network card such as a Peripheral Component Interconnect PCI card PCI express or some other I O card or on integrated circuit components mounted on a motherboard or other substrate.

The internal defect detection and repair circuit includes a portal through which test and repair input and output information may be passed among the defect detection and repair circuit and the other components of the device and if appropriate to devices external to the computer architecture device via an input device and an output device . One example of the portal is an on chip communication network or fabric side band. In one embodiment the portal may be accessed externally through a Test Access Port TAP system. Other communication portals may be utilized depending upon the particular application.

One or more of the components of the device may be omitted depending upon the particular application. For example a network router may lack a video controller for example. Also any one or more of the components of the computer architecture device may include one or more integrated circuits having an on die defect detection and repair circuit as described herein.

The defect detector circuit stores in a memory configured as a repair list repository also disposed within the device a list of memory locations of the memory each memory location of the list having a set of memory cells which includes at least one defective memory cell in the memory . The self repair logic circuit includes logic circuitry adapted to read the list of memory locations stored in the repair list repository and to repair the memory locations of the list. In the illustrated embodiment the memory locations of the list may be repaired by substituting a memory location of spare memory cells of the memory for a memory location having at least one defective memory cell.

In one embodiment the repair list repository may also include register or other memory locations for various flags . For example a flag may be set indicating that the number of memory locations having at least one defective memory cell exceeds the maximum for a particular memory region of the memory . Another flag may be set for each memory region indicating whether at least one row of the particular memory region has at least one defective memory cell within the particular memory region. Other flags may be stored in the repair list repository depending upon the particular application.

The test pattern generator includes a plurality of generators including a programmable address pattern generator which includes at least one address generator . . . and a loop sequencer circuit adapted to apply to an appropriate one or more of the generators . . . of the programmable address generator a plurality of nested loop instructions including a sequential loop of address instructions in a sequence of address instructions Address Instruction Address Instruction . . . Address Instruction n to an address generator . . . . Each address generator . . . may include one or more finite state machines. Each address instruction Address Instruction Address Instruction . . . Address Instruction n of the sequence when executed by an appropriate address generator . . . causes that address generator . . . to generate a pattern of memory cell addresses as a function of the particular address instruction Address Instruction Address Instruction . . . Address Instruction n and the particular address generator . . . to which it is applied. The test pattern generator is adapted to execute memory commands at memory cells addressed by a pattern of memory cell addresses generated by an address instruction Address Instruction Address Instruction . . . Address Instruction n being executed in sequence in the loop of address instructions. A counter of the counters of the instruction loop sequencer generates a pointer to the sequence of address instructions Address Instruction Address Instruction . . . Address Instruction n which in turn generates the current address instruction to be used. Parameters of the address instructions may include parameters identifying the size of the memory region to be tested a starting address of the memory region to be tested and a parameter indicating that a particular address instruction is the last address instruction of the sequence. Additional examples of parameters for address instructions are provided below. It is appreciated that other parameters may be included or utilized depending upon the particular application.

For example shows a plurality of nested instruction loops including a data instruction loop nested within the address instruction loop an algorithm instruction loop nested within the data instruction loop a command instruction loop nested within the algorithm instruction loop and selectable offset instruction loops of a set of offset instructions nested within the command instruction loop . It is appreciated that in some embodiments the number and type of nested instruction loops may differ from those illustrated and the order of nesting may be changed as well depending upon the particular application.

In this example the address pattern generated is a walking pattern in which the generated address of the address pattern walks to the next adjacent memory cell of a particular column of memory cells . Thus the address pattern may start at a particular memory cell address which may be represented as an ordered pair of a column address and a row address such the column row address depicted in . The next address of this particular address pattern may be generated by incrementing the row address portion of the memory cell address to the column row address depicted in . The remaining addresses of the remaining memory cells of the column are sequentially generated in this fashion.

Once the end of the column is reached the row address portion may be reset to the original row address and the column address may be incremented to the column row address depicted in . The remaining addresses of the memory remaining memory cells of the region are sequentially generated in this fashion. Once the end of the last column is reached the final column row address of the address pattern is depicted in

The address pattern which is generated may be readily changed by changing the address instruction or changing the address generator to which the address instruction is applied or both. Thus in the example depicted in the direction of cell walking may be reversed from that shown in by providing an appropriate address instruction to an address generator. Other address patterns may walk up one column and then walk down another column for example. Other address patterns may walk across a row before changing to a different row instead of walking up or down a column. Other address patterns for traversing a memory which are suitable for stress testing a memory may be readily implemented by appropriate selection of address instructions and address generator designs. Thus parameters of the address instruction may include a parameter defining address generation direction. It is appreciated that other parameters may be included or utilized depending upon the particular application. It is appreciated that providing multiple address instructions for multiple address generators facilitates implementation of a suitable stress tests for a memory.

In the illustrated embodiment the sequence of address instructions Address Instruction Address Instruction . . . Address Instruction n applied to the address generators . . . may comprise a sequence of four address instructions for example. It is appreciated that the number of address instructions in a sequence of address instructions may vary depending upon the particular application.

The test pattern generator further includes a programmable data pattern generator which includes at least one data generator . . . . The loop sequencer circuit is adapted to apply to appropriate ones of the data generators . . . a plurality of nested loop instructions including a sequential loop of data instructions in a sequence of data instructions Data Instruction Data Instruction . . . Data Instruction n. A counter of the counters of the instruction loop sequencer generates a pointer to the sequence of data instructions which in turn generates the current address instruction to be used. A parameter of the data instructions may include a parameter indicating that a particular data instruction is the last address instruction of the sequence. It is appreciated that other parameters may be included or utilized depending upon the particular application. Each data generator . . . may include one or more finite state machines. Each data instruction Data Instruction Data Instruction . . . Data Instruction n of the sequence when executed by an appropriate one of the data generators . . . causes that data generator . . . to generate a data pattern as a function of the particular data instruction Data Instruction Data Instruction . . . Data Instruction n and the particular data generator . . . to which it is applied.

The test pattern generator is adapted to execute memory commands at memory cells to write a pattern of test data generated by a data instruction being executed in sequence in the loop of data instructions Data Instruction Data Instruction . . . Data Instruction n in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions. Thus in the example of a data generator such as the data generator for example of the programmable data pattern generator may generate a string of data bits such as all ones for example in response to one of the data instructions such as Data Instruction for example. A generated data bit of the generated data pattern is written for example into each memory cell by the test pattern generator as the address generator for example in response to one of the address instructions such as Address Instruction for example generates the walking address pattern depicted for a memory region of memory cells of the memory . Other examples of data patterns which may be generated by the programmable data pattern generator include strings of 0 s checkerboard patterns of alternating 1 s and 0 s etc. depending upon the particular application. Thus the data output by the programmable data pattern generator may be used as write data for example to stress test the memory as commands are executed at memory addresses traversing the memory . Furthermore the data output by the programmable data pattern generator may also be used as expected test result data to compare to actual test data obtained as the memory is stress tested. Still further the generated data patterns may also be used as control signals to control the control signal inputs of the memory . Thus parameters of the data instruction may include parameters indicating whether to invert data and indicating various data backgrounds such as solid column stripes row stripes checkerboard etc. It is appreciated that other parameters may be included or utilized depending upon the particular application.

In the illustrated embodiment the sequence of data instructions Data Instruction Data Instruction . . . Data Instruction n applied to the appropriate data generators . . . may comprise a sequence of four data instructions for example. It is appreciated that the number of data instructions in a sequence of data instructions may vary depending upon the particular application.

The test pattern generator further includes a programmable algorithm pattern generator which includes at least one algorithm generator . . . . The loop sequencer circuit is adapted to apply to appropriate ones of the algorithm generators . . . a plurality of nested loop instructions including a sequential loop of algorithm instructions in a sequence of algorithm instructions Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n. A counter of the counters of the instruction loop sequencer generates a pointer to the sequence of algorithm instructions which in turn generates the current algorithm instruction to be used. A parameter of the algorithm instructions may include a parameter indicating that a particular algorithm instruction is the last algorithm instruction of the sequence. It is appreciated that other parameters may be included or utilized depending upon the particular application. Each algorithm generator . . . may include one or more finite state machines. Each algorithm instruction Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n of the sequence when executed by an appropriate one of the algorithm generators . . . causes that algorithm generator . . . to generate a test data pattern as an output of an algorithm.

In one embodiment the programmable algorithm test generator inputs the data pattern generated by the programmable data pattern generator and modifies the input data pattern to a modified data pattern in accordance with the algorithm of the selected algorithm generator . . . executing the selected algorithm instruction Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n of the sequence . In other embodiments the programmable algorithm test generator generates a data pattern as a function of the particular algorithm instruction Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n and the particular algorithm generator . . . to which it is applied without inputting the data pattern generated by the programmable data pattern generator .

The test pattern generator is adapted to execute memory commands at memory cells to write a data test pattern in accordance with an algorithm instruction being executed in sequence in the loop of algorithm instructions Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions. Thus the data output by the programmable algorithm test generator may be used as write data for example to stress test the memory as commands are executed at memory addresses traversing the memory . Sill further the data output by the programmable algorithm test generator may also be used as expected test result data to compare to actual test data obtained as the memory is stress tested. Still further the generated data patterns may also be used as control signals to control the control signal inputs of the memory .

One example of an algorithm which may be generated by a selected algorithm generator . . . such as the algorithm generator for example executing a selected algorithm instruction Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n such as the Algorithm Instruction for example of the sequence is a shift register based random pattern algorithm which may be used for testing interconnects of the memory for example. These random patterns generated by an algorithm generator such as the algorithm generator for example executing a selected algorithm instruction such as the Algorithm Instruction for example are believed to create white noise on an interconnect to stress the interconnect to test for a defect. As described above the random pattern may be generated by modifying a test data pattern generated by a generator of the programmable data pattern generator using an algorithm generator of the programmable algorithm pattern generator . Alternatively the random pattern may be generated by an algorithm generator of the programmable algorithm pattern generator without modifying a test data pattern generated by a generator of the programmable data pattern generator .

Another example an algorithm which may be generated by a selected algorithm generator . . . such as the algorithm generator for example executing a selected algorithm instruction Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n such as the Algorithm Instruction for example of the sequence is a neighbor interaction based address walking algorithm. This algorithm may be used for example for testing memory cells of dynamic random access memories which are primarily capacitive in nature. In accordance with the neighbor interaction based address walking algorithm if all neighboring cells in the memory are switched a cross coupling effect may cause a cell under test to flip to the wrong digital value.

In this algorithm a memory cell designated Base the address of which is generated by an address generator as a base address is stressed by neighbors cells within two cells away from it. Thus the test pattern generator is adapted to execute a first set of memory commands write Wr and read Rd at a first neighbor memory cell a second set of memory commands write Wr and read Rd at a second neighbor memory cell and so on finishing with an eighth set of memory commands write Wr and read Rd at an eighth neighbor memory cell in accordance with a neighbor interaction based address walking algorithm which may be generated by the algorithm generator for example executing the Algorithm Instruction for example of the sequence .

Parameters of the algorithm instructions may further include parameters indicating the starting command of a sequence of commands the starting address direction for that sequence of commands whether data is to be inverted one or more wait periods to prevent a new algorithm instruction from beginning until the wait condition is satisfied whether to reset a counter such an instruction counter for a sequence of instructions such as a sequence of command instructions for example. It is appreciated that other parameters may be included or utilized depending upon the particular application.

It is appreciated that the algorithm instructions Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n of the sequence when executed by an appropriate one of the algorithm generators . . . may implement other algorithms for stress testing the memory depending upon the particular application. In the illustrated embodiment the sequence of algorithm instructions Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n applied to the appropriate algorithm generators . . . may comprise a sequence of eight algorithm instructions for example. It is appreciated that the number of algorithm instructions in a sequence of algorithm instructions may vary depending upon the particular application.

The test pattern generator further includes a programmable command pattern generator which includes at least one command generator . . . . The loop sequencer circuit is adapted to apply to appropriate ones of the command generators . . . a plurality of nested loop instructions including a sequential loop of command instructions in a sequence of command instructions Command Instruction Command Instruction . . . Command Instruction n. A counter of the counters of the instruction loop sequencer generates a pointer to the sequence of command instructions which in turn generates the current command instruction to be used. A parameter of the command instructions may include a parameter indicating that a particular command instruction is the last command instruction of the sequence. It is appreciated that other parameters may be included or utilized depending upon the particular application. Each command generator . . . may include one or more finite state machines. Each Command instruction Command Instruction Command Instruction . . . Command Instruction n of the sequence when executed by an appropriate one of the command generators . . . causes that command generator . . . to generate a pattern of commands as a function of the particular selected command generator and the particular selected command instruction.

The test pattern generator is adapted to execute a pattern of memory commands at memory cells in accordance with a command instruction being executed in sequence in the loop of command instructions Command Instruction Command Instruction . . . Command Instruction n in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions. The data of the write commands is provided by one or both of the programmable data pattern generator and the programmable algorithm generator as discussed above. In addition to providing data to be written to the memory the generated data patterns may also be used for control signal commands of the programmable command pattern generator to control the control signal inputs of the memory .

In the illustrated embodiment the sequence of command instructions Command Instruction Command Instruction . . . Command Instruction n which are applied to the appropriate command generators . . . may comprise a sequence of twenty four command instructions for example. It is appreciated that the number of command instructions in a sequence of command instructions may vary depending upon the particular application.

In one embodiment each command instructions Command Instruction Command Instruction . . . Command Instruction n may instruct an appropriate command generator of the command generators . . . to generate a single command such as a memory write or memory read command for example. In other embodiments each command instruction Command Instruction Command Instruction . . . Command Instruction n may instruct an appropriate command generator of the command generators . . . to generate a sequence of commands.

For example in the stress test pattern depicted in a single command in this example a write command is executed for each memory cell of the memory region as the programmable address pattern generator generates a pattern of addresses which walks through the memory region as shown. depicts a multi part stress test which employs a sequence of commands. In part of the stress test of in a manner similar to that of the stress test pattern depicted in a single command in this example a write command is executed for each memory cell of the memory region as the programmable address pattern generator generates a pattern of addresses which walks through the memory region as shown to initialize the memory region . Once memory region has been initialized with a write command to each memory cell in part of the stress test a sequence of commands in this example a quick read command R followed by a write inverse Wbar command is executed for each memory cell of the same memory region as the programmable address pattern generator again generates the same pattern of addresses generated in part which again walks through the memory region a second time as shown. Following part of the stress test another sequence of commands in this example a quick read inverse Rbar command followed by a write W command is executed for each memory cell of the same memory region as the programmable address pattern generator again generates the same pattern of addresses generated in parts and which again walks through the memory region a third time as shown.

In one embodiment each command instruction may be applied to a common finite state machine of a command generator. It is appreciated that in other embodiments command instructions may be applied to different finite state machine of various command pattern generators.

In one embodiment each command instruction defines one command to execute. A sequence of commands may be provided by a sequence of command instructions each of which may be applied to a particular memory address in sequence. The sequence of commands may then be applied over a sequence of different addresses one address location at a time over the course of a stress test. It is appreciated that in other embodiments a command instruction may define more than one command in a sequence.

Thus in one embodiment parameters of a command instruction may include parameters indicating a read or write command whether data for the command is to be inverted identifying an alternate data source and a hammer function in which specifies repeated write operations. It is appreciated that other parameters may be utilized depending upon the particular application.

The test pattern generator further includes a programmable address offset pattern generator which includes at least one offset generator of the offset generators . . . . Each offset generator . . . is adapted to generate a pattern of address offsets to offset a base address generated by the programmable address pattern generator . The loop sequencer circuit is adapted to apply to appropriate ones of the offset generators . . . a plurality of nested loop instructions including a selected sequential loop of offset instructions in a sequence of offset instructions Offset Instruction Offset Instruction . . . Offset Instruction n. A counter of the counters of the instruction loop sequencer generates a pointer to the sequence of offset instructions which in turn generates the current offset instruction to be used. A parameter of the offset instructions may include a parameter indicating that a particular offset instruction is the last offset instruction of the sequence. It is appreciated that other parameters may be included or utilized depending upon the particular application. Each offset generator . . . may include one or more finite state machines. Each Offset instruction Offset Instruction Offset Instruction . . . Offset Instruction n of the sequence when executed by an appropriate one of the offset generators . . . causes that offset generator . . . to generate a pattern of address offsets as a function of the particular selected offset generator and the particular selected offset instruction.

The test pattern generator in executing memory commands at memory cells is adapted to execute a pattern of commands generated by a command instruction being executed in sequence in the loop of command instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions and offset by the pattern of memory address offsets generated by a memory address offset instructions Offset Instruction Offset Instruction . . . Offset Instruction n being executed in sequence in the loop of memory address offset instructions. In this manner a base address of the address pattern generated by the programmable address pattern generator may be offset by one or more address offsets of the offset pattern generated by the programmable offset pattern generator . The data of the write commands is provided by one or both of the programmable data pattern generator and the programmable algorithm generator as discussed above.

In the illustrated embodiment the sequence of offset instructions Offset Instruction Offset Instruction . . . Offset Instruction n which are applied to the appropriate offset generators . . . may comprise a sequence of two offset instructions for example. It is appreciated that the number of offset instructions in a sequence of offset instructions may vary depending upon the particular application.

In one embodiment one loop of offset instructions such as loop for example may be a loop of offset address instructions which create a variety of possible offset operations in an address range relative to the current base address. The offset address commands allow a sequence of offset address commands such as a sequence of six offset address commands for example to be sequentially executed in each loop . An offset address instruction of this loop may include parameters indicating the direction of offset such as north south east or west of the base address for example whether a stripe is involved and that a particular offset address instruction is the last offset address instruction of the sequence. In one embodiment the stripe function disables the normal carry from row to column or column to row during the offset address increments. It is appreciated that other parameters may be included or utilized depending upon the particular application.

In one embodiment one loop of offset instructions such as loop for example may be a loop of offset command instructions that may be sequentially executed in the loop . An offset address instruction of this loop may include parameters indicating a read or write command whether data for the offset command is to be inverted identifying an alternate data source whether to use the base address or an offset address a hammer function which specifies repeated write operations and that a particular offset command instruction is the last offset command instruction of the sequence. It is appreciated that other parameters may be utilized depending upon the particular application.

In one embodiment in connection with a command instruction of the sequence of command instructions an offset instruction as described above may be substituted for a current command instruction by setting an offset command substitution parameter of the command instruction of the sequence . In addition the offset loop of the offset command to be substituted may be indicated by an offset loop identifying parameter of the command instruction of the sequence . As previously mentioned shows an example of a neighbor interaction based address walking algorithm stress test. In this stress test a memory cell designated Base is stressed by neighbors cells within two cells away from it. The base address which is the address of the memory cell is generated by the programmable address generator . The addresses of the neighbors of the base cell are generated by modifying the base address of the base cell with the address offsets generated by the programmable address offset pattern generator . For example the address of the neighbor cell may be generated by adding a column offset of one to the address of the base cell . The address of the neighbor cell may be generated by adding a column offset of two to the address of the base cell or may be generated by adding a column offset of one to the generated address of the neighbor cell . Similarly the address of the neighbor cell may be generated by subtracting a row offset of two from the address of the base cell . The address offsets may be generated by the offset generator for example executing the Offset Instruction for example.

Thus the test pattern generator is adapted to execute a first set of memory commands write Wr and read Rd at a first neighbor memory cell a second set of memory commands write Wr and read Rd at a second neighbor memory cell and so on finishing with an eighth set of memory commands write Wr and read Rd at an eighth neighbor memory cell in accordance with a neighbor interaction based address walking algorithm at addresses which may be generated by the programmable address generator offset by the address offset pattern generated by the programmable address offset generator .

For example discussed above depicts a stress test which employs a single command a write command in this example which is generated by the programmable command pattern generator in response to the Command Instruction in this example. The write command is executed for each memory cell of the memory region as the programmable address pattern generator in response to the Address Instruction in this example generates a pattern of addresses which walks through the memory region as shown to initialize the memory region . The same bit or bits if a multi bit cell may be written into each memory cell of the memory region or the bits may vary from cell to cell as defined by the data pattern generated by the programmable data pattern generator in response to the Data Instruction in this example.

In one embodiment the stress test of does not employ address offsets and accordingly the programmable offset pattern generator may in response to the Offset Instruction pass the addresses generated by the programmable address pattern generator unmodified. In another embodiment the walking pattern may be generated by sequentially applying column and row offsets to a base address generated by the programmable address pattern generator . Similarly depending upon the particular stress test the programmable algorithm pattern generator in response to the Algorithm Instruction may pass the write data generated by the programmable pattern generator unmodified by a particular algorithm.

Once a stress test has been applied to a particular memory region or regions in response to the execution of the initial set of programmable pattern generator instructions the memory defect detector compares block the results of the stress test to expected values and identifies defects if any in the memory region or regions tested and stores appropriate defect location data in the repair list repository of failing addresses.

As previously mentioned the self test logic executes a nested loop of offset instructions nested within the command instruction loop . A determination block is made as to whether all of the offset instructions of the offset instruction sequence have been selected. If not the next offset instruction such as Offset Instruction for example in the sequence of offset instructions is selected block for the programmable offset pattern generator . Since the offset instruction loop is nested within the command loop the command instruction as well as the algorithm data and address instructions remain unchanged at this point. Accordingly the selected offset instruction together with the initial instructions selected for the programmable pattern generators and may be applied to the appropriate generators of the programmable pattern generators and and executed block to generate the selected address data algorithm command and offset patterns to generate the appropriate stress tests of the memory .

If it is determined block that all of the offset instructions of the offset instruction sequence have been selected and executed a determination block is made as to whether all of the command instructions of the command instruction sequence have been selected. If not the next command instruction such as Command Instruction for example in the sequence of command instructions is selected block for the programmable command pattern generator . Since the command instruction loop is nested within the algorithm instruction loop the algorithm instruction as well as the data and address instructions remain unchanged at this point. However the offset instruction selection is reinitialized block to the first instruction of the offset instruction sequence . Accordingly the selected command instruction together with the initial instructions selected for the programmable pattern generators and may be applied to the appropriate generators of the programmable pattern generators and and executed block to generate the selected address data algorithm command and offset patterns to generate the appropriate stress tests of the memory .

As previously mentioned depicts a multi part stress test which employs a sequence of commands which may be generated by the programmable command generator . In part of the stress test of a single command in this example a write command is executed in response to an initial command instruction such as Command Instruction for example for each memory cell of the memory region as the programmable address pattern generator generates in response to an initial address instruction such as Address Instruction for example a pattern of addresses which walks through the memory region as shown to initialize the memory region . Once memory region has been initialized with a write command to each memory cell in part of the stress test a sequence of commands in this example a quick read command R followed by a write inverse Wbar command is executed for each memory cell of the same memory region as the programmable address pattern generator again generates the same pattern of addresses generated in part which again walks through the memory region a second time as shown for part .

In one embodiment the second sequence of commands a quick read command R followed by a write inverse Wbar command of part may be generated in response to a second selected command instruction such as Command Instruction for example as the programmable address pattern generator generates in response to the unchanged initial address instruction such as Address Instruction for example the same pattern of addresses which again walks through the memory region for part of the stress test. In another embodiment each command may be generated in response to a single command instruction.

Following part of the stress test another sequence of commands in this example a quick read inverse Rbar command followed by a write W command is executed for each memory cell of the same memory region as the programmable address pattern generator again generates the same pattern of addresses generated in parts and which again walks through the memory region a third time as shown for part . Again in one embodiment the sequence of commands of part may be generated in response to a third selected command instruction. In another embodiment the sequence of commands of part may be generated in response to a single command instruction which also generated the commands of parts and of the stress test.

If it is determined block that all of the command instructions of the command instruction sequence have been selected and executed a determination block is made as to whether all of the algorithm instructions of the algorithm instruction sequence have been selected. If not the next algorithm instruction such as Algorithm Instruction for example in the sequence of algorithm instructions is selected block for the programmable algorithm pattern generator . Since the algorithm instruction loop is nested within the data instruction loop the data instruction as well as the address instruction remain unchanged at this point. However the command instruction selection is reinitialized block as well as the offset instruction selection block to the first instruction of the respective instruction sequence . Accordingly the next selected algorithm instruction together with the initial instructions selected for the programmable pattern generators and may be applied to the appropriate generators of the programmable pattern generators and and executed block to generate the selected address data algorithm command and offset patterns to generate the appropriate stress tests of the memory .

If it is determined block that all of the algorithm instructions of the algorithm instruction sequence have been selected and executed a determination block is made as to whether all of the data instructions of the data instruction sequence have been selected. If not the next data instruction such as Data Instruction for example in the sequence of data instructions is selected block for the programmable data pattern generator . Since the data instruction loop is nested within the address instruction loop the address instruction remains unchanged at this point. However the algorithm instruction selection is reinitialized block as well as the command selection block and the offset instruction selection block to the first instruction of the respective instruction sequences . Accordingly the selected data instruction together with the initial instructions selected for the programmable pattern generators and may be applied to the appropriate generators of the programmable pattern generators and and executed block to generate the selected address data algorithm command and offset patterns to generate the appropriate stress tests of the memory .

If it is determined block that all of the data instructions of the data instruction sequence have been selected and executed a determination block is made as to whether all of the address instructions of the address instruction sequence have been selected. If not the next address instruction such as Address Instruction for example in the sequence of address instructions is selected block for the programmable address pattern generator . The data instruction selection is reinitialized block as well as the algorithm instruction selection block command instruction selection block and the offset instruction selection block to the first instruction of the respective instruction sequences . Accordingly the selected address instruction together with the initial instructions selected for the programmable pattern generators and may be applied to the appropriate generators of the programmable pattern generators and and executed block to generate the selected address data algorithm command and offset patterns to generate the appropriate stress tests of the memory . Once all of the address instructions of the address instruction sequence have been selected block the test pattern generation is done block unless new instructions are loaded into the sequences and executed repeating the test pattern generation and execution depicted in .

The defect detector circuit detects block a failure of a memory cell in response to a stress test applied by the test pattern generator using a stress test pattern generated by the test pattern generator . As described above a stress test may include memory commands including read commands write commands or both or control signals or both which are applied to the memory or a region thereof. Data is read from the memory and compared to expected results.

The comparison of actual to expected results may indicate a defect in a memory cell. If so a determination is made as to whether block the maximum number of defects has already been reached. In one embodiment the memory cells may be arranged in a plurality of memory regions and a fixed number of spare rows of memory cells may be available to be substituted for each row of memory cells containing a defective cell. Thus for a bank of memory cells for example there may be a maximum of two spare rows of cells to available to replace rows having defective cells in that particular bank of cells. It is appreciated that the number of spare rows of cells available for a particular region may vary depending upon the particular application. Thus although stress testing and repair is described herein with respect to rows and banks of memory cells it is appreciated that stress testing and repair may be organized at other levels such as on a rank basis or chip basis or any memory region or portion thereof.

In some embodiments the number of spare rows may exceed the number of repair list repository locations for storing row addresses of rows containing defects for a particular bank of memory. Accordingly the maximum number of defects will be equal to the number of spare rows available or the number of repair list repository locations available whichever is less for a particular bank of the memory .

It is understood that it may not be cost effective in some embodiments to implement a repair list repository with a relatively large number of locations for storing the addresses or rows needing repair. However if the number of repairable elements exceeds the number of repair list repository locations the test and repair process may be repeated finding additional failing rows on each iteration referred to herein as two pass three pass or n pass testing. In this manner it may be possible to test and repair memory devices with a large number of defects while employing a relatively limited number of repository locations.

The number of spare rows or repair list repository locations available for each bank of the memory may be set by a user setting a configuration register for example via the portal prior to the initiation of testing. In other embodiments the number of spare rows or repair list repository locations available for each bank of the memory may be set as a fixed value at the time of manufacture of the device .

Thus a determination may be made as to whether the number of memory locations such as rows for example having at least one defective memory cell exceeds a maximum for a particular memory region such as a bank of memory cells for example. In one embodiment such a determination may be made by checking a flag such as a flag of the flags of for example which when set indicates that the failure maximum has been reached. Thus upon detecting block a defective memory cell it may be determined whether block the maximum number of defects has already been reached for the region in which the defect was found by checking the status of the failure maximum flag for that region. If the maximum has already been reached such that the additional defect exceeds the maximum the detection and recording process is ended block for that particular defect.

In this manner the failure maximum flag provides an overflow indicator which indicates whether additional repair is possible for a particular bank. In one embodiment stress testing of a bank may continue after the failure maximum flag has been set to determine whether additional defects exist in that bank notwithstanding that additional spare rows or additional repair list repository locations are not available for use in connection replacement of any such additional defects. If appropriate a failure maximum flag may be reset by a write operation to a configuration register of the flags via the portal or by an explicit reset operation.

If the maximum number of defects has not been exceed a determination is made as to whether block the row of the defective memory cell is new that is whether the defective memory cell is the first known defective memory cell of a set of memory locations such as a row of memory cells for example. As previously mentioned in the illustrated embodiment the memory may be repaired by replacing a row of memory cells containing a defective cell with an entire row of spare cells. Hence if the row is not new and unique that is it has already been designated for replacement then the defect is not the first defect discovered for that row and the detection and recording process is ended block for that particular defect.

As explained below a row or other set of memory locations containing a defective memory cell may be designated for replacement in a memory configured as a repair list repository such as the repair list repository of failing memory addresses. In such an embodiment it may be determined as to whether block the defective memory cell is the first known defective memory cell of a row of memory cells for example by determining if the row of memory cells containing the defective memory cell of a particular memory region of memory cells has already been stored as an entry in the list of the repair list repository . If so the defective memory cell is determined to not be the first known defective cell of that row and storing a designation of that row containing the defective memory cell in the repair list repository as an entry of the list of memory locations may be bypassed block since the particular row of memory cells of the particular memory region of memory cells has already been stored as an entry in the list of the repair list repository.

If it is determined block that the defective memory cell is the first known defective memory cell of a set of memory locations such as a row of memory cells for example a determination may be made as to whether the number of memory locations such as rows for example having at least one defective memory cell has reached block the maximum for a particular memory region such as a bank of memory cells for example. If so the aforementioned failure maximum flag may be set block and the detection and recording process is ended block for that particular defect. In one embodiment the failure maximum may be set to indicate when the supply of spare rows available for replacement of defective rows has been exhausted for a particular memory region.

If the failure maximum has not been reached indicating that additional spare rows are available for use as replacement for defective rows for a particular memory region a determination is made as to whether block there have been prior failures of other rows detected. If so a counter representing a failure count is incremented block . This failure count may be compared to the failure maximum in a subsequent determination block to determine if the number of failure detections has reached the failure maximum.

The row address of the row containing the defective memory cell may be stored block in an appropriate location of the repair list repository of failing addresses and a flag set block indicating that the address of a row of memory cells has been stored in the repair list repository for repair of that row. This flag may be checked in a subsequent determination block as to whether there have been prior failures detected for that memory region. In one embodiment a flag may be set for each memory region indicating whether at least one row of the particular memory region has at least one defective memory cell.

Accordingly upon detection block of the first defective row of a particular bank such as Bank the row address of the memory cell row of Bank containing the defective memory cell may be placed in the repair list repository location Bank Fail and a flag may be set block in the Bank Flags location of the repair list repository indicating that the address of a row of memory cells has been stored in the repair list repository for repair of that memory cell row in Bank . Upon detection block of the next new unique defective memory cell row of Bank the failure count is incremented block to point to repository location Bank Fail the next location in the row of repository locations for Bank and the memory cell row address of that next new unique row of Bank containing the defective memory cell may be placed in the repair list repository location at Bank Fail . In addition a flag may be set block in the Bank Flags location of the repair list repository indicating that another address of a row of memory cells has been stored in the repair list repository for repair of that memory cell row in Bank .

Upon each subsequent detection of a new unique row of memory cells of Bank containing a defect the failure count is incremented block to point to the next repository location in the row of locations for Bank and the memory cell row address of that next unique memory cell row of Bank containing the defective memory cell may be placed in the repair list repository location corresponding to that failure count. In addition a flag may be set block in the Bank Flags location of the repair list repository indicating that another address of a memory cell row of memory cells has been stored in the repair list repository for repair of that row in Bank .

Stress testing of Bank continues until all of that bank has been stress tested with each of the programmed stress tests. As the stress testing of Bank progresses once the number of detected new unique rows containing a defect exceeds the number of spare rows for Bank the failure maximum is reached block and the failure maximum flag may be set block in the Bank Flags location in the repair list repository . At that point no additional memory cell row addresses are recorded block in the repair list repository since no additional spare rows remain for Bank . However stress testing of Bank may continue in one embodiment even after the failure maximum is reached to identify whether additional defects exist in Bank . In other embodiments stress testing of a particular bank may be terminated once the failure maximum has been reached.

Upon termination of stress testing and defect recordation in the repair list repository for Bank the failure count as indicated by the failure counter may be reset either automatically or by a user or external software resetting the failure counter prior to the initiation of testing of the next bank of the memory . In one embodiment the failure counter may be maintained as a register in the flags and accessed via the portal to be read or reset as appropriate. Also in some embodiments a separate failure counter may be maintained for each bank or other memory region of the memory .

Stress testing of the memory continues stress testing the remaining banks Bank Bank . . . Bank n wherein the memory cell row addresses of new unique memory cell rows containing defects are recorded in the repair list repository in a manner similar to that described above for Bank . In addition flags may be set for each bank as stress testing progresses for each bank as described above.

Once at least one memory cell row address of a row of memory cells containing a defect has been recorded in the repair list repository the self repair logic may automatically commence repairing the defective memory by replacing the row of cells containing a defect with a spare row of memory cells without user or external software intervention. In one embodiment the self repair logic may operate in parallel with the self test logic such that the memory may be repaired in parallel with ongoing stress testing of the memory to identify additional rows if any containing a defective memory cell.

Thus in one embodiment the repair logic may be activated once all stress tests are complete and all defective memory cells rows have been recorded in the repository . In another embodiment the repair logic may be activated once all stress tests are complete for a particular memory region such as a bank for example and all defective memory cells rows have been recorded in the repository for that bank. As such stress tests may be resumed to identify any memory defects in one bank while defective memory cell rows already recorded in the repair list repository are repaired for another bank. In yet another embodiment the repair logic may be activated to repair memory cell rows as soon as defective memory cell rows are recorded in the repair list repository without waiting for stress testing to be completed for a particular memory region such as a bank for example.

It is appreciated that the contents of the repair repository including the addresses of rows with at least one defective cell and the associated flags may be read out by hardware or software and saved for later use in repair. As described above the repair may be conducted as failures are detected or after all stress tests have completed. In addition the repair may be deferred to a later time in the same test step or even to some other future test step. If the repair data is stored in volatile registers it may be required to copy the data to some other permanent storage either on die or off die such as over a network or storage device before removing power from the repository . Storing the repair data in this way may not only facilitate deferred repair but may also serve as a permanent record of failure rates such as might be employed in process tracking for quality management or other purposes.

As explained in greater detail below the repair logic cycles through the list of failing addresses collected by the self test logic and recorded in the repair list repository . For each failing memory cell row the row address of which is recorded in a repository location of the repository the repair logic issues appropriate commands to the memory to replace the failing or failed row with a spare row built into the memory .

In a first state the state machine of the repair logic is idle awaiting recordation of a row address of a defective memory cell row in the repair list repository . Upon recordation of at least one row address of a defective memory cell row in the repair list repository the state machine automatically issues a precharge command state to precharge the memory region or regions containing the defective memory cell rows as identified in the repair list repository . Following a wait state to allow the precharge to complete the state machine automatically enables state the repair mode of the memory initiates state the repair of a memory cell row as identified by a location recorded in the repair list repository and enters a wait state to allow sufficient time for the repair of that memory cell row to be completed.

In one embodiment the state machine of the repair logic includes a suitable timer circuit for the wait state . For example a programmable delay counter may be provided to allow sufficient time such as 200 milliseconds for example for the repair to complete. In some embodiments the counter may have up to 20 bits depending on the input clock frequency. To reduce the size of the counter circuitry it may be appropriate in some embodiments to have a two stage counter which includes a fixed counter divider with an output timing granularity of approximately 2 to 5 milliseconds and a programmable 6 to 8 bit counter. It is appreciated that other timer designs may be employed depending upon the particular application.

In one embodiment the state machine of the repair logic may issue appropriate Post Package Repair PPR commands in accordance with the JEDEC JEDEC Solid State Technology Association formerly known as the Joint Electron Device Engineering Council protocols. In response to the commands fuses are opened or closed as appropriate to remove the defective memory cell row from the memory array and add a spare memory cell row in circuit to the array to substitute the spare memory cell row for the defective row. It is appreciated that other repair commands and protocols may be utilized depending upon the particular application.

Upon expiration of the wait state another precharge command state may be issued followed by another wait state to allow the precharge to complete. The cycle of state machine states is automatically repeated for each additional row address recorded in the repair list repository until all defective memory cell rows identified in the repair list repository have been replaced by spare memory cells of the associated bank.

Once all defective memory cell rows identified in the repair list repository have been replaced by spare memory cells of the associated bank the state machine of the repair logic exits state the repair mode waits state for the exit to complete and the repair operations are complete. A flag bit of the flags may be set to indicate that all repairs have been done. This flag bit may be polled internally or by external test equipment or software to determine when the repairs have been completed.

In one embodiment suitable instruction sequences may be loaded into appropriate configuration registers or other memory of the self test logic via the portal . Such loading operation may be performed automatically by logic on board the computer architecture device . In other embodiments devices or software external to the computer architecture device may be employed to load suitable instruction sequences into the self test logic . In this manner the instruction sequences may be changed as appropriate to facilitate changing stress test patterns. In still other embodiments suitable instruction sequences may be fixed into the logic of the self test logic . Whether instruction sequences are fixed or changeable it is appreciated that the nested loop structure of instruction sequences described herein may facilitate readily adapting the self test logic to conduct a wide variety of stress tests.

In one embodiment hardware configuration registers registers of the flags and the repair list repository are accessible in a system Peripheral Component Interconnect PCI or PCI Express configuration space or from a Test Access Port TAP controller. Configuration space registers may be mapped to memory locations. Device drivers and diagnostic software may have access to the configuration space and the operating system may use Application Programming Interfaces API s to allow access to the device configuration space. In those embodiments in which the operating system does not have access methods defined or API s for memory mapped configuration space requests the driver or diagnostic software accesses the configuration space in a manner that is compatible with the operating system underlying access rules. In other embodiments the hardware configuration registers may be accessed through some other interface or an existing interface adapted for the purpose of accessing hardware configuration registers.

In the illustrated embodiment the flags including the failure counter may be implemented with a single register or adjacent registers to facilitate allowing all status bits for a channel to be read with as few as a single TAP operation. Thus in one embodiment the registers for a 4 bank 4 row repair engine of the self repair logic circuit may occupy 20 bits for example for the flag bits plus the number of bits implementing the delay register of the finite state machine of the self repair logic circuit .

As previously mentioned the internal defect detection and repair circuit may interrupt normal memory transactions between the processor and memory to conduct memory test and repair operations. For example the defect detection and repair circuit may be invoked as part of a boot process executing a Basic Input and Output System BIOS boot process of the computer architecture device .

Also in this example the pipeline address generator is configurable into a plurality of configurations . . . depicted in respectively. A particular configuration may be selected by an address instruction for example of the address instructions . . . of the sequence of the instruction loop for example. In the illustrated embodiment each configuration . . . generates addresses in a particular address order of the hierarchical structure of the memory . As previously mentioned a memory region of rows and columns of memory cells may be referred to as a bank. The memory may have a plurality of integrated circuit memory chips in which a group of integrated circuit memory chips is often referred to as a rank. In this embodiment each rank of the memory has a rank address and comprises a plurality of banks of memory cells on one or more dies. However the memory may in some embodiments have a hierarchical structure which lacks ranks or may have one or more ranks on the same die.

Each bank of a rank of banks in turn has a bank address and comprises a memory region of a plurality of rows and column of memory cells arranged in an array. Thus the full address of each memory cell of the memory includes a rank address bank address row address and column address. However it is appreciated that in some embodiments a full address may lack a rank address for example.

The pipeline address generator may be configured to generate the full address of a memory cell in different address orders depending upon the configuration selected for the generator . Thus the pipeline address generator generates row column bank and rank addresses in a particular address order. By altering the address order in which the parts of the full address are generated the path of the generated addresses through the memory is correspondingly altered. Thus parameters of the address instruction may include address order. It is appreciated that other parameters may be included or utilized depending upon the particular application.

In one example the configuration of the pipeline address generator depicted in sequentially generates memory addresses sequentially in a first address order of rank bank row and column which defines the order in which addresses are sequentially generated by rank bank row and column as shown in . In the configuration the pipeline address generator has a column address generator in the lowest address order slot addressorder of the first pipestage n and a row address generator in the next lowest address order slot addressorder of the second pipestage n. Thus after initializing the rank bank row and column addresses blocks and outputs block the first full address the pipeline address generator increments the column address to generate block the next column address with the column address generator of the first pipestage n to traverse in a column loop nested in a row loop the generated full addresses across the columns of memory cells of a particular row of a particular bank of a particular rank before the row address generated by the row address generator of the second pipestage n changes in the row loop . Once traversal of the columns has been completed block in the column loop the pipeline address generator increments in the row loop the row address to generate block the next row address generated by the row address generator of the second pipestage n and resets block the column address to traverse the generated full addresses again across the columns of memory cells of the next row of a particular bank of a particular rank before the row address generated by the row address generator of the second pipestage n again changes block in the row loop .

In this manner the pipeline address generator generates full addresses of memory cells to traverse the generated full addresses across the columns and rows of a particular bank of memory cells in a column row address order. In the configuration the pipeline address generator has a bank address generator in the second to highest address order slot addressorder of the second pipestage n and a rank address generator in the highest address order slot addressorder of the second pipestage n. Thus the column loop is nested in the row loop which in turn is nested in a bank loop . The bank loop is in turn nested in a rank loop .

Thus once traversal of the rows and columns has been completed block in the nested column and row loops for a bank the pipeline address generator increments in the bank loop the bank address to generate block the next bank address generated by the bank address generator of the second pipestage n and resets the row address block and the column address block to traverse the generated full addresses across the next bank of memory cells of a particular rank in the manner described above in the nested column loop and row loop before the rank address generated block by the rank address generator of the second pipestage n changes. Once the traversal of all the banks of the particular rank has been completed block the pipeline address generator increments in the rank loop the rank address to generate block the next rank address generated by the rank address generator of the second pipestage n and resets block the bank address row address block and column address block to traverse the generated full addresses again across each of the banks of memory cells of the next rank in the manner described above in the nested column loop row loop and bank loop before the rank address generated by the rank address generator of the second pipestage n again changes block . Once the traversal of all the ranks of the selected memory region has been completed block the traversal of the selected memory region has been completed block . In this manner the pipeline address generator generates full addresses of memory cells to traverse the generated full addresses across the columns and rows of each bank of each rank of memory cells of the selected memory region in the address order of rank bank row and cell of the configuration of

In another example the configuration of configuration may be modified from that depicted in to generate memory addresses sequentially in a different address order of rank bank column and row for example as shown in and . In this modified configuration the pipeline address generator has a row address generator in the lowest address order slot addressorder of the first pipestage n and a column address generator in the next lowest address order slot addressorder of the second pipestage n. The positions of the rank address generator and the bank address generator are unchanged. Thus in the row loop is nested in the column loop which is nested in a bank loop which is in turn nested in a rank loop .

As shown in the pipeline address generator of this modified configuration increments block the row address generated by the row address generator of the first pipestage n to traverse the generated full addresses across the rows of memory cells of a particular column of a particular bank of a particular rank before the column address generated by the column address generator of the second pipestage n changes block .

In another example the configuration of configuration may be modified from that depicted in to generate memory addresses sequentially in a different address order of rank row column and bank for example as shown in . In this modified configuration the pipeline address generator has a bank address generator in the lowest address order slot addressorder of the first pipestage n a column address generator in the next lowest address order slot addressorder of the first pipestage n a row address generator in the second highest address order slot addressorder of the second pipestage n and a rank address generator in the highest address order slot addressorder of the second pipestage n. Thus the bank loop is nested in the column loop which is nested in the row loop which in turn is nested in a rank loop of

The pipeline address generator of this modified configuration increments in bank loop the bank address of a particular full address to generate block the next bank address generated by the bank address generator of the first pipestage n to traverse in bank loop the generated full address at a particular column address and row address across the banks of memory cells of a particular rank one memory cell per bank before the column row and rank addresses generated by pipeline address generator changes. Once the generated full address is traversed across the banks of memory cells of the particular rank the column address the next higher address order is incremented in the column loop to generate block the next column address with the column address generator of the first pipestage n. The bank address is reset block and the bank traversal process of bank loop repeated traversing that full address with the incremented column address and unchanged row and rank addresses across the banks of memory cells in the bank loop one memory cell per bank of the particular rank until the memory cells of the incremented column address and unchanged row and rank addresses of the banks have been traversed.

Once a generated full address has been incremented for each column and traversed block across the banks of memory cells of the particular rank one memory cell per bank for each bank and column such that traversal of the columns has been completed block in the column loop the bank block and column block addresses are reset and the row address the next higher address order is incremented in row loop to generate block the next row address with the row address generator of the second pipestage n. The bank column ordered traversal process of bank loop nested in column loop to traverse the banks in bank loop one column at a time as described above is repeated for the incremented row traversing the full address with the incremented row address and with unchanged rank address in the row loop across the banks in bank loop one column at a time and incrementing in column loop the column address each time the banks of the particular rank are traversed in the bank loop .

Thus once traversal of the rows and columns and banks has been completed block in the nested bank column and row loops for a rank the pipeline address generator increments in the rank loop the rank address to generate block the next rank address generated by the rank address generator of the second pipestage n and resets the row address block column address block and bank address block to traverse the generated full addresses again across each of the banks of memory cells of the next rank in the manner described above in the nested bank loop column loop and row loop before the rank address generated by the rank address generator of the second pipestage n again changes block . Once the traversal of all the ranks of the selected memory region has been completed block the traversal of the selected memory region has been completed block . In this manner the pipeline address generator generates full addresses of memory cells to traverse the generated full addresses across the columns and rows of each bank of each rank of memory cells of the selected memory region in the address order from lowest to highest of bank column row and rank of the configuration of and

In generating addresses to traverse through the memory it is appreciated that address portions such as row addresses column addresses bank addresses and rank addresses for example may be incremented by a positive or negative amount depending upon the selected traversal direction for example north south east west of the selected traversal pattern. It is further appreciated that address portions may be incremented positively or negatively by more than one applicable unit such as a cell bank or rank unit to skip cells banks or ranks depending upon the particular walking pattern selected. Moreover the incremental amount may vary rather than being fixed in some traversal patters. A traversal pattern including the parameters defining the traversal pattern may be selected by an address instruction for example of the address instructions . . . of the sequence of the instruction loop for example applied to a selected address generator.

In the neighbor traversal pattern depicted in four offset full addresses are generated by incrementing the column address of the base address in the row address of the base address first in one direction and then reversing to the opposite direction. Similarly an additional four offset full addresses are generated by incrementing the row address of the base address in the column address of the base address first in one direction and then reversing to the opposite direction. To facilitate rapid column or row address generation the positions of the row address and column address generators may be reconfigured from the configuration depicted in to be reversed as appropriate.

In accordance with another aspect of the present description the pipeline address generator has a carry count generator such as the carry count generators of the configurations respectively. In the illustrated embodiment one or more of the addresses generated by the corresponding address generators of the pipeline address generator are a function of the output of the carry count generator which is which performs a look ahead function for the address carry of addresses being generated.

For example in the address order of the configuration of following generation of the last row address the bank address increments to the bank address of the next bank of the sequence of the selected walking pattern. However in embodiments in which an address such as a row or column address is generated by an address generator having a large counter having 32 bits or 64 bits for example it is appreciated that generation of an address carry by such a generator may take a correspondingly large amount of time.

In addition the generator is configured block for a selected memory region. Such configurations parameters may be provided by an address instruction for example and may define the size of the memory region to be traversed in terms of number of ranks banks columns rows etc. and include a starting address for example. Following a startup period block such as the startup period the first full address may be output in a clock cycle interval such as the interval B of the clock clock for example.

Following the startup period a pipestage such as the pipestage n for example over the course of a clock cycle increments block and outputs the column address in the address order of the configuration of configuration FIG. and the column and row combined carry out count of the carry counter generator . Over the course of the next clock cycle a pipestage such as the pipestage n for example updates and outputs block the row address bank address and the rank address. The row address bank address and the rank address generated by the pipestage n are a function of the column and row combined carry out count generated by the pipestage n in the prior clock cycle. While the row address bank address and the rank address are being generated for one full address by the pipestage n the pipestage n is generating in the same clock cycle the column and row combined carry out count as well as the column address for the next full address. Thus to generate a full address takes two clock cycles. However because the pipestages n and n operate in parallel a full address is output each clock cycle. In one embodiment the output of the address carry count generator of the first pipeline stage is valid in each clock signal after the initial startup period and the next full address is valid in a subsequent part of each clock signal after the initial startup period.

If block the last full address of the selected memory region has not been generated and output the operations of block are repeated for the next clock cycle such as clock for example. In this manner a full address is generated and output for each clock cycle following the startup period. Once block all the addresses of the selected memory region have been generated the process ends block for that portion of the stress tests.

In the illustrated embodiment the memory is a dynamic random access memory DRAM in which bits are stored as charges on a node capacitance. In a DRAM a bit cell typically loses charge over time. To prevent loss of data stored in the memory the memory controller for a DRAM periodically issues a refresh signal to all the rows within an allowed refresh time to restore the charge and retain the data stored within each cell.

If the memory cells are refreshed too infrequently data may be lost. If the memory cells are refreshed too frequently energy may be wasted and may lead to premature battery exhaustion in portable devices. Accordingly the variable refresh signal generator may be programmed to generate a refresh signal at various refresh rates both within and without an expected refresh rate of the memory specification to test for defective cells and to determine whether the memory may be refreshed at a rate below specification and yet retain the stored data.

In one embodiment the variable refresh signal generator may be programmed to generate refresh signals in a declining sequence of refresh rates for refreshing memory cells at each rate of the declining sequence of refresh rates. Each refresh rate of the declining sequence may be reduced by an amount from the rate of the prior refresh rate of the declining sequence of refresh rates. In this manner the memory cells may be refreshed at declining refresh rates until memory defects or data loss is detected.

In one embodiment the refresh rate may be varied by varying the frequency of refresh signals as the test progresses. In another embodiment the duty cycle of refresh pulses of refresh signals may be varied as the test progresses. It is appreciated that refresh signals may be programmed to vary in other respects depending upon the particular application. In another aspect varying the refresh rate may be combined with various other stress tests in which memory commands of various memory command patterns are issued to memory cells addressed by various memory address traversal patterns as the refresh rate is varied.

In one embodiment the variable refresh signal generator may be programmed or configured by algorithm instruction such as one of the algorithm instructions . . . of the sequence of the algorithm instruction loop for example to provide refresh signals at a programmed rate.

The data input and modified by the variable refresh signal generator to generate a refresh signal at various refresh rates may be provided by the programmable data pattern generator . In other embodiments the input signal may be self generated by the variable refresh signal generator . In one embodiment the output of the generator is an alternate data source which may be selected by a parameter of a command instruction.

In the illustrated embodiment the pattern sequencers are each programmable to output various patterns of multiplexer selection signals S S S. In one embodiment the pattern sequencers may be programmed by the sequential loop of algorithm instructions in the sequence of algorithm instructions Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n. Each algorithm instruction Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n of the sequence when executed by an appropriate one of the pattern sequencers causes that pattern sequencer to generate a multiplexer select signal pattern as a function of the particular algorithm instruction.

In another aspect of the algorithm generator the pattern mixer data which is generated and stored in the cache may remain static that is unchanged over the course of a particular stress test. is a table depicting examples of various Boolean function based modes of operation based upon various pattern mixer codes which may be stored in the cache and provided to the inputs of a particular multiplexer . . . . As shown in the data output by each multiplexer . . . may be considered as a Boolean function of the multiplexer selection signals S S S. The particular Boolean function of the multiplexer selection signals S S S may be selected by storing a particular pattern mixer code in the cache and providing the pattern mixer code to the inputs of a particular multiplexer . . .

For example if the pattern mixer code 00 hex is stored in the cache and provided to the inputs of the multiplexer for example the data output of the multiplexer is a constant 0 bit value. Similarly if the pattern mixer code FF hex is stored in the cache and provided to the inputs of the multiplexer for example the data output of the multiplexer is a constant 0 bit value. If the pattern mixer code AA hex is stored in the cache and provided to the inputs of the multiplexer for example the data output of the multiplexer is the same as the multiplexer selection signal S. The other multiplexer selection signals S S are don t care for pattern mixer code AA . Similarly if the pattern mixer code CC or F0 hex is stored in the cache and provided to the inputs of the multiplexer for example the data output of the multiplexer is the same as the multiplexer selection signal S S respectively.

If the pattern mixer code 03 hex is stored in the cache and provided to the inputs of the multiplexer for example the data output of the multiplexer is the same as the Boolean AND function of the inverse of each of the multiplexer selection signals S and S. The other multiplexer selection signal S is don t care for pattern mixer code 03 . If the pattern mixer code 80 hex is stored in the cache and provided to the inputs of the multiplexer for example the data output of the multiplexer is the same as the Boolean AND function of the multiplexer selection signals S S and S. If the pattern mixer code C hex is stored in the cache and provided to the inputs of the multiplexer for example the data output of the multiplexer is the same as the Boolean AND function of the multiplexer selection signals S and S. The other multiplexer selection signal S is don t care for pattern mixer code C . If the pattern mixer code EE hex is stored in the cache and provided to the inputs of the multiplexer for example the data output of the multiplexer is the same as the Boolean OR function of the multiplexer selection signals S and S. The other multiplexer selection signal S is don t care for pattern mixer code EE . It is appreciated that other Boolean functions may be selected using other pattern mixer codes depending upon the particular application.

In one embodiment the pattern mixer code is programmed at the beginning of the test and may be relatively static that is is not reprogrammed as the test progresses through the test cycle. Conversely the pattern streams of the multiplexer selection signals S S S connected to the multiplex select inputs may be relatively dynamic that is change on every clock cycle for example. By comparison in prior multiplexed schemes it is believed that dynamic input streams typically go to the multiplexer inputs and one of the dynamic streams is selected with relatively static selection signals on the select lines of the multiplexer.

In another aspect of the algorithm generator each the pattern sequencer is a multi mode pattern sequencer in which a mode of operation may be selected to output a selected pattern of multiplexer selection signals S S S. . shows one example of the pattern sequencers as a multi mode pattern sequencer. The other pattern sequencers may be constructed in a similar fashion. The capability of selecting one of a plurality of modes of operation in each sequences permits for example allowing the same sequence for outbound patterns directed to the memory to be used for many tests on many devices as well as allowing patterns of the expected results for comparing to inbound test results to be generated on the fly. Thus test patterns for stress testing memory regions may be generated in real time as expected results patterns for those test patterns are generated either at the same time or in overlapping fashion for example.

The pattern sequencer includes a first fixed pattern mode in which a shift register shifts a fixed pattern stored in the shift register on a shift register output through an output multiplexer to the pattern sequencer output which is multiplexer select signal S in this example. The pattern may be shifted into the shift register through an input multiplexer . The pattern sequencer further includes a clock signal pattern mode which a clock signal generator outputs a clock signal on an output through the output multiplexer to the pattern sequencer output that is the multiplexer selection signal S. In the illustrated embodiment the clock signal has a programmable period and programmable duty cycle in which the length of the clock pulse within the clock period is programmable.

The pattern sequencer further includes a linear feedback mode which outputs a linear feedback polynomial pattern to the pattern sequencer output . The pattern sequencer has linear feedback polynomial logic of a finite state machine which determines the next state of the finite state machine of the multi mode pattern sequencer . An output of the shift register is fed back to inputs of the linear feedback polynomial logic and to an input of the input multiplexer .

As best seen in each bit of the linear feedback polynomial logic includes one or more multiplexers having an input coupled to the output of a bit register of the shift register and an output coupled to the input of the shift register . Another input of the multiplexer of each bit of the linear feedback polynomial logic is coupled to polynomial combinational logic as represented by an exclusive OR gate . The linear feedback polynomial logic of the finite state machine determines the next state of the finite state machine of the multi mode pattern sequencer in which the state of the finite state machine is represented by the bits stored in the bit registers of the shift register . In this manner the linear feedback polynomial finite state machine of the linear feedback mode shares the bit registers of the shift register of the fixed pattern mode. Thus in this example the linear feedback mode which may also be referred to as a linear feedback shift register LFSR based mode the shift register holds the initial seeds provided through the input multiplexer and the LFSR feedback polynomials of the logic determine the next states of the state machine . In one embodiment the logic supports multiple optimized LFSR polynomials which may vary in size such as from 8 bits to 32 bits for example.

As previously mentioned a random pattern generated by an algorithm generator such as the algorithm generator for example executing a selected algorithm instruction such as the Algorithm Instruction for example may be used to create white noise on an interconnect to stress the interconnect to test for a defect. Thus if one pattern sequencer such as pattern sequencer for example was programmed to be operated in the clock signal mode to generate a low frequency clock signal on multiplexer select line S and another pattern sequencer such as the pattern sequencer was programmed to operate in the LFSR based mode to generate a random appearing bit pattern on the multiplexer select line S the Boolean function of S AND S provided by the pattern mixer code C hex will provide a burst of noise followed by quiet period and the cycle repeats.

In one embodiment seed data may be provided and a mode of operation may be selected from the available modes of operation including the fixed pattern mode of the shift register the programmable clock signal mode of the clock generator and the linear feedback polynomial mode by application of one or more algorithm instructions in the sequence of algorithm instructions Algorithm Instruction Algorithm Instruction . . . Algorithm Instruction n. In other embodiments modes may be selected by other portions of the tester circuit.

For example a data background function is a selectable function which may be selected by a parameter of a data instruction being executed by the data generator . Accordingly in the embodiment of the data generator has an input for receiving parameters of the data instructions by which a function may be selected. In a first operation a memory address based background function is selected block at the input . A pattern of data and inverted data is generated block in accordance with selected memory address based background function and output at the output .

An example of one such data background function is a solid function in which the same value such as a logical 1 for example is written to and then subsequently read back from every address of a particular region under test as illustrated in for a memory region of memory cells of the memory . The memory region is represented by a five by five array of memory cells arranged in columns and rows. As previously mentioned a typical memory region may be substantially larger and thus may have memory cells numbering in the kilobytes megabytes gigabytes terabytes or more. One example of a memory region is often referred to as a bank. Each memory cell may store a single bit a byte a word or a longer string of bits depending upon the particular application.

Another data background function which may be selected by an appropriate parameter of a data instruction being executed by the data generator is a alternating column stripe function in which data which is being generated is written to and then subsequently read back from every address of the even columns of a particular region under test as illustrated in for the memory region of memory cells of the memory and in which data which is being generated is inverted and then written to and then subsequently read back from every address of the odd columns of a particular region under test as illustrated in for the memory region of memory cells of the memory . It is appreciated that in other embodiments the inverted data may be written to the even columns instead of the odd columns.

Accordingly the data generator of the embodiment of includes a data inverter which can selectively invert the generated data before it is written to the memory region under test as a function of the addresses of the memory cells to which the data is being written. Thus in the embodiment of the data generator has an input for receiving the addresses being generated by one or more address generators of the test pattern generator . In this example the data inverter selectively inverts the generated data as a function of the column addresses of the memory cells of the region to be tested. More specifically the data is inverted for odd column addresses and remains uninverted for even column addresses. For example in one embodiment the data may be inverted Inverted Data if the least significant or lowest order bit of the column address is odd a logical 1 and may remain uninverted Data if the least significant bit of the column address is even a logical 0 . It is appreciated that in other embodiments the data may be inverted for even column addresses and remain uninverted for odd column addresses. The data which is selectively inverted or selectively remains uninverted may be generated internally by the data generator or may be generated by another data generator . . . of the test pattern generator and input at an input of the data generator

Another data background function which may be selected by an appropriate parameter of a data instruction being executed by the data generator is a alternating row stripe function in which data which is being generated is written to and then subsequently read back from every address of the even rows of a particular region under test as illustrated in for the memory region of memory cells of the memory and in which data which is being generated is inverted and then written to and then subsequently read back from every address of the odd rows of a particular region under test as illustrated in for the memory region of memory cells of the memory . It is appreciated that in other embodiments the inverted data may be written to the even rows instead of the odd rows.

In this example the data inverter selectively inverts the generated data as a function of the row addresses of the memory cells of the region to be tested. More specifically the data is inverted for odd row addresses and remains uninverted for even row addresses. For example in one embodiment the data may be inverted Inverted Data if the least significant or lowest order bit of the row address is odd a logical 1 and may remain uninverted Data if the least significant bit of the row address is even a logical 0 . It is appreciated that in other embodiments the data may be inverted for even row addresses and remain uninverted for row column addresses.

Yet another data background function which may be selected by an appropriate parameter of a data instruction being executed by the data generator is an alternating row and column cell or checkerboard function in which data which is being generated is written to and then subsequently read back from every even cell address of the even rows of a particular region under test as illustrated in for the memory region of memory cells of the memory and in which data which is being generated is inverted and then written to and then subsequently read back from every odd cell address of the even rows of a particular region under test as illustrated in for the memory region of memory cells of the memory .

Similarly in the checkerboard function data which is being generated is written to and then subsequently read back from every odd cell address of the odd rows of a particular region under test as illustrated in for the memory region of memory cells of the memory and data which is being generated is inverted and then written to and then subsequently read back from every even cell address of the odd rows of a particular region under test as illustrated in for the memory region of memory cells of the memory . In the illustrated embodiment the least significant or lowest order bit of the column address and the least significant bit of the row address of each memory cell are input in an Exclusive OR function to determine whether the data generated to Write Read to that specific address is inverted Inverted Data or remains uninverted Data . It is appreciated that in other Checkerboard data background functions the inverted data may be written to the even cell addresses of the even rows instead of the odd cell addresses of the even rows and the inverted data may be written to the odd cell addresses of the odd rows instead of the even cell addresses of the odd rows.

In this example the data inverter selectively inverts the generated data as a function of both the row and column addresses of the memory cells of the region to be tested. More specifically the data is inverted or not inverted as an Exclusive OR function of the least significant bit of the row and column addresses. It is appreciated that in other embodiments the data may be inverted or not inverted as a function of other functions including other logical function of the row and column addresses depending upon the particular application.

In the illustrated embodiment a data background function may be selected using an appropriate parameter of a data instruction. Thus a solid data background function an alternating column stripe background function an alternating row stripe background function or a checkerboard background function may be selected using a parameter code of 00 01 10 or 11 respectively for example. It is appreciated that other data background functions may be selected and other instruction parameter codes may be utilized to select the particular data background functions depending upon the particular application.

Another example of a selectable function for the generated pattern of data is a global invert function which globally inverts all data being generated for all memory cells of the region under test. Such a global inversion of the test data may be selected using an appropriate parameter of a data instruction for example.

Another example of a selectable function for the generated pattern of data is a selectable periodic data inversion function in which data is inverted as a function of a periodic pattern of memory address offsets. Accordingly in the embodiment of the data generator has an input for receiving address offsets being generated by one or more address offset generators of the test pattern generator in response to appropriate offset address instructions. As explained below a selectable periodic pattern of memory address offsets may be generated by a selectable periodic memory address offset function. In one embodiment the selectable periodic memory address offset function may be selected with an appropriate offset address instruction which is executed by an address offset generator to generate the selected periodic pattern of memory address offsets.

Utilizing a selectable periodic data inversion function data being written to a memory region under test may be inverted on a select set of cells of that region in response to an address offset instruction as the memory region is being traversed. Similarly when the memory region is traversed a second time to read the data from the memory region to verify the prior data write operations another address offset instruction may be used to account for the periodic data inversion of the data write operations.

One example of a selectable periodic data inversion function which may be selected by an appropriate address offset instruction being executed by an address offset generator and an appropriate data instruction executed by the data generator is a single column stripe function in which data which is being generated is inverted and then written to a single column such as the column Col for example of of a memory region which is a four by four memory cell region in this example. For the remaining columns of the memory region under test the data which is being generated is written without being inverted as indicated for the columns Col Col Col of . Although the memory region under test is depicted as a four by four array of memory cells in for clarity purposes it is appreciated that the memory region under test may typically have tens hundreds thousands millions etc. of memory cells depending upon the particular application.

In traversing the four by four cell memory region depicted in the base cell of the traversal may be considered to be the cell at the row and column address Row Col for example. In this example the data written to the base cell at Row Col is inverted as shown in . The memory region may be traversed from left to right along a row for example. This left to right traversal along a row is indicated as the north direction in

If the data written to the base cell at the row and column address Row Col is inverted the data written to the next three data cells at Row Col Row Col Row Col respectively in a north traversal of a single column stripe data inversion pattern are not inverted. Continuing the traversal in the north direction the data written to the next cell at the row and column address Row Col is inverted and the data written to the next three data cells at Row Col Row Col Row Col respectively in the north direction traversal are not inverted. This process is repeated until data has been written to all the memory cells of the memory region under test wherein the data written to the cells of a four by four memory region in a north direction traversal is inverted every fourth cell to produce a single column stripe data inversion pattern with a period of four cells.

The number of rows or the number of columns of a square array of memory cells in a memory region under test may be represented by the variable N. Thus for a single column stripe data inversion pattern for an N by N array of memory cells in the memory region under test the period of the periodic data inversion function is equal to N for a traversal in the north direction. For an M rows by N columns rectangular array the period of the periodic data inversion function is equal to N the number of columns within the array for a traversal in the north direction.

The memory region may traversed in the south direction in a single column stripe data inversion pattern instead of in the north direction. It is seen that the data written to the cells of a four by four memory region in a south direction traversal is again inverted every fourth cell to produce a single column stripe data inversion pattern with a period of four cells. Hence the period of the periodic data inversion function in this single stripe pattern is the same that is N the number of columns in the array whether in the north or south direction to produce a single column stripe data inversion pattern. In a subsequent verification test the data generated to test the data read back from the M rows by N columns memory region in a north or south direction traversal is inverted every Nth cell to produce a single column stripe data inversion pattern with a period of N cells.

Another example of a periodic data inversion function which may be selected by an appropriate address offset instruction being executed by the data generator is a row stripe function in which data which is being generated is inverted and then written to a single row such as the row Row for example of of a memory region which is a four by four memory cell region in this example. For the remaining rows of the memory region under test the data which is being generated is written without being inverted as indicated for the rows Row Row Row of . Although the memory region under test is depicted as a four by four array of memory cells in for clarity purposes it is appreciated that the memory region under test may typically have tens hundreds thousands millions etc. of memory cells depending upon the particular application.

In traversing the four by four cell memory region depicted in the base cell of the traversal may be considered to be the cell at the row and column address Row Col for example. In this example the data written to the base cell at Row Col is inverted as shown in . The memory region may be traversed from up to down along a column for example. This up to down traversal along a column is indicated as the east direction in

If the data written to the base cell at the row and column address Row Col is inverted the data written to the next three data cells at Row Col Row Col Row Col respectively in an east traversal of a single row stripe data inversion pattern are not inverted. Continuing the traversal in the east direction the data written to the next cell at the row and column address Row Col is inverted and the data written to the next three data cells at Row Col Row Col Row Col respectively in the east direction traversal are not inverted. This process is repeated until data has been written to all the memory cells of the memory region under test wherein the data written to the cells of a four by four memory region in an east direction traversal is inverted every fourth cell to produce a single row stripe data inversion pattern with a period of four cells where the period again equals N the size of the square array. Thus for a single row stripe data inversion pattern for an N by N square array of memory cells in the memory region under test the period of the periodic data inversion function is equal to N for a traversal in the east direction. For an N rows by M columns rectangular array the period of the periodic data inversion function is equal to N the number of rows within the array for a traversal in the north direction.

The memory region may traversed in the west down to up direction in a single row stripe data inversion pattern instead of in the east direction. It is seen that the data written to the cells of a four by four memory region in a west direction traversal is again inverted every fourth cell to produce a single row stripe data inversion pattern with a period of four cells. Hence the period of the periodic data inversion function in this single row stripe pattern is the same that is N the number of rows of the array whether in the east or west direction to produce a single row stripe data inversion pattern. In a subsequent verification test the data generated to test the data read back from the N rows by M columns memory region in an east or west direction traversal is inverted every Nth cell to produce a single row stripe data inversion pattern with a period of N cells.

Another example of a selectable periodic data inversion function for the generated pattern of data in which data is inverted as a function of a periodic pattern of memory address offsets is a diagonal stripe data inversion function as depicted in . In the diagonal stripe data inversion function data which is being generated is inverted and written to a diagonal stripe of a memory region under test which may be similar to the memory region of for example. For the remaining cells of the memory region under test which are not within the diagonal stripe the data which is being generated is written without being inverted.

In traversing the four by four cell memory region depicted in the base cell of the traversal may be considered to be the cell at the row and column address Row Col for example. In this example the data written to the base cell at Row Col is inverted as shown in . The memory region may be traversed from left to right along a row for example. This left to right traversal along a row is indicated as the north direction in

If the data written to the base cell at the row and column address Row Col is inverted the data written to the next four data cells at Row Col Row Col Row Col Row Col respectively in a north traversal for a single diagonal stripe data inversion pattern are not inverted followed by inverting the data written to the next fifth cell at the row and column address Row Col. The data written to the next four data cells at Row Col Row Col Row Col Row Col respectively in the north direction traversal are not inverted and the data written to the next fifth cell at the row and column address Row Col is inverted. This process is repeated until data has been written to all the memory cells of the memory region under test. In this manner the data written to the cells of a four by four memory region in a north direction traversal is inverted every fifth cell to produce a single diagonal stripe data inversion pattern with a period of five cells. Thus for a single diagonal stripe data inversion pattern for an N by N array of memory cells in the memory region under test the period of the periodic data inversion function is equal to N 1 for a traversal in the north direction. For an M rows by N columns rectangular array the period of the periodic data inversion function is equal to N 1 where N equals the number of columns within the array for a traversal in the north direction.

The memory region may also be traversed in the east down direction along a column to generate a single diagonal stripe data inversion pattern instead of in the north left to right direction along a row. It is seen that the data written to the cells of a four by four memory region in an east direction traversal is again inverted every fifth cell to produce a single diagonal stripe data inversion pattern with a period of five cells. Hence the period of the periodic data inversion function in this single diagonal stripe pattern is the same whether in the north or east direction to produce a single diagonal stripe data inversion pattern. In a subsequent verification test the data generated to test the data read back from the four by four memory region in a north or east direction traversal is inverted every fifth cell to produce a single diagonal stripe data inversion pattern with a period of five cells. Thus for a single diagonal stripe data inversion pattern for an N by N array of memory cells in the memory region under test the period of the periodic data inversion function is equal to N 1 for a traversal in the east direction. For an N rows by M columns rectangular array the period of the periodic data inversion function is equal to N 1 where N equals the number of rows within the array for a traversal in the east direction.

In each period of cells such as a period of five cells discussed in these examples the particular cell for which the data is inverted may be the first cell of the period or may be the last cell of the period or may be an intermediate cell of the period. In other embodiments it is appreciated that the data for more than one cell of the period including intermediate cells may be inverted to produce a diagonal stripe data inversion pattern.

The memory region may also be traversed in the west up direction along a column to generate a single diagonal stripe data inversion pattern. In traversing the four by four cell memory region depicted in the base cell of the traversal may again be considered to be the cell at the row and column address Row Col for example. In this example the data written to the base cell at Row Col is inverted as shown in . The memory region may be traversed in the west direction from down to up along a column for example. This down to up traversal along a column is indicated as the west direction in

If the data written to the base cell at the row and column address Row Col is inverted the data written to the next two data cells at Row Col Row Col respectively in a west traversal for a single diagonal stripe data inversion pattern are not inverted followed by inverting the data written to the next third cell at the row and column address Row Col. The data written to the next two data cells at Row Col Row Col respectively in the west direction traversal are not inverted and the data written to the next third cell at the row and column address Row Col is inverted. This process is repeated until data has been written to all the memory cells of the memory region under test. In this manner the data written to the cells of a four by four memory region in a west direction traversal is inverted every third cell to produce a single diagonal stripe data inversion pattern with a period of three cells. Thus for a single diagonal stripe data inversion pattern for an N by N array of memory cells in the memory region under test the period of the periodic data inversion function is equal to N 1 for a traversal in the west direction. For an N rows by M columns rectangular array the period of the periodic data inversion function is equal to N 1 where N equals the number of rows within the array for a traversal in the west direction.

The memory region may also be traversed in the south right to left direction along a row to generate a single diagonal stripe data inversion pattern instead of in the west down to up direction along a column. It is seen that the data written to the cells of a four by four memory region in a south direction traversal is again inverted every third cell to produce a single diagonal stripe data inversion pattern with a period of three cells. Hence the period of the periodic data inversion function in this single diagonal stripe pattern is the same whether in the south or west direction to produce a single diagonal stripe data inversion pattern. In a subsequent verification test the data generated to test the data read back from the four by four memory region in a north or east direction traversal is inverted every third cell to produce a single diagonal stripe data inversion pattern with a period of three cells. Thus for a single diagonal stripe data inversion pattern for an N by N array of memory cells in the memory region under test the period of the periodic data inversion function is equal to N 1 for a traversal in the south direction. For an M rows by N columns rectangular array the period of the periodic data inversion function is equal to N 1 where N equals the number of columns within the array for a traversal in the south direction.

In each period of cells such as a period of three cells discussed in these examples the particular cell for which the data is inverted may be the first cell of the period may be the last cell of the period or may be an intermediate cell of the period. In other embodiments it is appreciated that the data for more than one cell of the period including intermediate cells may be inverted to produce a diagonal stripe data inversion pattern.

In a first operation a period for generating periodic memory address offsets is selected block . In the illustrated embodiment the period for generating periodic memory address offsets may be specified as a parameter of an offset address instruction which may be input at the input of the offset address generator . As indicated above in the example of an N by N array the period for generating periodic memory address offsets may be initially specified as N as a parameter of an offset address instruction. In the example of an M rows by N columns array the period for generating periodic memory address offsets may be initially specified as N the number of columns of the array for a north or south traversal as a parameter of an offset address instruction. In the example of an N rows by M columns array the period for generating periodic memory address offsets may be initially specified as N the number of rows of the array for an east or west traversal as a parameter of an offset address instruction. It is appreciated that an offset address instruction may have other parameters such as a parameter enabling a periodic data inversion function.

In another operation an adjustment for the specified period for generating periodic memory address offset is selected block . In the illustrated embodiment the adjustment for adjusting the period for generating periodic memory address offsets may be specified as a parameter of an offset address instruction which may be input at the input of the offset address generator . The table of indicates examples of parameter codes which may be used to select various adjustments to the specified period for generating a pattern of periodic memory address offsets for various periodic data inversion functions. Thus for a memory cell array adjustment to the specified initial period N for generating periodic memory address offsets may be specified as 0 using a parameter code such as 00 for example as shown in . Similarly adjustment to the specified period N for generating periodic memory address offsets may be specified as 1 using a parameter code such as 01 or 10 for example. Also adjustment to the specified period N for generating periodic memory address offsets may be specified as 1 using a parameter code such as 11 for example. It is appreciated that other adjustments may be made to the period of a periodic data inversion function using other parameter codes depending upon the particular application.

As set forth above for a single column stripe data inversion pattern for example for a memory region under test the period of the periodic data inversion function is initially equal to N the number of columns of the memory region for a traversal in the north or south direction. Hence as indicated in the table of for a single column stripe data inversion pattern the adjustment to the period may be specified using an appropriate offset address instruction parameter code to be zero 0 so that the adjusted period remains N. The data inversion may occur on the Nth access to the cells of the period in response to this offset address instruction parameter.

Similarly for a single row stripe data inversion pattern for example for a memory region under test the period of the periodic data inversion function may initially be specified to be equal to N the number of columns of the memory region for a traversal in the west or east direction. Hence for a single row stripe data inversion pattern the adjustment to the period may be specified using an appropriate offset address instruction parameter code to again be zero 0 . The data inversion may occur on the Nth access for example to the cells of the period in response to this offset address instruction parameter.

Thus an adjustment of zero to the period of the periodic data inversion function with an inversion on the Nth access may be selected by providing a parameter code such as of 00 for example as a parameter of an offset address instruction as indicated in to provide a row or column stripe periodic data inversion function. It is appreciated that the inversion may be selected to occur on other accesses to the cells of each period depending upon the particular application.

Also as set forth above for a single diagonal stripe data inversion pattern for example for a memory region under test the initial period of the periodic data inversion function is adjusted to equal to N 1 for a traversal in the north or east direction. Hence for a single diagonal stripe data inversion pattern being traversed in the north or east direction the adjustment to the period may be specified to be plus one 1 using an offset address instruction parameter code of 01 or 10 for example. A parameter code of 01 may be used to specify that the inversion occurs on the Nth access to the cells of the period. Conversely a parameter code of 10 may be used to specify the inversion occurs on the first access to the cells of the period. It is appreciated that other parameter codes may be utilized to select the appropriate adjustment to the period and the appropriate access for the inversion to achieve a particular periodic data inversion function.

Similarly for a single diagonal stripe data inversion pattern for example for a memory region under test the initial period of the periodic data inversion function may be adjusted to equal to N 1 for a traversal in the west or south direction. Hence for a single diagonal stripe data inversion pattern being traversed in the west or south direction the adjustment to the period may be specified to be minus one 1 using an offset address instruction parameter code of 11. The parameter code of 11 may also be used to specify that the inversion occurs on the Nth access to the cells of the period. It is appreciated that other parameter codes may be utilized to select the appropriate adjustment to the period and the appropriate access for the inversion to achieve a particular periodic data inversion function.

A pattern of offset memory addresses may be generated block to invert data in accordance with a selected offset address instruction. As previously mentioned the pattern of data output at an output of the data generator is generated as a selectable function of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written. One such selectable function discussed above is a selectable periodic data inversion function in which data is selectively inverted as a function of a selectable periodic pattern of memory address offsets. In the embodiment of the input of the data generator receives the periodic pattern of address offsets being generated by the address offset generator of the test pattern generator in response to appropriate offset address instructions.

Accordingly a periodic data inversion function such as the single column stripe function the single row stripe function and the single diagonal stripe function may be selected using an offset address instruction having appropriate parameters defining the initial period of the periodic pattern of address offsets being generated by the address offset generator of the test pattern generator and the adjustments to the period and cell access within the period as discussed above. It is appreciated that other periodic data inversion functions and other periodic patterns of address offsets may be selected depending upon the particular application.

In the illustrated embodiment in traversing a memory region under test in connection with a periodic data inversion function the increments to the row addresses and column addresses may be limited to a plus one 1 increment for example. It is appreciated that in other embodiments the size of the row or column increments for traversing a memory region may vary depending upon the particular application.

In another aspect of the present description a periodic data inversion function as described herein may be repeated incrementing the address of the base cell each time the periodic data inversion function is performed. In one embodiment the number of repeats of the periodic pattern of address offsets may be set to the number of cells within the memory region under test.

In still another aspect of the present description inversion functions as described herein may be chained together to invert the data in stages as depicted in . The output of a data inversion function in one stage is input by the data inversion function of the next stage of the chain.

The inversion functions Function X inv Function Y inv Function Z inv represent various inversion functions each which may be a periodic data inversion function as described herein or another inversion function such as data background function for example. Thus the output of one inversion function stage having an inversion function such as a single diagonal stripe pattern inversion function may be input by the next stage having a global inversion function for example. Other combinations of inversion functions may be chained together in stages depending upon the particular application. Although depicts three such inversion functions chained together it is appreciated that the number of chained inversion functions may vary depending upon the particular application.

In another aspect of the present description a user or vendor defined function of a stage may also be chained with the pattern generation functions described herein. The user or vendor defined function may include logical to physical memory address mapping logic to provide a logical to physical mapping of memory addresses. Mapping values for mapping of the logical to physical memory address mapping logic may be defined by the user or vendor using registers of the user or vendor defined function stage .

It is appreciated that memory addresses which are contiguous in a logical memory space may not be physically contiguous in the actual physical layout of physical blocks of memory. Thus a row address may be used for example as a key to determine if odd and or even data bits are to be inverted. This data generation capability provides a user defined function through registers space similar to programmable logic array to give the vendors the flexibility to program the inversion as a function of address bits after a design has been implemented in an integrated circuit device without changing the integrated circuit device. Moreover this user defined function frees a designer from predicting a particular vendor s physical address map ahead of time and the vendor need not disclose their physical layout while using the tester described herein to test their memory circuits.

Another example of a selectable function for the generated pattern of data is a data lane rotation function which rotates a lane of data being generated for a memory region under test. For example a memory having a 64 bit data bus may be thought of as having 64 data lanes that correspond to the 64 bit data bus. shows an example of a data lane Lane having five bits bit bit arranged right to left from least significant bit LSB to most significant bit MSB . It is appreciated that the number of bits in each lane such as Lane may vary depending upon the particular application. For example the number of bits may be substantially larger depending upon the size of the data pattern being generated and the size of the memory region under test.

The data of each lane of the data pattern being generated may be rotated one data bit position each rotation in a direction from the least significant bit position toward the most significant bit as shown in which depicts four such rotations. Each rotation the bit at the most significant bit position rotates back to the least significant bit position. The data lane rotation function may be enabled in a parameter of a data instruction for example. The number of rotations may similarly be specified in a parameter of a data instruction. The data pattern of each rotation may be applied in turn to a memory region being tested and used to test the results of each such test.

Example 1 is a memory controller for use with a memory having memory cells including spare memory cells comprising 

an internal self test logic circuit built in within the memory controller the self test logic circuit including 

a test pattern generator for generating test patterns and for testing memory cells within the memory using the generated test patterns 

a detector circuit adapted to detect defective memory cells in response to the test patterns testing the memory cells and to store in the repository within the memory controller a list of memory locations each memory location of the list having a set of memory cells which includes at least one defective memory cell and

an internal self repair logic circuit built in within the memory controller the internal self repair logic including a repair logic circuit adapted to read the list of memory locations stored in the repository and to repair the memory locations of the list by substituting a memory location of spare memory cells for a memory location having at least one defective memory cell.

In Example 2 the subject matter of Examples 1 20 excluding the present Example can optionally include a semiconductor die wherein the internal self test logic circuit and the internal self repair logic circuit are disposed on the die of the memory controller.

In Example 3 the subject matter of Examples 1 20 excluding the present Example can optionally include that the test pattern generator includes a plurality of generators including at least one address generator and a loop sequencer circuit adapted to apply to the generators a plurality of nested loop instructions including a sequential loop of address instructions in a sequence of address instructions to an address generator each address instruction of the sequence when executed by an address generator causes an address generator to generate a pattern of memory cell addresses and wherein the test pattern generator is adapted to execute memory commands at memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 4 the subject matter of Examples 1 20 excluding the present Example can optionally include that the plurality of generators includes at least one data generator and wherein the loop sequencer circuit is adapted to apply to a data generator a sequential loop of data instructions in a sequence of data instructions each data instruction of the sequence when executed by a data generator causes a data generator to generate a pattern of data for a pattern of test data wherein the sequential loop of data instructions is nested within another loop of instructions and wherein the test pattern generator in executing memory commands at memory cells is adapted to write a pattern of test data generated by a data instruction being executed in sequence in the loop of data instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 5 the subject matter of Examples 1 20 excluding the present Example can optionally include that the plurality of generators includes at least one algorithm generator and wherein the loop sequencer circuit is adapted to apply to an algorithm generator a sequential loop of algorithm instructions in a sequence of algorithm instructions each algorithm instruction of the sequence when executed by an algorithm generator causes an algorithm generator to generate a pattern of data for a pattern of test data wherein the sequential loop of algorithm instructions is nested within another loop of instructions and wherein the test pattern generator in executing memory commands at memory cells is adapted to write a pattern of test data in accordance with an algorithm instruction being executed in sequence in the loop of algorithm instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 6 the subject matter of Examples 1 20 excluding the present Example can optionally include that the plurality of generators includes at least one command generator and wherein the loop sequencer circuit is adapted to apply to a command generator a sequential loop of command instructions in a sequence of command instructions each command instruction of the sequence when executed by a command generator causes a command generator to generate a pattern of memory commands wherein the sequential loop of command instructions is nested within another loop of instructions and wherein the test pattern generator in executing memory commands at memory cells is adapted to execute a pattern of commands generated by a command instruction being executed in sequence in the loop of command instructions said pattern of commands writing a pattern of test data generated by the output of the test pattern generator in response to an algorithm instruction being executed in sequence in the loop of algorithm instructions and in response to a data instruction being executed in sequence in the loop of data instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 7 the subject matter of Examples 1 20 excluding the present Example can optionally include that the plurality of generators includes at least one address offset generator and wherein the loop sequencer is adapted to apply to an address offset generator a sequential loop of memory address offset instructions in a sequence of memory address offset instructions each memory address offset instruction of the sequence when executed by an address offset generator causes an address offset generator to generate a pattern of memory address offsets wherein the sequential loop of memory address offset instructions is nested within another loop of instructions and wherein the test pattern generator in executing memory commands at memory cells is adapted to execute a pattern of commands generated by a command instruction being executed in sequence in the loop of command instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions and offset by the pattern of memory address offsets generated by a memory address offset instruction being executed in sequence in the loop of memory address offset instructions.

In Example 8 the subject matter of Examples 1 20 excluding the present Example can optionally include that the memory cells are arranged in a plurality of memory regions and wherein the detector circuit is adapted to determine if the number of memory locations having at least one defective memory cell exceeds a maximum for a particular memory region and if so to set a flag indicating that the number of memory locations having at least one defective memory cell exceeds the maximum for the particular memory region.

In Example 9 the subject matter of Examples 1 20 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns of memory cells and each memory location of a memory region is a row of memory cells and wherein the detector circuit is adapted to determine if a particular row of memory cells of a particular memory region of memory cells has already been stored as an entry in the list of the repository and to bypass the storing in the repository the particular row of the particular memory region of memory cells as an entry of the list of memory locations if the particular row of memory cells of the particular memory region of memory cells has already been stored as an entry in the list of the repository.

In Example 10 the subject matter of Examples 1 20 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns of memory cells and each memory location of a memory region is a row of memory cells and wherein the detector circuit is adapted to set a flag for each memory region indicating whether at least one row of the particular memory region has at least one defective memory cell in the at least one row of memory cells of the particular memory region.

In Example 11 the subject matter of Examples 1 20 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns wherein each memory cell has a row address and a column address and wherein the at least one address generator is a first configurable pipeline address generator having a plurality of pipeline stages having an address carry count generator in a first pipeline stage and one of a row address generator and a column address generator in a second pipeline stage which generates one of a row address and a column address respectively as a function of the output of the address carry count generator of the first pipeline stage.

In Example 12 the subject matter of Examples 1 20 excluding the present Example can optionally include that wherein the memory regions are arranged in banks of memory regions each bank having a bank address and the banks are arranged in ranks of banks each rank having a rank address the first configurable pipeline address generator having a first configuration which includes a bank address generator in one of the first and second pipeline stages and a rank address generator in at least one of the first and second pipeline stages.

In Example 13 the subject matter of Examples 1 20 excluding the present Example can optionally include that wherein in the first configuration of the configurable pipeline address generator the row column bank and rank address generators are arranged in the first configurable pipeline address generator to generate row column bank and rank addresses respectively sequentially in a first address order defining the order in which addresses are sequentially generated by row column bank and rank and wherein the first configurable pipeline address generator is configurable in a second configuration wherein in the first configuration of the configurable pipeline address generator the row column bank and rank address generators are arranged in the first configurable pipeline address generator to generate row column bank and rank addresses respectively sequentially in a second address order in which addresses are sequentially generated by row column bank and rank in an address order different from the first address order.

In Example 14 the subject matter of Examples 1 20 excluding the present Example can optionally include that in the first address order the configurable pipeline address generator is adapted to sequentially increment bank addresses to the next bank address in sequence before a rank address is incremented to the next rank address in sequence and wherein in the second address order the configurable pipeline address generator is adapted to sequentially increment rank addresses to the next rank address in sequence before a bank address is incremented to the next bank address in sequence.

In Example 15 the subject matter of Examples 1 20 excluding the present Example can optionally include that in the first address order the configurable pipeline address generator is adapted to sequentially increment row addresses to the next row address in sequence before a column address is incremented to the next column address in sequence and wherein in the second address order the configurable pipeline address generator is adapted to sequentially increment column addresses to the next column address in sequence before a row address is incremented to the next row address in sequence.

In Example 16 the subject matter of Examples 1 20 excluding the present Example can optionally include that the pipeline address generator is adapted to be responsive to a clock signal and to produce the next full address including rank bank column and row addresses every clock signal after an initial startup period and wherein the output of the address carry count generator of the first pipeline stage is valid in each clock signal after the initial startup period and the next full address is valid in each clock signal after the initial startup period.

In Example 17 the subject matter of Examples 1 20 excluding the present Example can optionally include that the at least one algorithm generator includes a refresh signal generator adapted to generate a refresh signal for the memory cells having a variable refresh rate.

In Example 18 the subject matter of Examples 1 20 excluding the present Example can optionally include that the refresh signal generator is adapted to generate refresh signals in a declining sequence of refresh rates for refreshing memory cells at each rate of the declining sequence of refresh rates each refresh rate of the declining sequence being reduced by an amount from the rate of the prior refresh rate of the declining sequence of refresh rates.

In Example 19 the subject matter of Examples 1 20 excluding the present Example can optionally include that the at least one algorithm generator includes at least one pattern sequencer each having an output a multiplexer having a plurality of inputs and outputs and at least one selector input coupled to an output of at least one pattern sequencer wherein the multiplexer is adapted to select a multiplexer input to output to a multiplexer output in response to at least one pattern sequencer coupled to at least one multiplexer selector input.

In Example 20 the subject matter of Examples 1 20 excluding the present Example can optionally include that at least one pattern sequencer is a multi mode pattern sequencer having a shift register comprising a plurality of bit registers a finite state machine comprising linear feedback polynomial logic coupled to the bit registers of the shift register and combinational logic including a plurality of counters and a plurality of modes of operation including a fixed pattern mode in which the shift register is adapted to shift a fixed pattern to the pattern sequencer output a clock signal pattern mode in which the pattern sequencer is adapted to output a clock signal to the pattern sequencer output the clock signal having a programmable duty cycle in which the length of a clock pulse within the clock period is programmable in which a first counter of the combinational logic is adapted to time the delay of initiation of the clock pulse of the clock signal within the clock period a second counter of the combinational logic is adapted to time the duration of the clock pulse and a third counter is adapted to time the duration of the remaining period of the clock signal after the clock pulse until the beginning of the next clock signal and a linear feedback mode in which the pattern sequencer is adapted to output a linear feedback polynomial pattern to the pattern sequencer output in which the linear feedback polynomial logic is adapted to determine the next state of the finite state machine of the multi mode pattern sequencer.

an internal self test logic circuit built in within the device the self test logic circuit including 

a test pattern generator for generating test patterns and for testing memory cells within the device using the generated test patterns 

a detector circuit adapted to detect defective memory cells in response to the test patterns testing the memory cells and to store in the repository within the device a list of memory locations each memory location of the list having a set of memory cells which includes at least one defective memory cell and

an internal self repair logic circuit built in within the device the internal self repair logic including a repair logic circuit adapted to read the list of memory locations stored in the repository and to repair the memory locations of the list by substituting a memory location of spare memory cells for a memory location having at least one defective memory cell.

In Example 22 the subject matter of Examples 21 40 excluding the present Example can optionally include that the device further comprises a memory controller disposed on a semiconductor die within the device for controlling the memory cells of the device and wherein the internal self test logic circuit and the internal self repair logic circuit are disposed on the die of the memory controller.

In Example 23 the subject matter of Examples 21 40 excluding the present Example can optionally include that the test pattern generator includes a plurality of generators including at least one address generator and a loop sequencer circuit adapted to apply to the generators a plurality of nested loop instructions including a sequential loop of address instructions in a sequence of address instructions to an address generator each address instruction of the sequence when executed by an address generator causes an address generator to generate a pattern of memory cell addresses and wherein the test pattern generator is adapted to execute memory commands at memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 24 the subject matter of Examples 21 40 excluding the present Example can optionally include that the plurality of generators includes at least one data generator and wherein the loop sequencer circuit is adapted to apply to a data generator a sequential loop of data instructions in a sequence of data instructions each data instruction of the sequence when executed by a data generator causes a data generator to generate a pattern of data for a pattern of test data wherein the sequential loop of data instructions is nested within another loop of instructions and wherein the test pattern generator in executing memory commands at memory cells is adapted to write a pattern of test data generated by a data instruction being executed in sequence in the loop of data instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 25 the subject matter of 21 40 excluding the present Example can optionally include that the plurality of generators includes at least one algorithm generator and wherein the loop sequencer circuit is adapted to apply to an algorithm generator a sequential loop of algorithm instructions in a sequence of algorithm instructions each algorithm instruction of the sequence when executed by an algorithm generator causes an algorithm generator to generate a pattern of data for a pattern of test data wherein the sequential loop of algorithm instructions is nested within another loop of instructions and wherein the test pattern generator in executing memory commands at memory cells is adapted to write a pattern of test data in accordance with an algorithm instruction being executed in sequence in the loop of algorithm instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 26 the subject matter of 21 40 excluding the present Example can optionally include that the plurality of generators includes at least one command generator and wherein the loop sequencer circuit is adapted to apply to a command generator a sequential loop of command instructions in a sequence of command instructions each command instruction of the sequence when executed by a command generator causes a command generator to generate a pattern of memory commands wherein the sequential loop of command instructions is nested within another loop of instructions and wherein the test pattern generator in executing memory commands at memory cells is adapted to execute a pattern of commands generated by a command instruction being executed in sequence in the loop of command instructions said pattern of commands writing a pattern of test data generated by the output of the test pattern generator in response to an algorithm instruction being executed in sequence in the loop of algorithm instructions and in response to a data instruction being executed in sequence in the loop of data instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 27 the subject matter of Examples 21 40 excluding the present Example can optionally include that the plurality of generators includes at least one address offset generator and wherein the loop sequencer is adapted to apply to an address offset generator a sequential loop of memory address offset instructions in a sequence of memory address offset instructions each memory address offset instruction of the sequence when executed by an address offset generator causes an address offset generator to generate a pattern of memory address offsets wherein the sequential loop of memory address offset instructions is nested within another loop of instructions and wherein the test pattern generator in executing memory commands at memory cells is adapted to execute a pattern of commands generated by a command instruction being executed in sequence in the loop of command instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions and offset by the pattern of memory address offsets generated by a memory address offset instruction being executed in sequence in the loop of memory address offset instructions.

In Example 28 the subject matter of Examples 21 40 excluding the present Example can optionally include that the memory cells are arranged in a plurality of memory regions and wherein the detector circuit is adapted to determine if the number of memory locations having at least one defective memory cell exceeds a maximum for a particular memory region and if so to set a flag indicating that the number of memory locations having at least one defective memory cell exceeds the maximum for the particular memory region.

In Example 29 the subject matter of Examples 21 40 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns of memory cells and each memory location of a memory region is a row of memory cells and wherein the detector circuit is adapted to determine if a particular row of memory cells of a particular memory region of memory cells has already been stored as an entry in the list of the repository and to bypass the storing in the repository the particular row of the particular memory region of memory cells as an entry of the list of memory locations if the particular row of memory cells of the particular memory region of memory cells has already been stored as an entry in the list of the repository.

In Example 30 the subject matter of Examples 21 40 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns of memory cells and each memory location of a memory region is a row of memory cells and wherein the detector circuit is adapted to set a flag for each memory region indicating whether at least one row of the particular memory region has at least one defective memory cell in the at least one row of memory cells of the particular memory region.

In Example 31 the subject matter of Examples 21 40 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns wherein each memory cell has a row address and a column address and wherein the at least one address generator is a first configurable pipeline address generator having a plurality of pipeline stages having an address carry count generator in a first pipeline stage and one of a row address generator and a column address generator in a second pipeline stage which generates one of a row address and a column address respectively as a function of the output of the address carry count generator of the first pipeline stage.

In Example 32 the subject matter of Examples 21 40 excluding the present Example can optionally include that the memory regions are arranged in banks of memory regions each bank having a bank address and the banks are arranged in ranks of banks each rank having a rank address the first configurable pipeline address generator having a first configuration which includes a bank address generator in one of the first and second pipeline stages and a rank address generator in at least one of the first and second pipeline stages.

In Example 33 the subject matter of Examples 21 40 excluding the present Example can optionally include that in the first configuration of the configurable pipeline address generator the row column bank and rank address generators are arranged in the first configurable pipeline address generator to generate row column bank and rank addresses respectively sequentially in a first address order defining the order in which addresses are sequentially generated by row column bank and rank and wherein the first configurable pipeline address generator is configurable in a second configuration wherein in the first configuration of the configurable pipeline address generator the row column bank and rank address generators are arranged in the first configurable pipeline address generator to generate row column bank and rank addresses respectively sequentially in a second address order in which addresses are sequentially generated by row column bank and rank in an address order different from the first address order.

In Example 34 the subject matter of Examples 21 40 excluding the present Example can optionally include that in the first address order the configurable pipeline address generator is adapted to sequentially increment bank addresses to the next bank address in sequence before a rank address is incremented to the next rank address in sequence and wherein in the second address order the configurable pipeline address generator is adapted to sequentially increment rank addresses to the next rank address in sequence before a bank address is incremented to the next bank address in sequence.

In Example 35 the subject matter of Examples 21 40 excluding the present Example can optionally include that in the first address order the configurable pipeline address generator is adapted to sequentially increment row addresses to the next row address in sequence before a column address is incremented to the next column address in sequence and wherein in the second address order the configurable pipeline address generator is adapted to sequentially increment column addresses to the next column address in sequence before a row address is incremented to the next row address in sequence.

In Example 36 the subject matter of Examples 21 40 excluding the present Example can optionally include that the pipeline address generator is adapted to be responsive to a clock signal and to produce the next full address including rank bank column and row addresses every clock signal after an initial startup period and wherein the output of the address carry count generator of the first pipeline stage is valid in each clock signal after the initial startup period and the next full address is valid in each clock signal after the initial startup period.

In Example 37 the subject matter of Examples 21 40 excluding the present Example can optionally include that the at least one algorithm generator includes a refresh signal generator adapted to generate a refresh signal for the memory cells having a variable refresh rate.

In Example 38 the subject matter of Examples 21 40 excluding the present Example can optionally include that the refresh signal generator is adapted to generate refresh signals in a declining sequence of refresh rates for refreshing memory cells at each rate of the declining sequence of refresh rates each refresh rate of the declining sequence being reduced by an amount from the rate of the prior refresh rate of the declining sequence of refresh rates.

In Example 39 the subject matter of Examples 21 40 excluding the present Example can optionally include that the at least one algorithm generator includes at least one pattern sequencer each having an output a multiplexer having a plurality of inputs and outputs and at least one selector input coupled to an output of at least one pattern sequencer wherein the multiplexer is adapted to select a multiplexer input to output to a multiplexer output in response to at least one pattern sequencer coupled to at least one multiplexer selector input.

In Example 40 the subject matter of Examples 21 40 excluding the present Example can optionally include that at least one pattern sequencer is a multi mode pattern sequencer having a shift register comprising a plurality of bit registers a finite state machine comprising linear feedback polynomial logic coupled to the bit registers of the shift register and combinational logic including a plurality of counters and a plurality of modes of operation including a fixed pattern mode in which the shift register is adapted to shift a fixed pattern to the pattern sequencer output a clock signal pattern mode in which the pattern sequencer is adapted to output a clock signal to the pattern sequencer output the clock signal having a programmable duty cycle in which the length of a clock pulse within the clock period is programmable in which a first counter of the combinational logic is adapted to time the delay of initiation of the clock pulse of the clock signal within the clock period a second counter of the combinational logic is adapted to time the duration of the clock pulse and a third counter is adapted to time the duration of the remaining period of the clock signal after the clock pulse until the beginning of the next clock signal and a linear feedback mode in which the pattern sequencer is adapted to output a linear feedback polynomial pattern to the pattern sequencer output in which the linear feedback polynomial logic is adapted to determine the next state of the finite state machine of the multi mode pattern sequencer.

storing in a repository within the device a list of memory locations each memory location of the list having a set of memory cells which includes at least one defective memory cell and

repairing the memory locations wherein the repairing includes substituting a spare memory location having a set of memory cells for a memory location having at least one defective memory cell.

In Example 42 the subject matter of Examples 41 60 excluding the present Example can optionally include that the device further comprises a memory controller disposed on a semiconductor die within the device for controlling the memory cells of the device and wherein the internal self test logic circuit and the internal self repair logic circuit are disposed on the die of the memory controller.

In Example 43 the subject matter of Examples 41 60 excluding the present Example can optionally include that the applying the test patterns includes executing a sequential loop of address instructions in a sequence of address instructions each address instruction of the sequence when executed generating a pattern of memory cell addresses and executing memory commands at memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 44 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating test patterns includes executing a sequential loop of data instructions in a sequence of data instructions each data instruction of the sequence when executed generating a pattern of data for a pattern of test data wherein the sequential loop of data instructions is nested within another loop of instructions and wherein the executing memory commands at memory cells includes writing test data generated by a data instruction being executed in sequence in the loop of data instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 45 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating test patterns includes executing a sequential loop of algorithm instructions in a sequence of algorithm instructions each algorithm instruction of the sequence when executed generating a pattern of data for a pattern of test data wherein the sequential loop of algorithm instructions is nested within another loop of instructions and wherein the executing memory commands at memory cells includes writing a pattern of test data in accordance with an algorithm instruction being executed in sequence in the loop of algorithm instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 46 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating test patterns includes executing a sequential loop of command instructions in a sequence of command instructions each command instruction of the sequence when executed generating a pattern of memory commands wherein the sequential loop of command instructions is nested within another loop of instructions and wherein the executing memory commands at memory cells includes executing a pattern of commands generated by a command instruction being executed in sequence in the loop of command instructions said pattern of commands writing a pattern of test data generated by the output of an algorithm of an algorithm instruction being executed in sequence in the loop of algorithm instructions and in response to a data instruction being executed in sequence in the loop of data instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions.

In Example 47 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating test patterns includes executing a sequential loop of memory address offset instructions in a sequence of memory address offset instructions each memory address offset instruction of the sequence when executed generating a pattern of memory address offsets wherein the sequential loop of memory address offset instructions is nested within another loop of instructions and wherein the executing memory commands at memory cells includes executing a pattern of commands generated by a command instruction being executed in sequence in the loop of command instructions in memory cells addressed by a pattern of memory cell addresses generated by an address instruction being executed in sequence in the loop of address instructions and offset by the pattern of memory address offsets generated by a memory address offset instruction being executed in sequence in the loop of memory address offset instructions.

In Example 48 the subject matter of Examples 41 60 excluding the present Example can optionally include that the memory cells are arranged in a plurality of memory regions the method further comprising determining if the number of memory locations having at least one defective memory cell exceeds a maximum for a particular memory region and if so setting a flag indicating that the number of memory locations having at least one defective memory cell exceeds the maximum for the particular memory region.

In Example 49 the subject matter of Examples 41 60 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns of memory cells and each memory location of a memory region is a row of memory cells the method further comprising determining if a particular row of memory cells of a particular memory region of memory cells has already been stored as an entry in the list of the repository and bypassing the storing in the repository the particular row of the particular memory region of memory cells as an entry of the list of memory locations if the particular row of memory cells of the particular memory region of memory cells has already been stored as an entry in the list of the repository.

In Example 50 the subject matter of Examples 41 60 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns of memory cells and each memory location of a memory region is a row of memory cells the method further comprising setting a flag for each memory region indicating whether at least one row of the particular memory region has at least one defective memory cell in the at least one row of memory cells of the particular memory region.

In Example 51 the subject matter of Examples 41 60 excluding the present Example can optionally include that the memory cells are arranged in memory regions of memory cells each memory region comprising an array of memory cells arranged in rows and columns wherein each memory cell has a row address and a column address and wherein the generating a pattern of memory cell addresses includes generating in a first configurable pipeline address generator having a plurality of pipeline stages an address carry count in a first pipeline stage and generating in a second pipeline stage one of a row address and a column address as a function of the address carry count generated in the first pipeline stage.

In Example 52 the subject matter of Examples 41 60 excluding the present Example can optionally include that the memory regions are arranged in banks of memory regions each bank having a bank address and the banks are arranged in ranks of banks each rank having a rank address the method further comprising generating in one of the first and second pipeline stages in a first configuration of the first configurable pipeline address generator a bank address and generating in one of the first and second pipeline stages in the first configuration of the first configurable pipeline address generator a rank address.

In Example 53 the subject matter of Examples 41 60 excluding the present Example can optionally include generating in the first configurable pipeline address generator the row column bank and rank addresses sequentially in a first address order defining the order in which addresses are sequentially generated by row column bank and rank and generating in a second pipeline address generator row column bank and rank addresses sequentially in a second address order in which addresses are sequentially generated by row column bank and rank an address order different from the first address order.

In Example 54 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating the row column bank and rank addresses sequentially in the first address order includes sequentially incrementing bank addresses to the next bank address in sequence of the device before a rank address is incremented to the next rank address of the device in sequence and wherein the generating the row column bank and rank addresses sequentially in the second address order includes sequentially incrementing rank addresses to the next rank address in sequence of the device before a bank address is incremented to the next bank address of the device in sequence.

In Example 55 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating the row column bank and rank addresses sequentially in the first address order includes sequentially incrementing row addresses to the next row address in sequence of the device before a column address is incremented to the next column address of the device in sequence and wherein the generating the row column bank and rank addresses sequentially in the second address order includes sequentially incrementing column addresses the next r column address of the device in sequence before a row address is incremented to the next row address of the device in sequence.

In Example 56 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating the row column bank and rank addresses includes clocking the pipeline address generator with a clock signal and producing the next full address including rank bank column and row addresses every clock signal after an initial startup period and producing a valid address carry count output in each clock signal after the initial startup period and producing a valid next full address in a subsequent part of each clock signal after the initial startup period.

In Example 57 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating a test data pattern as an output of an algorithm includes generating a refresh signal having a variable refresh rate and refreshing memory cells at the variable refresh rate.

In Example 58 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating a refresh signal having a variable refresh rate includes generating the refresh signals in a declining sequence of refresh rates each refresh rate of the declining sequence being reduced by an amount from the rate of the prior refresh rate of the declining sequence of refresh rates and wherein the refreshing memory cells at the variable refresh rate includes refreshing memory cells at each rate of the declining sequence of refresh rates.

In Example 59 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating a test data pattern as an output of an algorithm includes generating a patterned sequence of multiplexer input selection signals selecting inputs of a multiplexer in response to the patterned sequence of multiplexer input selection signals and outputting a test pattern from the multiplexer in response to the multiplexer input selecting.

In Example 60 the subject matter of Examples 41 60 excluding the present Example can optionally include that the generating a patterned sequence of multiplexer input selection signals includes 

selecting a mode of a multi mode pattern sequencer having a shift register comprising a plurality of bit registers a finite state machine comprising linear feedback polynomial logic coupled to the bit registers of the shift register combinational logic including a plurality of counters and a plurality of modes of operation including a fixed pattern mode a clock signal pattern mode and a and a linear feedback mode 

operating the multi mode pattern sequencer in the fixed pattern mode includes the shift register shifting a fixed pattern to the pattern sequencer output 

operating the multi mode pattern sequencer in the clock signal pattern mode includes generating a clock signal at the pattern sequencer output the clock signal having a programmable duty cycle in which the length of a clock pulse within the clock period is programmable the clock signal generating including timing the delay of initiation of the clock pulse of the clock signal within the clock period using a first counter of the combinational logic timing the duration of the clock pulse using a second counter of the combinational logic and the duration of the remaining period of the clock signal after the clock pulse until the beginning of the next clock signal timing using a third counter of the combinational logic and

operating the multi mode pattern sequencer in the linear feedback mode includes generating a linear feedback polynomial pattern at the pattern sequencer output the generating a linear feedback polynomial pattern including the linear feedback polynomial logic determining the next state of the finite state machine of the multi mode pattern sequencer.

Example 61 is a memory controller for use with a memory having memory cells including spare memory cells comprising 

an internal self test logic circuit built in within the memory controller the self test logic circuit including a test pattern generator for generating test patterns and for testing memory cells within the memory using the generated test patterns wherein the test pattern generator includes a plurality of generators including at least one address generator configured to generate a pattern of memory cell addresses in response to an address instruction to traverse a memory region of a plurality of memory cells and at least one data generator configured to generate in response to a data instruction a pattern of data for a pattern of test data to be written in memory cells addressed by a pattern of memory cell addresses generated by the address generator wherein the generated pattern of data is a selectable function of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 62 the subject matter of Examples 61 75 excluding the present Example can optionally include that the data generator is configured to invert data in a selectable striped pattern as a function of one of the row address and the column address of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 63 the subject matter of Examples 61 75 excluding the present Example can optionally include that the data generator is configured to invert data in a selectable checkerboard pattern as a function of the Exclusive OR function of the lowest order row address bit and lowest order column address bit of the row and column addresses respectively of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 64 the subject matter of Examples 61 75 excluding the present Example can optionally include that the data generator is configured to generate a selectable pattern of data which is all logical ones for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 65 the subject matter of Examples 61 75 excluding the present Example can optionally include that the data generator is configured to selectively invert the pattern of data for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 66 the subject matter of Examples 61 75 excluding the present Example can optionally include that the data generator is configured to selectively rotate the generated pattern of data by a bit position for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 67 the subject matter of Examples 61 75 excluding the present Example can optionally include that the data generator is configured to selectively repeat the rotation of a generated pattern of data a bit position a selectable number of times for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 68 the subject matter of Examples 61 75 excluding the present Example can optionally include that the plurality of generators includes at least one address offset generator configured to generate a periodic pattern of memory address offsets as a function of a period and the data generator is configured to provide a selectable periodic data inversion function to selectively invert the pattern of data in a selectable periodic data inversion pattern.

In Example 69 the subject matter of Examples 61 75 excluding the present Example can optionally include that the data generator is configured to selectively invert the pattern of data in a stripe pattern as a function of the periodic pattern of memory address offsets generated by the address offset generator wherein the stripe pattern is one of a column stripe a row stripe and a diagonal stripe.

In Example 70 the subject matter of Examples 61 75 excluding the present Example can optionally include that the period of the periodic pattern of memory address offsets is a function of one of the number of rows and the number of columns of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 71 the subject matter of Examples 61 75 excluding the present Example can optionally include that the period of the periodic pattern of memory address offsets is a function of an initial period and an adjustment to the initial period.

In Example 72 the subject matter of Examples 61 75 excluding the present Example can optionally include that the initial period is a function of the direction of traversal of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 73 the subject matter of Examples 61 75 excluding the present Example can optionally include that the initial period is set to one of the number of rows and the number of columns of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 74 the subject matter of Examples 61 75 excluding the present Example can optionally include a plurality of data generators chained in a plurality of stages each data generator configured to generate a pattern of data as a function of memory addresses.

In Example 75 the subject matter of Examples 61 75 excluding the present Example can optionally include a plurality of registers adapted to store mapping values and a logical to physical address mapping logic configured to map logical addresses to physical addresses as a function of the mapping values stored in the registers.

an internal self test logic circuit built in within the device the self test logic circuit including a test pattern generator for generating test patterns and for testing memory cells within the memory for defective memory cells using the generated test patterns wherein the test pattern generator includes a plurality of generators including at least one address generator configured to generate in response to an address instruction a pattern of memory cell addresses to traverse a memory region of a plurality of memory cells and at least one data generator configured to generate in response to a data instruction a pattern of data for a pattern of test data to be written in memory cells addressed by a pattern of memory cell addresses generated by the address generator wherein the generated pattern of data is a selectable function of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written and

an internal self repair logic circuit built in within the device the internal self repair logic including a repair logic circuit responsive to the internal self test logic circuit and configured to repair a defective memory location by substituting a memory location of a spare memory cell for a memory location having at least one defective memory cell.

In Example 77 the subject matter of Examples 76 90 excluding the present Example can optionally include that the data generator is configured to invert data in a selectable striped pattern as a function of one of the row address and the column address of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 78 the subject matter of Examples 76 90 excluding the present Example can optionally include that the data generator is configured to invert data in a selectable checkerboard pattern as a function of the Exclusive OR function of the lowest order row address bit and lowest order column address bit of the row and column addresses respectively of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 79 the subject matter of Examples 76 90 excluding the present Example can optionally include that the data generator is configured to generate a selectable pattern of data which is all logical ones for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 80 the subject matter of Examples 76 90 excluding the present Example can optionally include that the data generator is configured to selectively invert the pattern of data for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 81 the subject matter of Examples 76 90 excluding the present Example can optionally include that the data generator is configured to selectively rotate the generated pattern of data by a bit position for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 82 the subject matter of Examples 76 90 excluding the present Example can optionally include that the data generator is configured to selectively repeat the rotation of a generated pattern of data a bit position a selectable number of times for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 83 the subject matter of Examples 76 90 excluding the present Example can optionally include that the plurality of generators includes at least one address offset generator configured to generate a periodic pattern of memory address offsets as a function of a period and the data generator is configured to provide a selectable periodic data inversion function to selectively invert the pattern of data in a selectable periodic data inversion pattern.

In Example 84 the subject matter of Examples 76 90 excluding the present Example can optionally include that the data generator is configured to selectively invert the pattern of data in a stripe pattern as a function of the periodic pattern of memory address offsets generated by the address offset generator wherein the stripe pattern is one of a column stripe a row stripe and a diagonal stripe.

In Example 85 the subject matter of Examples 76 90 excluding the present Example can optionally include that the period of the periodic pattern of memory address offsets is a function of one of the number of rows and the number of columns of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 86 the subject matter of Examples 76 90 excluding the present Example can optionally include that the period of the periodic pattern of memory address offsets is a function of an initial period and an adjustment to the initial period.

In Example 87 the subject matter of Examples 76 90 excluding the present Example can optionally include that the initial period is a function of the direction of traversal of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 88 the subject matter of Examples 76 90 excluding the present Example can optionally include that the initial period is set to one of the number of rows and the number of columns of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 89 the subject matter of Examples 76 90 excluding the present Example can optionally include a plurality of data generators chained in a plurality of stages each data generator configured to generate a pattern of data as a function of memory addresses.

In Example 90 the subject matter of Examples 76 90 excluding the present Example can optionally include a plurality of registers adapted to store mapping values and a logical to physical address mapping logic configured to map logical addresses to physical addresses as a function of the mapping values stored in the registers.

wherein the test pattern generating includes generating in response to an address instruction a pattern of memory cell addresses to traverse a memory region of a plurality of memory cells and generating in response to a data instruction a pattern of data for a pattern of test data to be written in memory cells addressed by the generated pattern of memory cell addresses and wherein the generating a pattern of data includes selecting a pattern of data and generating the selected pattern of data as a selectable function of the generated pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written and

using an internal self repair logic circuit built in within the device repairing in responsive to the internal self test logic circuit a defective memory location by substituting a memory location of a spare memory cell for a memory location having at least one defective memory cell.

In Example 92 the subject matter of Examples 91 105 excluding the present Example can optionally include that the generating the selected pattern of data as a selectable function of the generated pattern of memory cell addresses includes inverting data in a selectable striped pattern as a function of one of the row address and the column address of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 93 the subject matter of Examples 91 105 excluding the present Example can optionally include that the generating the selected pattern of data as a selectable function of the generated pattern of memory cell addresses includes inverting data in a selectable checkerboard pattern as a function of the Exclusive OR function of the lowest order row address bit and lowest order column address bit of the row and column addresses respectively of the pattern of memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 94 the subject matter of Examples 91 105 excluding the present Example can optionally include that the generating a pattern of data includes generating a selectable pattern of data which is all logical ones for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 95 the subject matter of Examples 91 105 excluding the present Example can optionally include that the generating a pattern of data includes selectively inverting the pattern of data for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 96 the subject matter of Examples 91 105 excluding the present Example can optionally include that the generating a pattern of data includes selectively rotating the generated pattern of data by a bit position for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 97 the subject matter of Examples 91 105 excluding the present Example can optionally include that the rotating the generated pattern of data includes selectively repeating the rotation of a generated pattern of data a bit position a selectable number of times for all memory cell addresses of the memory cells in which the generated pattern of data is to be written.

In Example 98 the subject matter of Examples 91 105 excluding the present Example can optionally include that the generating a pattern of memory cell addresses includes generating a periodic pattern of memory address offsets as a function of a period and wherein the generating the selected pattern of data as a selectable function of the generated pattern of memory cell addresses includes providing a selectable periodic data inversion function to selectively invert the pattern of data in a selectable periodic data inversion pattern.

In Example 99 the subject matter of Examples 91 105 excluding the present Example can optionally include that the generating the selected pattern of data as a selectable function of the generated pattern of memory cell addresses includes selectively inverting the pattern of data in a stripe pattern as a function of the generated periodic pattern of memory address offsets wherein the stripe pattern is one of a column stripe a row stripe and a diagonal stripe.

In Example 100 the subject matter of Examples 91 105 excluding the present Example can optionally include that the period of the periodic pattern of memory address offsets is a function of one of the number of rows and the number of columns of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 101 the subject matter of Examples 91 105 excluding the present Example can optionally include that the period of the periodic pattern of memory address offsets is a function of an initial period and an adjustment to the initial period.

In Example 102 the subject matter of Examples 91 105 excluding the present Example can optionally include that the initial period is a function of the direction of traversal of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 103 the subject matter of Examples 91 105 excluding the present Example can optionally include that the initial period is set to one of the number of rows and the number of columns of the memory cells addressed by the pattern of memory cell addresses generated by an address instruction.

In Example 104 the subject matter of Examples 91 105 excluding the present Example can optionally include that the generating the selected pattern of data as a selectable function of the generated pattern of memory cell addresses includes generating selected patterns of data in a plurality of stages each pattern of data of each stage being a function of memory addresses.

In Example 105 the subject matter of Examples 91 105 excluding the present Example can optionally include mapping logical addresses to physical addresses as a function of mapping values stored in registers.

Example 106 is directed to an apparatus comprising means to perform a method as described in any preceding Example.

The described operations may be implemented as a method apparatus or computer program product using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof. The described operations may be implemented as computer program code maintained in a computer readable storage medium where a processor may read and execute the code from the computer storage readable medium. The computer readable storage medium includes at least one of electronic circuitry storage materials inorganic materials organic materials biological materials a casing a housing a coating and hardware. A computer readable storage medium may comprise but is not limited to a magnetic storage medium e.g. hard disk drives floppy disks tape etc. optical storage CD ROMs DVDs optical disks etc. volatile and non volatile memory devices e.g. EEPROMs ROMs PROMs RAMs DRAMs SRAMs Flash Memory firmware programmable logic etc. Solid State Devices SSD etc. The code implementing the described operations may further be implemented in hardware logic implemented in a hardware device e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc. . Still further the code implementing the described operations may be implemented in transmission signals where transmission signals may propagate through space or through a transmission media such as an optical fiber copper wire etc. The transmission signals in which the code or logic is encoded may further comprise a wireless signal satellite transmission radio waves infrared signals Bluetooth etc. The program code embedded on a computer readable storage medium may be transmitted as transmission signals from a transmitting station or computer to a receiving station or computer. A computer readable storage medium is not comprised solely of transmissions signals. Those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present description and that the article of manufacture may comprise suitable information bearing medium known in the art. Of course those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present description and that the article of manufacture may comprise any tangible information bearing medium known in the art.

In certain applications a device in accordance with the present description may be embodied in a computer system including a video controller to render information to display on a monitor or other display coupled to the computer system a device driver and a network controller such as a computer system comprising a desktop workstation server mainframe laptop handheld computer etc. Alternatively the device embodiments may be embodied in a computing device that does not include for example a video controller such as a switch router etc. or does not include a network controller for example.

The illustrated logic of figures may show certain events occurring in a certain order. In alternative embodiments certain operations may be performed in a different order modified or removed. Moreover operations may be added to the above described logic and still conform to the described embodiments. Further operations described herein may occur sequentially or certain operations may be processed in parallel. Yet further operations may be performed by a single processing unit or by distributed processing units.

The foregoing description of various embodiments has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit to the precise form disclosed. Many modifications and variations are possible in light of the above teaching.

