---

title: Operating system and architecture for embedded system
abstract: An operating system for an aircraft according to an exemplary aspect of the present disclosure includes, among other things, a core services layer and a hardware interface layer that is time and space partitioned from the core services layer. The hardware interface layer is operable to control communications with hardware in a computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09075671&OS=09075671&RS=09075671
owner: Hamilton Sundstrand Corporation
number: 09075671
owner_city: Windsor Locks
owner_country: US
publication_date: 20140610
---
The present invention relates generally to operating systems and architecture and more particularly to an operating system and run time architecture for safety critical systems.

Aircraft systems are subject to functionality restrictions and the verification requirements specified in the RTCA DO 178B DO 178B Standard Software Considerations in Airborne Systems and Equipment Certification. The Federal Aviation Authority in conjunction with its world wide counterparts recognizes and enforces adherence to this standard. In the RTCA DO 178B standard there are three concepts of interest defined the first being Levels of software criticality the second concept being protection and the third which is closely related to the second is the concept of partitioning.

Software levels of criticality as defined in the DO 178B standard are defined as five differing levels e.g. Levels A B C D E where Level A represents software of the highest criticality and Level E the lowest in terms of the software s function in controlling safety critical function on the aircraft. Thus the standard provides a method to classify high criticality functions and tasks from lower level criticality functions and tasks. Safety critical standards from other industries may define this concept similarly.

The DO 178B standard defines partitioning as the separation of software levels of criticality in both time and space running on a single CPU. Thus a partitioned design provides both Time Partitioning and Space Partitioning. Time Partitioning is the ability to separate the execution of one task from another task such that a failure in one task will not impede the execution of the other. Space Partitioning is defined as the separation of execution space for two partitions such that one partition cannot corrupt the other partition s memory space or access a critical resource. The DO 178B standard defines protection as the protection of one partition from another partition such that a violation of either time or space in a partition has no effect on any other partition in the system.

Many existing task analysis and scheduling techniques exist in real time preemptive operating systems today. One method of interest is Deadline Monotonic Analysis DMA and Scheduling DMS reference Embedded Systems Programming see Deadline Monotonic Analysis by Ken Tindell June 2000 pp. 20 38 . Deadline Monotonic Analysis DMA is a method of predicting system schedule ability where the system is a CPU with multiple tasks that are to be executed concurrently. DMA requires that the analyst have the following basic information for every task to be scheduled in the system 1 Task period the task cycle or rate of execution. 2 Task Deadline the time that the task must complete execution by as measured from the start of a task period. 3 The task s worst case execution time WCET the worst case execution path of the task in terms of instructions converted to time. Armed with this basic information the analyst can use the DMA mathematics or formulas to predict if the system can be scheduled i.e. whether all tasks will be able to meet their deadlines in every period under worst case execution scenarios. If the system can be scheduled then the system can be executed using a runtime dynamic compliant Deadline Monotonic Scheduler DMS .

Existing Deadline Monotonic Schedulers use a dynamic method for determining individual task execution at runtime. At each timing interval an evaluation is made at run time to determine whether the currently executing task is to be preempted by a higher priority task or whether a new task is due to be started on an idle system. This dynamic method achieves the goals of schedule ability but does introduce an element of variability since the individual preemption instances and task initiation times may vary over successive passes through the schedule. For example in an existing Deadline Monotonic Scheduler individual task execution may be slid to an earlier execution time if the preceding task finishes early or aborts. Also the number and placement of preemptions that take place are similarly affected and so individual tasks may vary anywhere within the bounds defined by their DMS parameters.

Even though the amount of variability in existing Deadline Monotonic Schedulers is limited to the schedule parameters it is nevertheless undesirable for certain applications where a higher degree of predictability and repeatability is desired for example DO 178B avionics and other safety critical applications.

In a partitioned design tasks inside of one partition communicate data via Application Programming Interfaces APIs or APplication EXecutive or APEX as they are called in ARINC 653 compliant designs. The RTCA DO 178B standard concept of protection requires that partitions be protected from each other such that a violation of either time or space in partition has no effect on any other partition in the system. This concept of protection applies to the APIs or APEX interfaces as well.

In ARINC 653 compliant designs partitions are given access to the APEX interface during the partition s window of execution. During this window a partition can request or send data to any resource available in the system via calls to the appropriate APEX interface.

In the case of the ARINC 653 compliant designs all partitions have access to all of the APEX interfaces to request or send information. Thus the standard has no concept for restricted use or protected services or restricted interfaces. Thus it is possible for one partition to overload or corrupt any APEX interface or associated service such that the service is not available during the next partitions window of execution. This limitation does not support the protection criteria required by DO 178B in partitioned designs.

Many safety critical industries like aviation provide regulatory guidelines for the development of embedded safety critical software. Adherence to safety critical software design standards involves creation of design and verification artifacts that must support and prove the pedigree of the software code in its particular application and assessed software criticality level.

Adherence to these safety critical standards typically means that designers will spend less than 20 of their time producing the actual code and greater than 80 producing the required supporting artifacts and in some cases the time spent producing the code can enter the single digits.

While adherence to these standards is meant to produce error free embedded software products the cost associated with the production of these products is high. As a result the producers seek as much reuse as possible. Due to the critical nature of these products in the industries that they serve the safety critical standards also provide guidance for reuse.

The reuse guides typically state that a software configuration item can be reused without additional effort if it has not changed implying that its artifacts have not changed in addition to the code.

Today only one standard exists for a partitioned software design in the safety critical world of avionics. That standard is the ARINC 653 standard. The ARINC 653 standard supports application partitions that could be reused across multiple applications. Since the standard provides a common APEX or user interface to the Operating System functions it is possible to write an application that utilizes the specified APEX interface. If an application can be written using the standards specified for APEX interface calls only then if properly developed the applications artifacts and code would not change from product to product.

One of the flaws with the ARINC 653 approach is that the underlying system hardware like on aircraft avionics communications protocols and or other product or system hardware devices can and will change from program to program or aircraft to aircraft . In addition most aircraft OEM s change aircraft specifications from aircraft to aircraft which puts application software reuse at risk.

In summary existing safety critical operating systems contain many noticeable drawbacks among these are the following 

1 They do not ensure that the individual tasks grouped within a partition will be individually time partitioned.

2 They do not provide the flexibility to space partition multiple tasks of the same criticality either individually or in subgroups.

3 The architecture requires the operating system to provide all Application Programming Interfaces API s or APEX s in the case of ARINC 653 to all partitions.

4 Access to system hardware or CPU resources is provided by the operating system via the API or APEX in the case of ARINC 653 thus the interface for these resources is controlled by the operating system and could change from platform to platform limiting the ability to reuse software without change.

5 The architecture and API or APEX interfaces provide no mechanism for exclusive use of critical resources by a partition the concept of protected resources.

6 The architecture and API or APEX interfaces are open to use by any caller and as such does not provide protection for each partition.

An operating system for an aircraft according to an exemplary aspect of the present disclosure includes an application layer and a core services layer that is time and space partitioned from the application layer. A hardware interface layer being time and space partitioned from both the application layer and the core services layer is operable to control communications with hardware in a computer.

An operating system for an aircraft according to another exemplary aspect of the present disclosure includes a plurality of core services and a plurality of application specific services that are time and space partitioned from the core services. The core services are common across multiple platforms. The application specific services are specific to one of the multiple platforms such that the application specific services can be modified without altering the core services. A hardware interface layer is time and space partitioned from both the core services and the application specific services. The hardware interface layer is operable to control communications with hardware in a computer.

The application tasks in each partition run in user mode and are certified to the level of criticality required by function hazard assessment and system safety assessment. The application tasks can have their own partitions or can share a partition with one or more tasks of the same criticality level as shown. The application tasks interface with the application specific support services core support services and the operating system through the APIs . It should be noted that the application tasks do not interface with the hardware directly. The core support service and application specific support service run in user mode while the operating system runs in supervisor mode.

The tasks within the core support service can each have their own unique partitions or can share a partition with one or more core support services of the same criticality level. The tasks within the core support services interface with the application tasks other application specific support services operating system and the BSP services through APIs .

The application specific support services module contains tasks that run in user mode. The services are reserved for services that change from aircraft to aircraft. The application specific support services tasks are certified to a level of criticality required by functional hazard assessment and system safety assessment. Application specific support service tasks can have their own unique partitions or can share a partition with one or more tasks of the same criticality level. The tasks in each application specific support service interface with the applications core support services operating system and the BSP services through APIs and . The tasks in the BSP services run in user mode. The interfaces will be particular to the product s hardware interfaces. The hardware interfaces can either be tasks or device drivers. Tasks can have their own unique partitions or can share a partition of one or more tasks of the same criticality level hardware access and partition needs must be considered . Device drivers can be called by any task in any partition to read data without delay. Device drivers can handle writing to hardware I O if an exclusive device driver one per task . The BSP services interface with the core support services application specific support services and operating system through BSP interfaces .

The APIs comprise two types message queues and device drivers. Referring to the message queues only two shown for purposes of illustration can have fixed length messages or variable length messages and provide communication across partitions. The message queues pass multiple messages between an application task in one partition and an application task in another partition . Message queues are controlled by the RTOS in terms of size shape access etc and are implemented using system calls. Each message queue is dedicated to sending messages from one specific task to another specific task in a single direction. Each queue has one task as the sender and the other task as the receiver. If the two tasks require handshaking then two queues must be created such as in the example shown. Message queue sends messages from task to task while message queue sends messages from task to task . Each task has a queue for each of the tasks to which it has to send data and a queue for each of the tasks from which it has to receive data.

Referring to in use a sending task such as the galley light switch task copies its message to the queue galley light to communications queue which resides in the RTOS during its task slot. Referring to I O communications services is one of the services shown generically in . During its task slot the receiving task I O communications services in this example copies the message from the queue . In this example the I O communications services would then map the output data to the hardware via BSP Interfaces of not shown in .

Referring to device drivers one device driver is shown can also be used to read information between task partitions . Device drivers have a single entry point and are re entrant and pre emptive. The device drivers are implemented using system calls and there is no data delay. The device drivers are operated in supervisor mode by the RTOS and can traverse space partitions. The I O communications services retrieves inputs from hardware during its period of execution and places an image of the data into a memory map . As shown in a task in this example again the galley light switch task requests the communication I O device driver . The request is handled in the RTOS executing in supervisor mode. RTOS adds code and data partition to the MMU for the device driver . Execution is then placed in user mode and the device driver is invoked. Referring to the communication I O device driver executes with memory that is partitioned for both the galley light switch task and the I O communications services . The device driver copies the requested inputs into the galley light switch data partition. Referring to when the device driver is finished execution returns to the RTOS in supervisor mode. The RTOS removes the code and data partition from the MMU for the device driver . Execution is then returned to the requesting task and the total execution time required to run the device driver is charged to the requesting task .

The space partitioning is illustrated conceptually in . A mask is defined by Block Address Translation BAT registers and is used for space partitioning. For example a task is assigned data BAT entry which defines a partition in RAM of memory for example. Transition lookaside buffer TLB defines a partition in RAM for task . Further instruction BAT entry register defines partition in ROM of memory of memory .

Tasks are assigned to a partition and . Every task switch loads in the predefined registers of the partition that task belongs to. No searches are required if a BAT miss is encountered. The miss is a space partitioning fault. The transition lookaside buffer on chip page table registers are used for stack protection. No searches are required if a TLB miss occurs. The miss is a space partitioning fault. The BAT registers are defined at compile time. All registers can be used for designer to allocate. The last register is multiplexed with a device driver. For communication all tasks can write to the last register.

For the instruction BATs the first register is assigned to the operating system API instruction area function call . The second to the last registers can be used for a designer to allocate. The last register is multiplexed with a device driver. Switching tasks requires first a check that a Single Event Upset SEU did not occur in the BAT registers. Then the BAT registers are updated with the new tasks partition BAT values. The system then checks that the SEU did not occur for the TLB registers for the stacked protection. The current TLB registers are invalidated for the current task and the TLB registers are updated with the new tasks values.

Referring to the schedule does not change during operation. For example the first three execution blocks are always for Task A even if A should terminate or fail. A status register has a plurality of registers that each correspond to the time blocks in the schedule . The status register indicates the expected operation of the task associated with that particular status register . For example the 1 may mark the beginning of a task for restarting the task. The 0 may signify that the Task may continue executing. The 2 indicates that the Task should end. An index of the deadline monotonic scheduler is incremented at each timer interrupt . The index indicates which execution block in the schedule is currently being performed.

The DM scheduler ensures that no task can starve or block another task because the DM scheduler will only give each task the exact execution blocks that are allotted it in the schedule . Therefore if Task A for example fails to complete before the third execution block where the status register of 2 indicates that the Task A should end Task A is terminated put to sleep or restarted. In the fourth execution block Task C begins on schedule. If necessary the entire control system may be restarted.

A new schedule can be inserted when the index reaches the end of the current schedule . The index is then set to the beginning of the new schedule. For example the system may utilize a first startup schedule for startup and another normal schedule for normal operation. The startup schedule may permit some of the various tasks more time to start up with different WCETs periods and deadlines. Once the system is in full operation the normal schedule may be seamlessly switched into operation.

In accordance with the provisions of the patent statutes and jurisprudence exemplary configurations described above are considered to represent a preferred embodiment of the invention. However it should be noted that the invention can be practiced otherwise than as specifically illustrated and described without departing from its spirit or scope.

