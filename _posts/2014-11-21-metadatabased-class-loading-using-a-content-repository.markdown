---

title: Metadata-based class loading using a content repository
abstract: An example method of loading classes from a content repository includes storing a set of files in a content repository. The set of files includes a representation of a set of classes. The method also includes extracting first metadata that describes the set of classes and storing the first metadata in a content repository. The method further includes receiving a request including second metadata corresponding to one or more classes of the set of classes. The request is from a repository-class loader executable in a node. The method also includes selecting, based on the second metadata, a class of the set of classes. The method further includes sending the selected class to the repository-class loader for loading into the node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09411618&OS=09411618&RS=09411618
owner: Red Hat, Inc.
number: 09411618
owner_city: Raleigh
owner_country: US
publication_date: 20141121
---
A class loader loads classes used by an application at runtime. Given the name of a class the class loader locates the definition of the class and loads it. For example JAVA has three default class loaders the Bootstrap class loader extensions class loader and application class loader. Trademarks are the properties of their respective owners. The bootstrap class loader is responsible for loading the core Java libraries stored in a directory. The bootstrap class loader which is part of the core JVM is written in native code. The extensions class loader is responsible for loading the code in the extensions directories. Finally the application class loader is responsible for loading code that is found in a predefined path e.g. java.class.path system property . An administrator may place all the classes in a folder and then the classes may be loaded from the folder.

With conventional application class loaders when the administrator wants to update classes the administrator typically copies the updated class into the predefined path and overwrites the original class. Unfortunately the original class is lost and the administrator may not be able to determine which classes have been updated. A similar problem occurs when a server s profile has been changed. For example a server s profile may be configured to different profiles e.g. a production environment profile or testing environment profile and different classes may be used for different profiles. Classes may be loaded into the server and when the administrator wants to change the server s profile the administrator typically copies classes that are used for the new profile into the predefined path and overwrites the original class in the predefined path. Again the original class is lost and the administrator may not be able to determine which classes have been updated.

It may be hard to maintain a system that loads classes found in a predefined path especially if it is desirable to have different versions of a class in the predefined path or to change a server s profile.

It may be desirable to provide a more flexible way to load classes. This disclosure relates to loading classes from a content repository.

According to an embodiment a method of loading classes from a content repository includes storing a set of files in a content repository. The set of files includes a representation of a set of classes. The method also includes extracting first metadata that describes the set of classes and storing the first metadata in a content repository. The method further includes receiving a request including second metadata corresponding to one or more classes of the set of classes. The request is from a repository class loader executable in a node. The method also includes selecting based on the second metadata a class of the set of classes. The method further includes sending the selected class to the repository class loader for loading into the node.

According to another embodiment a system for loading classes from a content repository includes a content repository that stores a set of files and first metadata. The set of files includes a representation of a set of classes and the first metadata describes the set of classes. The system also includes a class sequencer that sequences the set of files extracts the first metadata based on the set of files and stores the first metadata in the content repository. The system further includes a repository class loader that sends a request including second metadata corresponding to one or more classes of the set of classes and responsive to the request receives a class corresponding to the second metadata. The repository class loader is executable in a node and loads the class into the node. The system also includes a class distributor that receives the request including the second metadata selects based on the second metadata the class corresponding to the second metadata and sends the selected class to the repository class loader.

According to another embodiment a non transitory machine readable medium includes a plurality of machine readable instructions that when executed by one or more processors are adapted to cause the one or more processors to perform a method including storing a set of files in a content repository the set of files including a representation of a set of classes extracting first metadata that describes the set of classes storing the first metadata in a content repository receiving a request including second metadata corresponding to one or more classes of the set of classes the request being from a repository class loader executable in a node selecting based on the second metadata a class of the set of classes and sending the selected class to the repository class loader for loading into the node.

It is to be understood that the following disclosure provides many different embodiments or examples for implementing different features of the present disclosure. Some embodiments may be practiced without some or all of these specific details. Specific examples of components modules and arrangements are described below to simplify the present disclosure. These are of course merely examples and are not intended to be limiting.

The present disclosure provides techniques to maintain classes and load them into nodes. Rather than load classes from a predefined class path techniques are provided to load the classes from a content repository. The classes that are loaded into the nodes are stored in the content repository. Accordingly one or more nodes that load a particular set of classes may be provided with the set of classes through a central storage unit.

In an embodiment a system for loading classes from a content repository includes a content repository that stores a set of files and first metadata. The set of files includes a representation of a set of classes and the first metadata describes the set of classes. The system also includes a class sequencer that sequences the set of files extracts the first metadata based on the set of files and stores the first metadata in the content repository. The system further includes a repository class loader that sends a request including second metadata corresponding to one or more classes of the set of classes and responsive to the request receives a class corresponding to the second metadata. The repository class loader is executable in a node and loads the class into the node. The system also includes a class distributor that receives the request including the second metadata selects based on the second metadata the class corresponding to the second metadata and sends the selected class to the repository class loader.

An advantage of an embodiment may provide for easy maintenance of classes because if a class in a package changes it may be unnecessary to change each node that loads that class. Rather a change may be made to the class that is stored in the content repository and this updated class may then be loaded into other nodes. Additionally multiple versions of a class may be stored in the content repository. An advantage of an embodiment may provide for tracking of the different class versions. If an updated version of a class proves to be faulty an administrator may revert back to the old version of the class. Additionally a node may be configured in accordance with multiple profiles. An advantage of an embodiment may provide the administrator with a convenient way to switch a node s profile and load another set of classes used for the updated profile. It may be unnecessary for the administrator to restart the node because the administrator can change the configuration without restarting the node.

Each of nodes and may be implemented on a computing device that includes a memory and a processor. In an example a node may be a virtual machine and or application server running on a computing device. A virtual machine is a software implementation of a machine that executes programs. The virtual machine may be for example a JAVA virtual machine JVM . Nodes and may be implemented on the same computing device or different computing devices. If nodes and are implemented on different computing devices nodes and may be separated by a network. The network may include various configurations and use various protocols including the Internet World Wide Web intranets virtual private networks wide area networks local networks private networks using communication protocols proprietary to one or more companies Ethernet WiFi and HTTP and various combinations of the foregoing. Although two nodes are illustrated other embodiments including fewer than or more than two nodes are within the scope of the present disclosure.

A node may execute an application which is written in a high level programming language. In an example application is written in an object oriented programming language that defines classes. A data object may be a self contained entity that has state and behavior and represents an instance of a class. The data object s state may be described by its fields and attributes and the data object s behavior may be described by its methods and events. The application may include code that creates instances of a class and an instance of a particular class may expose methods and attributes defined by that class. An application may be for example a JAVA application or a C application. Code in the application may include the new keyword which is a JAVA operator that creates an instance. Although the present disclosure may describe the application as being a JAVA application it should be understood that the techniques in the disclosure apply to any object oriented programming language that loads classes.

In the example illustrated in a domain includes a class manager and all classes that are used by nodes and are stored in a content repository . Domain may include a set of nodes e.g. nodes and that are under corporate control and controlled by one administrator. In some embodiments content repository is used for all nodes e.g. nodes and in domain . Each domain may include one class manager and the nodes included in the respective domain may load classes through the class manager belonging to the respective domain. Additionally all nodes included in a particular domain may load the same set of classes. A node may use a class loader e.g. a repository class loader to load a class into the runtime environment.

An administrator may maintain classes for all nodes in domain . The administrator of domain may load a set of classes into content repository which may provide hierarchical organization versioning indexing search access control and transactions. An application may include a set of one or more source files that each includes a class definition. The set of source files may be compiled to generate a set of compiled classes which administrator loads into content repository and is stored in set of files . A compiled version of all the classes that make up the application may be stored in set of files . In an example application is a JAVA application the set of source files includes .java files e.g. Class1.java Class2 java etc. that can be compiled using a JAVA compiler and set of files includes a set of .class files e.g. Class1.class Class2.class etc. .

Content repository stores set of files which includes a representation of one or more classes. In an example the application is a JAVA application and a class file includes the binary representation of a class. In this example set of files includes JAVA bytecode that can be executed in node . The class file includes the executable bytecodes and references to other classes used by that class. Classes may be loaded into a node as they are referenced by the bytecode being executed in the node. When a class is loaded all classes that the class references may be loaded in a recursive pattern until all classes used by the node are loaded into the node. It is possible that not all of the classes in an application are loaded into the node. In an example unreferenced classes are not loaded until the time they are referenced.

Content repository includes a class sequencer that processes items saved in the content repository. Class sequencer may store set of files in content repository and sequence set of files to extract meaningful information from content in the set of files. In an example class sequencer automatically sequences set of files by extracting metadata that describes the set of compiled classes stored in set of files . Class sequencer saves the compiled classes e.g. bytecode together with their metadata into content repository . Class sequencer stores metadata in content repository in an easily accessible form making it easier to reuse that information at a later point in time.

A class may have different types of associated metadata. In an example a class has a class name and metadata may include the name of the class. In another example a class may be updated or revised and different versions of the class may exist and be stored in content repository . In this example metadata may include version metadata that specifies one or more versions of one or more classes stored in content repository . For example if two versions of a class Class1 are stored in content repository each class may have associated metadata specifying the version of the class. A repository class loader may load different versions of a class into a node. For example repository class loader may load the most recent version of a class that is stored in content repository into node .

Additionally a node may be configured in accordance with a profile. Metadata may include profile metadata that specifies one or more classes stored in set of files used for one or more profiles. For example node may include a configuration file e.g. Extensible Markup Language XML file and be configured in accordance with a production environment profile testing environment profile development environment profile or performance profile. A node e.g. application server may be configured for example by placing directives in plain text configuration files. Accordingly repository class loader may be able to determine the profile to which node is configured and also the class s and the version of the class es used for a particular profile by reading the node s configuration file.

A particular set of classes may be used for particular profiles. For example if node is configured in accordance with the production environment profile classes thisClass Production1 and Production2 may be used for the production environment profile and thus loaded into and used by node . In another example if node is configured in accordance with the testing environment profile classes thisClass Test1 and Test2 may be used for the testing environment profile and thus loaded into and used by node . Node may be configured in accordance with the production environment profile and later configured in accordance with the testing environment profile. The classes stored in set of files may include classes used for both the production environment and testing environment profiles. A repository class loader may load different classes into node depending on the profile to which the node is configured. A repository class loader may include a constructor including the profile to which the node is configured. As discussed further below metadata may be used to provide a node with a class that best fits the node s configuration.

In another example a class may expose public attributes and methods that may be invoked via an application programming interface API of the class. In this example metadata may include attribute and method metadata that specifies an API of one or more classes in set of files . In another example a first class may reference an attribute of a second class or may call a method of the second class. In this example metadata may include dependency metadata that specifies a partial API of the second class that is called by the first class. The first and second classes may be stored in set of files .

A class may be marked with an indication of the version of the class profile s that use the class e.g. production environment profile testing environment profile development environment profile or performance profile API of the class and or partial API of the class. A developer of the class may mark the class. In an example the indication is an annotation that marks the class. For example the class may be marked with an annotation e.g. Java annotation indicating the class s version associated profile s API and or partial API. In this example class sequencer may sequence set of files identify the classes with the annotations in set of files and identify the version s of the classes profiles for which the classes are used API s of the classes and or partial API s of the classes based on the annotations. Class sequencer may extract this metadata based on the annotations and store the metadata in content repository . In another example the API of the class and or partial API of the class dependencies may be extracted from any class file. In this example it may be unnecessary for the developer to specify the API and or partial API explicitly in an annotation.

In another example a class is marked using a Java Archive JAR file which is a file format that is used for bundling multiple files into a single archive file. When a JAR file is created a default manifest file is automatically created for the JAR file. The JAR file s manifest is a special file that may contain information about the files packaged in the JAR file e.g. the class files . In this example class sequencer may sequence each JAR file loaded into content repository derive the classes from the JAR file extract the metadata based on the classes and load the metadata into content repository for storing with the associated class.

A class distributor acts as an intermediary between repository class loaders and content repository . Class distributor may search navigate version and listen for changes in content repository . Classes stored in content repository may be loaded into a node. In an example when a class is loaded into a node that is included in a domain all the nodes in that domain load the same class. In some embodiments content repository is a Java Content Repository JCR and repository class loader is a JAVA class loader that loads classes from the JCR. In this example content repository may be ModeShape which is a JCR implementation that provides access to content stored in many different kinds of systems including the federation of multiple systems e.g. file systems databases other repositories services and applications . In such an example content repository may retrieve its content by federating multiple back end systems e.g. databases services other repositories etc. allowing those systems to continue owning the information while ensuring the unified repository stays up to date and in sync.

Class distributor communicates with the repository class loaders to determine which classes are requested for loading into nodes and provides the requested classes to the repository class loaders. Class distributor manages electronic files and the metadata associated with them. In an example class distributor receives a request for a class from a repository class loader and invokes an API at content repository to retrieve that class. Content repository may provide an API that may be invoked by class distributor to search for a class stored in the content repository. As discussed below class distributor may identify which class is being requested based on the information e.g. metadata included in the request and may send the requested class to a repository class loader for loading into a node. Additionally class distributor retrieves the metadata of classes from content repository and uses the metadata to retrieve the classes that correspond with the request from a repository class loader. Acquired metadata may be used to provide classes to the nodes according to their configurations.

A repository class loader may load classes from content repository into a node. The metadata stored in content repository may be used to provide a node with the most suitable class that is compatible with classes that have already been loaded into the node. provides an example process flow of loading one or more classes from a content repository according to some embodiments. Process flow includes an action in which node starts up. Node may include a configuration file and be configured in accordance with a profile that is set in the configuration file. Repository class loader may know from the node s configuration which classes to load into node . In an example node is a server and the class version and profile of the node depend on the server configuration.

Process flow may proceed from action to an action in which repository class loader reads node s configuration file and determines based on node s configuration a profile of node . Various actions may trigger repository class loader to read node s configuration file. For example repository class loader may detect that node has started up or has been restarted and read node s configuration file based on the detection. In another example repository class loader may detect a change in node s configuration and read node s configuration file based on the detected change.

In an example configuration file specifies that node is configured to the production environment profile and uses version 2 of the class Class1. Repository class loader may determine based on the profile a set of classes that is used for the profile. Repository class loader may desire to load this set of classes into node .

At an action repository class loader sends a request for a set of classes based on node s configuration. Repository class loader may send request to class distributor . In an example request is a request for a set of classes used for the production environment profile. Request includes metadata corresponding to one or more classes stored in content repository . For example request may include version metadata specifying a version of one or more classes profile metadata specifying the profile of the node an API of one or more classes used for the profile and or a partial API of one or more classes used for the profile. In an example metadata includes class name s e.g. Class1 version s of the class es e.g. Version 2 and node s profile e.g. production environment profile .

Class distributor receives request including metadata corresponding to one or more classes stored in set of files. At an action class distributor searches metadata for metadata that corresponds to metadata included in the request. Process flow proceeds from action to an action in which class distributor selects based on metadata a set of classes stored in set of files . Set of classes may include binary data representative of one or more classes in application .

In an example metadata includes . Class distributor may search metadata for metadata corresponding to the metadata in request . For example class distributor may search for metadata corresponding to a class having the name Class1 and version 2 of this class and corresponding to a class having the name Class2 and version 1 of this class. In this example set of classes e.g. classes Class1 and Class2 may include the classes corresponding to this metadata. Class distributor may select set of classes by retrieving the metadata that corresponds to metadata from content repository and selecting the set of classes associated with the corresponding metadata. In an example set of classes may correspond to metadata that is a perfect match with the metadata in the request. In another example set of classes may correspond to metadata that is the closest match with the metadata in the request.

At an action class distributor may check whether set of classes is compatible with the classes that have already been loaded into node . Class distributor may maintain a list of all classes that have been loaded by each node. For example class distributor has two separate lists for nodes and . A first list may include all classes that have been loaded by node and a second list may include all classes that have been loaded by node . When a node requests a class class distributor checks whether the requested class is compatible with all classes that are currently in the corresponding list of already loaded classes in that node. To check the compatibility class distributor may compare the partial API of dependencies of the requested class with the API of the classes that are already loaded by the node. Class sequencer sequences set of files and information about the API s of classes are sequenced when the class es are stored in content repository . This feature may be important when classes are regularly updated and it is undesirable to restart the application servers often. Compatibility checking may allow the loading of a new version of a class only when the class is compatible with the classes that are already loaded by the application server. When a node is restarted class distributor may empty out that node s list.

At an action if set of classes is compatible with the classes that have already been loaded into node class distributor sends set of selected classes to repository class loader for loading into node . Repository class loader may then load set of selected classes into node . In an example the set of classes in set of files is in a binary format e.g. bytecode that is executable. In this example class distributor may send set of selected classes in a binary format to repository class loader . Repository class loader may receive set of selected classes which is in a binary format. In an example set of selected classes includes binary data representative of one or more classes stored in content repository and repository class loader loads the binary data into node .

For each of the nodes in domain a repository class loader that is executable in the respective node may load set of classes or a different set of classes into the respective node using similar techniques as that described in process flow .

Additionally at a later point in time a node may be configured in accordance with a different profile that uses one or more classes different from the one s previously loaded into the node. For example administrator may want to debug a problem and accordingly change the profile of node from the production environment profile to a testing environment profile. The testing environment profile may use one or more classes different from the ones used for the production environment profile. For example classes used for the testing environment profile may include more debug information compared to the classes used for the production environment profile. When the testing is finished administrator may switch the configuration back to the production environment profile. In another example administrator may want to use an updated version of a class e.g. version 2 of class Class1 rather than version 1 of class Class1 that is used for the production environment. Classes may be updated periodically. In an example node is a server and administrator may want to apply patches. In such an example administrator may set the server to load the newest version of a class and load the patched classes into content repository . A repository class loader may load the patched classes the next time the class is requested. Administrator may easily return back to using the unpatched version of a class if the patched class has bugs.

Administrator may load the classes that are not yet stored in content repository but used for the profile to which a node is or will be configured into the content repository for retrieval at a later point in time. As discussed administrator may load a binary representation e.g. bytecode of a set of classes into content repository . Class sequencer may then sequence the binary representation of the set of classes to extract metadata that describes the set of classes and store the metadata with its associated class in content repository .

Repository class loader may load a second set of classes used for the new profile into node using similar techniques as that described in process flow . The second set of classes may include zero or more classes of set of selected classes . In an example repository class loader may determine a second set of classes used for the testing environment profile and send a request including metadata corresponding to the second set of classes. The metadata may include the name s of the class es of the second set of classes the version s of the class es and the API s and partial API s of the class es of the second set of classes.

As discussed above and further emphasized here are merely examples which should not unduly limit the scope of the claims. In an example although block diagrams and are described herein with reference to one domain and one class manager other embodiments including more than one domain and or more than one class manager are within the scope of this disclosure. Moreover it should be understood that one or more modules e.g. class sequencer and class distributor in may be combined with another module. It should also be understood that one or more modules in FIG. e.g. class sequencer and class distributor may be separated into more than one module.

Additionally a repository class loader may send a request to class distributor with different metadata corresponding to one or more classes stored in content repository . For example repository class loader may send a request including the profile to which a node is configured and class distributor may be able to determine a set of classes used for the profile. In an example class distributor may maintain a list of classes used for one or more profiles. Class distributor may then select this set of classes and send the set of classes to the requesting repository class loader for loading into a node.

Method includes steps . In an action a set of files is stored in a content repository the set of files including a representation of a set of classes. In an example content repository stores set of files in content repository set of files including a representation of a set of classes. In an action first metadata that describes the set of classes is extracted. In an example class sequencer extracts metadata that describes the set of classes.

In an action the first metadata is stored in a content repository. In an example class sequencer stores metadata in content repository . In an action a request including second metadata corresponding to one or more classes of the set of classes is received the request being from a repository class loader executable in a node. In an example class distributor receives request including second metadata corresponding to one or more classes of the set of classes request being from repository class loader executable in node . In an action a class of the set of classes is selected based on the second metadata. In an example class distributor selects based on the second metadata a class of the set of classes. In an action the selected class is sent to the repository class loader for loading into the node. In an example class distributor sends the selected class to repository class loader for loading into node .

In some embodiments actions may be performed for any number of classes that are requested for loading into a node. It is also understood that additional actions may be performed before during or after actions discussed above. It is also understood that one or more of the actions of method described herein may be omitted combined or performed in a different sequence as desired.

Computer system includes a bus or other communication mechanism for communicating information data signals and information between various components of computer system . Components include an input output I O component for processing user actions such as selecting keys from a keypad keyboard or selecting one or more buttons or links etc. and sending a corresponding signal to bus . I O component may also include an output component such as a display and an input control such as a cursor control such as a keyboard keypad mouse etc. . An audio I O component may also be included to allow a user to use voice for inputting information by converting audio signals into information signals. Audio I O component may allow the user to hear audio.

A transceiver or network interface transmits and receives signals between computer system and other devices via a communications link to a network. In an embodiment the transmission is wireless although other transmission mediums and methods may also be suitable.

CPU which may be a micro controller digital signal processor DSP or other processing component processes these various signals such as for display on display of computer system or transmission to other devices via communication link . A processor may also control transmission of information such as cookies or IP addresses to other devices.

Components of computer system also include a system memory component e.g. RAM a static storage component e.g. ROM and or a computer readable medium . Computer system performs specific operations by one or more CPUs and other components by executing one or more sequences of instructions contained in system memory component . Logic may be encoded in computer readable medium which may refer to any medium that participates in providing instructions to one or more CPUs for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. In various implementations non volatile media include optical or magnetic disks or solid state drives volatile media include dynamic memory such as system memory component and transmission media include coaxial cables copper wire and fiber optics including wires that include bus .

In an embodiment the logic is encoded in non transitory computer readable medium. Computer readable medium may be any apparatus that can contain store communicate propagate or transport instructions that are used by or in connection with CPU . Computer readable medium may be an electronic magnetic optical electromagnetic infrared or semiconductor device or a propagation medium or any other memory chip or cartridge or any other medium from which a computer is adapted to read. In an example transmission media may take the form of acoustic or light waves such as those generated during radio wave optical and infrared data communications.

In various embodiments of the present disclosure execution of instruction sequences e.g. method to practice the present disclosure may be performed by computer system . In various other embodiments of the present disclosure a plurality of computer systems coupled by communication link to the network e.g. such as a LAN WLAN PTSN and or various other wired or wireless networks including telecommunications mobile and cellular phone networks may perform instruction sequences to practice the present disclosure in coordination with one another.

Where applicable various embodiments provided by the present disclosure may be implemented using hardware software or combinations of hardware and software. Also where applicable the various hardware components and or software components set forth herein may be combined into composite components including software hardware and or both without departing from the spirit of the present disclosure. Where applicable the various hardware components and or software components set forth herein may be separated into sub components including software hardware or both without departing from the spirit of the present disclosure. In addition where applicable it is contemplated that software components may be implemented as hardware components and vice versa.

Application software in accordance with the present disclosure may be stored on one or more computer readable mediums. It is also contemplated that the application software identified herein may be implemented using one or more general purpose or specific purpose computers and or computer systems networked and or otherwise. Where applicable the ordering of various actions described herein may be changed combined into composite actions and or separated into sub actions to provide features described herein.

The foregoing disclosure is not intended to limit the present disclosure to the precise forms or particular fields of use disclosed. As such it is contemplated that various alternate embodiments and or modifications to the present disclosure whether explicitly described or implied herein are possible in light of the disclosure. Changes may be made in form and detail without departing from the scope of the present disclosure. Thus the present disclosure is limited only by the claims.

