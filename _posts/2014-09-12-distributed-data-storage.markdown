---

title: Distributed data storage
abstract: The present invention relates to a distributed data storage system comprising a plurality of storage nodes. Using unicast and multicast transmission, a server application may write data in the storage system. When writing data, at least two storage nodes are selected based in part on a randomized function, which ensures that data is sufficiently spread to provide efficient and reliable replication of data in case a storage node malfunctions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09503524&OS=09503524&RS=09503524
owner: COMPUVERDE AB
number: 09503524
owner_city: 
owner_country: SE
publication_date: 20140912
---
This application is a continuation of U.S. patent application Ser. No. 13 174 350 filed Jun. 30 2011 which is a continuation in part of PCT Application No. PCT EP2011 056317 filed Apr. 20 2011 which claims the benefit of European Application No. EP10160910.5 filed Apr. 23 2010 the disclosures of which is incorporated herein by reference.

The present disclosure relates to a method for writing data in a data storage system comprising a plurality of data storage nodes the method being employed in a server in the data storage system. The disclosure further relates to a server capable of carrying out the method.

Such a method is disclosed e.g. in U.S. 2005 0246393 A1. This method is disclosed for a system that uses a plurality of storage centres at geographically disparate locations. Distributed object storage managers are included to maintain information regarding stored data.

One problem associated with such a system is how to accomplish simple and yet robust and reliable writing as well as maintenance of data.

One object of the present disclosure is therefore to realise robust writing of data in a distributed storage system.

The object is also achieved by means of a method for writing data to a data storage system of the initially mentioned kind which is accomplished in a server running an application which accesses data in the data storage system. The method comprises sending a multicast storage query to a plurality of storage nodes receiving a plurality of responses from a subset of said storage nodes the responses including storage node information respectively relating to each storage node selecting at least two storage nodes in the subset based on said responses. The selecting includes determining based on an algorithm for each storage node in the subset a probability factor which is based on its storage node information and randomly selecting said at least two storage nodes wherein the probability of a storage node being selected depends on its probability factor. The method further involves sending data and a data identifier corresponding to the data to the selected storage nodes.

This method accomplishes robust writing of data since even if storage nodes are selected depending on their temporary aptitude information will still be spread to a certain extent over the system even during a short time frame. This means that maintenance of the storage system will be less demanding since the correlation of which storage nodes carry the same information can be reduced to some extent. This means that a replication process which may be carried out when a storage node malfunctions may be carried out by a greater number of other storage nodes and consequently much quicker. Additionally the risk of overloading storage nodes with high rank during intensive writing operations is reduced as more storage nodes is used for writing and fewer are idle.

The storage node information may include geographic data relating to the geographic position of each storage node such as the latitude longitude and altitude thereof. This allows the server to spread the information geographically within a room a building a country or even the world.

It is possible to let the randomly selecting of storage nodes be carried out for storage nodes in the subset fulfilling a primary criteria based on geographic separation as this is an important feature for redundancy.

The storage node information may include system age and or system load for the storage node in question.

At least three nodes may be selected and a list of storage nodes successfully storing the data may be sent to the selected storage nodes.

The randomly selecting of the storage nodes may be carried out for a fraction of the nodes in the subset which includes storage nodes with the highest probability factors. Thereby the least suitable storage nodes are excluded providing a selection of more reliable storage nodes while maintaining the random distribution of the information to be written.

The disclosure further relates to a server for carrying out writing of data corresponding to the method. The server then generally comprises means for carrying out the actions of the method.

The present disclosure is related to a distributed data storage system comprising a plurality of storage nodes. The structure of the system and the context in which it is used is outlined in .

A user computer accesses via the Internet an application running on a server . The user context as illustrated here is therefore a regular client server configuration which is well known per se. However it should be noted that the data storage system to be disclosed may be useful also in other configurations.

In the illustrated case two applications run on the server . Of course however this number of applications may be different. Each application has an API Application Programming Interface which provides an interface in relation to the distributed data storage system and supports requests typically write and read requests from the applications running on the server. From an application s point of view reading or writing information from to the data storage system need not appear different from using any other type of storage solution for instance a file server or simply a hard drive.

Each API communicates with storage nodes in the data storage system and the storage nodes communicate with each other. These communications are based on TCP Transmission Control Protocol and UDP User Datagram Protocol . These concepts are well known to the skilled person and are not explained further.

It should be noted that different APIs on the same server may access different sets of storage nodes . It should further be noted that there may exist more than one server which accesses each storage node . This however does not to any greater extent affect the way in which the storage nodes operate as will be described later.

The components of the distributed data storage system are the storage nodes and the APIs in the server which access the storage nodes . The present disclosure therefore relates to methods carried out in the server and in the storage nodes . Those methods will primarily be embodied as software implementations which are run on the server and the storage nodes respectively and are together determining for the operation and the properties of the overall distributed data storage system.

The storage node may typically be embodied by a file server which is provided with a number of functional blocks. The storage node may thus comprise a storage medium which typically comprises of a number of hard drives optionally configured as a RAID Redundant Array of Independent Disk system. Other types of storage media are however conceivable as well.

The storage node may further include a directory which comprises lists of data entity storage node relations as a host list as will be discussed later.

In addition to the host list each storage node further contains a node list including the IP addresses of all storage nodes in its set or group of storage nodes. The number of storage nodes in a group may vary from a few to hundreds of storage nodes. The node list may further have a version number.

Additionally the storage node may include a replication block and a cluster monitor block . The replication block includes a storage node API and is configured to execute functions for identifying the need for and carrying out a replication process as will be described in detail later. The storage node API of the replication block may contain code that to a great extent corresponds to the code of the server s storage node API as the replication process comprises actions that correspond to a great extent to the actions carried out by the server during reading and writing operations to be described. For instance the writing operation carried out during replication corresponds to a great extent to the writing operation carried out by the server . The cluster monitor block is configured to carry out monitoring of other storage nodes in the data storage system as will be described in more detail later.

The storage nodes of the distributed data storage system can be considered to exist in the same hierarchical level. There is no need to appoint any master storage node that is responsible for maintaining a directory of stored data entities and monitoring data consistency etc. Instead all storage nodes can be considered equal and may at times carry out data management operations vis vis other storage nodes in the system. This equality ensures that the system is robust. In case of a storage node malfunction other nodes in the system will cover up the malfunctioning node and ensure reliable data storage.

The operation of the system will be described in the following order reading of data writing of data and data maintenance. Even though these methods work very well together it should be noted that they may in principle also be carried out independently of each other. That is for instance the data reading method may provide excellent properties even if the data writing method of the present disclosure is not used and vice versa.

The reading method is now described with reference to the latter being a flowchart illustrating the method.

The reading as well as other functions in the system utilise multicast communication to communicate simultaneously with a plurality of storage nodes. By a multicast or IP multicast is here meant a point to multipoint communication which is accomplished by sending a message to an IP address which is reserved for multicast applications.

The reading as well as other functions in the system utilise multicast communication to communicate simultaneously with a plurality of storage nodes. By a multicast or IP multicast is here meant a point to multipoint communication which is accomplished by sending a message to an IP address which is reserved for multicast applications.

In principle only one server may be registered as a subscriber to a multicast address in which case a point to point communication is achieved. However in the context of this disclosure such a communication is nevertheless considered a multicast communication since a multicast scheme is employed.

With reference to and the method for retrieving data from a data storage system comprises the sending of a multicast query to a plurality of storage nodes . In the illustrated case there are five storage nodes each having an IP Internet Protocol address 192.168.1.1 192.168.1.2 etc. The number of storage nodes is needless to say just an example. The query contains a data identifier 2B9B4A97 76E5 499E A21A6D7932DD7927 which may for instance be a Universally Unique Identifier UUID which is well known per se.

The storage nodes scan themselves for data corresponding to the identifier. If such data is found a storage node sends a response which is received by the server cf. . As illustrated the response may optionally contain further information in addition to an indication that the storage node has a copy of the relevant data. Specifically the response may contain information from the storage node directory about other storage nodes containing the data information regarding which version of the data is contained in the storage node and information regarding which load the storage node at present is exposed to.

Based on the responses the server selects one or more storage nodes from which data is to be retrieved and sends a unicast request for data to that those storage nodes cf. .

In response to the request for data the storage node nodes send the relevant data by unicast to the server which receives the data. In the illustrated case only one storage node is selected. While this is sufficient it is possible to select more than one storage node in order to receive two sets of data which makes a consistency check possible. If the transfer of data fails the server may select another storage node for retrieval.

The selection of storage nodes may be based on an algorithm that take several factors into account in order to achieve a good overall system performance. Typically the storage node having the latest data version and the lowest load will be selected although other concepts are fully conceivable.

Optionally the operation may be concluded by server sending a list to all storage nodes involved indicating which nodes contains the data and with which version. Based on this information the storage nodes may themselves maintain the data properly by the replication process to be described.

With reference to and the method comprises a server sending a multicast storage query to a plurality of storage nodes. The storage query may comprise a data identifier and basically consists of a question whether the receiving storage nodes can store a file. Optionally if the file identity is included in the query the storage nodes may check with their internal directories whether they already have a file with this name and may notify the server in the unlikely event that this is the case such that the server may rename the file.

In any case at least a subset of the storage nodes will provide responses by unicast transmission to the server . Typically storage nodes having a predetermined minimum free disk space will answer to the query. The server receives the responses which comprise storage node information relating to properties of each storage node such as geographic data relating to the geographic position of each server. For instance as indicated in such geographic data may include the latitude the longitude and the altitude of each server. Other types of geographic data may however also be conceivable such as a ZIP code a location string i.e. building room rack row rack column or the like. The responses may be stored or cached for future use.

Alternatively or in addition to the geographic data further information related to storage node properties may be provided that serves as an input to a storage node selection process. In the illustrated example the amount of free space in each storage node is provided together with an indication of the storage node s system age and an indication of the load that the storage node currently experiences.

Based on the received responses the server selects at least two in a typical embodiment three storage nodes in the subset for storing the data. The selection of storage nodes is carried out by means of an algorithm that takes different data into account. The selection may be carried out in order to achieve some kind of geographical diversity. At least it could preferably be avoided that only file servers in the same rack are selected as storage nodes. Typically a great geographical diversity may be achieved even selecting storage nodes on different continents. In addition to the geographical diversity other parameters may be included in the selection algorithm. It is advantageous to have a randomized feature in the selection process as will be disclosed below.

Typically the selection may begin by selecting a number of storage nodes that are sufficiently separated geographically. This may be carried out in a number of ways. There may for instance be an algorithm that identifies a number of storage node groups or storage nodes may have group numbers such that one storage node in each group easily can be picked.

The selection may then include calculating based on each node s storage node information system age system load etc. a probability factor which corresponds to a storage node aptitude score. A younger system for instance which is less likely to malfunction gets a higher score. The probability factor may thus be calculated as a scalar product of two vectors where one contains the storage node information parameters or as applicable their inverses and the other contains corresponding weighting parameters.

A file to be stored may be predestinate to a specific disk if the storage node has more than one disk. This may be determined by the file s UUID. For instance if a storage node has 16 hard drives numbered hexadecimally from 0 to F the disk to be used for a specific file can be determined by the first four bits of the UUID.

Thus when a storage node receives a storage query including the file s UUID it can check the status of the relevant disk and return this status in the response to the server .

The status may typically include the disk queue i.e. the number of tasks that the storage node s operative system has sent to the hard drive in question and that has not yet been carried out. This factor is very determining for how quickly the write operation can be carried out.

Another disk status parameter that can be of interest is whether the hard drive in question is sleeping or not. If the disk is sleeping i.e. does not rotate it may be efficient to select another storage node to save energy.

The selection may then comprise randomly selecting storage nodes where the probability of a specific storage node being selected depends on its probability factor. Typically if a first server has a twice as high probability factor as a second server the first server has a twice as high probability of being selected.

It is possible to remove a percentage of the storage nodes with the lowest probability factors before carrying out the random selection such that this selection is carried out for a fraction of the nodes in the subset which fraction includes storage nodes with the highest probability factors. This is particularly useful if there are a lot of available storage nodes which may render the selection algorithm calculation time consuming.

Needless to say the selection process can be carried out in a different way. For instance it is possible to first calculate the probability factor for all storage nodes in the responding subset and carry out the randomized selection. When this is done it may be checked that the resulting geographical diversity is sufficient and if it is not sufficient repeat the selection with one of the two closest selected storage nodes excluded from the subset. Making a first selection based on geographic diversity e.g. picking one storage node in each group for the subsequent selection based on the other parameters is particularly useful again in cases where there are a lot of available storage nodes. In those cases a good selection will still be made without performing calculations with parameters of all available storage nodes.

The selection process for a file to be stored can be carried out based on responses received as the result of a multicast query carried out for that file. However it would also be possible to instead use responses recently received as the result of a multicast query issued in relation to the storing of another file. As a further alternative the server can regularly issue general multicast queries what is your status to the storage nodes and the selection may be based on the responses then received. Thus it may not be necessary to carry out a multicast query for every single file to be stored.

When the storage nodes have been selected the data to be stored and a corresponding data identifier is sent to each selected node typically using a unicast transmission.

Optionally the operation may be concluded by each storage node which has successfully carried out the writing operation sending an acknowledgement to the server. The server then sends a list to all storage nodes involved indicating which nodes have successfully written the data and which have not. Based on this information the storage nodes may themselves maintain the data properly by the replication process to be described. For instance if one storage node s writing failed there exists a need to replicate the file to one more storage node in order to achieve the desired number of storing storage nodes for that file.

The data writing method in itself allows an API in a server to store data in a very robust way as excellent geographic diversity may be provided.

In addition to the writing and reading operations the API in the server may carry out operations that delete files and update files. These processes will be described in connection with the data maintenance process below.

The aim of the data maintenance process is to make sure that a reasonable number of non malfunctioning storage nodes each store the latest version of each file. Additionally it may provide the function that no deleted files are stored at any storage node. The maintenance is carried out by the storage nodes themselves. There is thus no need for a dedicated master that takes responsibility for the maintenance of the data storage. This ensures improved reliability as the master would otherwise be a weak spot in the system.

With reference to the method for maintaining data comprises the detecting conditions in the data storage system that imply the need for replication of data between the nodes in the data storage system and a replication process . The result of the detection process is a list of files for which the need for replication has been identified. The list may further include data regarding the priority of the different needs for replication. Based on this list the replication process is carried out.

The robustness of the distributed storage relies on that a reasonable number of copies of each file correct versions are stored in the system. In the illustrated case three copies of each file is stored. However should for instance the storage node with the address 192.168.1.5 fail the desired number of stored copies for files B and C will be fallen short of.

One event that results in a need for replication is therefore the malfunctioning of a storage node in the system.

Each storage node in the system may monitor the status of other storage nodes in the system. This may be carried out by letting each storage node emit a so called heartbeat signal at regular intervals as illustrated in . In the illustrated case the storage node with address 192.168.1.7 emits a multicast signal to the other storage nodes in the system indicating that it is working correctly. This signal may be received by all other functioning storage nodes in the system carrying out heartbeat monitoring cf. or a subset thereof. In the case with the storage node with address 192.168.1.5 however this node is malfunctioning and does not emit any heartbeat signal. Therefore the other storage nodes will notice that no heartbeat signal has been emitted by this node in a long time which indicates that the storage node in question is down.

The heartbeat signal may in addition to the storage node s address include its node list version number. Another storage node listening to the heartbeat signal and finding out that the transmitting storage node has a later version node list may then request that transmitting storage node to transfer its node list. This means that addition and removal of storage nodes can be obtained simply by adding or removing a storage node and sending a new node list version to one single storage node. This node list will then spread to all other storage nodes in the system.

Again with reference to each storage node searches its internal directory for files that are stored by the malfunctioning storage node. Storage nodes which themselves store files B and C will find the malfunctioning storage node and can therefore add the corresponding file on their lists .

The detection process may however also reveal other conditions that imply the need for replicating a file. Typically such conditions may be inconsistencies i.e. that one or more storage nodes has an obsolete version of the file. A delete operation also implies a replication process as this process may carry out the actual physical deletion of the file. The server s delete operation then only need make sure that the storage nodes set a deletion flag for the file in question. Each node may therefore monitor reading and writing operations carried out in the data storage system. Information provided by the server at the conclusion of reading and writing operations respectively may indicate that one storage node contains an obsolete version of a file in the case of a reading operation or that a storage node did not successfully carry out a writing operation. In both cases there exists a need for maintaining data by replication such that the overall objects of the maintenance process are fulfilled.

In addition to the basic reading and writing operations at least two additional processes may provide indications that a need for replication exists namely the deleting and updating processes that are now given a brief explanation.

The deleting process is initiated by the server cf. . Similar to the reading process the server sends a query by multicasting to all storage nodes in order to find out which storage nodes has data with a specific data identifier. The storage nodes scan themselves for data with the relevant identifier and respond by a unicast transmission if they have the data in question. The response may include a list from the storage node directory of other storage nodes containing the data. The server then sends a unicast request to the storage nodes that are considered to store the file that the file be deleted. Each storage node sets a flag relating to the file and indicating that it should be deleted. The file is then added to the replication list and an acknowledgement is sent to the server. The replication process then physically deletes the file as will be described.

The updating process has a search function similar to the one of the deleting process and a writing function similar to the one carried out in the writing process. The server sends a query by multicasting to all storage nodes in order to find out which storage nodes has data with a specific data identifier. The storage nodes scan themselves for data with the relevant identifier and respond by a unicast transmission if they have the data in question. The response may include a list from the storage node directory of other storage nodes containing the data. The server then sends a unicast request telling the storage nodes to update the data. The request of course contains the updated data. The storage nodes updating the data sends an acknowledgement to the server which responds by sending a unicast transmission containing a list with the storage nodes that successfully updated the data and the storage nodes which did not. Again this list can be used by the maintenance process.

Again with reference to the read write delete and update operations may all indicate that a need for replication exists. The same applies for the heartbeat monitoring . The overall detection process thus generates data regarding which files need be replicated. For instance a reading or updating operation may reveal that a specific storage node contains an obsolete version of a file. A deletion process may set a deletion flag for a specific file. The heartbeat monitoring may reveal that a number of files stored on a malfunctioning storage node need be replicated to a new storage node.

Each storage nodes monitors the need for replication for all the files it stores and maintains a replication list . The replication list thus contains a number of files that need be replicated. The files may be ordered in correspondence with the priority for each replication. Typically there may be three different priority levels. The highest level is reserved for files which the storage node holds the last online copy of. Such a file need be quickly replicated to other storage nodes such that a reasonable level of redundancy may be achieved. A medium level of priority may relate to files where the versions are inconsistent among the storage nodes. A lower level of priority may relate to files which are stored on a storage node that is malfunctioning.

The storage node deals with the files on the replication list in accordance with their level of priority. The replication process is now described for a storage node which is here called the operating storage node although all storage nodes may operate in this way.

The replication part of the maintaining process starts with the operating storage node attempting to become the master for the file it intends to replicate. The operating storage nodes sends a unicast request to become master to other storage nodes that are known store the file in question. The directory cf. provides a host list comprising information regarding which storage nodes to ask. In the event for instance in case of a colliding request that one of the storage nodes does not respond affirmatively the file is moved back to the list for the time being and an attempt is instead made with the next file on the list. Otherwise the operating storage node is considered to be the master of this file and the other storage nodes set a flag indicating that the operating storage node is master for the file in question.

The next step is to find all copies of the file in question in the distributed storage system. This may be carried out by the operating storage node sending a multicast query to all storage nodes asking which ones of them have the file. The storage nodes having the file submit responses to the query containing the version of the file they keep as well as their host lists i.e. the list of storage nodes containing the relevant file that is kept in the directory of each storage node. These host lists are then merged by the operating storage node such that a master host list is formed corresponding to the union of all retrieved host lists. If additional storage nodes are found which were not asked when the operating storage node attempted to become master that step may now be repeated for the additional storage nodes. The master host list contains information regarding which versions of the file the different storage nodes keep and illustrate the status of the file within the entire storage system.

Should the operating storage node not have the latest version of the file in question this file is then retrieved from one of the storage nodes that do have the latest version.

The operating storage node then decides whether the host list need to be changed typically if additional storage nodes should be added. If so the operating storage node may carry out a process very similar to the writing process as carried out by the server and as described in connection with . The result of this process is that the file is written to a new storage node.

In case of version inconsistencies the operating storage node may update copies of the file that are stored on other storage nodes such that all files stored have the correct version.

Superfluous copies of the stored file may be deleted . If the replication process is initiated by a delete operation the process may jump directly to this step. Then as soon as all storage nodes have accepted the deletion of the file the operating storage node simply requests using unicast all storage nodes to physically delete the file in question. The storage nodes acknowledge that the file is deleted.

Further the status i.e. the master host list of the file is updated. It is then optionally possible to repeat steps to make sure that the need for replication no longer exists. This repetition should result in a consistent master host list that need not be updated in step .

Thereafter the replication process for that file is concluded and the operating storage node may release the status as master of the file by sending a corresponding message to all other storage nodes on the host list.

This system where each storage node takes responsibility for maintaining all the files it stores throughout the set of storage nodes provides a self repairing in case of a storage node malfunction self cleaning in case of file inconsistencies or files to be deleted system with excellent reliability. It is easily scalable and can store files for a great number of different applications simultaneously.

The invention is not restricted to the specific disclosed examples and may be varied and altered in different ways within the scope of the appended claims.

