---

title: Hardware and software methodologies for detecting illegal memory address of a memory access operation
abstract: A system for providing bound checking to insure memory accessed, including indirect object access through pointers, is within a range of defined object bounds is disclosed herein. Embodiments of the present disclosure provide hardware and software methodology for bound checking, where bound checking is performed in hardware and in parallel with the execution of the memory accesses using dedicated hardware. There is reduced overhead associated with the enforcement of bound checking, and hardware is modified to include new registers and/or instructions for bound checking support. An exception is raised when an out of bound violation is detected. According to some embodiments, a compiler extracts bound information from the respective programming language (e.g. C/C++, Java) and generates tables with special APIs known to the hardware that enables both execution of the program and bound checking to be performed simultaneously.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09535613&OS=09535613&RS=09535613
owner: Futurewei Technologies, Inc.
number: 09535613
owner_city: Plano
owner_country: US
publication_date: 20141124
---
Embodiments of the present invention generally relate to the field of computer programming. More specifically embodiments of the present invention relate to methodologies for detecting illegal memory access during program execution.

Accessing or modifying data outside of an allocated address space is a well known problem in programming languages. An unintended memory reference can cause faults data corruption or breaches in the security of an entire system potentially causing substantial damage to the system and the underlying data. Memory references that occur outside of an allocated memory space may render software unreliable and these errors may be difficult to detect in many cases.

Programming languages such as Java for example implement secure memory access methodologies in programming semantics. In Java every memory access is guaranteed to be safe and within the range of addresses as intended by the programmer. However Java does not support the use of pointers to objects therefore it is much easier to enforce data access security in Java when compared to languages such as C C for example that do support the use of pointers. In C C knowledge regarding bounds to which a pointer to an object can point is lost and it is almost impossible to identify and test for potential illegal memory accesses at run time when the data is accessed.

Conventionally memory accesses bound checking is usually performed in software. A compiler generates bound checking code and memory address checking is performed at runtime. An error is issued if an out of bound memory addresses is detected. However this process substantially degrades performance of the code being executed because a substantial amount of checking is involved. Special compiler optimizations have been developed to move bound checks out of loops for example to code segments that are less frequently executed.

Some specialized hardware such as employed by certain types of Intel processors for example support software bound checking libraries e.g. Intel Parallel Studio XE 2013 to improve the performance of bound checking operations. Generally a compiler generates code and prepares bound checking data for the new hardware memory instructions. These machines execute bound checking code in parallel with the execution of the rest of the code using different cores. However pointers are excluded in these systems as mentioned above. Better bound checking is needed.

An approach to providing bound checking to insure memory access including indirect object access through pointers is within a range of defined object bounds is disclosed herein. Embodiments of the present disclosure provide hardware and software methodologies for bound checking where bound checking is performed in parallel with the execution of the memory accesses using dedicated hardware. There is reduced overhead associated with the enforcement of the proposed bound checking approach and hardware may be modified to include new registers and or instructions for bound checking support. An exception is raised in the case of an out of bound violation being detected. According to some embodiments a compiler extracts bound information from the respective programming language e.g. C C Java and generates tables with special APIs known to the hardware that enable execution of both the program and memory access bound checking to be performed simultaneously while the rest of the program executes.

According to some described embodiments an apparatus for detecting an illegal memory access by a software function is disclosed. The apparatus includes a register for storing a reference to a base address of a map table where the map table includes an object address and a size value of a memory operation of the software function where a legal memory range for the memory operation is computed based on the object address and the size value. The apparatus also includes a cache for storing the map table and a processor including an object construction module for generating a value pair comprising a first value and a second value for a declared pointer within the software function where the first value includes a current address of a memory operation of the software function the second value including a reference to the object address and the size value of the map table and where the declared pointer is initialized with a memory address of the value pair. The processor performs bound checking based on the legal memory range and the current address and signals an interrupt responsive to a memory address being outside of the legal memory range.

According to other embodiments a method is disclosed for detecting an illegal memory access by a software function. The method includes storing a reference to a base address of a map table in a register storing the map table in a cache where the map table comprises an object address and a size value of a memory operation of the software function where a legal memory range for the memory operation is computed based on the object address and the size value. A value pair comprising a first value and a second value for a declared pointer within the software function is generated where the first value includes a current address of a memory operation of the software function the second value includes a reference to the object address and the size value of the map table and where the declared pointer is initialized with a memory address of the value pair. Bound checking is performed based on the legal memory range and the current address and an interrupt is signaled responsive to a memory address being outside of the legal memory range.

According to other embodiments a method for detecting an illegal memory access by a pointer of a software function is disclosed. The method includes loading a pair of values pointed to by the pointer the pair of values including a first address and a second address. An upper address limit is determined by loading an ID value of a map table indicated by the second address and adding the ID value to a base address of a map table. A lower address limit is determined based on the first address and content of a memory location pointed to by the first address is retrieved. Responsive to the first address being between the lower address limit and the upper address limit the content is assigned to an object associated with the first address. Responsive to the first address being outside of the lower address limit and the upper address limit an error and or an interrupt is signaled.

Reference will now be made in detail to several embodiments. While the subject matter will be described in conjunction with the alternative embodiments it will be understood that they are not intended to limit the claimed subject matter to these embodiments. On the contrary the claimed subject matter is intended to cover alternative modifications and equivalents which may be included within the spirit and scope of the claimed subject matter as defined by the appended claims.

Furthermore in the following detailed description numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. However it will be recognized by one skilled in the art that embodiments may be practiced without these specific details or with equivalents thereof. In other instances well known methods procedures components and circuits have not been described in detail as not to unnecessarily obscure aspects and features of the subject matter.

Portions of the detailed description that follows are presented and discussed in terms of a method. Although steps and sequencing thereof are disclosed in a figure herein describing the operations of this method such steps and sequencing are exemplary. Embodiments are well suited to performing various other steps or variations of the steps recited in the flowchart of the figure herein and in a sequence other than that depicted and described herein.

Some portions of the detailed description are presented in terms of procedures steps logic blocks processing and other symbolic representations of operations on data bits that can be performed on computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. A procedure computer executed step logic block process etc. is here and generally conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout discussions utilizing terms such as accessing writing including storing transmitting traversing associating identifying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Some embodiments may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

In the following embodiments hardware and software methodologies for providing memory access bound checking are provided to insure memory accesses including indirect object accesses through pointers are maintained within the range of predefined object bounds defined by the programmer. According to embodiments of the present invention bound checking is performed in parallel with execution of memory accesses by dedicated hardware. Therefore overhead associated with address range enforcement in the proposed system is reduced and hardware is modified to comprise a new class of registers and instructions for bound checking support. These instructions are used to perform bound checking in parallel with the execution of memory access instructions. It is appreciated that an exception is raised when an out of bound violation is detected.

A compiler is an instrument used to provide automated bound checking. According to embodiments of the present invention a compiler extracts bound information from a respective programming language e.g. C C Java and automatically generates tables with special application programming interfaces APIs known to the hardware that enable the hardware to execute a program and simultaneously e.g. in parallel determine if a memory access is legal while the program executes.

With regard to an exemplary safe pointer to an object is depicted in a diagram according to embodiments of the present invention. As disclosed herein a pointer is a safe pointer if the pointer cannot be dereferenced to access a memory address outside of the bounds of the object to which it points. Safe pointers are initialized either to NULL or to an address of an object. An assignment to a safe pointer can be an address of an object or an assignment of another safe pointer. Furthermore as disclosed herein an object is a safe object if access to that object is performed using only safe pointers. An object or a pointer is not a safe pointer or object e.g. an unsafe object or pointer if it is not compiled by a compiler that generates safe code. Safe code is code that when executed does not attempt to perform illegal memory accesses.

In the following discussion all objects and pointers discussed are considered to be safe objects and safe pointers. Safe and unsafe pointers may coexist in an executable however according to the methodologies disclosed herein it is illegal to assign an unsafe pointer to a safe pointer however assignment of safe pointers to unsafe pointers is legal .

Still with regard to pointer P as depicted indirectly points to an object J that comprises two elements. A first element E indicates the address of a target object of P and a second element E points to an object e.g. a map table entry J. Entry J comprises a first element E that indicates a starting address of the target object and a second element E that indicates a size of the target object in bytes.

As depicted in an exemplary object A and exemplary pointer P are defined using the instructions of Table 1. Pointer P points to an address of a memory location J that has a pair of values the address of A 6 e.g. current address E and a pointer E to another object table entry J that has the address of A 0 e.g. object address E and its size E which is 400 bytes. Pointer P is a safe pointer because it cannot be dereferenced to access a memory address outside of the bounds of the object to which it points and is initialized either to an address of an object e.g. object J . Also object J is a safe object because object J is accessed using only safe pointers.

According to embodiments of the present invention a compiler and a loader are used to produce unique Address Size data pairs referred to as address size pair in predefined tables used by the hardware. When an object is declared or created in the program an entry is created in a predefined table. The scope of an object is either local or global. The scope of a global object comprises the entire program. Local scope objects are declared within a function body. The life time of a Local scope object ends when the function returns to its caller.

A global map is a table created and initialized by a loader and contains an address size pair for the globally scoped objects in the program. An offset value e.g. an ID in a global map indicates where information about the object is located and may be used to identify that object. Offset values IDs are used by the hardware memory operations to verify the legality of memory accesses at runtime.

A local map is a table created by a compiler at runtime for local variables. A local map is created for local objects and the structure of a local map is similar to the structure of a global map. A local map is allocated on a stack frame of a function and initialized upon entry of the function. A local map contains information about objects declared within the function body. A compiler generates code in the function to create and initialize a local map. An offset value e.g. an ID of a local map indicates where information about an object is stored and may be used to identify the object.

With regard to an exemplary memory resident map table is depicted according to embodiments of the present invention and comprises a local map table or a global map table. As depicted n is a variable that represents the total number of entries in map table . A first table entry comprises an ID offset value A of 0 an object address value B and a size value C. As described above an object address value indicates the location of the beginning of an object in memory. A size value of an entry in a local or global map table indicates a size of an object in bytes. A second table entry comprises an ID value A of 1 an object address value B and a size value C. The table contains other entries e.g. ID ID . . . ID n 1 that are not depicted in . A final table entry having an ID value A of entry n comprises an object address value B and a size value C.

A constructor of an object e.g. object construction module containing a pointer creates an address address pair value for the pointers declared within the object and initializes the pointer with an address of the pair. In other words a pointer points to the address address pair the object created. The two addresses in the address address pair are set to zero for an uninitialized pointer or a pointer initialized to NULL. For an initialized pointer the first address in the pair is the address of the target and the second address is an ID of the assigned object. Note that an ID is the offset of a map table e.g. a local or global map . It is appreciated that to determine an address of the object information the ID is added to the base address of the corresponding map. For example where pointer P B i an address address pair for pointer P is created by the constructor of P and contains an address of B i and an ID of object B in a map table. Where pointer P Q assignment of the address in pointer Q is moved to P. In other words the address address pair of Q is assigned to P.

With regard to an exemplary map table for performing bound checking is depicted according to embodiments of the present invention. In the example of K P.

An exemplary method comprising a sequence of computer implemented steps for performing bound checking is depicted by flowchart of according to embodiments of the present invention. The following references simultaneously. A hardware unit e.g. processor and or RAM of the computer system loads pointer P which points to address address pair Step . A hardware unit e.g. processor and or RAM determines if address of the pair is within a range of legal addresses by determining a base of a legal address by loading the ID value indicated by address Step . The ID offset value e.g. address is added to the base address e.g. address of the corresponding map table e.g. map table to produce an address upper limit Step . An address lower limit is determined based on the address of the object pointed to by address Step .

Hardware simultaneously loads address and retrieves the content e.g. data of the memory pointed to by the address . If the address is in a legal range the values loaded are assigned to K step . Otherwise if address address size an out of bound object access interrupt is signaled step .

According to some embodiments of the present invention dynamically allocated objects are considered global in scope. For example a memory allocation function e.g. malloc allocates an object on a heap at address X. The memory allocator function creates an entry E in a global map table and saves address X and the allocated size of the object in entry E. The address address pair for the allocated space is returned to the caller. Management and optimization of the entries created in the global map by the memory allocator are performed by the memory allocator. This process is very similar to the allocation of address address pairs for local variables. However in this case a global map entry is released when the object is destroyed. In the other cases local map table entries may be destroyed when the function returns.

With regard to an exemplary computer system for performing bound checking is depicted according to embodiments of the present invention. According to some embodiments a hardware unit e.g. processor or RAM comprises a special register e.g. register A or B for pointing to the base address of the global map table. A hardware unit e.g. processor and or RAM also comprises a dedicated cache e.g. cache A or B for holding IDs offsets and or memory bounds.

Memory instructions comprising an identifier are used by the hardware unit to identify an ID offset for bound checking purposes. The indicator identifying the ID may comprise a register an immediate field or part of a 64 bit memory address when bits are available. For example for computer systems comprising a 64 bit processor an address is usually 48 bits and 16 bits are available for other use. Data storage device may be used to store data that is accessed infrequently or to provide redundant storage in case of failure of a memory component e.g. RAM or ROM and ROM provides non volatile data storage. Processor is communicatively coupled with RAM for example to load and execute instructions as well as to store results output by processor . A constructor of an object e.g. object construction module containing a pointer creates an address address pair value for the pointers declared within the object and initializes the pointer with an address of the pair. Object construction module may comprise a compiler module for generating code and preparing bound checking data for new hardware memory instructions.

According to some embodiments of the present invention a dedicated cache e.g. cache A or B is used to maintain an ID table for storing ID offset values. According to some embodiments of the present invention additionally circuitry configured to flag out of bound memory references is provided.

With reference to a flowchart illustrating an exemplary process comprising a sequence of computer implemented steps for performing bound checking for a software function is depicted according to embodiments of the present invention. At step the process begins by generating and or storing a map table e.g. a local map table or a global map table in memory the table comprising an ID an object address and a size value for entries associated with software functions in a cache e.g. cache A or cache B . A legal memory range for a memory operation is computed based on the object address and the size value at step . A value pair comprising a first value and a second value is generated for a declared pointer within a software function at step . The first value comprises a current address of a memory operation of the software function and the second value comprises a reference to the object address and the size value of the map table. When a pointer is declared it is initialized with a memory address of the value pair. At step bound checking is performed based on the legal memory range and the current address. At step an interrupt and or an error signal is signaled responsive to a memory address to be accessed by the software function being outside of the legal memory range.

When a memory operation is executed a dedicated cache comprising an ID of the memory operation is accessed. Memory bound information may be obtained simultaneously with the memory accesses. A memory address pointed to by a pointer is safe if the memory address falls within a specified range defined by the ID. In the case of a violation an interrupt signal is generated which is handled by the interrupt handler. Safe memory access instructions have a field for the ID of the object referenced. The ID field indicates an offset of an associated global or local map table. The ID field may comprise an immediate e.g. a constant value and or may be in a register e.g. Register A and B . According to some embodiments of the present invention an ID field resident in a register enables pointer based access and large IDs that do not fit in an immediate field of a memory instruction. According to some embodiments of the present invention a register e.g. register A or B is used to maintain an address of a global map table.

As another example where P Q m a compiler generates the exemplary code depicted in Table 2. Instruction LDA loads a target address in the address address pair and adds it to r2 8. The result is stored in register r3. A hardware unit e.g. a processor and or memory determines in parallel if the computed address is within the range of the object pointed to by Q as specified in register r1 e.g. Q Real address m 8 . The hardware raises an exception if any of the bytes to be loaded are outside of an address space of the target object. Instruction STA stores the value in register r3 into the target address of pointer P retrieves the address address pair from register r4 and retrieves the target address and its corresponding map. Bound checking is performed as described above and the value in register r3 is stored if the address is determined to be legal.

As another example an address is stored in register r2 and a value is stored in register r1. A series of load check and store check instructions are performed according to Table 3. Vector or other instructions may be performed in a similar manner.

Embodiments of the present invention are thus described. While the present invention has been described in particular embodiments it should be appreciated that the present invention should not be construed as limited by such embodiments but rather construed according to the following claims.

