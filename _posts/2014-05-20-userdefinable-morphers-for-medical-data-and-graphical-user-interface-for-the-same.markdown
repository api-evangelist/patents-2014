---

title: User-definable morphers for medical data and graphical user interface for the same
abstract: Systems, methods, and computer-readable medium containing instructions for processing image data. One system includes at least one processor configured to generate a graphical user interface (“GUI”). Through the GUI, the at least one processor receives a matching condition and a morphing action from a user. The morphing action includes an action to perform on a data attribute associated with image data when the image data satisfies the matching condition. Based on the received matching condition and morphing action, the at least one processor creates executable code. The at least one processor also receives image data including an image data attribute and executes the executable code to determine if the received image data satisfies the matching condition. If the image data satisfies the matching condition, the at least one processor automatically performs the morphing action on the received image data attribute.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507914&OS=09507914&RS=09507914
owner: Merge Healthcare Incorporated
number: 09507914
owner_city: Chicago
owner_country: US
publication_date: 20140520
---
The present application claims priority to U.S. Provisional Patent Application No. 61 847 142 filed on Jul. 17 2013 the entire content of which is hereby incorporated by reference.

Embodiments of the present invention relate to systems and methods for allowing users to define morphers for medical data such as medical images.

In the field of medical imaging vendors each have their own implementation of various standards such as the Digital Imaging and Communications in Medicine DICOM standard. Therefore discrepancies can arise because different systems have different understandings usages and management of the DICOM standard i.e. the DICOM attributes associated with medical imaging and other such standards.

Morphers can be used to fix the discrepancies referenced above. Morphers are small software modules that alter DICOM image attributes e.g. a patient identifier patient name issuers of patient identifiers etc. and image attributes following other standards using morphing actions when certain matching conditions are met. It should be noted that although the following description references the DICOM standard the present invention is equally applicable to other types of imaging standards. Accordingly the DICOM standard is referenced below only by way of example and for ease of description. In some embodiments a morpher is used on a DICOM image received by an archive from a designated source e.g. into a vendor neutral archive VNA output to another archive or DICOM compliant entity or based on other specific events such as a query . Matching conditions are conditions that should be met before the associated morphing action or actions are executed on a dataset that alters DICOM image attributes. A matching condition can include whether an image attribute matches a particular value or falls within a range of values whether an image attribute exists etc. For example an example matching condition may be the value of attribute patient identifier starts with the letter A or the value of attribute image modality is CR. In some embodiments a matching condition evaluates to a TRUE value or a FALSE value.

A morphing action is the corresponding action that is performed when matching conditions are met. For example a morphing action can delete an image attribute add an image attribute or modify an image attribute e.g. add a prefix INT to a patient name .

Morphers are currently programmed into archiving systems and typically have a high level of complexity. Therefore new morphers usually have a long lead time because a programmer typically has to code a new morpher to handle every new or different customization.

Accordingly embodiments of the present invention provide methods and systems for allowing users to define edit and simulate morphers. One embodiment of the invention provides a graphical user interface GUI that allows users to define edit and simulate morphers. In some embodiments the morphers are defined using a specialty programming language and are processed by a morphing engine that includes a rules engine and a morphing core. The rules engine assembles the code for each user defined morpher and the morphing core initializes and executes a morpher.

In some embodiments the invention provides a method of processing image data and includes generating by a processor a graphical user interface for display to a user receiving by the processor a matching condition from the user through the graphical user interface and receiving by the processor a morphing action from the user through the graphical user interface. The morphing action can include an action to perform on a data attribute associated with image data when the image data satisfies the matching condition. The method can also include automatically creating by the processor executable code based on the morphing action and the matching condition. Furthermore the method can include receiving image data including an image data attribute automatically executing the executable code to determine if the received image data satisfies the matching condition and when the image data satisfies the matching condition automatically performing the morphing action on the received image data attribute.

Some embodiments of the present invention provide a system for processing image data having at least one processor configured to generate a graphical user interface GUI wherein through the GUI the at least one processor receives a matching condition and a morphing action from a user and wherein the morphing action includes an action to perform on a data attribute associated with image data when the image data satisfies the matching condition. Based on the received matching condition and morphing action the at least one processor can create executable code. The at least one processor can also receive image data including an image data attribute and can execute the executable code to determine if the received image data satisfies the matching condition. If the image data satisfies the matching condition the at least one processor can automatically perform the morphing action on the received image data attribute.

In some embodiments the present invention provides non transitory computer readable medium that contains executable instructions for generating a graphical user interface for display to a user receiving a matching condition from the user through the graphical user interface receiving a morphing action from the user through the graphical user interface and automatically creating executable code based on the morphing action and the matching condition. The morphing action can include an action to perform on a data attribute associated with image data when the image data satisfies the matching condition. The medium can further contain executable instructions for receiving image data including an image data attribute automatically executing the executable code to determine if the received image data satisfies the matching condition and when the image data satisfies the matching condition automatically performing the morphing action on the received image data attribute.

Other aspects of the invention will become apparent by consideration of the detailed description and accompanying drawings.

Before embodiments of the present invention are explained in detail it is to be understood that the invention is not limited in its application to the details of construction and the arrangement of components set forth in the following description or illustrated in the accompanying drawings. The invention is capable of other embodiments and of being practiced or of being carried out in various ways.

Also it is to be understood that the phraseology and terminology used herein is for the purpose of description and should not be regarded as limited. The use of including comprising or having and variations thereof herein is meant to encompass the items listed thereafter and equivalents thereof as well as additional items. The terms mounted connected and coupled are used broadly and encompass both direct and indirect mounting connecting and coupling. Further connected and coupled are not restricted to physical or mechanical connections or couplings and can include electrical connections or couplings whether direct or indirect. Also electronic communications and notifications may be performed using any known means including direct connections wireless connections etc.

It should be noted that a plurality of hardware and software based devices as well as a plurality of different structural components may be utilized to implement the invention. In particular when terms such as controller control unit module etc. are used in the following detailed description it should be understood that these terms can represent non transitory computer readable medium encoded with instructions that when executed by a processing unit result in various actions and computations. Furthermore and as described in subsequent paragraphs the specific configurations illustrated in the drawings are intended to exemplify embodiments of the invention and that other alternative configurations are possible.

As noted above embodiments of the invention provide methods and systems for allowing a user to define and manage morphers e.g. creating editing deleting simulating etc. . schematically illustrates a system according to an embodiment of the invention. The system includes a computing device . The computing device can include a desktop computer a laptop computer a tablet computer a smartphone or another device configured to execute instructions and provide output. As illustrated in the computing device includes a processor a memory module including computer readable medium and an input output interface . The processor memory module and input output interface are connected by one or more connections such as a system bus. It should be understood that although only one processor memory module and input output interface are illustrated in the computing device can include multiple processors memory modules and or input output interfaces .

The processor retrieves and executes instructions stored in the memory module . The processor can also store data to the memory module . The memory module can include a non transitory computer readable medium and can include volatile memory non volatile memory or a combination thereof. As illustrated in the memory module can store a morpher application . As described below in more detail the morpher application when executed by the processor allows a user to define edit and configure morphers i.e. executable code that automatically performs a predetermined morphing action on data that satisfies a predetermined matching condition . In particular the application can generate a graphical user interface GUI that allows a user who may have little or no programming experience to design a morpher. It should be understood that the morpher application can be distributed among multiple applications or modules. For example in some embodiments the morpher application includes a rules engine and a morpher core. As described in more detail below the rules engine can be configured to create morphers whereas the morpher core initializes and executes morphers. In some embodiments the memory also stores morphers created through the application and or through other means.

The input output interface can exchange information with one or more external devices or systems. For example the computing device can communicate with one or more peripheral devices such as a monitor or screen a keyboard a mouse a printer etc. through the input output interface . For example as noted above the processor can execute the application to generate a GUI that is transmitted to and displayed by a monitor or screen. It should be understood that in some embodiments the monitor is included in the computing device rather than as an external peripheral device.

The computing device can also communicate with one or more data sources through the input output interface . For example the data source can include a database that stores medical image data and the computing device can receive image data from the data source and or transmit image data to the data source for storage. In some embodiments the data source can also include an imaging modality or other device that generates or provides image data.

As illustrated in in some embodiments the computing device also communicates with one more external devices over at least one network e.g. via a TCP IP LAN or WAN connection through the input output interface . For example the computing device can communicate with a data source over the network . Alternatively or in addition the computing device can communicate with other computing devices over a network. For example in some embodiments the computing device stores the morpher application and a user directly interacts with the computing device to use and interface with the morpher application . In other embodiments the computing device stores the morpher application but hosts the morpher application as a server accessible by a user indirectly through the use of another computing device e.g. through a browser application executed by the user s computing device . Furthermore in some embodiments the computing device may interact directly with a user but may request data from other computing devices such as other servers e.g. storing information regarding existing morphers .

As noted above the morpher application interacts with a user to manage morphers. In some embodiments the application can create a GUI that allows a user to create new morphers and manage existing morphers. For example shows a management screen of a GUI generated by the morpher application that allows a user to manage existing morphers and create new morphers. The screen can include selection mechanisms for selecting different categories of morphers. For example the screen can include a customer managed morpher selection mechanism and a professionally managed morpher selection mechanism . A user can select the customer managed selection mechanism to access existing customer managed morphers and create new customer managed morphers. Similarly a user can select the professionally managed selection mechanism to access existing professionally managed morphers and create new professionally managed morphers.

Professionally managed morphers can include morphers created by individuals having detailed knowledge of a specific programming language e.g. JAVA as well as the DICOM standard and archiving fundamentals. For example the professionally managed morphers can be directly written by individuals in source code. In contrast user created morphers are morphers created by users through the application and in particular through the GUI generated by the application as described below. Therefore user created morphers insulate users who are creating or modifying the morpher from the internals of the archive and the specific programming used to code the morphers. Accordingly the user created morphers require minimal knowledge of the DICOM standard to be able to create and or modify morphers. In some embodiments only the user created morphers are editable by a user through the application . In other embodiments each user may be assigned different access read and write rights that govern what morphers the user may access and how the user can interact with e.g. modify such morphers.

Both the user created morphers and the professionally managed morphers can include further categories of morphers. For example morphers can be categorized as an input morpher a query morpher an output morpher or a query result. Input morphers are executed when an image is received at a data source and output morphers are applied to images leaving a data source e.g. for transmission to and storage in a different data source . Query morphers are applied to queries performed for stored images within a data source and query result morphers are applied to the results of a query performed for stored images within a data source . It should be understood that other categories of morphers can be used to handle other types of transactions performed with images or other data. Furthermore in some embodiments no categories of morphers are used. Also in some embodiments a user can access a directory of all existing morphers to locate morphers of interest i.e. rather than drilling down through categories of morphers .

Each category of morpher can be associated with a create morpher selection mechanism see . A user can select the create morpher selection mechanism to add a new morpher to the associated morpher category. In some embodiments the application also allows a user to create a new morpher without initially defining a category for the new morpher. is a flowchart illustrating a method performed by the morpher application to create a new morpher. As shown in to start the creation process the application receives configuration data for the new morpher at block . For example displays a new morpher creation screen . The screen includes various inputs that allow a user to provide configuration data for a new morpher. The inputs can include a morpher name input a morpher description input and a morpher type input . The screen can also include an application entities AEs input that allows the user to select applications associated with the new morpher. In particular a morpher can be configured to be applied only to data e.g. images supplied from particular application s e.g. a query application an output application etc. . Therefore a user can select the AEs for each new morpher. In some embodiments the screen includes a list of available AEs and a user can use the list to identify and select one or more AEs for the new morpher. Alternatively default AEs can be assigned to each new morpher.

Within the morpher creation screen a user can also enable and disable the morpher such as by selecting or unselecting a Morpher is Enabled checkbox . Additional information regarding enabled versus disabled morphers is provided below. Accordingly the configuration data for the new morpher specifies identifying information for the morpher and the parameters in which the new morpher will be applied.

Returning to the application also receives one or more matching conditions for a new morpher at block . For example as illustrated in the morpher creation screen also includes a matching conditions input . A user can add edit and delete matching conditions from the input using one or more selection mechanisms . The input can also be associated with a sample rule selection mechanism that allows a user to view a sample matching condition. For example as illustrated in the application can generate a window that displays a sample matching condition . In some embodiments the sample matching condition is based on input previously provided by the user. In other embodiments the sample matching condition is unrelated to any input previously provided by the user e.g. the condition is a default condition displayed anytime the user selects the sample rule selection mechanism . Accordingly in some embodiments the application prevents a user from modifying the sample matching condition . However in other embodiments a user can perform certain functions on the sample matching condition such as copying the condition or a portion thereof editing the condition etc.

A matching condition includes an argument an operand and an operator. In some embodiments a matching condition evaluates to a TRUE value or a FALSE value. The argument specifies data used as an input to the operand. The operand specifies an operation applied to the argument and the operator specifies operations performed on the output of the operand. An operator can be a unitary operator that operates on just the output of the operand e.g. an is empty operator or a binary operator e.g. a less than or greater than operator that operates on the output of the operand in conjunction with operation data e.g. constants predetermined strings or datasets etc. .

For example an argument can include a DICOM tag a DICOM sequence tag or an item within a sequence. Similarly an operand can include an age operand that calculates the days between a date and today s date a data element operand that extracts a data element from a dataset a length operand that calculates the length of a value of an argument a value operand that extracts the value of the image attribute a value representation VR operand that extracts a value representation of an image attribute or a value multiplicity VM operand that extracts the value multiplicity of an image attribute. For example below is an example portion of a DICOM file represented in a human readable format 

Each line is a data element of the DICOM file. Each data element is identified by a tag which includes a group and an element number. The tag is denoted within single parentheses such as 0010 0010 . Each data element also includes a value representation e.g. character string name integer date code etc. . The value representation is denoted within the angle brackets such as . For example the PATIENTBIRT data element identified by the tag 0010 0030 is in date or DA format which can include an eight digit data string formatted as YYYYMMDD. The VR operand reads the value representation from a data element.

Each data element also includes a value multiplicity. The value multiplicity indicates whether a data element contains only value of its type or several values e.g. how many values per attribute . The value multiplicity is denoted with the square brackets and such as 0.20 0.20 . If a data element has several values the values listed in the value multiplicity are separated by backward slashes . The VM operand reads the number of values from the value multiplicity. For example the PATIENTNAME data element identified by the tag 0010 0010 has a value multiplicity of CREST MAGGIE which includes only a single value i.e. the value multiplicity does not include any backward slashes separating values. Therefore the VM operand would return a value of 1 for the PATIENTNAME data element. In contrast the IMAGERPIXELSPACING data element identified by the tag 0018 1164 has a value multiplicity of 0.20 0.20 which includes two values separated by a backward slash. Therefore the VM operand would return a value of 2 for the IMAGERPIXELSPACING data element.

For example a matching condition can include an argument that includes a DICOM tag an operand that extracts the value of the DICOM tag and an operator that determines whether the extracted value of the DICOM tag is equal to a predetermined value. Similarly a matching condition can include an argument that includes a DICOM tag an operand that extracts the value of the DICOM tag and an operator that determines whether the extract value of the DICOM tag matches a predetermined string.

In some embodiments a user can select a matching condition or elements thereof from a list or look up table. For example illustrates a lookup window displaying available matching conditions in a list . If the user selects one of the available matching conditions from the list the application adds the selected matching condition to the input .

A user can also add a matching condition to the input by selecting each element of the condition from lists of available options for each element. For example if a user selects an Add selection mechanism on the screen the application can display an add condition window as illustrated in . A user can use the addition condition window to select an argument e.g. a DICOM tag from an argument list or enter an argument using an argument input . A user can also use the window to select an operand from an operand list select an operator from an operator list and optionally enter a value associated with the operator using a value input . After making the desired selections the user selects the OK selection mechanism and the application automatically adds a matching condition to the input field based on the user selections.

In some embodiments a user can define more than one matching condition to create a composite condition. A composite condition is composed of individual matching conditions that are connected together by logic operators such as in the case of a user entering more than one matching condition user selection of two or more of the matching conditions to create a composite condition. For example after selecting two or more matching conditions e.g. within the input the application can display an add composite condition window see e.g. . The add composite condition window allows a user to tie two or more conditions together using a logic operator e.g. AND OR NOT etc. . In some embodiments after grouping a set of matching conditions into a composite condition the application allows a user to tie the composite condition to other matching conditions or even other composite conditions. By creating a composite condition that has multiple levels a user can create a powerful and effective matching condition for any situation. For example illustrates a sample composite matching condition . After creation composite matching conditions can be illustrated in the input e.g. as illustrated in like any other matching condition.

Optionally similar to defining matching conditions a user can use the morpher creation screen see to define exclusion conditions. Exclusion conditions exclude particular images that otherwise satisfy the matching condition s for a morpher. Exclusion conditions can be added edited and deleted using an exclusion conditions input and selection mechanisms as described above for the matching conditions. Similarly a user can select a sample rule selection mechanism that allows a user to view a sample exclusion condition. For example as illustrated in the application can generate a window that displays a sample exclusion condition . In some embodiments the sample exclusion condition is based on input previously provided by the user. In other embodiments the sample exclusion condition is unrelated to any input previously provided by the user e.g. the condition is a default condition displayed anytime the user selects the sample rule selection mechanism . Accordingly in some embodiments the application prevents a user from modifying the sample exclusion condition . However in other embodiments a user can perform certain functions on the sample exclusion condition such as copying the condition or a portion thereof editing the condition etc.

Returning to in addition to receiving one or more matching conditions the application also receives one or more morphing actions from the user at block . The morphing action defines changes to make to an image e.g. to one or more image attributes which can include a patient identifier a patient name or an issuer of a patient identifier when the image satisfies the corresponding matching conditions. Similar to a matching condition a morphing action can include an operand an argument and an operator. The morphing action applies the operator to the results of applying the operand to the argument. For example an argument for a morphing action can include a DICOM tag. An operand for a morphing action can include a construct operand that constructs a data element with a specified tag and a data element operand that extracts a data element from a dataset. An operator for a morphing action can include for example 

In some embodiments a user can use the morpher creation screen to input the morphing action for a new morpher. For example a user can select an Actions tab see on the screen to access an action input that operates similar to the matching condition input . For example if a user wants to add a morphing action the user can select an Add selection mechanism to access an action selection window as illustrated in . The window can include an actions list that lists available actions or operators. After selecting an action from the window the application can display a property window as illustrated in . The property window allows a user to select the source argument e.g. a DICOM tag using a list of available tags . Alternatively a user can manually enter a tag into a tag input . Additionally if the user selected action is associated with a value e.g. add 5 to value of a tag a user can manually enter the value using a value input .

In some embodiments a user can define a composite morphing action. A composite morphing action includes two or more morphing actions. When a user specifies a composite morphing action each morphing action included in the composite morphing action is applied when the corresponding matching condition s are satisfied.

Returning to after receiving matching condition s and morphing action s from the user for a new morpher the application automatically creates a morpher i.e. executable code based on the received matching condition s and morphing action s at block . As noted above in some embodiments the application includes a rules engine and a morphing core wherein the rules engine is configured to create morphers. In some embodiments the rules engine codes the morphers in a specialty morpher or rules language. In this morpher language matching conditions and morphing actions can have the following structure by way of example only DICOM Operand ArgumentType ArgumentValue Operator OperationData where DICOM is a keyword for the language specifying a DICOM Condition or DICOM Action Operand is the object of an operation a quantity on which an operation defined by an operator is performed ArgumentType specifies a classification identifying the various types of data that can be used as an input for the operand ArgumentValue specifies input data for an operand to function on Operator specifies the operations that can be performed on the results of the operand using operation data as described above and can include a unary operator or a binary operator and Operation Data specifies data used to perform an operation in conjunction with an operand.

Examples of matching conditions and morphing actions using an example morpher language are provided below. In particular exemplary matching conditions can include the executable code illustrated by cases 1 3 below 

Case 1 Standalone DICOM Condition with Unary Operator DICOM DATAELEMENT TAG 00280008 EXISTS where DICOM is a reserved keyword for the morpher language DATAELEMENT specifies the DATAELEMENT operand which extracts from a given dataset represented by the Argument Value and is a reserved keyword TAG specifies the Argument Type and is a reserved keyword. 0028008 specifies the Tag represented by group number 0028 and part number 0008 . This tag will be evaluated by the DATAELEMENT operand and is extracted from the dataset. EXISTS represents the exists operator which is a unary operator and checks for the existence of the tag specified in the Argument Value in a given dataset. Again EXISTS can be a reserved keyword.

Case 2 Standalone DICOM Condition with Binary Operator DICOM VALUE TAG 00280008 0 where DICOM is a reserved keyword and VALUE specifies the value operand which extracts the value of given tag. TAG specifies the Argument Type and is also a reserved keyword. 0028008 specifies the Tag represented by group number 0028 and part number 0008 . This tag will be evaluated by the VALUE operand to extract its value. represents the equals operator and compares the value extracted by the VALUE operand to the value specified in the operation data. If both values match the equals operator returns TRUE. Otherwise if the values do not match the equals operator returns FALSE. Like other operators is a reserved symbol for the morpher language. Finally 0 specifies the operation data for the equals operator.

Case 3 Composite DICOM Conditions AND DICOM DATAELEMENT TAG 00280008 exists DICOM VALUE TAG 00280008 0 

As noted above a composite matching condition is composed of individual matching conditions and or other composite matching conditions connected together by a logic operation e.g. AND OR NOT etc. . Therefore a composite matching condition can have one of the following formats AND Term Term . . . Term OR Term Term . . . Term NOT Term Term . . . Term where Term is a matching condition or a composite condition and AND OR NOT are reserved keywords for the morpher language.

Similar to the sample matching conditions exemplary morphing actions are illustrated by cases 4 6 below 

Case 4 Standalone DICOM Action DICOM DATAELEMENT SOURCETAG 00280008 DELETE where DICOM is a key word DATAELEMENT is an operand that extracts the data element represented by the argument value in the dataset and is a reserved keyword for the morphing language and SOURCETAG is another key word and specifies the Argument Type. As noted above 0028008 specifies the tag represented by group number 0028 and part number 0008 . DELETE represents the unary delete operator that deletes the tag represented by the Argument Value in the dataset and is a reserved keyword for the Language.

Case 5 DICOM Action with Binary Operator and Operation Data DICOM DATAELEMENT SOURCETAG 00100020 FLIP DESTINATIONTAG 00280080 where DICOM is a key word and DATAELEMENT is an operand that extracts the data element represented by the argument value in the dataset and is also a reserved keyword. SOURCETAG specifies the Argument Type and is a reserved keyword and 0010020 specifies the Tag represented by group number 0010 and part number 0020 . As noted above FLIP represents the binary Flip operator that flips the value of the source tag with the value of the destination tag. DESTINATIONTAG specifies the Operation Data Type and is a reserved keyword and 0028008 specifies the tag represented by group number 0028 and part number 0080 .

Case 6 Composite DICOM Action DICOM DATAELEMENT SOURCETAG 00100020 FLIP DESTINATIONTAG 00080080 DICOM DATAELEMENT SOURCETAG 00181318 ROUND 

As noted above a composite morphing action is composed of individual DICOM Actions and can be separated by commas. Therefore a composite morphing action can have the following format Term Term . . . Term where Term is a morphing action.

Just like other large and small programming languages the morpher language can be supported by a grammar. A grammar is a set of structural rules that govern the composition of phrases and words in a given language. The morpher language can be associated with a parser and a syntax tree builder e.g. using Java Compiler Compiler JavaCC and Java Tree Builder JTB respectively and passing each component a grammar file associated with the morpher language . JTB see http compilers.cs.ucla.edu jtb is a syntax tree builder used with the JavaCC parser generator. The JTB takes a JavaCC grammar file as input and automatically generates the following 

JavaCC see http javacc.java.net is a parser generator for use with Java applications. A parser generator is a tool that reads a grammar specification and converts it to a Java program that can recognize matches to the grammar. In addition to the parser generator itself JavaCC provides other standard capabilities related to parser generation such as tree building via a tool called JJTree included with JavaCC actions debugging etc.

Morphing conditions and morphing actions abstract syntax tree walkers are also created within the rules engine by implementing the Visitor Design Pattern. These tree walkers traverse the syntax tree created by JTB for morphing conditions or morphing actions by going to each token node and creating an object hierarchy structure that can be used by the morphing core when initializing and executing a morpher.

It should be understood that the rules engine can be designed in such a way that it is extendable to other areas within the vendor neutral archive and other Java based products and is not limited to being implemented or used using the JAVA language or associated products.

After the rules engine creates a morpher the morpher can be executed i.e. applied to received image data . In some embodiments a generated morpher is applied by the application . However it should be understood that in some embodiments a separate application executes generated morphers. For example in some embodiments the application receives image data at block and executes existing and enabled morphers to apply the morphers to the image data at block . Receiving image data can include receiving an image that is associated with one or more image attributes. The received image can be received from a data source searched for queries in a data source returned as a search result from a data source or transmitted to a data source . The way an image is received can define the type of morphers applied to the image. In particular and as described above morphers can be grouped into an input morpher category a query morpher category an output morpher category and a query result morpher category by way of example.

In some embodiments the morphing core is responsible for initialization and execution of a morpher. In particular and with reference to java programming language by way of example only the rules engine when called by the morphing core upon initialization of a morpher returns a java object hierarchy tree representation of a morpher different from the abstract syntax tree representation to the morphing core. The java object hierarchy tree representation returned by the rules engine is then used by the morphing core to execute a morpher based on the occurrence of specific events e.g. when DICOM images coming from a designated source are injected into a data source or sent out of a data source as part of a data query etc. .

The morphing core executes a morpher to determine if the received image data satisfies the matching conditions associated with the morpher at block . In other words the application determines if a value of an image attribute of the received image data satisfies the matching condition. If the value of the image attribute does not satisfy the specified matching condition the morphing action associated with the morpher is not performed. However if the value of the image attribute satisfies the specified matching condition the morpher core performs the corresponding specified morphing action on the image at block . In particular the morphing core can automatically perform the morphing action by modifying a value of at least one attribute of the received image. It should be understood that the image attribute modified according to the morphing action can be the same or different than the image attribute used with the matching condition. It should also be noted that the morphing core can be designed to be backwards compatible. Therefore the morphing core can initialize and execute legacy morphers e.g. created using previous versions or configurations of the morpher language .

As noted above the application can be used to create new morphers and manage existing morphers. In particular and as illustrated in each category of morphers can include an expand selection mechanism that a user can select to view and manage the associated category of morphers. For example illustrates the screen that is displayed after a user selects the expand selection mechanism for the input morpher category. As illustrated in selecting the expand selection mechanism for a particular category causes the GUI to display a list of existing morphers for the category. Each existing morpher can be identified by a morpher name e.g. Flip Institution and Department . In some embodiments as illustrated in a user can select the name of an existing morpher or select an expand selection mechanism associated with each existing morpher to view details about the morpher such as the matching conditions and morphing actions for the morpher a description of the morpher an indication of whether the morpher is enabled or disabled a designation of what data source s e.g. application s the morpher is associated with etc.

For each existing morpher a user can use the GUI to access a menu of available options for the morpher. As illustrated in the menu can allow a user to edit delete enable disable simulate copy prioritize export and or input a morpher. Editing a morpher can include allowing the user to modify the matching condition and or the morphing action described below in more detail with respect to creating a new morpher . Editing an existing morpher in this manner is similar to creating a new morpher as described below. Editing a morpher can also include displaying source code to the user associated with the morpher and allowing the user to directly modify the code. In some embodiments users may require particular write rights to directly modify morpher code.

In some embodiments editing an existing morpher is performed similar to creating to a new morpher. For example illustrate a morpher edit window . Similar to the screen the window includes a name input a description input a type input an AE input a matching conditions input and an exclusion conditions input . As illustrated in the screen also includes a morphing actions input . A user can use these inputs to modify a morpher s configuration data matching conditions and or morphing actions.

Deleting a morpher removes the morpher from the list of existing morphers. In some embodiments deleting a morpher can delete the morpher temporarily such that the morpher is only deleted from the list of morphers but is still stored elsewhere or permanently such that the morpher is deleted from both the list of morphers and a stored location .

In some embodiments rather than deleting a morpher a user may desire to disable the morpher which retains the morpher in the list of existing morpher but marks the morpher as being disabled i.e. not being applied to image date . Disabling a morpher causes the morpher to remain inactive despite the matching condition being met such that the morpher is not applied to any image attributes while disabled. For example a user might disable a morpher to place that morpher on hiatus such as to enable a different morpher for modifying image attributes having the same matching condition. This can be done for example to provide various potential morphing actions for the same matching condition without having to frequently update existing morphers. Further a user may wish to disable a morpher whose actions conflict with those of another morpher. For example two morphers may have the same matching condition but opposing actions e.g. one is configured to add certain information while the other is configured to delete that information . In such cases a user may wish to disable one of the conflicting morphers without permanently deleting it such that the disabled morpher can be used again in the future.

After disabling a particular morpher a user can re enable the morpher. Enabling a morpher allows that morpher to be applied to an image attribute when the corresponding matching condition is met. As illustrated in in some embodiments an existing morpher is listed or displayed differently based on whether the morpher is currently enabled. For example enabled morphers can be displayed in a different color e.g. dark gray than disabled morphers e.g. light gray . Alternatively or in addition disabled morphers can be displayed in a different font or style e.g. strikethrough than enabled morphers.

Simulating a morpher allows a user to test or simulate the functionality performed by a particular morpher on a given dataset e.g. sample image data . In some embodiments the application is configured to generate a simulation report at the end of each simulation that enumerates the results of a simulation on a dataset e.g. a DICOM dataset . The simulation can be performed in memory so the specified dataset on disk is not changed. In some embodiments as part of running a simulation the user can select the dataset e.g. the DICOM file for the simulation to use via a simulate morpher window as illustrated in . After running the simulation the system can generate a simulation report as illustrated in . The simulation report identifies which tags were edited which matching conditions of the simulated morpher were matched and which actions were performed on the selected dataset. In some embodiments the system also allows a user to simulate a group of morphers by selecting a simulate group selection mechanism . For example shows a file selection window for simulating a morpher group. As with simulating a single morpher simulation reports can be generated for each group of morphers simulated. For example illustrate simulation reports for two different simulations performed on two different groups of morphers.

Copying a morpher makes a copy of an existing morpher which can be used as the starting point for a new morpher. The new copied morpher can be added to the list of existing morphers e.g. for the same category as the original morpher . In some embodiments the copied morpher can be associated a default name e.g. a name including the name of the original morpher . The copied morpher can have the same matching condition and or morphing action as the original morpher. Accordingly if a user wants to create a morpher that performs the same or a similar morphing action and or checks for the same or a similar matching condition as an existing morpher a user can copy the existing morpher and modify the copied morpher as necessary.

In some embodiments morphers can be prioritized. For example in some embodiments the order that existing morphers are displayed under a particular category designates the order in which the morphers are applied in practice. Accordingly in some embodiments existing morphers listed on the screen can be prioritized by clicking on an existing morpher and dragging the morpher to a desired place within the list of existing morphers.

In some embodiments the application also allows a user to import and export morphers. In particular an existing morpher managed through the application can be written to a flat file or another storage location type. Morphers can also be imported to the application e.g. as a flat file . For example illustrate windows that can be presented to a user for importing morphers. In particular illustrates a dialog box that includes a browse selection mechanism and an import selection mechanism . Selecting the browse selection mechanism opens a file selection window to help the user select the desired import file see . When the user selects one or more files for importation the selected files are in an input field of the dialog box see . Selecting the import selection mechanism imports the displayed files to the memory or another storage location associated with the application and responsible for storing morphers.

As illustrated in in some embodiments some or all of the functions available for existing morphers are provided as selection mechanisms e.g. icons in place of or as an alternative to the drop down menu . For example as illustrated in each existing morpher can be associated with an edit icon a simulate icon a copy icon a delete icon an enable icon a disable icon and a prioritize icon .

It should be understood that in some embodiments the functionality of particular drop down menu selections or selection mechanisms can be customized based on user preferences e.g. automatically deleting morphers temporarily vs. permanently simulating a morpher based on a predetermined data set placing a copy of a morpher into a particular category and or priority etc. .

Thus embodiments of the present invention provide among other things systems and methods for allowing users to define and manage morphers within the medical imaging industry. It should be understood that the functionality of the systems and methods described herein can also be used for other types of medical image processing such as prefetching and hanging protocols HPs . An HP is a set of rules for arranging images for optimal softcopy viewing within a picture archiving and communication system PACS context. For example one goal of an HP is to increase a radiologist s efficiency by eliminating the time otherwise required by the radiologist to manually reorder of the images for viewing and diagnosis. HPs also ensure consistent presentation of images for a particular type of study. HPs can vary based on modality body part department personal preference etc. A common interface e.g. a common GUI however can be used for these different types of images processing which increases ease of use and efficiency of the systems and methods. In addition to HP applications other medical industry related applications of the functionality can include rule creation for medical image routing creation and execution of image deletion policies creation of image decompression rules reassignments HL7 mapping morphing XDS family of standards transfer mappings morphing ANSI interchange standard for patient monitoring and telemetry desktop application interfaces e.g. mapping of context and operations between multiple applications and various point to point communications schemes. Similarly it should be understood that the functionality can be used outside of the medical imaging industry.

