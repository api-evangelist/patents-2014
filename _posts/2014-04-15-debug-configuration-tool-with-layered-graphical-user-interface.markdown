---

title: Debug configuration tool with layered graphical user interface
abstract: A debug configuration tool for configuration of on-chip debug features comprises a database comprising predefined analysis points, each relating to a configurable chip entity, and comprising a configurable condition and a configurable action for the chip entity, a plurality of predefined analysis groups, each relating to a group of configurable chip entities, and comprising a configurable condition and a configurable action for the group of chip entities. The tool comprises a graphical user interface module arranged to display representations of at least some of the analysis points and the analysis groups on different levels of detail, and to receive input from a user to set the configurable conditions and/or actions for the displayed analysis points and the analysis groups. An application program interface module processes data received from the graphical user interface module to obtain debug settings and to communicate the debug settings to a debug target system configuration module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483373&OS=09483373&RS=09483373
owner: FREESCALE SEMICONDUCTOR, INC.
number: 09483373
owner_city: Austin
owner_country: US
publication_date: 20140415
---
The present application is claims priority to Romanian Patent Application No. 2014 00118 filed Feb. 14 2014 entitled DEBUG CONFIGUREATION TOOL WITH LAYERED GRAPHICAL USER INTERFACE the entirely of which is herein incorporated by reference.

This invention relates to a debug configuration tool for configuration of on chip debug features and to a method for configuration of on chip debug features.

Today s complex systems on chip SoC encompass hardware acceleration blocks many cores and buses. Functionality issues and performance problems in such complex systems are not easy to analyse. One of the difficulties is the configuration of the on chip debug features on these systems. As an example there are more than 250 debug configuration registers associated with the Data Path Acceleration Architecture DPAA block of the so called QorIQ processors.

Users are focused to learn about system and modules functionality and do not have the time budget to also dig into the details of the on chip debug hardware. Instead they require a way to easily configure the debug features to obtain visibility into the performance and the behaviour of sub systems such as cores hardware acceleration blocks bus memory and interconnections.

The engineers working with complex SoCs do not have facile means to describe a debug configuration which in such systems could include hundreds of registers in order to obtain visibility into the system s activity. Engineering teams are mostly specialized in one or more subsystems. However when debugging they cannot ignore the interaction with other blocks in the system. They might need more details of the subsystems for which they are experts in while for the other subsystems they might need only a high level perspective.

Known methods to configure debug IP modules have not addressed well the above problems. Most of the tools are only targeting the software debug i.e. processing cores only and configuration APIs are usually just exposing the debug registers so the user would need to be knowledgeable of the debug IP modules. Some debug configurations can be described in XML files but such methods proved very error prone e.g. in CodeWarrior user would need to modify a 9000 line file to define a DPAA debug configuration .

Most of the known debugging tools provide a graphical user interface GUI for interaction with a user. The known GUIs are used to simply expose the debug register contents.

Elements in the figures are illustrated for simplicity and clarity and have not necessarily been drawn to scale. In the Figures elements which correspond to elements already described may have the same reference numerals.

The different components of the DPAA module may comprise debug IP registers not shown in from which data can be read and in which data can be written by a debugger configuration tool. The debugger tool may be running on a computer which is connected to the QorIQ chip via a debug adapter such as a state of the art JTAG Joint Test Action Group module.

Current debugger tools are mainly used to debug the software running on cores. A configuration component of a traditional GUI debugger tool plots e.g. a circle in the source code editor near the line where the user intends to stop the program execution. There is a need for a more advanced GUI interface which is useful in debugger tools not only for systems with cores but also for more complex systems with accelerators and multiple cores and also buses and memory blocks provided these have debug features .

According to an aspect a debug configuration tool is provided for configuration of on chip debug features. The debug configuration tool uses so called analysis points that are associated with configurable chip entities such as a processing unit CPU core a memory block a bus a Frame manager or a Queue manager of the DPAA module of the QorIQ chip. A special GUI is provided which may be used to configure any type of SoC functional block that implements debug features.

The GUI is arranged to display representations of the analysis points. The analysis points may be grouped into so called analysis groups. A user interacting with the GUI will look at the displayed analysis points and groups and may select a particular debug configuration by selecting certain analysis points and or groups. The analysis points and analysis groups can be shown at different levels of detail such as for example a module level a sub module level and a sub sub module level as will be explained in more detail later on.

Analysis points may be connected to each other by the user using the GUI. Alternatively connections between analysis points may be predefined in a database as will be explained below in more detail. Also analysis groups may be connected to each other or an analysis point may be connected to an analysis group.

As discussed above the analysis points are organized using analysis point groups or simply analysis groups. Similar to analysis points an analysis group can be used to configure a condition and an action. Such a group condition and group action apply to all the analysis points in the analysis group. Each analysis point group is graphically represented similar to the analysis points. A detailed view of the analysis points group shows the contained analysis points at sub module level. The analysis points and groups can be linked by dependency relation resulting in analysis chains.

The frames will be selected based to the Condition settings. By using the three different values 1 2 3 three debug flows can be marked simultaneously e.g. debug flow marked with 1 corresponds to TCP frames from IP 10.20.30.40 debug flow marked with 2 to all UDP frames debug flow marked with 3 corresponds to TCP from IP 11.21.31.41. An advantage of configuring the debug features in this way is that the user does not need to know the target debug registers to write specific values that need to be looked up in the SoC debug documentation.

As can be seen from the pop up menu in several different conditions may be set. In the example of the following options can be selected 

The pop up menu in is just an example showing possible condition settings for a frame manager at the module level. It should be clear to the skilled person that other condition settings are possible for other modules.

A condition of an analysis point or an analysis group may be determined by the content command or status of a SoC module register. It should be understood here that a user does not need to interact with the debugger registers themselves thanks to the GUI and API. The debug registers are known by the tool and the tool is able to translate GUI settings to content of debug registers.

Alternatively the condition may be determined by the data processed at that module e.g. it may depend on the debug mark field of the network frame descriptor. The analysis point condition may as well be determined by cross triggered events.

As was mentioned above an action of an analysis point or an analysis group may be the generation of a cross trigger also referred to as cross trigger event generation. An action may alternatively be an update of the content of the data processed by that SoC module e.g. writing a specific value in the debug mark field in the network frame descriptor .

An action may also be the generation of a trace referred to as trace generation. An action may also be the generation of an event signal referred to as event signal generation. Furthermore the action can be the stopping of the module execution see Debug halt option in to allow deep inspection of the module status.

The user may create a cross trigger between the analysis group in the QM module and the analysis group in the FM module . For example the user may click on the action icon of the analysis group in the QM module and select Event generation . He may chose e.g. event signal EVT  from a selection list not shown and then turn to the analysis group in the FM module . At the analysis group in the FM module the user can click on the condition icon and select the event match item in pop up and select signal EVT  as the matching criterion. Once the user has entered these options the GUI will be updated and a connection is shown between the analysis group in the QM module and the analysis group in the FM module .

Another way of creating relations between two analysis points or groups is achieved for instance by marking certain frames for debug. In the Queue Manager group an action may be to mark for debug the processed frame with value . In the Frame Manager group the condition may then be frame match based on the debug mark criterion and the same value being selected as the debug mark value.

The user may click on the second layer i.e. sub module layer to bring that layer to the front. shows an example of a medium layer of the configuration GUI according to an embodiment. shows the GUI of with the sub module layer brought to the front so as to show the analysis points view at the sub modules level. As can be seen from three modules are shown corresponding to the modules and on the module level. In this example each of the modules comprise two sub modules each of these is represented by a rounded rectangular surrounding a picture of an analysis point group. also shows a cross triggering connection between an analysis group in module and one in module which reflects the connection created at the module level when viewing layer see . The end points of connection are linked to those analysis groups in the sub modules as determined by a hierarchical API implementation info at upper levels is propagated top down to lower levels. The analysis group can e.g. represent a Frame Manager BMI and the analysis group can represent a Frame manager parser. A connection between the two may exist if the Frame Manager BMI marks frames for debug and the Frame Manager Parser matches those same debug frames as was described above.

At the sub module level view shown in the user can define analysis point conditions and actions for groups of block sub components like DPAA sub components. The medium level also allows the user to define and use convenient abstractions to improve usability of the interface.

In the modules and each contain multiple sub modules which contain an oval representing an analysis point. For a core on oval may represent a traditional breakpoint and for the DPAA it may represent a debug flow. A debug flow is a collection of properties that are used to identify frame flows of interest for the purposes of debugging or performance monitoring. Depending on the implementation the DPAA may support one or multiple debug flows which might be labelled and so on.

At a first module level the DPAA sub components can be configured. Examples of DPAA sub components configurable at this level are a Queue Manager a Frame Manager a Buffer Manager not shown and a Security Engine not shown in .

Examples of cores complex sub components configurable at this level are the set of DSP cores and the set of control cores.

A condition example for DPAA at this level is match frames received on network interfaces of Frame Manager . A condition example for the core complex at this level is the cache miss rate for the DSP cores set is 35 . An action example for the core complex at this level is start data trace on all DSP cores.

At a second module level analysis points may be associated with Frame Manager engines such as a Buffer Manager Interface BMI a Queue Manager Interface QMI a BMI Parser a Policer a Classifier or a key generator Keygen last three not shown . Other analysis points could be associated to so called frame enqueue dequeue points in the Queue Manager from and to Software Portals or accelerator portals e.g. the portals of the Security Engine or Pattern Matching Engine .

A condition example for a DPAA module at the level is set Frame Manager Keygen engine to match frames distributed on frame queue FQID 0xA0B0. Examples of cores complex sub components configurable at the level are individual cores and caches. An action example for the core complex at this level is start a data trace on all DSP cores.

At a register level analysis points may be associated with lower level entities such as debug flows for the DPAA module like was discussed with reference to . The register level is used for fine grained debug IP control. The user will use this layer when he needs wants to access full debug capability of the SoC and if that is not provided by the higher layers. Levels may be used at the beginning of an investigation. Non expert users will likely prefer using these levels. The levels are useful to narrow down the investigation. Expert users may prefer level for fine grained control.

The database comprises a plurality of predefined analysis points. Each of the analysis points relates to a configurable chip entity and comprises a configurable condition and a configurable action for the chip entity. Furthermore the database comprise a plurality of predefined analysis groups. Each of the analysis groups relates to a group of configurable chip entities and comprises a configurable condition and a configurable action for the group of chip entities.

The graphical user interface module is arranged to display representations of at least some of the analysis points and the analysis groups on different levels of detail and to receive input from a user to set the configurable conditions and or actions for the displayed analysis points and the analysis groups.

The application program interface module is arranged to process data received from the graphical user interface module to obtain debug settings and to communicate the debug settings to the debug target system configuration module .

The graphical user interface may be arranged to process inputs from the user such as the user selecting an item from a displayed menu and or dropdown list box as was explained above.

In an embodiment the graphical user interface module is arranged to display the representations of the analysis points and or analysis groups on different graphical layers reflecting the levels of detail. Each of the analysis groups may relate to a chip module and may be associated with one or more analysis points that relate to sub modules of the chip module.

In an embodiment the graphical user interface module is arranged to receive input from the user to define a cross triggering event between the analysis points and or the analysis groups. To this end the graphical user interface module may be arranged to set a specified action of a first analysis point and set a specified condition of a second analysis point the specified condition being dependent on the specified action as was described above with reference to .

In an embodiment the application program interface module is arranged to set a condition for an analysis group related to a chip module to obtain a condition setting. The condition setting is propagated the top down to analysis groups and or analysis points of lower leveled sub modules of the chip module. In this way the user can set condition on a high level for many sub modules at once.

The debug configuration tool as described above may comprise a set of API functions containing subsets of API functions for each of the different levels of detail.

In an embodiment the application program interface module comprises an API function that sets a module condition for an analysis group at a module level for a frame manager of a Data Path Acceleration Architecture block. The module condition may be defined by the matching of those frames conforming to a 3 tuple criteria the 3 tuple comprising a protocol type a source address and destination address of a frame.

Using the GUI as in the user selects condition Always match in popup menu for the FM module . This functionality is implemented by the GUI software in . Once the user has selected a condition the functionality in the API module is called via an API call that sets a condition for the analysis group associated to the FM module in this case Always match condition. Functionality in the API module propagates the condition setting top down to analysis groups associated to FM sub modules FM BMI FM Parser FM KeyGen . . . . In this case basically the condition of each of these analysis groups will also be set as Always match . Then functionality in the API module further propagates top down the Always match condition of the analysis groups associated to the FM BMI the FM Parser the FM Keygen until the analysis points at the lowest level related to e.g. the FM debug flows labeled and .

Once the user finished the configuration of the conditions and or actions he may push the Apply button so that the API module generates a debug configuration being the set of 2 tuples of type debug register name value based on the conditions and actions for the analysis points at the lowest level in the hierarchy. For instance in this case the FM bits to in the debug registers of type Rx Debug Configuration Register FMBM RDCFG will get value b001 representing Always match referred to as trap bypass . Note that there may be 30 such registers 3 debug flows 10 receive network port .

Then the DTSC module is activated it receives as input the debug configuration as a set of 2 tuples of type debug register name value from the module . The DTSC module connects to the SoC via the debug adapter such as a JTAG and writes each target debug register with the value associated to the corresponding register in the set of 2 tuples. Once the DTSC module finishes writing the target debug registers the SoC device is configured as desired by the user. The debugger tool is connected to the device. The user starts the application to be debugged or analyzed for performance optimization processes. Now the debug actions debug halt trace generation or event signaling will take place as configured by the user via the layered GUI.

So there is provided a generic analysis point as central concept and graphical element for system analysis tool user interfaces with improved usability high scalability and reusability for multiple SoC designs. The described debug configuration tool hides the complexity of the debugged system to allow for easy use of the tool. The debug configuration tool may support configurations of hundreds or even thousands of debug settings. The configuration debug tool s interface uses an abstract model design which makes it easy for the user to use the same set of tools for different SoC designs. The layered graphical user interface provides a representation of generic analysis point s inter dependencies. It provides a representation of generic analysis point groups. The layered graphical user interface provides a set of system view representations with increasingly detailed analysis configuration controls for each SoC sub system using unified terminology and representation across all system view layers.

1 On a SoC with 2 DDR blocks the memory latency is unexpectedly high for a test application the proposed debug configuration tool will allow to configure DDR to generate trace generation when high rates of memory accesses occur using a configuration with cross triggering from cores to DDR blocks. The DDR trace may reveal one of the DDR blocks was not enabled.

2 On a SoC with 4 accelerators and 2 processing cores the cores send chunks of data to be processed by accelerators. When reading back the data on cores some of the data is corrupted for an unknown reason. The proposed debug configuration tool will allow to configure the accelerators to halt when the core sends a specific data chunk to the accelerators. Deep investigation of the accelerator status may reveal that incorrect data offset was passed by the cores.

In an embodiment the method comprises the setting a condition for an analysis group related to a chip module to obtain a condition setting and the propagating the condition setting top down to analysis groups and or analysis points of lower leveled sub modules of the chip module.

An operating system OS is the software that manages the sharing of the resources of a computer and provides programmers with an interface used to access those resources. An operating system processes system data and user input and responds by allocating and managing tasks and internal system resources as a service to users and programs of the system.

In the foregoing specification the invention has been described with reference to specific examples of embodiments of the invention. It will however be evident that various modifications and changes may be made therein without departing from the broader spirit and scope of the invention as set forth in the appended claims.

The term program as used herein is defined as a sequence of instructions designed for execution on a computer system. A program or computer program may include a subroutine a function a procedure an object method an object implementation an executable application an applet a servlet a source code an object code a shared library dynamic load library and or other sequence of instructions designed for execution on a computer system.

In the claims any reference signs placed between parentheses shall not be construed as limiting the claim. The word comprising does not exclude the presence of other elements or steps then those listed in a claim. Furthermore the terms a or an as used herein are defined as one or more than one. Also the use of introductory phrases such as at least one and one or more in the claims should not be construed to imply that the introduction of another claim element by the indefinite articles a or an limits any particular claim containing such introduced claim element to inventions containing only one such element even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an. The same holds true for the use of definite articles. Unless stated otherwise terms such as first and second are used to arbitrarily distinguish between the elements such terms describe. Thus these terms are not necessarily intended to indicate temporal or other prioritization of such elements. The mere fact that certain measures are recited in mutually different claims does not indicate that a combination of these measures cannot be used to advantage.

