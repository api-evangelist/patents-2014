---

title: Systems and methods for implementing an encrypted search index
abstract: A search index stored within the system having a plurality of individual search index files having information stored therein. At least one of the individual search index files constitutes a term dictionary or a term index type file having internal structure that allows a portion of the individual search index file to be updated, encrypted, and/or decrypted without affecting the internal structure of the individual search index file. A file input/output (IO) layer encrypts the information being written into the individual search index file and to decrypt the information being read from the individual search index file. The file TO layer encrypts and decrypts only a portion of the individual search index file in reply to an operation without requiring decryption or encryption of the individual search index file in its entirety. A query interface executes the operation against the information stored in the memory in its decrypted form.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501661&OS=09501661&RS=09501661
owner: salesforce.com, inc.
number: 09501661
owner_city: San Francisco
owner_country: US
publication_date: 20140630
---
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Embodiments of the invention relate generally to the field of computing and more particularly to systems and methods for implementing an encrypted search index. Such means may be implemented within the computing architecture of a hosted computing environment such as an on demand or cloud computing environment which utilizes multi tenant database technologies client server technologies traditional database technologies or other computing architecture in support of the hosted computing environment.

The subject matter discussed in the background section should not be assumed to be prior art merely as a result of its mention in the background section. Similarly a problem mentioned in the background section or associated with the subject matter of the background section should not be assumed to have been previously recognized in the prior art. The subject matter in the background section merely represents different approaches which in and of themselves may also correspond to embodiments of the claimed inventions.

Conventionally known search indexing provides means to collect parse and store data so as to facilitate fast and accurate information retrieval including optimizing the speed and search performance in finding relevant documents or information responsive to a search query. The problem with conventional search indexes is that despite their usefulness they very often contain customer information which may be sensitive in nature.

Certain existing solutions overcome this problem by crudely encrypting the entirety of an index file upon updates and additions and then again decrypting the entirety of the index file for all search indexing. While such a solution may be feasible for very small indexes larger databases by their nature result in significantly larger search indexes easily ranging into the hundreds of megabytes when stored on disk. Consequently encrypting and decrypting the entirety of such large search indexes fails to scale up for larger implementations and becomes wholly infeasible after the search index files surpass a certain size on disk as the computing infrastructure simply cannot decrypt the large files and execute the requested search within an acceptable period of time.

Further still existing solutions of encrypting the entirety of a search index leave the encrypted search index open to frequency based attacks despite the encryption and in addition to unacceptably slowing search index processing existing solutions relegate search to exact term processing only and eradicate any ability to perform wild card searching.

The present state of the art may therefore benefit from the systems and methods for implementing an encrypted search index as is described herein.

Described herein are systems and methods for implementing an encrypted search index. An exemplary system may include for example a processor and a memory to execute instructions at the system a search index stored on disk within the system having therein a plurality of individual search index files the search index having customer information stored therein in which at least one of the individual search index files constitutes a term dictionary or a term index type file having internal structure which allows a portion of the individual search index file to be updated encrypted and or decrypted without affecting the internal structure of the individual search index file a file input output IO layer to encrypt the customer information being written into the individual search index file and to decrypt the customer information being read from the individual search index file in which the file TO layer encrypts and decrypts only a portion of the individual search index file in reply to an operation without requiring decryption or encryption of the individual search index file in its entirety and a query interface to execute the operation against the customer information stored in the memory in its decrypted form.

Certain embodiments operate within a hosted computing environment also referred to as a provider of on demand services on demand database services cloud computing services or simply a host organization that provides services to subscribing customer organizations. Such host organizations utilize various technologies to service many different tenants e.g. customer organizations and their users simultaneously. Such technologies may include for example client server implementations computing grids computing pods or pools of work machines traditional databases single tenancy database systems and or multi tenant database systems. A multi tenant database system in particular operates to store data on behalf of a multitude of subscribers each being a tenant of the database system hence the term multi tenant database system. Many subscribers e.g. users or tenants utilize the computing technologies of the host organization to access analytics charts views reports and other such data which is stored within the servers systems databases and multi tenant database system of the host organization. For instance a sales team may utilize sales data stored within such a system or customers may generally submit data to be stored within the system and execute search queries against such a system in which case the system returns search results.

In the following description numerous specific details are set forth such as examples of specific systems languages components etc. in order to provide a thorough understanding of the various embodiments. It will be apparent however to one skilled in the art that these specific details need not be employed to practice the embodiments disclosed herein. In other instances well known materials or methods have not been described in detail in order to avoid unnecessarily obscuring the disclosed embodiments.

In addition to various hardware components depicted in the figures and described herein embodiments further include various operations which are described below. The operations described in accordance with such embodiments may be performed by hardware components or may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor programmed with the instructions to perform the operations. Alternatively the operations may be performed by a combination of hardware and software.

Embodiments also relate to an apparatus for performing the operations disclosed herein. This apparatus may be specially constructed for the required purposes or it may be a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition embodiments are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the embodiments as described herein.

Embodiments may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the disclosed embodiments. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. a machine e.g. computer readable transmission medium electrical optical acoustical etc.

Any of the disclosed embodiments may be used alone or together with one another in any combination. Although various embodiments may have been partially motivated by deficiencies with conventional techniques and approaches some of which are described or alluded to within the specification the embodiments need not necessarily address or solve any of these deficiencies but rather may address only some of the deficiencies address none of the deficiencies or be directed toward different deficiencies and problems which are not directly discussed.

The multi tenant database system depicted in the embodiment shown includes a plurality of underlying hardware software and logic elements that implement database functionality and a code execution environment within the host organization . In accordance with one embodiment multi tenant database system further implements databases to service database queries and other data interactions with the databases . The hardware software and logic elements of the multi tenant database system as well as the search indexes the query interface and the file IO layer are separate and distinct from a plurality of customer organizations A B and C which utilize the services provided by the host organization by communicably interfacing to the host organization via network . In such a way host organization may implement on demand services on demand database services or cloud computing services to subscribing customer organizations A C.

Host organization receives input and other requests from a plurality of customer organizations A C via network such as a public Internet . For example incoming search queries database queries API requests interactions with displayed graphical user interfaces and displays at the client devices A C or other inputs may be received from the customer organizations A C to be processed against the multi tenant database system and or the search indexes as queries search queries etc. or such queries may be constructed from the requests for execution against the databases by the file IO layer and or the query interface pursuant to which results are then returned to an originator or requestor such as a user of one of a client device A C at a customer organization A C.

In one embodiment each customer organization A C is an entity selected from the group consisting of a separate and distinct remote organization an organizational group within the host organization a business partner of the host organization or a customer organization A C that subscribes to cloud computing services provided by the host organization .

In one embodiment requests are received at or submitted to a web server within host organization . Host organization may receive a variety of requests for processing by the host organization and its multi tenant database system . Incoming requests received at web server may specify which services from the host organization are to be provided such as query requests search request status requests database transactions graphical user interface requests and interactions processing requests to retrieve update or store data on behalf of one of the customer organizations A C code execution requests and so forth. Web server may be responsible for receiving requests from various customer organizations A C via network on behalf of the query interface and for providing a web based interface or other graphical displays to an end user client device A C or machine originating such data requests .

Host organization may implement a request interface via web server or as a stand alone interface to receive requests packets or other requests from the client devices A C. Request interface further supports the return of response packets or other replies and responses in an outgoing direction from host organization to the client devices A C.

Authenticator operates on behalf of the host organization to verify authenticate and otherwise credential users attempting to gain access to the host organization.

Query interface additionally provides functionality to pass queries from web server into the multi tenant database system for execution against the databases into the search indexes for processing search queries or into the other available data stores of the host organization s production environment . In one embodiment the query interface implements an Application Programming Interface API through which queries may be executed against the databases the search indexes or the other data stores.

A write or update operation may necessitate a change to information stored by an existing search index thus utilizing updated data or a new individual search index file or a new term index file may be built and thus incorporate new data. Regardless as is depicted here the query interface interfaces to the search index and its individual search index files including the term index file as stored on disk storage via file IO layer . The new or updated data in its unencrypted form resides within memory accessible to the query interface and is passed from memory by the query interface to the search index through file IO layer which takes the new or updated data in its unencrypted form encrypts it and writes the new or updated data in its encrypted form directly into the appropriate sub portion of the corresponding individual search index file or term index file within the search index resulting in the new or updated data in its encrypted form being passed into and stored within the search index on disk storage . Thus element depicts the new or updated data stored at rest in its encrypted state on disk.

The described means result in the implementation of an encrypted search index which ensures that all sensitive customer data is encrypted at rest while stored on disk. In doing so even in the event that the index files themselves are compromised the data will be of little value to malicious actors. Moreover by accessing only a subset fraction or portion of the larger individual index search files which make up the search index itself performance and search query processing is greatly improved as it is no longer necessary to decrypt and re encrypt entire individual search index files every time any interaction or transaction is undertaken. For instance for a simple search query only a small portion affected by the query needs to be decrypted and where an update or new information is added to the individual search index file be it a term index or otherwise only a portion of the total file needs to be re encrypted which is less computationally intensive and therefore faster than re encrypting an entire individual search index file in its entirety.

The file IO layer binds through software directly to the individual search index files which make up the search index and in doing so the file IO layer is enabled to selectively encrypt data based on its type and use. This method is more precise then a general encrypted file strategy which encrypts files as a whole and is more transparent to the query interface as file IO layer abstracts away the details of file Input Output operation from the query interface as well as from other applications APIs GUIs or any other entity making use of the search index. Stated differently the file IO layer performs its encryption decryption behind the scenes and out of view of the query interface and other applications and selectively applies the encryption and decryption to only specific values in any given individual search index file based on the value type. Other applications APIs GUIs and the query interface itself is able to operation without any knowledge that the file IO layer is encrypting or decrypting customer information stored within the search index.

A search index is broken down into multiple files only a subset of which require encryption and only sub portions or fractions of those individual search index files requiring decryption and re encryption at any given time in support of processing a received operation. Customer data within the search indexing pipeline it is treated as either terms in the term dictionary term index type file or treated as values in the field data file. Terms are also stored in files dealing with term vectors.

In accordance with one embodiment a Lucene compatible search index is specifically utilized which includes the following files a segments file e.g. segments.gen segments N which stores information about segments a lock file e.g. write.lock which prevents multiple IndexWriters from writing to the same file a compound file e.g. .dfs which is an optional virtual file consisting of all the other index files for systems that frequently run out of file handles a fields file e.g. .fnm which stores information about the fields a field index file e.g. .fdx which contains pointers to field data a field data file e.g. fdt which is specifically selected for encryption according to described embodiments and which stores fields for documents a term infos file e.g. .tis which is specifically selected for encryption according to described embodiments and which is part of the term dictionary and stores term information a term info index e.g. .tii .tip which is specifically selected for encryption according to described embodiments and which is the index into the term infos file a frequencies file e.g. .frq which contains the list of documents which contain each term along with their frequency a positions file .prx which stores position information about where a term occurs in the index a norms file e.g. .nrm which encodes length and boost factors for docs and fields a term vector index file e.g. tvx which is specifically selected for encryption according to described embodiments and which stores offset into the document data file a term vector documents file e.g. .tvd which is specifically selected for encryption according to described embodiments and which provides information about each document that has term vectors a term vector fields file e.g. .tvf which is specifically selected for encryption according to described embodiments and which provides the field level info about term vectors and a deleted documents file e.g. .del which provides information about which files are marked for deletion or were deleted.

Consider for example the case of an account record in which the record reflects the following information 

According to the described embodiments a subset of the elements may require encryption whereas others may require no encryption. For instance depicted along the CODEC pipeline and organizational data elements are the term index which includes term prefixes and pointers to the term dictionary. All of CODEC pipeline and org data elements are incorporated into existing Lucene compatible CODECs in accordance with the described embodiments. Term dictionary includes term suffixes which maps in turn to frequencies and positions . As depicted the file IO layer encrypts and decrypts the file sub portions as necessary in support of the embodiments as described herein. According to a specific embodiment and implementation it is necessary to sub class FSDirectory and SimpleFSDirectory for the term index and whole file encryption may be utilized in doing so and it is needed to sub class BlockTreeTermsReader and BlockTreeTermsWriter for the term dictionary and partial file encryption may be utilized for doing so in particular only the term suffixes may be encrypted rather than encrypting and decrypting the entire term dictionary in accordance with such an embodiment. Continuing with this specific exemplary embodiment Frequencies and positions are not encrypted.

Stored field values provides or includes for each document a list of attribute value pairs in which the attributes are field names. The stored field values are used to store auxiliary information about the document such as its title URL or an identifier to access a database. The set of stored fields are returned as each positive hit occurs when searching and may be keyed by document number according to certain implementations.

Field values include customer sensitive data and are stored in two locations. For instance the field values are stored for the purposes of indexing which associates a term of a field with a document in the term index dictionary. The field values are additionally included or stored as the field value as a whole and associated with a query result for use later. For example if a search for release information is performed and it shows up in the description of an account object and the description is chosen to be in the field data file then the entire description as a whole can be returned with the rest of the query results and displayed to a user or provided responsive to a query if field values are explicitly specified to be stored in support of such an implementation.

According to various embodiments certain files may be subjected to whole file encryption others not encrypted at all and yet others subjected to partial file encryption in which only a subset of information is read or retrieved decrypted manipulated re encrypted and replaced into the file without encrypting or decrypting the file in its entirety and without disrupting the existing structure of the file subjected to partial encryption. Alternatively it may be that information does not yet exist in a file subjected to partial encryption and thus the data is encrypted and written to the file in a first instance but again this is done without encrypting or decrypting the file in its entirety and without disrupting the existing structure of the file subjected to partial encryption. Additionally certain operations or transactions are read only and thus information is read or retrieved and decrypted but this is done without decrypting the entirety of the file and without disrupting the existing structure of the file subjected to partial encryption decryption.

According to an alternative embodiment a hybrid approach is utilized which includes encrypting suffix bytes in each term block of the term dictionary e.g. term index file at or term dictionary at . Because the term suffixes reside within in the same block in the file e.g. if a block has 23 terms in it the suffixes are all in one contiguous block all term suffixes are encrypted and decrypted as a single block via a single pass in accordance with certain embodiments. Additionally by encrypting suffixes per contiguous block it is only necessary to decrypt blocks that are affected utilized and or referenced by the transaction operation or search query in question as directed by the term index rather than requiring decryption of the term dictionary e.g. term index file at or term dictionary at in its entirety or the decryption of an entire search index file which can be many hundreds of megabytes in size and thus represent a large computational overhead cost as well as a delay in returning the result set to a user querying for such information. Encryption of the entire Term index .tii .tip file and loading of the entire file into memory may still be carried out at the directory level to further improve operational efficiency and speed and is therefore reverse compatible with conventional tools.

Values of the field data file .fdt may be encrypted. The field data file .fdt provides a set of key value pairs where the keys correspond to fields and where the values represent or specify further information about those fields. Since the fields themselves are not encrypted within the host organization and the values may include customer sensitive data such data will also be encrypted in accordance with particular embodiments.

Notwithstanding the encryption individual search index files may nevertheless remain accessible as a random access file including a term index type file. The structure of large files is preserved yet permits for encryption of customer sensitive data within the document. With the overall structure of the file preserved the file remains operational as a random access file permitting random access to specified parts of a large file without having to encrypt decrypt the file as a whole for each operation. Moreover vulnerability of customer sensitive information to frequency based attacks is greatly reduced by organizing and separating customer sensitive data into blocks and within those blocks dividing the block into sub blocks. Sub blocks are separated based on what is customer data and what is not customer data. For instance according to certain embodiments customer and non customer data do not share the same sub block and are thus divided accordingly. By organizing data in such a way and encrypting the sub block that contains customer data then even in the event that malicious actors sees the non customer sensitive data in another sub block it can t directly associated with any specifically encrypted term because all terms are encrypted as a single contiguous block rendering the ill gained access valueless to a hacker intruder or other malicious actor.

By applying the above two techniques to search index operations search indexes and search for information within such indexes are built and maintained in such a way that ensures customer sensitive information is encrypted and protected while at rest on disk within the file system.

In the unlikely event that a search server is nevertheless accessed by a malicious user hacker etc. then the customer data within the search index files would be accessible in a readable format without encryption of the search indexes being implemented. Without encryption the individual search index files could be used to recreate customer documents that are meant to be encrypted elsewhere in within the host organization s infrastructure. Existing solutions call for encrypting entire index files e.g. files that are retrieved and referenced as part of a search query as a whole but these prior solutions are unworkable within a large scale hosted computing environment such as that provided by salesforce.com due to the massive datasets maintained and serviced. Moreover prior solutions require the encryption of not only customer data but the encryption of entire files even if only a fraction of a file is needed referenced or changed. Since encryption takes time and costs real dollars by expending computer processing cycles as overhead implementing encryption of the search index in the least amount of processing cycle time and computing cost possible is necessary to meet usability requirements for search.

The write operation will take customer data a key and an Initialization Vector IV and encrypt this information and store it on disk within the host server. The customer data may arrive as an update request or a record insert with read operations implying a search query e.g. read only and with write operations implying that index documents are being received and added to the search index

Inside the structure of a given individual search index file such as the term index if there are 23 24 terms and if each term is encrypted individually then file is vulnerable to frequency attacks. For instance if the same term is viewed 50 times then it is probably a pronoun for instance maybe the etc. and thus the file and the customer s data within is still subject to some level of damage or harm despite the encryption of the individual terms.

Described embodiments therefore encrypt the terms all together and so a malicious actor e.g. a hacker etc. will just see a long block of encrypted text but does not know which term is which unless he is able to decrypt the entire string or block which cannot be done in the absence of the key. For instance if there are 100 blocks the structure is kept in tact. The file includes pointers and if only one small piece of the block with the customer information is needed to perform the operation or search query then only that small piece of the block is decrypted when it is needed without decrypting the entire file. In reply to a search query instead of having to decrypt the entire file if it is only 3 blocks that are required to perform the search query then only those 3 blocks are decrypted.

According to the described embodiments implementing an encrypted search index further enables enhanced search capabilities over conventional means. For instance implementing the encrypted search index enables exact term search and wildcard search each of which may not function correctly with conventional means.

An example of exact term search is searching for JOE in which the exact term is entered and processed through the search pipeline and eventually the search operation hits the term index file and positively hits or locates the term JOE and returns blocks that are relevant to that term. So the search for JOE may identify blocks and and return those blocks. With the blocks returned the search operation knows where the file pointers are and decrypts the blocks upon receipt or retrieval e.g. via the file IO layer etc. . When a query arrives and a search is performed using an appropriate key eventually the query will hit the term index file and the key is utilized to decrypt the term index file as well as the term dictionary each being pulled from disk and decrypted through the file IO layer.

Once decrypted and resident in memory conventional operations may be utilized to access and reference the decrypted data and in such a way the improvements made to encrypting the pipeline have no ill effect upon the query interface applications GUIs APIs etc. with each of such entities performing as usual when information is being pulled from disk because the file IO layer makes these retrieval and decryption encryption operations transparent or out of view of such entities. For instance when the term index file it is decrypted via the file IO layer and when the pointers are referenced the corresponding files e.g. the files pointed to by such pointers are located and retrieved and again the decryption happens automatically by the file IO layer.

According to described embodiments the file IO layer is a software interface bound to the particular individual search index files of the search index and operates as a barrier between the disk and the memory. The moment operations are executed to read or write to disk the decryption and encryption is performed automatically and transparently by such a file IO layer. Conventional solutions retrieve the file decrypt the file and work with the data of the file and then re encrypt the entire file and write the entire file back to disk in its encrypted state. Conversely the file IO layer pull blocks or sub portions of the file decrypts those blocks sub portions and works with them before re encrypting only those blocks or sub portions and writing only those blocks and sub portions back into the original file in an encrypted state permitting the original file to retain its original internal structure. For instance the structure of the term index or other individual search index files making up the search index are not modified only the contents of the blocks or sub elements within them as necessary to complete a particular operation transaction or search query. The search index files have their own built in internal structure similar to files that are paged or tagged or marked in someway or otherwise have structure around them. The search index files as described herein are not meant to be read into memory in their entirety and thus the problem with decryption is that by decrypting the entire file it is not only time intensive and wasteful but it additionally impairs the operation of other entities which utilize the search index such as the query interface APIs other applications GUIs etc.

Suffixes provide the organization information so if the search strings JOE or BLONDE were specified then those names and terms would be encrypted in the term dictionary resulting in a broader term dictionary. The next subset is blocks within the dictionary and then within the respective blocks there are a contiguous set of statistics regarding those terms and then a continuous set of descriptive information pertaining to the blocks. Thus encrypting the term or the suffix byte according to certain embodiments requires only encrypting those bytes and the randomness of the data is otherwise maintained without having to pull up the entire search index file. Importantly the structure of the search index file is also preserved and the volume of data that requires encrypting and decrypting drops substantially in contrast with conventional methodologies.

Search functionality utilizing wildcarding is additionally preserved with the implementation of an encrypted search index as described herein whereas such functionality is destroyed utilizing conventional encryption solutions. With wildcards a search is performed on a prefix tree and within a path and everything associated with for example J is located which may correspond to any of JOE or JAMES or JACKIE etc. The search may be further specified as JA and then the terms that it corresponds to is JAMES and JACKIE and if the search is still further narrowed to JAM then only JAMES corresponds to the search according to this particular example. Use of the prefix tree is well known but the problem is that if the prefix tree is encrypted then it will not match the various partial results. It may be possible to match a complete sting but not partial search strings relying upon wildcarding. For example because the encrypting randomizes the data searching for J and then JA and then JAM will take the search down a random path and hit random results because plaintext wildcarding search parameters are being utilized against an encrypted target thus breaking or destroying wild card search functionality. However implementation of an encrypted search index as described herein permits wild card functionality to continue to function because after the file IO layer pulls the relevant files from disk and places them into memory in a decrypted state with the encryption and decryption occurring transparently between the memory and disk by the file IO layer it is not necessary for any other search query interface API GUI etc. to make special accommodation for the presence of encryption because they are not exposed to the encrypted data when transacting with the target data within memory. Thus when the search is performed even using wild cards it does not encounter the randomness of encryption in the data but rather it encounters the expected information in its decrypted state in memory and requires no special handling for such a query interface API and GUI type entities.

At block processing logic stores a search index on disk within the host organization the search index having a plurality of individual search index files with customer information stored therein in which at least one of the individual search index files constitutes a term dictionary or a term index type file having internal structure which allows a portion of the individual search index file to be updated encrypted and or decrypted without affecting the internal structure of the individual search index file.

At block processing logic encrypts the customer information being written into the search index via a file input output IO layer and decrypting the customer information being read from the search index via the file IO layer in which the file IO layer encrypts and decrypts only a portion of the search index in reply to an operation without requiring decryption or encryption of the individual search index file in its entirety.

At block processing logic executes via a query interface the operation against the customer information stored in the memory in its decrypted form.

According to another embodiment method further includes receiving the customer information in its decrypted state into the memory from the file IO layer in advance of executing the operation against the customer information in the memory.

According to another embodiment of method the individual search index file includes a plurality of terms delineated by internal structure of the individual search index file each term corresponding to at least a value for the term and a field within which the term is maintained and in which method further includes dividing the individual search index file into blocks and dividing the blocks into sub blocks within which the customer data of the individual search index file and the non customer data of the individual search index file do not share any same sub block.

According to another embodiment of method the host organization implements the method via computing architecture of the host organization including at least the processor and the memory in which a user interface operates at a user client device remote from the host organization and communicatively interfaces with the host organization via a public Internet in which the operation is received at the user interface of the user client device and communicated to the host organization via the public Internet and in which the host organization operates as a cloud based service provider to the user client device.

According to another embodiment of method the host organization provides a multi tenant database system which implements the search index executing via computing architecture of the host organization the multi tenant database system having elements of hardware and software that are shared by a plurality of separate and distinct customer organizations each of the separate and distinct customer organizations being remotely located from the host organization.

In accordance with a particular embodiment there is non transitory computer readable storage media having instructions stored thereon that when executed by a processor of a system the instructions cause the system to perform operations including storing a search index on disk within the host organization the search index included of a plurality of individual search index files and having customer information stored therein in which at least one of the individual search index files constitutes a term dictionary or a term index type file having internal structure which allows a portion of the individual search index file to be updated encrypted and or decrypted without affecting the internal structure of the individual search index file encrypting the customer information being written into the search index via a file input output IO layer and decrypting the customer information being read from the search index via the file IO layer in which the file IO layer encrypts and decrypts only a portion of the search index in reply to an operation without requiring decryption or encryption of the individual search index file in its entirety and executing via a query interface the operation against the customer information stored in the memory in its decrypted form.

In accordance with one embodiment there is a system having at least a processor and a memory therein to execute implementing logic and or instructions . Such a system may execute within a hosted computing environment such as a host organization a multi tenant environment an on demand service provider a cloud based service provider a client server environment etc.

According to the depicted embodiment the system includes the processor and the memory to execute instructions at the system a search index stored on disk within the system having therein a plurality of individual search index files the search index having customer information stored therein in which at least one of the individual search index files constitutes a term dictionary or a term index type file having internal structure which allows a portion of the individual search index file e.g. or to be updated encrypted and or decrypted without affecting the internal structure of the individual search index file e.g. or a file input output IO layer to encrypt the customer information being written into the individual search index file e.g. or and to decrypt the customer information being read from the individual search index file e.g. or in which the file IO layer encrypts and decrypts only a portion of the individual search index file e.g. or in reply to an operation without requiring decryption or encryption of the individual search index file e.g. or in its entirety and a query interface to execute the operation against the customer information stored in the memory in its decrypted form .

According to another embodiment the memory of system is to receive the customer information in its decrypted form from file IO layer during the process of receiving and processing the operation against the search index the operation affecting at least the individual search index file amongst the plurality of individual search index files which make up the search index.

According to another embodiment of system the file IO layer is to encrypt and decrypt the customer information given an encryption key and Initialization Vector IV in which the search processing components interacting with the file IO layer will receive decrypted customer data from the individual search index file when given a correct encryption key and IV and continue processing the operation and creating search results without any further knowledge of what or how encryption occurs within the disk s file system.

According to another embodiment of system the file IO layer is a software implemented interface layer to encrypt and decrypt the customer information from at least the individual search index file of the search index at the IO level by interacting directly with and being bound uniquely to one or more of the plurality of individual search index files within the search index.

According to another embodiment of system the operation is an update operation including at least a write operation of new or updated customer information into the individual search index file of the search index in which the memory receives the customer information in its decrypted state via the file IO layer after receipt and during processing of the update operation as part of creating a return result responsive to the update operation in which the query interface executes the update operation against the customer information in the memory in its decrypted state including at least performing the write operation of the new or updated customer information in the memory and in which the file IO layer encrypts the customer information in the memory having at least the update or the addition thereto and writes the encrypted customer information back into the individual search index file of the search index.

According to another embodiment of system the operation includes a read only search query operation of the customer information previously stored in the individual search index file of the search index in which the memory receives the customer information in its decrypted state via the file TO layer after receipt and during processing of the read only search query operation as part of creating a return result responsive to the read only search query operation in which the query interface executes the read only search query operation against the customer information in the memory in its decrypted state and in which the file TO layer takes no further action on the customer information in the memory in its decrypted state subsequent to execution of the read only search query operation.

According to another embodiment of system the read only search query operation includes one of an exact term search or a wild card search and in which the exact term search or the wild card search is performed by the query interface against the customer information in its decrypted state in the memory.

According to another embodiment of system the search index is an Apache Lucene compatible type index to which random access is made to sub portions of individual search index files within the search index and to which updates to the sub portions of the individual search index files within the search index are made without affecting an internal structure of any individual search index file being accessed or updated within the search index.

According to another embodiment of system the individual search index files include a plurality of terms delineated by internal structure of the search index each term corresponding to at least a value for the term and a field within which the term is maintained.

According to another embodiment of system the individual search index file is divided into blocks and further in which the blocks are divided into sub blocks within which the customer data of the individual search index file and the non customer data of the search index do not share any same sub block.

According to another embodiment of system the file TO layer encrypts all terms of the individual search index file as a single contiguous block including the customer data at rest as stored on disk within the individual search index file to reduce vulnerability of the customer data to frequency based attacks and or reconstruction of the customer data from the search index.

According to another embodiment of system each term is marked with term information and a term suffix in accordance with an Apache Lucene compatible type index.

According to another embodiment of system the customer information includes sensitive customer data having at least one of the following represented therein customer name customer telephone number customer email address customer mailing address customer salary data customer financial data customer heath records data customer order history customer preference data customer payment information and or customer calendar data.

According to another embodiment of system the individual search index file and storage of the customer information within the search index is implemented via the plurality of individual search index files as stored on disk within the system which are selectively retrieved and or updated during the process of adding index documents or executing operations including search queries add operations delete operations and update operations and in which the query interface is operable to submit queries including the operation against the search index.

According to another embodiment of system the database includes a multi tenant database system implemented by the host organization to store customer data and search index metadata on behalf of a plurality of separate and distinct customer organizations which utilize the multi tenant database system and in which each of the plurality of separate and distinct customer organizations which utilize the multi tenant database system constitutes an entity selected from the group consisting of a separate and distinct remote organization an organizational group within the host organization a business partner of the host organization or a customer organization that subscribes to cloud computing services provided by the host organization.

Bus interfaces the various components of the system amongst each other with any other peripheral s of the system and with external components such as external network elements other machines client devices etc. including communicating with such external devices via a network interface over a LAN WAN or the public Internet. Query interface provides functionality to pass queries from the request interface e.g. web server into a multi tenant database system for execution against its databases or other data stores of the host organization s production environment as depicted in additional detail at .

Environment is an environment in which an on demand database service exists. User system may be any machine or system that is used by a user to access a database user system. For example any of user systems can be a handheld computing device a mobile phone a laptop computer a work station and or a network of computing devices. As illustrated in and in more detail in user systems might interact via a network with an on demand database service which is system .

An on demand database service such as system is a database system that is made available to outside users that do not need to necessarily be concerned with building and or maintaining the database system but instead may be available for their use when the users need the database system e.g. on the demand of the users . Some on demand database services may store information from one or more tenants stored into tables of a common database image to form a multi tenant database system MTS . Accordingly on demand database service and system is used interchangeably herein. A database image may include one or more database objects. A relational database management system RDMS or the equivalent may execute storage and retrieval of information against the database object s . Application platform may be a framework that allows the applications of system to run such as the hardware and or software e.g. the operating system. In an embodiment on demand database service may include an application platform that enables creation managing and executing one or more applications developed by the provider of the on demand database service users accessing the on demand database service via user systems or third party application developers accessing the on demand database service via user systems .

The users of user systems may differ in their respective capacities and the capacity of a particular user system might be entirely determined by permissions permission levels for the current user. For example where a salesperson is using a particular user system to interact with system that user system has the capacities allotted to that salesperson. However while an administrator is using that user system to interact with system that user system has the capacities allotted to that administrator. In systems with a hierarchical role model users at one permission level may have access to applications data and database information accessible by a lower permission level user but may not have access to certain applications database information and data accessible by a user at a higher permission level. Thus different users will have different capabilities with regard to accessing and modifying application and database information depending on a user s security or permission level.

Network is any network or combination of networks of devices that communicate with one another. For example network can be any one or any combination of a LAN local area network WAN wide area network telephone network wireless network point to point network star network token ring network hub network or other appropriate configuration. As the most common type of computer network in current use is a TCP IP Transfer Control Protocol and Internet Protocol network such as the global internetwork of networks often referred to as the Internet with a capital I that network will be used in many of the examples herein. However it is understood that the networks that the claimed embodiments may utilize are not so limited although TCP IP is a frequently implemented protocol.

User systems might communicate with system using TCP IP and at a higher network level use other common Internet protocols to communicate such as HTTP FTP AFS WAP etc. In an example where HTTP is used user system might include an HTTP client commonly referred to as a browser for sending and receiving HTTP messages to and from an HTTP server at system . Such an HTTP server might be implemented as the sole network interface between system and network but other techniques might be used as well or instead. In some implementations the interface between system and network includes load sharing functionality such as round robin HTTP request distributors to balance loads and distribute incoming HTTP requests evenly over a plurality of servers. At least as for the users that are accessing that server each of the plurality of servers has access to the MTS data however other alternative configurations may be used instead.

In one embodiment system shown in implements a web based customer relationship management CRM system. For example in one embodiment system includes application servers configured to implement and execute CRM software applications as well as provide related data code forms webpages and other information to and from user systems and to store to and retrieve from a database system related data objects and Webpage content. With a multi tenant system data for multiple tenants may be stored in the same physical database object however tenant data typically is arranged so that data of one tenant is kept logically separate from that of other tenants so that one tenant does not have access to another tenant s data unless such data is expressly shared. In certain embodiments system implements applications other than or in addition to a CRM application. For example system may provide tenant access to multiple hosted standard and custom applications including a CRM application. User or third party developer applications which may or may not include CRM may be supported by the application platform which manages creation storage of the applications into one or more database objects and executing of the applications in a virtual machine in the process space of the system .

One arrangement for elements of system is shown in including a network interface application platform tenant data storage for tenant data system data storage for system data accessible to system and possibly multiple tenants program code for implementing various functions of system and a process space for executing MTS system processes and tenant specific processes such as running applications as part of an application hosting service. Additional processes that may execute on system include database indexing processes.

Several elements in the system shown in include conventional well known elements that are explained only briefly here. For example each user system may include a desktop personal computer workstation laptop PDA cell phone or any wireless access protocol WAP enabled device or any other computing device capable of interfacing directly or indirectly to the Internet or other network connection. User system typically runs an HTTP client e.g. a browsing program such as Microsoft s Internet Explorer browser a Mozilla or Firefox browser an Opera or a WAP enabled browser in the case of a smartphone tablet PDA or other wireless device or the like allowing a user e.g. subscriber of the multi tenant database system of user system to access process and view information pages and applications available to it from system over network . Each user system also typically includes one or more user interface devices such as a keyboard a mouse trackball touch pad touch screen pen or the like for interacting with a graphical user interface GUI provided by the browser on a display e.g. a monitor screen LCD display etc. in conjunction with pages forms applications and other information provided by system or other systems or servers. For example the user interface device can be used to access data and applications hosted by system and to perform searches on stored data and otherwise allow a user to interact with various GUI pages that may be presented to a user. As discussed above embodiments are suitable for use with the Internet which refers to a specific global internetwork of networks. However it is understood that other networks can be used instead of the Internet such as an intranet an extranet a virtual private network VPN a non TCP IP based network any LAN or WAN or the like.

According to one embodiment each user system and all of its components are operator configurable using applications such as a browser including computer code run using a central processing unit such as an Intel Pentium processor or the like. Similarly system and additional instances of an MTS where more than one is present and all of their components might be operator configurable using application s including computer code to run using a central processing unit such as processor system which may include an Intel Pentium processor or the like and or multiple processor units.

According to one embodiment each system is configured to provide webpages forms applications data and media content to user client systems to support the access by user systems as tenants of system . As such system provides security mechanisms to keep each tenant s data separate unless the data is shared. If more than one MTS is used they may be located in close proximity to one another e.g. in a server farm located in a single building or campus or they may be distributed at locations remote from one another e.g. one or more servers located in city A and one or more servers located in city B . As used herein each MTS may include one or more logically and or physically connected servers distributed locally or across one or more geographic locations. Additionally the term server is meant to include a computer system including processing hardware and process space s and an associated storage system and database application e.g. OODBMS or RDBMS as is well known in the art. It is understood that server system and server are often used interchangeably herein. Similarly the database object described herein can be implemented as single databases a distributed database a collection of distributed databases a database with redundant online or offline backups or other redundancies etc. and might include a distributed database or storage network and associated processing intelligence.

User system network system tenant data storage and system data storage were discussed above in . As shown by system may include a network interface of implemented as a set of HTTP application servers an application platform tenant data storage and system data storage . Also shown is system process space including individual tenant process spaces and a tenant management process space . Each application server may be configured to tenant data storage and the tenant data therein and system data storage and the system data therein to serve requests of user systems . The tenant data might be divided into individual tenant storage areas e.g. tenant storage space which can be either a physical arrangement and or a logical arrangement of data. Within each tenant storage space tenant data and application metadata might be similarly allocated for each user. For example a copy of a user s most recently used MRU items might be stored to tenant data . Similarly a copy of MRU items for an entire organization that is a tenant might be stored to tenant storage space . A UI provides a user interface and an API provides an application programmer interface into system resident processes to users and or developers at user systems . The tenant data and the system data may be stored in various databases such as one or more Oracle databases.

Application platform includes an application setup mechanism that supports application developers creation and management of applications which may be saved as metadata into tenant data storage by save routines for execution by subscribers as one or more tenant process spaces managed by tenant management process space for example. Invocations to such applications may be coded using PL SOQL that provides a programming language style interface extension to API . Invocations to applications may be detected by one or more system processes which manages retrieving application metadata for the subscriber making the invocation and executing the metadata as an application in a virtual machine.

Each application server may be communicably coupled to database systems e.g. having access to system data and tenant data via a different network connection. For example one application server might be coupled via the network e.g. the Internet another application server might be coupled via a direct network link and another application server might be coupled by yet a different network connection. Transfer Control Protocol and Internet Protocol TCP IP are typical protocols for communicating between application servers and the database system. However it will be apparent to one skilled in the art that other transport protocols may be used to optimize the system depending on the network interconnect used.

In certain embodiments each application server is configured to handle requests for any user associated with any organization that is a tenant. Because it is desirable to be able to add and remove application servers from the server pool at any time for any reason there is preferably no server affinity for a user and or organization to a specific application server . In one embodiment therefore an interface system implementing a load balancing function e.g. an F5 Big IP load balancer is communicably coupled between the application servers and the user systems to distribute requests to the application servers . In one embodiment the load balancer uses a least connections algorithm to route user requests to the application servers . Other examples of load balancing algorithms such as round robin and observed response time also can be used. For example in certain embodiments three consecutive requests from the same user may hit three different application servers and three requests from different users may hit the same application server . In this manner system is multi tenant in which system handles storage of and access to different objects data and applications across disparate users and organizations.

As an example of storage one tenant might be a company that employs a sales force where each salesperson uses system to manage their sales process. Thus a user might maintain contact data leads data customer follow up data performance data goals and progress data etc. all applicable to that user s personal sales process e.g. in tenant data storage . In an example of a MTS arrangement since all of the data and the applications to access view modify report transmit calculate etc. can be maintained and accessed by a user system having nothing more than network access the user can manage his or her sales efforts and cycles from any of many different user systems. For example if a salesperson is visiting a customer and the customer has Internet access in their lobby the salesperson can obtain critical updates as to that customer while waiting for the customer to arrive in the lobby.

While each user s data might be separate from other users data regardless of the employers of each user some data might be organization wide data shared or accessible by a plurality of users or all of the users for a given organization that is a tenant. Thus there might be some data structures managed by system that are allocated at the tenant level while other data structures might be managed at the user level. Because an MTS might support multiple tenants including possible competitors the MTS may have security protocols that keep data applications and application use separate. Also because many tenants may opt for access to an MTS rather than maintain their own system redundancy up time and backup are additional functions that may be implemented in the MTS. In addition to user specific data and tenant specific data system might also maintain system level data usable by multiple tenants or other data. Such system level data might include industry reports news postings and the like that are sharable among tenants.

In certain embodiments user systems which may be client systems communicate with application servers to request and update system level and tenant level data from system that may require sending one or more queries to tenant data storage and or system data storage . System e.g. an application server in system automatically generates one or more SQL statements e.g. one or more SQL queries that are designed to access the desired information. System data storage may generate query plans to access the requested data from the database.

Each database can generally be viewed as a collection of objects such as a set of logical tables containing data fitted into predefined categories. A table is one representation of a data object and may be used herein to simplify the conceptual description of objects and custom objects as described herein. It is understood that table and object may be used interchangeably herein. Each table generally contains one or more data categories logically arranged as columns or fields in a viewable schema. Each row or record of a table contains an instance of data for each category defined by the fields. For example a CRM database may include a table that describes a customer with fields for basic contact information such as name address phone number fax number etc. Another table might describe a purchase order including fields for information such as customer product sale price date etc. In some multi tenant database systems standard entity tables might be provided for use by all tenants. For CRM database applications such standard entities might include tables for Account Contact Lead and Opportunity data each containing pre defined fields. It is understood that the word entity may also be used interchangeably herein with object and table. 

In some multi tenant database systems tenants may be allowed to create and store custom objects or they may be allowed to customize standard entities or objects for example by creating custom fields for standard objects including custom index fields. In certain embodiments for example all custom entity data rows are stored in a single multi tenant physical table which may contain multiple logical tables per organization. It is transparent to customers that their multiple tables are in fact stored in one large table or that their data may be stored in the same table as the data of other customers.

The exemplary computer system includes a processor a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. static memory such as flash memory static random access memory SRAM volatile but high data rate RAM etc. and a secondary memory e.g. a persistent storage device including hard disk drives and a persistent database and or a multi tenant database implementation which communicate with each other via a bus . Main memory includes a search index to store customer information and implement the mechanisms described herein a file IO layer e.g. software bound to the individual search index files including a term index type file making up the search index and a query interface to execute queries and operations as described herein. Main memory and its sub elements are operable in conjunction with processing logic and processor to perform the methodologies discussed herein.

Processor represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processor may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processor is configured to execute the processing logic for performing the operations and functionality which is discussed herein.

The computer system may further include a network interface card . The computer system also may include a user interface such as a video display unit a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. an integrated speaker . The computer system may further include peripheral device e.g. wireless or wired communication devices memory devices storage devices audio processing devices video processing devices etc. .

The secondary memory may include a non transitory machine readable storage medium or a non transitory computer readable storage medium or a non transitory machine accessible storage medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable storage media. The software may further be transmitted or received over a network via the network interface card .

While the subject matter disclosed herein has been described by way of example and in terms of the specific embodiments it is to be understood that the claimed embodiments are not limited to the explicitly enumerated embodiments disclosed. To the contrary the disclosure is intended to cover various modifications and similar arrangements as are apparent to those skilled in the art. Therefore the scope of the appended claims are to be accorded the broadest interpretation so as to encompass all such modifications and similar arrangements. It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the disclosed subject matter is therefore to be determined in reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

