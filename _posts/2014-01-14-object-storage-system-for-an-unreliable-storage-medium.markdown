---

title: Object storage system for an unreliable storage medium
abstract: A method and computer device for storage and retrieval of a data object on a storage medium. The method includes steps of disassembling the data object into a predetermined number of redundant sub blocks, storing the redundant sub blocks on the storage medium, retrieving at least a predetermined multiple of a minimal spreading requirement of the redundant sub blocks from the storage medium, and assembling the data object from any combination of a particular number of the redundant sub blocks, the particular number corresponding to a predetermined multiple of a minimal spreading requirement. The computer device includes modules for performing the steps.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09135136&OS=09135136&RS=09135136
owner: Amplidata NV
number: 09135136
owner_city: Lochristi
owner_country: BE
publication_date: 20140114
---
This application is a continuation application of U.S. Patent Application Serial No. 13 976 061 filed on Jun. 26 2013 which is a 371 nationalization of Application No. PCT EP2011 074035 filed Dec. 23 2011 which is a non provisional patent application claiming the priority benefit of U.S. Provisional Application Ser. No. 61 427 330 filed on Dec. 27 2010 and U.S. Provisional Application Ser. No. 61 427 377 filed on Dec. 27 2010 which applications are incorporated herein by reference in their entirety.

The present invention generally relates a distributed data storage system. Typically such distributed storage systems are targeted at storing large amounts of data such as objects or files in a distributed and fault tolerant manner with a predetermined level of redundancy. The present invention relates more particularly to a distributed object storage system.

The advantages of object storage systems which store data objects referenced by an object identifier versus file systems such as for example US2002 0078244 which store files referenced by an inode or block based systems which store data blocks referenced by a block address in terms of scalability and flexibility are well known. Object storage systems in this way are able to surpass the maximum limits for storage capacity of file systems in a flexible way such that for example storage capacity can be added or removed in function of the needs without degrading its performance as the system grows. This makes such object storage systems excellent candidates for large scale storage systems.

Such large scale storage systems are required to distribute the stored data objects in the object storage system over multiple storage elements such as for example hard disks or multiple components such as storage nodes comprising a plurality of such storage elements. However as the number of storage elements in such a distributed object storage system increase equally the probability of failure of one or more of these storage elements increases. To cope therewith it is required to introduce a level of redundancy into the distributed object storage system. This means that the distributed object storage system must be able to cope with a failure of one or more storage elements without data loss. In its simplest form redundancy is achieved by replication this means storing multiple copies of a data object on multiple storage elements of the distributed object storage system. In this way when one of the storage elements storing a copy of the data object fails this data object can still be recovered from another storage element holding a copy. Several schemes for replication are known in the art. In general replication is costly as the storage capacity is concerned. This means that in order to survive two concurrent failures of a storage element of a distributed object storage system at least two replica copies for each data object are required which results in storage capacity overhead of 200 which means that for storing 1 GB of data objects a storage capacity of 3 GB is required. Another well known scheme is referred to as RAID systems of which some implementations are more efficient than replication as storage capacity overhead is concerned. However often RAID systems require a form of synchronisation of the different storage elements and require them to be of the same type and in the case of drive failure require immediate replacement followed by a costly and time consuming rebuild process. Therefor known systems based on replication or known RAID systems are generally not configured to survive more than two concurrent storage element failures. Therefor it has been proposed to use distributed object storage systems that are based on erasure encoding such as for example described in WO2009135630 or US2007 0136525. Such a distributed object storage system stores the data object in encoded sub blocks that are spread amongst the storage elements in such a way that for example a concurrent failure of six storage elements out of minimum of sixteen storage elements can be tolerated with a corresponding storage overhead of 60 that means that 1 GB of data objects only require a storage capacity of 1.6 GB.

Current erasure encoding based distributed object storage system for large scale data storage are well equipped to efficiently store and retrieve large data objects however when small data objects need to be stored or retrieved the latency generated by the encoding technology can become too large especially if small data objects need to be stored in large quantities. The same holds for large data objects when only a smaller section of the data needs to be retrieved because in traditional distributed object storage systems the data object can only be retrieved in its entirety and retrieval can only start after the data object was entirely stored.

Therefore there still exists a need for a simple configuration facility that is able to cope with small data objects and data fragments of large data objects in a more efficient manner.

According to a first aspect of the invention there is provided a distributed object storage system which according to a first storage and retrieval option comprises 

This enables a distributed object storage system with a configuration that allows an increase in performance with regards to the storage of small data objects by a hybrid approach that differentiates the storage technology used on the basis of the size of the data object.

According to an embodiment said lower data object size threshold is 2 Megabyte or lower preferably 1 Megabyte.

According to a further embodiment said plurality of redundant storage elements each comprise a distributed key value store and in that said replication copies are stored in said distributed key value store. This enables a simple mechanism for storing the replication copies aside from the sub blocks which in some distributed object storage systems is already available.

Preferably said distributed key value store further comprises metadata of said data objects stored on said storage element said metadata comprising 

Next to functioning as a suitable storage facility for small data objects the key value store allows for a further performance optimization by means of its function as a metadata storage facility.

According to a further embodiment according to a third storage and retrieval option of said distributed object storage system 

This allows still a further performance optimization of the storage and retrieval operation as also the approach for large data objects is differentiated in a way that allows for parallel processing of the requests.

Preferably said upper data object size threshold is equal to or larger than 8 Megabyte preferably equal to or larger than 32 Megabyte.

According to a preferred embodiment according to said third storage and retrieval option of said distributed object storage system 

Optionally according to said third storage and retrieval option of said distributed object storage system is operable to store and or retrieve a specific selection of said sequential data objects by means of said data object offset identifier.

All the aforementioned embodiments allow for still a further performance optimization of the storage and retrieval operation.

According to still a further embodiment according to said first storage and retrieval option of said distributed object storage system 

In traditional systems the CRC calculation would be performed fully on the concatenated dataset even when the CRCs on subsets of the dataset are known. As the CRC calculation is an expensive calculation this requires additional CPU cycles and this takes longer. The system according to the invention optimizes the calculation of a CRC by correctly combining the known CRC s of the subsets. This method results in less CPU cycles and thus a faster CRC calculation which even further optimizes the performance of the storage and retrieval operation.

According to an embodiment according to said first storage and retrieval option of said distributed object storage system 

Optionally according to said first storage and retrieval option of said distributed object storage system 

According to a further optional embodiment according to said third storage and retrieval option of said distributed object storage system said decoding module is further operable during a retrieval operation to calculate the CRC of said data object from the respective CRCs of said plurality of sequential data objects.

According to a second aspect of the invention there is provided an apparatus for storage or retrieval of a data object on a storage medium which is unreliable said storage medium 

Said apparatus is operable to store and retrieve on said storage medium a data object comprising a data object identifier in the form of a predetermined number of redundant sub blocks comprising said data object identifier said predetermined number corresponding to a predetermined multiple of a desired spreading width which consists of the sum of 

According to an said embodiment said storage medium is segmented into at least said desired spreading width of different sections said spreading module further being operable to store said predetermined number of said redundant sub blocks on a number of said sections of said storage medium being larger or equal to said desired spreading width said clustering module further being operable to retrieve at least said predetermined multiple of said minimal spreading requirement of said redundant sub blocks from said sections of said storage medium.

This advantageously applies the teachings of a distributed object storage system in order to improve the robustness of an unreliable storage medium in which optionally the storage medium can be segmented in different sections which will be treated as if they were virtual storage elements of a distributed object storage system.

According to alternative embodiments of the distributed object storage system could comprise any other suitable number of storage nodes and for example two three or more controller nodes also connected to these storage nodes . These controller nodes and storage nodes can be built as general purpose computers however more frequently they are physically adapted for arrangement in large data centres where they are arranged in modular racks comprising standard dimensions. Particular controller nodes and storage nodes such as for example the Amplistor AS storage node as manufactured by Amplidata are dimensioned to take up a single unit of such rack which is generally referred to as 1U.

As shown in several storage nodes can be grouped together for example because they are housed in a single rack . For example storage nodes . . . . . . . and . . each are respectively grouped into racks . . . . . .. Controller node could for example be located in rack .. These racks are not required to be located at the same location they are often geographically dispersed across different data centres such as for example rack . . can be located at a data centre in Europe . . at a data centre in the USA and . . at a data centre in China.

Taking into account the distributed object storage system comprises a plurality of redundant storage elements . The storage nodes each comprise a share of these storage elements . As shown in storage node . comprises ten storage elements . .. Other storage nodes could comprise a similar amount of storage elements but this is however not essential. Storage node . could for example comprise eight storage elements . .. As will be explained in further detail below with respect to the distributed object storages system is operable to store and retrieve a data object comprising data for example 64 MB of binary data and a data object identifier for addressing this data object for example a universally unique identifier such as a globally unique identifier GUID . Storing the data offered for storage by the application in the form of a data object also referred to as object storage has specific advantages over other storage schemes such as conventional block based storage or conventional file based storage such as scalability and flexibility which are of particular importance in a distributed object storage system that is directed to large scale redundant storage applications sometimes also referred to as cloud storage.

The storage elements are redundant and operate independently of one another. This means that if one particular storage element fails its function can easily be taken on by another storage element in the distributed storage system. However as will be explained in more detail further below there is no need for the storage elements to work in synchronism as is for example the case in many well known RAID configurations which sometimes even require disc spindle rotation to be synchronised. Furthermore the independent and redundant operation of the storage elements allows to use any suitable mix of types storage elements to be used in a particular distributed object storage system . It is possible to use for example storage elements with differing storage capacity storage elements of differing manufacturers using different hardware technology such as for example conventional hard disks and solid state storage elements using different storage interfaces such as for example different revisions of SATA PATA and so on. All this results in specific advantages for scalability and flexibility of the distributed object storage system as it allows to add or remove storage elements without imposing specific requirements to their design in correlation to other storage elements already in use in that distributed object storage system .

According to an alternative embodiment the controller node could have an identical design as a storage node or according to still a further alternative embodiment one of the storage nodes of the distributed object storage system could perform both the function of a controller node and a storage node . According to still a further embodiment the device on which the application runs is a controller node .

As schematically shown in controller node comprises four modules an encoding module a spreading module a clustering module and a decoding module . These modules can be implemented as programming instructions stored in local memory of the controller node for execution by its processor .

The functioning of these modules will now be explained to . The distributed object storage system stores a data object offered by the application in function of a reliability policy which guarantees a level of redundancy. That means that the distributed object storage system must for example guarantee that it will be able to correctly retrieve data object even if a number of storage elements would be unavailable for example because they are damaged or inaccessible. Such a reliability policy could for example require the distributed object storage system to be able to retrieve the data object in case of six concurrent failures of the storage elements it comprises. In large scale data storage massive amounts of data are stored on storage elements that are individually unreliable as such redundancy must be introduced into the storage system to improve reliability. However the most commonly used form of redundancy straightforward replication of the data on multiple storage elements is only able to achieve acceptable levels of reliability at the cost of unacceptable levels of overhead. For example in order to achieve sufficient redundancy to cope with six concurrent failures of storage elements data objects would need to be replicated six times and stored on redundant storage elements . This means that next to the master copy of a data object stored on one storage element six replica s must be stored on six other storage elements. As such storing 1 GB of data objects in this way would result in the need of 7 GB of storage capacity in a distributed object storage system this means an increase in the storage cost by a factor of seven or an additional storage overhead of 600 . Therefor the distributed object storage system according to the invention makes use of erasure coding techniques in order to achieve the requirements of the reliability policy with considerably less storage overhead. As will be explained in further detail below when using an erasure encoding with a rate of encoding r 10 16 six concurrent failures of storage element can be tolerated which only require a storage overhead of 60 or a storage cost by a factor of 1.6. This means that storing 1 GB of data objects in this way only results in the need of 1.6 GB of storage capacity in the distributed object storage system . Some erasure encoding techniques make use of Reed Solomon codes but also fountain codes or rateless erasure codes such as online codes LDPC codes raptor codes and numerous other coding schemes are available.

Subsequently as shown in the spreading module will store the predetermined number x n 800 16 12800 of encoded redundant sub blocks . . on a number of storage elements which corresponds to said desired spreading width n 16 such as for example storage elements . .. The spreading module will store on each of these storage elements . . said predetermined multiple x 800 of these sub blocks . As shown in sub blocks . . are stored on storage element . the next x 800 of these sub blocks are stored on storage element . and so on until the last x 800 of these sub blocks are stored on storage element .. As shown in storage elements . . are arranged in storage node . and storage elements . . are arranged in storage node ..

According to an alternative embodiment the sub blocks could be spread by the spreading module on a number of storage elements which is larger than said desired spreading width n 16 for example n 1 16 1 17 storage elements . This could be implemented by for example storing sub blocks . . on storage element . and storing sub blocks . on storage element .. It is clear that this would still allow for the storage system to cope with f 6 concurrent failures of storage elements . Alternative methods for determining the share of sub blocks to be stored on specific storage elements are well known to the person skilled in the art and are for example described in WO2009135630.

It is clear that according to alternative embodiments of the invention other values could have been chosen for the parameters x f k n k f and r k n mentioned in embodiment above such as for example x 400 f 4 k 12 n k f 12 4 16 and r 12 16 or any other possible combination that conforms to a desired reliability policy for redundancy and concurrent failure tolerance of storage elements of the distributed object storage system .

According to still a further alternative there could be provided a safety margin to the number of concurrent failures f that a distributed object storage system needs to be able to cope with. In such an embodiment some of the efficiency is traded in for some additional redundancy over what is theoretically required. This preventively increases the tolerance for failures and the time window that is available for a repair activity. However according to a preferred embodiment this safety margin will be rather limited such that it only accounts for an increase in sub blocks that must be generated and stored of for example approximately 10 to 30 such as for example 20 .

The first storage and retrieval option as described above is optimal for storing large data objects such as for example multimedia files containing audio and or video content which have a size of several Megabytes up to several Gigabytes. However when applying this distributed encoding and decoding scheme to smaller data objects especially when a large number of these smaller data objects needs to be stored or retrieved there exists the risk that when they are stored according to the first storage and retrieval option the encoding and decoding process will introduce a large computational overhead of which the latency will start to outweigh the advantages with respect to storage cost when compared to replication. Furthermore also the decoding data f 1 f 12800 will start to have an impact on the storage cost. If for example the decoding data would require 16 bit as explained above for every sub block then this would amount to about 49600 Bytes for the embodiment described above with x n 16 800 12800 sub blocks . If the data object to be stored is smaller than 1 or 2 Megabytes for example 500 kB then this additional storage cost of about 50 kB can no longer be neglected. In alternative embodiments where the decoding data requires for example 20 Bytes generating sub blocks would mean an additional storage cost of about 256 kB which in the case of a 500 kB data object cannot be neglected. Therefor as shown in the distributed object storage system according to the invention is operated according to the first storage and retrieval option described above only if the size of the data object is equal to or larger than a predetermined lower data object size threshold. This predetermined lower data object size threshold is for example 2 Megabyte or lower preferably 1 Megabyte. If the size of the data object is smaller than this predetermined lower data object size threshold then the distributed object storage system according to the invention is automatically operated according to a second storage and retrieval option which is illustrated in for the embodiment of the distributed object storage system shown in . The storage operation of a data object of 500 kB which is smaller than the predetermined data object size threshold of for example 1 MB according to the second storage and retrieval option. It will be clear from that the plurality of redundant storage elements . . according to the invention are also capable of storing and retrieving the data object identified by its data object identifier in the form of a predetermined plurality of replication copies . . of this data object which are also identifiable by means of this data object identifier during a storage and retrieval operation. In order to fulfil the requirements of the redundancy policy as described above the number of replication copies . . generated corresponds to the desired spreading width which according to this embodiment of the invention was n 16. As such the encoding module will generate n 16 of these replication copies . . each comprising an exact copy of the data object which are subsequently offered to the spreading module which subsequently stores them a corresponding number n 16 of storage elements . .. The computational overhead for the encoding module is much lower than in the first storage and retrieval option because no calculations needs to be performed in order to encode the data object into a plurality of sub blocks . The only operation to be performed by the encoding module is to instruct the spreading module to store a required number of replication copies of the data object on the storage elements . Therefor the latency for storing these smaller data objects is considerably lower during a storage operation. In this way the distributed object storage system enables a storage operation with an optimal level of responsiveness when processing small data objects by means of replication while limiting the impact on the storage cost of the overall system by using a redundant encoding scheme for larger data objects .

According to a preferred embodiment of the distributed object storage system each of the storage elements comprises a distributed key value store in which the replication copies are stored. This is advantageous as such a distributed key value store is also suited to store metadata for the data objects stored in the distributed object storage system in order to allow for efficient storage and retrieval of the data object. During a storage operation the encoding module and or the spreading module add for every data object they store a respective entry for its data object identifier which can subsequently be consulted by the clustering module and or the decoding module during a retrieval operation. Furthermore because the distributed key value store is distributed over the storage elements and it preferably stores metadata for the data objects stored on the respective storage element in this way the metadata is stored according to the same reliability policy as the corresponding data object . According to an embodiment this metadata could for example comprise for each data object stored on the storage element its data object identifier a list of identifiers of the storage elements on which sub blocks or replication copies of this data object are stored and an identifier for the type of storage and retrieval option that was used to store said data object . In the particular case that the data object is stored according to the second storage and retrieval option this could then be supplemented by an entry which comprises the replication copy itself.

According to still a further embodiment as shown in the distributed object storage system can further be operated according to a third storage and retrieval option in order to handle very large data objects more efficiently. The distributed object storage system will then be operated according to this third storage and retrieval option if the size of the data object is larger than a predetermined upper data object size threshold. This upper data object size threshold could for example be equal to or larger than 8 Megabyte preferably equal to or larger than 32 Megabyte as such the upper data object size threshold could for example be 8 Megabyte 16 Megabyte 32 Megabyte 64 Megabyte or 128 Megabyte but could equally be for example 1 or 2 Gigabyte. Such data object could for example be a digital version of a movie which comprises 6 GB of data. As shown in the application offers a data object to encoding module which comprises data with a size of 192 MB. Now the encoding module first splits this data object into a plurality of sequential data objects and in this particular case it concerns three sequential data objects and each comprising an sequential part of the data of data object . This means that data object comprises object data which corresponds to the first 64 MB of the data of data object data object comprises object data that corresponds to the subsequent 64 MB of the data of data object and data object comprises object data that corresponds to the final 64 MB of the data of data object . As such the sequence of the object data of these data objects corresponds to the data of the data object .

Each of the sequential data objects and further comprises a data object identifier and . These data object identifiers each comprise the data object identifier of the data object and a data object offset identifier . The data object identifiers and in this way allow for identification by means of the data object identifier of the data object and also allow tracking of their sequential position by means of the data object offset identifiers and . According to a simple implementation data object identifier could comprise the same GUID that forms the data object identifier supplemented by a data object offset identifier which is a suitable binary representation of the numerical value 0 . The data object identifier equally comprises as a data object identifier the same GUID that forms the data object identifier but is now supplemented by a data object offset identifier which is a suitable binary representation of the numerical value 1 and similarly the data object offset identifier will be a suitable binary representation of the numerical value 2 . Alternatively the data object offset identifier could be any other suitable identifier that enable to identify the correct sequence of the sequential data objects and . As further shown in each of said sequential data objects and is subsequently being stored according to the first storage option as for example shown in . This means that each of the sequential data object and is stored as an amount of encoded sub blocks that are stored on a plurality of storage elements as explained above. According to an advantageous embodiment shown in each of the sequential objects and can be processed in parallel by a storage operation of the first type by means of their respective instance of the encoder module and spreading module . In this way each of storage operation of the first type of the respective sequential data objects progresses independent from the storage operation the other sequential data objects and as such the storage operation is more robust and allows to initiate already retrieval operations on some specific sequential data objects that were stored without the necessity for all of the sequential data objects to be stored.

It will be clear to a person skilled in the art that a number of alternative policies are available for splitting the data object into a number of sequential data objects. A preferred alternative is shown in the embodiment of in which the data object is split into an integer number of sequential data objects and with a predetermined size of 64 MB of course other suitable sizes could be possible. In such a case when the data object to be split is not an exact integer multiple of this predetermined size the last of the sequential data objects could optionally be padded until it for example comprises a multiple of x k 800 10 8000 Bytes. The fact that a large portion of the sequential data objects comprise a fixed size offers the additional advantage that this allows for optimizing for example memory allocation and low level algorithms during the encoding and decoding stage of the storage and retrieval operation of the first type. It is further also preferred to set the upper data object size threshold equal to this predetermined size of the sequential data objects which according to the embodiment described above would be 64 MB. as then the first storage and retrieval option is particularly suited to store and retrieve these sequential data objects efficiently.

During the corresponding retrieval operation for retrieving the data object stored during the storage operation according to the third storage and retrieval operation as shown in the client issues a retrieval request to the distributed object storage system . As explained above in this embodiment the requested data object can be addressed by its object identifier . In response to this request for a retrieval operation the clustering module of the controller node will initiate the retrieval of the sub blocks associated with this data object identifier as comprised within the data object identifiers and of the sequential data objects and . Preferably there will be provided an instance of the clustering module for a plurality of these sequential data objects in parallel. The sequential data objects and are retrieved according to the first storage and retrieval option as described above. This means that for each of the sequential data objects the clustering module will try to retrieve at least the predetermined multiple of the minimal spreading width x k 800 10 8000 of the redundant sub blocks that were stored on the storage elements . The retrieved sub blocks allow the decoding module to assemble the sequential data object and preferably as shown in each of the sequential data objects is decoded by a separate instance of the decoding module . Subsequently the decoding module will be able to assess the correct order of the sequential data objects and by means of their data object offset identifier and . This will allow the decoding module to concatenate the sequential data objects in the correct order such that they form the data object which is subsequently offered to the application .

Although for the embodiment described in the upper data object size threshold has been chosen to be 64 MB it can be chosen to be another convenient value but in order to achieve notable beneficial effects it has been determined that it should be equal to or larger than 8 Megabyte preferably equal to or larger than 32 Megabytes. As such the upper data object size threshold could for example be 8 Megabyte 16 Megabyte 32 Megabyte 64 Megabyte or 128 Megabyte but could equally be for example 1 or 2 Gigabyte.

According to a specifically advantageous embodiment of the distributed object storage system as shown in it is possible to store and or retrieve a specific selection of the sequential data objects and . For example during a retrieval operation of a data object which represents a digital movie comprising data of several GB. The application which for example displays the content of this movie on a suitable device could request to retrieve a specific part of this movie for example in order to start playback at a particular part of the movie or to playback a particular scene. In such a case the application will provide next to the data object identifier of the data object it wants to retrieve an indicator for the specific section of the data it wants to retrieve to the distributed object storage system . This can for example be implemented by means of for example providing an offset and the size of the data section for example in the case of the digital movie the application could be interested in a specific data section which starts at an offset of 1 GB and has a size of 256 MB. It is clear that the distributed object storage system will be able to calculate which particular sequential data objects hold the requested data section and is able to initiate a specific retrieval operation for this selection of sequential data objects by means of their data object offset identifier. Similarly also during a storage operation it is sometimes beneficial to store only a specific data section for example if only a specific part of the data of a data object was updated the distributed object storage system will only need to update the corresponding sequential data objects which can be selected by means of their data object offset identifier.

According to a further embodiment of the distributed object storage system as shown in the encoding module will will generate a Cyclic Redundancy Check also referred to as CRC for each of the sub blocks . As such there will now be available a predetermined number of sub blocks and a predetermined number of CRCs of these sub blocks . The spreading module subsequently stores this predetermined number of CRCs together with their corresponding redundant sub blocks on the storage elements . These CRCs now allow to assess data consistency of the sub blocks stored in the distributed object storage system. It is clear that during the encoding operation a lot of CRCs will need to be calculated and that during a subsequent decoding operation a lot of CRCs will need to be verified. Further adding to this as for example shown in and described in WO2009 135630 is that during the encoding process sub blocks are generated on the basis of intermediate data blocks each of which is preferably provided with a CRC during the encoding process itself in order to verify these intermediate data blocks for data consistency. According to a preferred embodiment of the distributed object storage system the encoding and decoding operation during a storage and retrieval operation of the first type can be performed more efficiently especially with regard to the aspect of the generation and verification of CRCs. According to this embodiment the encoding module is operable to calculate the redundant sub blocks by means of a predetermined combination of XOR operations on intermediate data blocks . This is shown in more detail in where in Step the data of the data object of for example 64 MB is split into x k 800 10 8000 first level intermediate data blocks by the encoding module by splitting the data object into x k 800 10 8000 parts of 8 kB. Optionally if the data can be padded until it comprises a multiple of x k 800 10 8000 Bytes. For each of these first level intermediate data blocks . . a corresponding CRC is calculated by the encoding module. In Step x f 800 6 4800 equally sized second level intermediate data blocks . . are calculated by means of suitable XOR operation of one or more first level intermediate data blocks . Intermediate data block . could for example be the XOR operation of intermediate data block . and .. Also for these second level intermediate data blocks the encoding module will generated a corresponding CRC. The first level and second level intermediate data blocks and in this way form already a set of the predetermined number x n 800 16 12800 intermediate data blocks with a size of 8 kB. Subsequently in Step the encoding module will generate sub blocks . . by applying suitable XOR operations on the intermediate data blocks generated in the previous steps. Sub block . could for example be generated by an XOR operation of intermediate data block . and . and .. As indicated above also for these sub blocks the encoding module generates a corresponding CRC. The way in which these XOR operations are to be performed on the intermediate data blocks in order to generate suitable sub blocks are well known to the person skilled in the art which is aware of erasure encoding and decoding implementations. As such each sub block can be seen as the result of a combination of XOR operations performed on a plurality of intermediate data blocks . In prior art systems the encoder module will calculate the CRC of the sub blocks on the basis of the data they comprise. According to this preferred embodiment of the invention however the CRC of a sub block can be calculated without processing the data of the sub block . This is can be accomplished as the intermediate data blocks all have the same size 8 kB in this example and then there is known that the CRC of the result of an XOR operation on a plurality of these intermediate data blocks will be equal to the result of that same XOR operation applied to the CRCs of these intermediate data blocks . It is clear that the XOR operation on the CRCs of the intermediate data blocks can be executed far more efficiently then the calculation of the CRC based on the data of a sub block as less data is to be processed and less calculations are to be performed. Therefor according to this embodiment the encoding module will calculate the CRC a redundant sub block by applying the predetermined combination of XOR operations to the respective CRCs of the intermediate data blocks that corresponds to the predetermined combination of XOR operations that was performed on these intermediate data blocks in order to generate the sub block . The same could also be applied to the calculation of the CRCs for the second level intermediate data block which could also be calculated by applying the predetermined combination of XOR operations to the respective CRCs of the first level intermediate data blocks which were used to generate this second level data block . As such the only CRCs that need to be calculated based on the data itself are the CRCs of the first level intermediate data blocks all other CRCs can be calculated on the basis of other CRCs. Optionally the XOR operations can be further optimised by prepending or appending the CRC to the intermediate data blocks during the XOR operations performed thereon. In this way the CRCs can be calculated making use of the same XOR operation that is performed on these intermediate data blocks during the encoding process.

As known from for example Everything we know about CRC but afraid to forget Andrew Kadatch Bob Jenkins Sep. 3 2010 the CRC of a concatenated data block which is the concatenation of two data blocks for which the CRC is available can be efficiently calculated without accessing the contents of the concatenated data block. For the sake of brevity we will refer to such functionality as a concatenated CRC generator. Therefore according to a further embodiment as shown in similar to that of with the addition of the fact that the sub blocks now are supplemented with a header which for example comprises for example the data object identifier decoding data f i other suitable identifiers and or status information. The sub block as such is a concatenation of the header and the 8 kB of data of the sub block that is calculated by means of XOR operations on the intermediate data blocks as explained above. The CRC of the header which often has a limited size of for example 16 bits to about 32 bytes can be calculated efficiently on the basis of its data. The CRC of the 8 kB of data can be calculated efficiently from the CRCs of the intermediate data blocks as explained above. The CRC from the entire sub block can then subsequently be calculated from the CRC of the header and the CRC of the 8 kB of data by means of the concatenated CRC generator.

According to still a further embodiment of the distributed object storage system the invention as shown in the processing of CRCs during a retrieval operation according to the first storage and retrieval option is also optimized using these concepts. As explained above during such a retrieval operation the clustering module will retrieve the required sub blocks from the storage elements . Along with these sub blocks it will further also retrieve the respective CRCs of these redundant sub blocks . Subsequently the decoding module as explained above will assemble the data object from a sufficient number of redundant sub blocks . As will be clear to a person skilled in the art when the XOR based erasure encoding scheme was used for encoding the data object then there are available similar XOR based decoding schemes for decoding the data object from these sub blocks . The way in which these XOR operations are to be performed on the sub blocks in order to generate suitable intermediate data blocks are well known to the person skilled in the art which is aware of erasure encoding and decoding implementations. As explained above with reference to the encoding operation the decoding module will be able to calculate the CRCs of the intermediate data blocks from the CRCs of the sub blocks by applying this predetermined combination of XOR operations to the respective CRCs of the redundant sub blocks .

As further shown in the decoding module forms the data object retrieved according to the first storage and retrieval option from a concatenation of a plurality of these intermediate data blocks . As such the decoding module will be able to efficiently calculate the CRC of said data object from the CRCs of these respective intermediate data blocks by means of the concatenated CRC generator as explained above. The processing of the CRCs by means of the concatenated CRC generator can proceed in a linear fashion this means that the concatenated CRC generator first processes the CRC for the concatenation of the first and second intermediate data block and subsequently processes this CRC with the CRC of the third intermediate data block in the sequence in order to calculate the CRC of the sequence of the concatenation of the first second and third intermediate data block and so on until the CRC of the concatenation of all intermediate data blocks forming the data of the data object is calculated. Alternatively the calculation could also be performed in a parallel way this means that in a plurality of parallel instances of the concatenated CRC generator for example first the CRC is calculated for the concatenation of the first and second intermediate data block and in parallel the CRC is calculated for the concatenation of the third and fourth intermediate data block subsequently the CRC for the concatenation of the first to the fourth intermediate data block based on the CRCs calculated in the previous step and so on until the CRC for the concatenation of all intermediate data blocks which form the data of the data object is calculated.

According to a further alternative embodiment as shown in when a plurality of sequential data objects have been retrieved according to the first storage and retrieval option in order to assemble a data object according to the third storage and retrieval option. The decoding module is able to calculate the CRCs of the sequential data objects as described above with reference to . The decoding module is then subsequently able to calculate the CRC this data object from the respective CRCs of the plurality of sequential data objects by means of the concatenated CRC generator.

According to still a further embodiment it is possible as for example described in Everything we know about CRC but afraid to forget Andrew Kadatch Bob Jenkins Sep. 3 2010 to calculate the CRC of a message of which a part has been modified from the CRC of the original message efficiently. As such if for example one or more of the sequential data objects constituting a data object are updated or if one or more of the intermediate data blocks for forming the data object are updated the CRC of the update data object can be calculated by means of the CRC of the data object before the update as indicated above. According to a further alternative the CRC can be calculated by using the concatenated CRC generator in a linear or parallel fashion on the CRCs of the updated regions and the CRCs of the regions which have remained unchanged.

According to still a further advantageous embodiment in the case of the first storage and retrieval option the CRC of the data object could be calculated directly from the CRCs of the intermediate data blocks or the CRCs of the sub blocks . The CRC of this data object can then be checked in order to detect if there is any data corruption. If data corruption is detected then in a second phase the more intense process of checking the CRCs of the sub blocks or the intermediate data blocks is initiated. The corrupt sub blocks are eliminated replaced by new sub blocks or the intermediate data blocks and the aforementioned retrieval operation is repeated.

According to still a further aspect of the invention the concepts of the distributed object storage system can be applied to provide for sufficient redundancy when making use of a storage medium which is inherently unreliable. Such an apparatus is suitable to store and retrieve on such a storage medium a data object in the form of a predetermined number of redundant sub blocks as explained with reference to the distributed object storage system. In this case the minimal spreading requirement will when multiplied with the predetermined multiple correspond to the minimal number of sub blocks that are not allowed to fail. The maximal concurrent failures tolerance will when multiplied with the predetermined multiple correspond to the number of sub blocks of said data object which are allowed to fail concurrently. The encoding module and decoding module will operate as described above with reference to the distributed object storage system. The spreading module will to store the predetermined number of redundant sub blocks on the storage medium and the clustering module will be configured to retrieve at least the predetermined multiple of said minimal spreading requirement of the redundant sub blocks from said storage medium.

According to a further embodiment Instead of spreading the data objects in encoded form amongst a plurality of storage elements they are spread amongst a plurality of specific sections of the storage medium. The storage medium will for this purpose be segmented in to a plurality of different sections. If the storage medium is for example a 16 GB Flash drive and the desired spreading width n 16 then the storage medium can be segmented in for example at least n 16 different sections of 1 GB. The spreading module will then store the predetermined number of redundant sub blocks on a number of these sections of said storage medium being larger or equal to said desired spreading width n 16. The clustering module will in this case further be able to retrieve at least said predetermined multiple of said minimal spreading requirement x k 800 10 8000 of redundant sub blocks these sections of said storage medium.

Such storage media could for example be a flash drive which is prone to cell failures after a predetermined number of read or write cycles. But also other storage media such as a magnetic storage medium such as a magnetic tape or disk drive an optical storage medium such as cd or dvd a holographic storage medium or a quantum information storage medium exhibit unreliable behaviour because of some inherent instability of the basic elements of their storage technology. In order to cope with this inherent instability said apparatus comprises a distributed object storage system which executes a storage and retrieval operation of the first type as described above on the virtual storage elements.

Although the present invention has been illustrated by reference to specific embodiments it will be apparent to those skilled in the art that the invention is not limited to the details of the foregoing illustrative embodiments and that the present invention may be embodied with various changes and modifications without departing from the scope thereof. This is especially the case for the exemplary mentioning of all the sizes of data and numbers that have been described as parameters they can easily be adapted to other suitable values and have only been mentioned in order to improve the clarity of the examples. The present embodiments are therefore to be considered in all respects as illustrative and not restrictive the scope of the invention being indicated by the appended claims rather than by the foregoing description and all changes which come within the meaning and range of equivalency of the claims are therefore intended to be embraced therein. In other words it is contemplated to cover any and all modifications variations or equivalents that fall within the scope of the basic underlying principles and whose essential attributes are claimed in this patent application. It will furthermore be understood by the reader of this patent application that the words comprising or comprise do not exclude other elements or steps that the words a or an do not exclude a plurality and that a single element such as a computer system a processor or another integrated unit may fulfil the functions of several means recited in the claims. Any reference signs in the claims shall not be construed as limiting the respective claims concerned. The terms first second third a b c and the like when used in the description or in the claims are introduced to distinguish between similar elements or steps and are not necessarily describing a sequential or chronological order. Similarly the terms top bottom over under and the like are introduced for descriptive purposes and not necessarily to denote relative positions. It is to be understood that the terms so used are interchangeable under appropriate circumstances and embodiments of the invention are capable of operating according to the present invention in other sequences or in orientations different from the one s described or illustrated above.

