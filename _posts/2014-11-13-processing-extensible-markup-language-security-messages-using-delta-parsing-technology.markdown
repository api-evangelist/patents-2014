---

title: Processing extensible markup language security messages using delta parsing technology
abstract: Markup language security messages are processed. A template corresponding to a markup language security message is identified. The markup language security message is parsed for variable values using the template. A transition sequence is generated that represents the entire markup language security message. Each transition in the transition sequence is associated with a portion of the markup language security message. A lightweight data model of the markup language security message is populated using the transition sequence. The lightweight data model includes nodes for the variable values and a set of selected constant values.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09530012&OS=09530012&RS=09530012
owner: International Business Machines Corporation
number: 09530012
owner_city: Armonk
owner_country: US
publication_date: 20141113
---
This application is a divisional of U.S. patent application Ser. No. 13 456 097 filed Apr. 25 2012 which is a divisional of U.S. patent application Ser. No. 11 690 434 filed Mar. 23 2007. The contents of both aforementioned applications are incorporated herein by reference.

The present invention relates generally to a data processing system and in particular to a method and apparatus for web services. More particularly the present invention relates to a computer implemented method apparatus and computer usable program code for processing of extensible markup language XML security messages using delta parsing technology with a lightweight data model.

A web service is a collection of protocols and standards for enabling an application to interact and exchange data with one or more other applications over the Internet. An application that is available over the Internet may be referred to as a web application or a web service application. Web services enable applications on different hardware software databases or network platforms to interact with each other over the Internet.

Web services provide self contained modular platform independent applications. Web service applications are not limited to any one operating system platform or programming language for applications to communicate and exchange data. For example encoding web services messages in extensible markup language enables an application on a computer running a Unix operating system to interact with an application associated with a computer running a Windows operating system. Likewise an application written in Java can interact with an application written in a different programming language such as practical extraction and report language. Thus a web service is like an application programming interface that allows a client to execute an application on a remote computing device as if the application were present on the client s own system.

Web services may be implemented using service oriented architecture in which the basic unit of communication and data exchange between applications is a message. Web services message level communications between applications are generally performed in extensible markup language format. Web services exchange extensible markup language documents and messages over the Internet using standards such as transmission control protocol Internet protocol hypertext transfer protocol simple object access protocol web service definition language and other standards and protocol layers for exchanging data over the Internet.

Web services enable business applications to be shared combined and used by heterogeneous computing devices within a business or enterprise. Web services also allow those business applications to be shared with customers suppliers vendors and business partners. Due to the varied and widespread uses of web services security of web services messages is important to ensure trust and privacy for users as well as to avoid malicious and intentional changes of web services messages man in the middle attacks and repudiations by senders.

Web Services Security defines data structures describing digital signatures encryption and other security devices that can be implemented on top of a simple object access protocol message to secure message data. When Web Services Security is applied to a Web Services message the message may be referred to as a security message. Simple object access protocol is the basic messaging protocol for exchanging extensible markup language messages such as security messages. The simple object access protocol may be thought of as an envelope that encloses an extensible markup language message. Web Services Security provides enhancements to simple object access protocol messaging to provide increased security of message data exchanged by web services. Many of the security features and protocols used in a security message may be found in the simple object access protocol envelope associated with the message.

However Web Services Security processing typically requires that the entire content of an extensible markup language security message be parsed and stored in memory as a tree based data model such as document object model. Document object model tree type data models can result in considerable overhead for creating the data model as well as for traversing the possibly extensive nodes and branches in the data model to access needed data values. Thus currently available Web Services Security message processing may result in decreased performance due to the overhead associated with processing the extensible markup language security message in addition to the overhead associated with the verbosity of extensible markup language messages.

The illustrative embodiments provide a computer implemented method apparatus and computer usable program code for processing markup language security messages. In one embodiment a template corresponding to a markup language security message is identified. The markup language security message is parsed for variable values using the template. The template is stored in a cache. The cache can store multiple templates using transitions. Each transition in the cache is associated with a portion of the markup language security message. A transition sequence is generated that represents the entire markup language security message. A lightweight data model of the markup language security message is populated using the transition sequence. Variable values in the lightweight data model are populated using an original data encoding for the markup language security message without any data conversion. The lightweight data model includes nodes for the variable values and a set of selected constant values. The markup language security message may be an extensible markup language security message.

The lightweight data model may be generated using the template. A set of unneeded constant values from a plurality of constant values in the template may be identified. Constant values in the template that are required to process the markup language security message are selected to form the set of selected constant values. The lightweight data model includes a node for each variable value in the variable values in the security message and a node for each constant value in the set of selected constant values. A node for a value in the set of unneeded constant values is absent from the lightweight data model.

Thus information that is not required for processing the security message is absent from the lightweight data model. Processing security messages may include generating a digital signature verifying a digital signature encrypting data or decrypting data. The lightweight data model may be used to add a digital signature to a portion of the markup language security message verify a digital signature in the markup language security message encrypt a portion of the markup language security message or decrypt an encrypted portion of the markup language security message.

In response to receiving a second markup language security message a determination may be made as to whether a result of a canonicalization of a markup language security message stored in a canonicalization automaton is a match with the second markup language security message. In response to identifying a match between a result of canonicalization stored in the canonicalization automaton and the second markup language security message a canonicalization of the second markup language security message may be skipped.

In response to receiving a second markup language security message a determination may be made as to whether a result of a transformation of a previous markup language security message stored in the transformation automaton is a match with the second markup language security message. In response to identifying a match between a result of transformation of a previous markup language security message stored in the canonicalization automaton and the second markup language security message a transformation of the second markup language security message may be skipped.

With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which different embodiments may be implemented. Many modifications to the depicted environments may be made.

With reference now to the figures depicts a pictorial representation of a network of data processing systems in which illustrative embodiments may be implemented. Network data processing system is a network of computers in which embodiments may be implemented. Network data processing system contains network which is the medium used to provide communications links between various devices and computers connected together within network data processing system . Network may include connections such as wire wireless communication links or fiber optic cables.

In the depicted example web services server and server connect to network along with storage unit . Web services server is a server providing access to one or more applications to users on network as a web service. Web services server is any type of computing device employing a web services protocol stack to enable users at a remote computing device to access and execute applications on web services server by means of network .

Server is any type of server including but not limited to an application server a web services server or any other type of server. In addition server may also request access to and or execution of one or more web services applications available on web services server . Likewise web services server may also request access to and or execution of one or more web services applications available on server .

Clients and connect to network and request to access and or execute applications on web services server . These clients and may be for example personal computers or network computers. In the depicted example web services server provides data such as boot files operating system images and applications to clients and . Clients and are clients to web services server in this example. Network data processing system may include additional servers clients applications and other devices not shown.

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols and web services protocol stack to communicate with other computing devices and applications connected to network . At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN a wireless network a wide area network WAN an Ethernet or the Internet. is intended as an example and not as an architectural limitation for different embodiments.

With reference now to a block diagram of a data processing system is shown in which illustrative embodiments may be implemented. Data processing system is an example of a computer such as web services server or client in in which computer usable code or instructions implementing the processes may be located for the illustrative embodiments.

In the depicted example data processing system employs a hub architecture including a north bridge and memory controller hub MCH and a south bridge and input output I O controller hub ICH . Processing unit main memory and graphics processor are coupled to north bridge and memory controller hub . Processing unit may contain one or more processors and even may be implemented using one or more heterogeneous processor systems. Graphics processor may be coupled to the MCH through an accelerated graphics port AGP for example.

In the depicted example local area network LAN adapter is coupled to south bridge and I O controller hub and audio adapter keyboard and mouse adapter modem read only memory ROM universal serial bus USB ports and other communications ports and PCI PCIe devices are coupled to south bridge and I O controller hub through bus and hard disk drive HDD and CD ROM drive are coupled to south bridge and I O controller hub through bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS . Hard disk drive and CD ROM drive may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. A super I O SIO device may be coupled to south bridge and I O controller hub .

An operating system runs on processing unit and coordinates and provides control of various components within data processing system in . The operating system may be a commercially available operating system such as Microsoft Windows XP Microsoft and Windows are trademarks of Microsoft Corporation in the United States other countries or both . An object oriented programming system such as the Java programming system may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both.

Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processing unit . The processes of the illustrative embodiments may be performed by processing unit using computer implemented instructions which may be located in a memory such as for example main memory read only memory or in one or more peripheral devices.

The hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the illustrative embodiments may be applied to a multiprocessor data processing system.

In some illustrative examples data processing system may be a personal digital assistant PDA which is generally configured with flash memory to provide non volatile memory for storing operating system files and or user generated data. A bus system may be comprised of one or more buses such as a system bus an I O bus and a PCI bus. Of course the bus system may be implemented using any type of communications fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture.

A communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. A memory may be for example main memory or a cache such as found in north bridge and memory controller hub . A processing unit may include one or more processors or CPUs. The depicted examples in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a tablet computer laptop computer or telephone device in addition to taking the form of a PDA.

The illustrative embodiments recognize that existing extensible markup language messaging security uses a structured tree data model similar to document object model DOM to process extensible markup language security messages. The structured tree data model may result in performance bottlenecks due to document object model tree construction unnecessary data handling and document object model tree traversal.

The illustrative embodiments provide a computer implemented method apparatus and computer usable program code for processing markup language security messages. In one embodiment a template corresponding to a markup language security message is identified. The template contains constant values and variable values. Constant values are values that tend to remain constant or the same in multiple different security messages. Variable values are values that tend to vary or change in different security messages. In other words in security messages conforming to a common structure or type the variable values tend to be different in different security messages while constant values tend to remain the same.

The markup language security message is parsed for variable values using the template. The template may be stored in a cache. The cache can store a transition. The transition in the cache is associated with a portion of the markup language security message. A transition sequence is generated that represents the entire markup language security message.

The security message is parsed for variable values because these values are generally different in different security messages. Therefore the variable values in the template cannot be used in place of the actual variable values in the security message for generating a transition sequence. However the constant values in the security message are the same as the constant values in the template. Therefore the security message does not need to be parsed for the constant values. Instead the constant values from the template are used for generating the transition sequence.

The transition sequence is an intermediate sequence representing the security message. Each transition in the transition sequence is associated with a portion of the markup language security message. The transition sequence is used to populate a lightweight data model corresponding to the markup language security message. The lightweight data model is a Web Services Security data model that stores only the collection of information required for Web Services Processing. Processing security messages may include generating a digital signature verifying a digital signature encrypting data or decrypting data. The lightweight data model may be used to add a digital signature to a portion of the extensible markup language message based on the lightweight data model verify a digital signature in the markup language security message encrypt a portion of the markup language security message and decrypt an encrypted portion of the markup language security message.

Thus information that is not required for processing the security message is absent from the lightweight data model. The data model is lightweight such that a user can develop an implementation of the data model so as to reduce unnecessary memory usage and performance overhead when the data model is accessed. In other words because the data model does not include data values that are not used during processing of security messages it is easier and more efficient for a processor to traverse or retrieve needed data from the data model during processing of the security message. Thus the illustrative embodiments provide an improved logical structure for a data model that provides increased efficiency and reduces performance overhead during processing of security messages.

In one embodiment variable values in the lightweight data model are populated using an original data encoding for the markup language security message without any data conversion. The lightweight data model includes nodes for the variable values and a set of selected constant values. The set of selected constant values contains one or more constant values in these examples.

In one embodiment the lightweight data model is generated using the template. A set of unneeded constant values from a plurality of constant values in the template may be identified. Constant values in the template that are required to process the markup language security message are selected to form the set of selected constant values. The lightweight data model includes a node for each variable value in the variable values in the security message and a node for each constant value in the set of selected constant values. A node for a value in the set of unneeded constant values is absent from the lightweight data model.

The lightweight data model may be stored in a cache. The cache may be an automaton. The automaton may store a template for a security message transitions corresponding to the security message and or a lightweight data model corresponding to the security message. The lightweight data model may be mapped to the transitions. The automaton may store the entire lightweight data model or only a portion of the lightweight data model.

As used herein an automaton is a finite state machine. An automaton may consist of two parts a state and a transition. A state is a condition with regard to structure form phase or status. The state outputs stored data such as the current internal state of a parser at that moment and or a state of a portion of a lightweight data model. A transition is a change or movement from one state to another. A transition has a constant value or a variable generated from an input security message as a transition condition. In other words an automaton may be used to model and or store states of a system and transitions between those states.

In response to receiving a second markup language security message a determination may be made as to whether a result of a canonicalization of a markup language security message stored in a canonicalization automaton is a match with the second markup language security message. Canonicalization is the process of converting data that may be represented in multiple different formats into a standard format. Canonicalization may be necessary because markup languages such as extensible markup language may be written in varying equivalent formats. For example the use of white space inside extensible markup language elements is not significant. Therefore is syntactically equivalent to . Canonicalization is a transformation of extensible markup language in one format to extensible markup language in another equivalent format. Therefore to ensure that logically identical security message elements are treated the same despite variations in the element syntax canonicalization may be necessary to transform security messages into a standard format.

In response to identifying a match between a result of canonicalization stored in the canonicalization automaton and the second markup language security message a canonicalization of the second markup language security message may be skipped.

In response to receiving a second markup language security message a determination may be made as to whether a result of a transformation of a previous markup language security message stored in the transformation automaton is a match with the second markup language security message. In response to identifying a match between a result of transformation of a previous markup language security message stored in the canonicalization automaton and the second markup language security message a transformation of the second markup language security message may be skipped.

Thus the illustrative embodiments provide a processing model of extensible markup language messaging security to improve message processing performance. A lightweight data model is used instead of the currently used structured tree or document object model type data structure to reduce performance overhead for accessing the data model. Delta parsing is also used to avoid unnecessary data handling. For example unnecessary data handling may occur during the canonicalization process and or during transformation. Canonicalization refers to the process of converting data into a standard format for processing of the data. Transformation refers to the process of converting data from a source format into a destination format.

The illustrative embodiments herein are described in the context of extensible markup language security messaging associated with a Web Service. However the illustrative embodiments are not limited to Web Services Security messaging. The lightweight data model coupled with delta parsing technology of the illustrative embodiments may be implemented to process any type of markup language message containing a security element.

Web services server is a computing device providing access to a web services application located on or locally to web services server . Web services server is any type of known or available general computing device. Web services server may be implemented using any type of computing device such as a personal computer laptop personal digital assistant or any other computing device depicted in . In this example web services server may be web services server in .

Client is connected to web services server by a network connection such as network in . In this example the network is the Internet. Client requests to access and or execute a web services application associated with web services server by sending a web services request to web services server . In order to secure the web services request the request is generated as a web services security WS Security message such as Web Services Security message with a security element included in the simple object access protocol envelope of Web Services Security message .

Web Services Security processor on client and Web Services Security processor on web services server are Web Services Security processors that utilize delta parsing technology. Web Services Security processor encrypts message data and generates digital signatures to create security element in outgoing Web Services Security messages such as Web Services Security message .

Security element is a portion of an extensible markup language message delimited by a pair of security element tags. Security element may include a digital signature encryption and other nested security elements. Web Services Security processor also processes incoming Web Services Security message to decrypt message data and verify digital signatures in security element . Web Services Security processor includes delta parsing engine for parsing incoming Web Services Security messages. Likewise Web Services Security processor includes delta parsing engine for parsing incoming security messages.

Delta parsing engine is software for parsing an extensible markup language message using a template to identify variable values. In Web Services Security messaging extensible markup language messages frequently contain identical portions of the message with some values that vary or change from one message to the next. The values that tend to change from one extensible markup language message to the next are referred to as variable values. The values that tend to remain constant in the extensible markup language message format used for multiple extensible markup language messages are referred to as constant values.

Delta parsing engine and or delta parsing engine parses an extensible markup language message for variable values using a message template corresponding to the received extensible markup language message. The templates used by delta parsing engine are stored in automaton . In other words automaton is a cache for storing one or more cached extensible markup language message templates. Likewise automaton on web services server also stores cached extensible markup language message templates for Web Services Security messages.

Thus in accordance with this embodiment Web Services Security processor on client generates outgoing Web Services Security message to request access to an application on web services server . Web Services Security processor on web services server processes Web Services Security message by calling delta parsing engine .

To parse the message delta parsing engine identifies a matching template cached in automaton . A matching template is an extensible markup language message template that corresponds to the message structure of the entire extensible markup language message or a portion of the extensible markup language message. The template includes constant values and indicators or variables for non constant variable values.

Delta parsing engine may also retrieve a cached lightweight data model corresponding to Web Services Security message and a transition sequence that represents the entire Web Services Security message .

Each transition in a transition sequence is associated with a portion or snippet of Web Services Security message . In other words each transition could represent an element an element tag a nested sub element a nested sub element tag a content value a variable value a constant value and or an attribute. In other words if a template in automaton that matches the format or structure of Web Services Security message is identified in cache then a transition sequence and data model corresponding to the identified template may also be stored in cache.

Rather than parsing all of Web Services Security message delta parsing engine will use the cached template to parse Web Services Security message only for variable values. Using the template saves processor cycles and improves efficiency because Web Services Security message is only parsed for differences between the cached template and Web Services Security message . The differences between the template and Web Services Security message are identified by byte matching the variable values in the identified template with the byte arrays corresponding to the same variable value arrays in Web Services Security message . Byte matching refers to a byte by byte comparison of bytes in an input byte array with the bytes array in a template.

The difference between the template and Web Services Security message is the variable values. These parsed variable values are plugged into the cached transition sequence corresponding to the identified template saved in cache. If a transition sequence corresponding to the message is not available Web Services Security processor generates a transition sequence based on the parsed extensible markup language message data and stores a newly generated extensible markup language message template and a data model corresponding to the template in automaton for use in processing future extensible markup language messages received from a client such as client . Web services security processor uses the transition sequence to generate the lightweight data model for Web Services Security message .

Web Services Security processor maps the variable values and a set of selected constant values in the transition sequence to the cached data model to generate the lightweight data model. Web Services Security processor does not map all of the constant values to the data model because the data model is a lightweight data model that only includes variable values and selected constant values that are needed to process Web Services Security message . Any constant values that are not required to process Web Services Security message are not included in the lightweight data model of the illustrative embodiments.

The lightweight data model includes nodes for the variable values and a set of selected constant values. Web Services Security processor traverses the lightweight data model to access and decrypt message data in Web Services Security message .

If web services server decides to send an outgoing Web Services Security message response to client Web Services Security processor generates Web Services Security message including security element based on a lightweight security model generated by Web Services Security processor . When client receives Web Services Security message Web Services Security processor parses the message generates a transition sequence and populates a lightweight data model to process data from Web Services Security message .

In accordance with an illustrative embodiment if a template matching an extensible markup language message or a portion of an extensible markup language message is not found in automaton Web Services Security processor creates a template for the extensible markup language message by parsing the entire extensible markup language message. Web Services Security processor stores the newly generated extensible markup language message template in automaton for use in processing future extensible markup language messages received from servers such as web services server .

Web Services Security is an emerging mechanism to add security features to extensible markup language based simple object access protocol messages. Simple object access protocol is the primary data transfer protocol used by web services for the transmission of web services messages. Application data is embedded in a body element of a simple object access protocol message. Security information is embedded in a header element of the simple object access protocol message.

Security message includes security element embedded in a header element of the simple object access protocol envelope. Security element is delimited by security tags and . Security element includes security token element and signature element . Signature element is an extensible markup language digital signature included in the simple object access protocol message delimited by tags and .

Reference element is a value for a uniform resource identifier reference value. Reference element may be used to enable interaction between resources over a network.

Digest element is a variable value that is a digest of a portion of an extensible markup language message. A digest is a hash value of a hash function used to verify the integrity of message data.

Signature value is a variable value that may be used to decrypt a digital signature embedded in or associated with an extensible markup language message. A digital signature may include a cryptographic signature with mechanisms such as message authentication codes and integrity hashes used to verify the integrity of signature element .

In most cases web services messages exchanged between applications are sufficiently similar that portions of the messages are virtually identical. For example if a web service client sends extensible markup language messages that are secured by Web Services Security to the same web service repeatedly and or a web service receives messages that are secured by Web Services Security the structure of the simple object access protocol messages will be exactly the same with the exception of some variable values such as identifier values reference URI values digest values signature values and application data. In such cases an extensible markup language message template can be generated based on the constant parts of the message.

Template includes constant values and variable values. In this example variable values are indicated by an empty box or rectangular shape where a variable value should be provided or may be found. In this example the template does not include a value for the variable because the value may vary in different extensible markup language messages. In other words variable values cannot be predicted. Therefore template indicates variable values that may be parsed and or identified in a given security message.

Template is shown only for illustrative purposes and is not intended to suggest any structural format element or value limitations for a template. Template is merely one example of a possible format structure elements attributes and values that could be found in an extensible markup language message. In other words possible extensible markup language message templates are not limited to the format elements and values shown in template . A template generated based on any extensible markup language message may be used in accordance with the illustrative embodiments.

In this illustrative example template includes security element which is delimited by tags and . Security element includes security token element and signature element . Security token element includes variable values and . The other values in security token element are constant values that do not vary in disparate extensible markup language messages matching template .

In this example signature element is an extensible markup language digital signature included in the simple object access protocol message delimited by tags and . Reference element contains variable value . Digest element includes variable value . Signature value includes variable value .

Template may be stored in a cache or other data storage. In this example template is located in an automaton such as automaton in . When an extensible markup language message is received the message is compared to one or more templates cached in the automaton. If the entire extensible markup language message or any portion of the extensible markup language message matches the constant portions of one or more templates in the cache the matching of one or more templates may be used by the delta parsing engine such as delta parsing engine in to parse the extensible markup language message for variable values. There is no need to parse the extensible markup language message for constant values because these values are already available in the template. In one embodiment if a template matching or corresponding to a security message is not found a new template is generated based on the security message. The newly generated template is stored in cache for use in processing future extensible markup language messages.

A delta parsing engine can use template to parse an extensible markup language message for variable values by comparing the extensible markup language message to template . The constant portions of extensible markup language message template will be identical in the extensible markup language message.

The delta parsing engine considers the extensible markup language message as a byte array. The delta parsing engine compares the extensible markup language message to template and extracts the difference or variables by byte matching without regular extensible markup language parsing. Regular extensible markup language parsing would parse the entire extensible markup language message. Delta parsing only parses the extensible markup language message for differences between the extensible markup language message and extensible markup language message template . In this manner the illustrative embodiments improve processing performance by using delta parsing based on extensible markup language template .

In one embodiment canonicalization of the extensible markup language message is performed prior to the delta parsing engine comparing the extensible markup language message to extensible markup language message template . In another example a canonicalization corresponding to extensible markup language message template is stored in cache. This cached canonicalization is used to canonicalize the extensible markup language message rather than performing a new canonicalization process on the extensible markup language message.

Web Services Security processor populates a transition sequence with the parsed variable values identified by delta parsing the extensible markup language message using the identified template. In this manner Web Services Security processor generates a transition sequence for the extensible markup language message. The transition sequence may be a transition sequence retrieved from cache or a transition sequence generated by the Web Services Security processor. The transition sequence contains a transition representing every value in the extensible markup language message represented by the transition sequence. In other words the transition sequence represents the entire extensible markup language message.

Next the Web Services Security processor maps a set of transitions from the transition sequence corresponding to the extensible markup language message to a lightweight data model. The lightweight data model is smaller or has fewer nodes than a traditional document object model type tree data structure. In other words a traditional document object model type tree data structure would provide a node for every value in the entire extensible markup language message. However this results in processing overhead due to data model generation and traversal to locate needed data values. Therefore the lightweight data model excludes or does not provide nodes for values that are not necessary for processing a given extensible markup language message.

In this example constant parts in the transition sequence are mapped to the lightweight data model only if the constant values are necessary for decrypting and accessing data in the extensible markup language security message. For example a signature object for a digital signature element is necessary to verify a digital signature of a portion of an extensible markup language message. Therefore the digital signature element will be mapped from the transition sequence to the lightweight data model even though the digital signature element is constant in multiple different extensible markup language messages exchanged between one or more clients and a web services server.

Delta parsing engine is a software component in a Web Services Security processor for performing delta parsing of message to identify variable values such as signature value and cipher value . Delta parsing engine is a delta parsing engine such as delta parsing engine in . Delta parsing engine performs byte matching between a template identified as corresponding to message and message . If a template corresponding to all of message or a portion of message is not found delta parsing engine performs regular parsing of the entire message or a portion of message to create a new template. In other words the illustrative embodiments allow complete parsing of a security message or only partial parsing of a portion of a security message to create a template and or a lightweight data model corresponding to the entire security message or the portion of the security message. The new template is stored in an automaton for use in processing extensible markup language messages received in the future. The automaton may also be used to store transition sequences lightweight data models results of transitions and or results of canonicalization in addition to or instead of storing the template.

After delta parsing message to identify the set of variable values delta parsing engine retrieves transition sequence corresponding to the identified template from cache. If a transition sequence corresponding to the identified template is not available in cache a transformation process is performed on message to generate transition sequence . In this example the newly generated transition sequence is also stored in an automaton for use in processing extensible markup language messages received in the future.

In this example transition sequence is available in cache. Therefore delta parsing engine populates transition sequence with the set of variable values. It is not necessary to populate transition sequence with constant values because cached transition sequence already includes all the constant values.

In this example signature value in message shown in is a selected constant value that is needed to process the digital signature embedded in the simple object access protocol envelope of message . Signature tags and as well as a constant value for signature value in message are mapped from transition sequence to data model shown in . Signature tag in message is mapped to node in data model . Likewise signature value is mapped to node . Nodes and are nodes for selected constant values. Node is mapped to variable signature value . In other words all the variable values and the set of selected constant values in transition sequence that are needed to process and verify message are mapped to data model . However constant values that are not needed for processing and verifying that message are not mapped from transition sequence to data model . In this manner data retrieval and traversal of data model requires fewer processor cycles and results in improved Web Services Security message processing performance because unnecessary data handling message parsing and transformations are avoided.

Data model holds the minimum information needed by the Web Services Security processor to process and add a digital signature to the extensible markup language message or verify a digital signature in the extensible markup language message. Web Services Security processor can traverse data model more easily than a document object model type tree data structure holding all the values from the extensible markup language message.

Data model includes canonicalization method for canonicalizing the extensible markup language message. The actual value for the canonicalization method exc c14n is mapped to node . Data model also contains signature method signature value canonicalization automaton binary security token BST value and reference details . Key information includes information required to resolve a key used for digitally signing. Reference details include the reference to a portion of the message information about transforms digest method digest value and automaton used for transformations .

An automaton is a software component for storing one or more cached templates performing transformations performing canonicalization processes and or any other function associated with processing an extensible markup language message. In this example canonicalization automaton is an automaton for performing canonicalization operations. Transformation automaton is an automaton for performing transformation operations.

Data model includes key encryption method encrypted cipher data key information reference details and encrypted data details . Encrypted cipher data is encrypted data of the key used for data encryption. Key information includes information required to resolve a key used for encrypting. Reference details include the references to the encrypted data objects.

Encrypted data details may include but are not limited to data encryption method encrypted cipher data of the original data in the message and message template used for message replacement in the generator side or automaton used for decrypted data matching in the consumer side. The generator side refers to the Web Services Processor on the computing device that generated the extensible markup language message mapped to data model . The consumer side refers to the Web Services Security processor on the computing device that received the extensible markup language message and is decrypting and or processing the extensible markup language message to obtain message data.

Delta parsing engine is a delta parsing engine in Web Services Security processor for performing delta parsing of the extensible markup language message. Delta parsing engine receives transition sequence corresponding to an object to be verified in the extensible markup language message as input. Transition sequence is retrieved from the transition sequence corresponding to the extensible markup language message such as transition sequence in . Transformations automaton stores the transitions corresponding to one or more extensible markup language messages. Thus in this example delta parsing engine matches transition sequence with the transitions cached in transformations automaton .

Web Services Security processor makes a determination as to whether transition sequence matches completely with the cached transitions in automaton step . If transition sequence does not match completely with the cached transitions at step Web Services Security processor calls all necessary transforms step corresponding to the transform information stored in data model and constructs post transform template . A transform is necessary if it is needed to transform an input transition sequence into post transform template . A necessary transform may include but is not limited to a canonicalization transform.

Next Web Services Security processor updates transformations automaton with the post transform template step for use in processing future transformations.

Returning to step if the transition sequence does match with the cached transitions Web Services Security processor generates post transform template based on the results of delta parsing performed by delta parsing engine and the cached transforms step . Post transform template is the same as post transform template because using the cached transforms leads to the same result as the transformations operation performed in step .

In other words the meaning of the XPath expression in the transformation operations performed in step will always result in post transform template that is the same as post transform template generated based on the cached transforms and the results of delta parsing because the constant values in the cached transforms remain consistent from one extensible markup language message to the next. XPath is a language used to locate elements and attributes in an extensible markup language document. The variable values that do not remain consistent are identified by delta parsing the extensible markup language message. Thus we can skip transformations step and use the cached transforms to reduce the number of processor cycles required to generate the post transform template. Therefore Web Services Security processor can skip the transformations operation when it receives an extensible markup language message that has the same or similar structure. The details of how to construct a post transform template are shown below in .

Web Services Security processor populates the actual value of all variable parts in the post transform template and serializes the template step . Serialization refers to encoding data structures as a series of bytes. Web Services Security processor calls message digest to calculate the digest value of the serialized byte array derived in step . Web Services Security processor then checks or compares the digest value of the serialized byte array to the digest value stored in the data model step . If the digest value matches the stored value then the message is verified using the data model.

A delta parsing engine such as delta parsing engine in treats an input as a transition sequence. Thus when input transition sequence for an extensible markup language security message is received by the delta parsing engine the delta parsing engine determines if input transition sequence matches a cached transition sequence stored in a transformations automaton. If matching cached transitions are found the Web Services Security processor uses the results of delta parsing with the cached transforms to generate post transform template . Web Services Security processor fills or populates post transform template with the actual variable values and then performs a serialization operation to form serialized byte array .

However if cached transitions corresponding to input transition sequence are not available the Web Services Security processor calls transformers corresponding to the transform information stored in the data model and constructs post transform template . In this example Web Services Security process calls Xpath transform and canonicalization transform to generate post transform template . The data values in serialized byte array may then be used to perform verification of integrity of the extensible markup language security message.

Returning to step if the input completely matches with the cached transitions Web Services Security processor generates post canonicalization template based on the cached transforms and the results of delta parsing step .

Next Web Services Security processor fills the actual values of the variable parts in post transform template and serializes the template step . Serialization refers to encoding data structures as a series of bytes. Web Services Security processor calls signature engine to calculate the signature value of the serialized byte array derived in step . Web Services Security processor then checks or compares the signature value of the serialized byte array with the signature value stored in data model step by passing the serialized byte array derived in step . If the signature value in the byte array matches the signature value in the data model the digital signature embedded in the extensible markup language message is validated.

Web Services Security processor is an extensible markup language message processor on the generator side. Web Services Security processor signs portions of an outgoing extensible markup language message based on data model . Delta parsing engine of Web Services Security processor receives transition sequence corresponding to an object to be signed in the extensible markup language message as input. Transition sequence is retrieved from the transition sequence corresponding to the extensible markup language message such as transition sequence in . Delta parsing engine makes a determination as to whether transition sequence matches with the transitions cached in transformations automaton step . If transition sequence does not match with the cached transitions Web Services Security processor calls all necessary transformers corresponding to the transform information stored in data model step and constructs post transform template step . Next Web Services Security processor updates transformations automaton with the post transform template step for use in processing future transformations.

Returning to step if transition sequence completely matches with the cached transitions Web Services Security processor generates post transform template as a result of delta parsing. Web Services Security processor uses delta parsing to populate the variable values and uses cached transitions sequences to generate post transform template steps . The process in step results in the exact same post transform template generated as a result of performing transformation operations in step . Therefore Web Services Security processor can skip transformation operations in step the next time Web Services Security processor receives an extensible markup language message that has the same structure as the extensible markup language message being processed in .

Web Services Security processor fills and serializes the post transform template step . Serialization refers to encoding data structures as a series of bytes. Next Web Services Security processor calls message digest to calculate the digest value of the serialized byte array derived in step and stores the digest value in data model step with the process terminating thereafter.

Delta parsing engine receives transition sequence corresponding to the signed information element as input. Delta parsing engine makes a determination as to whether transition sequence matches with transitions cached in canonicalization automaton step . If transition sequence does not match with the cached transitions Web Services Security processor calls canonicalizer step and constructs post canonicalization template step . Next Web Services Security processor updates canonicalization automaton with post canonicalization template for use in processing future canonicalization. Therefore Web Services Security processor can skip canonicalization operations in step the next time Web Services Security processor receives an extensible markup language message that has the same structure as the extensible markup language message being processed in .

Returning to step if transition sequence completely matches with the cached transitions Web Services Security processor generates post canonicalization template by using the cached transitions and variable values identified by delta parsing engine as a result of delta parsing step . Post canonicalization template and post canonicalization template is the same post canonicalization template including the same values.

Web Services Security processor fills or populates post canonicalization template with variable values and serializes the template step . Serialization refers to encoding data structures as a series of bytes. Next Web Services Security processor calls signature engine to calculate a signature value by passing the serialized byte array derived in step and stores the signature value in data model step with the process terminating thereafter.

Web Services Security processor calls encryption engine to encrypt a byte array of a portion of an extensible markup language message step . Web Services Security processor stores encrypted data in node of data model step . Web Services Security processor replaces transition sequence that is cached in the encrypted data object in data model with transition sequence for the encrypting part step with the process terminating thereafter.

The process begins by receiving an extensible markup language security message step . The process makes a determination as to whether a cached template corresponding to the extensible markup language security message is available step . If a cached template is available the process performs delta parsing of the extensible markup language security message using the template step .

Next the process determines if a cached transition sequence corresponding to the extensible markup language security message is available in a transformations automaton step . If a cached transition sequence is available the process retrieves the cached transition sequence step . Next the process maps variable values and selected constant values identified by delta parsing to a lightweight data model using the transition sequence step with the process terminating thereafter.

Returning to step if a cached template corresponding to the extensible markup language security message is not available the process performs regular parsing of the entire message step . In one embodiment after parsing the entire message the parsing results are used to generate a template which is stored in cache.

Returning now to step if a cached transition sequence is not available the process calls all necessary transform operations to generate the transition sequence step . The process then stores the generated transition sequence in a transformations automaton step . The process then retrieves the cached transition sequence step and maps selected constant values and variable values to a lightweight data model using the transition sequence step with the process terminating thereafter.

The illustrative embodiments provide a computer implemented method apparatus and computer usable program code for processing extensible markup language security messages. In one embodiment a template matching an extensible markup language message is identified. The extensible markup language message is parsed for variable values using the template. A transition sequence that represents the entire extensible markup language message is generated. Each transition in the transition sequence is associated with a portion of the extensible markup language message. A lightweight data model for extensible markup language message level security is populated using the transition sequence. The lightweight data model includes nodes for the variable values and a set of selected constant values.

The illustrative embodiments provide an alternative processing model for extensible markup language messaging security to improve extensible markup language message processing performance. This alternative processing model uses delta parsing to avoid unnecessary data handling and unnecessary duplicative processing of extensible markup language message data that remains constant in multiple extensible markup language message elements.

The illustrative embodiments also couple delta parsing with a lightweight data model to reduce the performance overhead. In currently used processing methods overhead is caused by traversing a document object model type data structure containing every constant and variable data value found in an extensible markup language message to access the variable data. The lightweight data model of the illustrative embodiments includes variable values and a subset of constant values rather than including all constant values from an extensible markup language security message element. Thus the data structure is more lightweight or smaller than currently used data structures. Therefore Web Services Security processors expend fewer processor cycles traversing the data model to access variable data and process extensible markup language message data represented by the data model.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

