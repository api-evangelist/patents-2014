---

title: Systems and methods for controlling cacheability and privacy of objects
abstract: Described herein are systems, devices, and methods for content delivery on the Internet. In certain non-limiting embodiments, a caching model is provided that can support caching for indefinite time periods, potentially with infinite or relatively long time-to-live values, yet provide prompt updates when the underlying origin content changes. Origin-generated tokens can drive the process of caching, and can be used as handles for later invalidating origin responses within caching proxy servers delivering the content. Tokens can also be used to control object caching behavior at a server, and in particular to control how an object is indexed in cache and who it may be served to. Tokens may indicate, for example, that responses to certain requested URL paths are public, or may be used to map user-id in a client request to a group for purposes of locating valid cache entries in response to subsequent client requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09641640&OS=09641640&RS=09641640
owner: AKAMAI TECHNOLOGIES, INC.
number: 09641640
owner_city: Cambridge
owner_country: US
publication_date: 20141006
---
This application is based on and claims the benefit of priority of U.S. Application No. 61 887 302 filed Oct. 4 2013. This application is a continuation in part of U.S. application Ser. No. 14 046 884 filed Oct. 4 2013.

This disclosure generally relates to distributed data processing systems and to the delivery of content to users over computer networks and more particularly to techniques for caching content to accelerate content delivery over computer networks.

Distributed computer systems are known in the prior art. One such distributed computer system is a content delivery network or CDN that is operated and managed by a service provider. The service provider typically provides the content delivery service on behalf of third parties. A distributed system of this type typically refers to a collection of autonomous computers linked by a network or networks together with the software systems protocols and techniques designed to facilitate various services such as content delivery or the support of outsourced site infrastructure. This infrastructure is typically shared by multiple tenants the content providers. The infrastructure is generally used for the storage caching or transmission of content such as web pages streaming media and applications on behalf of such content providers or other tenants. The platform may also provide ancillary technologies used therewith including without limitation DNS query handling provisioning data monitoring and reporting content targeting personalization and business intelligence.

In a known system such as that shown in a distributed computer system is configured as a content delivery network CDN and has a set of machines distributed around the Internet. Typically most of the machines are servers located near the edge of the Internet i.e. at or adjacent end user access networks. A network operations command center NOCC may be used to administer and manage operations of the various machines in the system. Third party sites affiliated with content providers such as web site offload delivery of content e.g. HTML or other markup language files embedded page objects streaming media software downloads and the like to the distributed computer system and in particular to the CDN servers which are sometimes referred to as edge servers . Such servers may be grouped together into a point of presence POP at a particular geographic location.

The CDN servers are typically located at nodes that are publicly routable on the Internet within or adjacent nodes that are located in mobile networks in or adjacent enterprise based private networks or in a combination thereof.

Typically content providers offload their content delivery by aliasing e.g. by a DNS CNAME given content provider domains or sub domains to domains that are managed by the service provider s authoritative domain name service. The server provider s domain name service directs end user client machines that desire content to the distributed computer system or more particularly to one of the CDN serves in the platform to obtain the content more reliably and efficiently. The CDN servers respond to the client requests for example by fetching requested content from a local cache from another CDN server from the origin server associated with the content provider or other source.

For cacheable content CDN servers typically employ a caching model that relies on setting a time to live TTL for each cacheable object. After it is fetched the object may be stored locally at a given CDN server until the TTL expires at which time the object is typically re validated or re fetched from the origin server . For non cacheable objects sometimes referred to as dynamic content the CDN server typically must return to the origin server each time when the object is requested by a client. The CDN may operate a server cache hierarchy to provide intermediate caching of customer content in various CDN servers closer to the CDN server handling a client request than the origin server one such cache hierarchy subsystem is described in U.S. Pat. No. 7 376 716 the disclosure of which is incorporated herein by reference.

Although not shown in detail in the distributed computer system may also include other infrastructure such as a distributed data collection system that collects usage and other data from the CDN servers aggregates that data across a region or set of regions and passes that data to other back end systems and to facilitate monitoring logging alerts billing management and other operational and administrative functions. Distributed network agents monitor the network as well as the server loads and provide network traffic and load data to a DNS query handling mechanism . A distributed data transport mechanism may be used to distribute control information e.g. metadata to manage content to facilitate load balancing and the like to the CDN servers. The CDN may include a network storage subsystem sometimes referred to herein as NetStorage which may be located in a network datacenter accessible to the CDN servers and which may act as a source of content such as described in U.S. Pat. No. 7 472 178 the disclosure of which is incorporated herein by reference.

As illustrated in a given machine in the CDN comprises commodity hardware e.g. a microprocessor running an operating system kernel such as Linux or variant that supports one or more applications . To facilitate content delivery services for example given machines typically run a set of applications such as an hypertext transfer protocol HTTP proxy a name server a local monitoring process a distributed data collection process and the like. The HTTP proxy sometimes referred to herein as a global host or ghost typically includes a manager process for managing a cache and delivery of content from the machine. For streaming media the machine may include one or more media servers such as a Windows Media Server WMS or Flash server as required by the supported media formats.

A given CDN server shown in may be configured to provide one or more extended content delivery features preferably on a domain specific content provider specific basis preferably using configuration files that are distributed to the CDN servers using a configuration system. A given configuration file preferably is XML based extensible markup language based and includes a set of content handling rules and directives that facilitate one or more advanced content handling features. The configuration file may be delivered to the CDN server via the data transport mechanism. U.S. Pat. No. 7 240 100 the contents of which are hereby incorporated by reference describe a useful infrastructure for delivering and managing CDN server content control information and this and other control information sometimes referred to as metadata can be provisioned by the CDN service provider itself or via an extranet or the like the content provider customer who operates the origin server. U.S. Pat. No. 7 111 057 incorporated herein by reference describes an architecture for purging content from the CDN machines. More information about a CDN platform can be found in U.S. Pat. Nos. 6 108 703 and 7 596 619 the teachings of which are hereby incorporated by reference in their entirety.

In a typical operation a content provider identifies a content provider domain or sub domain that it desires to have served by the CDN. The CDN service provider associates e.g. via a canonical name or CNAME or other aliasing technique the content provider domain with a CDN hostname and the CDN provider then provides that CDN hostname to the content provider. When a DNS query to the content provider domain or sub domain is received at the content provider s domain name servers those servers respond by returning the CDN hostname. That network hostname points to the CDN and that hostname is then resolved through the CDN name service. To that end the CDN name service returns one or more IP addresses. The requesting client application e.g. browser then makes a content request e.g. via HTTP or HTTPS to a CDN server machine associated with the IP address. The request includes a host header that includes the original content provider domain or sub domain. Upon receipt of the request with the host header the CDN server checks its configuration file to determine whether the content domain or sub domain requested is actually being handled by the CDN. If so the CDN server applies its content handling rules and directives for that domain or sub domain as specified in the configuration. These content handling rules and directives may be located within an XML based metadata configuration file as noted above.

The CDN platform may be considered as an overlay across the Internet on which communication efficiency can be improved. Improved communications on the overlay can help when a CDN server needs to obtain requested content from an origin server or from another CDN server that is acting as an intermediate cache parent or when accelerating communication of non cacheable content across the overlay on behalf of a content provider or otherwise. Communications between CDN servers and or across the overlay may be enhanced or improved using route selection protocol optimizations including TCP enhancements persistent connection pooling and reuse content header compression and de duplication and other techniques such as those described in U.S. Pat. Nos. 6 820 133 7 274 658 7 607 062 and 7 660 296 among others the disclosures of which are incorporated herein by reference.

As an overlay offering communication enhancements and acceleration the CDN server resources may be used to facilitate wide area network WAN acceleration services between enterprise data centers and or between branch headquarter offices which may be privately managed as well as to from third party software as a service SaaS providers used by the enterprise users.

Along these lines CDN customers may subscribe to a behind the firewall managed service product to accelerate Intranet web applications that are hosted behind the customer s enterprise firewall as well as to accelerate web applications that bridge between their users behind the firewall to an application hosted in the internet cloud e.g. from a SaaS provider .

To accomplish these two use cases CDN software may execute on machines potentially in virtual machines running on customer hardware hosted in one or more customer data centers and on machines hosted in remote branch offices. The CDN software executing in the customer data center typically provides service configuration service management service reporting remote management access customer SSL certificate management as well as other functions for configured web applications. The software executing in the branch offices provides last mile web acceleration for users located there. The CDN itself typically provides CDN hardware hosted in CDN data centers to provide a gateway between the nodes running behind the customer firewall and the CDN service provider s other infrastructure e.g. network and operations facilities . This type of managed solution provides an enterprise with the opportunity to take advantage of CDN technologies with respect to their company s intranet providing a wide area network optimization solution. This kind of solution extends acceleration for the enterprise to applications served anywhere on the Internet. By bridging an enterprise s CDN based private overlay network with the existing CDN public internet overlay network an end user at a remote branch office obtains an accelerated application end to end. illustrates a general architecture for a WAN optimized behind the firewall service offering such as that described above along with examples of possible data flows across the overlay. Other information about a behind the firewall service offering can be found in teachings of U.S. Pat. No. 7 600 025 the teachings of which are hereby incorporated by reference.

While known techniques such as those currently used in CDNs offer many advantages there is a need for techniques to better accelerate traffic for which a no store or explicit TTL caching approach is suboptimal which is an increasing and important part of the traffic on the Internet. Content accessed through application programmer interfaces API are one example of such traffic. With the foregoing by way of introduction the improved systems methods and apparatus that are the subject of this disclosure are described below.

This disclosure describes among other things systems devices and methods for content delivery on the Internet. A caching model is described that can improve upon known time to live TTL based caching and no store approaches although such techniques can be used in conjunction with the teachings hereof as will be explained below . Approaches described herein can support caching for indefinite time periods while still updating promptly when the underlying origin content changes making them suited for among other things content retrieved using an application programming interface API although this is not a limitation.

For example in one embodiment an origin server can be programmed to annotate its responses to client content requests with identifiers in the form of tokens. In the case of an API the API running on the origin server can be programmed to annotate responses to client requests made to the API with tokens. The tokens can drive the process of caching the origin responses within caching proxy servers in the delivery platform. The TTL for issued responses can be considered to be infinite or relatively long enabling acceleration from cached responses in the proxies. Subsequently the tokens can be used as handles to invalidate prior responses.

Preferably tokens can correspond to or denote data or logic used to create the response at origin. For example a particular record in a database driving content generation at origin can correspond to a token. A token could also correspond to a file or other data at origin. When such a record file or other origin data is updated then an invalidation assertion can be issued for the token from origin for example and propagated to the appropriate proxy caches. Responses in the proxy caches that were tagged with the token then can be invalidated as those responses are dependent on data that has changed. A token could correspond to any item or set of data so the approach is flexible with regards to the origin database structure and content generation infrastructure.

Tokens can also be used to control object caching behavior at a server and in particular to control the privacy of response objects. Tokens may indicate for example that responses issued from certain URL paths are public tokens may also be used to map user id tendered in a client request to a group id for purposes of locating valid cache entries cached under or associated with that group id.

The subject matter described herein has a wide variety of applications in content delivery and online platform architectures and can be used in conjunction with CDN services and technologies.

As those skilled in the art will recognize the foregoing description merely refers to examples of the invention in order to provide an introduction. Other embodiments will be described in the remainder of this document. The foregoing is not limiting and the teachings hereof may be realized in a variety of systems methods apparatus and non transitory computer readable media. It should also be noted that the allocation of functions to particular machines is not limiting as the functions recited herein may be combined or split amongst different machines in a variety of ways.

The following description sets forth embodiments of the invention to provide an overall understanding of the principles of the structure function manufacture and use of the methods and apparatus disclosed herein. The systems methods and apparatus described herein and illustrated in the accompanying drawings are non limiting examples the claims alone define the scope of protection that is sought. The features described or illustrated in connection with one exemplary embodiment may be combined with the features of other embodiments. Such modifications and variations are intended to be included within the scope of the present invention. The abbreviation e.g. is used herein as shorthand for the non limiting phrase for example. 

According to this disclosure the functionality of a server is modified to provide content acceleration using a caching system that supports indefinite caching periods or said another way notification based invalidation instead of or in supplement to time expiration based invalidation. The server is typically a caching proxy server modified in accordance with the teachings hereof and may be part of a distributed CDN platform.

The techniques described herein may in certain embodiments offer improved acceleration for a variety of kinds of traffic and are particularly useful for without limitation API traffic. This disclosure describes approaches to caching of API traffic of the kind where the content provider customer offers an API to its users and the request responses delivered via that API are carried over and accelerated via a CDN so as to enable productized API acceleration. While the API use case is often used herein to provide a concrete example and illustration the teachings hereof are not limited to API traffic. Any traffic that can benefit from an indefinite caching period with notification based invalidation can benefit from the teachings hereof. The benefits may vary but the teachings hereof can be used with respect to delivery of any kind of object.

In one embodiment a system employs a set of caching proxy servers such as the CDN proxy servers described above and these caching proxy servers are modified in accordance with the teachings hereof. Such modified servers are sometimes referred to herein as Hologram servers a mnemonic inspired from project a hologram of your database into the network to differentiate the system from placing the authoritative copy of a database into the CDN system itself which these teachings do not require but with which would also be compatible .

Note that in some implementations the Hologram servers may be used in supplement to other CDN proxy servers e.g. that do not provide the caching and acceleration functions described herein by acting for example as a cache parent to the front line of CDN proxy servers deployed at the network edge.

In operation the customer s origin infrastructure can issue one or more tokens sometimes referred to as tags with API responses preferably in certain non standard HTTP headers. This is an adjustment to origin programming. The tokens drive the process of caching and invalidating these API responses within the CDN platform and in particular at the Hologram servers. Tokens issued by origin notate the pieces of data used in the API responses. The TTL for the API responses can be considered to be infinite or very long e.g. a year for these responses allowing them to be cached. The origin later invalidates by token potentially invalidating multitudes of prior API responses.

The tokens can be used as cache handling directives allowing responsive content to exist in cache and remain valid for serving for a long time when underlying origin data is quiet and then rapidly update in response to a flurry of changes at origin. This approach can support caching that is neither no store nor TTL based which are today s predominant approaches for accelerating un cacheable dynamic objects and offers an eventually consistent but preferably rapidly consistent data model. The approach is database agnostic allowing a content provider customer to utilize any SQL or No SQL database they like at origin.

The tokens can denote a variety of things. In a common case a token is associated with an item of data that appears in or was used to construct the given API response. Such a token can act as a handle for invalidating from a caching perspective an API response when data associated with that given data token changes in an origin database underlying the API is no longer valid. Thus a token can correspond to or has some ready counterpart in the underlying database. For example the token can represent a primary key for a record in the origin database and when that record changes the token can be used to invalidate those API responses that were based on that record.

The meanings of tokens are preferably selected such that collectively the tokens notating a particular response are tied to the data and logic that gave rise to the construction of the response but that might at some later time be altered and to match conveniently the ability to later invalidate upon those tokens taking into consideration how the origin system will maintain and monitor its own state how to conveniently refer to pieces of data by a handle and how to reliably express all changes to data through one or more tokens.

In a preferred implementation the system is built into a CDN and separate from the origin infrastructure which hosts the databases and acts as the authoritative source of data from the API. However the teachings hereof apply to implementations outside of CDN services as well.

An API or Application Programmer Interface is typically a wrapper around a service database or system made by one team of programmers for another team often outside their own organization. Some APIs are made for public consumption and some API s are made for internal use by a company s various teams as an organizing function. APIs generally encourage encapsulation of unnecessary details and enforce business logic and best practices. APIs often serve as a focusing agent to make contributing to a system or ecosystem much much simpler than without an API as only the API needs to be understood nothing else.

In a general technical sense an API is often realized as a documented set of calls that come with a definition on how they will behave and usually the data they will return. In the context of the web an API often comprises a pattern of HTTP requests understood at a certain domain or URL path that will act inside the web server system and with connected systems and return information back out to the web client or take an action and report a result back to the web client.

The web client will not often simply display or render the information directly as returned as in the case of web browsing but rather will use some logic to programmatically act on the data. Often that logic is encoded in Javascript or natively into the client application e.g. in a mobile app such as one written for the iOS or Android operating systems. In this way transactions can be accomplished although it should be said that simply laying out information on a page in an app is also a common use case although technically it may not be an HTML page as one might understand it in the context of discussing web browser software.

Data is often passed into the web API using GET and POST or other HTTP calls and returned from the web API using XML or JavaScript object notation JSON other open formats or proprietary formats. The format is generally designed to be easy for a computer to parse.

Much API work is a wrapper of REST calls yielding XML or JSON from SQL database queries. Sometimes the queries are quite complex or a series of queries is executed for a single response. Sometimes application layer caching is involved for performance.

This response carries information about a flight including the airports and flight equipment but also timestamps regarding planned and actual events. The information in this request will likely not change at all while waiting for the flight and then a flurry of changes will occur over a few hours that are very real time sensitive to any consumer of the API and then after conclusion of the flight the data will again settle to a permanent quiet period. In the event that some major piece of data changes leading up to the flight it s likely to be the type of aircraft or departure time or terminal and in both cases these are changes that should be reflected as instantly as possible in responses.

Serving this type of API response over a conventional dynamic no store CDN delivery solution with all traffic terminating at origin may make it more reliable than self hosting. Adding a small period of time based TTL caching in the CDN may make the origin traffic more tolerable although global latency to consumers is only helped as the TTL rises which at some level counteracts data freshness. Setting a high TTL and appealing to the purge functionality of a large CDN will result in purge timeframes that are too long for satisfactory updates for this and similar use cases. Thus a new way to look at caching and purging capability may be useful here and is addressed by the teachings hereof.

In one embodiment the origin API response can be augmented to comply with Hologram. An HTTP header named X Hologram Data can be added which can be listed before the payload as a normal header or after the payload as a trailer. The use of a trailer may be advantageous because the metadata in the trailer will come as a byproduct of payload construction at origin. In the example below the value of this header carries tokens separated by commas and optional whitespace following each comma and the tokens denote data rather than logic used to construct the response or ranges .

The size of the added header or trailer perhaps a couple hundred bytes would typically add very little to the overall size of the API response and it would enable Hologram caching. In this example the metadata is a list of comma separated tokens. As mentioned previously a variety of types of tokens are possible data tokens selection sorting tokens etc. and a variety of formats are possible too. In this case the data query was a direct lookup of a flight ID so only tokens denoting origin data are necessary and all tokens are essentially table primary key combinations.

 For the purpose of this example assume we know the table names and structure at origin. This is not necessarily reflected in the XML of the API response. In practice the tokens can be issued by code written by the same developers as the API so they understand the underlying data schema. 

The token can be constructed to relate to any set of data in the underlying database at origin. In this example assume the database supporting the API has a flight table containing the flight ID as a primary key. Therefore it is convenient to have the token be based on and represent the table primary key into the database and so the form table key is a reasonable default template.

The system is flexible though and the system is generally agnostic to how the token relates to the origin database. The actual table name need not be used as long as the name is a way to reference a bundle of data that will change or remain constant together. Full normalization is not required every table relationship need not be represented as long as when the data changes one of the tokens represented on this line is considered affected by origin. In sum the token need not be the actual primary key though it preferably represents a unique indexed key or hash that the origin can reference rapidly and relate to the actual primary key in the database. In fact the table colon value structure is also not needed and any token matching the regular expression A Za z0 9   can be accepted. Syntax extensions may also permit additional feature expression.

This flexibility means that any kind of data can be tokenized for the system. The above example focuses on a SQL database context but no SQL memcache or even file system elements can be converted into tokens. For example an origin could decide to have a token that represents the name of a stored file. 

Returning to the example the API response references two airports the departure and arrival airports. Note that for the purpose of tokens the relationship of the airports is now irrelevant so which one is the departure versus arrival is not notated nor is any reference back to the XML necessary at all as the system need not attempt to parse the XML and in fact this data payload could have been encoded as JSON or another format.

In an alternate embodiment the system could determine the tokens from the API response payload itself rather than relying on origin to produce and append the data tokens in a header. This might occur with or without assisting domain specific configuration in the CDN for that content provider s API traffic. The domain specific configuration in the CDN would contain transformation instructions to convert the various payloads into control headers or equivalent expressions with appropriate tokens. For example a configuration may call for the origin response payload to be scanned by a Hologram server for certain predetermined patterns or markup that designates token information embedded in the response. The token information would typically then be stripped out of the response and converted into a header or other equivalent field for communication within the Hologram system.

As another example an XSLT file could be associated with each URL pattern in an XML emitting API and when a response traverses through a Hologram server e.g. a Hologram server closest to the origin the XSLT would be applied to the XML in a standards compliant manner in order to generate a resulting document that is the same as or an XML fragment easily parseable into the needed header s that could have been transmitted along with the response in the first place. Similarly for JSON responses a document expressing data structure paths to walk in order to lift values from the JSON could be saved instead of XLST.

After transformation the transformed document provides the control data the tokens that would normally accompany a payload but the transformation is not intended to necessarily replace the payload. Because the control data ordinarily should not need to change between servers if a server would normally retain a control header from origin then after performing a transformation the server may append the control headers derived from transformation to the other HTTP headers before returning the response to a downstream requesting Hologram server. Thus in the context of dashed lines the parent Hologram server could append the control data before transmitting the decorated response to the child Hologram server.

Continuing through the XML in the API response we see that timestamps are available for events such as a flight departure time. These are all considered atomic data represented in the token list under the token flightId 12345. Thus when timestamps change or new timestamps are added the origin programming would be configured to know that all responses that had the token flightId 12345 are affected and presumably need to be invalidated.

Carrier codes are represented in the token list by mentioning a token each for the related carrier and for the related carrier s flight number. Because this type of flight number is a consumer flight number the developer at origin can design to have it stored in a separate table and to use a flightnum table designator as a token.

Finally the equipmentNumber N783AN and equipment 777 tokens represents the aircraft itself and a record for the type of airplane equipment .

Described above was the issuance of tokens from origin with API response payloads and how the tokens can represent the data structures in origin databases that gave rise to the content in the payload.

For API responses the cache time can be infinite or very long lasting unlike TTL based caching where some time is expressed. A Hologram compatible response is valid so long as none of the constituent tokens are invalidated. In other words in one implementation the HTTP proxy caches in a CDN may cache the API responses indefinitely until affirmatively invalidated by origin.

In the flight record example above until an invalidation is received for one of the 13 tokens listed the response XML document is considered to be valid to serve in response to end user client requests. During this time which may be quite long the document may be cached by the Hologram servers in the network and served repeatedly from cache.

In an alternative embodiment the Hologram system could require periodic revalidation of tokens with origin as a safety precaution and it could also overlay a global TTL to expire API responses notwithstanding that their corresponding data tokens are still valid as a safety precaution or as a data storage conservation measure. These are both compatible with the teachings hereof.

In an embodiment a Hologram server can obey standard cache related HTTP headers emitted from origin given that such headers would be expressed in conjunction with Hologram control headers and thus could take into account that a much longer time period is appropriate. Obeying all normal HTTP headers is compatible with the teachings hereof.

There are many possible techniques for invalidating a token. Just by way of example a token might be invalidated by i the inclusion of an invalidation assertion for a token in a given API response or ii the active calling of a Token Invalidation API by the origin when origin changes data outside the context of serving a web request . Such a Token Invalidation API is not to be confused with the API being accelerated.

Turning to invalidation mechanism i the Hologram network of servers preferably can handle an invalidation inline with any API response. In most cases the API response will actually be a response to a client request to update the API database i.e. a write message insofar as that event will cause records in the database to change and precipitate an invalidation. However the architecture can also support an invalidation inline with a response to a client request that is not writing to the database.

To illustrate let us say for purposes of illustration that the flight status API from above also allows updates to data and an authenticated user has issued an HTTP call to that API that will update the flight number of the Great Air codeshare for the flight. In the API response from origin for example an HTTP 200 ok response a Hologram invalidation can be included 

This notation would invalidate any document relying on the original flight number and the flight in question by the flight ID. The invalidation is asserted by listing tokens prepended with an exclamation mark to indicate invalidation. The Hologram node can be responsible for initiating the propagation of the invalidation through the remainder of the Hologram network or preferably for sending the invalidation to a publisher node in the network that publishes an invalidation channel for the given API domain more detail on which will be given below.

Turning to invalidation mechanism ii the Token Invalidation API mechanism can operate as follows at some point assume a piece of information changes. Let us assume that the XML was retrieved before the aircraft landed and then the aircraft landed resulting in arrivalDate status and actualArrival nodes to be updated in the XML. The origin may utilize a private and secured Token Invalidation API call to the CDN network to invalidate tokens. HTTPS and some form of API key authorization could be overlaid to the example here. The hologram path would be a pseudo path understood by Hologram enabled domains served by the CDN network.

In many cases the invalidation of a single token can function to invalidate all responses that were marked with that token which could potentially represent multitudes of API response documents network wide. The invalidation message must be propagated across the machines that support Hologram. This single invalidation can be sufficient to invalidate the XML response above such that a subsequent client request for the same content will need to be forwarded to origin to resolve. This invalidation also simultaneously invalidates any other response that depends on information about flight 12345 that is any documents previously served with a token of flightId 12345 among its various appended tokens.

As an alternative invalidation example let us pretend that London Heathrow Airport was changing its name to The Royal Airport. The invalidation API call would be 

Once propagated any response containing information about Heathrow on this particular API is now invalid in the CDN network and future responses from origin would reflect a different airport name allowing newly correct data to populate the CDN network in cache as client requests are fulfilled.

Preferably the origin can hold open a persistent HTTP or SPDY connection to the Token Invalidation API entrypoint so that the anticipated series of invalidations can be multiplexed across this connection.

In an alternate embodiment a WebSocket service could be made available such that origin would open a WebSocket to a CDN server e.g. one of the Hologram servers or otherwise and use the WebSocket to transmit invalidations.

In yet another example a hook polling call can be requested by origin meaning that either origin would make an API call to request or the domain specific CDN configuration would dictate a regular polled HTTP request from a CDN server to the origin requesting any and all updated token information which would then be presented by origin in the response as an alternative to providing it in normal data carrying responses.

The following describes a non limiting embodiment of a network of Hologram servers. An introductory overview to the communications of the Hologram network is presented first.

In this embodiment the various servers in a Hologram network function as an HTTP proxy network that is capable of answering HTTP client requests forwarding requests to nodes closer to origin forwarding to origin and caching the responses returned as they are served back.

In addition the Hologram servers can communicate to each other over a messaging system that is separate from the HTTP channel used to communicate with clients and to request and retrieve responses for clients. The Hologram messaging system could leverage HTTP too if desired but for purposes of description herein assume the HTTP traffic refers to the clients content requests and responses thereto as well as the forward requests and forward responses resulting from proxy operations. 

Messages are exchanged by the Hologram servers with one of them acting as a registrar tracking and assigning which of the servers on the network holds publisher status for any given domain name at any given time. Messages are also published on a publisher subscriber model from each respective publisher to all servers that have subscribed by virtue of receiving HTTP client requests for a domain for which the publishing server is the publisher as tracked by the registrar. The subscription will communicate token invalidations to subscribed servers and thus in this approach being subscribed is the status required in order to treat a local cache as authoritative for a given domain. Messages are also passed from non publishers to the publisher of a given domain if the non publisher goes forward to origin with an HTTP request and receives an origin response with a token invalidation or receives a request from origin on the Token Invalidation API either of which can cause it to have token messages that should be published.

All of the various connections can have logical timeout conditions based on traffic on the connection itself further subscriptions may be unsubscribed per domain as HTTP traffic for that domain becomes absent and publisher status may be cleared as HTTP traffic for a given domain becomes absent at the publisher. All message connections are described as direct but may also be made to be indirect through one or more broker nodes or parents for scalability. The registrar can be an otherwise normal Hologram server acting as registrar in addition to regular actions but it may be a dedicated registrar only server or set of servers or an abstract service provided by other means such as a distributed database service or DNS service.

With reference to a variety of Hologram servers are distributed in the platform. Labeled line segments represent connections between machines solid lines designating HTTP request and response messages and dashed and dotted lines designating connections between Hologram servers for passing token related and other messages. The dotted lines designate messages for a registrar and the dashed lines designate messages amongst Hologram servers in a publisher subscriber or peer relationship. In some cases multiple numerical labels are used as shorthand to indicate multiple line segments between the same nodes without drawing the line segments in duplicate.

Assume that user with client device makes an API request using HTTP to Hologram server as indicated by arrow 1.

Server determines the host domain for the instant HTTP request and determines if the Hologram subscribed status is set locally for the domain. Assume that the status is unsubscribed. As a consequence of being unsubscribed and also not being the publisher server is precluded from consulting its local cache for a previous response. Server determines the closest Hologram server to origin as server and thus prepares to forward the HTTP request to server configuration may have instead led to server forwarding to one or more cache parent servers before ultimately forwarding to server . Server forwards the HTTP request to server as indicated by arrow 2.

Server sends a message to server which serves currently as the registrar on the network indicating the domain its own identity and a flag indicating that the HTTP request is being forwarded to another Hologram server. This message is indicated by arrow 3. Server acting as the registrar determines that no publisher is set for the given domain and the requesting server is forwarding internally and returns an unknown response indicated by the return on arrow 3.

Server receives the HTTP request forwarded by server and performs the same domain check. Assume that server is also unsubscribed. Server forwards the HTTP request to origin indicated by arrow 4.

Server also messages server the registrar indicated by arrow 5 and because server is the closest Hologram server to origin or based on some other metric or combination thereof server assigns server to perform the publisher role for the domain in question returning its own identity in the reply message indicated by the return on arrow 5. Server sets itself as the publisher for the given domain upon receiving the reply.

Assume that the reply from registrar server indicated by the return on arrow 5 arrives at server prior to the completion of the HTTP response received from origin indicated by the return on arrow 4. When the HTTP response from origin is received the tokens attached to the response are parsed and the response is cached locally at server with the tokens indexed.

Server replies to the HTTP request from server as indicated by the return on arrow 2. Server having an unsubscribed status does not cache the response locally but strips token related headers and returns the response to client device as indicated by the return on arrow 1. If server had a subscribed status it could cache the response locally for use in responding to subsequent client requests for the same content as will be stated in more detail below. 

Next assume that user with client device makes an API request to Hologram server as indicated by arrow 6 and the request is for the same content as that previously requested by client device . Assume that on this domain cache keys are not derived from user identity.

Server performs the same checks as before and sends a message to the registrar at server as for the first HTTP client request. This message is indicated by arrow 7. Server responds with the identity of server as the publisher as indicated by the return on arrow 7. Server opens a subscription connection to server reusing a connection if one is open as indicated by line segment . Server performs the same calculation to determine the server closest to origin as before and forwards the HTTP request to server as indicated by arrow 8.

Server consults its local cache being the publisher and finds responsive content for the HTTP request. Further server verifies that each token attached to the original request has not been invalidated since the response was cached and returns the cached content to server as indicated by the return on arrow 8.

Assume that the subscription indicated on line segment is engaged prior to the completion of the HTTP response received from server indicated by the return on arrow 8. When the HTTP response from server is received by server the tokens attached to the response are parsed and the response is cached locally at server with the tokens indexed.

Further requests to server for the same content as above would result in the content being returned from the local cache at server provided that the customary HTTP cache control was satisfied or absent Cache Control headers and similar as well as that none of the tokens originally given with the response have since become invalid by a message from the publisher server over the subscription channel for that domain.

By way of further illustration assume that client device makes a request for the same content as above to server as indicated by arrow 10. Server would similarly to the process described above request publisher identity from server as indicated by arrow 11 forward the HTTP request to server as indicated by arrow 12 and subscribe to server for domain messages as indicated by line segment .

Assume that client device later makes a write request on the API sending an HTTP POST to server as indicated by arrow 14. Assume this domain is configured not to cache POST responses as is fairly customary with HTTP. Server forwards the request to server as indicated by arrow 15 which forwards the request to origin as indicated by arrow 16.

Origin returns an HTTP response as indicated by the return on arrow 16 and when received at server the Hologram tokens are parsed similarly to the description above this time however the origin s HTTP response message contains an invalidation for a token. Assume that the token invalidated was one of the tokens previously mentioned on content returned to client devices and as described above. Server creates a token message that is published to servers and by virtue of their subscription to token messages for the domain. Servers and receive the token message and update their local token caches accordingly.

The HTTP response for the API write action is returned to server as indicated by the return on arrow 15 and then sent to client device as indicated by the return on arrow 14.

Further requests to servers or for the content previously cached using the now invalidated token will result in full traversal back to origin as previously described with the subsequent repopulation of cached content similarly to previously described.

Assume that client device makes a request for content as above to server as indicated by arrow 17. Assume that server calculates that it should forward directly to origin possibly because a supplementary system has indicated that load is high on server or just the result of an alternative implementation. Server forwards the HTTP request to origin as indicated by arrow 18. Upon receiving the response Hologram tokens are parsed and are in need of publishing but server is not the publisher. Server opens a connection for peer to peer token passing or utilizes an existing connection to server the publisher for the domain and passes the token messages to server as indicated by arrow 19. After updating its token cache server passes the message to all subscribers which in this moment are servers and . Server receives the token message as indicated by arrow 20 and updates its local token cache. Server receives the token message as indicated by arrow 21 but will not need to alter its token cache as it was the source for the message and has already done so.

With reference to a snapshot state of an example Hologram network is shown. This is a non limiting embodiment. In this state all Hologram servers and have connections open to server acting as the registrar. HTTP traffic for one domain has been received from client devices and has resulted in open HTTP connections from servers and to server and a connection from server to origin an HTTP connection is also open from server to origin . To facilitate message publishing servers and the same servers that have open HTTP connections also have open subscription connections to server which has been assigned the publisher role for the domain in question. Additionally server has an open peer connection to server in order to pass token messages arising from contacting origin for HTTP responses. Messages regarding token invalidations generally can be distributed outwards from a point close to origin to all subscribed nodes even if they are not originated on the server designated as publisher and must first be sent over to the publisher. Token messages can invalidate prior responses that a subscribed node may have saved in cache and being subscribed is the state that permits the cache to be authoritative in the face of infinite or very long TTL s.

In an alternate embodiment a CDN employs Hologram servers in supplement to non Hologram HTTP proxy servers as illustrated previously in connection with and

In this alternate embodiment a Hologram server is still responsible for going forward to origin to fetch and cache Hologram enabled API responses storing tokens and indexing upon them for rapid access by token and for receiving and propagating token invalidations as fast as possible and can otherwise operate as described in connection with above. However the Hologram server sits behind a non Hologram HTTP proxy for example of the kind that populate a CDN platform without the benefit of the teachings hereof.

With non Hologram HTTP proxy servers alone a no store or must revalidate transaction typically has the type of flow shown in where the non Hologram HTTP proxies are simply designated as Proxy . In the notation used in arrows represent the direction of requests content in responses flows left to right.

A TTL based caching transaction has a type of flow shown in depending on where a valid unexpired copy of the requested content is found.

In the case of the TTL based caching the first instance in shows a cached response close to the client the second instance shows a cached response close to the origin and the third instance shows a cached response close to the origin.

We will now introduce Hologram nodes notated Holo . Proxy servers will be asked to treat responses as no store or must revalidate i.e. as dynamic objects or as cacheable objects but with a very minor TTL such as a couple of seconds while Hologram servers may be authoritative in caching. The Hologram network may be considered similar to a cache hierarchy. This yields the flow possibilities shown in

In the first instance shown in long network traversal is avoided by a Hologram server having a cached document and understanding that as of that instant it is not aware of any token invalidation that renders it invalid in the second instance the Hologram server does not have a valid document and forwards the request to a Hologram server close to origin for a second try a cache choking technique in the third instance the long haul is necessary to contact origin for an authoritative answer.

As before active token invalidation assertions can emanate from origin and are propagated from the initial Hologram server receiving the invalidation to other Hologram servers using a publisher subscriber or other technique as shown in

Described below is an exemplary socket implementation for messaging within a Hologram node. The following is intended only to be a non limiting example for purposes of illustrating a possible design.

In this embodiment the Hologram nodes are designed Hologram nodes are designed with a set of socket operations that facilitate the message flows for support of Hologram subscriptions and invalidations. These operations can augment conventional HTTP proxy capabilities.

In this example design sockets are dedicated to limited function and thus two nodes may be connected with more than a single socket at the same time. An alternative design would consider these boxes to represent virtual handles to other nodes and for single sockets at most to be opened between nodes with multiple message types carried on the same socket queues enforcement of and other details would differ in reasonably straightforward ways.

The design is based on messages which implies a framing format for the beginning and end of messages a maximum size for messages and headers to carry source destination routing and other message passing information. A message queue library may be employed to provide this layer of functionality or these rules can be designed on a custom basis. A subsystem of heartbeat messages between all nodes that normally communicate should be implemented in addition to the messages described below a failed heartbeat should count as a broken connection which particularly for subscribers should be deemed an involuntary unsubscription event.

This is design the IN and PASS are not single sockets but arrays of sockets starting at zero members and growing and shrinking with normal operation. For simplicity in explanation this is not shown in .

The Hologram messaging system may be engineered to run in the same operating system process es as the HTTP proxy system or it may be engineered to run separately in which TCP sockets or an inter process communication system native to the operating system may be used to pass messages from the HTTP proxy system to the Hologram messaging system. At least two types of messages are germane for this inter process link see below for messages arriving at REP and APP.

 REP is an object representing a listening socket that accepts multiple connections and performs the server side of a request reply paradigm. The client side sending requests is the local HTTP proxy system on the same server.

 APP is an object representing a listening socket that accepts multiple connections and accepts messages playing the role of pull in a push pull paradigm. The push side sending requests is the local HTTP proxy system on the same server.

 REG is an object representing a socket that connects form a normal node on the Hologram network to the registrar node on the Hologram network and performs requests in a request reply paradigm. The opposite end of this socket will connect to RGR on the Hologram registrar see RGR for message details. The Hologram registrar if and when processing data as a normal node will resolve registrar related questions by sending a message on REG to RGR and processing the reply as a separate event.

 RGR is an object representing a listening socket that accepts multiple connections and accepts messages from Hologram nodes and replies to them as the registrar. Preferably all Hologram nodes have the capability to act as the registrar. An external monitoring system may signal all Hologram nodes when the registrar needs to change either by changing a DNS entry or changing local configuration alternatively the Hologram nodes can rely on a failover strategy internal to the network.

Inquiry from a Hologram node to request the publisher identity for a host and to provide for a default action of volunteering to be publisher if necessary.

 OUT is an object representing a listening socket that accepts multiple connections from other Hologram nodes subscribing to messages regarding domains for which the given node is the publisher. The Hologram node will publish token messages to subscribed nodes via the OUT object which ensures that the message is distributed to the connected subscribers optionally filtering to limit messages to domains which the subscribers indicate in order to allow all domains published from the same node to be published over the same sockets.

Messages sent over sockets in the OUT object arrive at the sockets in the IN objects at various other nodes.

 IN is an array of zero or more objects representing sockets that connect to Hologram publisher OUT sockets to receive messages in a subscriber role or a publisher subscriber paradigm. IN sockets are added to the array as the need arises to subscribe to per host messages which is typically determined by activity on the REP socket followed by activity on the REG socket.

In order to bolster scalability of the network Hologram IN nodes may make connections directly to broker nodes which make connections onto the final destination thus making the overall number of connections on a fully connected network lower than if every node connected to every other node. The organization of broker nodes may be hard coded or nominated by dynamic election or other self organizing strategy based in whole or part on configuration. Further brokers may communicate with other brokers in arrangements to further separate direct connections.

If HTTP proxy activity for a particular host is not seen by way of the REP socket by a subscriber for some predetermined length of time a node can unsubscribe from those messages on a per host basis.

 PASS is an array of zero or more sockets opened to connect to other Hologram nodes which are publishers in order to pass message in the push role of a push pull paradigm. Messages passed over PASS are token messages that originate off publisher but must be made authoritative and propagated. The opposite end of this socket will connect to FUN on each Hologram publisher see FUN for message details.

If a node has opened a PASS socket to a publisher but has had no messages to pass over to the peer for any host for 1800 seconds continuously 30 minutes the PASS socket to that publisher is closed and removed from the array.

The existence of PASS sockets and the corresponding FUN sockets in the Hologram system can provide scalability in the subset of the network contacting origin without them all requests preferably go through one Hologram server to origin. The presence of PASS FUN sockets is one mechanism to permit multiple Hologram nodes to go forward to origin for HTTP responses as consequent Hologram invalidations retain a path through the network.

In the event that a Hologram node generates a token message but does not currently know the publisher for the given host a situation that may arise in normal operation because the registrar has only received at the time it was consulted by this node GET calls with HOP status and no FINAL status for the last node before origin also may arise from abnormal operation such as a server restart the node will pass the message to the registrar using a PASS socket. The registrar itself can act upon the message arriving at its FUN socket see FUN for details.

 FUN is an object representing a listening socket that accepts multiple connections and plays a pull role in a push pull paradigm to receive token messages from PASS sockets and acts upon them usually by passing them to the OUT socket. The FUN socket on the registrar may give rise to the application level queuing of a message. As soon as a publisher is determined a PASS socket on the registrar is used to pass the queued messages to the publisher s FUN socket where normal operation will continue.

In an example network state is shown. H1 H2 and H3 are nodes on a Hologram network. This is a non limiting embodiment provided for purposes of illustration.

Within each node of this example the PRSO proxy subscriptions output and PRTO proxy tokens output objects are sockets opened in the HTTP proxy software. There are one per Unix process on a multi process proxy daemon but for simplicity a single box is drawn for each. PRSO is an inter process socket that plays a request role in a request reply paradigm to communicate with the REP socket of the Hologram adjunct software. PRTO is an inter process socket that plays a push role in a push pull to communicate with the APP socket of the Hologram messaging software.

In the example shown in H3 is acting as registrar. REG REG2 REG3 are all open to RGR3 in order to facilitate queries necessitated by traffic arriving on REP sockets. H1 is publishing for at least one domain and H2 and H3 have both seen traffic for that domain and subsequently subscribed to receive updates via IN2 and IN3 .

Additionally in the reverse map system has caused both H2 and H3 to become final hops before origin for domains for which H1 is the publisher possibly the same domain as above and therefore PASS2 and PASS3 are open to FUN . H2 has been the final hop to a domain before it knew which node serves as publisher and thus it has opened PASS2 to FUN3 as well in order that the message be sent to the registrar.

The systems described herein can be extended to utilize another kind of token referred to as a cache key token to control how an object is indexed in cache and to whom it may be served. Conventionally objects retrieved in response to a client request that tenders a user id e.g. in a cookie or as part of the URL string or otherwise are treated either as uncacheable or cached with user id or device id or other such identifier in cache key so that they are effectively private. A cache key token can be used to signal to a cache server that the response is cacheable and or is available to serve to a broader set of users beyond the one who originally requested it. Put another way cache key tokens can be used to indicate that a given response object e.g. an API response or otherwise may be cached and served publicly or to a particular group or class of users where by otherwise the object would have been treated as private not cacheable or by default indexed with such a specific key that a subsequent cache hit would be unlikely and impair the cache hit ratio. Preferably cache key tokens are issued from origin with API or other responses in the manner of other types of tokens as described above and can be transported in the system and invalidated similarly.

By way of illustration assume a client device sends a request to a cache server with a particular user id e.g. in a cookie and the server sends a forward request to an origin for the requested content. The origin can send a response and appends a cache key token indicating that the particular requested URL path the path representing a particular API command returns public results. This overrides a default behavior on the server to cache per user id with the result being that the response can be cached and served to other clients.

Alternatively a cache key token may be used to indicate that a particular user id should be ignored for purposes of caching or that the user id should be mapped to a more encompassing group id for purposes of caching the object. A virtually unlimited number of user classes may be defined by group ids meaning the system enables an object to be cached and made available to a set of users of arbitrary scope.

It is important to note that cache key token functionality is compatible with cache servers that leverage non TTL based caching like Hologram servers as well as conventional TTL based caching proxy servers. Cache key functionality is particularly useful with API traffic that may be handled by Hologram servers. This is because many APIs will personalize results based on the user e.g. as an API key making the request. Personalization is typically applied for marketing personalization or application features such as privacy secrecy features group membership and the like.

In one embodiment a cache key token compatible server parses a request for an API call and identifies a user identity value. By default cache entries are created and accessed by user identity as is conventional. For example assume a cookie header carries a userid 123 value. An example might be a user identity cookie with a hash 

In this case the cache server can identify 123 as the user identifier and may even authenticate the hash knowing the origin methodology is SHA256 id password where square brackets show variable interpolation. The user identity of 123 would then be used in accessing and creating cache entries for responses in the conventional approach. However as noted above this hurts cacheability drastically. To mitigate this issue the cache key compatible server can be modified to support a URL Path is Public technique and or a Mapping User Id to Group Technique.

 URL Path is Public Technique. Certain URL paths API endpoints can be designated as public such that requests to those paths are known to be resolved by origin without regard to user identity. In such cases the fact that the user id is present is irrelevant because the request is nevertheless for public information. For example an API command to obtain aggregations of popularity such as tag cloud or trending keywords are often public information rendered without regard to user identity.

The URL path is public technique allows certain URL paths to be dynamically reported by origin as public client calls to these paths result in responses that the origin constructs without employing user identity and that the cache server should cache without employing user identity values in the cache key. The cache server may construct such a cache key by removing the user identity value or replacing it with a notation for public . Alternatively instead of a public response the origin can indicate a group id which the cache server should then use in constructing the cache key.

One of the ways that an origin can indicate that a response is constructed without user identity is to append an HTTP header with a token. These tokens are propagated through the network of servers e.g. using the publisher subscriber techniques described with reference to . For example assume an API endpoint reachable at tagcloud returns public results on a website that supports user login with cookie based user ids. Fetching via an HTTP Get the public tag cloud for an API results in a notation that this command is public 

Entries in the command cache are indexed with a key corresponding to a canonical form of the URL after URL parameter reordering and some common decoding concerns and a value corresponding to the cache key command. Instead of a URL the command cache may be indexed with a multi part key or a tree that uses components of the URL such as scheme authority hostname path etc. and some components may be disregarded. Each entry may have a TTL associated with it provided by server configuration or per customer or per domain configuration in any case entries would be subject to eviction for normal memory and storage concerns. In a system where only public notation is supported the command cache may not require a value store and thus will simply function as a list of keys.

Cache servers may subscribe to messages regarding traffic for a specific domain e.g. using the publisher subscriber techniques described with reference to in which case messages regarding the cache key construction for URL endpoints not yet served or cached may arrive out of band allowing those cache servers to have advance dynamic knowledge of the cacheability of certain URL endpoints. A cache server may alter the strategy employed to go forward to fetch a response using the result from the command cache for example if ID PUBLIC is known for a given canonical URL then a cache server that had this fact available to it from a prior message may contact a parent cache server in a cache hierarchy instead of going forward to origin. Generalizing a cache server with advance knowledge of the cacheability of certain URL endpoints as stored in a command cache can use that information to help determine where to go forward for content from a given endpoint.

 Mapping User Id to Group Technique. In this approach the cache server extracts user identity from the client request and interprets notation in the token response from origin designating a mapping of user id to a group. This mapping informs the cache server that API responses valid for that group may be served to the individual user id. In effect this mapping functionality indicates that a cache key less granular than user identity can be employed for this user.

Note that although the mapping notation accompanies an origin response it is relevant to the user and NOT the response. The caching of the mapping fact may be separate from the response in a special user to group mapping cache in the cache server which is consulted to rewrite user identity values before those values are incorporated into cache key computation and which can be propagated across the network e.g. using the publisher subscriber techniques described with reference to .

To illustrate consider a case where an HTTP API issues a cookie called id to identify a user by a number. In a normal HTTP caching scenario a cache server might be configured to construct cache keys using a hash of the URL and the cookie value. In a pseudo code notation this may be expressed as MD5 URL Cookie id 

Instead in a Hologram or other cache key compatible network that employs usermapping the pseudo code notation would be as follows where UserMapping is a function that yields a rewrite of the cookie value MD5 URL UserMapping Cookie id 

Another example assume a web site allows the posting of public wiki pages and also allows some wiki pages to be marked as private and these private pages should not be provided to anyone except the original poster. As an optimization the origin server can check user identity and upon discovering that a user has zero private wild pages sends a token that indicates that this user is effectively equivalent to a public user for the purposes of the items they will see via the API. Even if the API requires a login public is still a useful concept for the lowest common denominator grouping.

Subsequent requests by user id 123 for any purpose will be remapped to a user id of PUBLIC until the origin issues a replacement user mapping token which it can accomplish simply by mapping back to ID 123 . A TTL can exist on this mapping for extra safety.

As another example an API that has two classes of users admin and user may map all users to one or the other 

A final example an API representing a commerce engine that will personalize results may describe the user mapping in terms of data upon which personalization is based. The content is cached any user id matching the personalization may be served the associated content. The example shown here is for a site that will take into account that the user is Male 26 60 years old and living in Massachusetts. The coding is in plaintext but an MD5 hash of this token could have been sent instead.

Messages from origin that create entries in the user to group mapping cache may also be sent out of band in a separate connection from the origin in frames over WebSockets HTTP 2 or by calling an HTTP API for that purpose.

The client devices servers and other computer devices described herein may be implemented with conventional computer systems as modified by the teachings hereof with the functional characteristics described above realized in special purpose hardware general purpose hardware configured by software stored therein for special purposes or a combination thereof.

Software may include one or several discrete programs. A given function may comprise part of any given module process execution thread or other such programming construct. Generalizing each function described above may be implemented as computer code namely as a set of computer instructions executable in one or more microprocessors to provide a special purpose machine. The code may be executed using conventional apparatus such as a microprocessor in a computer digital data processing device or other computing apparatus as modified by the teachings hereof. In one embodiment such software may be implemented in a programming language that runs in conjunction with a proxy on a standard Intel hardware platform running an operating system such as Linux. The functionality may be built into the proxy code or it may be executed as an adjunct to that code.

While in some cases above a particular order of operations performed by certain embodiments is set forth it should be understood that such order is exemplary and that they may be performed in a different order combined or the like. Moreover some of the functions may be combined or shared in given instructions program sequences code portions and the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic.

Computer system includes a microprocessor coupled to bus . In some systems multiple microprocessor and or microprocessor cores may be employed. Computer system further includes a main memory such as a random access memory RAM or other storage device coupled to the bus for storing information and instructions to be executed by microprocessor . A read only memory ROM is coupled to the bus for storing information and instructions for microprocessor . As another form of memory a non volatile storage device such as a magnetic disk solid state memory e.g. flash memory or optical disk is provided and coupled to bus for storing information and instructions. Other application specific integrated circuits ASICs field programmable gate arrays FPGAs or circuitry may be included in the computer system to perform functions described herein.

Although the computer system is often managed remotely via a communication interface for local administration purposes the system may have a peripheral interface communicatively couples computer system to a user display that displays the output of software executing on the computer system and an input device e.g. a keyboard mouse trackpad touchscreen that communicates user input and instructions to the computer system . The peripheral interface may include interface circuitry and logic for local buses such as Universal Serial Bus USB or other communication links.

Computer system is coupled to a communication interface that provides a link between the system bus and an external communication link. The communication interface provides a network link . The communication interface may represent an Ethernet or other network interface card NIC a wireless interface modem an optical interface or other kind of input output interface.

Network link provides data communication through one or more networks to other devices. Such devices include other computer systems that are part of a local area network LAN . Furthermore the network link provides a link via an internet service provider ISP to the Internet . In turn the Internet may provide a link to other computing systems such as a remote server and or a remote client . Network link and such networks may transmit data using packet switched circuit switched or other data transmission approaches.

In operation the computer system may implement the functionality described herein as a result of the microprocessor executing code. Such code may be read from or stored on a non transitory computer readable medium such as memory ROM or storage device . Other forms of non transitory computer readable media include disks tapes magnetic media CD ROMs optical media RAM PROM EPROM and EEPROM. Any other non transitory computer readable medium may be employed. Executing code may also be read from network link e.g. following storage in an interface buffer local memory or other circuitry .

The client device may be a conventional desktop laptop or other Internet accessible machine running a web browser or other rendering engine but as mentioned above the client may also be a mobile device. Any wireless client device may be utilized e.g. a cellphone pager a personal digital assistant PDA e.g. with GPRS NIC a mobile computer with a smartphone client tablet or the like. Other mobile devices in which the technique may be practiced include any access protocol enabled device e.g. iOS based device an Android based device other mobile OS based device or the like that is capable of sending and receiving data in a wireless manner using a wireless protocol. Typical wireless protocols include WiFi GSM GPRS CDMA or WiMax. These protocols implement the ISO OSI Physical and Data Link layers Layers 1 2 upon which a traditional networking stack is built complete with IP TCP SSL TLS and HTTP. The WAP wireless access protocol also provides a set of network communication layers e.g. WDP WTLS WTP and corresponding functionality used with GSM and CDMA wireless networks among others.

In a representative embodiment the mobile device is a cellular telephone that operates over GPRS General Packet Radio Service which is a data technology for GSM networks. Generalizing a mobile device as used herein is a 3G or next generation compliant device that includes a subscriber identity module SIM which is a smart card that carries subscriber specific information mobile equipment e.g. radio and associated signal processing devices a man machine interface MMI and one or more interfaces to external devices e.g. computers PDAs and the like . The techniques disclosed herein are not limited for use with a mobile device that uses a particular access protocol. The mobile device typically also has support for wireless local area network WLAN technologies such as Wi Fi. WLAN is based on IEEE 802.11 standards. The teachings disclosed herein are not limited to any particular mode or application layer for mobile device communications.

It should be understood that the foregoing has presented certain embodiments of the invention that should not be construed as limiting. For example certain language syntax and instructions have been presented above for illustrative purposes and they should not be construed as limiting. It is contemplated that those skilled in the art will recognize other possible implementations in view of this disclosure and in accordance with its scope and spirit. The appended claims define the subject matter for which protection is sought.

It is noted that trademarks appearing herein are the property of their respective owners and used for identification and descriptive purposes only given the nature of the subject matter at issue and not to imply endorsement or affiliation in any way.

