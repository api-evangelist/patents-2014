---

title: Systems and methods to synchronize artifact relationships across a plurality of repositories
abstract: Systems and methods synchronize artifact relationships across a plurality of repositories. One example method includes mapping a first relationship of a first relationship type between a first source artifact in a first repository and a second source artifact to a second relationship of a second relationship type between a first target artifact in a second repository and a second target artifact according to a relationship mapping provided by a schema mapping guide. One example system includes a repository synchronizer to synchronize artifact relationship across at least first and second repositories. The repository synchronizer can include at least one processor. The example system can further include one or more schema mapping guides that provide one or more relationship mappings between the first and second repositories.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09459839&OS=09459839&RS=09459839
owner: TASKTOP TECHNOLOGIES, INCORPORATED
number: 09459839
owner_city: Vancouver
owner_country: CA
publication_date: 20141215
---
The present disclosure generally relates to synchronization of data across a plurality of repositories and more particularly to systems and methods to efficiently synchronize artifact relationships across a plurality of repositories associated with different computer applications or tools.

Many different computer applications or tools exist that perform different functions or enable users to perform different operations. As an example many different tools exist that assist the development of software products by an organization. Each of such software development tools may provide different features functions or data representations that are useful for certain aspects or stages of the development process or are useful to different individuals with different roles within the organization. For example a business analyst may use a first software development tool to perform her functions within the organization while a developer uses a second different development tool to perform his functions within the organization. Likewise other individuals with different organizational roles e.g. testers deployment operations etc. may use additional tools as well.

Each software development tool may allow users to create and manage artifacts within a repository associated with such software development tool. Each artifact is a representation of an aspect of the development process.

Different software development tools may use different artifact types to represent different aspects of the development process. As an example a first software development tool may allow the business analyst to generate and manage artifacts that represent epics features user stories requirements or other business concepts. Likewise a second software development tool may allow the developer to generate and manage artifacts that represent tasks defects or other development concepts. A third software development tool may allow a tester to generate and manage artifacts representative of tests or other testing concepts.

Furthermore each software development tool may allow users to define and manage relationships between the artifacts contained in the associated repository. The relationships may have different defined relationship types. For example the business analyst may define that a user story artifact depends upon a particular feature artifact. Such defined relationships may be useful in organizing and performing the development process within each corresponding tool.

The use of various different software development tools within a single organization or with respect to a single project results in various challenges. In particular individuals that work as a team must be able to effectively collaborate and communicate about various aspects of the development process. Thus for example a developer s progress on resolving a defect artifact may be highly relevant to the business analyst s user story artifact. However if such two artifacts are contained in different repositories associated with different tools the developer and the business analyst may have difficulty collaborating and communicating with respect to such aspect.

As an example one user may be forced to use an unfamiliar tool to understand the current work status of a second user. As another example manually updating a first artifact within a first repository to reflect changes or developments with respect to a second artifact in a second repository is highly inefficient and prone to user introduced error.

The use of artifact relationships within repositories provides yet additional challenges. For example a first set of relationship types available within a first tool may not match a second set of relationship types available within a second tool. As another example relationships that are internal within a first repository may be an external relationship when synchronized into a second repository or may have other differentiating characteristics. Thus even assuming that effective means to synchronize artifacts across different repositories exist the synchronization of relationships across repositories with different artifact and relationship types presents additional unique challenges. Therefore systems and methods to synchronize artifact relationships are desirable.

A method of operation in a repository synchronizer to synchronize artifact relationships across a plurality of repositories the repositories respectively associated with respective ones of a plurality of software development tools the repository synchronizer comprising at least one processor and at least one non transitory processor readable medium communicatively coupled to the at least one processor and which stores at least one of processor executable instructions or data may be summarized as including for a first source artifact in a first repository associated with a first development tool the first source artifact which is logically associated by a defined first relationship of a first relationship type with a second source artifact identifying a first target artifact in a second repository that corresponds to the first source artifact the second repository associated with a second development tool the second development tool different from the first development tool determining a defined second relationship type for a second relationship between the first target artifact in the second repository that corresponds to the first source artifact in the first repository and a second target artifact that corresponds to the second source artifact the determined defined second relationship type from a second set of defined relationship types for the second repository which is different from a first set of defined relationship types for the first repository and causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type.

Determining a defined second relationship type for a second relationship between the first target artifact in the second repository that corresponds to the first source artifact in the first repository and a second target artifact that corresponds to the second source artifact may include determining the defined second relationship type based at least in part on a schema mapping guide that provides a relationship mapping from the first relationship type in the first repository to the defined second relationship type in the second repository. Determining the defined second relationship type based at least in part on a schema mapping guide that provides a relationship mapping from the first relationship type in the first repository to the defined second relationship type in the second repository may include determining the defined second relationship type based at least in part on the schema mapping guide that provides a user defined relationship mapping from the first relationship type in the first repository to the defined second relationship type in the second repository. Causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may include establishing the second relationship of the determined defined second relationship type between the first target artifact and the second target artifact. Causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may include changing the second relationship between the first target artifact and the second target artifact to the determined defined second relationship type from a third relationship type. Causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may include determining that the second relationship exists between the first target artifact and the second target artifact as the determined defined second relationship type and leaving the second relationship between the first target artifact and the second target artifact as the determined defined second relationship type.

The method may further include prior to identifying the first target artifact in the second repository that corresponds to the first source artifact receiving an indication of an alteration of one or more data fields associated with the first source artifact and scanning the data fields of the first source artifact to identify as unprocessed the defined first relationship. Identifying the first target artifact in the second repository that corresponds to the first source artifact may include identifying autonomously by the repository synchronizer the first target artifact in the second repository that corresponds to the first source artifact determining the defined second relationship type for the second relationship may include determining autonomously by the repository synchronizer the defined second relationship type for the second relationship and causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may include causing autonomously by the repository synchronizer the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type. Identifying the first target artifact in the second repository that corresponds to the first source artifact may include identifying periodically and not responsive to human prompting the first target artifact in the second repository that corresponds to the first source artifact determining the defined second relationship type for the second relationship may include determining periodically and not responsive to human prompting the defined second relationship type for the second relationship and causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may include causing periodically and not responsive to human prompting the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type. Each of the first source artifact the second source artifact the first target artifact and the second target artifact may include one of a task a goal a user story an epic a defect a requirement an issue or a test. Determining a defined second relationship type for a second relationship between the first target artifact in the second repository that corresponds to the first source artifact in the first repository and a second target artifact that corresponds to the second source artifact may include determining whether the first relationship between the first source artifact and the second source artifact is an internal relationship within the first repository responsive to determining that the first relationship is an internal relationship within the first repository determining whether the second relationship between the first target artifact and the second target artifact is to be an internal relationship within the second repository and responsive to determining that the second relationship is to be an internal relationship within the second repository determining whether the second target artifact exists within the second repository.

Determining a defined second relationship type for a second relationship between the first target artifact in the second repository that corresponds to the first source artifact in the first repository and a second target artifact that corresponds to the second source artifact may further include marking one or more of the first source artifact the defined first relationship and the second target artifact as pending in response to determining that the second target artifact does not exist within the second repository. Determining a defined second relationship type for a second relationship between the first target artifact in the second repository that corresponds to the first source artifact in the first repository and a second target artifact that corresponds to the second source artifact may include determining whether the first relationship between the first source artifact and the second source artifact is an internal relationship within the first repository responsive to determining that the first relationship is an internal relationship within the first repository determining whether the second relationship between the first target artifact and the second target artifact is to be an internal relationship within the second repository and responsive to determining that the second relationship is not to be an internal relationship within the second repository generating a resource locator that describes a location of the second source artifact within the first repository or a third repository. Generating a resource locator that describes a location of the second source artifact within the first repository or a third repository may include generating a user selectable uniform resource locator URL providing access to the location of the second source artifact within the first repository or the third repository. Causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may include associating the resource locator that describes the location of the second source artifact with the first target artifact as the second relationship. Determining a defined second relationship type for a second relationship may include determining whether the first relationship between the first source artifact and the second source artifact is an internal relationship within the first repository and causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may include responsive to determining that the first relationship is not an internal relationship within the first repository merging a resource locator that describes a location of the second source artifact within the first repository or a third repository with any existing resource locators associated with existing relationships of the first target artifact.

A system to enable collaborative development of software products across a plurality of software development tools may be summarized as including at least a first repository that stores a first plurality of artifacts associated with a first software development tool and a second repository that stores a second plurality of artifacts associated with a second software development tool that is different from the first software development tool and a repository synchronizer to synchronize artifact relationships across at least the first and second repositories the repository synchronizer comprising at least one processor and at least one non transitory processor readable medium communicatively coupled to the at least one processor and which stores processor executable instructions execution of which causes for at least a first source artifact of the first repository that is logically associated by a defined first relationship of a first relationship type with a second source artifact the repository synchronizer to identify a first target artifact in the second repository that corresponds to the first source artifact determine a defined second relationship type for a second relationship between the first target artifact in the second repository that corresponds to the first source artifact in the first repository and a second target artifact that corresponds to the second source artifact the determined defined second relationship type from a second set of defined relationship types for the second repository which is different from a first set of defined relationship types for the first repository and cause the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type.

The repository synchronizer may determine the defined second relationship type based at least in part on a schema mapping guide that provides a relationship mapping between the first relationship type in the first repository and the defined second relationship type in the second repository. The relationship mapping provided by the schema mapping guide may be user defined. The instructions that cause the repository synchronizer to cause the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may cause the repository synchronizer to establish the second relationship of the determined defined second relationship type between the first target artifact and the second target artifact. The instructions that cause the repository synchronizer to cause the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may cause the repository synchronizer to change the second relationship between the first target artifact and the second target artifact to the determined defined second relationship type from a third relationship type. The instructions that cause the repository synchronizer to cause the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type may cause the repository synchronizer to determine that the second relationship exists between the first target artifact and the second target artifact as the determined defined second relationship type and leave the second relationship between the first target artifact and the second target artifact as the determined defined second relationship type. The instructions may cause the repository synchronizer to autonomously identify the first target artifact in the second repository autonomously determine the defined second relationship type for the second relationship and autonomously cause the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type. The instructions may cause the repository synchronizer to periodically and not responsive to human prompting identify the first target artifact in the second repository periodically and not responsive to human prompting determine the defined second relationship type for the second relationship and periodically and not responsive to human prompting cause the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type

A method to synchronize artifact relationships across a plurality of repositories respectively associated with a plurality of software development tools may be summarized as including receiving by one or more computing devices data that describes a first attribute field associated with a first source artifact contained in a source repository associated with a first software development tool of the plurality of software development tools the first attribute field that describes a first relationship of a first relationship type between the first source artifact and at least a second source artifact obtaining by the one or more computing devices a schema mapping guide that describes at least one relationship mapping between the first relationship type in the source repository and a second relationship type in a target repository associated with a second software development tool of the plurality of software development tools the second software development tool different than the first software development tool and updating by the one or more computing devices based at least in part on the first attribute field and the schema mapping guide a second attribute field associated with a first target artifact contained in the target repository to describe a second relationship of the second relationship type between the first target artifact and at least a second target artifact.

Obtaining by the one or more computing devices the schema mapping guide may include obtaining by the one or more computing devices the schema mapping guide that describes at least one user defined relationship mapping between the first relationship type in the source repository and the second relationship type in the target repository. Receiving by the one or more computing devices data that describes a first attribute field associated with a first source artifact may include receiving by the one or more computing devices an indication that a change has occurred in one or more attribute fields associated with the first source artifact and scanning by the one or more computing devices the one or more attribute fields to identify as unprocessed a change in the first attribute field.

The method may further include determining by the one or more computing devices whether the second target artifact is included in the target repository with the first target artifact wherein when it is determined that the second target artifact is not included in the target repository with the first target artifact updating by the one or more computing devices based at least in part on the first attribute field and the schema mapping guide a second attribute field associated with a first target artifact comprises generating by the one or more computing devices a resource locator that describes a location of the second target artifact within the source repository or a third repository and associating by the one or more computing devices the resource locator with the first target artifact.

The method may further include determining by the one or more computing devices whether the second source artifact is included in the source repository with the first source artifact wherein when it is determined that the second source artifact is not included in the source repository with the first source artifact updating by the one or more computing devices based at least in part on the first attribute field and the schema mapping guide a second attribute field associated with a first target artifact comprises associating by the one or more computing devices a resource locator that describes a location of the second source artifact with the first target artifact.

A method of operation in a repository synchronizer to synchronize artifact relationships across a plurality of repositories the repositories respectively associated with respective ones of a plurality of computer applications the repository synchronizer comprising at least one processor and at least one non transitory processor readable medium communicatively coupled to the at least one processor and which stores at least one of processor executable instructions or data may be summarized as including for a first source artifact in a first repository associated with a first computer application the first source artifact which is logically associated by a defined first relationship of a first relationship type with a second source artifact identifying a first target artifact in a second repository that corresponds to the first source artifact the second repository associated with a second computer application determining a defined second relationship type for a second relationship between the first target artifact in the second repository that corresponds to the first source artifact in the first repository and a second target artifact that corresponds to the second source artifact the determined defined second relationship type from a second set of defined relationship types for the second repository which is different from a first set of defined relationship types for the first repository and causing the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type.

The second computer application may be a different application than the first computer application. The first computer application may be a first instance of a computer application and the second computer application may be a second instance of the same computer application. The first and second computer applications may be software development tools or may be computer applications other than software development tools.

A system to enable collaboration across a plurality of computer applications may be summarized as including at least a first repository that stores a first plurality of artifacts associated with a computer application and a second repository that stores a second plurality of artifacts associated with a second computer and a repository synchronizer to synchronize artifact relationships across at least the first and second repositories the repository synchronizer comprising at least one processor and at least one non transitory processor readable medium communicatively coupled to the at least one processor and which stores processor executable instructions execution of which causes for at least a first source artifact of the first repository that is logically associated by a defined first relationship of a first relationship type with a second source artifact the repository synchronizer to identify a first target artifact in the second repository that corresponds to the first source artifact determine a defined second relationship type for a second relationship between the first target artifact in the second repository that corresponds to the first source artifact in the first repository and a second target artifact that corresponds to the second source artifact and cause the second relationship between the first target artifact and the second target artifact to match the determined defined second relationship type.

The second computer application may be a different application than the first computer application. The first computer application may be a first instance of a computer application and the second computer application may be a second instance of the same computer application. The first and second computer applications may be software development tools or may be computer applications other than software development tools. The determined defined second relationship type may be from a second set of defined relationship types for the second repository which is different from a first set of defined relationship types for the first repository.

In the following description certain specific details are set forth in order to provide a thorough understanding of various disclosed embodiments. However one skilled in the relevant art will recognize that embodiments may be practiced without one or more of these specific details or with other methods components materials etc. In other instances well known structures associated with computing devices have not been shown or described in detail to avoid unnecessarily obscuring descriptions of the embodiments.

Unless the context requires otherwise throughout the specification and claims that follow the word comprising is synonymous with including and is inclusive or open ended i.e. does not exclude additional unrecited elements or method acts .

Reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. Thus the appearances of the phrases in one embodiment or in an embodiment in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

As used in this specification and the appended claims the singular forms a an and the include plural referents unless the content clearly dictates otherwise. It should also be noted that the term or is generally employed in its broadest sense that is as meaning and or unless the content clearly dictates otherwise.

The headings and Abstract of the Disclosure provided herein are for convenience only and do not interpret the scope or meaning of the embodiments.

The system can be used to develop software products. For example a user can employ user computing device to interact with the first software development tool to perform aspects of the software development process that are enabled by the first software development tool . Although only a single user computing device is shown in the system can include any number of user computing devices via which different individuals in an organization interact with available software development tools e.g. tools and to develop software products.

The user computing device includes a processor and a memory . The processor can be one processor or a plurality of processors that are operatively coupled. The processor can be any processing device such as a microprocessor microcontroller integrated circuit circuitry that implements computer logic or some combination thereof. The memory can include any non transitory information storage device including but not limited to RAM ROM hard drives flash drives optical media other memory devices or some combination thereof. The memory can store information accessible by processor including instructions that can be executed by processor . The instructions can be any set of instructions that when executed by the processor cause the processor to provide desired functionality. The memory can also store data .

Software development tools and may provide different features functions or data representations that are useful for certain aspects or stages of the development process or are useful to different individuals with different roles within the organization. For example a business analyst may use the first software development tool to perform her functions within the organization while a developer uses the n th development tool to perform his functions within the organization.

Although only two software development tools are explicitly shown the system may include any number of different or similar software development tools. For example system can include software development tools that provide application lifecycle management project portfolio management requirements management development tools quality management IT assessment or service management operations tools or tools designed for other aspects of the development cycle. System can include more than one tool from each category of tools provided above.

The software development tools and can also be instances of the same software development tool. Thus the system may include any number of software development tools or other programs or devices that may be unique from each other instances of the same program or device or some combination thereof.

Furthermore although the present disclosure is discussed with reference to software development tools the teachings and components of the present disclosure can be applied to many other contexts as well. In particular alternatively or in addition to software development tools and the system can further include any number of other tools programs applications or devices that perform or enable operations other than the development of software. For example the present disclosure can be applied to synchronize artifacts across repositories associated with any group of arbitrary tools programs applications or devices including for example email clients employee management tools asset management tools resource allocation or planning tools manufacturing flow tools inventory management tools document management systems personal information organization systems financial management systems gaming systems mapping systems etc. In particular the repository synchronization device can synchronize artifacts and artifact relationships included in repositories associated with any many different resources.

Referring again to each development tool and includes a processor and respectively and a non transitory memory and respectively . Similar to processor and memory processors and can respectively be any processing device or combination of such devices. Likewise memory and memory can respectively include any information storage device or combination of such devices. Each memory and can store instructions and respectively and data and respectively .

In some implementations software development tools and respectively include one or more server computing devices. The server computing devices can be arranged according to any computer architecture including parallel sequential and or distributed computing architectures. The server computing devices can provide the software development functionality as a service over network . In other implementations software development tools and can be executed locally at the user computing device .

Each software development tool included in system stores a plurality of artifacts in an associated repository. For example the first software development tool stores a plurality of artifacts in a first repository while the n th development tool stores artifacts in repository . Generally artifacts are representations of aspects of the software development process. Artifacts can include without limitation a task a goal a user story an epic a defect a requirement an issue a test a feature a bug an asset a file a software package or other representations of aspects of the development process.

Relationships can be defined between artifacts. As will be discussed further with reference to relationships can be internal relationships between artifacts contained within the same repository or external relationships between artifacts respectively contained in different repositories.

Each repository can be a single database or a plurality of databases. In instances employing a plurality of databases such databases can be co located or can be distributed at different locations. Each repository can be co located with its corresponding development tool or can be located remotely and accessed over the network or other connection. In some implementations the repository for each development tool is stored in a local non transitory memory associated with one or more servers implementing such development tool.

Repository synchronization device synchronizes artifacts between repositories and . In particular repository synchronization device synchronizes artifact relationships between repositories and . In some instances the repository synchronization device instructs or commands e.g. via an application programming interface API the software development tools and to make changes to or otherwise alter data contained within their respective repositories and .

The repository synchronization device includes a processor and a memory . The processor can be one processor or a plurality of processors that are operatively coupled. The processor can be any processing device such as a microprocessor microcontroller integrated circuit other device that implements computer logic or some combination thereof. The memory can include any non transitory information storage device including but not limited to RAM ROM hard drives flash drives optical media other memory devices or some combination thereof. The memory can store information accessible by processor including instructions that can be executed by processor . The instructions can be any set of instructions that when executed by the processor cause the processor to provide desired functionality. The memory can also store data.

In some implementations repository synchronization device includes one or more server computing devices. The server computing devices can be arranged according to any computer architecture including parallel sequential and or distributed computing architectures. The server computing devices can interact with software development tools and over network to synchronize artifacts and . In other implementations repository synchronization device is executed locally at the user computing device .

The repository synchronization device includes a repository synchronizer one or more schema mapping guides and a schema mapping customizer .

The repository synchronization device implements the repository synchronizer to synchronize artifacts across a plurality of repositories. In particular the repository synchronization device implements the repository synchronizer to synchronize artifact relationships across a plurality of repositories. For example repository synchronization device can implement repository synchronizer to perform aspects of methods and of and respectively. In some implementations the repository synchronizer interacts with the software development tools and using vendor approved or vendor supplied APIs respectively associated with the development tools and .

In some implementations the repository synchronization device implements the repository synchronizer in an automated or autonomous fashion. For example synchronization may be performed periodically not responsive to human prompting or may be performed autonomously upon receiving at the device an indication from a software development tool that an attribute e.g. relationship of a particular artifact has been altered. Alternatively the repository synchronization device implements the repository synchronizer responsive to human prompting or according to a defined schedule. In some implementations the repository synchronization device implements the repository synchronizer according to one or more user defined conditions that specify certain rules logic times repositories and or artifact or relationship types according to which conditional synchronization should or should not be performed.

In some implementations the repository synchronizer includes processor executable instructions stored in or loaded into memory and executed by processor . In other implementations the repository synchronizer includes one or more circuits e.g. integrated circuits logic components or other items of computer hardware configured to implement computer logic or perform other functionality. In other implementations the repository synchronizer can be implemented using some combination of processor executable instructions and circuitry.

Each of the schema mapping guides provides one or more relationship mappings between relationship types in different repositories. In particular each software development tool and corresponding repository included in system may have a set of available relationship types to describe relationships associated with artifacts included in its repository. The sets of available relationship types associated with different repositories may be identical different overlapping and or non overlapping. For example if the artifacts are synchronized across multiple instances of the same tool the corresponding sets of available relationship types may be identical. Alternatively the tool may allow the user of each particular instance to customize or define its corresponding set of available relationship types and therefore the corresponding sets of available relationship types may be non identical. Further the sets of available relationship types can include subsets that are artifact type specific.

As one example in the first software development tool the business analyst may represent that a requirement artifact is blocked by a user story. However in the n th software development tool the blocked by relationship type may be unavailable as the development tool uses a second different set of relationship types. The repository synchronizer uses the schema mapping guides to synchronize artifact relationships between repositories. In particular the repository synchronizer uses the one or more relationship mappings provided by a particular schema mapping guide associated with two particular repositories to determine a target relationship type to which a source relationship type should be mapped. For example a particular schema mapping guide may indicate that the blocked by relationship type available in the first repository maps to a related to relationship type in the n th repository . Therefore the repository synchronizer will synchronize the blocked by relationship type in the first repository to the related to relationship type in the n th repository as indicated by the corresponding schema mapping guide .

The repository synchronization device implements the schema mapping customizer to allow a user to customize one or more of the schema mapping guides . In particular the repository synchronization device implements the schema mapping customizer to revise create delete copy update or otherwise customize one or more of the schema mapping guides based at least in part on user input received via user computing device . For example schema mapping customizer can interact with user computing device to provide at the user computing device a user interface by which a user adjusts defines or otherwise customizes one or more of the relationship mappings provided by a particular schema mapping guide . In some implementations the schema mapping customizer stores one or more predefined and or user defined or user customized schema mapping guide templates that may be applied to particular repositories or used by a user as a template for additional customization of a particular schema mapping guide .

In some implementations the schema mapping customizer includes processor executable instructions stored in or loaded into memory and executed by processor . In other implementations the schema mapping customizer includes one or more circuits e.g. integrated circuits logic components or other items of computer hardware configured to implement computer logic or perform other functionality. In other implementations the schema mapping customizer can be implemented using some combination of processor executable instructions and circuitry.

Network can be any type of communications network such as a local area network e.g. intranet wide area network e.g. Internet or some combination thereof and can include any number of wired or wireless links. In general communication between the components of system via network can be carried via any type of wired and or wireless connection using a wide variety of communication protocols e.g. TCP IP HTTP SMTP FTP encodings or formats e.g. HTML XML and or protection schemes e.g. VPN secure HTTP SSL .

Thus the repository synchronization device enables collaboration by synchronizing artifacts and artifact relationships across repositories associated with different software development tools employed by different individuals within an organization. Such may advantageously eliminate information silos around each functional discipline while maintaining and enhancing existing tool infrastructure. By allowing individuals to operate within their development tool of choice while receiving continual updates from other development tools software product development and deployment is strengthened and investment in existing tools is reinforced. Further the schema mapping customizer enables relationship mapping customization that increases the robustness of the infrastructure and allows for organization and or project specific relationship mapping configurations to be specified.

Due to the inherent flexibility of computer based systems a great variety of possible configurations combinations and divisions of tasks and functionality between and among the components of the system are possible. For instance system can be implemented using a single computing device or across multiple computing devices as shown in . Tasks shown as being performed at a certain device can instead be performed at other devices. Any combination of general purpose and special purpose computing devices can be used.

The data structure for the artifact also includes one or more attribute fields that respectively store information that describes one or more relationships between the artifact and one or more respective other artifacts. As an example a first relationship field stores information that describes a first relationship between the artifact and a first artifact. Likewise an n th relationship field stores information that describes an n th relationship between the artifact and an n th artifact.

In some implementations a component of the system e.g. the repository or the first software development tool creates the relationship fields responsive to creation of the corresponding relationship. In other implementations a component of the system creates the relationship fields upon creation of the artifact and the relationship fields simply remain null until populated with particular relationships.

In some implementations each relationship field stores a relationship type associated with the corresponding relationship. As an example the first relationship field can store information that describes a first relationship type associated with the first relationship between the artifact and the first artifact. In other implementations the first relationship type is stored in an additional attribute field that is different than the first relationship field .

In yet further implementations the data structure for each artifact includes an attribute field for each relationship type available within the corresponding repository. For example if the artifact exists within a repository associated with a software development tool for which six relationship types are available then the data structure may include at least six relationship fields that respectively correspond to the six relationship types. If the artifact has a relationship with a first artifact of a particular relationship type then the component of the system populates the corresponding relationship field with the identity of the first artifact. If the artifact has relationships of the same relationship type with plural artifacts then the component of the system creates multiple relationship fields corresponding to the same relationship type. Alternatively the component of the system may create multiple subfields within a single relationship field that corresponds to the particular relationship type. As yet another example the identities of each of the artifacts for which artifact has a relationship of such relationship type may be stored as a string or set of identifiers within a single relationship field. Other data structures may be used as well.

The relationship indicates that the second artifact is a child of the first artifact . Thus the relationship is of the child of relationship type. An attribute field associated with the second artifact stores data that describes the relationship . In some implementations an attribute field associated with the first artifact also stores data that describes the relationship . For example the data may describe that the second artifact is a child of the first artifact or that the first artifact is a parent of the second artifact . However in other implementations the data structure of the first artifact does not store data that describes the relationship .

The relationship indicates that the third artifact is tested by the fourth artifact . Thus the relationship is of the tested by relationship type. An attribute field associated with the third artifact stores data that describes the relationship . In some implementations an attribute field associated with the fourth artifact also stores data that describes the relationship . For example the data may describe that the third artifact is tested by the fourth artifact or that the fourth artifact tests the third artifact . However in other implementations the data structure of the fourth artifact does not store data that describes the relationship .

At the repository synchronizer identifies a first relationship of a first relationship type between a first source artifact in a first repository and a second source artifact. The first repository is associated with a first software development tool. The second source artifact can be included in the first repository or included in a repository different than the first repository.

In some implementations identifying the first relationship at includes receiving an indication of an alteration of one or more data fields associated with the first source artifact and scanning the data fields of the first source artifact to identify as unprocessed the first relationship. For example the indication of the alteration of the one or more data fields may be received from a software development tool that stores the first source artifact. Alternatively identifying the first relationship at can include automatically scanning the data fields of the first source artifact to identify the alteration of the one or more data fields without receiving an indication from the software development tool. The alteration of the one or more data fields may include for example alteration of data responsive to a creation a change or a deletion of the first relationship.

At the repository synchronizer identifies a first target artifact in a second repository that corresponds to the first source artifact. The second repository is associated with a second software development tool that is different from the first software development tool.

The first target artifact in the second repository may have been previously mapped to or otherwise synchronized with respect to the first source artifact in the first repository. Thus in some implementations identifying the first target artifact at includes accessing or otherwise reading previously stored data that indicates that the first source artifact is mapped to the first target artifact. For example such data may be stored in an attribute field associated with the first source artifact. As another example the repository synchronizer can consult a roster or manifest of artifact mappings to identify that the first target artifact in the second repository corresponds to the first source artifact in the first repository.

At the repository synchronizer determines a defined second relationship type for a second relationship between the first target artifact and a second target artifact. The second target artifact can be included in the second repository or included in a repository different than the second repository. The second target artifact may have been previously mapped to the second source artifact.

In some implementations the defined second relationship type is determined at based at least in part on a schema mapping guide that provides a relationship mapping from the first relationship type in the first repository to the defined second relationship type in the second repository. As one example upon identifying the first and second repositories a particular schema mapping guide associated with such first and second repositories is obtained. The obtained schema mapping guide provides a relationship mapping from the first relationship type in the first repository to the defined second relationship type in the second repository. Therefore determining the second relationship type at can include reading and or applying the relationship mapping provided by the schema mapping guide.

In some implementations the relationship mapping provided by the schema mapping guide is a user defined relationship mapping. For example the relationship mapping provided by schema mapping guide may have been customized through the use of a schema mapping customizer.

In other implementations the relationship mapping provided by the schema mapping guide is specific not only to the first and second repository but also to the artifact type of the first source artifact the artifact type of the second source artifact the artifact type of the first target artifact and or the artifact type of the second target artifact. Thus the schema mapping guide may provide a mapping from a unique set of artifact types and relationship types to another unique set of artifact types and relationship types.

In some implementations of the present disclosure the relationship mappings provided by schema mapping guides specify different mappings for relationships according to whether the first relationship is an internal relationship or an external relationship. Therefore in some implementations determining the defined second relationship type at includes determining whether the first relationship between the first source artifact and the second source artifact is an internal relationship within the first repository.

As one example in response to determining that the first relationship is an internal relationship within the first repository determining the second relationship type at can include determining whether the second relationship is to be an internal relationship within the second repository. If the second relationship is to be an internal relationship within the second repository then the repository synchronizer can perform a check at to ensure that the second target artifact presently exists within the second repository. Such may ensure that the second target artifact is created if needed. For example one or more of the first source artifact the first relationship the second target artifact or other items may be marked as pending until the second target artifact is created.

As another example if the second relationship is to be an external relationship then the repository synchronizer can generate a resource locator that describes a location of the second source artifact within the first repository or a third repository. For example the resource locator can be a uniform resource locator URL that provides access to the location of the second source artifact within the first repository or the third repository. The URL may be user selectable.

As yet another example if it is determined at that the first relationship is an external relationship then certain other actions may be taken to synchronize the first and second relationships as will be discussed further with respect to .

At the repository synchronizer can cause the second relationship to match the determined defined second relationship type. For example an attribute field or other data item associated with the first target artifact and or the second target artifact may be adjusted created or updated to cause the second relationship to have the second relationship type.

As an example the repository synchronizer can populate an attribute field of the first target artifact that is particularly associated with the second relationship type with the identity of second target artifact or otherwise amended to describe the second relationship. Alternatively or additionally the repository synchronizer can populate an attribute field of the second target artifact that is particularly associated with the second relationship type with the identity of first target artifact or otherwise amended to describe the second relationship. In some implementations the repository synchronizer instructs the appropriate software development tool to populate the appropriate attribute field.

Thus causing the second relationship to match the determined defined second relationship type can include establishing the second relationship of the determined defined second relationship type changing the second relationship to the determined defined second relationship type from a third relationship type determining that the second relationship of the second relationship type already exists between the first and second target artifacts and therefore leaving the second relationship as the second relationship type or other actions to cause the second relationship to match the determined defined second relationship type.

Furthermore as discussed above in certain implementations one or more components of the system can perform different actions to synchronize relationships according to whether the relationships to be synchronized are internal to internal internal to external or external to external. As one example if it is determined at that the first relationship is internal to the first repository but the second relationship is to be external then causing the second relationship to match the determined defined second relationship type at can include associating a resource locator that describes the location of the second source artifact with the first target artifact as the second relationship. For example the resource locator can be stored in an attribute field that corresponds to or otherwise describes the second relationship.

As another example if it is determined at that the first relationship is external to the first repository then causing the second relationship to match the determined defined second relationship type at can include copying a resource locator that describes a location of the second source artifact from an attribute field of the first source artifact to an attribute field of the first target artifact.

At the repository synchronizer receives a changed artifact. For example repository synchronizer can observe e.g. via periodic and autonomous scanning that one or more attribute fields of a particular artifact have been altered. Alternatively a software development tool can actively provide an indication that one or more attribute fields of a particular artifact have been altered to the repository synchronizer .

At the repository synchronizer scans the artifact for unprocessed relationship fields. For example the repository synchronizer can scan the attribute fields of the changed artifact to identify whether one or more relationship fields have changed and remain unprocessed.

At the repository synchronizer determines whether one or more unprocessed relationship fields are found. For example the results of the scan performed at may be considered at . If it is determined at that no unprocessed relationship fields were found then method proceeds to of .

However if it is determined at that at least one unprocessed relationship field is found the method proceeds to . For example the at least one unprocessed relationship field may describe a first relationship between the changed artifact and a second source artifact.

At the repository synchronizer determines whether the synchronization to be performed with respect to the unprocessed relationship field is an internal to internal synchronization. For example the repository synchronizer can obtain a schema mapping guide that describes one or more relationship mappings between a source repository in which changed artifact is stored and a target repository in which a first target artifact is stored. The first target artifact may have previously been mapped to the changed artifact. The obtained schema mapping guide can indicate or otherwise guide to repository synchronizer to determine whether the synchronization to be performed with respect to the unprocessed relationship field is an internal to internal synchronization.

If it is determined at that the synchronization to be performed is not an internal to internal synchronization then method proceeds to of . However it is determined at that the synchronization to be performed is an internal to internal synchronization then method proceeds to .

At the repository synchronizer resolves the relationship into target artifact identities. For example a first and second target artifact may have previously been respectively mapped to the changed artifact and the second source artifact. Thus resolving the relationship into the target artifact identities at can include reading previously stored data that indicates that the changed artifact is mapped to the first target artifact. As another example a roster or manifest of artifact mappings can be consulted at to determine the identities of the target artifacts to which the unprocessed relationship should be synchronized. As the synchronization is an internal to internal synchronization the target artifacts should reside within a single target repository.

At the repository synchronizer determines whether any referenced target artifacts are missing. For example the target repository can be accessed or otherwise analyzed at to ensure that both the first and second target artifacts currently exist within the target repository. More particularly a referenced target artifact can be missing if it has not yet been synchronized from the source repository i.e. generated within the target repository on the basis of being synchronized to the changed artifact the second source artifact or another artifact .

If it is determined that that at least one referenced target artifact is missing then method proceeds to . However it is determined that that no referenced target artifacts are missing then method proceeds to .

At the repository synchronizer updates a target field to reflect the relationship. In particular an attribute field associated with the first target artifact can be created updated deleted or otherwise adjusted to describe a second relationship between the first target artifact and the second target artifact that is synchronized with respect to the first relationship described by the unprocessed relationship field. The second relationship is of a second relationship type e.g. as indicated by a scheme mapping guide . Alternatively or additionally an attribute field associated with the second target artifact can be adjusted to describe the second relationship. In such fashion the second relationship is synchronized to the first relationship.

At the repository synchronizer marks the relationship field as processed. After method returns to and again scans the artifact for unprocessed relationship fields.

Returning to of if it is determined at that one or more referenced target artifacts are missing then method proceeds to .

At the repository synchronizer marks the changed artifact as pending. For example a flag or other data item of the artifact may be set e.g. adjusted to a certain value to indicate that the artifact is pending. The flag may be a data item held within the repository synchronization device or may be persisted to the artifact in its respective repository e.g. via use of a corresponding API .

At the repository synchronizer determines whether any of the missing referenced target artifacts are required. For example a referenced target artifact is required if another artifact and or the second relationship cannot exist without the referenced target artifact. As one example in some implementations a parent artifact must exist prior to a child of relationship being established at a given artifact. In other words the child s reference to the parent requires that the parent artifact exist.

If it is determined at that no missing referenced target artifacts are required then method returns to and again scans the artifact for unprocessed relationship fields. However if it is determined at that at least one missing referenced target artifact is required then method proceeds to of .

Returning to of if it is determined at that the synchronization to be performed is not an internal to internal synchronization then method proceeds to of .

Referring now to at the repository synchronizer determines whether the synchronization to be performed with respect to the unprocessed relationship field is an internal to external synchronization. For example the repository synchronizer can analyze an obtained schema mapping guide to determine whether the synchronization to be performed with respect to the unprocessed relationship field is an internal to external synchronization.

If it is determined at that the synchronization to be performed is not an internal to external synchronization then method proceeds to . However if it is determined at that the synchronization to be performed is an internal to external synchronization then method proceeds to .

At the repository synchronizer resolves the relationship into a first resource locator. For example the first resource locator can describe the location of the second target artifact. Resolving the relationship into the first resource locator at can include generating the first resource locator. In some implementations the first resource locator is a user selectable URL that provides access to the location of the second target artifact. For example a user computing device that executes the URL may be directed to an interface of a software development tool associated with the repository in which the second target artifact is stored.

At the repository synchronizer queries the first target artifact to determine whether the first resource locator already exists at the first target artifact. For example the attribute fields of the first target artifact can be scanned to determine the existence or non existence of the first resource locator within the data structure of the first target artifact.

At the repository synchronizer merges the first resource locator into the first target artifact if it does not already exist at the first target artifact. For example the first resource locator can be stored in or otherwise populate an attribute field associated with the first target artifact. In particular in some implementations the first resource locator can populate a particular attribute field associated with a particular relationship type indicated by an associated schema mapping guide.

At the repository synchronizer marks the relationship field as processed. After method returns to and again scans the artifact for unprocessed relationship fields.

Returning to of if it is determined at that no unprocessed relationship fields were found then method proceeds to of .

Referring now to at the non relationship fields are processed. For example changes to other attribute fields for attributes such as title type or other attributes can be scanned recognized and queued for processing.

At the repository synchronizer synchronizes the non relationship fields of a first target artifact that corresponds to the changed artifact to reflect the non relationship attribute changes processed at . For example the attribute fields of the first target artifact that correspond to title type or other attributes of the first target artifact can be edited in accordance with a schema mapping guide or other synchronization guide.

At the repository synchronizer determines whether the artifact is marked as pending. For example a flag or other data item can be read to determine whether the artifact is currently marked as pending.

If it is determined at that the artifact is not marked as pending then method terminates for example until invoked again. However if it is determined at that the artifact is marked as pending then method proceeds to . It should be noted that a determination at of that one or more missing referenced target artifacts are required will result in method proceeding to of .

Referring still to method pauses at until the referenced target artifacts exist. For example the repository synchronizer may perform sequentially or in parallel additional methods or routines to generate missing artifacts in certain repositories. Thus if a referenced target artifact is missing then at the method pauses until such additional method or routine generates the missing artifact s . Likewise if a changed artifact is marked as pending such may indicate that a relationship of the changed artifact may have yet to be fully synchronized on the basis of one or more missing referenced target artifacts. Therefore pausing at allows for such referenced target artifacts to come into existence prior to successive iterations of the artifact relationship synchronization process.

At the repository synchronizer removes the pending mark from the artifact. After method returns to and again scans the artifact for unprocessed relationship fields.

Artifact A includes an identifier field populated with identifier A an artifact type field populated with artifact type requirement and a relationship field that is null. Likewise Artifact A includes an identifier field populated with identifier A an artifact type field populated with artifact type requirement and a relationship field that is populated with data that indicates Artifact A is the father of Artifact A . As discussed above with respect to the data structure for each artifact can include multiple relationship fields that respectively correspond to different available relationship types. However a single relationship field is depicted for each artifact in and the Figures that follow for ease of presentation and understanding.

Referring again to the relationship field of Artifact A has recently been changed to reflect a newly established father relationship with respect to Artifact A. Therefore such relationship field change has not yet been synchronized to Repository B .

Repository B stores Artifact B and Artifact B . In particular Artifacts B and B have previously been respectively mapped to Artifacts A and A .

Artifact B includes an identifier field populated with identifier B an artifact type field populated with artifact type feature and a relationship field that is null. Likewise Artifact B includes an identifier field populated with identifier B an artifact type field populated with artifact type user story and a relationship field that is null as shown in .

Referring to at the repository synchronizer receives the changed Artifact A . At the repository synchronizer scans Artifact A to identify as unprocessed the relationship field . At the repository synchronizer determines that the unprocessed relationship field has been found.

At the repository synchronizer determines that an internal to internal relationship synchronization is to be performed. For example at a schema mapping guide associated with Repositories A and B can be obtained. The schema mapping guide may indicate that an internal father relationship within Repository A maps to an internal parent relationship within Repository B . Therefore method will proceed to .

In some implementations the schema mapping guide may also provide additional information that maps particular artifact types to other artifact types given the existence of certain relationship. For example the schema mapping guide may indicate that a requirement type artifact within Repository A that has an existing father relationship maps to an user story type artifact within Repository B Thus the schema mapping guide may provide mappings based on some combination of relationship type and or artifact type.

At the repository synchronizer resolves the relationship into the identities of the target artifacts. For example the previous respective mappings between Artifacts A and B and A and B may be identified at .

At the repository synchronizer determines that neither Artifact B nor Artifact B are missing as Artifact B and Artifact B presently exist within Repository B .

At the repository synchronizer updates the target field to reflect to synchronized relationship. In particular referring now to it can be seen that the relationship field of Artifact B has been changed to store data that indicates that the Artifact B is the parent of Artifact B . Thus the change in the relationship status of Artifact A has been synchronized over to Artifact B with the corresponding relationship types being directed by the schema mapping guide.

Referring again to the relationship field of Artifact A is marked as processed at . After method returns to .

Artifact A includes an identifier field populated with identifier A an artifact type field populated with artifact type requirement and a relationship field that stores data that indicates that Artifact A is tested by Artifact A . Likewise Artifact A includes an identifier field populated with identifier A an artifact type field populated with artifact type test and a relationship field that is null. In some implementations however relationship field indicates that Artifact A tests Artifact A .

The relationship field of Artifact A has recently been changed to reflect a newly established tested by relationship with respect to Artifact A . Therefore such relationship field change has not yet been synchronized to Repository B .

Repository B stores Artifact B . In particular Artifact B has previously been respectively mapped to Artifact A . Artifact B includes an identifier field populated with identifier B an artifact type field populated with artifact type feature and a relationship field that is null.

Referring to at the repository synchronizer receives the changed Artifact A . At the repository synchronizer scans Artifact A to identify as unprocessed the relationship field . At the repository synchronizer determines that the unprocessed relationship field has been found.

At the repository synchronizer determines that the synchronization to be performed is not an internal to internal synchronization. For example at a schema mapping guide associated with Repositories A and B can be obtained. The schema mapping guide may indicate that an internal tested by relationship within Repository A does not map to an internal relationship within Repository B . Therefore method will proceed to of .

Referring now to at the repository synchronizer determines that an internal to external relationship synchronization is to be performed. For example the schema mapping guide associated with Repositories A and B may indicate that an internal tested by relationship within Repository A maps to an external tested by relationship within Repository B . Therefore method will proceed to .

At the repository synchronizer turns the relationship into a resource locator e.g. a user selectable URL . The resource locator describes the location of Artifact A within Repository A .

At the repository synchronizer queries the Artifact B to determine whether a resource locator to Artifact A already exists within the data structure of Artifact B . Because the relationship field of Artifact B is null no resource locator is found at . More precisely because a tests relationship field within Artifact B represented here as relationship field is null no existing resource locator to Artifact A is found at .

At the repository synchronizer merges the resource locator into the relationship field . In particular as shown in the relationship field now includes data that indicates that the Artifact B is tested by Artifact A and includes the resource locator. Thus the change in the relationship status of Artifact A has been synchronized over to Artifact B with the corresponding relationship types being directed by the schema mapping guide.

The repository synchronizer marks relationship field of Artifact A as processed at . After method returns to of .

Artifact A includes an identifier field populated with identifier A an artifact type field populated with artifact type work item and a relationship field that stores data that indicates that Artifact A is tested by Artifact C . In particular the relationship field includes a resource locator that provides access to the location of Artifact C within Repository C .

Likewise Artifact C includes an identifier field populated with identifier C an artifact type field populated with artifact type test and a relationship field that is null. In some implementations however relationship field indicates that Artifact C tests Artifact A .

The relationship field of Artifact A has recently been changed to reflect a newly established tested by relationship with respect to Artifact C . Therefore such relationship field change has not yet been synchronized to Repository B .

Repository B stores Artifact B . In particular Artifact B has previously been respectively mapped to Artifact A . Artifact B includes an identifier field populated with identifier B an artifact type field populated with artifact type issue and a relationship field that is null.

Referring to at the repository synchronizer receives the changed Artifact A . At the repository synchronizer scans Artifact A to identify as unprocessed the relationship field . At the repository synchronizer determines that the unprocessed relationship field has been found.

At the repository synchronizer determines that the synchronization to be performed is not an internal to internal synchronization. For example at a schema mapping guide associated with Repositories A and B can be obtained. Alternatively it may be discerned from the external nature of relationship field itself that the synchronization is not an internal to internal synchronization. Therefore method proceeds to of .

Referring now to at the repository synchronizer determines that an external to external relationship synchronization is to be performed. For example the schema mapping guide associated with Repositories A and B may indicate that an external tested by relationship of an artifact of Repository A maps to an external tested by relationship for an artifact of Repository B . Therefore method will proceed to .

At the repository synchronizer queries the Artifact B to determine whether a resource locator to Artifact C already exists within the data structure of Artifact B . Because the relationship field of Artifact B is null no resource locator is found at .

At the repository synchronizer merges the resource locator into the relationship field . In particular as shown in the relationship field now includes data that indicates that the Artifact B is tested by Artifact C and includes the resource locator. In some implementations the resource locator can be copied from the relationship field of Artifact A to the relationship field of Artifact B . Thus the change in the relationship status of Artifact A has been synchronized over to Artifact B with the corresponding relationship types being directed by the schema mapping guide.

At the repository synchronizer marks the relationship field of Artifact A as processed. After method returns to of .

The various embodiments described above can be combined to provide further embodiments. The methods or algorithms set out herein may employ additional acts may omit some acts and or may execute acts in a different order than specified.

These and other changes can be made to the embodiments in light of the above detailed description. In general in the following claims the terms used should not be construed to limit the claims to the specific embodiments disclosed in the specification and the claims but should be construed to include all possible embodiments along with the full scope of equivalents to which such claims are entitled. Accordingly the claims are not limited by the disclosure.

