---

title: Using individualized APIs to block automated attacks on native apps and/or purposely exposed APIs
abstract: An API call filtering system filters responses to API call requests received, via a network, from user devices. The API call filtering system is configured to require personalized API call requests wherein each API call (except for some minor exceptions) includes a unique endpoint identifier (“UEID”) of the user device making the request. Using the UEID, the web service or other service protected by the API call filtering system can be secured against excessive request iterations from a set of rogue user devices while allowing for ordinary volumes of requests of requests the user devices, wherein one or more boundaries between what is deemed to be an ordinary volume of requests and what is deemed to be excessive request iterations are determined by predetermined criteria.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09258274&OS=09258274&RS=09258274
owner: SHAPE SECURITY, INC.
number: 09258274
owner_city: Palo Alto
owner_country: US
publication_date: 20140709
---
The present invention relates generally to network computer system security and more particularly to defense against some automated attacks on the network computer system.

The Internet and related networks can be used to send e mails conduct business automate machinery and data processing. Connected users can use the Internet to interact with other connected users and or connected computer systems. Some of the Internet traffic is wanted by the parties involved but other traffic is unwanted by at least one party. For example by some estimates more than three quarters of daily e mail volume over the Internet is unwanted by its targeted recipient sometimes referred to as spam . More than just e mail traffic is unwanted by its targeted recipient. For example banks bank customers and bank network operators and managers do not want traffic that is attempting to manipulate the bank s online banking system to facilitate fraud. Of course in today s world there is some traffic that is wanted and or necessary so one task that online systems operators have to deal with is separating the wanted traffic from the unwanted traffic letting the wanted traffic through and blocking the unwanted traffic.

For example the typical e mail recipient does not want to receive all unsolicited commercial offers. The online network operator that limits access to resources to authorized users does not want to receive traffic from unauthorized users. Unfortunately the initiators of such unwanted traffic really want to send it and will attempt to do so even if it requires getting around limits and controls placed by the online network operator. This creates an arms race between the initiators of unwanted traffic and the online network systems operator.

There are many reasons a sender of unwanted traffic might want to initiate the traffic. Often those are financial reasons. For example if a scammer can send out one million e mails with a total expenditure of less than ten dollars and a half hour of time and reap a few dollars in profits from just 0.01 of the e mail recipients it is cost effective for the scammer to do so. If an criminal organization can apply 100 000 username password pairs to an e commerce website to find the 0.01 that are vulnerable they would do so if the monetary returns from hacking ten user accounts is greater than the cost to the criminal organization of obtaining the username password pairs plus the cost of executing 100 000 attempted logins.

These unwanted attacks could be thwarted using guaranteed secure methods to filter out unwanted unauthorized traffic from wanted authorized traffic. However as illustrated from the examples above even a 99.99 success rate at blocking attacks would still allow enough traffic through to be a cost effective attack. Some of this economics comes about because automation lowers the cost of transactions. Ironically the very automation that makes it economically feasible for a bank retailer music distributor online storage vendor etc. to provide a low cost service to millions of its customers also makes it economically feasible for a criminal or criminal organization to make millions of attempts to get at network resources in an unauthorized way.

If the effort required to mount an attack on a network resource can be raised so that it is uneconomical to attack but still easy enough for authorized users to access the attacks might be reduced. Therefore it would be desirable to increase the efforts costs of access to the network resource in a way that makes it uneconomical for an organization to mount an attack on network resources while allowing authorized uses.

An API call filtering system filters responses to API call requests received via a network from user devices. The API call filtering system is configured to require personalized API call requests wherein each API call except for some minor exceptions includes a unique endpoint identifier UEID of the user device making the request. Using the UEID the web service or other service protected by the API call filtering system can be secured against excessive request iterations from a set of rogue user devices while allowing for ordinary volumes of requests of requests the user devices wherein one or more boundaries between what is deemed to be an ordinary volume of requests and what is deemed to be excessive request iterations are determined by predetermined criteria.

The user device can be an endpoint device that executes endpoint apps at least one of which sends requests via a network to a server or service that has been secured against excessive request iterations from a set of rogue user devices while allowing for ordinary volumes of requests from user devices. Those requests are first processed by the API call filtering system. An example user device might comprise an app initiator that processes data about by or for the user device storage for one or more UEIDs wherein at least one UEID is associated with the user device and a request generator that generates requests to be sent over the network to the service while identifying the user device in the requests.

Requests from user devices might include requests to authenticate the user device with respect to a secured account maintained at or for the API call filtering system. Verification might be performed by having end user devices generate a PKI key pair sending the public key portion of the key pair to the API call filtering system thereby allowing the API call filtering system to verify a UEID by sending a challenge message to the user device and receiving in return a signed message indicative of a case where the user device has a specific UEID.

The following detailed description together with the accompanying drawings will provide a better understanding of the nature and advantages of the present invention.

In the figures like reference symbols in the various drawings indicate like elements and multiple instances of objects might be denoted parenthetically e.g. 101 1 101 2 . . . 101 . Where numbered objects in figures are shown with parenthetical sub numbers ranging from 0 or 1 up to some letter designation e.g. 1 2 . . . k or 1 2 . . . n it should be understood that the letter designation represents some finite number the value of which is not essential for the understanding of the invention unless otherwise indicated.

Network resources might include information financial value computing resources or the like. For example online stored e mails online stored personal photo bank accounts with online transfer capability online shopping services computing power etc. are all forms of network resources.

Network services might include uploading data downloading data interacting with server side programs over a network access to physical resources e.g. printers cameras other equipment etc. communication services or similar services that might be provided over a network. Network services might be provided by an HTTP server coupled to a back end data processing system or the like. Other network protocols might be used as appropriate.

The network can be the Internet an intranet an extranet a LAN WAN or similar network that connects computers devices systems at network nodes to at least some other network nodes thereby allowing users to use the network services.

As used herein at least for the sake of readability participants in a transaction might be referred to as a user and a network service provider but it should be understood that these labels might sometimes refer to humans or computers as users and or persons business groups organizations etc. as network service providers even though specifically and technically it may well be that an electronic device operated by or at the behest of a user is what is doing the interaction and the interaction is with computer electronic hardware operated by or at the behest of a network service provider.

Electronic user devices might include computers tablets wearable computer devices smartphones embedded computer systems or other devices.

Also for the sake of readability explanations are provided in the context of a user user device running an app that interacts over the network with a server where the app and the server are coordinated such that the way the app interacts with the server is at least familiar to the server and vice versa. Unless otherwise indicated the app can be a program running at the user device in user space in system space in browser space etc. and can be a simple or complex program with a general or specific purpose. Thus the app designation herein is not unless otherwise indicated limited to specific types of programs.

Most often network resources are constrained so access to those network resources should be limited to those users and user devices that are authorized to access those resources and mechanisms would be used to block unauthorized access to those resources or at least thwart unauthorized access enough to make it uninteresting to those persons or organizations that would attempt unauthorized access. Common examples of network resources that are constrained might include a messaging e mail text etc. server that sends stores retrieves messages some of which are not intended to general viewing or an online banking application that might provide access to confidential financial information and the ability to transfer funds or obligate an account owner in some way.

One approach to this dichotomy one that makes it easy for authorized users to get in and access those network resources but makes it hard for unauthorized users to do so is to make it so that both authorized users and unauthorized users have to manually interact with the security system that protects a network resource. For example a webserver and system that allows users and user devices to initiate transactions to transfer money purchases or other markers of value from the system operator to the control of the initiator will want to control access. As a specific example an online clothing retailer might allow anyone to shop online and cause products to accumulate in an online shopping cart but then before the transaction is consummated the user is authenticated necessary financial details are made and the user is requested to pass a Turing test such as a CAPTCHA test to thwart attempts to automatically attempt to purchase goods using a large number of purloined username password pairs.

While in some cases this is an easy feature to provide in other cases it is not so straightforward. For example where there is direct user interaction the user interface can be such that it requires a human user to interact with the user interface in order to accomplish a task. While that might be good for thwarting automated attacks it would also block legitimate automated actions. Moreover introducing additional steps that require user interaction may discourage legitimate users which can decrease the usefulness of the service offered and often directly impact the revenue of the service provider.

Suppose a bank provides a way for friends to transfer small amounts among themselves and that way is to have each person call a call center and describe the details of the desired transaction to a call center operator. That is likely to be infeasible. It is more feasible to have the transaction done entirely by the user interacting with a computer system such as a website that allows users to transfer small amounts of money. Since it is expected that individual users would manually be accessing the website and that unauthorized organizations would attempt automated programmatic access to the website by only allowing direct website interfacing the unauthorized access can be made more difficult and thus less cost effective .

This works well until users and network resource managers decide that they want to allow for some interaction that is not manual. For example suppose five friends are playing an online poker game for real money. When one friend wins a hand the others would transfer some small amount to the winner. If the only way to transfer funds is for pairs of players to manually interact with the network resource that manages the funds transfers this can be cumbersome. At the end of each hand the players would stop look at the online poker game program to determine how much they won lost and to whom and then look to a financial transfers program to make the corresponding transactions.

Rather than require each of the players to manually navigate a money transfer program interface each hand the online poker game might handle that process directly by sending commands to indicate transfers after each hand. Typically this might be done using an application programming interface API wherein non human programs are given a structure to create interactions with the network resource in expected and authorized ways. But then this may then create a problem with unauthorized automated network access.

In some ways it might be easy to describe transactions and interactions that are legitimate and those that are not legitimate. For example a transfer of 25 cents every few minutes from Alice s poker funds account to Bob s poker funds account might be a legitimate set of transactions. Carol attempting to log in to her poker funds account three times might also be a legitimate set of transactions. Attempted transfers of 100 every fifteen seconds would not be a legitimate set of transactions for an online poker game among friends nor would logging in to the poker system using Carol s credentials and trying 10 000 possible passwords.

Some times this filtering is hard and sometimes it is easy. One aspect of filtering that would make it easier to separate the authorized accesses from the unauthorized accesses is to identify and flag behaviors that seem unauthorized. This has been done extensively in the credit debit card market where card issuers have automated systems that study patterns to detect potential fraud. This would prevent a criminal from stealing a credit card from someone who only uses the card to buy groceries once a week and using that credit card to buy expensive jewelry twice a day. Obviously the simplest computer program can flag that fraud and block the jewelry purchases. Unfortunately criminals and especially sophisticated criminal organizations know this and have found ways to work around those blocks.

A criminal organization might purchase a dataset of a large number of credit card numbers and then automate the use of each credit card for a small purchase that might later be converted to cash in the hands of the criminal organization and get around fraud protections. As explained herein those situations can be dealt with by having some limited resource that does not appear limited for authorized users but does appear limited for unauthorized automated attackers. As an example each device that is connected to a secured network resource might be allowed a set number of accesses in a time period e.g. 20 accesses per day per device 1 access per five minute period etc. . Unauthorized user devices that are relying on automation to make millions of accesses per day would be blocked.

Unfortunately again criminal organizations know this and might route around the blockage by having the unauthorized user device falsify information sent to the network resource so that the network resource sees a million accesses as coming from a million different user devices.

This document describes systems and techniques for weakly or strongly identifying specific end user devices and their interfaces despite the knowledge known to the attackers and thereby thwarting attacks. In particular attacks mounted by unauthorized users and or their devices using automated programs to replace human interaction with programs apps commonly referred to as bots .

In step the endpoint app is installed. The endpoint app in this example is modified to add uniquely identified API calls such that the API call identifies the particular instance of the endpoint app. In other variations those uniquely identified API calls might be native built in and or preexisting rather than modified. Where the endpoint has an original non unique API call protocol API and a modified uniquely identified API call protocol API it may be that the necessary modifications occur by changing a library used by program code such as a library linked at compile time. As explained later in this example since endpoint app and an API call filtering system herein a botwall are configured such that each user device is initialized with respect to the botwall before the endpoint app provides original intended functionality this can happen when the app first starts executing.

In step the user device or operating system or other code executing on the user device for this purpose determines whether the endpoint app has been used before or if this is the first use of the app. If so flow proceeds to step . It may be that the endpoint app has been used before but perhaps on a different hardware platform or it was deleted and restored but in some of those cases the endpoint app is treated as not having been run before.

In step the endpoint app or the user device generates or obtains a unique endpoint identifier UEID to be associated with that instance of the endpoint app. Various subprocesses for generating UEIDs are described hereinbelow. Once generated the UEID is transmitted to the botwall step as well as being stored local to the user device step . Once this initialization process is complete the user device has a UEID to associate with that instance of the endpoint app and that UEID might persist across changes of user device IP address configurations of hardware etc. and the botwall has the UEID associated with that instance of the endpoint app.

In some variations the UEID is created at the botwall upon request by the endpoint app or the user device and the UEID is sent from the botwall to the user device. In those variations the user device need not send the UEID to the botwall as the botwall would have retained a copy. In some embodiments the UEID is sent as a secured payload so that interlopers cannot discover it or alter it to their benefit.

In this example of it can be assumed that the user device has not previously run or initialized the endpoint app or has been reset wiped or reconfigured to appear to have not previously run or initialized the endpoint app. It should be understood that the installation use of the example endpoint app described in detail can be independent of the installation use of other apps on the user device. While some user devices might be configured to execute one and only one dedicated app other user devices might be configured to run as many apps as the user choses subject to storage constraints.

Subsequent API operations between the endpoint app and the web service are tagged the UEID. The API messages are intercepted by the botwall and if the UEID is valid it is striped from the message and then message is forwarded to the original web service or supporting server as will be explained with the flow proceeding to step . If the endpoint app is installed and it is determined that the endpoint app has already been initialized flow passes to step where the UEID is read by the endpoint app and or its library and flow passes to step .

By personalizing the API for each endpoint by requiring the UEID be appended for each API call the botwall can count the number of API calls from each unique endpoint. For example a dozen attempts to authenticate from one endpoint during one day might be normal but a thousand is clearly not an appropriate use of a single endpoint and is most likely and iterative kind of attack. The count of legitimate and the illegitimate uses of API calls are likely to differ by orders of magnitude. To protect the UEIDs from being reasonably guessed by the attacker the UEID protection could be based on probability i.e. a large random number .

At step when the endpoint app initiates an API call request it makes the call using the UEID as one of its arguments and sends it toward the botwall and or the supporting service . The botwall in turn will test the UEID for validity log the UEID and API call request and strip out the UEID to form a different API call request that is sent towards the API supporting service. Where the botwall tests the UEID for validity and finds that it is not valid determines that the API call volumes for the UEID are above a threshold between normal use and unauthorized use or the like the botwall can block drop or alter the API call request. In some cases API call request is identical to API call request but in preferred implementations API call request is not UEID specific and API supporting services that are UEID unaware will process API calls correctly. In some implementations exceeding a permitted API call volume would trigger the botwall to delete the associated UEID from the botwall s list of valid UEIDs.

If the botwall does pass API call request the supporting service such as a set of servers programmed to support a particular API using HTTP or other protocol would receive the API call step and field the API call by generating and returning step the appropriate call response to the endpoint app which would then continue processing as programmed step . This process would be repeated as often as needed.

Once the API call request is received by the botwall the botwall makes a note of the UEID step and then issues step a challenge message to the user device endpoint app. One purpose of this challenge message is so that the botwall can authenticate that the user device is the device associated with the proffered UEID. The user device receives the challenge message step prepares a response message and sends the response message to the botwall step . The response message is such that it contains information that could not have easily been generated apart from the endpoint app that is associated with that UEID.

The botwall then authenticates the response message step . If the response is valid thus indicating that that endpoint app is indeed associated with that UEID the botwall notes step the instance of use of that API call with that UEID and forwards the API call possibly with the UEID still included or removed toward the supporting server. If at step the botwall determines that the UEID is not valid the botwall can choose not to reply to the API call request.

In other variations the API supporting server and botwall are more tightly integrated such as being on the same machine or using intermingled code. However this may require modifications of the API supporting server. For example the filtering process for API calls could be built directly into the supporting service system.

In the manner described above API calls even though automated can be limited. For example it might be acceptable to accept up to ten login authentication API request messages related to one user device in a short period of time but it typically not acceptable to field tens of thousands of login authentication API request messages from a given user device.

In a specific embodiment of a botwall the challenge is a random number generated by the botwall that the endpoint app or user device then encrypts using a private key of a public private key pair associated with that UEID. The response is sent to the botwall which then decrypts the challenge response using the previously stored public key of the UEID app. If the decrypted challenge response includes the random number that the challenge message included as well as the correct UEID the botwall should be able to safely assume that the correct endpoint app user device performed that action as the private key should only exist in the context of that endpoint app. If the endpoint app user device fails the challenge the botwall might just discard the rest of that transaction.

Even if the challenge response is successful since the botwall has the UEID for each API call that uses these features transaction volume can be measured and where a rational rate is exceeded e.g. a rate that would be allowed for ordinary users the botwall might drop that API call and delete forget the UEID and its associated public key thus invalidating future UEID based API calls from that endpoint app until a new UEID is generated at least .

In some variations not all API calls are required to include the UEID but where it is included the botwall can easily correlate transaction requests with UEIDs. The botwall can do this even while user device fingerprints change e.g. when one user gets a new user device a device is restarted when an IP address changes etc. .

Of course some determined hackers could delete the app redownload it and start the initialization process thereby getting a new UEID. Since a legitimate user might only get an additional new UEID when purchasing a new user device limits on the frequency or volume of new UEIDs would not burden legitimate users but would thwart hacking attempts that use a small number of devices to make a large number of API calls and try to bypass the speed controls as the hacking attempt would involve attempts to generate many orders of magnitude more UEIDs than are legitimately needed.

To block unauthorized access by an unauthorized person while not encumbering legitimate users of an API service a threshold might be set for the number frequency location etc. of new UEID registrations. The threshold does not need to be fixed or exact as the difference between the two cases is typically quite wide.

A typical credential stuffing attack might take 1 000 000 username password pairs known to work on other web sites and test them on the target of interest in an attempt to discover where the credentials have been reused. Whereas a typical accidently incorrect password entry by a legitimate user might result in less than ten tries of username and password the attack needs at least thousands of iteration to be minimally effective. As explained herein one approach of prior art might attempt remediation by applying rate limits on the IP address. For example once an app server receives 100 login attempts from one IP address the app server can block all further traffic from that IP address or endpoint device. Without more this might also block legitimate users suppose the IP traffic from hundreds of legitimate users is routed through one IP address such as occurs in the office environment of a large company and further this approach might allow attackers to pass if they route their traffic through multiple proxies to make it appear that one device is actually many different devices. Another approach of prior art is to limit rates associated with a device fingerprint which is certain properties about the device such as the type of browser operating system version clock skew etc. The outcome is the similar to rate limiting by IP address attackers simply alter the fingerprint to other obviously valid permutations.

As explained herein to prevent or at least encumber a hacker from spoofing the botwall to hide the fact that a large number of user credential uses are coming from the same endpoint app endpoints are uniquely identified. To prevent or at least encumber a hacker from responding by having endpoints generate new UEIDs for every iteration of the attack or for every few iterations the UEID generation process can be tied to some subprocess that works well for small numbers but not well for large numbers.

One example of such a subprocess is to tie the UEID generation to a specific IP address. This can be a soft barrier. Suppose that each time some user device sends in a new UEID and public key pair the botwall records the IP address from which the request came. That way if volumes exceed rational rate thresholds then requests from the associated IP addresses might be subject to additional scrutiny for a time period or a non automatable step is imposed on the user.

It might be that the botwall includes a non automatable step for every UEID generation. While this would add an extra step even for legitimate users they would not see that extra step that often perhaps only when switching to a new user device. That non automatable step might involve a web page that is configured to block frustrate automated interaction with that web page.

In another approach the botwall performs an in band or out of band step that makes use of an address space limited domain. As an example a user s telephone number can be verified by an out of band process or non automatable step. If the botwall required each request for registration of a new UEID to include the UEID the public key and a valid telephone number in the custody of the user the app server could verify that telephone number by sending an SMS message to that number placing an IVR call to that number etc. and waiting for a user response.

The app server need not be hardcoded to reject multiple requests from the same telephone number as that might typically happen when multiple legitimate users are sharing a telephone number or a user gets a new user device without a new telephone number. However the app server can be coded to reject large numbers of requests from a given telephone number. Since a criminal organization performing some network attacks via an automation of API calls would likely need to execute a large volume of API calls in part to account for a very low hit rate they would be blocked from large scale automation in part by the fact that telephone numbers comprise an address space limited domain in particular the address es available to the attacker . Thus with UEID registration requests each being correlated with a verifiable telephone number attackers might not be able to obtain enough telephone numbers to produce sufficient different UEIDs to allow the attackers to run sufficient number of automated iterations. Telephone numbers associated with excessive iterations might be temporarily or permanently black listed.

Tying the registration of new UEIDs to the possession of a telephone number creates a supply problem for the attacker but not the legitimate user. This is because all legitimate users possess telephone numbers in sufficient quantity to register for any rational use. All attacks relying on iteration are deficient by orders of magnitude a sufficient quantity of unique telephone numbers to create valid registrations. The tying of registrations to telephone numbers could be implemented in or more of several ways. For example the registration might involve an IVR telephone call to the user wherein the app server sends the user an access code over the network channel and prompts the user to enter that access code into the telephone. The app server might just request any response which would block attackers that are not able to feasibly receive and respond to tens of thousands of telephone calls.

As explained herein in effect the API usable by each user device is personalized to that user device and automating volume requests that should not be in volume are filtered out because too many come from one UEID user device. If there are limits to the rate at which UEIDs can be created then it can become infeasible for an attacker to bypass the filtering by rapidly changing the UEID or spoofing it. Thus by personalizing each API the attacker cannot run sufficient iterations though one API case or find generate enough API cases to support the iterations required for a successful attack.

An API iteration attack relies on high iterations of a machine to machine M2M API. Since it is often a simple matter to reverse engineer and understand an M2M API interface the attacker can masquerade as any expected device application simply by exhibiting the correct behavior while exercising the API. Because of the use of Wi Fi for mobile device communication and other reasons IP addresses alone might not be a useful way to identify real mobile devices. However a typical attack that expects to create value by exercising an API iteratively will need millions of iterations to scale to the point where it can be sufficiently monetized to justify the attention of criminal enterprise and to produce losses worth mitigating. Through a combination of limiting the number of API calls from one user device and limiting the number of UEIDs that can be assigned this attack is likely rendered infeasible.

The initialization process could be transparent or semi transparent to the user. For example once the user installs an app that is protected with the personalized API and runs the app for the first time the endpoint app can obtain the UEID and verify the smartphone s telephone number all without user interaction. A message to the botwall might be in the form of an SMS sent via commonly available API s for smartphone apps. Short messages are correlated to network part of the transaction and the telephone number of the user device can be obtained from the inbound SMS header.

Where it is possible to spoof the telephone number in the SMS header added security might be provided by having the botwall sends a challenge number via SMS to the telephone number provided. Using the SMS API the endpoint app can capture this number and send it back to the app server. This might use a type 0 SMS silent message so not to disturb the user.

In other variations a transparent wrapper is used to wrap native app object code with more object code and intercept outbound socket connections. That connection might be directed to a botwall. Anti automation protocol is settled first and then traffic is routed from the botwall to the web service which sees the API as it was previously expected. In yet other variations the native app developer incorporates a library instead of wrapping object code. In some variations there is a separate endpoint app for handling the processes of initialization and or personalization and the native app calls that separate app. This might allow for more than one protected native app to share a single validation registration as well as correlating behavior over multiple apps.

Where the user device is a desktop computer tablet or the like that does not have an assigned telephone number the same approach could be taken by correlating with any telephone number in the possession of the endpoint app user perhaps by the IVR method described herein separate from the user device.

For publicly exposed APIs an anti automation library might be provided to the API user to do the endpoint device side part of the API personalization problem. Registrations might then be handled by a special web page flow on the API provider s site and may also correlate registrations with any telephone number using the IVR method.

For some web sites that cannot accommodate other defenses the personalized API methods and apparatus described herein might be used where the UEID is generated at on a specific web page created to block automation and then the UEID is validated on all subsequent web pages.

As illustrated in and elsewhere endpoint app code includes functionality to obtain and store a UEID for the user device that is executing endpoint app code . During execution when the user device s processor encounters an API call illustrated in as x apicall getuserdata UEID ARGs as an example that code calls API interface code which in turn performs one or more of the processes described herein to interface to the botwall. Once the apicall function returns a value or values from the supporting service the endpoint app can use that information.

App server code might include separate code sections for code to check UEID usage and apply throttling as deemed appropriate and code for API handling if code allows an API request from an endpoint device to pass.

A user device or app server etc. might include various components. For example a user device might comprise a central processing unit CPU random access memory storage for data values such as a private key and an UEID a network interface and an input output interface. A system bus might connect the various components.

Typically the CPU capable of processing instructions for execution that it reads from program code storage which might be RAM ROM flash magnetic storage etc. The CPU may be designed using any of a number of architectures such as a CISC Complex Instruction Set Computer processor a RISC Reduced Instruction Set Computer processor or a MISC Minimal Instruction Set Computer processor. The CPU might be a single threaded processor or a multi threaded processor. Additional functionality might be provided by a graphics I O system and processor.

In some implementations the memory used is a computer readable medium such as a volatile memory unit or a non volatile memory unit. Various storage devices might be capable of providing mass storage for various needs. For example in one implementation storage devices comprise flash drive devices floppy disk devices hard disk devices optical disk devices tape devices or the like.

Input output devices might include a keyboard and or pointing device and a display unit for displaying graphical user interfaces.

The features described can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier e.g. in a machine readable storage device for execution by a programmable processor and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device.

A computer program is a set of instructions that can be used directly or indirectly in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment.

Suitable processors for the execution of a program of instructions include by way of example both general and special purpose microprocessors and the sole processor or one of multiple processors of any kind of computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally a computer will also include or be operatively coupled to communicate with one or more mass storage devices for storing data. Storage devices suitable for tangibly embodying computer program instructions and data include many forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks.

The processor and the memory can be supplemented by or incorporated in ASICs application specific integrated circuits . To provide for interaction with a user the features can be implemented on a computer having a display device such as a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball or a touchscreen by which the user can provide input to the computer. Additionally such activities can be implemented via touchscreen flat panel displays and other appropriate mechanisms.

The features can be implemented in a computer system that includes a back end component such as a data server or that includes a middleware component such as an application server or an Internet server or that includes a front end component such as a client computer having a graphical user interface or an Internet browser or any combination of them. The components of the system can be connected by some form or medium of digital data communication such as a communication network. Examples of communication networks include a local area network LAN a wide area network WAN peer to peer networks having ad hoc or static members grid computing infrastructures and the Internet.

The computer hardware described herein might be used with the computer software described herein unless otherwise indicated. The software can be written in one or more languages and be stored in different forms of memory or storage. The computer hardware described and illustrated might include various forms of digital computers such as laptops desktops workstations personal digital assistants servers blade servers mainframes and other appropriate computers.

The user device might include mobile devices such as personal digital assistants cellular telephones smartphones and other similar computing devices. Additionally the system can include portable storage media such as Universal Serial Bus USB flash drives. For example the USB flash drives may store operating systems and other applications. The USB flash drives can include input output components such as a wireless transmitter or USB connector that may be inserted into a USB port of another computing device.

The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. An endpoint device is a device that connects in some manner to at least one of the servers directly or indirectly to perform some end goal. Where one device is designated as an endpoint device it may be that that endpoint device is a client in some client server relationship but it could also be a server in some instances and there may be intermediaries that are treated as client server combinations.

While this specification contains many specific implementation details these should not be construed as limitations on the scope of any inventions or of what may be claimed but rather as descriptions of features specific to particular implementations of particular inventions. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Other implementations are within the scope of the following claims. Similarly while operations are depicted in the figures in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

In some cases the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition the processes depicted in the accompanying figures do not necessarily require the particular order shown or sequential order to achieve desirable results. In certain implementations multitasking and parallel processing may be advantageous.

Further embodiments can be envisioned to one of ordinary skill in the art after reading this disclosure. In other embodiments combinations or sub combinations of the above disclosed invention can be advantageously made. The specification and figures are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims and that the invention is intended to cover all modifications and equivalents within the scope of the following claims.

