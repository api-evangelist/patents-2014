---

title: Dynamically loaded plugin architecture
abstract: A method and architecture for using dynamically loaded plugins is described herein. The dynamically loaded plugin architecture comprises a parent context and a plugin repository. The parent context may define one or more reusable software components. The plugin repository may store one or more plugins. When a plugin is loaded, a child context may be created dynamically. The child context is associated with the plugin and inherits the one or more reusable software components from the parent context.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09075691&OS=09075691&RS=09075691
owner: BITVORE CORP.
number: 09075691
owner_city: Los Angeles
owner_country: US
publication_date: 20140313
---
This application claims priority to U.S provisional patent application No. 61 784 542 filed Mar. 14 2013. The above referenced United States patent application is hereby incorporated herein by reference in its entirety.

The disclosure relates to the field of software engineering. In particular but not exclusively this disclosure relates to a dynamically loaded plugin architecture.

In software engineering a plugin is a set of software components that adds specific abilities to a larger software application. Plugins may enable customizing the functionality of a host application. The host application may provide services which the plugin can use including a way for plugins to register themselves with the host application and a protocol for the host application to exchange data with plugins. When a plugin registers the existence of the plugin is recorded and a unique identifier may be associated with the plugin. Plugins depend on the services provided by the host application and do not usually work by themselves. Conversely the host application operates independently of the plugins and when the invention described in this disclosure is implemented it is possible for end users to add and update plugins without needing to make changes to the host application.

In software engineering an application context refers to the minimal set of data used by a task that defines the initial configuration and execution state of that task e.g. a process or a job that must be saved to allow the task to be interrupted and restarted. The word context may be used interchangeably to refer to two different but related concepts 1 information carried around within the system describing the current state of elements or processes e.g. a web request carries information describing the message and in a typical web framework this is called the Request Context or 2 the data structure used to hold this information. The software container that holds the context for the Request Context may also be called the Request Context.

There are several disadvantages if more than one plugin uses the same application context. For example plugins may not be properly isolated from each other and dynamic loading of plugins may not be supported.

Further limitations and disadvantages of conventional and traditional approaches will become apparent to one of skill in the art through comparison of such systems with the present invention as set forth in the remainder of the present application with reference to the drawings.

The present disclosure is directed to methods and architectures aimed at reducing or eliminating the above problems with the prior art. In particular but not exclusively aspects of the disclosure are directed to a dynamically loaded plugin architecture.

One example embodiment of the dynamically loaded plugin architecture comprises a parent context and a plugin repository. The parent context may define one or more reusable software components. The plugin repository may store one or more plugins. When a plugin is loaded a child context is created dynamically. The child context is associated with the plugin and inherits the one or more reusable software components from the parent context.

In another example embodiment of the dynamically loaded plugin architecture another child context is created dynamically when the plugin is loaded a second time. Thereby the plugin may run concurrently as two independent versions.

In another example embodiment of the dynamically loaded plugin architecture the parent context may be defined by an application programming interface.

In another example embodiment of the dynamically loaded plugin architecture a second child context may inherit the one or more reusable software components from the parent context or from the first child context when the second plugin is loaded.

In the aforementioned example embodiments of the dynamically loaded plugin architecture a violation may be indicated if a service invoked from the first child context contains a strong reference to a plugin class or if the first plugin returns a plugin object that belongs to a second plugin. Class refers to a programming model of a concept. In object oriented programming a class is a definition of an object s behavior and properties and an object is an instance of a particular definition.

In the aforementioned example embodiments of the dynamically loaded plugin architecture a child context may indicate whether an associated plugin is loaded. Alternatively a plugin may invoke a timed action or an event based action to indicate whether the plugin is loaded.

The present disclosure describes one or more systems methods routines techniques and or tools for designing and using a dynamically loaded plugin architecture DLPA . To overcome the limitations of current plugins the DLPA may use a context hierarchy for loading and unloading plugins. Within this context hierarchy the DLPA may check for the existence of loaded plugins and compare plugin versions that may include conflicting context requirements. Different versions of the plugin may expect different information to be present in the context or that information is organized in different ways.

The parent in is illustrated as plugin application programming interface API . The context container and its data for the plugin API may be created during an initialization step and may be independent and different from the context container and its data of the runtime assembly . Open application programming interfaces APIs provide a standard interface allowing third parties to create plugins that interact with the host application. A stable API allows third party plugins to continue to function as the host application changes. The context container for the plugin API may use the assemblies loaded by an assembly definition loader. However the context container for the plugin API will not typically use the underlying executing instance of a virtual machine operating system thread or processing task which is responsible for the execution of the plugins and and the mapping of the plugins and onto specific computing resources. Systems running in different languages may use a different execution environment. For example the execution environment may be a process thread in UNIX where the virtual machine is replaced by the runtime system library. Alternatively the execution environment may be a Java Virtual Machine.

The DLPA may comprise a plugin repository. The plugin repository may store one or more plugins. When a plugin is loaded a child context is created dynamically. The child context is associated with the plugin and inherits the one or more reusable software components from the parent context container. The plugin repository has the ability to upload download and query and requisition plugins. The plugin repository may also store plugin assemblies and files of required libraries and resources. The plugin repository provides a mechanism to configure of plugins thereby enabling a user to query 1 plugin names 2 current versions of all enabled plugins 3 versions of a particular plugin and or 4 plugin definitions of a particular version of a particular plugin.

Individual contexts for plugins may be created dynamically during a plugin load. Individual contexts may also use a corresponding instance as defined below of a plugin assembly for loading classes and resources. A single plugin configuration or description source may be specified in a plugin manifest that may include a description of the plugins available to a system. The plugin configuration may be implemented using a textual description using a domain specific language such as but not restricted to XML or any other appropriate metadata configuration mechanism such as notations or annotations inserted into the executable binary code. This configuration data may or may not be available during the execution of the program.

Within the context hierarchy a second child context may inherit the one or more reusable software components from the parent context or from the first child context when the second plugin is loaded.

A child context may indicate whether an associated plugin is loaded. Alternatively a timed action or an event based action invoked by a plugin may indicate whether the plugin is loaded. Plugins and may 1 obtain information about their implementation from the plugin API 2 obtain information about their implementation from specific instructions integrated into the plugin itself when it is created using any methods e.g. automatic resolution of inter component dependencies to specific or alternate implementations and contexts 3 obtain properties and values defined in the plugin API 4 obtain properties and values defined in an instance or reference to the plugin itself 5 override configurations defined in the plugin API but only for the local use e.g. the local execution scope as the changes will not be visible for other contexts e.g. other plugins and or 6 implement different versions of assemblies or its alternatives to obtain correct context instances.

The global parent description may not be used by plugins as it points to a shared global plugin API context. Each plugin uses its own individual context. Violation may be indicated if a service invoked from the first child context contains a strong reference to a plugin class or if the first plugin returns a plugin object that belongs to a second plugin.

The DLPA is operable to enable dynamic loading and unloading of plugins. For example the DLPA may upgrade an existing plugin add a new plugin and remove an existing plugin. Version control of the upgrades and compatibility assessment of the new plugins may be managed by the DLPA. The DLPA may also support autowiring declarative configuration annotation based contexts and or loading of resources and properties. Autowiring refers to a method for finding compatible running software components and injecting the executable components into the running system.

The DLPA has the ability to 1 enable or disable plugins 2 select one of the available versions of a plugin as the current version 3 watch for changes in a plugin configuration 4 add a new version of a plugin 5 add a new plugin and 6 completely remove a plugin version or all versions of a plugin or all plugins at once.

Plugin is loaded and a first child context is created dynamically thereby generating plugin V. . Plugin is loaded a second time while plugin V. remains loaded. Then a second child context is created dynamically thereby generating plugin V. . The two versions of plugin and may run concurrently as two independent plugins.

When the system starts up the runtime assembly is in an initialization phase and may not have any plugins loaded. During the initialization it may receive a Load Request either from an external system not shown or from some internal configuration program. In response to this Load Request the plugin runtime assembly instantiates a new plugin . This plugin inherits its definition and state from the context of the runtime assembly and also adds to this its own context. Now the system comprises both the runtime assembly and the plugin .

While depicts the loading of only one plugin many plugins including but not limited to multiple versions of the same plugin may be loaded and run concurrently. Plugins may communicate with each other or only with the core runtime assembly .

The architecture describe herein allows for plugins with any possible mixture of version type or configuration to run concurrently or sequentially within the same system. The executing combination of type version and configuration is called an Instance and is identified by a plugin instance identifier PGID. However plugins are uniquely identified by their type version and configuration and the system may be configured that two exactly identical combinations may not be loaded simultaneously. This is optional and under certain circumstances exactly identical combinations may be loaded simultaneously and are identified by additional information in their PGID values.

Aspects of the present disclosure may be embedded and or embodied in a program which comprises features enabling the implementation of the embodiments described herein and which when loaded in a computer system is able to carry out these embodiments. Computer program in the present context means any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation b reproduction in a different material form.

While the present disclosure has been described with reference to certain embodiments it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted without departing from the scope of the present disclosure. In addition many modifications may be made to adapt a particular situation or material to the teachings of the present disclosure without departing from its scope. Therefore it is intended that the present disclosure not be limited to the particular embodiment disclosed but that the present disclosure will include all embodiments falling within the scope of the appended claims.

