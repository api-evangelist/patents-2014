---

title: System and method for implementing mesh network communications using a mesh network protocol
abstract: The following describes data structures, communication protocol formats and process flows for controlling and facilitating secure communications between the nodes of a mesh network, such as utility meters and gateway nodes comprising a utility network. The enabled processes include association, information exchange, route discovery and maintenance and the like for instituting and maintaining a secure mesh network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09621457&OS=09621457&RS=09621457
owner: Trilliant Networks, Inc.
number: 09621457
owner_city: Redwood City
owner_country: US
publication_date: 20140217
---
The present application claims the benefit of U.S. provisional patent application Ser. No. 61 094 116 entitled Message Formats and Processes for Communication Across a Mesh Network filed Sep. 4 2008 which is incorporated herein by reference in its entirety.

The present application hereby references and incorporates by reference each of the following United States patent applications 

This invention pertains generally to a protocol layer for facilitating the creation and maintenance of a secure mesh network. More particularly preferred embodiments of the invention describe data structures communication protocol formats and process flows for controlling and facilitating secure communications between the nodes of a mesh network such as utility meters and gateway devices comprising a utility network.

A mesh network is a wireless network configured to route data between nodes within a network. It allows for continuous connections and reconfigurations around broken or blocked paths by retransmitting messages from node to node until a destination is reached. Mesh networks differ from other networks in that the component parts can all connect to each other via multiple hops. Thus mesh networks are self healing the network remains operational when a node or a connection fails.

Advanced Metering Infrastructure AMI or Advanced Metering Management AMM are systems that measure collect and analyze utility usage from advanced devices such as electricity meters gas meters and water meters through a network on request or a predefined schedule. This infrastructure includes hardware software communications customer associated systems and meter data management software. The infrastructure collects and distributes information to customers suppliers utility companies and service providers. This enables these businesses to either participate in or provide demand response solutions products and services. Customers may alter energy usage patterns from normal consumption patterns in response to demand pricing. This improves system load and reliability.

A meter may be installed on a power line gas line or water line and wired into a power grid for power. Newly installed meters may associate with a specified network identifier entered by a user during installation. Alternatively the user may initiate an association window during which a meter may associate with a nearby mesh network.

In accordance with an embodiment of the present invention a method of associating a device to a mesh network is described. The method includes selecting a network for association including requesting by the device neighbor information from neighboring devices which may belong to one or more networks receiving at the device from one or more neighboring devices neighbor information for each of the one or more neighboring devices applying an association ratio algorithm to the received neighbor information to determine which of the one or more networks to select for association. The method further includes selecting a router within the selected network through which to proxy messages by applying a preferred route ratio algorithm sending a network association request from the device through the router to a network coordinator and at the network coordinator performing one of the following in response to the network association request validating the association request with an association response message which includes the short address for this device or not responding to the network association request. The method further includes constructing at the device an initial neighborhood table.

In accordance with another embodiment of the present invention a process for routing data frames from a first node to a second node within a network is described. The process includes a tree routing sub process a source routing sub process a temporary routing sub process and a mesh routing sub process. The particular sub process for routing a data frame from the first node the second nodes is selected in accordance with the following logic executed on a processor if the data frame has a source route header the source routing sub process is selected if there is an entry for the target address in a temporary routing table the temporary routing sub process is selected if the second node is a coordinator node the tree routing sub process is selected and if the second node is not a coordinator node the mesh routing sub process is selected.

In accordance with another embodiment of the present invention a process for discovering a route from a first node to a second node in a mesh network is described. The process includes broadcasting by the first node a route request message that is propagated across multiple nodes within the mesh network. The propagation follows a processor implemented process at the multiple nodes including accepting a route request at a receiving node if i no previous received route request message had the same request ID and ii the route request message is received through a link with a minimum LQI class at least equal to the requested one identifying the receiving node as a route candidate if the route request message is accepted by an intermediate node the route request is re broadcasted. If the route request message is accepted the second node sending a route reply message from the second node through the identified route candidate back to the first node to establish a static bidirectional route within the mesh network between the first node and the second node.

In accordance with a further embodiment of the present invention a process for upgrading a route from a first node to a second node in a mesh network is described. The process includes accepting a route request at a receiving node for upgrading the route if a route candidate already exists for the request ID the request was received through a link with a minimum LQI class at least equal to the requested one and the request was received through a better link than the prior received one. These determinations are made according to the following sets of conditions i the receiving node is a neighbor the route request is received from a neighbor and a resulting route length is shorter ii the receiving node is not a neighbor the route request is received from a neighbor and a resulting route length is shorter or equal to existing route length iii the receiving node is not a neighbor the route request is received from a non neighbor and a resulting route length is shorter. If the conditions are not met the route request is rejected.

In accordance with a further embodiment of the present invention a process for requesting a route from a first node to a second node within a mesh network is described. The process includes transmitting a route request message to a pre determined coordinator node wherein the route request message includes a long address for the second node constructing at the coordinator node a route through one or more routing nodes from the first node to the second node and transmitting a response to the route request message to the first node including the route to the second node wherein the route includes an assigned short address for the second node.

In accordance with a further embodiment of the present invention a data structure for securing data frames transmitted in a single hop within a mesh network from a first node to a second node is described. The data structure includes a data link layer DLL security header located after a service type octet when a predetermined security header flag is selected within the service type octet. The DLL security header including a first set of bits containing a portion of a transmitted nonce count a bit following the first set of bits containing a key identifier ID wherein the key ID selects a current version of a key used for calculating a message integrity check MIC and a second set of bits containing the MIC.

In accordance with a further embodiment of the present invention a process for validating integrity of message data transmitted in a single hop from a first node to a second node within a mesh network is described. The process including checking at a processor of the second node the 23 least significant bits of a count transmitted from the first node against a last authenticated count if the transmitted count value is greater than the last authenticated count combining at a processor of the second node the 23 least significant bits with the 17 most significant bits of the last authenticated count to form a revised count if the transmitted count value is lower than the last authenticated count incrementing the value of bits through by one before combining at a processor of the second node the 23 least significant bits with the 17 most significant bits of the last authenticated count to form a revised count calculating at the processor of the second node a message integrity check MIC value using the revised count and pre selected key if the calculated MIC value equals a received MIC value then the message data integrity is validated.

In accordance with a further embodiment of the present invention a data structure for securing data frames transmitted in multiple hops using multiple nodes across a mesh network. The data structure including a network security header located after a data link layer DLL security layer within a mesh header. The network security header including a first set of bits containing a network count a bit following the first set of bits containing a network key identifier ID and a second set of bits containing a network message integrity check MIC .

In accordance with a further embodiment of the present invention a process for validating integrity of a data frame transmitted in multiple hops using multiple nodes across a mesh network. The process including receiving a data frame at a receiver node wherein the data frame includes a network security header including a network count a network key identifier ID and a message integrity check MIC processing an identifier ID for an originating node that originated the data frame and a source field address to determine if the data frame was received from a coordinator node or a non coordinator node if the data frame was received from a coordinator node the network key ID selects a node key for determining verification if the data frame was received from a non coordinator node the network key ID selects a mesh key for determining verification. Further when the received data frame is a request a nonce is a combination of at least the network count the originating node ID and an originating node address and the receiving node verifies the integrity of the frame by adding a 0 to the network field to make a 40 bit field calculating the received MIC using either the node key or the mesh key as identified by the network key ID comparing the transmitted MIC with the received MIC wherein the data frame is verified if the transmitted MIC is equal to the received MIC. And when the received data frame is a response the network count is combined with the identifier and address for the target of the data frame and the originating node ID and an originating node address and the receiving node compares a network count in the response with a network count in the request wherein the data frame is verified if the response network count is equal to the request network count.

The following charts of terms and acronyms are intended to define the frequently used terms in the context of the preferred embodiments of the present invention. The definitions provided are not intended to define the entire scope of the term. One skilled in the art appreciates the various alternatives and variations that are clearly within the scope of the invention as described.

Association Router Router selected by a Node which is not yet a member of the network to act as a proxy to send the Node s association request.

Child In the context of tree routing all Routers in single hop radio frequency RF contact with a reference Router with a hop count greater than the hop count of that reference. In the context of End Devices a Child refers to an End Device of a specific Router through which it sends and receives messages.

Dedicated Router A router manually configured to associate to a specific network to guarantee that the network covers a specific geographical region.

Device Key A key unique to the device. The initial device key is assigned by its manufacturer and is unchangeable. A database for device IDs and initial Device Keys is made available to the system owner and is installed in the network s Configuration Host. A Device Key generated by a Configuration Host should be known only to the Configuration Host and the device. Device Keys are used only for securing Application Layer communication between the Configuration Host and the device. As such they are not directly part of the SM protocol which encompasses only the data link layers.

Key ID Keys are updated from time to time the specific generation of key is identified within this specification with a single bit Key ID which is the low order even odd bit of the actual key generation count.

Key Type Each key type has a specific usage scope and is associated to a specific management process. This specification supports three Key types the Maintenance Key the Mesh Key and the Node Key.

Maintenance Key This key is shared by all the devices in all PANs that are administered by a single Configuration Host. The Maintenance Key is used for Association Request Response messages and maintenance device point to point secured communication messages. The Maintenance Key can be factory assigned or is assigned by the Configuration Host it can be updated by a Coordinator.

Mesh Key This key is used for all DLL MIC calculations except those secured by the Maintenance Key. It is also used for the Network MIC when the message is broadcast through the mesh or when the Network Security is used for device to device communication. The Mesh Key is common throughout a PAN and to all interconnected PANs that are configured to support inter PAN communications. The Mesh Key is assigned and updated by the Coordinator.

Network Name Name assigned to a mesh network. Network names are typically assigned using a dot separated hierarchy with the first level representing all mesh networks forming a single AMI network. The typical format of a network name is utility.area.coordinatorID .

Node Key A unique key assigned to a device and used for secure communication between the Coordinator s and the device. It is primarily used for the Network MIC header calculation and for encrypting keys distributed by the Coordinator. The Node Key is initially assigned by the Configuration Host but it can be updated by either the Configuration Host or the Coordinator.

Originator Count The Originator Count Orig. Count is used as the nonce in the Network Security Header. Its value is the same as the Source Count value at the time the message is originated.

Parent In the context of tree routing all Routers that have a direct RF link with a reference Router and that have a hop count less than the hop count of that reference Router. In the context of an End Device the Router used to send and receive messages on behalf of this End Device.

SM Coordinator Referenced within this document as Coordinator this Node responsible for initializing the network accepting association requests and assigning unique short addresses.

SM End Device Referenced within this document as End Device this Node is not capable of routing messages and can communicate only through its Parent. An End Device can be either always be listening or wake up periodically to synchronize with its Parent in order to minimize energy.

SM Router Referenced within this document as Router this Node is capable of managing routes and routing messages.

Sibling In the context of tree routing all Routers that have a direct RF link with a reference Router with a hop count equal to the hop count of that reference Router.

Sleeping End Device A Sleeping End Device reduces it average power consumption by turning itself off for periods of time. It requires a Parent to store frames for it while it is sleeping. A Sleeping End Device cannot be used for routing.

Source Count The Source Count also referenced as Src. Count is used as the nonce in the DLL Security Header. The Source Count is incremented with every message transmitted by the device.

DLL Data Link Layer the data link layer provides device to device networking services in conjunction with the IEEE 802.15.4 MAC. For the SM system the DLL provides hop by hop security.

LQI Link Quality Indicator a value based on the signal strength and other quality aspects of the received signal.

LQI class Link quality between two Nodes expressed as four different classes Good 11 Normal 10 Poor 01 and No Connectivity 00 .

PAN Personal Area Network the IEEE 802.15.4 name for one of its networks whether for personal use or not.

The following describes the message formats and the processes implemented by the SecureMesh protocol hereafter SM protocol within a SecureMesh network hereafter SM network . Referring to the SM protocol in conjunction with the IEEE 802.15.4 MAC layer implement the Open Systems Interconnection OSI Data link. An exemplary SM network topology is shown in and is composed of a coordinator routers and end devices generically referred to as nodes . The preferred routes between routers create a tree for which the root is the coordinator . Each node can be a member of trees of different adjacent networks though any single network has only a single coordinator. A SM network may include non routing nodes called end devices which are associated to a preferred parent through which messages are sent and received. The SM protocol also supports routing of messages using alternate routes when a preferred parent fails this process is called local repair. In the preferred embodiments of the present invention the nodes typically include utility meters and related devices but the invention is not limited as such.

The transmission of messages between nodes defined by the SM protocol is governed by the following rules 1 Fields are transmitted in their order of definition from left to right when represented in a frame format diagram see for example or from top first to bottom last when listed in a table 2 All multi octet fields are transmitted least significant octet first little Endean 3 Binary or string fields are transmitted serially starting at index zero. For backward compatibility reasons short and long addresses can be configured as multi octet fields transmitted least significant octet first as specified by IEEE 802.15.4 or as binary fields transmitted serially. The transmission order of the addresses is controlled by the configuration parameter ADDRESS TX ORDER.

A critical process to SM network formation is the association process. The association process is used by nodes to become a member of an SM network or to evaluate their current association state. The association process incorporates the following primary functions selection of a PAN selection of an association router to proxy messages association with the coordinator and the reception of a short address assignment and construction of the initial neighborhood table.

As a first step in the association process each device referred to as a node once associated must be commissioned with the network s node key and the network s maintenance key prior to associating with a network. The key commissioning process for a particular device is determined by the device s application. For example the device may be configured at manufacturing or by a maintenance tool or through the Service Request and Service Response messages described in below. A quick summary of the association process is described with a follow on detailed description. A Neighbor Info Request is transmitted on each channel to locate and get information about neighbor nodes and neighbor SM networks. All nodes receiving the Neighbor Info Request respond with a Neighbor Info Response. A particular SM network is selected based on an Association Ratio algorithm discussed further below. An Association Router which is a member of the selected SM network is selected based on the Preferred Route Ratio algorithm also discussed below. An Association Request is transmitted to the selected Association Router by the requesting device. When the Association Router is not the Coordinator the Association Request is repackaged and forwarded in the form of an Association Confirmation Request message to the Coordinator using tree routing. If the Association Confirmation Request is received and validated the Coordinator sends back the assigned short address in an Association Confirmation Response message which is then repackaged and sent to the device as an Association Response message. Similarly when the Coordinator receives the Association Request directly it returns its response directly in an Association Response.

In the specific case of a successful association i.e. the Association Status within the Association Response is set to successful the Node sends a Neighbor Exchange message with the Immediate Broadcast Requested option set discussed below on the just associated SM network. As a result this causes surrounding neighbors to broadcast a Neighbor Exchange message using a pseudo random period within NEIGHBOR EX RND PERIOD thus allowing the Node to populate its Neighborhood Table right away.

Device association is started with the neighbor information request process shown in . Node A initiates the process with a Neighbor Info Request that is broadcasted on a channel and received by other Nodes in the neighborhood that are listening to that channel. Each Node receiving the message responds at a pseudo random time in the interval given by the parameter NEIGHBOR INFO RESP TIME. The IEEE 802.15.4 MAC known to those skilled in the art and described in numerous publicly available documents resolves most collisions that occur due to Nodes selecting the same response time. Node A waits for the interval NEIGHBOR INFO RESP TIME to receive all Neighbor Info Response messages from its neighbors. Once the Node has received neighbor s information it can start the association process.

In Node A is in the neighborhood of the Coordinator for PAN 1. As it receives Neighbor Info Response messages it uses the Association Ratio algorithm and the Preferred Route Ratio algorithm to select PAN 1 and the Coordinator for PAN 1 as its Parent. In this case it sends its Association Request directly to the Coordinator and gets the Association Response back. Node A expects to get a response back within a time period established by the ASSOCIATION RESP TIME parameter. This process is repeated on each available channel.

If the associating Node is not in the neighborhood of the Coordinator it uses a neighbor to proxy the Association Request. shows this proxy process. Node A receives a number of Neighbor Info Response messages. It uses the Association Ratio algorithm and the Preferred Route Ratio algorithm to select the Coordinator for PAN 1 and Node B as its best neighbor for the PAN. Node A then sends Node B the Association Request message and starts its response timer set with the value defined by ASSOCIATION RESP TIME. Node B takes Node A s request and generates an Association Confirmation Request message to the Coordinator. The Coordinator responds with the Association Confirmation Response message to Node B and Node B sends the Association Response message to Node A.

As mentioned previously the association process described in this section is also used by a network member to re evaluate its association status. This action is performed every ASSOCIATION EVAL PERIOD and is intended to determine if the network member should remain on the same SM network or if it should migrate to another one. The Node will change its network membership i.e. complete its association process on another network only if the resulting Association Ratio represents an improvement compared to its current Association Ratio. The required improvement must be equal or better than the ASSOCIATION EVAL MIN IMPROVEMENT. If it is not the case the Node maintains its membership on the current network and the whole process stops immediately.

The mesh layer see routes frames to the target addresses by one of four processes Tree Routing Source Routing Temporary Routing or Mesh Routing using combinations of the Neighborhood Table Routing Table and Temporary Route Table. The route selection processing facilitated by the mesh layer is shown in . The frame either arrives as a frame initiated by the Node device or as a received frame to be routed by the Node. Routed frames have an entry created in the Temporary Routing Table to allow subsequent traffic in the reverse direction using the reverse route. The routing process used for the frame is selected based on the following logic 

Tree routing is the preferred routing method when a Node initiates communications that target the Coordinator. Tree routing uses the Neighborhood Table to find a route to the Coordinator as shown in . The device selects the neighbor entry with the Preferred Parent Flag set in the Neighborhood Table. If transmission to the preferred parent does not succeed the device attempts to select another Parent in the Neighborhood Table e.g. an entry that has a hop count value less than the device s hop count value preferably ordering the selection on the device s Preferred Route Ratio value. If there are no Parent entries left to try the device looks for a Sibling entry e.g. an entry that has the same number of hops to the Coordinator preferably ordered based on the device s Preferred Route Ratio value. The device will try entries in the Neighborhood Table until it has reached the MAX TREE REPAIR limit or until the Neighborhood Table is exhausted. To avoid multiple lateral transmissions through Siblings a flag in the mesh header called Sibling flag is set when transmitting to a Sibling. Frames received with the Sibling flag set can be routed only through a Parent.

Referring to source routing is the preferred routing method when communications initiated from the Coordinator targets a specific Node. The Coordinator can also use the broadcast address as the target address at the end of the source route list to send a message to all the Nodes that are the neighbors of the last explicitly addressed device. Source addressing is also used for communication between any two Nodes if the originator knows the entire route between them. This node to node source route is determined by a Route Request to the target Node with the Trace Route Flag set or by a Route Establishment Request sent to the Coordinator asking for a route to the target Node. The source routing process sends a frame with the complete route embedded in the frame header. The Node receiving a source routed frame finds its address in the route list and uses the next address in the list as the next destination hop for the frame. A temporary return route is created when a source routed frame is received by each Node on the path so that upstream frames can be routed using the Temporary Routing Table.

Unlike tree routing which can only be used to reach the Coordinator mesh routing can reach any Node on the network. Routes are established using the Route Discovery process which is described later. The routes are stored in a Route Table whose entries contain the next hop for the target address. A route remains valid until a Node tries unsuccessfully to use it or a Route Error message is received deleting the Route Table entry. A Node that cannot send a frame to the Node listed in the Route Table generates a Route Error message and deletes the entry from its Route Table. The oldest Route Table entry may also be deleted when a Node needs space in its Route Table for a new entry. The use of mesh routing should be limited because of the overhead it imposes on the network. This method is used only when more preferred methods such as tree and source routing fail. Referring to the mesh routing process looks up the target address in the Route Table. If the target address is found the frame is sent to the designated Node. An error is generated when the MAC layer ACK is not received after repeated attempts or a Route Error message is received. In either case the route entry is removed from the Route Table and a Route Error message is broadcast to all neighbors. A Route Error message is also generated if the target address is not found in the Route Table.

Every time a mesh frame is forwarded no matter the routing method used with the exception of the Temporary routing itself the forwarding Node creates a temporary route entry to the originator in the Temporary Routing Table. This allows the destination Node to quickly send a reply even if it didn t previously know the route to the originator Node. This route expires after a period of time determined by TEMP ROUTE TO parameter. The Temporary Route Table takes precedence over the Neighborhood Table and the Route Table. Referring to the Temporary Route Table is accessed and the MAC destination address associated with the mesh layer target address is selected. The frame is then transmitted. If the MAC fails to transmit a frame the Error Received condition is true and the Node tries to send the frame by an alternative route using Tree Routing or Mesh Routing.

In a mesh message from Node A sets the temporary return route in the table of Node B. A mesh message from Node C to Node A is routed to Node B. Node B s temporary return route to Node A has not expired and so it uses the route to send the message to Node A. Sometime later another mesh message from Node A restarts the temporary route expiration timer. After the time TEMP ROUTE TO no new messages from Node A arrive and Node B deletes the temporary return route to Node A. The number of temporary return routes that can be stored is limited. If the limit is reached the oldest temporary return route is deleted when a new temporary return route is created.

A route discovery process is performed when a Node needs to create or trace a new route within the mesh network. It consists of a mesh broadcast of a Route Request message which is propagated through the network based on Route Request Acceptance Conditions. Once received by the target Node a Route Reply message is returned to the originator leading to the creation of a new static route in both directions.

Initially Route Request acceptance conditions are verified by each Node receiving a Route Request message. This verification algorithm allows a Router to forward or stop the propagation of a Route Request. When acceptance conditions are satisfied the Router from which the Route Request message was received is keep as a Route Candidate. A Route Candidate can be replaced based on Route Request acceptance conditions during the mute discovery process to improve routing. Route Candidates are used at the end of the route discovery process when the Route Reply message is sent back to the originator. A Route Request is accepted as the first Route Candidate if it meets all of the following conditions 

The overall route discovery process is summarized in which illustrates the simplest case i.e. without any Route Candidate upgrade. The effect of a Route Candidate upgrade is shown in in which the return path is updated during the route discovery process. The originator broadcasts a Route Request with a minimum LQI class of Reliable link. 

Every Router receiving the Route Request accepts or rejects the request based on conditions discussed above. If the Route Request is accepted as a first route candidate and the Router is not the target destination it creates a route candidate to the originator and rebroadcasts the Route Request. If the Router is the target destination it starts a timer of RREQ RX TIME milliseconds and creates a route candidate to the originator.

If the Route Request is accepted for a route candidate upgrade the Node upgrades its route candidate without re broadcasting the Route Request. At the expiration of the timer that was initialized to RREQ RX TIME the destination Node converts its route candidate into a static route and sends a Route Reply to the Next Hop of the route just created. Each Node receiving a Route Reply converts its route candidate into a static route to the originator. It also creates a static route entry to the destination. The Route Reply is then forwarded to the originator. If the originator does not receive a Route Reply after the RREQ TO timeout period 700 ms by default it broadcasts a second Route Request with a minimum LQI class set to Average link. If this second attempt fails the originator tries a third and last attempt with a minimum LQI class set to Unreliable link. If the three attempts of broadcasting a Route Request fail an error is returned to the upper layer. illustrates the Route Discovery process with no Route Candidate upgrade. illustrates the Route Discovery process with Route Candidate upgrade. If the trace route option is set in the Route Request message the target Node will set the trace route option in the Route Reply message. In this case intermediary Routes create a temporary route instead of a static route and the route is recorded in the Route Reply message. The originator of the request can subsequently use the temporary route or source routing to reach the destination. Each Route Request is identified by a unique combination formed by the originator s short address and the Request ID. It is then possible to identify a Route Request already received from another Node.

Referring to Route Establishment is a process in which a Node asks the Coordinator for a source route to another Node. The originator Node uses the target s 8 octet long address in its request. The Coordinator constructs a route using its current knowledge of the SM network. The Neighbor information contained in the periodic Keep Alive Request messages sent by Nodes is a prime source of information used by the Coordinator to construct routes. The Route Establishment response contains the source route to the target and the target s assigned short address. A route established from Node A to Node B is used for one way communication. When Node A sends a message to Node B that requires a reply Node B uses the temporary route set up along the route by Node A s message.

The neighbor exchange process is performed by all Nodes on a periodic basis. The Neighbors Exchange process is used to update neighbor information and routing tables. Each Node in the network generates a periodic Neighbors Exchange message. All Nodes receiving the request update their Neighborhood Table. shows one Neighbor Information Exchange broadcast message transmitted by Node A which is received by Nodes B C and X.

An LQI measure is taken each time a Neighbors Exchange is received. The value LQI rx in the Neighborhood Table is updated according to Table 2.

These rules tend to keep the LQI rx in the Neighborhood Table high even if a particular LQI measurement is lower or if a single Neighbors Exchange is missed. This is intentional.

Tree optimization is a recurrent process performed by all Nodes to ensure the network s optimal performance. The preferred route toward the Coordinator is re evaluated after each Neighbors Exchange message is received. To avoid tree instability the Avg LQI factor is omitted for tree optimization it is used only at association when a Node selects its initial preferred route. Only one route change is allowed per 6 cycles of NEIGHBORS EXCHANGE PERIOD to provide enough time for the information to propagate in the network. This delay limits the rate at which Child Nodes change their route when the route quality improves.

Each Node on the network shall report its presence to the Coordinator from time to time using Keep Alive Request messages to maintain its association status. The reporting period is determined by the CHECKPOINT PERIOD and is typically set to be one hour. The period between Keep Alive messages should be constant as specified by the Keep Alive Period field within the Keep Alive Request message. The Coordinator flags a Node as Non Responding if this Node fails to communication with it within the Keep Alive Period. If the Coordinator has not received a Keep Alive Request or a Power Event message in a specified time it removes the device from is registration table. The Coordinator s timeout period for Keep Alive Request Power Event messages can be as long as 90 days. The Checkpoint process is also used to trace the latest tree route for subsequent requests using source routing send network management information such as network statistics and neighborhood information allow configuration of mesh layer parameters controlled centrally and provide a window of opportunity for the upper layer batch traffic.

The Checkpoint is initiated autonomously by each Node. Checkpoint reporting by each Node is distributed pseudo randomly within the CHECKPOINT PERIOD. If the Coordinator needs to have better control over timing of the traffic generated on the network it can send a Keep Alive Initiate request prior to the autonomous transmission of the Keep Alive Request. The Keep Alive Initiate request relies on the routing information of the previous Keep Alive Request. If this information is out of date the subsequent autonomous Keep Alive Request sent by the Node will reestablish a valid route. It is important to note that a Keep Alive Initiate request does not create an entry in the Temporary Route table thereby allowing the subsequent Keep Alive Request to trace the currently optimized tree route. In Node A sends a Keep Alive Request frame to the Coordinator as triggered by expiration of its CHECKPOINT PERIOD timer. The Coordinator receives the request and sends a Keep Alive Response frame. The originator Node does not retry the request if it does not receive a reply. After a successful reception of the Keep Alive Response or timeout of a watchdog timer preset to the value of the parameter COORD RESPONSE TIMEOULT upper layers are notified so they can start exchanging information if needed.

There are three security services provided by the SM network and protocol privacy authentication and authorization. Initially though not all data transmitted throughout the SM network has to be kept private there are instances where the data sent should be encrypted to protect it from discovery. For example security key configuration information needs to be kept private. Additionally data is authenticated in two ways. First the data s integrity is checked to make sure that it has not been changed when transmitted through the network. Data integrity is verified from the source to the destination through one or more hops in the mesh network. Like the data the address is protected from being changed undetectably. If the key used to protect that address is unique to the source then the authentication verifies the integrity of the source address and that the stated sender originated the message frame. Further the operations in messages have permission requirements associated with them. Devices originating messages have authorizations configured in the SM network that give the devices the permission to perform operations that match the permission requirements.

The SM network protocol provides security for management frames routed through the mesh. These routed frames may span more than one hop and therefore need end to end security. The security features used by the SM network protocol are authentication and authorization. The mesh layer operations do not require privacy other than for the transmission of security keys where the privacy is provided by encrypting the transported keys. The SM protocol provides data link security services for hop by hop message transmissions. The SM data link protocol provides data and source authentication for each hop taken by the message. It also provides operation authorization for local communication with maintenance devices. This security level also provides replay protection for all local and routed communication. Table 3 summarizes the implemented security mechanisms in accordance with a preferred embodiment of the present invention the behavior of data link and network level counters and the key type used for each message type. For each message type in Table 3 the security method and key specified must be used or the receiver rejects the entire message.

In Table 3 the following define the behavior of the counters sent Src. count is the value of the current counter of the sender of the frame Single Hop Orig. count is the value of the current counter of the originator of the frame within the mesh network Reflection is the response use of the value of the counter received in the request Ticket is the Counter provided by a Router for use by Nodes before they are associated and for maintenance devices that communicate with the device using point to point messages. The nonce is created by concatenating full five octet ticket with the long address of the Router providing this ticket. Also in Table 3 the following define the behavior of the counters received. The last means the recipient of the frame may accepts any counter value playback rejection is not required since playback is already verified by the DLL security at each hop. Optionally if the recipient has the memory to store the previously received counts it may reject frames where the count is not greater than the stored count. The sent means the counter received must be equal to the counter sent in the request. The last n means the counter received must be greater than the RX Source DLL Nonce Count value maintained in the Neighborhood Table. The Neighbor Info Response frame initializes the RX Source DLL Nonce Count in the Neighborhood Table. The periodic Neighbor Exchange message maintains its currency in the absence of regular traffic between the two devices. The last ed means the counter received must be greater than the last RX Source DLL Nonce Count value maintained in the End Device Table. The periodic End Device Data Request message maintains its currency. And the last rc means the counter received must be greater than the last RX Source DLL Nonce Count value temporary maintained for a selected Node and acquired in the Neighbor Info Response or Local Broadcast Response. The last counts are initialized to zero in the tables and then updated with the first authenticated reception. The following letters are used in Table 3 to define the key type used by each message type. N is private Node Key S is Shared Mesh Key and M is shared Maintenance key.

The SM protocol provides a DLL Security service with data and source authentication using a message integrity check mechanism MIC 32 as described in Annex B of IEEE 802.15.4 2006 which is incorporated herein by reference in its entirety. DLL security uses the SM DLL Security header to select the security key and set the nonce used in the crypto calculation. The DLL Security header is an optional field following the Service Type octet that is present when the DLL Security Header Flag in the Service Type octet is set 1b as defined herein. The format of the DLL Security header is shown in . The first fifteen bits . . . of the DLL Security header contains a portion of the transmitted nonce count. Bit is the DLL Key ID that selects the current version of the key used to calculate the DLL MIC. This Key ID is used to coordinate the key used during a key change process by explicitly identifying which key was used in generating the DLL MIC.

The MIC 32 data authentication calculation uses the calculation process described in the IEEE 802.15.4 2006 standard. The SM DLL nonce used for the MIC calculation is shown in . The DLL nonce used in the MIC calculation is thirteen octets. The DLL Security nonce combines the full DLL nonce count and the MAC layer source address used by the transmitting device. The Full DLL Nonce Count is five octets long which ensures that its value does not repeat within the lifetime of a key at the frame transmission rates of SM devices. The address used in the MAC nonce is either the 8 octet long EUI address or the 2 octet source PAN ID plus the 2 octet short address prefixed by four octets of all ones. The Full DLL Nonce Count can be based on either the Source counter or the Ticket counter.

This process is used for all message types using the Source Counter as listed in the summary table in Table 3. The five octets bits of the Full DLL Nonce Count are constructed using the following algorithm The least significant octet bits of the transmitted nonce count is the IEEE 802.15.4 MAC header sequence number. The next 15 bits come from bits through of the DLL Security header s SM DLL Count. Together the 23 bits of the transmitted count forms the least significant bits of the counter portion of the SM DLL nonce. The receiver checks the least significant 23 bits of the transmitted count against the last authenticated RX Source DLL Nonce Count. In the case of an End Device the last authenticated RX Source DLL Nonce Count represent the Source Count acquired using a Neighbor Info Request and maintained in the End Device Table. In the case of mesh messages excluding the Association Request the last authenticated RX Source DLL Nonce Count represents the Source Count acquired using a Neighbor Info Request and maintained in the Neighborhood Table. The Neighborhood Table entry is selected using the source PAN ID and MAC address of the received message. In the case of an Association Request or of point to point messages the last authenticated RX Source DLL Nonce Count represents the Source Count acquired using a Neighbor Info Response a Local Broadcast Response or an End Device Node Present received and maintained temporarily for a selected Node. If the transmitted count value is greater than the last authenticated RX Source DLL Nonce Count then the transmitted counter bits are combined with the most significant bits of the last authenticated RX Source DLL Nonce Count to form the Full DLL Nonce Count. However the transmitted count is assumed to have rolled over if the transmitted count value is less than the value of the corresponding bits in the last authenticated RX Source DLL Nonce Count. When this is the case the value in bits through of the last authenticated RX Source DLL. Nonce Count is incremented by one before it is combined with the transmitted bits to form the Full DLL Nonce Count. The MIC 32 is calculated using the Mesh key generation specified by the DLL Key ID. The selected key and the Secure Full Mesh DLL Nonce are used to calculate the DLL MIC 32 value. If the calculated MIC 32 equals the transmitted MIC 32 then the message data integrity is validated and the message has not been received previously. In this case the last authenticated RX Source DLL Nonce Count is updated to the value of the Full DLL Nonce Count used in the MIC calculation.

The SM DLL security nonce ticket counter process is used for all message types using the Ticket Counter as listed in the summary table in Table 3. This process is used for the secured non routed DLL communications employed by Association Request Response messages and by point to point messages. For these messages at least one of the MAC addresses has a long 8 octet format the Maintenance Key is used and the process is modified. The DLL Key ID selects the appropriate Maintenance Key and nonce count. The following algorithm is used to calculate the MIC. The five octets bits of the Full DLL Nonce Count are constructed using the following algorithm the least significant octet bits of the IEEE 802.15.4 MAC header sequence number is combined with bits through of the DLL Security header. Together they form the 23 bits of the transmitted count bits of the DLL nonce count.

The Ticket field in the Maintenance Key Table contains the last authenticated count received. The receiver checks the least significant 23 bits from the table and compares them to the transmitted count. If the transmitted count value is greater than the value in the corresponding bits of Ticket then the transmitted counter bits are combined with the most significant bits . . . of the Ticket to form the Full DLL Nonce Count. However if the transmitted count value is less than the value of the corresponding bits in the Ticket rollover of the transmitted count value is inferred. When this is the case the value in bits through of the Ticket is incremented by one before it is combined with the transmitted bits to form the Full DLL Nonce Count. The MIC 32 is calculated using the key specified by the Maintenance Key selected by the DLL Key ID and the Full DLL Nonce Count. If the calculated MIC 32 equals the transmitted MIC 32 then the data integrity is validated and the message has not been received previously. In that case only the Full DLL Nonce Count is stored in the Ticket Count of the Maintenance Key Table.

The DL Security header MIC covers the SM message starting with the IEEE 802.15.4 Frame Control octet and continuing on through to the end of the payload. As shown in the IEEE 802.15.4 physical layer preamble and the Frame Check Sequence are not part of the DLL Security calculation.

The DLL Security header provides security for data authentication and operation authorization of SM messages that can travel one hop. The SM network security header provides end to end security for frames which can travel multiple hops. When present the network security header provides authentication of data that is not dependent on trusting the intermediate routing devices. The network security header controls security for that portion of the SM frame that does not change as it is routed through the network. The network security header is present when the Originator Network Security Header flag is set as defined in the common mesh header described below

The network security header is shown in . It is located in the SM header after the DLL Security header. The network security NET MIC 32 field is located at the end of the frame before the DLL MIC 32 field and the IEEE 802.15.4 FCS field see . When the Network Security header is present the receiver s SM application layer security process uses the Originator PAN ID and source address field of the received frame to determine if the frame is from the Coordinator or some other device. The Node Keys stored in the Node Key Table are used for communicating with the Coordinator. The Mesh Keys in the Neighborhood Table are used to communicate with other devices. For frames received from the Coordinator bit of the Network Security Header specifies the network Key ID selecting Node Key 0 or Node Key 1. For frames received from other devices the bit selects Mesh Key 0 or Mesh Key 1.

Routed messages are typically request response messages. The response messages reflect the value of the Network Count in the request. Messages that require reflected counts are listed in Table 3.

The SM network layer nonce is 13 octets long. Its structure is shown in . When the message is a request the combination of the Network Count the Originator PAN ID and Address padded with zeros ensures the uniqueness of the nonce. When the message is a response the Network Count is reflected and it is combined with the Target PAN ID and address and the Originator PAN ID and address. Devices receiving request messages use the Network Count to verify the integrity of the payload data and optionally check for repeated count values to reject already received responses. Devices receiving responses to request messages check that the Network Count equals that in the request message. If it does not the message is rejected. Response frames with repeated Network Count values also are rejected.

The SM Network MIC 32 is authenticated using the following algorithm. First the 39 bits of the Network Count is taken from the Network Security Header and padded with a zero to make a 40 bit field. This forms the counter portion of the network nonce. Next the MIC 32 is calculated using the key specified by the Network Security header Key ID using the Node Key for communications with the Coordinator and the Mesh Key for communications with other devices.

If the calculated MIC 32 equals the transmitted MIC 32 then the data integrity of the received frame is validated. The coverage of the Network Security header MIC is shown in . The Network MIC 32 provides authentication for almost all the SM frame s header field and payload. The portion of the SM frame s header field that is not covered by the Network MIC is the Max Remaining Hops field which is decremented for each hop. Keep Alive Request messages have a second exception to the Network MIC 32 coverage their Hop Addresses and Number of Hops fields. As with the DLL having two key in each of the Mesh Key Table and Node Key Table entries allows the Coordinator to set up new keys for devices without causing Network Security header MIC errors.

The SM network security process used for transmitting a message with a Network Security header is shown in . Node A prepares a request message for transmission by incrementing its source transmission counter and calculating the Network MIC. It then formats the request frame with the full five octet source transmission count in the Network Security header and transmits the message through Node B to Node C. Node A stores the count used and starts a message response timer with a timeout set to MESSAGE RESPONSE TO. Node C receives the request message and authenticates the Network Security header. Node C prepares a response to Node A using the same count value it received in the request. Node A receives the response and checks that the count value is the same as what it transmitted. Node A releases the stored count and stops the message response timer if the stored count is the same as the response count and the Network Security header is authenticated. If the tests fail and no other valid response frame is received in the timeout period Node A fails the request response process and releases the stored count value. Messages transmitted between the Coordinator and a device that employ the Network Security header use the Node Key assigned to the device. Messages transmitted between devices that have a Network Security header use the Mesh Key.

New devices associating with a network must be configured with the Node Key and Maintenance Key. This configuration may be done by the manufacture as a custom process for a purchaser by a maintenance tool prior to association or over the network using the Service messages described further herein. Keys transported over the network must be encrypted for confidentiality. When sent in Service Response and Service Forwarding messages the keys are generated by the Configuration Host and encrypted using the device s Device Key before being placed in the message payload. The Coordinator and the routing devices forward the encrypted keys without knowing the Device Key so they are unable to eavesdrop on the value of the new key. This configuration process is between the device s application and the Configuration Host application. It is not part of the overall mesh protocol. An outline of the device application to configuration host application configuration process is presented here for informational purposes. The new device uses a Service Request message to talk to the Configuration Host. The outgoing Service Request message contains a Service MIC in the payload that is calculated using the manufacturer supplied Device Key. This Service MIC is not the DLL or Network MIC. The routing device forwards the payload in a Service Forwarding message and the Coordinator sends the message to the Configuration Host. The routing device and the Coordinator do not have the Device Key and so they do not decode the MIC. The Configuration Host uses a well known Server ID 0 in the Service Request message. The Configuration Host looks up the 8 octet device MAC address and finds the Device Key in its database. If the MIC is OK it authenticates the new device. The Configuration Host sends a message to all Coordinators in the network that sets up a unique Node Key associated with the 8 octet device MAC address. This is a symmetric secret key that will be used for all secure communications between the Coordinators and the new device. In preferred embodiments Node Key 0 and Node Key 1 are set to the same value to avoid key synchronization problems as the system starts. This same value practice holds for the Maintenance Key 0 and Maintenance Key 1 values as well. After sending the Node key to the Coordinators the Configuration Host sends a response to the new device using a Service Forwarding Response or Service Response message where the message payload contains the unique Node Key and the shared Maintenance Key both encrypted by the new Node s Device Key. This response is sent back to the new device. The new device decrypts the Node Key and the shared Maintenance Key and stores them under the appropriate Key ID.

A device that is newly introduced to a SM network has only a single cryptographic key its factory assigned permanent Device key which is unique to the device. Before the device can participate in the SM network the device must be commissioned with the network s Maintenance and Mesh keys together with a device unique Node key and a second system assigned device unique Device key. This commissioning may be made over the network itself by direct wireless messaging to the device from a proximate commissioning device or through some extra protocol means such as a direct connection to the device.

The Maintenance Mesh and Node keys are used to authenticate messaging within the SM. Node keys are used to authenticate and encrypt end to end network management messaging within the SM. The permanent Device key is used only to authenticate the newly introduced device to the SM network and to protect the system assigned Device key when it is sent in response to the newly introduced Node. The system assigned Device key is then used to protect the device s Node key and the shared Maintenance key when they are distributed to the Node. In subsequent messages the device s Node key is used to protect the Mesh key whenever it is distributed to the Node. Receipt of a message that authenticates under the permanent Device key zeroizes all other keys setting them to a keyNotDefined status which restores a device s key state to that when it left the factory. This action protects the network against an attacker that has compromised the device s permanent Device key perhaps by gaining access to the database of all permanent Device keys that exist at key repository or to the subset database of Device keys of purchased devices that was delivered to the system owner.

A secure association between a device and a Coordinator uses the Association Request and Association Response messages that employ the DLL MIC and Network MIC. The associating device uses the Maintenance Key Ticket count value for the DLL MIC and the Node Key and Originator count value for the Network MIC. The routing forwards the Association Request payload to the Coordinator in the Association Confirmation Request message. The payload also includes the 8 octet MAC address of the new device. This forwarding process is shown in . The Coordinator validates the Association Confirmation Request message DLL Security header and Network Security header. It then validates the embedded Network Security header constructed by the new device using the new device s Node ID and the Originator count in the Network Security header. The Coordinator looks up the Node ID using the 8 octet address in the Association Confirmation Request message in a data base that has been configured by a process outside the scope of the mesh protocol. For valid association requests the Coordinator constructs an Association Confirmation Response message. The message payload has the assigned short address of the new device the Mesh Key Security Header the Encrypted Mesh Key and the Mesh Key MIC32. The Mesh Key is encrypted using the new device s Node Key version as specified in the Mesh Key Security Header. The Coordinator constructs a Network Security header and that calculates the Network MIC using the Coordinator s reflected count in the new device s Network Security header and the new device s Node Key. This Network Header is carried as the payload of the Association Confirmation Response message shown in .

The Mesh Key Security Header follows the same format as the 40 bit Network Security control word shown in with the Reflected Count Flag set to 0. The routing device that forwards the association response to the new device takes the payload of the Association Confirmation Response message and generates the Association Response message using the Maintenance Key and the router s Source count value to calculate the DLL MIC. The new device decrypts the Mesh Key using the Node Key with the Key ID specified in the Encrypted Key Security Header it then verifies the Mesh Key MIC32 and stores the Mesh Key. Devices that change the primary Coordinator with which they are associated follow the same procedure as new devices. They use the same Association and Association Confirmation messages and the same Node Key and Maintenance Key.

Preferred embodiments of the present invention institute key rotation practices changing the security keys periodically or when a security event has occurred. The mesh keys used by a device are the Node Key the Maintenance Key and the Mesh Key. The Coordinator changes these keys using the Keep Alive process and messages.

Each device maintains two versions of each of these keys Node Key 0 Node Key 1 Maintenance Key 0 Maintenance Key 1 Mesh Key 0 and Mesh Key 1. Each message sent has Key IDs in the DLL Security header and Network Security header that indicate which key is being used. In between key changes all the devices use only one version of each key for transmission and reception. The Coordinator writes the new key to the appropriate key and key version of each device. When the update process is finished and verified at most or all relevant devices the Coordinator signals the devices to start using the new key for transmission. After all the devices are using the new key for transmission the Coordinator deactivates the old key for reception.

The Coordinator starts an update of a key by getting the current state of the current Write Key Toggle Bit associated with the key. It does this by waiting for a Keep Alive Request message from a device with the key as shown in . The Keep Alive Request message from the device contains the Write Key Toggle State field that tells it current status of the toggle bits for each key. The Coordinator then sends the key update using the Write Key parameter option in the Keep Alive Response message. The Coordinator verifies that the key has been updated by reading the change in state of the selected key s Write Key Toggle Bit in the next Keep Alive Request. The process is repeated if the key has not been changed.

Eventually all or almost all the devices have both the new key and the old key. Only the old key is used for transmission but either the new key or the old key can be used for reception. The reception key selection is controlled by the DLL Security Header and the Network Security Header.

After all devices using the key have been updated and verified the Coordinator tells the devices to start using the new key for transmission. The Coordinator waits for a Keep Alive Request message from a node using the new key as shown is . In the Keep Alive Response message the Coordinator commands the node to switch to the new key for transmission. The switch is confirmed in the next Keep Alive Request message received from the device. After all the devices using the new key have switched the Coordinator deactivates the old key by waiting for a Keep Alive Request and then sending a Keep Alive Response containing the appropriate key deactivate command. The Coordinator verifies the deactivation in the next Keep Alive Request received from the device. This process is used to update Node Keys Maintenance Keys and Mesh Keys. The Process for changing a generic Key x version 0 is depicted in . Note that only the Coordinator is allowed to originate a Keep Alive Response message with key control commands in it.

An End Device s association to the network is similar to that of a regular Node see Association . The only difference is that after the End Device has selected a Coordinator it usually also needs to choose a Router to help with message forwarding. shows a new End Device Node A requesting neighbor information and receiving. In this example there are two PANs and three neighbors. Based on the Association Ratio algorithm Node A selects the Coordinator on PAN 1. It also selects Node B as its Parent using the Parent Selection algorithm. Node A then sends Node B an Association Request message which Node B converts to an Association Confirmation Request message addressed to the Coordinator. The Coordinator sends the Association Confirmation Response message back to Node B. Node B then sends the Association Response message to Node A. Node B adds Node A to its End Device Table after receiving a Keep Alive Request message from Node A with the Device Type set to End Device type and the Receiver On When Idle bit reset to off . This first Keep Alive Request message also carries the Multicast Group Addresses list which is captured by Node B for future filtering and forwarding of Multicast messages. The Coordinator receives the Keep Alive Request message. A Parent can remove a Node form its End Device Table if it has not received any Keep Alive Request messages from this Node for a period exceeding 24 hours.

When an End Device loses connectivity with its Parent i.e. after a number of unsuccessful attempts to communicate determined by the ROUTE LOST ATTEMPTS parameter it tries to find another Router on the same network. The End Device sends a Neighbor Info Request on the current channel and uses the Parent Selection algorithm to choose its new Parent. Then it sends a Keep Alive Request to inform both the Parent and the Coordinator of this change. The processes of re associating with the Coordinator and a new neighbor are shown in . The End Device Node A fails to communicate through Node B and after a number ROUTE LOST ATTEMPTS of attempts it broadcasts a Neighbor Info Request to Nodes on the same channel and PAN. It then selects the best neighbor with which to associate. In this case Node E is selected. It then sends a Keep Alive Request message to the Coordinator though Node E. The Coordinator returns a Keep Alive Response message.

Message forwarding with a non sleeping End Device is done as soon as received. Referring to a Non sleeping End Device advertises its presence to its Parent and to the Coordinator in both the Association Request and the Keep Alive Request messages. In both of these messages the Device Type field is set to End Device type and the Receiver On When Idle is set.

In the case of transmission by the Sleeping End Device the Parent allows the End Device to return to sleep as soon as the transmission acknowledgment 802.15.4 ACK MAC PDU for the message is received. All frames sent to a Sleeping End Device unicast multicast and broadcast are buffered by its Parent and transmitted to it when it is awake. If a response is expected a Sleeping End Device wakes up every RESP SLEEP PERIOD until the expected response is received. If no response is expected the Sleeping End Device sleeps for the interval SLEEP CHECK PERIOD. The Sleeping End Device wakes up periodically at each SLEEP CHECK PERIOD to check for buffered frames. It also wakes up when it has a message to transmit. When it wakes up with a message to transmit it first checks for buffered frames before it transmits its own message.

The Sleeping End Device frame forwarding process is illustrated in . The sleeping Node A wake ups and checks for any frames buffered in Node B by sending an End Device Data Request message. Node B replies with an End Device Response message with the no Frame Pending status that tells Node A there are no frames buffered. Node A then transmits a frame that does not require a response to a target application through its Parent Node B. Node A waits for an ACK MAC PDU from Node B and then goes to sleep for SLEEP CHECK PERIOD. This sleep is interrupted when Node A wakes up to transmit another frame. The new frame is a request that requires a response from the target. The request frame is routed to the target by Node B. When Node A receives the MAC level ACK from Node B it restarts its sleep timer with a duration set to the value of RESP SLEEP PERIOD. Node B forwards the request frame to the target application that then generates a response frame. Node B receives and buffers the response frame for Node A which is sleeping. Node A wakes at the end of the time period and sends Node B an End Device Data Request message and receives an End Device Response message with the Frame Pending bit set. Node A waits for the stored frame for a maximum duration of MAX MF WAIT. If it does not receive a frame during this time interval it resends the End Device Data Request message. In Node B sends the response frame in its buffer to Node A before the MAX MF WAIT PERIOD. Node A sends Node B an ACK MAC PDU and goes back to sleep with the timer duration set to the value of SLEEP CHECK PERIOD. Node B releases the buffer when it receives the ACK MAC PDU from Node A.

Sleeping End Device wakeups periodically to verify a message is pending. Each SLEEP CHECK PERIOD the Sleeping End Device sends an End Device Data Request frame to its Parent and waits a predefined time DATA REQUEST. TIMEOUT listening for pending frames before returning to sleep. show the Sleeping End Device Checkpoint process. In a message is received for Sleeping End Device Node A and buffered by the Parent Node B. Node A wakes when its Checkpoint timer expires. It sends an End Device Data Request message to Node B and receives an End Device Data Response message with the frame pending bit set. Node A then starts its listen timer with a duration of DATA REQUEST TIMEOUT and listens for a frame from Node B. Node B sends the buffered frame to Node A which stops the listen timer. The frame does not have the frame pending bit set which tells Node A that there are no more frames to receive. Node A sets the Checkpoint timer with the duration CHECKPOINT PERIOD and goes back to sleep. Node B releases the buffer when it receives the ACK MAC PDU frame from Node A.

In Node A wakes up when its Checkpoint timer expires. In this case Node B has no frame stored for Node A so when Node A sends the End Device Data Request message Node B s replying End Device Data Response message does not have the frame pending bit set. Node A sets its Checkpoint timer with the CHECKPOINT PERIOD and goes back to sleep.

This process exemplified in is used to initiate a point to point communication with a Sleeping End Device. Typical applications for this type of communication are between a handheld device and a sleeping End Device and occur during installation operation and maintenance processes. A physical trigger button reed switch magnet initiates Local Communication. This sets the Sleeping End Device in local communication mode. The Sleeping End Device then sends an End Device Node Present message with a periodicity of END DEVICE PERIOD and listens for the interval END DEVICE WAIT for any command sent in response. This process stops and the Sleeping End Device goes to sleep if it has not communicated with a local device in the interval determined by the END DEVICE INACTIVITY TO parameter. Once a communication is initiated with a local device the Sleeping End Device stays in the local communication mode for the time interval determined by the END DEVICE INACTIVE TO parameter after each frame is received or transmitted.

In a Sleeping End Device Node A receives an external trigger that puts it in a mode where it looks for a local device with which to communicate. It transmits an End Device Node Present frame and starts two timers. The first timer is the end device notification timer END DEVICE PERIOD which determines how long the Sleeping End Device listens for a response to the notification message. The second timer is the end device notification process timer. It determines how long the Sleeping End Device remains in the state where it is looking for a local device. In . Node A sends one End Device Node Present message that is not heard by the local device. After the end device notification timer expires it sends a second End Device Node Present message that triggers a second response by the local device. The ACK MAC PDU from the local device terminates the two timers and puts Node A in the local communication mode. In this mode Node A starts the end device communication timer that is set with a duration specified by the LOCAL COM TO parameter. During the first timer period the local device sends Node A a frame that resets the timer. During the second timer period Node A initiates a frame of its own to the local device. This transmitted frame also resets the timer. There is no communication during the third period other than the ACK MAC PDU from the local device. The ACK MAC PDU does not reset the timer which then expires causing Node A to exit from the local communication mode.

The concept of Dedicated Routers allows the deployment of multiple Coordinators at the same physical location. This approach consists of deploying multiple Routers possibly with directional antennae where each Router is dedicated to a specific mesh network Coordinator. A Dedicated Router has the following specific behavior a Dedicated Router is associated to a specific Network Name and is manually configured with this name and a Dedicated Router can associate only to the Coordinator or another Dedicated Router it is not allowed to associate with a normal non dedicated Router. This restriction is imposed to avoid the situation where a Dedicated Router works for some time until its environment changes in such a way that it is no longer capable of establishing a route to its Coordinator. For the computation of the association ratio a Dedicated Router is seen as a no hop distant device similar to a Coordinator. This guarantees that surrounding devices will prefer the Dedicated Router over other Routers for their association. Dedicated Router sets the Dedicated Router Flag in the Neighbor Info Response message. Nodes receiving Neighbor Info Response message with the Dedicated Router Flag set shall consider it to be as a no hop distant device when computing its Association Ratio.

The following mechanisms are provided to control the flow of messages on the network and to provide some control on message latency. Most traffic is either sent from or to the Coordinator. Message latency is directly affected by the way the Coordinator manages this traffic. Internally the Coordinator orders messages based on the importance of the associated task and the notion of priority implemented by the application layer. In the case of the ANSI C12.22 application layer this notion of priority takes the form of the URGENT flag carried in the Calling AE Qualifier element. To control traffic flow in the reverse direction the protocol allows the Coordinator to control the timing of the Checkpoint process at each Node. To do this the Coordinator sends a Keep Alive Initiate message to each Node before the end of that node s CHECKPOINT PERIOD. Frames routed within the mesh network have an Urgent flag which when set permits the Router to reorder outbound frames when there are other frames of lesser priority in the transmit queue. Nodes are not permitted to use the entire network capacity for any extended period of time. In the network protocol this throttling is provided by a single frame transmission window with an end to end acknowledgment.

A mesh forwarding process is required for support services that are used before a Node has associated with a network. This forwarding process allows the unassociated Node to communicate with service hosts such as commissioning or location tracking hosts on a LAN or WAN segment. The commissioning process is implemented by the application. The secure mesh protocol does not determine how commissioning is done but it does support over the network commissioning using the Service and Service Forwarding messages. When used these messages convey the Node Key and Maintenance Key that will be used by the device so that it is able to run the Association processes. Alternatively the device could be commissioned with these keys during manufacturing.

The forwarding process is illustrated in . The requesting device issues a Neighbor Info Request frame and listens for Neighbor Info Response frames. This is the same process used when the device associates with the network. The neighbor information process is shown in . The device uses the Association Algorithm to pick the neighbor to use as a proxy for service message forwarding. The requesting device Node A places the service message in a Service Request frame addressed to the selected neighbor Node B. The Service Request frame identifies the service the message is to go to in the mesh header in the Server field. The Service Request frame is then transmitted to Node B. Node A starts a halt service request timer when the MAC ACK is received from Node B. This timer is set with the parameter SERVICE PERIOD that prevents Node A from sending more service frames until the timer has expired.

Node B recognizes the Service Request frame from its service type and service code fields. It processes the frame by assigning the forwarding process for Node A a Requestor id value and sending the contained information to the Coordinator in a Service Forwarding frame. Node B starts a halt service request RX timer when it successfully transmits the Service Forwarding frame. The timer is set with the SERVICE PERIOD parameter. While the timer is active Node B does not accept additional Service Request frames from any Node including from Node A.

The SERVICE PERIOD timeout set by both Node A and Node B is cancelled as soon the service host accepts servicing the request as indicated by an appropriate service reply. The SERVICE PERIOD timeout is reestablished for each new Service Request frame that is sent.

The Coordinator receives the Service Forwarding frame from Node B. It registers the Requestor ID value and Node B s address. The Coordinator sends the service message contained in the Service Forwarding frame to the service host identified in the Server Requested field. When the service host responds the Coordinator puts the service message in a Service Forwarding Reply frame and addresses it to Node B. The Coordinator also fills in the Requestor id value for Node A. The Coordinator sets a Service keep alive timer that will release the forwarding process if it is inactive for the duration SERVICE TO. Releasing the forwarding process for Node A removes the Node A s Requestor id from memory.

Node B receives the Service Forwarding frame from the Coordinator and looks up the Requestor id to identify Node A as the destination. The receipt of the Service Forwarding frame sets Node B s Service keep alive timer for the duration SERVICE . . . TO. If the timer expires before another Service Forwarding frame is received for Node A the Node A Requestor id is released. Node B constructs the Service Requestor response frame and sends it to Node A.

Node A receives the Service Requestor response frame and extracts the host s service message. The receipt of the Service Requestor response frame sets Node A s Service keep alive timer for the duration SERVICE TO. If Node A does not receive another host message in this time it times out the service request process. If later there is another message generated to a host the service request process is restarted from the beginning with a new Neighbor Info Request frame.

Every Node in the mesh network can notify the Coordinator rapidly after it loses power or when the power is restored. The performance goal for the process is to have most Nodes notify the Coordinator within one minute after their status changes. Those Nodes that take longer should not exceed the three minutes of backup power provided by the Nodes implementing the Power Outage Routing option as advertised by the Neighbors Exchange service. The system load induced by this process is a critical consideration because every Node may need to communicate in a very short time. Power event report aggregation and low overhead tree routing are employed to reduce the amount of system communication capacity used for this reporting.

Any Node that has a power event that passes this transient suppression test goes into the PO AGGREGATE PERIOD round. The leaf Nodes Nodes without any Children in their Neighborhood Table and first hop Nodes report their event in this round. To distribute these transmissions more uniformly each reporting Node transmits at a pseudo randomly chosen time within the interval whose duration is PO AGGREGATE PERIOD. Nodes receiving events during this interval aggregate these events for later transmission. At the end of the PO AGGREGATE PERIOD round Nodes enter the PO RND PERIOD round. Event Nodes that have event reports to send schedule transmission at a pseudo randomly chosen time within this interval. During this interval non aggregating Nodes are free to piggyback their event report to any of the Power Event Report frames that they may route however aggregating Nodes must initiate their own Power Event Report frame since the eventual acknowledgment they receive for the forwarded aggregated event reports needs to be broadcast to the aggregator s neighbor Nodes.

The Coordinator receives power event reports and sends acknowledgements. These event acknowledgements follow a source route constructed from the entries in the Power Event Report. Because of this the acknowledgement message follows the reverse route of the report and confirms the reception to each Node reporting an event. When the target Node is not the last Nodes in the reporting list within the Power Event Report the target address is set to the broadcast address 0xFFFF . The broadcast address allows leaf Nodes to be acknowledged using a broadcast at the end of the source route path. Reporting Nodes that do not receive an acknowledgement from the Coordinator at the end of the PO RND PERIOD round enter into a PO RETRY RND PERIOD round.

Each such Node schedules a transmission time pseudo randomly within the following interval of duration PO RETRY RND PERIOD. This round is repeated until the event report is acknowledged or the backup power is exhausted. Nodes acknowledged prior to a scheduled power event reporting transmission do not initiate that transmission even if they had entered into the retry round. Nodes reporting a power event do not initiate any Data Transfer messaging of their own while they are in any of the power event reporting rounds. All event Nodes continue to route the messages they receive.

At the end of the delay if Node A was not able to piggyback its event it initiates its own Power Event Report frame including any additional aggregated events.

After sending or piggybacking its event report Node A expects an acknowledgment from the Coordinator. In Node A receives this acknowledgement and so it does not enter into a retry state at the end of the current round. Even though Node A does not go into a retry round it continues to route messages until its backup power is exhausted.

At the end of the round Node A goes into a retry round. The retry round lasts for the time determined by the PO RETRY RND PERIOD parameter. Node A selects its retry transmit time pseudo randomly within the period and resends a power event report containing its address. Node A does not have to originate a retry frame if it has an opportunity to add its event report to a routed Power Event Report frame while in the retry round.

An example of power event reporting for a Node that is one hop from the Coordinator is shown in . Node B is a neighbor of the Coordinator. One hop Nodes can transmit their reports to the Coordinator in the PO AGGREGATE PERIOD round. Node B transmits the power event report after a pseudo randomly chosen delay and receives an acknowledgement. If the acknowledgement were not received the Node would retransmit the event report in the following PO RND PERIOD round.

Leaf Nodes transmit their reports during the PO AGGREGATE PERIOD round. shows a typical leaf Node power event reporting process. A Leaf Node Node C chooses a pseudo random time within the interval of duration PO AGGRETATE PERIOD to transmit its power event report. The acknowledgement for this report may not be received until near the end of the interval of duration PO RND PERIOD. In this case Node C receives the acknowledgement and its power event reporting process is completed. If an acknowledgement is not received Node C enters an interval of duration PO RETRY RND PERIOD and retransmits the event report. This continues until Node C runs out of backup power or an acknowledgement is received.

Tree routing is normally used to send power outage restoration event notification frames. Mesh routing may also be used as an alternate method if the Node has been waiting to send its event for more than the time set by the parameter POWER REPORT WAIT.

Power restoration reporting uses the same process and messaging as power outage reporting except that the parameters PO RND PERIOD and PO RETRY RND PERIOD are replaced by the parameters PR RND PERIOD and PR RETRY RND PERIOD. For Nodes that are members of overlapping networks power outage and power restoration notifications may be done to any of the registered networks. Different Coordinators are selected in round robin fashion at each attempt of reporting a notification. Attempts to send power restoration notifications are repeated up to the duration RESTORATION TIMEOUT. Nodes that are not members of overlapping networks initiate an Association process after waiting an interval whose duration is RESTORATION TIMEOUT. After a successful Association the associating Nodes do not need to send Power Event Report messages since the Association process itself sets the Coordinator s state for the Node to Alive. 

A mesh multicast service is used to send application level information to a group of Nodes that share the same group address. A group address is a 2 octet short address within the range 0x3000 to 0x3FFF. Group addresses are well known or configured with well known addresses assigned from address 0x3FFF and decreasing while configured addresses are assigned from address 0x3000 and increasing. The mesh layer does not provide services to configure group addresses such assignment needs to be made by the application layer from a centralized location such as the Coordinator.

A Mesh multicast service consists of a local broadcast by the originator of the multicast message. Each Router receiving this message verifies that the message has been received from an authenticated Node listed in its Neighborhood table and that the message Originator address and Request ID do not match those of a previously processed message. The Router then verifies that the Target Address matches one of its own group addresses. If a match is found the message is propagated to the Router s upper layers for processing. The Router also determines whether the Target Address matches a group address of its child End Devices. If so the message is sent to each child End Device having a matching group address. A copy of the message is saved for each Sleeping End Device with a matching group address.

Child group addresses are acquired by a Parent Router by inspecting the first Keep Alive Request message sent by each child End Device after the End Device chooses or changes its primary parent. Routers do not forward group addressed frames to End Devices for which they are not primary parents.

Multicast Data Transfer frames with a Max Remaining Hops field greater than one are re broadcast. To re broadcast a message the Router first decrements the Max Remaining Hops field and broadcasts the resulting message to its own neighbors. Duplicate multicast messages are ignored based on the messages Originator address and Request ID as specified previously.

The Max Remaining Hops field can be used to limit the region for which a multicast is sent. To target all Nodes within the network a Coordinator should set the Max Remaining Hops field to the value MAX HOPS. To achieve the same result for frames from a different source a non Coordinator Node should set the Max Remaining Hops field to twice the value MAX HOPS. All SM nodes in a group have the well known group address shown in Table 5.

A simple example of the mesh multicast process is shown in . Node X initiated the multicast data transfer which progressed through the mesh network until it reached Node A and Node B where Node A is a neighbor of Node B and Node C and Node C is a neighbor of Node D but Node B is not a neighbor of Node C. Node A receives the Multicast Data Transfer frame and checks the Originator Address and Request ID. Because it appears to be a previously unreceived multicast frame and the value of the Max Remaining Hops field is greater than one Node A forwards the frame after decrementing the value of the Max Remaining Hops field. The forwarded frame goes to Node B and Node C. Both Node B and Node C also forward the frame to their neighbors. The frame forwarded by Node C goes to Node D where it is not re forwarded because the value of the Max Remaining Hops field in the received frame equals one. At a later time Node B receives the multicast frame via another route. This duplicate frame carries the same Originator Address and Request ID as the prior frame so it is discarded and not forwarded.

The local communication process is used to initiate point to point communication between two Nodes that may not already be part of the same mesh network. Typical applications that use this type of communication are installation operation and maintenance activities and walk by reading of Nodes using a handheld reader. Local communications use the Node s long 8 octet IEEE EUI 64 address rather than its short 2 octet address. In the cases of walk by communication with targeted devices that are not sleeping the handheld device issues the Local Broadcast Request frame to initiate local communication. From the responses to this local broadcast the handheld device can build a table of local devices that are awake where each table entry includes the following information about the responding Node long and short addresses 

PAN IDs Device Class information and optionally Network Name security flag VERSION OWNER and BAR CODE ID.

From this resulting acquired table of device information the user can select the device with which to communicate. There are two local communication options 1 local data transfers that use the application level services using Local Data Transfer frames and 2 RF link measurements using the Range Test Request and Range Test Response frames.

The Range Test process uses the local communication Range Test Request and Range Test Response frames. The Range Test Request command frame is used to check whether Node is reachable in the local communication mode. The Range Test Response frame reports the signal strength as recorded by the responder in the forward direction. The signal strength of the response is measured by the range test originator to determine signal strength in the return direction. The Range Test Initiate and Range Initiate Result frames can be used to request one Node to perform a range test with a different Node and to report the test results to the requester. A typical example of this function is for a handheld test tool to request a Router to do a range test with an End Device.

The FRR test is used to evaluate the one way link quality between a sender and a receiver. Theses two Nodes need to be able to reach each other directly. The sender sends a configurable number of frames in local communications mode to the receiver. At the end of the test the receiver sends a result frame to the sender. This frame contains the FRR and the average LQI for received frames. A frame reception rate session consists of the transmission of the Frame Reception Rate Test Init message multiple transmission of the Frame Reception Rate rest Data messages the transmission of the Frame Reception Rate Test End message and the reception of the Frame Reception Rate Test Result message.

With the exception of the Frame Reception Rate Test Data messages Frame Reception Rate Test control messages are transmitted with MAC layer acknowledgment and retry. In the case of a MAC layer transmission failure such control messages are re transmitted up to a maximum of FRR TEST RETRY times.

An example of the frame reception rate test process is shown in . A handheld initiates the test in this example by sending the Frame Reception Rate Test Init message to Node A. The test is set to send N test frames without acknowledgements. The handheld starts sending the first of the N test frames to Node A after it receives the ACK from Node A for the test initializing message. The Frame Reception Rate Test End message is sent after the N test frames. The test end message is acknowledged by Node which then sends the Frame Reception Rate Test Result v to the testing handheld.

The ping command is used to check whether a Node is reachable through the mesh network and to determine and trace the routes used for each direction of communication. The Ping frame tests the ability of a device to reach a Node that is more than one hop distant since testing of the first hop is provided by Range Test commands. A Ping Request can be used by a Coordinator to determine whether a device that is awake is reachable in the intervals between Keep Alive Requests. The Ping Request frame can be used with any type of routing. As the frame traverses each Node the RSSI and LQI values measured during frame reception are noted. Both values are added to the frame before it is forwarded. The addressed receiving device processes the Ping Request frame converts it to a Ping Response frame and sends that response back to the originating device. The RSSI and LQI values measured during frame reception on the return path are appended to those accumulated as the Ping Request frame traversed its forward path.

In Node A initiates a Ping Request message targeting Node C. The frame within the Ping Request message is routed through Node B. Node B updates the frame data by incrementing the hop count and appending its 2 octet address the measured RSSI and the observed LQI to the Ping Request frame s accumulated data before forwarding the frame to Node C. Node C converts the received Ping Request frame to a Ping Response frame and sends it to Node A. When the Ping Response frame arrives at Node A it contains the path traversed by the request and response frames and the measured RSSI and observed LQI values noted at each hop.

The SM frame structure is presented so that the leftmost or first described field is transmitted or received first. Except for octet arrays all multi octet fields are transmitted or received least significant octet first. To maintain compatibility with the IEEE 802 standards addresses and PAN identifiers are considered octet arrays and are transmitted unaltered which is equivalent to transmitting them most significant octet first when viewed as multi octet fields.

Each frame described in this document includes MAC layer fields which are documented within the mesh layer to provide the context on which the mesh layer operates. The MAC and mesh layers are tightly coupled so that information required by the mesh layer that is already present at the MAC layer is not duplicated. Descriptions of the MAC layer fields are provided in this subsection so that they need not be duplicated in the description of each mesh layer frame format. More information on these fields can be found in the IEEE 802.15.4 2006 standard which is the controlling specification for the MAC protocol and is incorporated herein by reference in its entirety.

Bits to of the first octet of the Mesh header are called the Service type. This field defines the structure of the next of the mesh header and the general behavior of a group of messages. With the exception of the Data Transfer frame the subsequent header prefix contains a field called Service Code which defines the specific message format for the last of the mesh header. Table 7 enumerates all defined combinations of Service Type and Service Code.

This message frame format shown in is used to transport upper layers information for all requests and responses.

The mesh multicast message format set forth in facilitates multicast of application data to a group of Nodes within a mesh network. Group addresses need either to be pre assigned or assigned by an upper layer. This layer does not provide services to remotely assign group address to Nodes.

The route request message is used to create a route to a target Node for peer to peer communication between two Nodes using mesh routing. The route request message format is shown in .

The route error message is sent out to inform surrounding Nodes that a route to a destination has fail and need to be invalidated. This message is sent as a broadcast frame with Hop Count set to 1. Each Node receiving this message re broadcast the Route Error if its route table shows that other Nodes use this Node as a route to the destination and must therefore be informed of the invalid route. The route error message format is shown in .

All messages described within this subsection share the same MAC header and Mesh header prefix format. This common portion of the message is shown in .

The association confirmation request message is sent to the Coordinator by a Router when an Association Request is received from a Node requesting an association. The association request message format is shown in .

The association confirmation response message is returned by the Coordinator to a Router in response to an Association Confirmation Request. The association confirmation response message format is shown in .

The Keep Alive Initiate message is sent by the Coordinator to request that a Node initiate immediately its Keep Alive Request. This message is optional and used by the Coordinator to control the flow and distribution of Checkpoint messages. Independently of this optional message Nodes autonomously initiate their Checkpoint process by sending a Keep Alive Request after each CHECKPOINT PERIOD. To control the flow of messages the Coordinator must send a Keep Alive Initiate prior to the expiration of this period. WARNING This request is sent using source routing Routers routing this message shall not create a temporary route. This allows the following Keep Alive Request to trace current tree route from this Node. The Keep Alive Initiate message format is shown in .

The Keep Alive Request message is sent periodically to the Coordinator to maintain the Node association. The Keep Alive Request frame format is shown is .

The following describes the different extensions to this basic frame format. Transmission of these extensions follows these rules which are listed in order of priority 

This extension is not authenticated by the Network MIC 32 since the Number of Hops value is incremented and a PAN identifier and short address is appended at each hop.

The Keep Alive Response message is sent by the Coordinator in response to a Keep Alive Request. The Keep Alive Response frame format is shown in .

Operations on the Mesh Key are associated with the Mesh Key Table entry for the Coordinator sending the Keep Alive Response message. The Write Switch Deactivate Key parameter list member may be occurring multiple times in a message.

The Route Establishment Request message is used by a Node to request from the Coordinator a route to a target Node for peer to peer communication using source routing. The Route Establishment Request message frame format is shown in .

The Route Establishment Response message format shown in is sent by the Coordinator in response to a Route Establishment Request.

The Power Event Report message is sent by Nodes to notify of a power outage or power restoration condition and the frame format is shown in .

The ping message is used to test mesh communication during quality assessment QA or when the network is deployed. The ping message frame format is shown in .

The Service Forwarding message is used by the Router servicing a Service Request to send service messages to and from the Coordinator. The Service Forwarding message frame format is shown in .

The Association Request message is sent by a Node to Router in its neighborhood to request an association to the identified mesh network. The Association Request message frame format is shown in .

An Association Response message is returned by a Router to a Node in response to an Association Request. An Association Response message frame format is shown in .

The Neighbor Info Request message is broadcast to get information about neighbor Routers. The frame format shown in is used when the originator of the message is not a network member. The frame format shown in is used when the originator of the message is a network member.

The Neighbor Info Response message is sent by each neighbor Router when a Neighbor Info Request is broadcast. This message contains the network name and Coordinator load of the responding neighbor the quality of the requesting Node s signal as received by this neighbor and the list tree position of this neighbor on different network trees. The Neighbor Info Response message frame format for an non network originator is shown in . The Neighbor Info Response message frame format for an in network originator is shown in .

The Neighbors Exchange message is broadcast locally by each Node and used to maintain the neighborhood information and to optimize the network tree. The Neighbors Exchange message frame format is shown in .

The End Device Data Request message is used by an End Device to request pending data messages from its Parent. The End Device Data Request message frame format is shown in .

The End Device Data Response message is used in response to an End Device Request to indicate the presence or not of pending data. The End Device Data Response message frame format is shown in .

The Service Request message is used by a device non member of the network to communicate with a specific service such as the commissioning service. The Router used as a proxy is responsible for limiting the flow of messages to provide protection from denial of service attacks. See the Forwarding Service Messages for more detail. The Service Request message frame format is shown in . The Service Request Response frame format is shown in .

The Local Data Transfer message is used to transport upper layers information for a point to point communication. The Local Data Transfer message frame format is shown in .

The Frame Reception Rate Test Init messages are used to compute the Frame Reception Rate. This function is provided mainly in support of radio manufacturing. A test is initiated by sending a Frame Reception Rate Test Init frames follow by one or a multitude of Frame Reception Rate Test Data frames followed by an optional Frame Reception Rate Test End frame. The target Node responds to the Frame Reception Rate Test End frame with a Frame Reception Rate Test Result frame. When a Frame Reception Rate Test Result is not received the originator can retry by sending one or more Frame Reception Rate Test End frames. The Frame Reception Rate Test Init message frame format is shown in .

The Local Broadcast Request message is used to retrieve a list of local devices. The Local Broadcast Request message frame format is shown in .

The Local Broadcast Response message is sent by all Nodes which have received a Local Broadcast Request with matching criteria RSSIs and Payload . The Local Broadcast Response message frame format is shown in .

The End Device Node Present message is sent by a battery operated device e.g. a sleeping device to a wake up device following an impulse such as a magnetic impulse from a wake up device e.g. hand held device. The End Device Node Present message frame format is shown in .

The Range Test Request message is used to record the signal strength RSSI in both directions between two Nodes. The Range Test Request message frame format is shown in .

The Range Test Response command is returned in response to the Range Test Request. The format is shown in .

The Range Test Initiate command is used to request that a Node initiate a Range Test Request to a target Node. The Range Test Initiate command frame format is shown in .

The Range Test Result command is used in response to a request that a Node initiate the Range Test Request to a target Node. The Range Test Result command frame format is shown in .

The 802.15.4 standard states the following about Link Quality Indicator LQI . The LQI measurement is a characterization of the strength and or quality of a received frame. The measurement may be implemented using receiver ED a signal to noise ratio estimation or a combination of these methods. In a preferred embodiment transceivers are used to measure signal strength. The LQI is calculated as follows 

where l is the received signal level in dB above the sensitivity level of the radio on the meter node . The sensitivity is measured for each radio model used in the mesh network. It is defined as the signal level above ambient noise for which a frame reception rate of 99 is obtained. Measurement is done with a wired lab setup with frame lengths of 127 octets.

LQI classes group together links that have similar probability of successful transmission. Various studies on RF propagation mostly targeting cellular market suggest using a fade margin between 20 and 40 dB. Since the meters in the preferred embodiment are fixed and time dependent attenuation is only caused by the movement of external obstacles persons vehicles .

Accordingly a margin of 15 dB should be sufficient to have a reliable link. In other words we consider a link with a signal strength 50 dB above the sensitivity level has about the same chances of success as a link with a signal strength 15 dB above sensitivity. The limit for average links is set at 5 dB above sensitivity. Table 59 summarizes the significance of the LQI classes.

The Association Ratio is calculated by a Node to select which Coordinator to choose. It is a weighted sum of the Number of Hops to the Coordinator from Neighbor Info Response the Coordinator Load from Neighbor Info Response the number of local neighbors from the number of Neighbor Info Responses received for the selected network and the Min LQI Class maximum value from all Neighbor Info Response adjusted for last hop . Table 60 lists the weighting factors.

The Preferred Route Ratio is computed by a Node to select within its Parents the one that represents the optimized path to access the Coordinator. This ratio is calculated based on the neighborhood table information as received within a Neighbor Info Response or a Neighbors Exchange.

End Devices selects a neighboring Router based on the following criteria applied in the order indicated 

The pseudo random delays required by Nodes for this layer are computed based on the following equation pseudoRandomNumber shortAddress 0x7F 0x7F XOR pseudoRandomValue 0x7F pseudoRandomPeriod sec pseudoRandomNumber period 8191 Each time a pseudo random number is generated i i 1 8 

The pseudoRandomValue represents a value within the radio which changes over time such as the Neighbor table checksum or the Number of frames transmitted statistic.

The IEEE 802.15.4 short addresses are assigned sequentially by the coordinator. Six bits of this address are used to partition Nodes into 64 different groups. This number represents bits to of the final pseudo random number. For example if a network has 432 Nodes between 6 and 7 End points will share the same 6 bits. Bit to of the pseudo random number is computed based on the IEEE 802.15.4 long address and a pseudo random value that changes over time.

The pseudo random number generated is a number between 0 and 8191 which needs to be scaled for the appropriate range.

The following tables propose data structure definitions in support of the implementation of the SM layer discussed herein and may be adapted for each specific implementation.

The Mesh Key Tables stores the Mesh Key s used by the device. Each Mesh Key is associated with the PAN ID of the Coordinator it is used with. Mesh Keys are administered by the associated Coordinator.

The Node Key table stores the Node Key s used by the device. The SM network security process uses the Node Key Table to look up the information needed for the Network Security MIC calculation for messages between the Coordinator and devices. The information in the Node Key Table is retained during a power outage and a device reset.

The Maintenance Table stores the information used for Nodes associating with the network and for maintenance devices that access the Nodes using point to point messages. The information in the Maintenance Table is retained during a power outage and a device reset.

The Neighborhood Table data structure is maintained in each radio to keep the information about neighbor Nodes. This data structure is required to implement at least the following processes Association. Tree Routing Route Discovery Neighbors Exchange. Tree Optimization Checkpoint.

When the number of Neighbors exceeds the capacity of the Neighborhood table the goal is to keep in the table 5 best Parents Siblings best routes and all nodes that set the current node as preferred Parent avoid tree instability . We also want to give a chance to new candidates to flag the current Node as preferred Parent. This is done by including them in a round robin fashion among others entry. The radio applies the following logic when it receives a new candidate.

This last clause 3 allows candidates to receive the information needed to choose this node as preferred Parent. If the new candidate has flagged the current node as preferred Parent this last condition is ignored.

Freshness Use The Freshness value is used when the table is full and a new entry is added. The entry with the smallest Freshness value is replaced with the new entry. If more than one entry has a value of zero anyone can be replaced. This case only occurs if the table size is greater than 255 entries.

Every time a mesh frame is forwarded no matter the routing method used at the exception of the Keep Alive Initiate the forwarding Node creates a temporary route entry to the originator in Temporary Route Take. This allows the destination Node to quickly send a reply even if it didn t previously know the route to the originator Node. This route expires after TEMP ROUTE TO.

Security events are provided to the upper layers for diagnostic and auditing purposes. The content of each event is described bellow.

The Source Route table is used to maintain source routes established by the Route Discovery process with the Trace Route flag bit set and through the Route Establishment process.

