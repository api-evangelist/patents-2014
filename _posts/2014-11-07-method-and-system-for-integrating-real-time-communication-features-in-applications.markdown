---

title: Method and system for integrating real time communication features in applications
abstract: A computer has a processor and a memory connected to the processor. The memory stores instructions executed by the processor to receive a real time communication request from a client device and perform an evaluation of the number of client devices associated with the real time communication request. The evaluation results in the coordination of peer-to-peer communications in the event of two client devices and an attempt to host a real time communication session using a first protocol in the event of three or more client devices. A second protocol for the real time communication session is invoked in the event that the attempt to host the real time communication session using the first protocol is unsuccessful.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09083770&OS=09083770&RS=09083770
owner: Snapchat, Inc.
number: 09083770
owner_city: Venice
owner_country: US
publication_date: 20141107
---
This application claims priority to U.S. Provisional Patent Application Ser. No. 61 909 343 filed Nov. 26 2013 and U.S. Provisional Patent Application Ser. No. 61 916 562 filed Dec. 16 2013 the contents of which are incorporated herein by reference.

This invention relates to real time communications in a computer network. More particularly this invention relates to techniques for integrating real time communication features into software applications.

Real time communication tools allow users to communicate in real time. The real time communication can include audio video images etc. The real time communication tools are available as stand alone applications that can be installed on devices or as web browser based applications. However the current real time communication tools do not provide efficient ways to integrate them into existing software applications. Further they lack reliability efficiency and adaptability to network bandwidth features.

A computer has a processor and a memory connected to the processor. The memory stores instructions executed by the processor to receive a real time communication request from a client device and perform an evaluation of the number of client devices associated with the real time communication request. The evaluation results in the coordination of peer to peer communications in the event of two client devices and an attempt to host a real time communication session using a first protocol in the event of three or more client devices. A second protocol for the real time communication session is invoked in the event that the attempt to host the real time communication session using the first protocol is unsuccessful.

Technology is disclosed for integrating real time communication RTC features into software applications the technology . Various embodiments of the technology provide an RTC tool that allows users e.g. application developers to integrate RTC features into software applications. The RTC features support streaming of content including audio video and screen sharing. In some embodiments the RTC tool is generated using Web Real Time Communication WebRTC application programming interfaces APIs . The WebRTC enables browser to browser applications for voice calling video chat and P2P file sharing without plugins. The RTC tool can be integrated in various popular platforms. For example the RTC tool is available as a JavaScript for web applications this can use native WebRTC for browsers supporting it and a native NPAPI ActiveX plug in otherwise as native Java for Android devices as Objective C for iOS devices native C for Mac OS X and Microsoft Windows for desktop applications.

The client software development kit SDK of the RTC tool allows the application to establish a connection to the streaming infrastructure of the tool and create a multimedia session with multiple contributing sources e.g. clients connected to the streaming service and media types. Additionally it is possible to exchange messages between peers connected to the same session or scope using the reliable data channel.

The server side components include a streaming server device having a streaming server that provides the core streaming functionality of the RTC tool . Other components including the Command and Control CnC application and the streamer agent provide a support framework for the core streaming functionality. The RTC tool also includes the database engines such as MySQL 160 Redis 115 and Cassandra 110.

The streaming server hereinafter referred to as streamer is the core component of the RTC collaboration infrastructure. The streamer serves a role of an intelligent multipoint control unit MCU providing services including media streams relaying quality control and signaling.

The streamer is effectively a smart packet relay. It transmits packets between peers connected to the same virtual video conference room referred to as Media Scope scope or session . There can be two use cases for this functionality multiparty conferences and Network Address Translation NAT traversal. Whenever there are more than two participants in the session the data is relayed to ensure that the client sends the data only once. This allows the RTC tool to utilize the most efficient media session topology e.g. the star topology. In case of the one to one sessions with at least one user behind a NAT device using an implementation other than the endpoint independent mapping as per RFC 4787 2 relaying makes the data transmission possible.

The streamer can also be responsible for all the measurements and feedback notifications required to ensure the quality of the session for all the peers participating. This can apply in both directions of media streams from client to the streamer and vice versa. When ensuring the stream quality from peers to the streamer the server side component measures the loss one way packet queuing delay and generates Real time Transport Control Protocol RTCP receiver report as per RFC 3550 feedback messages sent to the clients. The client SDKs use this information to adapt the quality of the sent stream accordingly. The downstream adaptation is done in a similar way. This time the client side performs all the measurements and notifies the streamer using RTCP receiver report RR messages. It then controls which peer should receive high video quality feed and which one a lower video quality feed.

The streamer provides signaling communication required to establish and maintain a media session. It allows each client to know where and how to send the media streams when establishing a media session. The signaling controls also the basic presence by letting all the peers know who is connected to the session and what kind of media streams are published by every participant. Finally it provides reliable data channel functionality.

The streamer runs as an independent process in the streaming server device . In some embodiments it does not require any application container e.g. Tomcat or front end reverse proxy server Ngnix Apache . The streamer can be implemented using various programming languages e.g. C C programming languages etc. and several open source libraries such as boost Google protocol buffers oRTP OpenSSL Google Breakpad Hiredis JSONCPP etc.

The streamer interacts with the client SDKs and the streamer agent . In some embodiments the client SDK streamer communication is done by the signaling and media streaming protocols. In the latter case the streamer uses a local instance of the Redis database server to pass asynchronous events with usage and quality statistics.

The CnC application executing in a CnC server is a web application that manages clusters of streaming server instances. The CnC application associates an instance of the streamer with a multimedia session ensuring that 1 all peers requesting a connection to the same media session will use the same streaming server instance 2 the load is distributed evenly across all the streamers available and 3 the geographically closest streamer is used.

The CnC application is also responsible for persistence of the diagnostic data including bug reports logs devices etc. The CnC application provides an API to access the analytics data stored in Cassandra database . The API can be consumed by the JavaScript components of the Developer Dashboard of the RTC tool. The CnC web application can be implemented using various programming languages such as Python and can use open source Python libraries such as Flask Simpleapi and Jinja2 . The CnC application may not interact directly with other server side components instead it can use the database engines employed by the RTC tool. As stated above the Redis database is used to maintain the session streamer mappings. The Cassandra database is queried for the usage and quality statistics when serving the API requests. The MySQL database can be used for persisting automatic error reports.

The streamer agent is a server side component that helps to maintain a set of streaming servers . The streamer agent receives events from streamers process them to generate usage and quality statistics and persist the statistics using the Cassandra database . The streamer agent can receive events including 1 session created triggered by first connection to a session 2 session joined triggered after any connection to a session including the first one 3 session left triggered after any disconnection from a session 4 session disposed triggered after the last participant leaves a session and 5 media stream quality statistics sent periodically for every media stream included in an active session .

The events related to the session lifecycle created joined left disposed can be required to collect session information when it was started and ended who was participating and when each participant joined or left the session. The media stream quality statistics events are useful for analyzing the system behavior under certain condition which allows system optimizations. The streaming agent releases the session streamer mapping when the session disposed event is received.

In one embodiment the streamer agent interacts with two database engines Redis 115 as a source of events and Cassandra 110 as a persistent data store. Regarding the implementation details the streamer agent can be a daemon process implemented using various programming languages including Python and open source third party Python libraries such as Redis Pycassa Jsonpickle and Supervisor .

The MySQL database is used by the RTC to store information including clients applications billing data monthly minute usage per application details about the WebRTC streaming server instances etc. The MySQL database can be used by the components of CnC server and developer dashboard .

In one embodiment the RTC tool uses Cassandra database to persist the usage and quality statistics including 

In some embodiments the Cassandra database is a NoSQL storage engine. A NoSQL database provides a mechanism for storage and retrieval of data that employs less constrained consistency models than traditional relational databases. The Cassandra database is used by the CnC application and streaming agent modules.

The Redis database can be used for exchanging events between the streaming server and the components of streamer agent and for providing to the streamer a way to get an API key when authenticating a connection request. In some embodiments the Redis database is a No SQL database. The Redis database can be hosted on cloud services such as Amazon EC2 .

The client side components of the RTC tool includes internal components of client SDKs and the API bindings which are described in further detail in the following paragraphs.

The RTC client side service referred to as RTC client e.g. RTC client is one of the core client side components. The RTC client can be responsible for the RTC features especially where the native WebRTC implementation is not available e.g. in mobile SDKs desktop SDKs and browsers without the native support for the WebRTC via an RTC Plug in . The RTC client can contain modules for video conferencing aspects such as video capture devices management video coding quality control networking business logic and an audio engine built on top of the libWebRTC.

The API published by the RTC client is composed of a few functions that use primitive values integers C strings pointers to platform specific structures for rendering e.g. HWND a handle to window in Microsoft Windows . The service functionality is available via a function invoke which takes as the input parameter an invocation request serialized as a string. Internally the request is parsed and delegated to a proper internal function. The requests handling is implemented using known reactor design patterns where all the requests are put in a queue by the calling thread and processed by a single Service thread. This approach can allow calls from application user interface UI thread and reduce the possibility of synchronization issues within the RTC client implementation.

The RTC client can be implemented using various programming languages including portable C C with platform specific subcomponents responsible for video capture devices handling rendering and logging. It can be distributed as a native library e.g. dll on Microsoft Windows dylib on Apple Mac OS X .framework for iOS development .so for Android development etc. The RTC client interacts with the API bindings the RTC Plug in the Operating System and the server side components.

The RTC Plug in uses the RTC client to provide real time audio and video streaming functionality to browsers not supporting the WebRTC technology natively. The RTC Plug in uses NPAPI standard on browsers supporting it and the ActiveX on Microsoft Internet Explorer . The browser compatibility layer is implemented with the help of the FireBreath open source library. The RTC tool uses a unique approach to keeping the software up to date the RTC Plug in passes the requests to the RTC client without being aware of the RTC client functionality. The RTC client component can be replaced while the RTC Plug in is loaded in memory without the need to restart the browser.

The RTC client uses several API bindings allowing users e.g. application developers who integrate RTC tool into their software applications to use the RTC client with the various platforms available on the market. The APIs offered include

The RTC tool uses various communication protocols e.g. between the server side components and the client side components. The RTC tool uses at least three classes of communication protocols the signaling protocol for media session establishment and maintenance the media protocols for transmission of media data audio video screen and for the auxiliary communication for diagnostics and platform maintenance.

The signaling and media streaming protocols can be used in communication between the RTC client or WebRTC enabled browser and the streaming server . The auxiliary communication can be performed between the client SDKs and the CnC web application .

The RTC tool uses various protocols including a proprietary protocol for the signaling part of the client server communication. The existing protocols that have been considered for this purpose SIP H.323 were designed to accomplish a calling scenario where peer A calls peer B in order to establish media session. The client SDKs e.g. desktop SDK to establish a multimedia session between peer A and B or any other peers involved make a logical connection to a single virtual room the media scope or session. This use case requires the flexibility not offered by any of the aforementioned protocols which led to a proprietary protocol. The protocol designed is built on top of a reliable Transport Layer Security TLS over Transmission Control Protocol TCP channel and can use Google Protocol Buffers library for messages serialization.

The TLS over TCP is selected for various reasons. First of all the TCP protocol offers a reliability of the data delivery which can be crucial for the use case. Additionally since the rate of the signaling messages exchanged is fairly low the variable latency of the TCP is not an issue. Finally the use of TLS TCP and port on the streamer side allows the protocol to mimic HTTPS traffic which improves the ability to traverse firewall and NAT devices. In one embodiment the signaling protocol also called the management link is composed of following message types 

The transmission of the real time media data places high demands on the networking infrastructure. These requirements include but are not limited to 

The RTC tool is designed to ensure the best quality possible even in environments as hostile as the WAN. The RTC tool uses a suit of media protocols to ensure the best quality where possible and fallback to the best effort when required. The core protocol used is the industry standard SRTP and RTCP. Using it as a base the RTC tool also supports following transport mechanisms for the media streaming 1 User Datagram Protocol UDP in peer to peer mode P2P 2 UDP relayed through the streaming server and 3 Transport Layer Security TLS over TCP fallback trough the streaming server .

The RTC tool uses the UDP relayed protocol as a primary media streaming transport mechanism. After the client SDK establishes the management link to the Streamer the RTC client will first try to use this protocol. If the UDP communication fails most likely due to a firewall restriction the RTC client will try to reach the Streamer over the TCP fallback transport type. The P2P mode of the UDP based protocol is used as an optimization in case there are only two peers connected to a scope. The state transitions between different media connection types are shown in the . Initially UDP probing is performed. Is successful a UDP relay is established with a UDP P2P . UDP probing fails TCP connecting is pursued. If successful a TCP TLS session transpires. Disconnection occurs upon a disconnect state of a failed TCP connection .

The following sections provide more detailed description of each of the media transport mechanisms employed by the RTC tool.

The UDP relay connection is the primary connection type for the RTC tool. The RTC client tries to establish this type of a connection as soon as the authentication response from the streamer is received. To ensure that the UDP packet flow is functional the client component sends a series of probing packets to the UDP ports given in the response. After receiving at least a single reply the UDP channel is considered as functional and the media packets flow begins.

The UDP relay uses multiple UDP ports for streaming purposes. In some embodiments initially the client SDK will attempt to connect to the streamer using ports for the audio stream and the port for video. This is to ease the port based Quality of Service QoS polices when using the on premise deployments. If the RTC client fails to communicate using the default ports it will proceed and attempt to establish the connection using the TCP fallback. Upon a success it will try to establish UDP connectivity again using multiple possible remote UDP ports with audio and video multiplexed within a single channel. This is to leverage the existing firewall exception policies that may be configured on the end user network for other media streaming services.

The TLS over TCP connection is treated as a fallback for clients behind restrictive firewall devices. The RTC client will try to establish the TCP streaming connection when the UDP probing timeout occurs. The connection is made to the same host and the same port as with the management link port . Once the TCP and TLS connection is established the connection is considered as functional and the media packets flow will start. Since the TCP uses data streams instead of datagrams the RTC tool uses Protocol Buffers messages to serialize and de multiplex between signaling and media packets.

An attempt to establish the Peer to Peer P2P transport is done only when there are two clients in the session and if the UDP relay works for both of them. The notification to enable the P2P mode is always sent by the streamer . This is because in some embodiments the streamer is the only component that has all the data needed to decide whether this mode should be enabled. The data includes the exact number of users connected type of media protocol used by each participant and the public UDP endpoints used by participants.

The notification is sent using the user event message over the signaling channel. The body of the message contains only the public UDP endpoint of the remote peer. The RTC client will use this information and probe the endpoint. Upon a success the data transmission is smoothly transitioned to use the direct link. The communication between the RTC client and streamer is maintained even when the media streaming uses direct channel. This is to ensure that the port mapping is maintained on the NAT device used by the client.

The P2P connection establishment process employs the core mechanisms from the RFC 5245 4 ICE protocol such as UDP hole punching exchange of UDP endpoints visible from the WAN or heart beating.

The signaling and media streaming protocols are functional also when the end user device is connected to the Internet via a proxy. The RTC tool supports following various proxy server types including SOCKS5 TCP and UDP proxies without the authentication support HTTPS proxies not requiring authentication HTTPS proxies requiring basic or digest authentication HTTPS proxies using Kerberos NTLM for authentication.

The RTC client communicates also with the CnC application . For this purpose it can use the HTTPS protocol. A streamer endpoint resolution is a process where an application id and scope id are passed to the CnC component to resolve which streamer should be used to conduct the session. The request can be made using HTTPS GET method with parameters encoded in the query string. The CnC application can reply using a plain text string e.g. in the form of STREAMER HOST STREAMER PORT.

The RTC client can use several POST requests to facilitate automatic bug reports in case of a platform failure media devices used during a session upon a successful connection service logs while the client is connected to any session etc.

The RTC tool provides an adaptive layer protecting an end user s endpoint from congestion and resources overuse e.g. CPU overuse . The RTC tool controls the quality of the video streams to ensure the fixed high quality of audio streaming. The RTC tool can scale the quality of the video feed from e.g. 64 kbps QVGA 10FPS up to 1 1.5 Mbps 720p 24 FPS . It means that the streams generated by the RTC tool can require as little as 100 kbps of bandwidth for the tool to operate

The RTC tool uses 3 types of quality control adaptation including Uplink adaptation Downlink adaptation and Peer to Peer adaptation.

The Uplink adaptation monitors client network to detect packet queuing delay to avoid the congestion early before there is loss packet loss in case of networks lossy in general and increased jitter.

The reduction of the quality is done on various levels quality of the encoder target bitrate size of the video feed and amount of the frames per second.

When publishing the video stream an application tells the SDK the maximum quality it wants to publish max width height and frames per second . The SDK uses this as an upper cap of the quality of the video feed.

The downlink adaptation uses an approach called simulcast. For the simulcasting the RTC tool uses two separate video streams no SVC streams are not related high quality video feed the dynamic bitrate and quality see uplink adaptation and low quality feed fixed bitrate and quality . In one embodiment the high quality feed is the primary one exchanged between the peers by default.

The low quality feed is used when one of the peers involved in a session has problems with the reception of the data. The streamer can detect this by increased loss and or queuing delay. In this case the streamer will request one or more other participants to start publishing an extra low quality feed which gets delivered to the peer with issues to reduce the bandwidth utilization and avoid congestion.

When session has only two users connected the session uses a single layer of dynamic quality. Each peer can reduce quality when there are issues on the uplink side exactly as per the uplink adaptation. When it comes to congestion when receiving the data each peer reports to the other peer the capacity of the downlink. When the uplink side detects that the other end has problems with the reception it will back off the quality to a level where the queuing delay is stable thus the capacity of the channel was reached .

The following paragraphs provide a brief overview of the reliability of the RTC tool. In some embodiments the RTC tool can ensure a 99.95 up time reliability policy. In some embodiments to ensure the reliability the RTC tool focuses on the streaming service .

The RTC tool is built on the assumption that each instance of the streamer may fail at any time. The following paragraphs describe the techniques to ensure service resilience to outages of a single instance of the streamer .

The key facility to achieve this resilience is the reconnects. When the client SDK detects a lost connection it will automatically try to recover by reestablishing a connection. To achieve this it will request a streaming endpoint from the CnC application . This request can contain two additional query string parameters in addition to applicationld and scopeld e.g. reconnect true to explicitly indicate that this is a reconnect request streamer endpoint to inform the CnC application about which instance of the streamer potentially failed.

The CnC application handles those special mapping requests by checking the health of the Streamer reported and by returning a new one if necessary. The exact procedure can be described using the following example procedure 

If the above procedure reports that the streamer is functional the existing mapping will be returned to the client. Otherwise a new instance of the streamer can be selected using the following example procedure 

Before sending this request the client SDK can wait a random amount of milliseconds between one and two seconds . This approach can serve two purposes to prevent a flood of similar requests and to cover the case when a streamer crashed and instantly restarted by the supervisor daemon.

As another reliability measure the RTC tool monitors the health of the streamer processes and hosts. It allows the RTC tool to detect issues before they are experienced by end users such as end users and . In one embodiment the monitoring facility is composed of the following layers 

The CnC application is a web application can be implemented with Python and Flask . In some embodiments reliability of the CnC application can be ensured using tools and methodologies publicly available. The CnC application can run on completely separate deployments in different cloud server regions e.g. Amazon EC2 regions North Virginia and Oregon . Both of these deployments can use distinctive domain names e.g. cnc2.addlive.com and cnc3.addlive.com.

The implementation of the client SDK uses all configured CnC endpoints for the streamer endpoint resolution. At first it will choose a random endpoint from the list configured. If the resolution fails it will iterate repeatedly through the available resolvers until one succeeds or the retry limit is reached.

Both CnC deployments use the same setup. This configuration uses Nginx as a reverse proxy with multiple nodes attached to a single upstream. Subsequently each node that is linked the master Nginx server uses Nginx as a reverse proxy and has multiple uWSGI processes as final workers. Additionally the configuration of the leaf http server uses a retry policy where an error result triggers the request to be passed to the next uWSGI process in the upstream. This approach allows the platform to seamlessly handle temporal issues with e.g. database connectivity.

The Redis datastore is used throughout the RTC tool. The RTC tool uses two separate deployments of Redis 115 e.g. one to store the API keys and the other to maintain the session streamer mappings. The reliability of both deployments is achieved in different ways due to different usage patterns. This is described in the following paragraphs.

Each streaming node runs a local copy of the Redis server and communicates with it using the Unix domain sockets. Every local database server is connected to a single master as a read only slave. Whenever customers create modify or remove the API credentials these data are stored in a SQL database and in the Redis master server. The Redis master server then populates the API credentials to all the slaves.

This approach makes the authentication process robust. Since the local instances of Redis are employed for authentication the service will operate seamlessly even if the master node fails or any network partitioning occurs. In case of master failure to restore the API credentials store manageability the RTC tool administrator is only required to start another host running an instance of the Redis server populate it with the data from the MySQL database and assign the designated elastic IP.

Furthermore a failure of a slave usually occurs due to a failure of the complete host in which case the streaming service is already compromised on the node. The crash of a Redis server is highly unlikely and is handled manually either by restarting the Redis server process or by replacing the streaming node with a completely new instance.

In some embodiments to scale the service horizontally the RTC tool uses multiple instances of the Redis database to store the session streamer mappings. The instance to be used by a particular mapping is defined using a simple partitioner which uses an application id and a session id to generate an index of the Redis node to be used. Additionally this approach improves reliability as there is no single point of failure.

To keep the service operational when one of those instances fails every instance has a read only slave. When there is an issue with one of the master database servers the CnC application that detected it instantly falls back to the slave effectively promoting it to a new master. This is possible because Redis 115 allows itself to be reconfigured on line using the CONFIG SET commands.

The temporary infrastructure creation kit provides entities using the RTC tool to provide RTC features to their clients with a package e.g. bundle distribution that will contain RTC tool provider assets e.g. server side components client SDKs Plug in installers etc. and a set of scripts that will take a descriptor as an input and will spin off a cluster of all the necessary infrastructure.

With this approach whenever the infrastructure maintained e.g. streamer by the RTC provider for the functioning of the RTC tool fails the entities can still provide RTC services to their clients with no to minimal downtime. The above described method provides an effective disaster recovery technique. This way the entities using the RTC tool can be sure of the RTC tool s availability and trust the RTC tool provider. The temporary infrastructure creation kit can be used when the RTC infrastructure maintained by the RTC tool provider fails. In some embodiments a client will have to initiate it manually if certain outage was reached or we went out of business.

The following paragraphs explain the security features of the RTC tool. The security analysis covers following areas 1 Connection Authentication validation that only allowed users can connect to a particular session 2 Communication security assessment of the media and signaling channels security to prevent eavesdropping 3 Binary components security assessment of the security of the binaries installation processes to prevent use of the RTC tool as a target vector for installation of malicious software.

Within the RTC tool each and every connection made to the WebRTC streaming server needs to be authenticated. This is to ensure that only the users that are allowed by the original application connect and receive streams from other peers. The authentication scheme does not require any communication between the server side components and the RTC tool. Instead on the server side the application should prepare all the required data sign them using a shared secret a.k.a. API Key and pass it to the client component of the application. The client side then should use the data given to prepare the connection descriptor.

To authenticate a given connection request the RTC tool expects data including the following data to be provided 

The above authentication data should be passed e.g. in the authDetails attribute of the ConnectionDescriptor object passed to the connect method of the API binding.

In order to protect user data from eavesdropping the signaling messages are transmitted over the TLS TCP channel using the TLS 1.0 encryption scheme. In some embodiments the scheme is configured as follows 1 cipher suites are restricted to 128 and 256 bit key AES encryption 2 key exchange is done using the Ephemeral Diffie Hellman algorithm 3 for peer authentication the RSA algorithm is employed 4 for message block authentication the SHA1 algorithm is employed.

In some embodiments the media data flow is protected using the Secure Real time Transport Protocol SRTP . The SRTP provides confidentiality message authentication and replay protection. The keys used for media encryption are volatile generated by the streamer during the session creation when the first participant joins the session . Once generated the key is not persisted anywhere and is transmitted to peers within the auth response message over the already secured signaling channel.

In some embodiments the SRTP encryption scheme is configured in the following way 1 AES CBC 128 bit key for RTP packet encryption 2 HMAC SHA1 for packet authentication and integrity 3 No RTCP packets authentication.

This section covers briefly the security of the binary components installed on the end user computer e.g. RTC Plug in installation and self updating.

The RTC Plug in is available for various operating systems including Apple Mac OS X and Microsoft Windows operating systems. On the Windows platform the installation process is done using a custom installer binary. Also on this platform all the binaries used by the RTC Plug in or Native Desktop SDK are cryptographically signed using a certificate issued by a well trusted certifying authority e.g. GlobalSign Inc.

On The Mac OS X platform all the binaries are signed using the certificate issued by Apple as a part of Mac OS X developer program.

The RTC Plug in self update process from security perspective works in the same way on both desktop platforms. In some embodiments it can be described in following high level steps 

Also as an additional security means all the update components and installers are protected by a monitoring service ensuring that the binaries available are those uploaded by the RTC tool provider responsible for the distribution.

In some embodiments the RTC application can also be used for commercial purposes. For example service providers such as attorneys can providing counseling to their clients using the RTC application. The service provider and the client may view and hear each other using the RTC application. In some embodiments the RTC application may require the users who wish to the use the RTC application to sign up and create a profile with the RTC application.

The RTC application includes a mechanism for a service provider to bill a client who wishes to use his her services. In the GUI a service provider Kavan receives a call from a user or a client Bob who wishes to talk to Kavan. The service provider can choose whether to accept or reject the call from the client. If the service provider chooses to accept the call the service provider may also choose to bill the call. The service provider may send the charge to the client using the mechanism e.g. a button Bill Bob provided on the GUI . The client can choose to accept or reject the charge as explained at least with reference to . Accordingly embodiments of the disclosed technology enables billing a user in a single click of a button.

In some embodiments upon accepting the charge the client may be presented with a list of available payment methods that the client can choose from to pay the service provider. An example GUI showing the list of available payment methods is illustrated in GUI of . Upon selecting one of the payment methods displayed in GUI the RTC application requests the client to provide the payment details e.g. credit card number checking account number etc. illustrates an example GUI for providing payment details to the RTC application consistent with various embodiments of the disclosed technology. After the payment is successfully completed the client is connected to the service provider.

The client can be charged in various ways e.g. a flat fee per hour etc. If the client is charged on a per hour basis the client may billed at the end of the call in which case the RTC application does not charge the client upon receiving the payment details in GUI . The RTC application may just validate the payment method in GUI and then connect the call. The service provider and the client may engage in conversation as illustrated in GUI of . The GUI can display a variety of information including charge per hour duration of the call current charges for the call whether the call is billed etc. Upon completing the call the client is billed using the payment details provide in GUI .

In some embodiments the client may provide a default payment method in his her user profile created with the RTC application. If the client has a default payment method and enabled a single click payment the client may make the payment in a single click of a button. For example consider that the client has configured a default payment method and enabled single click payment in his profile. When the client receives a charge from the service provider as illustrated in GUI on selecting accept the client is directly connected to the call and the GUI is presented to the client. The payment method GUI and payment detail GUI may not displayed to the client.

Accordingly embodiments of the disclosed technology enables a user of the RTC application to bill in a single click and to pay in a single click. It should be noted that the GUIs illustrated in are examples only. The GUIs can be designed in various ways for example the Bill Button can be implemented as a link or any other GUI element. The GUI can display additional or less information e.g. information related to the RTC application users the call charges etc.

The memory and storage devices are computer readable storage media that may store instructions that implement at least portions of the described technology. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communications link. Various communications links may be used such as the Internet a local area network a wide area network or a point to point dial up connection. Thus computer readable media can include computer readable storage media e.g. non transitory media and computer readable transmission media.

The instructions stored in memory can be implemented as software and or firmware to program the processor s to carry out actions described above. In some embodiments such software or firmware may be initially provided to the processing system by downloading it from a remote system through the computing system e.g. via network adapter .

The technology introduced herein can be implemented by for example programmable circuitry e.g. one or more microprocessors programmed with software and or firmware or entirely in special purpose hardwired non programmable circuitry or in a combination of such forms. Special purpose hardwired circuitry may be in the form of for example one or more ASICs PLDs FPGAs etc.

The above description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding of the disclosure. However in certain instances well known details are not described in order to avoid obscuring the description. Further various modifications may be made without deviating from the scope of the embodiments. Accordingly the embodiments are not limited except as by the appended claims.

Reference in this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the disclosure. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover various features are described which may be exhibited by some embodiments and not by others. Similarly various requirements are described which may be requirements for some embodiments but not for other embodiments.

The terms used in this specification generally have their ordinary meanings in the art within the context of the disclosure and in the specific context where each term is used. Certain terms that are used to describe the disclosure are discussed below or elsewhere in the specification to provide additional guidance to the practitioner regarding the description of the disclosure. For convenience certain terms may be highlighted for example using italics and or quotation marks. The use of highlighting has no influence on the scope and meaning of a term the scope and meaning of a term is the same in the same context whether or not it is highlighted. It will be appreciated that the same thing can be said in more than one way. One will recognize that memory is one form of a storage and that the terms may on occasion be used interchangeably.

Consequently alternative language and synonyms may be used for any one or more of the terms discussed herein nor is any special significance to be placed upon whether or not a term is elaborated or discussed herein. Synonyms for certain terms are provided. A recital of one or more synonyms does not exclude the use of other synonyms. The use of examples anywhere in this specification including examples of any term discussed herein is illustrative only and is not intended to further limit the scope and meaning of the disclosure or of any exemplified term. Likewise the disclosure is not limited to various embodiments given in this specification.

Those skilled in the art will appreciate that the logic illustrated in each of the flow diagrams discussed above may be altered in various ways. For example the order of the logic may be rearranged sub steps may be performed in parallel illustrated logic may be omitted other logic may be included etc.

Without intent to further limit the scope of the disclosure examples of instruments apparatus methods and their related results according to the embodiments of the present disclosure are given below. Note that titles or subtitles may be used in the examples for convenience of a reader which in no way should limit the scope of the disclosure. Unless otherwise defined all technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art to which this disclosure pertains. In the case of conflict the present document including definitions will control.

