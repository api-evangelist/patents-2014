---

title: Application performance management tools with a service monitor for collecting network breadcrumb data
abstract: Some embodiments provide application performance management tools with a service monitor that operates on a number of different mobile devices to track and monitor services that an application is using. In some embodiments, the service monitor stores a log relating to the use of the service each time the application uses the service. The application performance tool also includes an error monitor to detect an application error and report the application error to a performance monitoring server along with one or more logs relating to the use of the service when the error is detected. The performance monitoring server then provides an error report with the one or more logs to assist a developer in diagnosing the cause of the error with the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09639412&OS=09639412&RS=09639412
owner: APTELIGENT, INC.
number: 09639412
owner_city: San Francisco
owner_country: US
publication_date: 20140312
---
This application claims the benefit of U.S. Provisional Patent Application 61 951 491 entitled Service Monitor for Monitoring and Tracking the Performance of Applications Running on Different Mobile Devices filed Mar. 11 2014. U.S. Provisional Patent Application 61 951 491 is incorporated herein by reference.

The mobile device industry has been growing for a number of years. The growth in the industry has led to a proliferation of many different types of mobile devices from various different vendors. A vendor may provide various different make and or models of several mobile devices to gain a competitive edge in the growing industry. For instance the vendor may provide different smart phones and or tablets that come in different sizes with different specifications etc. In addition different mobile devices may come with different mobile operating systems OSs or different versions of the same mobile OS. Some vendors even modify a particular mobile OS to add or remove specific features. The evolution of the mobile OSs has even led to many other computing devices e.g. game systems media player appliances etc. adopting the mobile OSs or modified versions thereof.

With the growth there is an increasing demand for quality applications. The challenges that application developers face can be daunting. For example to grow with the industry the developers may have to write applications for different mobile OSs. Different mobile OSs will try to promote different programming languages e.g. through their respective application programming interfaces APIs libraries and or frameworks . In addition each different version of one mobile OS may add and or remove features e.g. use different APIs .

Many application developers rely on user feedback to determine if there are any issues e.g. performance issues with their applications. Such user feedback may be valuable but it may not provide the developers with e.g. real time data about how their applications are performing across a number of different mobile devices e.g. that are from different vendors and or operate on different mobile OSs . The user feedback may also not provide e.g. at least in real time and with minimum effort detailed measurements of how their applications are performing across different mobile devices in relation to different services such as cloud services that the applications are using.

Some embodiments provide a service monitor that operates on a number of different mobile devices to track and monitor services that an application is using. An application may depend on a number of services such as network services to access various cloud services. In some embodiments a cloud service represents any service that an application executing on the mobile device needs to access a server through a network such as the Internet to provide data and or retrieve data. Although this list is non exhaustive examples of different types of cloud services include a storage service e.g. an image hosting service a data backup service a social network service a media streaming service a news service a weather forecast service a game service a messaging service etc.

In some embodiments the application can be a native application a carrier based application or a third party application that communicates with a server through one or more different interfaces such as through a Wi Fi interface and a cellular interface e.g. 4G interface . The service monitor operates in conjunction with such an application to gather data relating to the services and send the gathered data to a server e.g. managed by a mobile application performance monitoring mAPM service provider . The gathering of the data can occur in many mobile devices that are of different types e.g. smart phone tablet etc. that are from various different vendors and or that operate on different mobile operating systems OSs . For instance any mobile device with the application with the service monitor enabled can trap and send data each time the application uses a particular service.

Once the data is gathered it is presented on a client in some manner to inform the application developer of the performance of the application. As an example the gathered data can be formatted or translated and then presented e.g. in real time by a mAPM server to show latencies error rates data bandwidth and the number of service requests to different application programming interfaces APIs . This provides the developer with a wealth of knowledge to quickly identify areas that need improvement and or troubleshoot any poorly performing APIs as well as verify and maintain the quality of correctly performing APIs. As the data is gathered from different types of mobile devices the gathered data can be used to pinpoint or identify a particular type of mobile device e.g. make and model or mobile OS e.g. a particular version of the mobile OS in which the application is performing poorly.

In monitoring the service monitor of some embodiments is configured to intercept services calls that an application makes and record certain information relating to the calls. In some embodiments when a network service is requested by the application the service monitor captures data relating to the network service request. If there is a response to the service request the service monitor may also capture data relating to the response. For instance the service monitor may record the time of the request and the time of the response. From the recorded timestamps the service monitor may compute latency or some other measurement such as response time. Alternatively or conjunctively with such timestamps the service monitor may capture other data such as an address URL associated with the request the amount of data sent e.g. bytes sent with the request the amount of data received e.g. bytes received with the response an error code in the response other headers of the response etc.

As mentioned above the gathering of the data can occur in many different types of mobile devices e.g. smart phone tablet etc. from various different vendors. The gathering of data can occur on several different mobiles OSs. To provide additional context regarding the service calls the service monitor of some embodiments gathers mobile state data. In some embodiments the service monitor associates each service call data with mobile state data that indicates the state of the mobile device e.g. at the time the service call data was captured . The mobile state data can include any one or more of the following carrier info e.g. the name or identity of the wireless carrier that is servicing the mobile device geo location information e.g. latitude longitude network connectivity information e.g. whether the device was on Wi Fi cellular or not connected mobile network code MNC mobile country code MCC roaming time battery level memory usage up time whether the device is jailbroken or rooted mobile OS version and mAPM service monitor version.

In addition to mobile state data or instead of it the service monitor may collect other data that provide additional context regarding each service call. For instance when the service monitor is ready to send a report regarding a service call the service monitor might add to the report an application ID the version number of the application a device ID the make and or model of the mobile device the version number of the mobile operating system OS etc. In this manner when the developer views the gathered data the developer can pinpoint specific areas of interest e.g. a particular application version a particular make or model of the mobile device etc. that need improvement.

In some embodiments the service monitor operates on different types of mobile OSs. On or more different types of mobile OSs the service monitor of some embodiments includes a service call wrapper that wraps an object method or function to 1 intercept a service request made by the application to access the service and 2 capture data relating to the service request. Alternatively in one or more other different types of mobile OSs the service monitor may include a monitored socket object and or a monitored connection object to capture data relating a network connection each time the application uses the connection to access a network service.

The service monitor of some embodiments is one of several different tools provided by a mAPM service provider. For instance the mAPM service provider may also provide one or more other monitors e.g. a crash monitor a handled exceptions monitor . In some such embodiments the service monitor operates on a mobile device to track at least one service that the application is using and to store a log relating to the use of the service each time the application uses the service. An error monitor may also operate on the mobile device to detect an application error e.g. an application crash . When there is an application error the error monitor may send a message to the API server regarding the error e.g. with a code stack trace along with one or more logs relating to the use of the service. In some embodiments the message is then used to present an error report to a developer. The developer can then use the error report with one or more log entries to determine if the service usage is in any way correlated to the application error.

The preceding Summary is intended to serve as a brief introduction to some embodiments as described herein. It is not meant to be an introduction or overview of all subject matter disclosed in this document. The Detailed Description that follows and the Drawings that are referred to in the Detailed Description will further describe the embodiments described in the Summary as well as other embodiments. Accordingly to understand all the embodiments described by this document a full review of the Summary Detailed Description and the Drawings is needed. Moreover the claimed subject matters are not to be limited by the illustrative details in the Summary Detailed Description and the Drawings but rather are to be defined by the appended claims because the claimed subject matters can be embodied in other specific forms without departing from the spirit of the subject matters.

In the following detailed description of the invention numerous details examples and embodiments of the invention are set forth and described. However it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.

Embodiments described herein provide a service monitor that operates on a number of different mobile devices to track and monitor services that an application is using. An application may depend on a number of services such as network services to access various cloud services. In some embodiments a cloud service represents any service that an application executing on the mobile device needs to access a server through a network such as the Internet to provide data and or retrieve data. Although this list is non exhaustive examples of different types of cloud services include a storage service e.g. an image hosting service a data backup service a social network service a media streaming service a news service a weather forecast service a game service a messaging service etc.

In some embodiments the application can be a native application a carrier based application or a third party application that communicates with a server through one or more different interfaces such as through a Wi Fi interface and a cellular interface e.g. 4G interface . The service monitor operates in conjunction with such an application to gather data relating to the services and send the gathered data to a server e.g. managed by a mobile application performance monitoring mAPM service provider . The gathering of the data can occur in many mobile devices that are of different types e.g. smart phone tablet etc. that are from various different vendors and or that operate on different mobile operating systems OSs . For instance any mobile device with the application with the service monitor enabled can trap and send data each time the application uses a particular service.

Once the data is gathered it is presented on a client in some manner to inform the application developer of the performance of the application. As an example the gathered data can be formatted or translated and then presented e.g. in real time by a mAPM server to show latencies error rates data bandwidth and the number of service requests to different application programming interfaces APIs . This provides the developer with a wealth of knowledge to quickly identify areas that need improvement and or troubleshoot any poorly performing APIs as well as verify and maintain the quality of correctly performing APIs. As the data is gathered from different types of mobile devices the gathered data can be used to pinpoint or identify a particular type of mobile device e.g. make and model or mobile OS e.g. a particular version of the mobile OS in which the application is performing poorly.

For some embodiments of the invention conceptually illustrates a system for tracking and monitoring services that applications use on different mobile devices. Specifically this figure shows several mobile devices reporting data regarding services that applications are using to a set of one or more application programming interface API servers. The captured data is then stored in storage formatted and or translated in some manner by an API server and presented to an application developer on a client.

The service monitor operates on different types of mobile devices to monitor services that applications are using. In the example of the mobile devices include a tablet and several smart phones and . However one of ordinary skill in the art will understand that the discussion in this example as well as other examples discussed hereinafter is equally applicable to other kinds of mobile devices e.g. a smart watch a phablet etc. or any other electronic devices e.g. a digital media player appliance a game system a smart television TV a smart appliance desktop computer laptop etc. . Today many electronic devices are using a modified version of an existing mobile device operating system OS as their OS. For instance a digital media player or a game system might come pre packaged with a modified version of iOS by Apple Inc. or Android OS by Google Inc.

In addition to device types the mobile devices can be from different vendors. For instance in the tablet is from a first vendor e.g. Amazon Inc. the smart phone is from a second vendor e.g. Apple Inc. and the smart phone is from a third vendor e.g. Nokia Inc. . Today many vendors modify a particular mobile device OS e.g. Android OS to add and or remove features.

The mobile devices can also be serviced by different carriers. For instance in the mobile device may use one carrier to access the cellular network while the mobile device may use another carrier. In addition the devices might access the network using one or more different services. For instance the tablet may access the internet through Wi Fi or through the cellular network.

The service monitor performs the monitoring on such different device to capture various pieces of data e.g. performance data metadata relating to services that applications use. As an example each time that an application uses a network service to send and receive data the service monitor may trap and send metadata and performance data to the API server. The developer can then view and analyze the captured data to identify any issues e.g. performance issues error issues that end users are having with the application. As the service monitor operates on such different types of devices and different types mobile OSs the developer can have a complete view of the developer s application s and identify areas that need improvement.

In addition to capturing service call data the service monitor of some embodiments captures other types of data. In some embodiments the service monitor collects mobile device state data and associates it with the service call data. For example to provide additional context regarding the service calls the service monitor or of some embodiments gathers mobile state data. The mobile state data can include any one or more of the following carrier info e.g. the name or identity of the wireless carrier that is servicing the mobile device geo location information e.g. latitude longitude network connectivity information e.g. whether the device was on Wi Fi cellular or not connected mobile network code MNC mobile country code MCC roaming time battery level memory usage up time whether the device is jailbroken or rooted mobile OS version and mAPM service monitor version. The service monitor of some embodiments then sends a report with the service call data and the mobile state data to the API server.

In addition to mobile state data or instead of it the service monitor or may collect other data that provide additional context regarding each service call. For instance when the service monitor is ready to send a report regarding a service call the service monitor might add to the report an application ID the version number of the application a device ID the model of the mobile device the version number of the mobile operating system OS etc. In this manner when the developer views the gathered data the developer can pinpoint specific areas of interest e.g. a particular application version a particular make or model of the mobile device etc. that need improvement.

In some embodiments each service monitor or monitors one application that executes on a mobile device. The service monitor may be a part of the application that it monitors. For instance when the application is installed on a device it will include the service monitor as one of its components. This is shown in because each service monitor or is contained in a particular application or . Also when there are two different applications and on a same mobile device each application includes its own service monitor or . Alternatively the service monitor may monitor a group of applications and send a service report that is specific for a particular application executing on a mobile device each time the application makes a service call.

In some embodiments the mAPM solution provider provides a set of tools that when enabled monitors and captures different aspects of mobile application performance. For instance an application developer can download a package a kit e.g. Software Development Kit SDK a library or a software framework that includes the set of tools to monitor errors within the application as well as services that interact with the application. To enable the monitoring the application developer can link the developer code with the service monitoring code. In one embodiment the linking is static in another embodiment the linking is dynamic or in other embodiments there could be both. The application developer can then release or publish e.g. to an online App store a version of the application with the monitoring features. The application developer can then monitor and track how the application performs on various different mobile devices of different end users.

In some embodiments the API server or a group of API servers is responsible for back end processing. This may entail receiving the captured data from the mobile devices storing it in storage and presenting it to developers. In some embodiments the API server provides a real time global view of application diagnostics and crashes across different mobile device platforms e.g. iOS Android Windows Phone etc. . The API server of some embodiments formats or translates the captured data in some manner to present it to developers. For example the captured data may be presented in statistical and or in graphical format. Such a format allows developers to easily track e.g. in real time performance of one or more of their applications across different types of mobile devices operating systems OSs Application versions etc. This is important because the developers do not have to wait for user feedback. Instead they can access one or more of the different application performance reports determine if there are any problems and address those problems if there are any.

In some embodiments the API server generates different views with trends associated with the monitored applications. Trending represents tracking captured data over some period of time to detect and diagnose changes in the application s performance. The trends can be over different types of data. For instance the API server of some embodiments allows developers to track real time and historical performance across device OS versions etc. The API server may allow developers to view trends by device OS and carrier. For developers such trends can be important from a business perspective as well as a technical perspective. From a business perspective the trends allow the developers to know which device e.g. make and or model OS e.g. version and or carrier is the most popular. From a technical perspective the trends allow the developers to know which device OS and or carrier is the most problematic across the developer s user base.

In the example of the client is a web server client. The web server client can be a standard web browser that accesses the web server . The web server delivers web pages to the clients. As shown the web server might send to the client one or more pages with application performance data device trends OS trends carrier trends and crash reports. In some embodiment the API server can be accessed via a stand alone application or any other distributed software application or service. For instance instead of a thin client the mAPM solution provider may provide a thick client application to access the API server e.g. directly rather than through the web server .

The storage stores the captured data from the various different mobile devices . In some embodiments the captured data includes the service monitoring data as well as error monitoring data. In some embodiments the storage may store user accounting data. The user account data may be used to allow the developers to log on and access the monitoring services to charge the developers for the use of the monitoring services etc. To simplify the description only one storage is shown in . However the captured data and the user accounting data may be stored in a number of storages e.g. databases . In addition the data may be stored at different locations e.g. at different data centers . The data may also be accessed using standard Structured Query Language SQL using a NoSQL mechanism or using some other data access protocol.

Three operational stages of the mobile device are shown in . The first stage shows the mobile device showing its home screen page on the device s touch screen display. The home screen page includes a number of icons several of which are arranged along the bottom of the screen e.g. in a dock . Each icon can be selected to open a corresponding application. Here the user taps the user s finger over an icon associated with the application. The gesture causes the application to be opened as illustrated in the second stage .

The second stage conceptually shows the application being directed to make a service call. As shown the user interacts with the application by tapping the user s finger over a selectable item. The selectable item has a label that reads Use Service . However an application can make a service call in various different ways. For instance the application may make network calls when the application is trying to load data when triggered when directed by a user etc. The end user may or may not be aware of the service calls that are taking place in the application.

Third stage illustrates the mobile device after making the service call. In particular this stage shows that the service call resulted in an error. For instance there may have been network connectivity issues which caused the application to fail in sending the service request. As another example the application may have sent the response but got no response. These are just two of many possible reasons why a failure can occur with a service call.

Irrespective of whether a service call fails or not the service monitor of some embodiments operates in conjunction with the application to gather data regarding the call. illustrates the service monitor capturing data regarding the service call made by the application. Four operational stages of the mobile device are shown in the figure. These four stages represent several operations that are occurring as the user interacts with the application in stages of .

As shown in the application executes on the mobile device . In this example the service monitor is part of the application and includes a service call wrapper a mobile device state data collector a parser an output agent and a storage .

The service call wrapper is a service monitor component that is responsible for monitoring and capturing data regarding a service call. In some embodiments the service call wrapper intercepts service calls e.g. by wrapping one or more methods functions or objects . Without the service monitor feature enabled the service call would have been received by the application service call module . However as the feature is enabled the service call that would normally be directed towards the application service call module is now directed towards the service call wrapper . Upon interception the service wrapper of some embodiments captures services call data and or facilitates in capturing data and redirects the service call to the application service call module .

In some embodiments the parser receives the service call data from the service call wrapper and then parses the call to extrapolate or extract various pieces of data. The data may be extracted from the headers the body and or the trailer. Depending on the type of service call the parser may be configured to identify different types of data. As an example for a network call the parser may be configured to extract from the service call an address e.g. uniform resource locator URL associated with the call the number of bytes sent e.g. the content length associated with the call etc. Not all data may be extracted from a call. That is the service monitor may identify derive or be informed of other data relating to call. As an example the service monitor may record the time of the request.

If there is a response to the service request the service monitor of some embodiments capture data relating to the response. In some embodiments the service monitor captures the number of byte received e.g. the content length associated with the response etc. Not all data may be extracted from a response. That is the service monitor may identify derive informed of and or calculate other data relating to call. As an example the service monitor may record the time of the response and calculate the latency using the time of the response and the previously recorded time of request.

Different from the service call wrapper the mobile device state data collector is responsible for aggregating state data relating to the mobile device. In some embodiments the mobile state data includes carrier info e.g. the name or identity of the wireless carrier that is servicing the mobile device geo location information e.g. latitude longitude and network connectivity information e.g. whether the device was on Wi Fi cellular or not connected .

The output agent is responsible for sending captured data e.g. service monitoring message to the API server. The output agent may send the data immediately or may send the data when triggered. For instance the data may be sent on a periodic basis. The frequency of this period may be set by the API server. Alternatively the data may be sent immediately when it is ready to be retrieved from the storage . In some embodiments the output agent only sends the data when all the necessary data has been aggregated e.g. in the storage . The output agent of some embodiments sends the data in a particular order e.g. in the order the service call has been invoked .

The storage stores captured service call data. In some embodiments the storage stores other data such as mobile state data. In some embodiments the storage is a data queue. In some embodiments the storage is a first in first out FIFO queue that preserves the order of the different service calls. In other words each call data will be processed or output in the order that it was put into the queue. In some embodiments the storage is a serial queue in that it does not process multiple data requests in parallel. Instead it process one data request at a time e.g. in the order that the request was received . In some embodiments the serial queue is used to ensure that each dataset relating to a service call is associated with the appropriate mobile device state. For instance a mobile device s state can change often. The serial queue ensures that with all these state changes the captured service call data is synchronized with the correct mobile state data. The storage may filter data may compress data or may redact data.

While many of the features of the service monitor have been described as being performed by one component or module e.g. the output agent the mobile device state data collector etc. one of ordinary skill in the art will recognize that the functions of such components and other components described herein might be split up into multiple sub components. Similarly functions described as being performed by multiple different components might be performed by a single component in some embodiments.

Having described several example components the operations of the service monitor will now be described in terms of the four stages that are illustrated in . The first stage illustrates the service monitor storing the mobile device state in the storage . Specially the mobile device state data collector gathers the latest mobile state data and stores it in the storage. The mobile device state data collector may initially gather this data when the application is opened and continue updating the data. For instance if network connectivity changes the mobile device state data collector may be informed of the change and update the state data in the storage. In this manner when a service call is intercepted it is associated with the latest state that is stored in the storage.

The second stage illustrates the service monitor intercepting a service call. This corresponds to a point in time after the user has initiated the service call by tapping the user s finger over the selectable item in the second stage of . As mentioned above without the service monitor feature enabled the service call would have been received by the application service call module . However as the feature is enabled the service call that would normally be directed towards the application service call module is now directed towards the service call wrapper .

The third stage shows the service monitor storing data relating to the service call in the storage. Particularly the service call wrapper has intercepted the call and passed it to the parser. Having received the call the parser parses the call to extrapolate one or more pieces of data. Here the service monitor may identify derive and or calculate other data relating to call. Thereafter all the captured data is stored in the storage along with the mobile state data.

The fourth stage shows the service monitor sending the captured data to the API server e.g. the application performance monitoring server . In sending the output agent may retrieve the captured data from the storage which includes the call data and the mobile state data and interface with one or more other components to encrypt the data and send it to the API server. For instance the service call message may encrypt via secure socket layer SSL or some other encryption method e.g. IPsec and send the data to the API server. The data may also be removed from the storage e.g. popped from the queue .

Having described an overview of service monitoring an example process will now be described. conceptually illustrates a process that some embodiments implement to monitor services that an application is using. Particularly the process shows capturing data regarding a service call and sending the captured data e.g. along with other data to a server. In some embodiments the process is performed by a service monitor.

As shown in the process begins when it starts at monitoring an application for any service calls that it makes. In some embodiments the monitoring begins when the application has been opened e.g. on a mobile device . The process determines at whether a service call has been intercepted.

When a service call has been intercepted the process gathers at data regarding the service call. In gathering the process of the some embodiments identifies various pieces of information regarding the service call. At the process determines whether a response to the call has been received. If a response has been received the process gathers at data regarding the response. If no response has been received the process of some embodiments notes at that there was no response to the call or notes that there was an error with the call e.g. via an error code .

When network service is available the process sends at the gathered data along with mobile state data and or other data to an API server e.g. when network service is available . The process determines at whether to continue monitoring. Here the application might be closed by user or the device is locked turned off or placed in stand by mode. If the determination is made to continue monitoring the process returns to which is described above. Otherwise the process ends.

Some embodiments perform variations on the process . The specific operations of the process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Further the process could be implemented using several sub processes or as part of a larger macro process.

Many more examples of the service monitor are described below. Specifically Section I describes examples of how the service monitor can be implemented on a particular mobile device platform. This is followed by Section II that describes examples of how the service monitor can be implemented on a different mobile device platform. Next Section III then describes an example performance monitoring tool with the service monitor as well one or more different error monitors. Finally Section V describes electronic systems for implementing some embodiments of the invention.

As mentioned above the service monitor of some embodiments operates different types of mobile devices to monitor one or more services that applications are using. An example implementation of the service monitor will now be described by reference to . In these figures the service monitor is implemented on a particular mobile device operating system OS namely iOS that is developed and distributed by Apple Inc. However one of ordinary skill in the art would understand that the service monitor could be implemented on various other mobile device platforms following one or more of the techniques described below.

The network monitor initializer of some embodiments is a component that determines which one or more entities e.g. classes objects in the application are responsible for making network requests. To make such a determination the network monitor initializer may read one or more lists e.g. application execution binary or bundle list and identify each class that it is interested in to produce a filtered list.

In some embodiments the network monitor initializer performs several different levels of filtering. In particular the network initializer may perform a first level filtering to identify one or more classes. The network initializer of some embodiments identifies all classes from the initial set of lists e.g. the bundle list . In some embodiments the initial filtering is done to identify all classes and or objects that are provided by application developer rather than the mobile OS provider. This is because the application bundle list lists items that are specific to the application. Also it is important to only identify the classes provided by the application developer because it may be against the policy of the mobile OS provider to modify their code e.g. APIs libraries frameworks etc. .

In some embodiments the network initializer performs a second level filtering to identify one or more different types of classes. The network initializer of some embodiments identifies delegate classes. The network initializer of some embodiments identifies classes that implement an interface e.g. a Java interface . The network initializer of some embodiments identifies each class that inherits off another class and implements one or more of the parent s methods or functions.

In some embodiments the network initializer performs a second level filtering to identify one or more specific classes e.g. delegate classes relating to network services. The different levels of filtering can occur at different operational stages of the application. As an example the first level filtering can occur when the application is initializing when opened and the second level filtering can occur when the application has been initialized. To perform such filtering the network monitor initializer includes a loading module and a set of filtering agents .

The loading module of some embodiments performs a first level filtering to identify all classes. One or more of the filtering agents may identify certain type of classes. In some embodiments the loading module is a modified version of the load method but practitioners of the art will understand that other alternatives in other embodiments could be used for the same loading purpose. The output of the load method is the application runtime data which is read by the application runtime engine during the execution of the application. This load method along with initialize is tied to the early stages in the loading sequence of an objective C program.

In some embodiments the output of the loading module is a list of one or more classes not shown . This list is then read by the set of filtering agents to perform the one or more additional levels of filtering. In some embodiments the set of filter agents identifies certain types of classes. For instance the set of filtering agents may identify delegate classes or objects. A delegate object is an object that acts on behalf of or in coordination with another object when an event is encounter in a program. The set of filtering agents identifies such delegate classes because they may implement one or more methods associated with network requests. For instance in Objective C many objects which are responsible for making network requests are delegate objects of the NSURLConnection class. The NSURLConnection is a class provided by Apple Inc. to implement an interface for creating and canceling a network connection.

In some embodiments the identifying of a certain type of class or object includes analyzing data associated with the class. For instance the set of filtering agents of some embodiments identifies delegate classes by determining whether a class implements a particular protocol or has a particular protocol declaration. For instance in Objective C many objects which are responsible for making network requests are delegate objects of the NSURLConnection class. The NSURLConnection is a class provided by Apple Inc. to implement an interface for opening and closing a network connection. The protocol associated with the NSURLConnection class is NSURLConnectionDelegate This protocol defines the optional methods implemented by delegates of NSURLConnection objects.

Alternatively or conjunctively with identifying certain types of classes and or objects the set of filtering agents may perform other filtering on the output list from the loading module . In some embodiments the set of filtering agents narrows the list to one or more specific classes. This can entail removing certain classes from the list that should not be modified and or removing classes that are associated with the service monitor. As an example it may be predetermined that a particular class e.g. UIWebView runs off the main thread and should not be modified. The set of filtering agents may also identify one or more other classes that inherit from that particular class. This is to ensure that the service monitoring code does not adversely affect the application code. As another example the set of filtering agents might identify that a delegate class should not be in the list because the class is provided by the mAPM solution provider to track and monitor network services applications crashes handled exceptions etc. In other words the set of filtering agents removes such classes so that it does not monitor itself e.g. in making network requests to the API server .

As shown in the output of the set of filtering agents is a class list cache . The swizzling module is a component of the network monitor that is responsible for injecting the service monitor code e.g. wrap those entities to trap the network requests . In some embodiments the swizzling module accomplishes this by reading the class list cache and performing swizzling or monkey patching.

In some embodiments the swizzing module performs method swizzling. The method swizzling entails swapping out an original method e.g. application method with a new method e.g. the network service monitor method and then calling the original method e.g. application method . For certain programming languages method swizzling entails notifying the runtime engine or program execution engine e.g. virtual machine to call the new method instead of the original method. The method swizzling may also entail modifying the runtime code file or library so that the runtime engine calls the new method.

In some embodiments the swizzling module performs monkey patching. The monkey patching extends or modifies the run time code of certain programming languages without altering the original source code of the application. In some embodiments the monkey patching refers to dynamic modifications of a class or module at runtime. There are other ways of modifying classes at runtime have different names based on their different intents. As an example security patching in some systems are often delivered using dynamic class modification but they are called hot fixes.

In the example of the swizzling entails notifying the application runtime engine to call the network monitor method instead of some other original method that would normally be called. The swizzling is done here to extend or modify the run time code of dynamic languages without altering the original source code. In essence the swizzling results in the service monitor method wrapping the original method. Once wrapped the network service monitor method extends or modifies the run time behavior of the application by capturing data relating to each network service request made by the application. In some embodiments the swizzling module reads the class list cache to identify one or more delegate classes and modifies the runtime data. Specifically the swizzling module modifies the runtime data so that the runtime engine calls one or more service monitor methods instead of one or more corresponding methods of the delegate classes.

The network monitor includes a set of one or more network monitor methods. Each method is similar to the service call wrapper that is described above by reference to . The network monitor method intercepts a network call. Without the swizzling the runtime engine would normally call the application method. However after the swizzling the network call that would normally be directed towards the application method is now directed towards the network monitor method. Upon interception the network monitor method of some embodiments captures network call data and redirects the network request to the application delegate method.

The mobile device state data collector is responsible for aggregating state data relating to the mobile device. For instance each service monitoring message may include a chunk of metadata about the mobile device as well as data e.g. performance data relating to the call. In some embodiments the mobile state data can include any one or more of the following carrier info e.g. the name or identity of the wireless carrier that is servicing the mobile device geo location information e.g. latitude longitude network connectivity information e.g. whether the device was on Wi Fi cellular or not connected mobile network code MNC mobile country code MCC roaming time battery level memory usage up time whether the device is jailbroken or rooted mobile OS version and mAPM service monitor version.

The output agent is responsible for sending captured data e.g. network monitoring message to the API server. The output agent may send the data immediately or may send the data when triggered. For instance the data may be sent on a periodic basis. The frequency of this period is set by the API server in some embodiments. Alternatively the data may be sent immediately when it is ready to be popped from the data queue. In some embodiments the output agent only sends the data when all the necessary data has been aggregated e.g. in the data queue . The output agent of some embodiments sends the data in a particular order e.g. in the order the service call has been invoked .

Prior to sending the captured data the output agent may also aggregate other data and merge it with the captured data. These other data provide additional context relating to the network request. For instance the output agent might aggregate data relating to the make and or model of the mobile device the version of the OS that is running on the mobile device the device ID the application version etc. Several examples of such additional context data will be described in detail below by reference to .

The storage stores captured service call data. In some embodiments the storage stores other data such as mobile state data. In some embodiments the storage is a queue. In some embodiments the storage is a data queue. In some embodiments the storage is a priority queue. In some embodiments the storage is a first in first out FIFO queue that preserves the order of the different service calls. In other words each call data will be processed or output in the order that it was put into the queue. In some embodiments the storage is a serial queue in that it does not process multiple data request in parallel. Instead it process one data request at a time e.g. in the order that the request was received . In some embodiments the serial queue is used to ensure that each dataset relating to a service call is associated with the appropriate mobile device state. For instance a mobile device s state can change often. The serial queue ensures that with all the state changes the captured service call data is synchronized with the correct mobile state data.

Having described several components of the example architecture the operations of these components will now be described in the following sub sections by reference to . In particular Section I.B describes operations of the network monitor initializer . This is followed by Section I.C that describes operations of the swizzling module . Example operations of the network monitor method are described in Section I.D. The operations of the mobile device state data collector are described in Section I.E. Lastly Section I.F described operations of the output agent in gathering other data for the network call report and sending the report to the API server.

As method above the network monitor initializer of some embodiments is a component that determines which one or more entities e.g. classes objects in the application are responsible for making network service requests. To make such a determination the network monitor initializer may read one or more lists e.g. application execution binary bundle list or some other list and identify each class that it is interested in to produce a filtered list.

As mentioned above the network monitor initializer of some embodiments performs several different levels of filtering. provides an illustrative example of such multi level filtering. The figure shows two operational stages and of the network monitor initializer . The network monitor initializer includes the loading module and the set of filtering agents which are described above by reference to .

The different levels of filtering can occur at different operational stages of the application. The first stage illustrates the network monitor initialization performing the first level filtering on application initialization. Specifically the loading module iterates through the application execution binary or the bundle list and outputs the global class list .

The second stage illustrates the network monitor initializer performing one or more other levels filtering after the initialization of the application. As shown the set of filtering agents iterates through the global class list to output the class list cache. In some embodiments the second level filtering occurs after the loading module e.g. the load method has completed its operations in loading the runtime data. For instance the second level filtering may begin after the load method and one or more other methods e.g. initialize has completed their respective tasks.

The loading module of some embodiments takes advantage of the fact the application execution binary is read when the application is being initialized and attempts to perform at least one level identification at this initialization stage. On the other hand the set of filtering agents may only be available after they have been initialized and ready to be executed by the runtime engine not shown . The initialization stage is also a fragile environment in that the application is initializing or in other words trying to load the different items e.g. classes objects etc. to be executed by the runtime engine. Therefore performing additional one or more levels of filtering may not even be possible at this initialization stage.

As shown in the application execution binary lists different items that the application requires for successful operation. The application execution binary may list executables resource other supported files etc. The bundle list may also list one or more delegate classes. Although the binary is conceptually shown as one data structure it can encompass multiple data structures or files in some embodiments. In the example of the application execution binary lists N number of items including three classes .

The first stage illustrates the loading module iterating through the application execution binary . Specifically the loading module has identified that a list item is a class and adds it to the global class list .

The second stage illustrates the loading module identifying class or object from the application execution binary . Here the loading module adds the class to the global class list . The third stage illustrates the loading module identifying another class or object from the application execution binary . The next item is another class . So the loading module adds the class to the global class list . Here the loading module may continue processing the application execution bundle list to identify other classes and or objects.

The first stage illustrates the set of filtering agents identifying the delegate classes that implement one or more methods relating to a network service. Particularly in the first stage the filtering agent has identified that the delegate class is associated with a network service and added the delegate class to the class list cache . In some embodiments the filtering agent makes this identification based on whether the class implements a particular protocol specified for a particular network connection e.g. the NSURLConnection protocol . Alternatively the set of filtering agents can make the identification based on whether the class implements one or more methods relating to the network service.

The second stage illustrates the set of filtering agents iterating through the list . Here the set of filtering agents selects the next class from the list . The next class is not a delegate class. According the loading module does not add the class to the class list cache .

The third stage illustrates the set of filtering agents identifying a delegate class that should not be modified. As such the set of filtering agents do not add the delegate class to the class list cache . As mentioned above it may be predetermined that a particular class runs off the main thread and should not be modified. In the example of the third stage the class is a delegate but it implements or inherits UIWebView. The UIWebView is a class to embed web content in the developer s application. However it may be predetermined that modifying such a class or a sub class thereof may result in instability of the application as it runs off the main thread.

The fourth stage illustrates the set of filtering agents identifying another delegate class that should not be modified. Here the set of filtering agents has identified that the delegate class is associated with the network monitor. For example even though the delegate method might implement for a particular connection e.g. the NSURLConnection the class may belong to the network monitor or some other class relating to the network monitor. In other works the set of filtering agents might identify that a delegate class should not be in the list because the class is provided by the mAPM solution provider to track and monitor network services applications crashes handled exceptions etc. The set of filtering agents do not add such delegate class so that it does not monitor itself e.g. in making network requests to the API server .

In the example described above the set of filtering agents identified one or more delegate classes. The set of filtering agents identifies such delegate classes because the example relates to Objective C. However the set of filtering agents might identify the same or different type of class for other programming languages. For instance the loading module may identify one or more sub classes or interfaces if the application was written primarily in a different high level object oriented programming language such as Java C etc.

Also in the example described above the network monitor initializer performs multi level filtering to identify a list of classes e.g. delegate classes sub classes interfaces or any other classes that implements service oriented methods or functions . In some embodiments the network initializer may only perform one level of filtering e.g. on or after application initialization . In some embodiments the network monitor may save the list and reuse it each time the application is opened. Alternatively the network monitor may save a list based on the first level filtering and reuse that list to perform the second level filtering or save a list based on the second level filtering and reuse that list to perform a third level of filtering and so on.

Having described an example of network monitor initialization an example process will now be described by reference to . conceptually illustrates a process that some embodiments use to initialize the network monitor. In some embodiments the initialization entails identifying one or more classes or objects. Once identified the network monitor wraps one or more methods from each class to track and monitor service calls. The process of some embodiments is performed by a network monitor initializer.

The process begins when it identifies at a set of classes to define a list of classes which is also referred to as a global class list. At the process identifies from the set of classes one or more classes e.g. delegate classes to cache. The process removes at each class that belongs to the network monitor from the global list. The process also removes at each class that should not be monitored or modified. The process then caches at the remaining one or more classes in the global class list. The process then ends.

Some embodiments perform variations on the process . The specific operations of the process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Further the process could be implemented using several sub processes or as part of a larger macro process.

As mentioned above the swizzling module is a component of the network monitor that is responsible for injecting the service monitor code e.g. wrap those entities to trap the network requests . In some embodiments the swizzling module accomplishes this by reading the class list cache and performing method swizzling or monkey patching.

The first stage illustrates the class list cache and the runtime library . As shown the class list cache includes a number of delegate classes and . These are same classes that the network monitor initializer has determined to be the classes whose runtime behavior should be modified. The runtime library represents data that is to be read by the runtime engine during runtime. The runtime library includes several methods or functions used by the runtime engine to define the behavior of the application during runtime. To simplify the description the runtime library is shown as listing several application delegate methods but it can include many more items or even fewer items. Also the format of the runtime library may be different or can change depending on the type of runtime engine. In other words different runtime engines read different runtime data and the runtime data can be in various different formats.

The second stage shows the swizzling module modifying the runtime library . Specifically the swizzling module identifies the delegate class from the class list cache . Based on the identification the swizzling module then identifies a particular method associated with the class. The swizzling module then replaces that particular method with the network monitor s method .

The third stage shows the swizzling module replacing another application method with a particular network monitor method. Here the swizzling module has already identified the delegate class using the class list cache but decided that there was more than one application method that should be replaced in the runtime library. Accordingly the swizzling module then replaces another method with the network monitor s method .

The fourth stage shows the swizzling module replacing another application method with a particular network monitor method. Here the swizzling module has identified the delegate class using the class list cache . The swizzling module then replaces the delegate class s method with the network monitor s method .

The runtime engine reads the runtime library to control the operations of the application during runtime. For instance the runtime engine might read the runtime library and call the network mentor method rather than the native application class method. The network class delegate method then extends the functionality of the application delegate method by capturing data relating to the network service request. The network class method then calls the application delegate method. This is conceptually shown in with several arrowed lines that represents different calls. For each new network service call the runtime engine directs the call to the network monitor class delegate method and the network monitor delegate method directs the call the app class delegate method. The crossed out arrow indicates that the runtime engine does not directly invoke the app class method when there a network access is needed.

By altering the runtime behavior the swizzling results in the network monitor method wrapping the original method. Once wrapped the service monitor method extends or modifies the run time behavior of the application by capturing data relating to each network service request made by the application. shows an example of an application method prior to being wrapped by a network monitor method. In particular shows the original application method that would be called. The method may receive an input and output some value. Depending on the application method the input may simply be the name of the method or function call without any parameter. In some embodiment the input to the method is a network service request e.g. HTTP request and the output is the response to the network service request e.g. HTTP response . Also depending on how the method is coded the application method may not have any output value.

Having described an example of swizzling an example process will now be described. conceptually illustrates a process that some embodiments use to instrument one or more methods to track and monitor service calls. In some embodiments the instrumentation results in an application runtime engine calling at least one network monitor method instead of the application method. The network monitor method then performs its accounting or tracking operations and calls the application method. In some embodiments the process is performed by a network monitor.

The process begins when it identifies at a class that is associated with the application. The class may be a delegate class that implements a particular method. The process identifies at a method associated with the class. The process then instruments at the identified method. Here the process of some embodiments is specifying that the application runtime engine to call the network monitor method instead of the application method. In specifying the process may modify one or more items e.g. a runtime library which the runtime engine uses to execute the application.

At the process determines whether there is another method to instrument for the identified class. If so the process returns to which is described above. Otherwise the process determines at whether there is another class to examine. If there is another class the process returns to which is described above. If there are no additional classes the process ends.

Some embodiments perform variations on the process . The specific operations of the process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Further the process could be implemented using several sub processes or as part of a larger macro process.

The network monitor of some embodiments captured data relating to a network service call and sends the captured data to an API server. In some embodiments the network monitor captures mobile state data and sends the mobile state to the API server along with the service call data. The network monitor of some embodiments collects other contextual data and sends the contextual data along with the captured data. Several examples of capturing and aggregating such data will now be described by reference to

The network monitor of some embodiments captures data relating to a network service call and sends the captured data to an API server. The data may be captured at the input of the network service request. Alternatively or conjunctively with input data the network monitor may capture data relating to the response to the network service request. An example of capturing data associated with a network service request will now be described by reference to . These figures are followed by which show an example of capturing data associated with a response to the network service request.

The second stage illustrates the mobile device after the user has inputted an address into the field. As shown the user taps on a button . This causes the web based application to generate a request based on the user input and send the request to a web server .

The second stage shows the network monitor after it has intercepted the network service request. Specially the network service request is passed to the parser . The request is then parsed by the parser and then stored as a request object . The parser then parses the request to identify one or more pieces of associated with the request. In some embodiments the parser identifies an address associated with the service request the type of method the amount of data sent with the request e.g. in bytes and or other data in the request e.g. request headers body and or trailer . The third stage shows the network monitor method calling the application method .

In some embodiments the network monitor not only derives information from the request but also is informed of other data. For instance the network monitor may store with the request object a timestamp. In some embodiments the timestamp records the date and time the request was processed by the network monitor. This can be the time at which the request data was recorded. Alternatively the timestamp can be recorded when the network request was received by the network monitor method when the network request was forwarded to the application method or when the network request was processed by the application method. In this manner the least amount of processing time on the application s end is factored into different measurements such as latency response time etc.

The second stage shows the network monitor after it has intercepted the network service response. Specially the network service response is passed to the parser . The response is then parsed by the parser and then stored with the request data as the request object. The parser parses the response to identify one or more pieces of data associated with the request. For instance the network monitor may record the time of the request and the time of the response to compute latency. In some embodiments latency is measured from first byte sent to first byte received. Alternatively or conjunctively with such timestamps the network monitor may capture other data such as an address URL associated with the request the amount of data sent e.g. bytes sent with the request the amount of data received with the response an error code in the response etc.

In some embodiments the network service request is an HTTP request and the response is an HTTP response to the HTTP request. conceptually illustrates an example of a request object that encapsulates data relating to an HTTP request and an HTTP response. The network monitor includes the network monitor method and the parser . The network monitor method intercepts the network request and response and passes them to the parser . In the second stage the parser then parses the request and the response to identify data that defines the request object . The third stage shows the network monitor method calling the application method .

In the example of the request object includes various data relating to the HTTP request and the HTTP response. Specifically with relation the request header data the request object has a web address or URL the type of HTTP method e.g. GET POST HEAD DELETE PUT and the content length that indicates the size of the entire body of the request. Alternatively or conjunctively with one or more of the request header data listed above the network monitor may identify other request header data such as Content Type i.e. MIME type of the body of the request .

With relation the response header data the request object has the content length that indicates the size of the entire body of the request i.e. content body and the status of the response e.g. 200 OK . Alternatively or conjunctively with one or more of the request header data listed above the network monitor may identify other response header data such as Content Type i.e. MIME type of the content Content Encoding Content Language etc.

In some embodiments the network monitor identifies several timestamps to measure latency. For instance when the network monitor receives a network request it might record the current time. Also when the network monitor receives a response it might again record the current time. The two timestamps are then used by the network monitor to calculate latency. In some embodiments the network monitor records the time immediately after it intercepts the response. In this manner additional processing on the application s end does not factor into different measurements such as latency and response time. The calculation of latency may be offloaded to the API server in some embodiments.

The network monitor of some embodiments analyzes the network request and or the response to specify its own code e.g. error code . As an example the network monitor may determine that there was no response to the request and specify a particular internal error code. Such internal error codes are used by the API server to provide a more detailed error report in relation to network service usage by an application in some embodiments.

To provide additional context regarding the network request the network monitor of some embodiments gathers mobile state data. The mobile state data can include any one or more of the following carrier info e.g. the name or identity of the wireless carrier that is servicing the mobile device geo location information e.g. latitude longitude network connectivity information e.g. whether the device was on Wi Fi cellular or not connected mobile network code MNC mobile country code MCC roaming time battery level memory usage up time whether the device is jailbroken or rooted mobile OS version and mAPM service monitor version.

In some embodiments each time there is a change in the mobile device state the network monitor updates the state data. This is to ensure that the request object is associated with the latest state. provide an illustrative example of the network monitor updating the mobile state data. Specifically shows changes in network connectivity of the mobile device. This is followed by which shows how the network monitor gathers the mobile state data in accord with the changes in the network connectivity.

Three operational stages of the mobile device are shown in . In the first stage the mobile device has been turned on and the application has been opened. The mobile device s touch screen display also shows a status bar of the mobile operating system. The status bar has a label or icon that indicates that the mobile device is on a Wi Fi network.

The second stage shows a change in the network connectivity of the mobile device. The mobile device is no longer connected to the Wi Fi network. Here the mobile device is not connected to the cellular network as well. This is conceptually shown with the Wi Fi label of the status bar in first stage that is being replaced with a No Service label in the second stage .

The third stage shows another change in the network connectivity of the mobile device. The mobile device is now on the cellular network. This is conceptually shown with the No Service label of the status bar in second stage that is being replaced with a Cellular 4G label in the third stage .

The first stage corresponds to the first stage of the previous figure. Here it shows the mobile device state data collector updating the connectivity info in the data queue . Specially the mobile device state data collector has been notified that the mobile device is connected to the Wi Fi network. The mobile device state data collector updates the connectively info in the data queue . This is conceptually shown in the first stage as the connectivity info now reads on Wi Fi .

The second stage corresponds to the second stage of the previous figure. Here it shows the mobile device state data collector once again updating the connectivity info in the data queue . Specially the mobile device state data collector has been notified that the mobile device is not connected any network. As such the mobile device state data collector updates the connectively info in the data queue . This is conceptually shown in the second stage as the connectivity info now reads not connected .

The third stage corresponds to the first stage of the previous figure. Here it shows the mobile device state data collector yet once again updating the connectivity info in the data queue . Specially the mobile device state data collector has been notified that the mobile device is now connected to the cellular network. As such the mobile device state data collector updates the connectively info in the data queue . This is conceptually shown in the third stage as the connectivity info now reads on cellular .

In the example described above the network monitor updates the connectivity info in the storage e.g. in the data queue . However one of ordinary skill in the art would understand that the example is equally applicable to other mobile state data including carrier info e.g. the name or identity of the wireless carrier that is servicing the mobile device geo location information e.g. latitude longitude network connectivity information e.g. whether the device was on Wi Fi cellular or not connected mobile network code MNC mobile country code MCC roaming time battery level memory usage up time whether the device is jailbroken or rooted mobile OS version and mAPM service monitor version. For instance when the application is open the mobile device state data collector may update the geo location info each time there is a detectable change in the physical location of the mobile device . Similarly when the application is open the mobile device state data collector may update carrier info each time there is a detectable change in the carrier that is providing services for the mobile device .

In some embodiments the network monitor updates or replaces a mobile device state if is not associated with another. This is to ensure that each network service request report is associated with that state of the mobile device at the time the request was processed e.g. when the request was intercepted . provide an illustrative example of the network monitor not updating or replacing a mobile device state because the state is associated with a network request report. Specifically illustrates a network request being made by the application while the state of the mobile device is changing. This is followed by which shows that the network monitor does not update or replace a mobile device state if that state is associated with service call data.

Three operational stages of the mobile device are shown in this figure. In the first stage the mobile device has been turned on and the application has been opened. The mobile device s touch screen display also show a status bar of the mobile operating system. The status bar has a label or icon that indicates that the mobile device is on a cellular network. In this example the user performs a touch based gesture over the device s touch screen display to select an application button. The selection triggers a network service request to retrieve a web page.

The second stage shows that the user request to retrieve the web page has been completed. This is shown with the web page on the device s screen. The second stage also shows a change in the network connectivity of the mobile device. The mobile device is no longer connected to the cellular network. Here the mobile device is now connected to the Wi Fi network. This is conceptually shown with the Cellular 4G label of the status bar in first stage that is being replaced with a Wi Fi label in the second stage .

The third stage shows another change in the network connectivity of the mobile device. The mobile device is now returned to the cellular network. This is conceptually shown with the Wi Fi label of the status bar in second stage that is being replaced with a Cellular 4G label in the third stage .

The first stage corresponds to the first stage of the previous figure. Here it shows the mobile device state data collector updating the connectivity info in the data queue . Specially the mobile device state data collector has been notified that the mobile device is now connected to the cellular network. The mobile device state data collector updates the connectively info in the data queue . This is conceptually shown in the first stage as the connectivity info reads on Cellular .

The second stage corresponds to the second stage of the previous figure. Here the network monitor method has intercepted and stored data regarding the network request as a request object in the data queue. The request object is stored with or associated with the previously stored connectivity info .

After capturing the data in the second stage the mobile device state data collector is notified of an update to the connectivity info. Specially the mobile device state data collector has been notified that the mobile device is now connected to the cellular network. As shown the mobile device state data collector does not update the state that is associated with the request object . Instead the mobile device state data collector simply stores it in the data queue. Note that the request object and the associated state have not been popped from the data queue . This may be because some embodiments send capture data in a periodic basis and the frequency may be specified by the mAPM provider. Such similar situation may also occur when there is no network connection.

The third stage corresponds to the third stage of the previous figure. Here the data queue has been popped and the request object and the network connectivity info has been packaged as a service call report and sent to the API server. The third stage also shows another change in the network connectivity of the mobile device . The mobile device has now returned to the cellular network. As such the mobile device state data collector updates the connectively info in the data queue . This is conceptually shown in the third stage as the connectivity info now reads on cellular . Different from the previous stage the mobile device state data collector updates a previously stored state. This is because the previously stored state was not associated with captured service call data.

In addition to mobile state data or instead of it the network monitor may collect other data that provide additional context regarding each network service call. conceptually shows an example of gathering additional context data for the network service call report. Two operational stages and of an application performance monitor are shown in this figure. As will be described below by reference to . The network monitor of some embodiments is one of several different monitoring tools that are provided by the mAPM provider. In this example the network monitor a set of data collectors and the output agent are shown inside the application performance monitor box. This is to provide a visual indication that these components are tools of the application performance monitor .

The first stage of shows the application performance monitor gathering data. Although the figure shows several arrowed lines with numbers that indicate some sort of a sequence. The actual sequence may be different because each component could be gathering different data at different time. As shown the set of data collectors gather additional contextual data and stores it in storage . In this example the context data includes application ID the version number of the application a username etc. The username can be a user ID an email address login name e.g. to access a user account associated with the application or a cloud service or any other string identifying a user.

The first stage also shows the network monitor capturing request data and mobile state data. Specifically the mobile device MD state data collector has been informed about an update in the mobile device state and stored data regarding the update in the data queue . The network monitor method has also intercepted a network call and stored a request object relating to the network call in the data queue .

The second stage shows a network request report being sent to the API server from the application performance monitor . In particular the output agent retrieves e.g. pops a dispatch queue to retrieve the request object and the mobile device state data. The output agent also gathers additional contextual data from the storage. The output agent then packages or formats the gathered data as one or more network request reports or messages . Thereafter the output agent sends each report to the API server.

In some embodiments the performance data includes an address or URL a sample timestamp e.g. the time at which the performance information was recorded latency e.g. the time it took to complete the network transaction active network e.g. either on Wi Fi on cellular unknown or not connected bytes in e.g. the number of bytes received from the server in the network transaction bytes out e.g. the number of bytes sent to the server in the network transaction status code e.g. status code returned from the server error codes e.g. internal error code that is used to display error information on the server end location e.g. Latitude and longitudinal coordinates . In some embodiments latency is measured from first byte sent to first byte received. This sort of measurement is often referred to as round trip latency and does not factor in the processing that can occur on the server side.

In the example described above the report to the API server includes various items. One of ordinary skill in the art would understand that the report is an example report. Different embodiments can choose different pieces of data for such a report. For instance the actual report that is sent may include additional data or even fewer data. The report may even include other data that is not shown in the list such as content type e.g. MIME type content encoding content language etc.

At the process gathers data regarding the network call including any response received for the network call. For instance when a network service is requested by the application the process might captures data relating to the network service request. If there is a response to the service request the process might also capture data relating to the response. Here the process may record the time of the request and the time of the response to compute latency. In some embodiments latency is measured from first byte sent to first byte received. Alternatively or conjunctively with such timestamps the process may capture other data such as an address URL associated with the request the amount of data sent e.g. bytes sent with the request the amount of data received with the response an error code in the response etc.

At the process gathers data other contextual data. For instance when the process is ready to send a report regarding a service call the service monitor might add to the report an application ID the version number of the application a device ID the model of the mobile device the version number of the mobile operating system OS etc. The process then sends at the gathered data to the API server. The process then ends.

Some embodiments perform variations on the process . The specific operations of the process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Further the process could be implemented using several sub processes or as part of a larger macro process.

The previous section described various examples of how the service monitor can be implemented on a particular mobile device platform such as iOS by Apple Inc. The following section describes example implementations of the service monitor on a different mobile device platform such as Android OS by Google Inc. One of the main differences between the two mobile OSs is that they each use a different programming language as a primary language to code applications. For instance the iOS promotes Objective C through its application programming interfaces APIs while the Android OS promotes Java through its respective APIs. Accordingly some of the techniques described in this section conform to the programming constructs of the Java programming language. However one of ordinary skill in the understand that the examples in this section or the previous section can be applied to any mobile device platform using any high level programming language such as C C etc.

The monitored connection object is a component of the network monitor that is responsible for capturing data relating to an open network connection. In particular the monitored connection object wraps a connection object to read data regarding a network service call made by the application. For instance the monitored connection object may read the output stream data associated with connection object to capture data relating to a network service request. The monitored connection object may read the input stream data associated with connection object to capture data relating to a response to the network service request.

In some embodiments the monitored connection object wraps a high level connection object. The high level connection object may be capable of handling one or more different communication protocols such as Hypertext Transfer Protocol HTTP File Transfer Protocol FTP etc. An example of such a high level connection object is URLConnection class that is provided by Java. The high level connection object may also include a number of pre defined methods to read specific pieces of information e.g. URL address Content Length etc. associated with the network request and response.

The network monitor of some embodiments provides the monitored connection object that wraps a lower level connection object. In some embodiments the lower level connection operates at the socket level. As such the lower level connection object may not have a number of pre defined methods to read specific pieces of information e.g. URL address Content Length etc. associated with the network request and the response to the request.

To capture data from such streams the network monitor some embodiments includes the parser . In some embodiments the monitored connection object passes an output stream associated with the low level connection object to the parser. The parser then parses the output stream to capture data regarding a network request. In some embodiments the monitored connection object passes an input stream associated with the low level connection object to the parser. The parser then parses the input stream to capture data regarding a response to the network service request.

In some embodiments the network monitor factory object is responsible for creating a particular connection object. For instance when an application requires a network connection the application may call upon the factory object to create a new connection object. Thereafter the monitored connection object which wraps that new connection object can read the connection object s input and output streams.

In some embodiments the factory object is called each time the application requires a particular network connection. illustrates an example of how the network factory objet is called upon each time the application needs to a new connection. Specifically shows the operations of the application without the network monitor enabled. shows the operations of the same application after the network monitor has been enabled.

The second stage shows the application after the initialization. Specifically when the application needs a network connection the application calls the module . Similar to above the module makes a call to the network library to create a new socket. However in reasons to the call the library creates and or assigns the network monitor factory object to handle the connection. This is because the network monitor in the first stage network monitor initializer has informed the network library to use the network monitor factory object.

In some embodiments the network monitor factory is called by one or more higher level networking libraries. For instance in Java currently there are two primary networking libraries java.net.URLConnection and Apache s HttpClient library. Both of these libraries are built on top of the java Socket library. Both libraries create sockets by instantiating a socket with the normal java constructor new Socket . This is a built in java call. Every built in java Socket creates a SocketImpl using a global call SocketImplFactory.create . That is where the network service monitor comes in. Before any networking has started the network service monitor has installed or instrumented its own SocketImplFactory by calling Socket.setSocketImplFactory .

In the example described above the network monitor of some embodiments does not perform method swizzling or monkey patching to direct a runtime engine to call its method instead of the application s method. This is different from the example implementation shown in Section I.A where the network monitor performs method swizzling. In the example of Section II.A the network monitor provides a monitored connection object that wraps a connection object to trap data. One of the reasons that the monitored connection object of Section II.A does not perform swizzling is because Java does not support method swizzling or monkey patching. Also one reason that the swizzling is performed in the example implementation of Section I.A is because Objective C does not have a standardized factory.

As mentioned above the network monitor of some embodiments provides a monitored connection object that wraps a high level connection object. In some embodiments the network monitor provides a monitored connection object that wraps a low level connection object. Examples of such different monitored connection objects will now be described below by reference to .

The monitored connection object wraps the URLConnection object . In some embodiments the monitored connection object captures one or more pieces of information associated with a network service request. The output of the monitored connection object is the captured data regarding the network service request.

In this example the monitor socket object wraps the socket object s input stream method and output stream method . The input stream method returns an input stream for reading bytes from the socket. The output stream method returns an output stream for reading bytes from the socket. The input stream method is wrapped to tap into the object s input stream while the output stream method is wrapped to tap into the object s output stream.

The parser receives the output stream to capture one or more pieces of information associated with a network service request. The parser receives the input stream to capture one or more pieces of information associated with a response to the request. The output of the parser is the captured data regarding the network service request. In some embodiments after reading the input stream the monitor socket object performs a logging operating e.g. calls a log method to store data relating to the network service request and the response as breadcrumb data in a storage e.g. in a queue . Several examples of storing breadcrumb data are described below by reference to .

In some embodiments the network monitor utilizes both monitored connection objects and . For instance the network monitor may utilizes the monitored connection for certain types of connection e.g. HTTPS HTTP or for one or more different version of the mobile OS e.g. Android OS and may utilize the monitored socket object for all other connections. In some such embodiments the network service monitor de instruments the socket instrumentation for one or more specific types of connections e.g. connection objects that are created. For instance the network service monitor may de instrument the socket instrumentation for each HttpsURLConnection object that is created. The network service monitor may de instrument the socket instrumentation at creation time e.g. of the HttpsURLConnection object . In some embodiments the creation time represents the time the monitored application requests such a connection. The network service monitor may re instrument the socket version after the application performs the one or more network operations with the connection. In some embodiments the network monitor utilizes only one of the monitors or . For instance the network monitor may utilize the monitored socket object to capture data relating to all network service requests.

As mentioned above the network monitor some embodiments includes a parser. In some embodiments a monitored connection object passes an output stream associated with the low level connection object to the parser. The parser then parses the output stream to capture data regarding a network request. In some embodiments the monitored connection object passes an input stream associated with the low level connection object to the parser. The parser then parses the input stream to capture data regarding a response to the network service request.

In some embodiments the request line parser parses the output stream to read a first line in the request. If the first line has been successfully read the control is shifted to the request header parser . If there is an error the control is shifted to the no op state . The no op state ends the parsing of the output stream. In reading the first line the request line parser may analyze the format of the first line. If the request line parser determines that it does not recognize the first line the control is transitioned to the no op state in some embodiments. For instance the request line parser may determine from the first line of the request that output stream does not contain a properly formatted HTTP request and shift the control to the no op state .

In some embodiments the request line parser identifies one or more pieces of information from the first line of the request. Referring to the request line parser may identity the type of method e.g. GET POST etc. associated with the request and or an address e.g. URL associated with the request.

As shown in if the first line has been successfully processed the control is shifted to the request header parser . The request header parser parses each header line to identify one or more pieces of information. In some embodiments the request header parser tries to identify header values such as Content Length. This is shown in as the Content Length from the request is added to the request object . The request header parser may also identify a value associate with Transfer Encoding field. This header field indicates what if any type of transformation has been applied to the message body in order to safely transfer it between the sender and the recipient. This is important because the value associated with field allows the parser to determine whether the body is chunked. By chunked it means that the request was broken into multiple parts e.g. because the body of the request is lengthy .

As indicated by the new line arrow the request header parser is called e.g. by the request line parser or the request header parser for each new line of the header. If there is an error the control is shifted to no op state that ends the parsing of the output stream. If there is a double new line the request header parser has reached the end of the header lines. If the determination is made that the body is not chunked the control is shifted to the request body parser.

In some embodiments the request body parser does not identify any data associated with the body of the request. Instead it uses the Content Length to determine how much of the body must be read to reach the next request. When the end of the body is reached the control is shifted back to the request line parser . However if there is an error the control is shifted to no op state that ends the parsing of the output stream.

If the determination is made that the body is chunked the control is shifted to the chunked body parser . The chunk body parser reads the body of the request until it reaches the end. A chunked HTTP message may include the following tags . . . . This is opposed to a normal Transfer encoding identity message which would just have an instead of all the chunk tags. In some embodiments the purpose of the chunk body parser is to parse out the corresponding sections of the HTTP message. The chunk size parser may operate with a chunk size parser not shown in some embodiments. In some embodiments the chuck size parser counts the number of bytes that come through in the chucked body so that parser can determine when the next section starts. After reading through the chunked body the control is shifted back to the request line parser . If there is an error the control is shifted to no op state that ends the parsing of the output stream.

In some embodiments the response line parser parses the input stream to read a first line in the request. In some embodiments the response line parser does not identify any piece of information from the first line of the response. After reading the first line the control is shifted to the response header parser .

In some embodiments the response header parser identifies one or more pieces of information from the response header. In the example of the response header identifies a state code and Content Length from the request and adds the values associated with the fields to the request object . The response header parser may also identify Transfer Encoding to determine if the body of the response is chunked.

As shown in the response header parser is called e.g. by the response parser or the response header parser for each new header line. If there is a double new line the response header parser has reached the end of the header lines. If the determination is made that the body is not chunked the control is shifted to the request body parser. If the determination is made that the body is chunked the control is shifted to the chunked body parser . The chunk body parser reads the body of the request until it reaches the end. If for any reason the connection is closed the control is shifted to the done state . If the connection is not closed the control is shifted back to the response line parser .

If the determination is made that the body is not chunked the control is shifted to the response body parser . This response body parser reads the body of the request until it reaches the end. If for any reason the connection is closed the control is shifted to the done state . If the connection is not closed the control is shifted back to the response line parser .

The service monitor of some embodiments is one of several different application performance monitoring tools provided by the mAPM solution provider. shows an example architecture of an application with such performance monitoring tools. As shown in this example the application developer has enabled the application performance monitor features. For instance the application developer may have downloaded a software development kit SDK with the tools and linked the developer code with the performance monitoring code.

As shown in when the application performance monitor features are enabled the application includes the application performance monitor . The application performance monitor includes a collection of tools to monitor application performance. The application performance monitor includes the service monitor that stores service call data in storage . Several different examples of such a service monitor are described above in Sections I and II. The application performance monitor may also include a crash monitor a handle exceptions monitor and or a breadcrumb data collector .

The crash monitor of some embodiments monitors for and track unhandled exceptions. Similar to the service monitor the crash monitor may store crash data in a storage e.g. a data queue . When an unhandled exception i.e. crash occurs in the app this agent may retrieve the stack trace of code. The stack trace of code shows which line of code caused the crash. The stack trace may be sent to the API server with additional diagnostic data about the application and the device. This information allows the developer to recreate or understand the conditions of the crash. For instance the developer may be informed that a certain portion of the code in version 1.0 of the application is crashing on a particular mobile device from a particular vendor. In some embodiments the crash monitor collects any one or more of the following data types threads e.g. the lines of code that caused the crash including the stack trace and any background threads that were running type e.g. the type of crash such as unhanded exception signal crash etc. and breadcrumbs. As will be described below breadcrumb detection is a special feature a company or app developer can implement which allows them to specify a series of events that occurred before the crash occurred e.g. Pressed Login View Account Variable 0 .

The handled exception monitor of some embodiments monitors for and track unhandled exceptions. Specifically this agent allows a developer to track error conditions in an application that do not necessarily cause the application to crash. Most common use cases for handled exceptions are for tracking places in developer s code where there already exists a try catch to test third party SDKs and critical areas in the code where developer might already be adding assertions. Handled exceptions can also be used to track error events such as low memory warnings. When there is a handled exception the handled exception monitor of some embodiments collects data relating to the handled exceptions and sends it to the API server. The handled exception report may include custom value with context about the exception. Similar to the service monitor the handled exception monitor may store crash data in a storage e.g. a data queue .

The breadcrumb data collector is a special type of collector that the developer or application author can use to track changes and information about their running program. The breadcrumb data collector is customizable by the developer. For instance the developer might want to know what chain of events led to a crash in the application. So the developer can specify a list of items e.g. changes to the application such as an end user navigated to a different application tab the end user when to a screen to get a list of songs etc. .

When there is a crash the breadcrumbs are then sent with the crash report or as part of the crash report. In this manner the developer can have an understanding of the series of one or more events that occurred prior to crash. In some embodiments developers can specify what breadcrumbs they would like to track through the performance monitor tool or kit SDK . For instance the developers can leave breadcrumbs through a SDK call Service monitor leave Breadcrumb hello world . This is an example of a user defined breadcrumb. In some embodiments the service monitor captures network breadcrumbs. In some embodiments the network breadcrumbs are logged automatically when any network call happens. In some embodiments the network breadcrumbs are logged automatically but do not show up on error reports unless specified by a developer. Alternatively the network breadcrumbs may only be logged after the developer instructs the service monitor to log network breadcrumbs.

In some embodiments the service monitor is used to track only a set number of network breadcrumbs. The service monitor may only log the last several connections and not all connection. For instance the service monitor may be used to log the last ten network connections. In some embodiments the number of network breadcrumbs the service monitor logs can be customized based on user input. That is the performance monitor tools of some embodiments may allow a user to specify e.g. through the performance monitor tool or kit the maximum number of breadcrumbs to track. In some embodiments the breadcrumb data collector only retains the last several number of network breadcrumbs in a e.g. circular buffer or queue.

In some embodiments the information gathered by the service monitor regarding a service call is stored as a breadcrumb data. The breadcrumb data then is sent to the API server when there is a crash. shows an example of how data relating to a connection can be sent part of a crash report. In this example the application performance monitor includes the service monitor the breadcrumb data collector and the crash monitor . The service monitor includes the service call wrapper the parser and the output agent which are described above by reference to .

The data flow of begins when the service call wrapper intercepts a call. The server call wrapper then passes at 1 the service request and any response to the parser . The parser parses the call and any response to identity service call data . The parser then stores at 2 the service call data in the storage . When the service call data is ready to be sent the output agent may gather additional contextual data as mentioned above by reference to . The output agent then the report to the API server.

The output agent also provides at 3 and 4 the service call data to the breadcrumb data collector . The breadcrumb data collector then stores at 5 the data in the storage . If there is a crash the crash detector gathers data regarding the crash and stores it in the storage . When the crash data is ready to be sent the crash monitor retrieves at 6 the crash data from the storage. The crash monitor then retrieves at 7 the service call data from the breadcrumb storage . The crash monitor then sends at 8 a crash report with the crash data and the service call data. This association of the service call data with the crash report allows the developer to determine if there was a connection between the network event and the application crash.

In the example described above the breadcrumb data is sent with the crash report. Alternatively or conjunctively such breadcrumb data may be sent with handled exception report in some embodiments. Although shows several arrowed lines with numbers that indicate a sequence of operations. The actual sequence may be different because each component could be gathering different data at different time. Also the figure has been simplified to highlight how network connection data can be sent as part of a crash report. In addition although the shows the output agent handing the network breadcrumb to the breadcrumb data collector. The service monitor may interface with a logging module or agent not shown to store the network breadcrumb in storage . An example of a service monitoring object calling an example logging module e.g. a log data method is shown and described above by reference to .

As mentioned above the breadcrumb data collector is customizable by the developer. For instance the developer might want to know what chain of events led to a crash in the application. So the developer can specify a list of items. For instance the developer may specify tracking changes to the application such as change in data value associated with a parameter. The developer may specify tracking user interaction with the application such as an end user navigated to a different application tab the end user when to a screen to get a list of songs change in data etc. conceptually illustrate an example of capturing service call data and user interaction data as breadcrumb data. Specifically illustrates an example of a user interacting with an application. The user interaction leads to application crashing. shows an example of breadcrumb data that is captured by the breadcrumb data collector prior to the crash.

Three operational stages of the mobile device are shown in this figure. In the first stage the mobile device has been turned on and the application has been opened. In this example the application is an application to buy music. However the application can be any application or game e.g. that makes network service requests .

As shown in the first stage the user selects a button on a page of the application to navigate to a page with a list of songs. Here the first user input on the button initiates a first network request. The second stage shows that first user input caused the mobile device to display a page with a list of songs. The song page includes a number of buttons to purchase songs. The user then selects one of the buttons to purchase a song. This is the second user interaction shown in . The second user interaction also initiates a second network request. The third stage illustrates the mobile device after the second user interact. Specifically the third stage shows that the application has crashed.

The second stage illustrates several breadcrumb data being stored as a result of the second user input and second first network in the second stage of the previous figure. Specifically the breadcrumb data collector has detected the second user interaction and stored data regarding the interaction as a breadcrumb data in the breadcrumb data storage . The service monitor has also detected the second network request and stored data regarding the request in the service call data storage . The service monitor has also sent the service call data to the breadcrumb data collector . The breadcrumb data collector then stores the service call data in the breadcrumb data storage .

The third stage illustrates the crash monitor detecting the application crash and storing data relating to the crash in the crash data storage . The fourth stage shows the crash monitor retrieving the crash data from the storage . The crash monitor then retrieves the group of breadcrumbs data e.g. that relates to the two network request and the two user interactions from the breadcrumb storage . The crash monitor then sends a crash report with the crash data and the group of breadcrumb data.

As mentioned above the API server e.g. managed by the mAPM service provider generates a real time global view of application diagnostics and crashes across different mobile device platforms e.g. iOS Android Windows Phone etc. . The API server of some embodiments formats or translates the captured data e.g. the service call data mobile state data other contextual data etc. in some manner to present it to developers. For example the captured data may be presented in statistical and or in graphical format. Such a format allows developers to easily track e.g. in real time performance of one or more of their applications across different types of mobile devices Operating Systems OSs Application versions etc. This is important because the developers do not have to wait for user feedback. Instead they can access one or more of the different application performance reports determine if there are any problems and address those problems if there are any.

In this example the performance report is a trend report but can be any other type of report. In some embodiments trending represents tracking captured data over some period of time to detect and diagnose changes in the application s performance. The trends can be over different types of data. For instance the API server of some embodiments allows developers to track real time and historical performance across device OS carriers versions etc. The API server may allow developers to view trends by device OS and carrier. For developers such trends can be important from a business perspective as well as a technical perspective. From a business perspective the trends allow the developers to know which device e.g. make and or model OS e.g. version and or carrier is the most popular. From a technical perspective the trends allow the developers to know which device OS and or carrier is the most problematic across the developer s user base.

Although the performance report shows a performance report for a number of mobile devices or OSs the API server may provide a report regarding performance of the application on a single mobile device in some embodiments. This can be achieved because the API server has all the necessary metadata such as the device ID that is described above by reference to . Also the performance report can be formatted translated or presented differently using one or more of the different types of data shown in or any other captured or collected data described herein e.g. mobile network code MNC mobile country code MCC roaming time memory usage up time whether the device is jailbroken or rooted etc. . In some embodiments the API server can provide raw data that can be processed at the client device e.g. through a web component plug in or if the client device has a thick client application through the client application s code .

As shown in the report includes a device section with device trends and an OS section with OS trends. The device section lists different mobile devices by make and or model. Each one is listed with measurements or statistics such as the total number of requests e.g. request volume the average latency user base or the number of people using the application the developer s application the number of service errors and the average number of crashes. Each measurement is shown graphically and textually. The OS section has the same measurements or statistics but the section lists different versions of mobile one or more mobile operating systems. Although the figure shows several bar graphs the report may present other types of graphs e.g. a line graph pie chart etc. or other types of graphical representation e.g. media presentation or animation of the captured data.

Many of the above described features and applications are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium also referred to as computer readable medium . When these instructions are executed by one or more computational or processing unit s e.g. one or more processors cores of processors or other processing units they cause the processing unit s to perform the actions indicated in the instructions. Examples of computer readable media include but are not limited to CD ROMs flash drives random access memory RAM chips hard drives erasable programmable read only memories EPROMs electrically erasable programmable read only memories EEPROMs etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.

In this specification the term software is meant to include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments the software programs when installed to operate on one or more electronic systems define one or more specific machine implementations that execute and perform the operations of the software programs.

The service monitor of some embodiments operates on mobile devices. The applications of some embodiments operate on mobile devices. is an example of an architecture of such a mobile computing device. Examples of mobile computing devices include smartphones tablets laptops etc. As shown the mobile computing device includes one or more processing units a memory interface and a peripherals interface .

The peripherals interface is coupled to various sensors and subsystems including a camera subsystem a wireless communication subsystem s an audio subsystem an I O subsystem etc. The peripherals interface enables communication between the processing units and various peripherals. For example an orientation sensor e.g. a gyroscope and an acceleration sensor e.g. an accelerometer is coupled to the peripherals interface to facilitate orientation and acceleration functions.

The camera subsystem is coupled to one or more optical sensors e.g. a charged coupled device CCD optical sensor a complementary metal oxide semiconductor CMOS optical sensor etc. . The camera subsystem coupled with the optical sensors facilitates camera functions such as image and or video data capturing. The wireless communication subsystem serves to facilitate communication functions. In some embodiments the wireless communication subsystem includes radio frequency receivers and transmitters and optical receivers and transmitters not shown in . These receivers and transmitters of some embodiments are implemented to operate over one or more communication networks such as a GSM network a Wi Fi network a Bluetooth network etc. The audio subsystem is coupled to a speaker to output audio e.g. to output different sound effects associated with different image operations . Additionally the audio subsystem is coupled to a microphone to facilitate voice enabled functions such as voice recognition digital recording etc.

The I O subsystem involves the transfer between input output peripheral devices such as a display a touch screen etc. and the data bus of the processing units through the peripherals interface . The I O subsystem includes a touch screen controller and other input controllers to facilitate the transfer between input output peripheral devices and the data bus of the processing units . As shown the touch screen controller is coupled to a touch screen . The touch screen controller detects contact and movement on the touch screen using any of multiple touch sensitivity technologies. The other input controllers are coupled to other input control devices such as one or more buttons. Some embodiments include a near touch sensitive screen and a corresponding controller that can detect near touch interactions instead of or in addition to touch interactions.

The memory interface is coupled to memory . In some embodiments the memory includes volatile memory e.g. high speed random access memory non volatile memory e.g. flash memory a combination of volatile and non volatile memory and or any other type of memory. As illustrated in the memory stores an operating system OS . The OS includes instructions for handling basic system services and for performing hardware dependent tasks.

The memory may include communication instructions to facilitate communicating with one or more additional devices graphical user interface instructions to facilitate graphic user interface processing input processing instructions to facilitate input related e.g. touch input processes and functions. The memory may also include other instructions such as instructions to update different types of mobile device state e.g. location information carrier information network connectivity information etc. . The instructions described above are merely exemplary and the memory includes additional and or other instructions in some embodiments. For instance the memory for a smartphone may include phone instructions to facilitate phone related processes and functions. The above identified instructions need not be implemented as separate software programs or modules. Various functions of the mobile computing device can be implemented in hardware and or in software including in one or more signal processing and or application specific integrated circuits.

While the components illustrated in are shown as separate components one of ordinary skill in the art will recognize that two or more components may be integrated into one or more integrated circuits. In addition two or more components may be coupled together by one or more communication buses or signal lines. Also while many of the functions have been described as being performed by one component one of ordinary skill in the art will realize that the functions described with respect to may be split into two or more integrated circuits.

The bus collectively represents all system peripheral and chipset buses that communicatively connect the numerous internal devices of the electronic system . For instance the bus communicatively connects the processing unit s with the read only memory the GPU the system memory and the permanent storage device .

From these various memory units the processing unit s retrieves instructions to execute and data to process in order to execute the processes of the invention. The processing unit s may be a single processor or a multi core processor in different embodiments.

The read only memory ROM stores static data and instructions that are needed by the processing unit s and other modules of the electronic system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instructions and data even when the electronic system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device .

Other embodiments use a removable storage device such as a floppy disk flash memory device etc. and its corresponding drive as the permanent storage device. Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments the invention s processes are stored in the system memory the permanent storage device and or the read only memory . From these various memory units the processing unit s retrieves instructions to execute and data to process in order to execute the processes of some embodiments.

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the electronic system. The input devices include alphanumeric keyboards and pointing devices also called cursor control devices cameras e.g. webcams microphones or similar devices for receiving voice commands etc. The output devices display images generated by the electronic system or otherwise output data. The output devices include printers and display devices such as cathode ray tubes CRT or liquid crystal displays LCD as well as speakers or similar audio output devices. Some embodiments include devices such as a touchscreen that function as both input and output devices.

Finally as shown in bus also couples electronic system to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the Internet. Any or all components of electronic system may be used in conjunction with the invention.

Some embodiments include electronic components such as microprocessors storage and memory that store computer program instructions in a machine readable or computer readable medium alternatively referred to as computer readable storage media machine readable media or machine readable storage media . Some examples of such computer readable media include RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives read only and recordable Blu Ray discs ultra density optical discs any other optical or magnetic media and floppy disks. The computer readable media may store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations. Examples of computer programs or computer code include machine code such as is produced by a compiler and files including higher level code that are executed by a computer an electronic component or a microprocessor using an interpreter.

While the above discussion primarily refers to microprocessor or multi core processors that execute software some embodiments are performed by one or more integrated circuits such as application specific integrated circuits ASICs or field programmable gate arrays FPGAs . In some embodiments such integrated circuits execute instructions that are stored on the circuit itself. In addition some embodiments execute software stored in programmable logic devices PLDs ROM or RAM devices.

As used in this specification and any claims of this application the terms computer server processor and memory all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification the terms display or displaying means displaying on an electronic device. As used in this specification and any claims of this application the terms computer readable medium computer readable media and machine readable medium are entirely restricted to tangible physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals wired download signals and any other ephemeral signals.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. Also while many of the features of the service monitor have been described as being performed by one component or module e.g. the output agent the mobile device state data collector etc. one of ordinary skill in the art will recognize that the functions of such components described herein might be split up into multiple sub components. Similarly functions described as being performed by multiple different components might be performed by a single component in some embodiments. Further while many of the features of the service monitor have been described as being performed by one module e.g. the output agent the mobile device state data collector etc. one of ordinary skill in the art will recognize that the functions of such components described herein might be split up into multiple components. Similarly functions described as being performed by multiple different components might be performed by a single component in some embodiments. In addition a number of the figures including conceptually illustrate processes. The specific operations of these processes may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. Thus one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details but rather is to be defined by the appended claims.

