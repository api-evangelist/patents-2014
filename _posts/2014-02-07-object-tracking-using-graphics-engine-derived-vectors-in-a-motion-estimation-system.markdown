---

title: Object tracking using graphics engine derived vectors in a motion estimation system
abstract: A method and apparatus are provided for motion estimation in a sequence of images. One or more motion vectors representing movement of a camera or viewer position or direction are determined between each pair of fields or frames in the sequence of images. A set of candidate motion vectors is then determined for deriving positions of objects in a field or frame from the positions of objects in a previous field or frame. This set of candidate motion vectors is adjusted using the motion vectors representing movement of camera or viewer position and thus a set of motion vectors is derived for a sequence of images using the adjusted set of candidate motion vectors.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09100537&OS=09100537&RS=09100537
owner: Imagination Technologies Limited
number: 09100537
owner_city: Kings Langley
owner_country: GB
publication_date: 20140207
---
This invention relates to motion estimation of a sequence of input images in particular to methods associated with generating candidate motion vectors based on the orientation and position of the camera viewer.

Motion estimation the identification of motion in a sequence of images frames or video fields is well known. Existing methods of motion estimation typically consider two or more frames from a sequence and create a set of motion vectors that represents the 2D translational motion of image areas from one frame to the next. One possible technique for motion estimation is a motion search in which a previous frame is searched to find an area of the image that best matches a particular area in the current frame. The difference in the position of the two matching areas gives the motion vector at the current position.

Different systems have different requirements of the motion estimator. In a compression system such as a video encoder the requirement is to form the most compact representation of a frame by reference to a previous frame from the sequence. The requirement is generally to find motion vectors which give the best matches between areas of pixels in the current frame and the reference frame as this leads to the most compact encoding. While the resulting motion vectors are usually representative of the actual motion of objects in the scene there is no requirement that this is always the case. In other applications such as object tracking or frame rate conversion it is more important that the motion vectors represent the true motion of the scene even if other distortions in the video mean that the pixels in the corresponding image areas are not always the best possible match to each other. By applying appropriate constraints during the motion search procedure the results can be guided towards best pixel match or true motion as necessary. Collectively the set of motion vectors in a frame is known as the motion vector field for that frame. Note that use of the term vector field should not be confused with the use of field or video field to describe the data in an interlaced video sequence as described below.

While many approaches to motion estimation exist a common implementation is that of a block based motion estimator. The invention disclosed in this patent will be described by showing how it can be used with a block based motion estimator although the principles of the invention may also be applied to motion estimators of other types. In a block based motion estimator frames are subdivided typically into a regular grid of rectangular areas known as blocks or macroblocks. In a motion search procedure each block s pixel data is compared with pixel data from various candidate locations in the previous frame and a scoring function is computed for each candidate. The relative positions of the blocks with the best score gives the motion vector at the current block position.

Rather than exhaustively consider every possible location many block based motion estimators select their output motion vector by testing a set of motion vector candidates with a scoring function such as a sum of absolute differences SAD or mean of squared differences MSD to identify motion vectors which give the lowest error block matches. illustrates the candidate evaluation process for the block in the current frame which has pixel contents shown in . In this simple example system three motion vector candidates and are considered which correspond to candidate pixel data areas at locations and in the previous frame. The pixel contents of these pixel data areas can be seen in and respectively. It is apparent that the pixel data at location provides the best match for block and should therefore be selected as the best match lowest difference candidate. Superimposed back onto the current frame the matching pixel data area is at and the associated motion vector is .

Motion vectors are known to be highly correlated both spatially and temporally with vectors in adjacent blocks so these neighbouring vectors are often used as the basis for the set of candidate motion vectors considered in the motion estimation for a particular block. A random element may also be incorporated into the candidates to allow the system to adapt as the motion in the video changes. Where a block has motion that is not simply predicted by its neighbours a system may rely on random perturbation of vector candidates known as jitter. This works well for slowly changing vector fields but tends not to allow the motion estimator to converge rapidly to a new vector where it is very different to its neighbours. A system relying on randomness may wander towards the correct motion over time but is prone to becoming stuck in local minima or converging so slowly that the motion has changed again by the time it gets there. It is therefore desirable to introduce candidates that can more accurately predict new and changing motion or improve the selection of candidate motion vectors to improve the speed of convergence of the vector field. The number of candidate motion vectors tested for each block is often a compromise between choosing a set large enough to identify true motion and or provide good matches with a low residual error while being small enough to minimize computational expense.

Video sequences typically comprise a series of non interlaced frames of video data or a series of interlaced fields of video data. The interlaced sequences are produced by fields which carry data on alternate lines of a display such that a first field will carry data for alternate lines and a second field will carry data for the missing lines. The fields are thus spaced both temporally and spatially. Every alternate field in a sequence will carry data at the same spatial locations.

Not all video sequences are comprised of real images such as may be produced by a video camera. Applications such as games virtual reality environments Computer Aided Design CAD systems etc. typically output a series of images which may be referred to as artificially generated video sequences.

In computer graphics and particularly in 3D computer graphics a number of coordinate systems are commonly used. shows three important coordinate systems. The world space is a space with an arbitrary origin in which a camera or eye point a screen position and three objects and are shown in plan view. The direction in which the camera is pointing is shown as . An initial step in rendering this scene is to transform the objects into the camera space. In the camera space also shown in plan view the camera is at the origin and points along the z axis. The screen is perpendicular to the view direction. A second step projects the objects into screen space where the x y position of an object on the screen depends not only on its x y position but also its z coordinate in the camera space. This is therefore a perspective projection which helps to give the scene a three dimensional appearance.

In a motion estimation system processing a conventional video sequence the movement of an object is considered to be the distance that the object s representation on the display screen moves between frames. The motion estimation process occurs entirely in screen space. In reality the motion of an object on the display screen is determined by the motion of the object in the world space the projection of that motion onto the screen and also upon any change in the position and orientation of the camera. This is true for both video sequences and artificially generated sequences but can present a particular problem in artificially generated sequences such as 3D games where rapid motion is often combined with sudden changes in view direction. These camera movements cannot easily be predicted by the motion estimator and motion estimation performance suffers as a result.

In order to render an artificial scene the graphics engine responsible for creating the sequence of frames must have knowledge about objects in the scene as well as details about the camera position and orientation. While the position and motion of objects in a scene is usually unavailable outside of the graphics engine it is common for graphics engines to provide an API application programming interface which allows some information to be made available to other applications. Conveniently many APIs provide details of the camera location and orientation often in the form of matrices describing the transformation from world to camera space and the projection into screen space. It is also often possible to access depth or Z buffer information which stores the depths of objects at each pixel position in the screen space rendered image.

Where the video sequence has been produced using a conventional 2D video camera camera position and depth information is not normally available. Nevertheless if this information or an approximation to it can be produced then this invention may still be used to improve motion estimation. Possible approaches to approximating camera location orientation and distance to objects in a scene may be derived using Structure from Motion techniques in the field of Computer Vision.

Agrawala Beers and Chadda. Model Based Motion Estimation for Synthetic Animations. ACM Multimedia 1995.

The present invention introduces an efficient method of generating candidate motion vectors that are derived from the position and orientation of the camera and optionally from the distance between the camera and objects in the scene. Changes to the position and orientation of the camera contribute to the screen space motion of an object in a predictable way that can be used to guide the choice of motion vector candidates.

When camera movements are combined with object depth information the resulting screen space object motion can be determined mathematically. By representing object motion in screen space as the combination of motion due to camera movement and motion due to object movement in world space further improvements in motion estimation performance can be achieved.

These methods work by introducing motion vector candidates that may otherwise have been unavailable through other vector propagation techniques relying on temporally and spatially derived candidates and provide a more efficient method of tracking motion that accommodates apparent motion due to changes in the camera viewer position. The present invention may overcome erratic motion introduced by a user controlled camera allow faster convergence in areas of rapid or changing motion allow fewer candidates to be considered and or compensate for changes in viewer location all resulting in more accurate motion vector fields.

In all the figures motion vectors are shown with the head of the arrow at the centre of the block to which the vector corresponds and for simplicity objects are considered to be of point size.

Geometry in a three dimensional computer application such as a game is typically given in homogeneous coordinates. This representation will allow a transformation matrix to be defined which incorporates the six degrees of freedom three translations and three rotations of the camera position.

For a point p in world space the transformation to the corresponding point q in camera space is given by 

In the camera matrix C the terms t t and trepresent translation and the terms rto rrepresent rotation. The skilled person will be aware that the matrix can also represent transformations such as scaling and shearing but these are rarely used in the camera transform.

The projection of q into homogeneous screen space vector r is then given by the projection matrix P where the vector d incorporates dand d the offset to the corner of the screen and dthe distance from the camera to the screen 

Finally a divide by the homogeneous coordinate gives the location of the point s on the 2D screen. A scale factor is not shown but may also be required to map the image correctly onto the coordinate system of the display device 

The problem that must be solved is to determine the screen space position sin the previous frame of a point sin the current frame given a change in camera matrix from Cto C. We will see later how the actual screen space position of an object smay differ from the prediction. Calculation of scan be achieved by first reconstructing rfrom s and transforming it back into the world space position p. Assuming that the point does not move in world space i.e. that p p the point pmay then be transformed back into the screen space coordinate s using the method shown above.

Notice that to construct the 4D vector rfrom 2D vector s we must use information from elsewhere. The homogeneous depth r is retrieved from the depth buffer. The rterm appears to have been lost but can be recomputed since we know from the projection matrix P that r qand r q d. In the equations below note that we use different projection matrices Pand P to allow for the unlikely possibility that the projection may change between frames 

From the original screen space position of a point s and the predicted screen space position in the previous frame s a motion vector can be calculated simply from the difference between the two vectors 

Since it is based on predicted position s this motion vector is also a prediction. The prediction is based on the assumption that world space position pis equal to p i.e. that the point has not moved in the world space. The assumption is clearly not always true as the vast majority of 3D applications include moving objects. It is however the case that even in a scene containing moving objects there are large areas perhaps even the majority of each image that display only background and static objects. In these areas the predicted motion vector due to camera movement m is highly likely to be a useful motion vector candidate.

When the camera is stationary and an object moves in world space from p to p a corresponding change in screen space occurs from s to s where s and s are derived from p and p using the coordinate system transforms outlined above. The prime notation is used here to distinguish the coordinates of moving objects from the earlier explanation where the coordinates were those of stationary objects. The difference between the two screen space positions now gives the screen space vector m that describes the motion of the object on the screen arising from it s movement in world space alone Moving Objects with Camera Movement.

The motion of an object in screen space can be described as the sum of the vector due to any camera movement and the vector due to any object movement in world space 

Decomposing the motion estimation problem into two components allows us to apply the methods disclosed in this patent to significantly improve the motion estimation process on complex scenes.

The camera s position and orientation typically in the form of matrices Cand C are assumed to be available directly from the graphics engine or from some other source or approximated using an appropriate method. When information about the depth of pixels in the scene i.e. the depth buffer is also available to the motion estimation system this allows the calculation of camera transformation vectors m for every pixel in the frame as described above.

The way in which screen space motion depends on depth is illustrated in . The camera is at position . Vector identifies the direction in which the camera is pointed and the centre of the field of view. Objects and are at different distances from the camera but both are similar distances from the centre of the field of view. When the camera is rotated and the view direction changes to it can be seen that although the objects and have not moved in world space they are now at different distances from the centre of the new field of view . The two objects will appear to move relative to each other when the image is projected onto the screen.

In the absence of depth information for the scene the camera matrices can be used to predict the likely trends in motion of pixels in the scene based on their location in the image as illustrated in to . For example in if the camera moves down the image on the screen is likely to appear to move up. Although the absence of depth information means that an exact value for mcannot be calculated the information can be used to bias candidate vectors in the appropriate direction. This biasing could include methods such as generating more motion vector candidates that are aligned with the predicted direction of on screen movement extending search ranges along the predicted alignment or biasing the candidate selection mechanism.

Since a depth buffer typically provides a depth value for every pixel in the image an mvector can also be calculated for every pixel in the image. This often provides more vector candidates than a motion estimator can reasonably use. For example a simple block based motion estimator may use a single vector to represent the motion of a block of pixels or a more sophisticated design may use several vectors per block but the number of vectors per block is typically significantly fewer than the number of pixels in the block. In these cases one of numerous possible methods can be used to reduce the large number of per pixel vectors to a smaller number of per block vectors. For example if one depth can be found that is representative of the depths of a group of pixels then one set of transformation calculations can provide an mvector for that group of pixels. A representative depth of pixels may be found using averages such as the mean mode or median. If the pixels in a block can be classified into several groups on the basis of their depth values then this allows one mvector to be calculated for each group.

The classification of pixel groups according to depth may also be used to identify a boundary between objects or between foreground and background areas of an image. There is clearly a benefit to motion estimation performance in being able to calculate mseparately for each group of pixels. Further improvements that may be made in the calculation of mare described below.

The absence of information about object position and motion in world space means that the vector mmust be determined through motion estimation. Motion estimators operating in screen space actually find the total screen space motion vector m from which mcan be calculated by subtraction of m 

A motion estimator such as the typical block based type illustrated in and compares the pixels of each block in the current frame with pixel data areas from the previous frame with spatial offsets equal to each of a number of candidate motion vectors. These pixel data areas are of block size but are not necessarily constrained to being block aligned. As motion vectors are usually assumed to be highly correlated both spatially and temporally with vectors in adjacent blocks these neighbouring vectors are often used as the basis for selecting the candidate motion vectors used by the motion estimation for a particular block.

A difficulty arises in using a conventional motion estimator to find mbecause rapid and or erratic camera transformations can make assumptions about consistency of motion and predictability from one frame to the next unreliable. Furthermore motion estimators typically operate over a limited search area when attempting to find matching pixel data areas. If motion is so large that matches cannot be found in the available search area then motion estimation will fail. There is often some flexibility in the placement of the search area but this is only useful if the approximate motion can be predicted before the motion search begins.

Knowledge of mallows the motion estimation system to compensate for the component of motion caused by movement of the camera.

For example an existing motion estimation system might test four vector candidates a b c and z the zero vector in a search range centred at an offset of zero from the current block. If a sudden camera movement has occurred then none of these candidates are likely to give good pixel matches. In the current invention mis computed from camera matrices and depth values for the current block and leads the motion estimator to centre its search area on a position offset by mfrom the current block. The vectors searched are a m b m c m and m. The search is now considerably more likely to find a good match because the effect of the camera movement has been compensated for.

The choice of vector candidates in an existing system may be based on results that have already been calculated for neighbouring blocks. For example as motion estimation proceeds the motion estimator will store the best motion vector m for each block in a memory array. Since it is known that there is a high degree of spatial and temporal consistency in the vector fields the motion vector candidates for a block are likely to include vectors taken from the m arrays for the current and previous frames. Four typical vector candidates are therefore mand m taken from neighbouring blocks in the current frame m taken from a co located block in the previous frame and the zero vector z. As has been seem these vectors may not be good candidates in the event of camera motion. In particular mis unlikely to be a good candidate if there has been a change in camera motion since the previous frame and mand mare unlikely to be good candidates if the camera movements include rotations or movement perpendicular to the plane of the screen as these cause non uniform vector fields as illustrated in and respectively.

In this invention the motion estimation stores two vectors preferably mand m in the memory array. Any pair of vectors from m m m may be stored and the third calculated as required using the known relationship between the three. The overall screen space motion m is typically required as the output of the motion estimator. The mvectors may be used to provide vector candidates which are not affected by camera movements. In a similar example to that of the existing system above the four object motion vector candidates would be m m m and z. Finally compensating for the camera motion as before the candidates tested would be m m m m m m and m.

The block diagram of comprises input frame N at . A previous frame N 1 is stored in a frame buffer . The input frame N is compared with frame N 1 in a motion estimator using a set of candidate vectors generated in a candidate vector set generator which may generate candidate vectors in accordance with a number of well known methods. The output of the motion estimator is an output vector field for locks or pixels in the image.

In a graphics system generates output in which is for the output frame . These become the frames N and N 1 one of which is stored in the frame buffer before the two are compared in motion estimator to provide the output vector field .

The output of frame passes to a structure from video system which is used to assist in the derivation of candidate vector sets. This sends data related to the video system to an estimate camera position unit and optionally to an estimate scene depth unit . The output of the estimate camera position unit and optionally the output of the estimate scene depths unit are supplied to a camera transformation derived vector field corresponding to pixels or blocks of pixels in the image. This camera transformation derived vector field is then combined with candidate vector from the candidate vector sets generator in a camera corrected candidate vector sets unit . These camera corrected candidate vector sets are then used by the motion estimator .

In a graphics engine provides an output frame which using frame buffer can provide frame N and N 1 to motion estimator to provide an output vector field .

The output graphics engine also provides data to an output depth buffer corresponding to depths of objects at pixels or groups of pixels. It also provides scene data including camera location and orientation at . Data from the output depth buffer and scene data unit form the inputs to a camera transformation derived vector field unit as in . Vectors from this are combined with candidate vector sets from a candidate vector sets generator in the camera corrected candidate vector sets

A practical system would of course be likely to test a larger number of motion vector candidates than the examples shown above. In particular a random element is normally required. The same principle of compensating for camera motion can be applied to some or all of the motion vector candidates.

Situations in which compensation for camera movement is particularly useful is in the calculation of temporal vector candidates such as m described above. By isolating the component of motion due to an object moving in world space from the component caused by camera movement more accurate approximations of physical effects such as momentum and acceleration can also be determined. In our United Kingdom patent application no. 0907039.2 we describe a system which models the momentum and acceleration of objects generating motion vector candidates at a position offset from the current position of an object such that a candidate likely to represent the motion of the object is placed at a location where the object is likely to appear in future frames. Clearly such a system can be susceptible to camera movement effects where the apparent movement of an object that is expected to be moving with constant velocity or constant acceleration is made unpredictable by camera movements which are independent of the motion of the object.

The same method of compensating for camera movement can be applied in such a system by subtracting the motion component m and making vector calculations such as the calculation of momentum mand acceleration mcandidate vectors using the mcomponent. A vector stored at a location offset from the current block position by either mor mdoes not normally coincide with the screen space position of the object in the next frame as that position depends on a camera vector mwhich has not yet been computed. The lookup locations of momentum or acceleration candidates in the next frame must therefore also be compensated by the camera vector computed at that time.

In the second example the motion estimation is taking place at block and the camera vector has changed to such that the negated camera vector indicates that the object component should be retrieved from block . The vector is again which when added to the camera vector gives overall screen space motion vector candidate . It can be seen that again this candidate correctly predicts the motion of the object and that an accurate candidate has been computed despite the change in camera motion.

The discussion above and in United Kingdom patent application no. 0907039.2 describes the modelling of the motion of physical objects in screen space. The person skilled in the art will appreciate that the same principles can alternatively be applied in world space. Modelling in world space makes the predictions of future motion and position independent of the method of projection used and may be more robust in cases where the projection distorts the screen space image e.g. a simulation of a fish eye lens.

Where depth values are available and pixels in a block have been classified according to depth the motion estimator may use this information to improve motion estimation by sub dividing a block and assigning two or more vectors to the sub block regions.

A higher resolution may be obtained by splitting a lock into groups of pixels with similar depth and assigning vectors to these.

A simple example is illustrated in where block contains an object edge. Pixels inside the edge are part of a moving object while pixels outside the edge contain a stationary background object . The arrangement in shown in screen space and also in plan view where it can be seen that object is closer to the camera position than the background object i.e. the foreground object and background have different depth values. The camera is panning from right to left as illustrated by arrow and object is also moving from right to left at a greater speed. In this case the classification system would identify two groups of pixels and based on the similarity of the depth values within each group and the dissimilarity of the two groups to each other.

Motion estimation may then proceed independently for each group of pixels with the pixel classification being used to derive a mask at a resolution finer than that of the whole block. Ideally the mask would be at the resolution of individual pixels. The mask may then be used to include only the pixels in that group in the calculation of the scoring function e.g. SAD or MSD for each motion vector candidate. Typically the same set of motion vector candidates would be used for each groups of pixels but sets of motion vector candidates may also be prepared independently for each group for example by preferring to select candidates from neighbouring blocks that also have similar depth values.

In it can be seen that vector representing the observed movement of the stationary background due to camera movement is assigned to pixel group while vector the overall screen space motion of object is assigned to pixel group .

Such a method does not add significantly to the computational requirements of the system since for example in calculating an SAD the same number of pixel difference calculations are required as for a whole block SAD. The mask is used to accumulate each difference in one of two accumulators so as to produce an independent SAD for each pixel group.

The pixel classification system may clearly be extended to identify more than two groups of depth values allowing more than two vectors to be assigned to each block.

The use of multiple motion vectors per block is valuable in applications such as motion compensated frame rate conversion. A single vector per block is unable to represent the motions at the silhouette edge of a moving object and this can lead to visible halo artefacts around moving objects. The halo effect is considerably reduced by the use of multiple motion vectors calculated using the method described here.

