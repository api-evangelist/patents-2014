---

title: System and method for smart throttling mechanisms for virtual backup appliances
abstract: A method for managing resources of virtual backup appliances is described. The method includes receiving, by a backup management server (BMS), a request to back up a plurality of virtual machines (VMs), determining, at the BMS, a set of VMs to be backed up from the plurality of VMs that yields a maximum performance for the backup request without causing the set of VM servers to become bottlenecked, wherein the determination is performed based on at least one of a concurrency limit of the virtual backup appliance (VBA) and any VBA proxies corresponding to the set of VMs, and a set of one or more data performance metrics of one or more storage devices in the set of VM storage arrays, and sending one or more backup jobs to the VBA to back up the determined set of VMs to be backed up to a backup storage system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09628561&OS=09628561&RS=09628561
owner: EMC IP Holding Company LLC
number: 09628561
owner_city: Hopkinton
owner_country: US
publication_date: 20141219
---
Embodiments of the present invention relate generally to data storage systems. More particularly embodiments of the invention relate to smart throttling mechanisms for virtual backup appliances.

Virtual machines VMs provide one mechanism for an enterprise to reign in the costs of expansion by reducing hardware expenditures. However the introduction of VMs into an enterprise presents new challenges in the data management of the new VM environment. New systems have been created to address issues such as backup management of the VM environment. Typically these systems include a backup management server a backup storage system and one or more virtual backup appliances VBAs which are VMs in the VM environment that include logic for backing up the other VMs in the environment. An example of such a system is EMC Avamar NetWorker Hopkinton Mass. .

In a typical backup scenario the backup management server may send a request to one or more of the VBAs to request backup of one or more VMs to the backup storage system. The one or more VBAs receive the request and then fetch the VM disk files for the VMs in the system and transmit the disk files possibly after deduplication to the backup storage system. However while this works well for smaller backup jobs for larger jobs with many VMs this backup methodology runs into problems. A particular issue is with performance and maintaining service level standards.

When a large backup request is submitted to the system the system may attempt to execute the individual jobs e.g. a backup job for an individual VM of the request all at once. This creates a risk of having the system run out of memory or suffer reduced performance. One possible solution to this issue is to better size the underlying environment. For example an administrator may size the environment to have a large memory capacity. However this may not always be feasible as the requirements of the real life system may differ greatly from the estimated requirements.

Thus there is a desire for a better system to manage the resources of the VM environment and backup system during the execution of a backup request.

Various embodiments and aspects of the inventions will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However in certain instances well known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

Storage system may include any type of server or cluster of servers. For example storage system may be a storage server used for any of various different purposes such as to provide multiple users with access to shared data and or to back up mission critical data. Storage system may be for example a file server e.g. an appliance used to provide NAS capability a block based storage server e.g. used to provide SAN capability a unified storage device e.g. one which combines NAS and SAN capabilities a nearline storage device a direct attached storage DAS device a tape backup device or essentially any other type of data storage device. Storage system may have a distributed architecture or all of its components may be integrated into a single unit. Storage system may be implemented as part of an archive and or backup system such as a de duplication storage system available from EMC Corporation of Hopkinton Mass.

In one embodiment storage system includes but is not limited to backup engine deduplication storage engine and one or more storage units communicatively coupled to each other. Storage units may be implemented locally e.g. single node operating environment or remotely e.g. multi node operating environment via interconnect which may be a bus and or a network. In one embodiment one of the storage units operates as an active storage to receive and store external or fresh user data while the other storage unit operates as a target storage unit to periodically archive data from the active storage unit according to an archiving policy or scheme. Storage units may be for example conventional magnetic disks optical disks such as CD ROM or DVD based storage magnetic tape storage magneto optical MO storage media solid state disks flash memory based devices or any other type of non volatile storage devices suitable for storing large volumes of data. Storage units may also be combinations of such devices. In the case of disk storage media the storage units may be organized into one or more volumes of Redundant Array of Inexpensive Disks RAID .

In response to a data file to be stored in storage units optional deduplication storage engine is configured to segment the data file into multiple segments according to a variety of segmentation policies or rules. Deduplication storage engine only stores a segment in a storage unit if the segment has not been previously stored in the storage unit. In the event that a segment has been previously stored metadata stores information enabling the reconstruction of a file using the previously stored segment. As a result segments of data files are stored in a deduplicated manner either within each of storage units or across at least some of storage units . Data stored in the storage units may be stored in a compressed form e.g. lossless compression Huffman coding Lempel Ziv Welch coding delta encoding a reference to a segment plus a difference subsegmenting a list of subsegments or references to subsegments etc. . In one embodiment different storage units may use different compression methods e.g. main or active storage unit from other storage units one storage unit from another storage unit etc. .

The metadata may be stored in at least some of storage units such that files can be accessed independent of another storage unit. Metadata of each storage unit includes enough information to provide access to the files it contains. When an active storage unit fails metadata contained in another storage unit may be utilized to recover the active storage unit. When one storage unit is unavailable e.g. the storage unit has failed or is being upgraded etc. the system remains up to provide access to any file not stored in the failed storage unit. When a file is deleted the metadata associated with the files in the system is updated to reflect that the file has been deleted.

In one embodiment the metadata information includes a file name a storage unit where the segments associated with the file name are stored reconstruction information for the file using the segments and any other appropriate metadata information. In one embodiment a copy of the metadata is stored on a storage unit for files stored on a storage unit so that files that are stored on the storage unit can be accessed using only the information stored on the storage unit. In one embodiment a main set of metadata information can be reconstructed by using information of other storage units associated with the storage system in the event that the main metadata is lost corrupted damaged etc. Metadata for a storage unit can be reconstructed using metadata information stored on a main storage unit or other storage unit e.g. replica storage unit . Metadata information further includes index information e.g. location information for segments in storage units .

In one embodiment the storage system as shown in may be used as a tier of storage in a storage hierarchy that comprises other tiers of storage. One or more tiers of storage in this hierarchy may utilize different kinds of storage devices and or may be optimized for different characteristics such as random update performance. Files are periodically moved among the tiers based on data management policies to achieve a cost effective match to the current storage requirements of the files. For example a file may initially be stored in a tier of storage that offers high performance for reads and writes. As the file ages it may be moved into a tier of storage according to one embodiment of the invention. In various embodiments tiers include different storage technologies e.g. tape hard drives semiconductor based memories optical drives etc. different locations e.g. local computer storage local network storage remote network storage distributed storage cloud storage archive storage vault storage etc. or any other appropriate storage for a tiered data storage system.

Referring back to backup engine is configured to backup data from client systems and to store the backed up data in one or more of storage units which may be deduplicated by deduplication storage engine . In one embodiment backup engine can back up data from a client system that is stored in a virtual operating environment such as a VM provided by a variety of VM vendors such as VMware . The data can be backed up without having to install a backup agent within the corresponding VM and or without having to mount the corresponding VM disk on a proxy server. Further instead of backing up the entire VM disk a portion or subdirectory of the VM disk can be backed up.

In this example client includes one or more VMs hosted by VM monitor or manager VMM where VMs include virtual backup application or software executed therein to perform backup operations of data in a local storage system and or a remote backup storage such as storage system . The VMs having the respective backup application software executed therein or communicatively coupled to or associated with are referred to as virtual backup appliance VBAs . Data of each of VMs is stored in one of VM disk files in physical storage e.g. local storage representing a virtual storage device of the associated VM. Data stored in VM disk files may be optionally deduplicated by a deduplication storage engine not shown . VMs may be managed by a remote VM management server e.g. vCenter from VMware which communicates with VMM over network for example via an application programming interface or API which may be operated by a third party entity that is different than an entity of backup server .

A virtual machine represents a completely isolated operating environment with a dedicated set of resources associated with. A virtual machine may be installed or launched as a guest operating system OS hosted by a host OS. Typically a host OS represents a virtual machine monitor VMM also referred to as a hypervisor for managing the hosted virtual machines. A virtual machine can be any type of virtual machines such as for example hardware emulation full virtualization para virtualization and operating system level virtualization virtual machines. Different virtual machines hosted by a server may have the same or different privilege levels for accessing different resources.

According to one embodiment backup engine is to parse a virtual disk file of a VM e.g. virtual disk files of VMs to generate metadata describing content files of stored in a virtual storage device of the VM. In one embodiment backup engine of storage system accesses the VM disk file of a data processing system such as client system hosting one or more VMs where each VM corresponds to a virtual disk file storing content files of a virtual storage device of the respective VM. In one embodiment backup engine remotely accesses over network virtual disk file via an API of VMM e.g. virtual storage API to parse virtual disk file to generate metadata representing the content files contained in the virtual disk file. In one embodiment backup engine communicates with the VMM to cause the VMM to generate a snapshot of the virtual disk file and to generate the metadata based on the snapshot of the virtual disk file.

In one embodiment the metadata is utilized to generate a file index database e.g. metadata database not shown that can be queried subsequently for backup purposes. The file index database can be implemented in a variety of formats or architectures. In one embodiment the file index database includes many entries each entry corresponding to a file stored in a particular directory of the corresponding virtual disk file also referred to herein as a source virtual disk file and storing metadata associated with the respective file. Metadata of a file may include information that can identify the file from the source virtual disk file such as a file system record identifier ID identifying a file system record of the file compatible with a file system of the source virtual disk file current and or parent directory information of the file and at least some file attributes of the file e.g. at least some information from an mode of the file . The file index database may further include information describing the corresponding virtual disk file such as virtual disk file header information or information associated with the corresponding VM such that the source virtual disk file can be recreated based on information stored in the file index database.

The file index database can be utilized to back up data from a source virtual disk file by either a full backup or a partial backup at a variety of granularity levels e.g. block and or file granularity level . In one embodiment in response to a request to back up a subdirectory also referred to as a subtree of one or more files of a VM backup engine accesses the file index database based on an identifier e.g. directory name of the requested subdirectory obtained from the request to identify a file system record or records associated with the requested subdirectory. Backup engine transmits the file system record identifying information to VMM to retrieve the data blocks corresponding to the file system records. Data blocks corresponding to the identified file system records are then backed up from the source virtual disk file of the remote data processing system without having to back up the remaining data of the source virtual disk file. The data blocks may further be deduplicated by deduplication storage engine before being stored in storage units . Note that some functionality of backup engine as described above may be implemented within backup management server or simply referred to as a backup server . Similarly certain functionalities of backup server may be integrated with storage server .

According to one embodiment backup server includes maintained therein user interface throttling module and backup policies . User interface may be implemented as a graphical user interface GUI such as a Web interface or a command line interface CLI to allow a user such as an administrator to initiate and manage backup operations that back up data from clients to backup storage system based on one or more backup policies . Backup server further maintains backup metadata storing backup operations and or statistics of the backup operations. Backup metadata may further include information identifying VMs whose backup operations are managed by backup server .

According to one embodiment throttling module is configured to allow the backup management server BMS to throttle the number of backup jobs or backup processes running against the storage system and against the VM client so that the backup process is able to run more efficiently. In some embodiments the VBA on the VM client server reports to the BMS the number of concurrent jobs it may handle. In some embodiments before any scheduled backup jobs the VBA measures the performance of the storage units that store the VM backups and relays this information to the BMS . The VBA may also determine or calculate how many backup streams it can handle concurrently and its buffering capacity e.g. queue length without significant delay and communicate such information to backup management server for example in real time periodically or in demand from backup management server . The BMS then customizes the backup policy such that the backup jobs are run against the storage units to have the best aggregate data throughput. In some embodiments the BMS causes the VBA to measure data latency in real time during a backup and report this information to the BMS . When the BMS determines that latency has increased beyond a threshold value the BMS may stop adding to the backup queue at one or more of the VBAs. In some embodiments additional logic or software on the VBAs assist in the implementation of the throttling.

This improvement provides a great benefit over traditional systems. In traditional systems when a large number of backup jobs are scheduled at the BMS the BMS sends all these jobs to the respective VBAs. This influx of a large number of backup jobs may cause resource errors such as out of memory errors or may cause performance issues as multiple jobs attempt to access the same resources simultaneously or may cause the jobs to simply time out and never be completed. In this traditional approach the BMS and the VBAs do not necessarily have any intelligence of the underlying environment. Instead with this improvement the system can provide a particular service level and more guaranteed performance and reliability regardless of the resources allocated to the underlying system. This improved system will be further described with reference to . In some embodiments this improved system is included as part of the NetWorker backup system of EMC Corporation Hopkinton Mass. .

In some embodiments BMS also includes backup metadata . Backup metadata includes metadata information regarding the backup jobs and the VMs e.g. backup statistics VM identifiers etc. . In some embodiments backup metadata is the same as backup metadata as described in .

In some embodiments BMS includes a throttling module . This module may be comprised of software and or hardware. The module includes logic to determine the capabilities and status of the VBAs the VM servers and the VM storage in the system and is able to use this system to send backup jobs to the VBAs but without causing a bottleneck to occur in the VBAs or the VM storage. The details of throttling module will be described in further detail below.

System also includes one or more VM servers e.g. VM . VM servers are hardware hosts that provide a platform for VMs such as VMs to execute on top of. In some embodiments the VM servers are known as hypervisors. In some embodiments the VM servers are the same as the client in . Although two VM servers are depicted in in some embodiments the system includes more than two VM servers and in some embodiments the system only includes one VM server.

Each one of the VM servers includes a VBA. The VBA may be a VM on a VM server with special software that may interface with the VM server software or hypervisor directly and access the VM disk files for the VMs on the respective VM server. This allows the VBA to perform various file and backup operations on the VM disk files of the server and communicate with the BMS to receive backup jobs from BMS . One of the VM servers includes a primary VBA and the remaining VM servers include a VBA proxy . The VBA proxy is similar in function to the VBA in function but does not include management functions. Thus while the VBA proxy may include a job queue it may not include a scheduler. Instead the VBA proxy is managed and or controlled by the primary VBA . When the BMS receives a backup request the BMS sends the backup jobs to the primary VBA which then coordinates amongst the VBA proxies e.g. . The VBA proxies may not communicate with the BMS directly. The VBA and the VBA proxies then back up the VM disk files from the VM storage array and send these files to the backup storage system . Although only one VBA proxy is shown in in some embodiments of the invention the system has multiple VM proxies per primary VBA and may also have multiple primary VBAs. In some embodiments the VBAs also perform deduplication of data before sending the data to the backup storage system. In some embodiments the VBA interfaces with the VM server hypervisor or VM monitor through the use of a plugin to the VM server hypervisor or VM monitor software.

Each VBA whether a proxy or primary includes a throttling module e.g. throttling module and . This module is configured to allow the VBA to throttle backup jobs such that no bottlenecks performance or reliability issues occur. The details of the throttling module on the VBAs will be described in further detail below.

System also includes a VM storage array . This array includes one or more storage devices that store the VM disk files e.g. VM disk files for the VMs on the VM servers . As noted previously VM disk files are files that represent the storage media for the VMs on the VM server. When the VM accesses a storage device inside the VM the VM server accesses the corresponding VM disk file on the storage array . In some embodiments system includes data replicator . This may be a hardware server that duplicates or replicates backup data from the VBAs in order to copy the data to various storage media such as backup storage system or to a separate tape drive etc.

System also includes a backup storage system . The backup storage system includes one or more storage devices that store the backups made from the VMs by the VBAs and . The backup storage system may receive the backup files from the VM storage array via the VBAs or may receive the backup files from the data replicator . When BMS receives a backup request e.g. from a client device the throttling module on BMS may perform one or more throttling actions in order to ensure a particular service level performance and reliability.

In some embodiments the throttling module on BMS has queried the VBA for the number of concurrent backup jobs that the primary VBA and its proxies e.g. VBA proxy can process. If the BMS sends a number of backup jobs exceeding this limit to the VBA then the jobs will sit in a job queue on the VBA and after a timeout period passes those jobs that are still in the job queue may be discarded. However since the BMS has queried the VBA regarding its concurrent backup job limit the BMS sends only those number of backup jobs to the primary VBA and the primary VBA then passes the jobs to any VBA proxies. The remaining jobs are stored or queued at the job scheduler and are sent to the VBAs after the VBAs have processed some of the current batch of jobs. Further details regarding this embodiment will be described with reference to .

In some embodiments the throttling module queries the throttling module on the primary VBA to request a performance metric regarding the VM storage array . The primary VBA then takes sample reads of the various VM disk files stored on various storage devices of the VM storage array and sends this information to the BMS . The throttling module on BMS may then calculate a combination of storage devices from VM storage array for which reading from them would generate the greatest net aggregate throughput. Based on this information the BMS sends those backup jobs in the backup request that include VM disk files on those storage devices such that a backup of these VM disk files would yield the greatest net aggregate throughput. Further details regarding this embodiment will be described with reference to .

In some embodiments the BMS after receiving the backup request sends a portion of the backup jobs of the backup request to the VBAs. At regular intervals the BMS queries the VBAs for the I O latency of the current accesses to the VM storage array . When the threshold is reached the BMS restricts the number of additional jobs that are sent to the VBAs. Further details regarding this embodiment will be described with reference to .

These improvements described above allows an administrator to back up a large amount of data without having to worry about any failures of the backup system. Furthermore scheduling the backups based on component level capability will give a smart way of addressing data protection challenges in a large data center. Additionally the BMS is made to be smart thinking in ensuring a fairly even distribution of the load on individual components in backup workflow. This improvement prevents non functional issues such as backup hanging backups waiting forever performance issues due to un managed queue depth on the VBA etc.

Furthermore as the VM environment grows it becomes more complex to address the functional as well as non functional issues due to backup failures hang issues and performance issues. This improvement would help to reduce the turnaround time in addressing such issues. Additionally resource utilization on the VBA can be more fairly used by distributing the backup load fairly on the VBA. This would help to enhance the end user experience by ensuring more successful backup rates even during unusual scenarios such as single policy backing up more than 1000 VMs with just one VBA.

Each VBA may also include a job queue e.g. job queue and . This job queue holds the backup jobs that are sent to the VBA but which cannot be processed at the moment. The job may not be able to be processed because all concurrent backup job slots on the VBA are taken by other backup jobs. In some scenarios in a VM environment if a single VBA e.g. VBA is backing up a large number of VMs e.g. 1000 in a virtual data center with a majority of these VMs stored on a small number of storage units in the VM storage array then the job queue at the VBA may become very large and the VBA becomes a bottleneck. For example in some cases each VBA can process up to 8 backup jobs concurrently. In this case if many hundred backup jobs were sent to that VBA for processing the job queue on that VBA would be unnecessarily long and if an error were to occur in the system or if a timeout counter was implemented for the backup jobs in the queue some backup jobs might be lost.

To solve this problem in some embodiments when a backup request is received at the BMS the BMS has queried the VBAs in the system e.g. VBAs and VBA their limits on concurrent backup jobs. In some embodiments this query is performed by throttling module . This limit may be preset for the VBA by an administrator or developer of the VBA software or may be determined automatically by the VBA based on available system resources. The VBA then responds to the BMS with its concurrent backup job limit including for example a number of proxies the VBA is associated with. This response may be made via the throttling module of the VBA e.g. throttling module and .

The BMS may then store this concurrent job limit information within the backup policies as a separate policy e.g. VBA concurrency policy or in combination with an existing backup policy. Alternatively the BMS may store this concurrent job limit information in a separate policy and an administrator may apply the policies on BMS through a GUI to one or more VMs or groupings of VMs e.g. groupings at the VM server level system level cluster level etc. .

Subsequently an administrator may initiate or schedule the backup policy in backup policies that includes the concurrency limit information. Once the policy is executed the backup request made at the BMS and the BMS submits the individual backup jobs of the backup request to the primary VBA such that the number of backup jobs sent do not exceed the concurrency limit calculated for the primary VBA and its VBA proxies. For example if the concurrency limit of each VBA is 8 then if there are two VBAs total including the primary VBA then the maximum number of concurrent jobs would be 16.

In some embodiments the concurrency limit is not stored within the backup policies and instead the BMS queries the VBAs for the concurrency limit after the backup request is made. In such a case if the VBA concurrency policy is applied to a set of VMs for a particular backup request this indicates to the BMS to query the concurrency limit of the VBAs before submitting the jobs for this backup request to the VBAs.

During the backup operation when one of the VBAs completes a backup job it will notify the BMS at which point the BMS submits another job to that VBA to replace the completed job. This method of throttling helps to ensure that all backup jobs are processed without having to wait for long time in queue and also ensures that the jobs are not terminated due to any timeout mechanism. This also helps to maintain an efficient means of handling queuing by single primary VBA with or without VBA proxies.

In some embodiments one or more of the VBAs include a measurement module as part of the throttling module . This measurement module is able to measure the read and write performance throughput and or I O latency performance of the various storage devices of the VM storage array . In some embodiments the VM storage array includes more than one storage device to store the VM disk files . The performance on each of these storage devices may vary and the distribution of the VM disk files on the storage devices may also vary both to the number and size of the files on each storage device and also in regards to which VM has which one of its VM disk files on which storage device.

Thus in some cases if a single VBA with multiple VBA proxies are backing up a huge number of VMs e.g. 1000 with a majority of these VMs residing on a single storage device or sharing a limited bandwidth connection this creates a high concurrency of data streams per storage device and thus the storage device or VM storage array itself could be stressed and become a bottleneck. Once this bottleneck is reached the performance of the backup is reduced.

To solve this problem in some embodiments the throttling module on the BMS submits a request to the throttling module on one or more of the VBAs to measure the data throughput performance of each storage device by performing a few sample reads and or writes of the VM disk files on the corresponding storage device . The VBA may measure the data throughput either read or write or both or latency of the storage device and return that data to the BMS . The VBA may also measure the highest concurrent number of reads or writes that the storage device may accept without losing performance i.e. maximum read write performance . For example the VBA may read from the VM disk files on a single storage device and issue increasing number of concurrent read requests until a plateau or limit is reached.

Once the BMS receives the storage device measurement data from the VBAs the BMS may store this data as measurement data in backup policies . BMS may then be able to present this data to an administrator so that the administrator may configure a backup policy that submits an optimal combination of backup jobs for VMs with VM disk files that when backed up maximize the net aggregate throughput i.e. that have a net aggregate maximum read performance throughput of the storage devices on the VM storage array when the VBAs are processing a set of backup jobs. Alternatively the BMS may automatically schedule the backup jobs for each VBA such that a maximum net aggregate data throughput is reached.

For example in the exemplary system of four VM disk files are on storage device and four VM disk files are on storage device . If for example each storage device is saturated by three concurrent read operations then the BMS after it receives this performance metric from the VBAs can schedule jobs such that the VMs that are backed up only require three concurrent read requests to each storage device . This means that some backup jobs for some VMs that are stored on the same storage device may be postponed until the prior VM backup job is completed.

In some embodiments the BMS includes a latency measurement module which may be included within the job scheduler or may be a separate module. When the BMS receives a backup request either manually from an administrator or automatically through a schedule the BMS begins to send the backup jobs to the VBAs but also periodically measures the latency of the access to the storage devices as reported by the VBAs possibly via the throttling module on the VBA or by comparing an estimated completion time for a job under no congestion versus the actual completion time.

In some embodiments in order to make these measurements the BMS has stored within it possibly in the backup policies or backup metadata information regarding what storage devices the VM disk files of each VM is stored on. The BMS continues to send an increasing number of backup jobs to the VBAs. Once the BMS determines that the latency response or job completion time related to a particular storage device is slowed beyond a predetermined threshold due to the increasing number of access on that storage device from the backup jobs then BMS may determine that this particular storage device is bottlenecked or saturated. The BMS may then configure the VM server possibly through the throttling module of VBA on the server to limit the amount of I O requests that each backup job for VMs stored on that storage device can make. In some embodiments the BMS limits all I O requests to the same storage device equally or similarly such that all concurrent requests are provided with the same share of the throughput. In some alternative embodiments the BMS updates the existing backup jobs on the VBA to indicate a certain I O request rate. In some embodiments the predetermined threshold is set by an administrator.

In majority of virtualized data centers the underlying storage will be shared. The shared storage generally hosts many VMs. The performance of a backup job backing up such VMs thus depends on underlying data store throughput. If data store where the VMs resides is saturated beyond its data transfer capacity then there is a penalty to the backup or recovery performance. The improvements presented with reference to and allows the BMS to intelligently throttle the backup jobs based on the performance characteristics of each storage device in the VM storage array.

At block the method includes receiving by a backup management server BMS a request to back up a plurality of virtual machines VMs of a set of one or more VM servers wherein each VM includes one or more VM disk files that are stored on a set of one or more VM storage arrays wherein the BMS is configured to manage backup operations to back up data from the set of VM storage arrays to a backup storage system over a network wherein a primary VM server of the set of VM servers has a virtual backup appliance VBA wherein any remaining VM servers of the set of VM servers each have a VBA proxy and wherein the VBA receives backup jobs from the BMS and communicates with any VBA proxies to carry out the backup jobs.

At block the method includes determining at the BMS a set of VMs to be backed up from the plurality of VMs in the backup request that yields a maximum performance for the backup request without causing the set of VM servers to become bottlenecked wherein the determination is performed based on at least one of a concurrency limit of the VBA and any VBA proxies corresponding to the set of VMs and a set of one or more data performance metrics of one or more storage devices in the set of VM storage arrays.

At block the method includes sending one or more backup jobs to the VBA to back up the determined set of VMs to be backed up to the backup storage system.

In some embodiments the concurrency limit of the VBA and any VBA proxies is the maximum number of VMs that each VBA and VBA proxy can process at once and wherein the BMS further requests concurrency limits from the VBA and any VBA proxies prior to the sending of the one or more backup jobs and wherein the set of VMs to back up is of a number equal to the net concurrency limit of the VBA and any VBA proxies.

In some embodiments the set of data throughput performance metrics includes a set of one or more maximum read performance throughput limits of each of the one or more storage devices in the set of VM storage arrays and wherein the set of VMs to be backed up is determined from the plurality of VMs in the backup request such that a net aggregate maximum read performance throughput is reached for the set of VM storage arrays when the VBA and any VBA proxies carry out the back up of the set of VMs to be backed up.

In some embodiments the net aggregate maximum read performance throughput is reached when the set of VMs to be backed up is selected to have VM disk files that when backed up by the VBA and any VBA proxies generate the maximum read throughput limit in the most number of the one or more storage devices in the set of VM storage arrays.

In some embodiments the set of data throughput performance metrics includes a set of one or more latency measurements for the one or more storage devices in the set of VM storage arrays as measured by the BMS while the VBA and any VBA proxies carry out the one or more backup jobs wherein for each of the one or more storage devices the BMS sends an increasing number of the one or more backup jobs to the VBA for VMs that have VM disk files on that storage device until the latency measurement for that storage device exceeds a predetermined threshold and wherein the set of VMs to be backed up are those VMs that are associated with the one or more backup jobs.

In some embodiments the BMS adjusts an input output I O rate of all the backup jobs for VMs with VM disk files on a saturated storage device such that each job requests a similar amount of data transfer from that saturated storage device wherein a saturated storage device is a storage device with a latency measurement that exceeds the predetermined threshold.

In some embodiments the BMS includes a backup policy store to store at least one of the concurrency limit of the VBA and any VBA proxies corresponding to the set of VMs and the set of one or more data performance metrics.

In one embodiment storage system includes a deduplication engine interfacing one or more clients with one or more storage units storing metadata and data objects . Clients may be any kinds of clients such as for example a client application backup software or a garbage collector located locally or remotely over a network. A network may be any type of networks such as a local area network LAN a wide area network WAN such as the Internet a corporate intranet a metropolitan area network MAN a storage area network SAN a bus or a combination thereof wired and or wireless.

Storage devices or units may be implemented locally e.g. single node operating environment or remotely e.g. multi node operating environment via an interconnect which may be a bus and or a network e.g. a storage network . In one embodiment one of storage units operates as an active storage to receive and store external or fresh user data from a client e.g. an end user client or a primary storage system associated with one or more end user clients while the another one of storage units operates as a target storage unit to periodically archive data from the active storage unit according to an archiving policy or scheme. Storage units may be for example conventional magnetic disks optical disks such as CD ROM or DVD based storage magnetic tape storage magneto optical MO storage media solid state disks flash memory based devices or any other type of non volatile storage devices suitable for storing large volumes of data. Storage units may also be combinations of such devices. In the case of disk storage media the storage units may be organized into one or more volumes of redundant array of inexpensive disks RAID . Data stored in the storage units may be stored in a compressed form e.g. lossless compression HUFFMAN coding LEMPEL ZIV WELCH coding delta encoding a reference to a chunk plus a difference etc. . In one embodiment different storage units may use different compression methods e.g. main or active storage unit from other storage units one storage unit from another storage unit etc. .

The metadata such as metadata may be stored in at least some of storage units such that files can be accessed independent of another storage unit. Metadata of each storage unit includes enough information to provide access to the files it contains. In one embodiment metadata may include fingerprints contained within data objects where a data object may represent a data chunk a compression region CR of one or more data chunks or a container of one or more CRs. Fingerprints are mapped to a particular data object via metadata enabling the system to identify the location of the data object containing a data chunk represented by a particular fingerprint. A fingerprint may be generated based on at least a portion of a data chunk for example by applying a predetermined mathematical algorithm e.g. hash function to at least a portion of the content of the data chunk. When an active storage unit fails metadata contained in another storage unit may be utilized to recover the active storage unit. When one storage unit is unavailable e.g. the storage unit has failed or is being upgraded etc. the system remains up to provide access to any file not stored in the failed storage unit. When a file is deleted the metadata associated with the files in the system is updated to reflect that the file has been deleted.

In one embodiment metadata may include a file name a storage unit identifier ID identifying a storage unit in which the chunks associated with the file name are stored reconstruction information for the file using the chunks and any other appropriate metadata information. Metadata may further include a chunk ID a chunk sketch a hash of a chunk an encrypted hash of a chunk random data or any other appropriate metadata. In some embodiments metadata associated with a chunk is used to identify identical and or similar data segments. The stored metadata enables a faster identification of identical and or similar data chunks as an ID and or sketch e.g. a set of values characterizing the chunk do not need to be recomputed for the evaluation of a given incoming data segment.

In one embodiment a chunk ID includes one or more deterministic functions of a data chunk also referred to as a data segment one or more hash functions of a data chunk random data or any other appropriate data chunk ID. In various embodiments a data chunk sketch includes one or more deterministic functions of a data chunk one or more hash functions of a data chunk one or more functions that return the same or similar value for the same or similar data chunks e.g. a function that probably or likely returns a same value for a similar data segment or any other appropriate data segment sketch. In various embodiments sketch function values are determined to be similar using one or more of the following methods numeric difference hamming difference locality sensitive hashing nearest neighbor search other statistical methods or any other appropriate methods of determining similarity. In one embodiment sketch data includes one or more data patterns characterizing a chunk. For example a sketch may be generated by applying one or more functions e.g. hash functions on a chunk and a subset of the results of the functions performed on the chunk e.g. a number of results for example the ten lowest results or the ten highest results are selected as a sketch.

In one embodiment a copy of the metadata is stored on a storage unit for files stored on a storage unit so that files that are stored on the storage unit can be accessed using only the information stored on the storage unit. In one embodiment a main set of metadata information can be reconstructed by using information of other storage units associated with the storage system in the event that the main metadata is lost corrupted damaged etc. Metadata for a storage unit can be reconstructed using metadata information stored on a main storage unit or other storage unit e.g. replica storage unit . Metadata information further includes index information e.g. location information for chunks in storage units identifying specific data objects .

In one embodiment deduplication storage engine includes file service interface segmenter also referred to as a chunking module or unit duplicate eliminator file system control and storage unit interface . Deduplication storage engine receives a file or files or data item s via file service interface which may be part of a file system namespace of a file system associated with the deduplication storage engine . The file system namespace refers to the way files are identified and organized in the system. An example is to organize the files hierarchically into directories or folders which may be managed by directory manager . File service interface supports a variety of protocols including a network file system NFS a common Internet file system CIFS and a virtual tape library interface VTL etc.

The file s is are processed by segmenter and file system control . Segmenter also referred to as a content store breaks the file s into variable length chunks based on a variety of rules or considerations. For example the file s may be broken into chunks by identifying chunk boundaries. Chunk boundaries may be determined using file boundaries directory boundaries byte counts content based boundaries e.g. when a hash of data in a window is equal to a value or any other appropriate method of determining a boundary. Reconstruction of a data block data stream file or directory includes using one or more references to the one or more chunks that originally made up a data block data stream file or directory that was were previously stored.

In some embodiments chunks are segmented by identifying chunk boundaries that are content based such as for example a hash function is applied to values of data within a sliding window through the data stream or block and when the hash function is equal to a value or equal to one of several values then a chunk boundary is identified. In various embodiments chunk boundaries are identified using content based functions operating on a sliding window within a data stream or block that have a minimum or maximum or other value or any other appropriate content based chunking algorithm. In various embodiments chunks include fixed length chunks variable length chunks overlapping chunks non overlapping chunks chunks with a minimum size chunks with a maximum size or any other appropriate chunks. In various embodiments chunks include files groups of files directories a portion of a file a portion of a data stream with one or more boundaries unrelated to file and or directory boundaries or any other appropriate chunk.

In one embodiment a chunk boundary is determined using a value of a function calculated for multiple windows within a segmentation window. Values are computed that are associated with candidate boundaries within the segmentation window. One of the candidate boundaries is selected based at least in part on a comparison between two or more of the computed values. In one embodiment a segmentation window can be determined by determining a first location corresponding to a minimum segment length and determining a second location corresponding to a maximum length where data within the segmentation window is considered the segment from the first location to the second location.

Determining a boundary can include determining multiple windows within the segmentation window. Each window corresponds to a location within the segmentation window and is associated with a candidate boundary. In one embodiment a function is then evaluated for each window. The function has as its inputs one or more data values of the window. In one embodiment the function includes a hash function such as for example SHA 1 Secure Hash Algorithm 1 SHA 256 SHA 384 SHA 512 MD5 Message Digest algorithm 5 RIPEMD 160 RACE Integrity Primitives Evaluation Message Digest 160 bit version a Rabin hash a fingerprint a CRC Cyclic Redundancy Check a sum an XOR or any other appropriate function to distinguish a window. After the function values are generated for all windows a boundary is selected based at least in part on the values that were generated for example the location corresponding to an extrema of a function value of all values generated the location corresponding to the minimum value of all values generated is selected the location corresponding to the maximum value of all values generated is selected the location corresponding to a value with the longest run of 1 bits in its value of all values generated is selected or the location corresponding to a value with the most 1 bits in its value of all values generated is selected. If there is tie for the value criteria of selecting the location that maximizes or minimizes the segment length could be adopted.

In one embodiment file system control also referred to as a file system manager processes information to indicate the chunk s association with a file. In some embodiments a list of fingerprints is used to indicate chunk s associated with a file. File system control passes chunk association information e.g. representative data such as a fingerprint to index . Index is used to locate stored chunks in storage units via storage unit interface . Duplicate eliminator also referred to as a segment store identifies whether a newly received chunk has already been stored in storage units . In the event that a chunk has already been stored in storage unit s a reference to the previously stored chunk is stored for example in a chunk or segment tree associated with the file instead of storing the newly received chunk. A chunk or segment tree of a file may include one or more nodes and each node represents or references one of the deduplicated chunks stored in storage units that make up the file. Chunks are then packed by a container manager which may be implemented as part of storage unit interface into one or more storage containers stored in storage units . The deduplicated chunks may be further compressed into one or more CRs using a variation of compression algorithms such as a Lempel Ziv algorithm before being stored. A container may contain one or more CRs and each CR may contain one or more deduplicated chunks also referred to deduplicated segments . A container may further contain the metadata such as fingerprints sketches type of the data chunks etc. that are associated with the data chunks stored therein.

When a file is to be retrieved file service interface is configured to communicate with file system control to identify appropriate chunks stored in storage units via storage unit interface . Storage unit interface may be implemented as part of a container manager. File system control communicates e.g. via segmenter with index to locate appropriate chunks stored in storage units via storage unit interface . Appropriate chunks are retrieved from the associated containers via the container manager and are used to construct the requested file. The file is provided via interface in response to the request. In one embodiment file system control utilizes a tree e.g. a chunk tree obtained from namespace of content based identifiers e.g. fingerprints to associate a file with data chunks and their locations in storage unit s . In the event that a chunk associated with a given file or file changes the content based identifiers will change and the changes will ripple from the bottom to the top of the tree associated with the file efficiently since the appropriate content based identifiers are easily identified using the tree structure. Note that some or all of the components as shown as part of deduplication engine may be implemented in software e.g. executable code executed in a memory by a processor hardware e.g. processor s or a combination thereof. For example deduplication engine may be implemented in a form of executable instructions that can be stored in a machine readable storage medium where the instructions can be executed in a memory by a processor.

In one embodiment storage system may be used as a tier of storage in a storage hierarchy that comprises other tiers of storage. One or more tiers of storage in this hierarchy may utilize different kinds of storage devices and or may be optimized for different characteristics such as random update performance. Files are periodically moved among the tiers based on data management policies to achieve a cost effective match to the current storage requirements of the files. For example a file may initially be stored in a tier of storage that offers high performance for reads and writes. As the file ages it may be moved into a tier of storage according to one embodiment of the invention. In various embodiments tiers include different storage technologies e.g. tape hard drives semiconductor based memories optical drives etc. different locations e.g. local computer storage local network storage remote network storage distributed storage cloud storage archive storage vault storage etc. or any other appropriate storage for a tiered data storage system.

In one embodiment system includes processor memory and devices via a bus or an interconnect . Processor may represent a single processor or multiple processors with a single processor core or multiple processor cores included therein. Processor may represent one or more general purpose processors such as a microprocessor a central processing unit CPU or the like. More particularly processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processor may also be one or more special purpose processors such as an application specific integrated circuit ASIC a cellular or baseband processor a field programmable gate array FPGA a digital signal processor DSP a network processor a graphics processor a network processor a communications processor a cryptographic processor a co processor an embedded processor or any other type of logic capable of processing instructions.

Processor which may be a low power multi core processor socket such as an ultra low voltage processor may act as a main processing unit and central hub for communication with the various components of the system. Such processor can be implemented as a system on chip SoC . Processor is configured to execute instructions for performing the operations and steps discussed herein. System further includes a graphics interface that communicates with graphics subsystem which may include a display controller a graphics processor and or a display device.

Processor may communicate with memory which in an embodiment can be implemented via multiple memory devices to provide for a given amount of system memory. Memory may include one or more volatile storage or memory devices such as random access memory RAM dynamic RAM DRAM synchronous DRAM SDRAM static RAM SRAM or other types of storage devices. Memory may store information including sequences of instructions that are executed by processor or any other device. For example executable code and or data of a variety of operating systems device drivers firmware e.g. input output basic system or BIOS and or applications can be loaded in memory and executed by processor . An operating system can be any kind of operating systems such as for example Windows operating system from Microsoft Mac OS iOS from Apple Android from Google Linux Unix or other real time or embedded operating systems such as VxWorks.

System may further include IO devices such as devices including network interface device s input device s and other IO device s . Network interface device may include a wireless transceiver and or a network interface card NIC . The wireless transceiver may be a WiFi transceiver an infrared transceiver a Bluetooth transceiver a WiMax transceiver a wireless cellular telephony transceiver a satellite transceiver e.g. a global positioning system GPS transceiver or other radio frequency RF transceivers or a combination thereof. The NIC may be an Ethernet card.

Input device s may include a mouse a touch pad a touch sensitive screen which may be integrated with display device a pointer device such as a stylus and or a keyboard e.g. physical keyboard or a virtual keyboard displayed as part of a touch sensitive screen . For example input device may include a touch screen controller coupled to a touch screen. The touch screen and touch screen controller can for example detect contact and movement or break thereof using any of a plurality of touch sensitivity technologies including but not limited to capacitive resistive infrared and surface acoustic wave technologies as well as other proximity sensor arrays or other elements for determining one or more points of contact with the touch screen.

TO devices may include an audio device. An audio device may include a speaker and or a microphone to facilitate voice enabled functions such as voice recognition voice replication digital recording and or telephony functions. Other IO devices may further include universal serial bus USB port s parallel port s serial port s a printer a network interface a bus bridge e.g. a PCI PCI bridge sensor s e.g. a motion sensor such as an accelerometer gyroscope a magnetometer a light sensor compass a proximity sensor etc. or a combination thereof. Devices may further include an imaging processing subsystem e.g. a camera which may include an optical sensor such as a charged coupled device CCD or a complementary metal oxide semiconductor CMOS optical sensor utilized to facilitate camera functions such as recording photographs and video clips. Certain sensors may be coupled to interconnect via a sensor hub not shown while other devices such as a keyboard or thermal sensor may be controlled by an embedded controller not shown dependent upon the specific configuration or design of system .

To provide for persistent storage of information such as data applications one or more operating systems and so forth a mass storage not shown may also couple to processor . In various embodiments to enable a thinner and lighter system design as well as to improve system responsiveness this mass storage may be implemented via a solid state device SSD . However in other embodiments the mass storage may primarily be implemented using a hard disk drive HDD with a smaller amount of SSD storage to act as a SSD cache to enable non volatile storage of context state and other such information during power down events so that a fast power up can occur on re initiation of system activities. Also a flash device may be coupled to processor e.g. via a serial peripheral interface SPI . This flash device may provide for non volatile storage of system software including a basic input output software BIOS as well as other firmware of the system.

Storage device may include computer accessible storage medium also known as a machine readable storage medium or a computer readable medium on which is stored one or more sets of instructions or software e.g. module unit and or logic embodying any one or more of the methodologies or functions described herein. Module unit logic may also reside completely or at least partially within memory and or within processor during execution thereof by data processing system memory and processor also constituting machine accessible storage media. Module unit logic may further be transmitted or received over a network via network interface device . In some embodiments module unit logic includes a throttling module such as those throttling modules described above. In some embodiments module unit logic includes a job scheduler such as those job schedulers described above.

Computer readable storage medium may also be used to store the some software functionalities described above persistently. While computer readable storage medium is shown in an exemplary embodiment to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The terms computer readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media or any other non transitory machine readable medium.

Module unit logic components and other features described herein can be implemented as discrete hardware components or integrated in the functionality of hardware components such as ASICS FPGAs DSPs or similar devices. In addition module unit logic can be implemented as firmware or functional circuitry within hardware devices. Further module unit logic can be implemented in any combination hardware devices and software components.

Note that while system is illustrated with various components of a data processing system it is not intended to represent any particular architecture or manner of interconnecting the components as such details are not germane to embodiments of the present invention. It will also be appreciated that network computers handheld computers mobile phones servers and or other data processing systems which have fewer components or perhaps more components may also be used with embodiments of the invention.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as those set forth in the claims below refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the invention also relate to an apparatus for performing the operations herein. Such a computer program is stored in a non transitory computer readable medium. A machine readable medium includes any mechanism for storing information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices .

The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software e.g. embodied on a non transitory computer readable medium or a combination of both. Although the processes or methods are described above in terms of some sequential operations it should be appreciated that some of the operations described may be performed in a different order. Moreover some operations may be performed in parallel rather than sequentially.

Embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

