---

title: Data source-independent search system architecture
abstract: A search system architecture is disclosed. The search system architecture includes a search server, which in turn includes a search services module and a search engine adapter. The search services module and the search engine adapter are communicatively coupled to one another. The search services module is configured to communicate with a user interface. The search engine adapter is configured to communicate with a search engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454609&OS=09454609&RS=09454609
owner: Oracle International Corporation
number: 09454609
owner_city: Redwood Shores
owner_country: US
publication_date: 20141024
---
The present application is a continuation of U.S. patent application Ser. No. 12 254 449 filed Oct. 20 2008 entitled Data Source Independent Search System Architecture and naming Hari K. Gutlapalli Shirish K. Kothari Suhas R. Mehta and Wai Pak as inventors which claims the benefit under 35 U.S.C. 119 e of U.S. Provisional Application No. 60 981 367 filed Oct. 19 2007 entitled Data Source Independent Search System Architecture and naming Hari K. Gutlapalli Shirish K. Kothari Suhas R. Mehta and Wai Pak as inventors. The above referenced applications are hereby incorporated by reference herein in their entirety and for all purposes.

Portions of this patent application contain materials that are subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office file or records but otherwise reserves all copyright rights whatsoever.

This invention relates to the field of enterprise wide data searching and more particularly relates to a search system a search system architecture.

Businesses ever increasing reliance on information and the computing systems that produce process distribute and maintain such information in its various forms puts great demands on techniques for efficiently accessing that information. Business organizations can produce and retain large amounts and varieties of information and normally do so in fact . Searching for specific data has thus become an integral part of many enterprise applications.

Various business units within an enterprise can maintain data using a variety of searchable objects. A searchable object is a representation of a set of one or more joined tables that contain data. A searchable object can have table like behavior such as an ability to query a set of records within those joined tables. Commonly the data types within a searchable object are complex and varied.

In today s world search has become an integral part of enterprise customer relationship management CRM applications for example. In a typical CRM application used by communications companies for example thousands of call center agents create update millions of records on a daily basis. In such an environment a typical call center agent performs numerous search operations during a workday in order to get to the correct record s to assist their customers quickly and efficiently.

Additionally it is common for an enterprise to run multiple applications e.g. an enterprise resource planning ERP system CRM application human resource management system HRMS application and the like possibly from different vendors catering to various needs of the enterprise. Moreover each of these applications may need to use different search engines.

A centralized search system can be used to coordinate searching for desired data among various locations where data may be stored. It is important to optimize the search system s configuration in order to get precise relevant and accurate search results.

In an attempt to provide such advantages older search systems employ search techniques that tightly integrate searching mechanisms with the user interface. These mechanisms are neither flexible nor configurable and provide only a proprietary user interface for searching a database. Existing search architectures therefore do not provide the ability to modify the system to employ a new search engine. In other words a user cannot with minimal effort and downtime replace an existing search engine with a new one. In present systems the search engine is tightly woven into the architecture stack. Hence even a small change such as adding a new field to a search category forces the application server to be shutdown thereby potentially affecting the productivity of tens of thousands of users.

Therefore it is desirable to have a mechanism that permits search access to a number of data stores of varying types without the need for costly downtime of the enterprise wide search system. Moreover the system should allow for multiple search engines again without the need for extensive modification of the existing search architecture. Further still such a system should provide for efficient searching by allowing a user to specify a number of data stores rather than only one or all such data stores when performing a search.

The present invention provides a mechanism for a search system that is flexible and configurable. Such functionality is provided through the use of a mechanism that permits search access to a number of data source of varying types without the need for costly downtime of the enterprise wide search system. Moreover the system allows for multiple search engines again without the need for extensive modification of the existing search architecture. Further still such a system can provide for efficient searching by allowing a user to specify a number of data stores rather than only one or all such data stores when performing a search.

The search architectures described subsequently provide an example of representative enterprise data systems according to architectures of the present invention as well as their operation. This architecture is flexible and loosely coupled with the search engines and is based on a flexible and configurable object architecture. This allows pluggability for search engines to integrate with enterprise applications. The entire search configuration can be performed using the client application and hence with any changes to the system s configuration requiring a re login at most. This is in contrast to existing systems which require the restarting of the search server for example. A configuration file e.g. a field mappings file e.g. using a format such as the extensible markup language XML enables dynamic configurability and can be used to govern the definition of business component also referred to herein as BusComp based search categories. The search categories and fields to be indexed can be pre defined in a standard XML format field mappings file.

An architecture of the present invention supports push model indexing thereby absorbing the logic and control for submitting data into the application. This control provides the ability to push the new and or modified data via automated incremental indexing e.g. using a repetitive background job as well as manually refreshing the search index if required. Additionally the search engine is decoupled from the database. Finally the results irrespective of the individual data source are rendered inside the application using a generic UI not using a standard list applet. A search engine integrated with an enterprise application in the manner of the present invention can now be treated as a black box that consumes data creates manages indexes on the engine and executes searches and returns results based on hits on its index .

The present search architecture allows different search engines to be plugged into an enterprise data application of the present invention with minimal disruption and also allows the user to obtain results from these various resources in a single query. In order to plug a new search engine into the search server to integrate with application one need only write or re write the search engine specific adapters or possibly only a portion thereof depending on the change . This module works closely with the generic search adapter which typically includes elements such as a web extensions frame and web templates business components and search services. This framework is shared across all the search engines that are to be integrated the search architecture.

In turn logic tier is depicted in as including search services module and search engine adapters . Search engine adapters provide for communications between search services module and elements of search index tier and data tier . In so doing search engine adapters provide a generic interface to search services module while allowing search services module to be agnostic to the specifics of components within search index tier and data tier .

Search services can be implemented as objects for example. Such objects need not be tied to specific objects but rather can operate or act upon objects to achieve a particular goal. Such services can be reused and can be used by external systems to communicate with applications. Such objects can be configured to work with a set of properties which can be set through the use of administrative tools. Search services can also store information regarding searches performed e.g. during a given session using caching for example. By supporting such storage search services module is able to support persistent searches.

Search engine adapters can be implemented as driver dynamic link libraries DLLs for example. Using the present disclosure such driver DLLs can be implemented by third parties using what is referred to herein as a Third Party Interface . The interface for a particular search can then be implemented internally or by a third party vendor. These DLLS support the plug and play mechanism for search engines in embodiments of the present invention. Using this approach a third party search engine is then able to plug into the application by implementing the third party interface.

Search index tier includes a search engine which allows for the searching of data residing in data tier . This data is represented in as a data source within data tier .

User interface communicates a search request to search services module in logic tier . Search request can be in a standard format and so for example can be communicated as a property set. Search services then communicates search request to search engine adapters as a search query . Search query can be and preferably is in a standard generic format. For example search query can be communicated using an extensible markup language XML . Search engine adapters then communicate search query to search engine as index data . Index data will typically be in a native database format.

Search engine performs the request search and returns its results as native result data . As with index data native result data will typically be in a native database format. Search engine adapters communicate these results to search services module as result data . In the manner of the earlier discussed communications between search services module and search engine adapters e.g. search query result data can be and preferably is in a standard generic format e.g. XML . Search services then communicate these results from logic tier to user interface within client tier as search results . As before communications between user interface and search services module can be and preferably are in a standard format such as property sets. User interface receives search results and then presents these results to the user.

Should the user desire further information on one or more of the results in search results the user once again employs user interface to communicate refined search requests information search request to search services module . Search services once again sends search query appropriately modified to reflect the additional information desired by the user to search engine adapters . Search engine adapters then perform a data access in order to access the data in data source . Data source then returns the requisite data as data . Data access and data access are preferably communicated between search engine adapters and data source using a standard format such as XML. Additionally a data abstraction layer can be implemented between search engine adapters and data source either as a separate module or from at least the perspective of search engine adapters as part of data tier . In one embodiment this data abstraction layer is implemented as one or more virtual business components.

Regarding the signals described herein those skilled in the art will recognize that a signal may be directly transmitted from a first block to a second block or a signal may be modified e.g. amplified attenuated delayed latched buffered inverted filtered or otherwise modified between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next other embodiments of the present invention may include modified signals in place of such directly transmitted signals as long as the informational and or functional aspect of the signal is transmitted between blocks. To some extent a signal input at a second block may be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved e.g. there will inevitably be some attenuation and delay . Therefore as used herein a second signal derived from a first signal includes the first signal or any modifications to the first signal whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and or final functional aspect of the first signal.

The foregoing described embodiment wherein the different components are contained within different other components e.g. the various elements components of a computer system . It is to be understood that such depicted architectures are merely examples and that in fact many other architectures can be implemented which achieve the same functionality. In an abstract but still definite sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermediate components. Likewise any two components so associated can also be viewed as being operably connected communicatively coupled or operably coupled to each other to achieve the desired functionality.

In the aforementioned manner for example search engine adapter is able to communicate with a search engine residing on a search engine server of search system architecture . A number of search engines of the present invention are depicted in as search engines N . Thus search engine adapter communicates with search engine by sending index data and subsequently receiving native result data . While search engine adapters N and search engines N are depicted in as having a one to one relationship a single search engine adapter can be implemented to support more than one search engine and access to a given search engine can be implemented so as to allow search services module to use two or more of search engine adapters N . Thus the number of each need not be equal or even comparable.

Moreover it will be noted that the variable identifier N is used in several instances in to more simply designate the final element e.g. search engine adapters N and search engines N of a series of related or similar elements e.g. search engine adapters and search engines . The repeated use of such variable identifiers is not meant to imply a correlation between the sizes of such series of elements although such correlation may exist. The use of such variable identifiers does not require that each series of elements has the same number of elements as another series delimited by the same variable identifier. Rather in each instance of use the variable identified by N may hold the same or a different value than other instances of the same variable identifier.

If further information with respect to the data thus identified is desired the user can drill down delve further into the data identified . Thus in the manner discussed with regard to access by search engine adapters to data source in search engine adapters N access data sources depicted in as including data sources N to get whatever additional information is desired and available. To do so one or more of search engine adapters N sends a request for further information on a given search or search results depicted in as a data access . In response the one or more of search engine adapters N receives the requested additional information depicted in as data . As is depicted in search engine adapters N access data sources via a virtual business component of search system architecture .

Virtual business component can represent external data as a business component. This allows the user to represent external data as a business component within an application. Virtual business component also allows search services e.g. search services module to transfer data directly to user interface on client as shown in .

Virtual business component in the manner discussed with regard to the data abstraction layer of a virtual business component provides a data abstraction layer that allows search engine adapters N to access data sources N of data sources in an abstract manner. This allows search engine adapters N to access the various data sources within data sources e.g. various databases having various formats file systems having various formats flat file databases electronic mail in various formats resources on the Internet resources within an enterprise s internal network and many other such data sources . Thus search server is able to provide access to searchable data located within a heterogeneous set of searchable objects provided by a variety of vendors. Data sources thus correspond to the searchable objects that can include databases file systems portals electronic mails and other electronically accessible data sources. As can also be seen in virtual business component also provides an interface that is accessible by search services module . As with search engine adapters N the interface provided by virtual business component to search services module is preferably a standardized generic format such as would be provided by its implementation using XML.

The architecture illustrated in can therefore provide a variety of types of searches. Examples of such searches include keyword searches full text searches single item multiple item searches Boolean expression searches and synonym searches among other such searches. In addition the search system in can provide for sorting results of searches and refining searches through various functionalities provided by search server . Provision of the various functionalities can also result in different user interface screens being provided to a user throughout a session though this can be minimized or eliminated if a strictly uniform user interface is desired .

Search services is configured in part through the use of a search index. By referencing the search index the search services can provide the user interface with information identified by values provided for searching using the searchable fields available to the user. A search index can be built by providing a mapping between the searchable fields in the search index and the related fields found within the searchable objects of interest. Embodiments of the present invention provide such a mapping through the use of a modifiable field mapping file. The field mapping file provides information necessary to make a linkage between fields of the search index and fields of a variety of searchable objects. A user can be provided with the ability to modify the field mappings file and if such a modification is performed then the searchable index can be modified at runtime to provide access to or deny access to fields affected by such a modification of the field mappings file.

As will be appreciated in light of the present disclosure and particularly search engine adapters N rather than a number of search engine adapters such as search engine adapter a number of search engines e.g. search engines N of which search engine is an example can also be implemented by providing a number of search engine adapters of which search engine adapter is an example although such a configuration is not shown in for the sake of simplicity. It will be further appreciated that the implementation of multiple search engine adapters does not mandate the implementation of multiple generic search adapters a single generic search adapter can be configured to support multiple search engine adapters. Further a combination of generic search adapters can be implemented to provide some combination of 1 1 or 1 N support for multiple search engine adapters. Again such alternatives though contemplated by the present disclosure are not shown in for the sake of simplicity. Search engine presents search engine API to search engine adapter such that engine specific adapter is able to access a search index of search engine in order to provide search services module with the information requested by the user via user interface .

In the manner noted earlier with regard to search engine adapter via engine specific adapter and a virtual business component is provided access to data sources . Data sources as depicted in include a number of data sources depicted in as data sources N . Although depicted and referred to in the singular virtual business component VBC can be implemented as a set of VBCs if needed as will be discussed subsequently though including a number of elements. Virtual business component allows search services module and search engine adapter via engine specific adapter to access data sources N in a uniform and generic manner. As such virtual business component will in fact typically include a number of business objects not shown in for the sake of simplicity and can for example include a business object corresponding to each of data sources N .

In the low level class diagram of QueryAdapter Class is composed of EngineSpecificAdapter Class and these classes have a 1 1 relationship. QueryAdapter Class has a relationship with an aggregation of object classes represented in by ObjectClass . In turn EngineSpecificAdapter Class has an association with SearchAdapterBase Class . SearchAdapterBase Class has a relationship with an aggregation of object classes represented in by ObjectClass . IndexAdapter Class is composed of EngineSpecificAdapter Class in a 1 1 relationship and has a relationship with an aggregation of object classes represented in by ObjectClass .

Service Class also has a relationship with an aggregation of object classes represented in by ObjectClass . InvokeSearchService Class has a relationship with UIService Class which in turn has a relationship with Service Class and so ObjectClass . SearchQueryService Class SearchExternalService Class and ContentService Class each also have a relationship with Service Class and so ObjectClass . SearchQueryService Class SearchExternalService Class and ContentService Class also have relationships among themselves. Both SearchQueryService Class and ContentService Class are composed of SearchExternalService Class and these classes have a 1 1 relationship.

In terms of UML the foregoing thus implies that all other classes in inherit the basic characteristics of objects from ObjectClass . Similarly QueryAdapter Class is a type of EngineSpecificAdapter Class and ObjectClass . In turn EngineSpecificAdapter Class is a type of SearchAdapterBase Class . IndexAdapter Class is a type of EngineSpecificAdapter Class and ObjectClass . Service Class is also a type of ObjectClass . In turn UIService Class as well as SearchQueryService Class SearchExternalService Class and ContentService Class are each a type of Service Class . InvokeSearchService Class is a type of UIService Class . SearchQueryService Class and ContentService Class are each a type of SearchExternalService Class .

Using the low level classes of search services according to embodiments of the present invention can be made independent of the underlying adapter such search services might use. Among other advantages this independence allows search engine adapters to be swappable. These search services include services such as a Search External Service. An example of an API for a Search External Service is provided in Table 1.

Table 2 shows the Invoke Search Center Service API which is responsible for controlling the user interface presented to the user in support of the search functionality described herein.

Table 3 shows the Content Service API. This class is responsible for indexing services and is designed to handle not only a fresh index request but also incremental indexing. In addition this class provides a mechanism to perform synchronous client side or asynchronous server side indexing.

Table 4 shows the Search Data Processor Service API. This class is responsible for delegating indexing services on the server side. This class is designed to handle not only fresh index request but also incremental indexing. In addition this class provides a mechanism to perform synchronous client side or asynchronous server side indexing.

Given that each search adapter is typically crafted to access a specific search engine each such search adapter can be specific to its respective underlying search engine. In fact there need not be any interaction between the search adapters for different search engines though such search adapters can be designed to communicate with one another if desired. In the former case each such search adapter can be stored in a separate directory thereby allowing compilation into separate DLLs. As will be appreciated in light of the present disclosure a generic search adapter can also be created to serve as a default search adapter or a search adapter providing basic functionality common to all data sources or some subset thereof .

Table 5 shows the API design for a search engine adapter Search Engine Adapter Adapter API . This adapter deals with searches as well as indexing administrative functionality.

The Search Engine Adapter Adapter Class is responsible for among other functions receiving requests from the search services above and then delegating these search requests to their corresponding sub adapter classes. The Search Engine Adapter Adapter Class receives requests for performing searches indexing and or administrative tasks. The search index and administrative requests are delegated to the Query Adapter Class Index Adapter Class and Administrative Adapter Class respectively.

In light of the foregoing any business service need only acquire a reference to an instance of the Search Engine Adapter Adapter Class to propagate such requests and obtain responses thereto. The search service can dynamically instantiate the adapter using a generic search adapter reference and at runtime binds it to the actual engine specific code. At runtime the search service binds the adapter to the actual engine specific code.

The Query Adapter Class is responsible for preparing and submitting search requests to the underlying search engine. The Query Adapter Class then receives the results from the search engine in a standard format e.g. XML . The Query Adapter Class then converts this standard format e.g. the XML into an output format e.g. Property Set format and propagates this the property sets to the caller classes and up to the UI rendering code.

This class is responsible for preparing and submitting business data for indexing by the underlying search engine. The Index Adapter Service receives the indexing requests from the UI. The Index Adapter Service collects the relevant information from the UI database and then forwards the request to the corresponding service classes for further processing. The query requests are sent to the Search Query Service while the indexing requests are sent to the Search Content Service.

Examples of data model requirements are now given in the following tables. Table 8 depicts the data model requirements for search engine settings available to the administrator and so the information from Table 8 is set by the administrator. As depicted Table 8 holds the name of the search engine.

Table 9 depicts the data model requirements for search administrator engine parameter settings. The information from Table 9 is set by the administrator. This is a child of the search administrator engine settings table Table 8 . As depicted Table 9 holds the search setting parameters for example in the form of name and value pairs.

Table 10 depicts a listing of the names in the name and value pairs of the search administrator engine parameter settings table Table 9 .

Table 11 depicts the data model requirements for search settings. The information from Table 11 is displayed on a per user basis and a per engine basis on search preference screen. It is typically the responsibility of the given Business Component Business Object to retrieve the details pertaining to a given user and a given search engine from the search settings table.

Table 12 depicts the data model requirements for search operator mapping. Shown in Table 12 are the internal operators supported by one embodiment of the present invention. The search operator mapping is used by the engine specific adapter to correlate the internal operators with the engine supported logical operators.

Table 13 depicts the data model requirements for search save table. As depicted Table 13 holds the information about a search that is then saved.

Table 14 depicts the data model requirements for a search category table. As depicted Table 14 holds category information which can be obtained from information stored in certain administrative tools for example. A mapping between the category table and the collections is used which can be stored in the administrative tools repository.

Table 15 depicts the data model requirements for search category collection table. As depicted Table 15 holds information regarding the collection s to which a category belongs. This can be a temporary table. A method in the search service is called to insert update this value.

Table 16 depicts the data model requirements for search category field mappings. As depicted Table 16 holds the field mappings for a given search category. For a given search category the search category fields can be displayed in a result view screen mapping as well as the fields to be referred upon further inspection of that result view.

Table 17 depicts the data model requirements for an advanced search of a data source. As depicted Table 17 holds the name of the data source. Table 17 is used to obtain the data source values in an advanced search operation and is stored at the administrative tools level.

Table 18 depicts the data model requirements for an advanced search of a user data source. As depicted Table 18 holds the name of the data source. Table 18 is used to obtain data source values in an advanced search operation and is stored at the application level.

Table 19 depicts the data model requirements for an advanced search of a given file format Table 19 is used to get file format values in an advanced search operation. Table 19 is stored at the administrative tools level.

Table 20 depicts the data model requirements for an advanced search of a given user file format Table 20 is used to get file format values in an advanced search operation. Table 20 is stored at the application level.

Table 21 depicts the data model requirements for a search using a user selected logical operator. Table 21 corresponds to a menu selection of Perform Using which performs a search using the requisite operator s in an advanced search.

Table 22 depicts the data model requirements for a search using a user criteria. Table 22 corresponds to a menu selection of Search Criteria which performs a search using the requisite criteria in an advanced search.

In such a system the process of the present invention begins with a user interacting with a user interface. The user interface sends a search request to a search server and more particularly to a search services module step . The search frame of the user interface passes the search text and category or categories to a search execution virtual business component. Virtual business components are used rather than regular business components because the data in terms of search results come from an external data source namely search indices . The virtual business component passes the search to the search services of a search server.

Next the search server performs the requested search as depicted in greater detail in step . The search server having performed the search returns search results to the user interface step . The user interface in turn receives the search results from the search server and presents these results to the user step .

As noted depicts a flow diagram illustrating a process according to one embodiment of the present invention. It is appreciated that operations discussed herein may consist of directly entered commands by a computer system user or by steps executed by application specific hardware modules but the preferred embodiment includes steps executed by software modules or by operations performed by hardware modules. The functionality of steps referred to herein may correspond to the functionality of modules or portions of modules.

The operations referred to herein may be modules or portions of modules e.g. software firmware or hardware modules . For example although the described embodiment can include software modules and or manually entered user commands the various example modules can be implemented as application specific hardware modules. If implemented as software modules embodiments of the present invention can include script batch or other executable files or combinations and or portions of such files. Such software modules may include a computer program or subroutines thereof encoded on computer readable media.

Additionally those skilled in the art will recognize that the boundaries between modules are merely illustrative and alternative embodiments may merge modules or impose an alternative decomposition of functionality of modules. For example the modules discussed herein may be decomposed into submodules to be executed as multiple computer processes and optionally on multiple computers. Moreover alternative embodiments may combine multiple instances of a particular module or submodule. Furthermore those skilled in the art will recognize that the operations described in example embodiment are for illustration only. Operations may be combined or the functionality of the operations may be distributed in additional operations in accordance with the invention.

Alternatively such actions may be embodied in the structure of circuitry that implements such functionality such as the micro code of a complex instruction set computer CISC firmware programmed into programmable or erasable programmable devices the configuration of a field programmable gate array FPGA the design of a gate array or full custom application specific integrated circuit ASIC or the like.

Each of the blocks of the flow diagram may be executed by a module e.g. a software module or a portion of a module or a computer system user using for example a computer system such as the computer system described subsequently herein. Thus the methods described herein the operations thereof and modules therefore may be executed on a computer system configured to execute the operations of the method and or may be executed from computer readable storage media. The method may be embodied in a machine readable and or computer readable storage medium for configuring a computer system to execute the method. Thus software modules of embodiments of the present invention may be stored within and or transmitted to a computer system memory to configure the computer system to perform the functions of the module.

Such a computer system normally processes information according to a program a list of internally stored instructions such as a particular application program and or an operating system and produces resultant output information via I O devices. A computer process typically includes an executing program or portion of a program current program values and state information and the resources used by the operating system to manage the execution of the process. A parent process may spawn other child processes to help perform the overall functionality of the parent process. Because the parent process specifically spawns the child processes to perform a portion of the overall functionality of the parent process the functions performed by child processes and grandchild processes etc. may sometimes be described as being performed by the parent process.

The software modules described herein may be received by such a computer system for example from computer readable storage media. The computer readable storage media may be permanently removably or remotely coupled to the computer system. The computer readable storage media may non exclusively include for example any number of the following magnetic storage media including disk and tape storage media. optical storage media such as compact disk media e.g. CD ROM CD R etc. and digital video disk storage media. nonvolatile memory storage memory including semiconductor based memory units such as FLASH memory EEPROM EPROM ROM or application specific integrated circuits. volatile storage media including registers buffers or caches main memory RAM and the like. In a UNIX based embodiment such software modules may be embodied in a file which may be a device a terminal a local or remote file a socket a network connection or other expedient of communication or state change. Other new and various types of computer readable media may be used to store and or transmit the software modules discussed herein.

Once the search service preprocessing has been performed the search services module sends the preprocessed search request to a search engine adapter in the form of a search query step . As noted earlier the search request can be communicated in the form of one or more property sets while the search query can be communicated in a standardized generic format such as XML.

Once the search engine adapter receives the search query the search engine adapter performs search engine adapter processing on the search query step . The process of search engine adapter processing is described in further detail with regard to .

The search request having been preprocessed by the search services and processed by the search engine adapter is then sent to a search engine as index data. Using this information the search engine is able to perform the requested search step . The search engine then returns the results thus identified as native result data to the requesting search engine adapter step . Via processing by the search engine adapter and the search services the search server converts the native result data into search results that are then provided by the search services to the user interface step . The processes performed in converting the native result data into search results for consumption by the user interface by the search services module and the search engine adapter are discussed in further detail with regard to .

Once connected to the desired search engine s the search services identify the desired search categories and if needed attendant child categories step . The search services then identify any user preferences communicated to the search server in the given search request step . The search services then apply any filters requested by the user step . The search services using this information and other information in the search request then constructs the query or queries necessary to effect the search requested by the user step . With the query or queries thus constructed the search services then build one or more searches to send to the search adapter using the standardized generic format employed in communications between the search services and the search engine adapters step . The search or searches thus constructed are then sent to the requisite search adapter s step .

Once called the search engine API commands sent to the search engine in native format cause the search engine to perform the requested search step . Once the search has been performed the search engine adapter receives the native result data from the search engine at an engine specific adapter that is configured to receive these results step . The search engine adapter via the engine specific adapter and generic search adapter then reformats and converts if necessary the native response data into the standard format for presentation to the search service step . This result data is then sent in the standard format to the search service step .

Virtual business component is in communication with data sources which include data sources N . In one embodiment virtual business component includes a number of business objects N . As depicted in each of data sources N is presented to search server by one of business objects N . In the context of this aspect of the present invention business objects N can be viewed as logical tables which in some embodiments can then either represent or even store data retrieved from their respective data sources or metadata representing the data in the given data source . For example such business objects can be implemented using structured query language SQL tables.

It will be appreciated that prior to the present invention if such a structure were to become relatively large i.e. include a relatively large number of records performing searches could become cumbersome because such searches would take a relatively long time if individual tables were searched and or would often result in an inordinately large number of hits if all or a large number of such tables were searched globally or some combination thereof. This is particularly problematic if an enterprise application focuses primarily on an individual business object when searching which requires a large number of searches because each business object must be searched in such a scenario. Since many enterprises distribute information across multiple business objects this can lead to gross inefficiency resulting from the need to perform numerous searches or large global searches.

Two general types of search indices are global indices and individual indices. A global search index or more simply a global index is one large search index that indexes all the business objects to which the search engine has access. Searches using a global index typically return large number of results basically all such results because effectively all data sources are searched. Alternatively an individual index is provided. An individual search index or more simply an individual index indexes a particular business object individually. In this case then the search engine accesses only the individual search index for the desired business object. In order to search more than one such data source using such an index alone more than one search must therefore be performed by the user.

In a system according to embodiments of the present invention however such issues are addressed through the use of logical collections of business objects. These logical collections logically group business objects together for purposes of searching. This approach allows searches that are neither global nor individual but are instead focussed on the desired data from the desired data sources. In embodiments of the present invention each search index of a given search engine references one or more business objects using one or more references within the set of references that make up the search index. The search index can be used to access a given reference through the use of a keyword for example. Each keyword maps to one or more references which in turn each reference one or more business objects.

In the foregoing examples of search indices embodiments of the present invention allow a user to access business objects using a global index or individual indices using a logical collection by using information associated with the logical collection to reduce the number of business objects searched and or reduce the number of results thus generated. Regardless of the underlying search index accessed however the user need only perform one search operation to obtain the desired result s when using embodiments of the present invention.

In the case of a global index such a search returns only references from those business objects in the logical collection by filtering out those references for business objects not in logical collection or alternatively filtering out those references for business objects not in logical collection . In the case of an individual index the search engine need access individual search indices only for those business objects in the logical collection. Thus using the present invention the search engine does not need to access the search index for each and every business object. Similarly the user need not repeatedly search the various data sources of interest and then somehow aggregate the data thus retrieved into a usable collection in a suitable format. When using individual indices embodiments of the present invention return only references to business objects that are in logical collection thereby effectively searching only the desired data sources.

An application according to embodiments of the present invention supports the definition of any number of logical collections each with any combination of searchable business objects therein. In such embodiments search indexing is typically done at the individual business object level although such an indexing approach is not mandatory. As will be apparent from the present discussion when a search is executed on a logical collection the results from the search engine are based on hits from any of the business objects within the logical collection. The implementation and use of logical collections thus allows for the searching of data from multiple business objects using a single search. This reduces the number of searches a user would otherwise have to perform to get to the requisite information.

The use of a logical collection begins with the logical collection s definition. By defining a logical collection the user defines the collection of business objects to be searched. To search a logical collection the identifier for logical collection the logical collection identifier or LCID is used to access the appropriate LCID entry in a given logical collection table also referred to herein as a logical collection map within the search engine. The logical collection table maps a logical collection using the LCID to the business object s represented therein using one or more business object identifiers BOIDs .

Table 23 is an example of the logical correspondences in a logical collection table in which a logical collection of business objects is represented by the logical collection table . In the manner noted a logical collection table such as Table 23 contains information that includes a set of logical collection identifiers LCIDs and business object identifiers BOIDs among other associated information.

As will be appreciated in light of the present discussion such logical collection tables can be made customizable and so can include any number of LCIDs each of which can be a collection of any of the business objects available to the user for searching. This allows the user interface to display and the user to select one or more business objects e.g. as a list of BOIDs text representing each BOID or business object or the like and logical collections e.g. as a list of LCIDs text representing each LCID or logical collection or the like for searching.

In the example presented in Table 23 each logical collection is represented by a corresponding LCID and the logical collection represented by each LCID is as follows LCID1 BOID1 BOID2 BOID7 1 LCID2 BOID3 BOID5 BOID6 2 LCID3 BOID4 BOID5 3 

Thus the user interface allows the user to select any one of BOID1 BOID2 BOID3 BOID4 BOID5 BOID6 or BOID7 for searching individually. Additionally the user interface allows the user to select any one of LCID1 LCID2 or LCID3 for searching thereby allowing the user to efficiently search the business object s corresponding to the logical collection without the user having to repetitively search business object after business object and then somehow assemble the results.

In operation one or more keywords and LCID are sent to the appropriate search engine. The search engine uses the LCID as an index into the appropriate logical collection table to identify the business object s to be searched as identified by their respective BOID . The search engine then performs the requested search. The operations performed depend on the type of search to be performed which in turn depends on the search index to be employed.

In the case of a global search the search engine uses a global search index which returns all results that satisfy the given search. These results are then filtered using the business object identifier the BOID as specified by the given LCID and record number from the reference identified by the keyword to choose records that satisfy the search. Thus given the requisite keyword s and LCID the search engine uses the LCID to identify the business object s and the keyword s to identify the record s from which results are to be provided to the user. The user thus receives the desired results via the user interface only from the business object s in the logical collection.

In the case of an individual search the search engine uses the individual indices for the business object s identified by the selected logical collection. Using the LCID which identifies the selected logical collection the business object s identified by the BOID s of the logical collection are searched using the given keywords. This identifies one or more references into each of the business objects identified by the logical collection. Each of these references refers to a record in its respective business object s allowing retrieval of this information to satisfy the given search. Thus when using individual search indices the LCID and keyword s combination allows for the identification of the requisite business object s and record s therein.

According to embodiments of the present invention the path from logical collection to desired record s can thus proceed as follows. The logical collection s LCID is used to identify the business object s by BOID that represent the data source s the user wishes to search. Using a logical collection the logical collection s LCID and desired keyword s are sent to the search engine. Using the LCID and keyword s the search engine is able to return only the references that are in the logical collection thus returning some but not all references to which the keyword s might map . The LCID and so BOID s is used to determine which search index indices of the given search engine are to be used in searching. A search engine s search index uses keywords as tags for the reference s associated with the given keyword serving to map a keyword to its corresponding reference s . The combination of keyword s and search index thus results in one or more references. Each of these references represents a record identifier e.g. record number but more simply record and the BOID of the business object in which the desired record can be found. A reference as discussed herein therefore represents one or more records in one or more business objects. As will be appreciated in light of the present disclosure a business object and so data source can have multiple indices but will typically have at least an individual index and a global index. Thus a search index contains one or more keywords each of which provide access to one or more references each of which in turn references one or more records in one or more business objects.

Table 24 represents an example of keyword reference record correspondence according to embodiments of the present invention.

As can bee seen in Table 24 each reference references one or more business objects. In one embodiment of the present invention a search engine need only search the business object s of interest because only a subset references are searched and those references typically only reference a subset of the business objects even in the aggregate . It will be appreciated that although business objects are identified by BOID in Table 24 this is done merely to delineate one record from another in another business object . The fact that the desired record is within the given business object is simply a result of the search engine s use of the given search index as a result of the business object s BOID being one of those in the logical collection created selected by the user . The processes by which global and individual search indices are used as well as searching using such indices are discussed in further detail in connection with .

It should be noted that while the present depiction is certainly within the scope of the present invention the data abstraction layer provided by virtual business component does not require such a one to one correspondence. Multiple business objects can thus be used to represent a single data source and conversely multiple data sources can be represented by a single business object. In the manner previously discussed data sources N can be any number and type of sources of data metadata databases and other such sources of data.

As can be seen in as in earlier figures search services module and search engine adapter are able to access virtual business component in the embodiment depicted in . Search server via search engine adapter also accesses search engine via a search engine API . Search engine API in turn is presented as an interface to search engine components . Search engine components perform the requisite searching using search indices the storage of which is depicted in as a search index . Search engine components also have access to a logical collection map . Search indices such as search index in combination with logical collection map permit search engine components to perform searches of data sources N as indexed by each search engine in a fast and efficient manner.

One or more of client computers N and or one or more of servers N may be for example a computer system of any appropriate design in general including a mainframe a mini computer or a personal computer system. Such a computer system typically includes a system unit having a system processor and associated volatile and non volatile memory one or more display monitors and keyboards one or more diskette drives one or more fixed disk storage devices and one or more printers. These computer systems are typically information handling systems which are designed to provide computing power to one or more users either locally or remotely. Such a computer system may also include one or a plurality of I O devices i.e. peripheral devices which are coupled to the system processor and which perform specialized functions. Examples of I O devices include modems sound and video devices and specialized communication devices. Mass storage devices such as hard disks CD ROM drives and magneto optical drives may also be provided either as an integrated or peripheral device. One such example computer system discussed in terms of client computers N is shown in detail in .

Bus allows data communication between central processor and system memory which may include both read only memory ROM or flash memory neither shown and random access memory RAM not shown as previously noted. The RAM is generally the main memory into which the operating system and application programs are loaded. The ROM or flash memory may contain among other code the Basic Input Output system BIOS which controls basic hardware operation such as the interaction with peripheral components. Applications resident with computer system are generally stored on and accessed via a computer readable storage medium such as a hard disk drive e.g. fixed disk an optical drive e.g. CD ROM drive floppy disk unit or other such storage medium.

Storage interface as with the other storage interfaces of computer system may connect to a standard computer readable storage medium for storage and or retrieval of information such as a fixed disk drive . Fixed disk drive may be a part of computer system or may be separate and accessed through other interface systems. Many other devices can be connected such as a mouse connected to bus via serial port a modem connected to bus via serial port and a network interface connected directly to bus . Modem may provide a direct connection to a remote server via a telephone link or to the Internet via an internet service provider ISP . Network interface may provide a direct connection to a remote server via a direct network link to the Internet via a POP point of presence . Network interface may provide such connection using wireless techniques including digital cellular telephone connection Cellular Digital Packet Data CDPD connection digital satellite data connection or the like.

Many other devices or subsystems not shown may be connected in a similar manner e.g. bar code readers document scanners digital cameras and so on . Conversely it is not necessary for all of the devices shown in to be present to practice the present invention. The devices and subsystems may be interconnected in different ways from that shown in . The operation of a computer system such as that shown in is readily known in the art and is not discussed in detail in this application. Code to implement the present invention may be stored in computer readable storage media such as one or more of system memory fixed disk CD ROM or floppy disk . Additionally computer system may be any kind of computing device and so includes personal data assistants PDAs network appliance X window terminal or other such computing device. The operating system provided on computer system may be MS DOS MS WINDOWS OS 2 UNIX Linux or other known operating system. Computer system also supports a number of Internet access tools including for example an HTTP compliant web browser having a JavaScript interpreter such as Netscape Navigator Microsoft Explorer and the like.

Referring to a browser running on computer system employs a TCP IP connection to pass a request to server which can run an HTTP service e.g. under the WINDOWS operating system or a daemon e.g. under the UNIX operating system for example. Such a request can be processed for example by contacting an HTTP server employing a protocol that can be used to communicate between the HTTP server and the client computer. The HTTP server then responds to the protocol typically by sending a web page formatted as an HTML file. The browser interprets the HTML file and may form a visual representation of the same using local resources e.g. fonts and colors .

The present invention is well adapted to attain the advantages mentioned as well as others inherent therein. While the present invention has been depicted described and is defined by reference to particular embodiments of the invention such references do not imply a limitation on the invention and no such limitation is to be inferred. The invention is capable of considerable modification alteration and equivalents in form and function as will occur to those ordinarily skilled in the pertinent arts. The depicted and described embodiments are examples only and are not exhaustive of the scope of the invention.

As noted the foregoing detailed description has set forth various embodiments of the present invention via the use of block diagrams flowcharts and examples. It will be understood by those within the art that each block diagram component flowchart step operation and or component illustrated by the use of examples can be implemented individually and or collectively by a wide range of hardware software firmware or any combination thereof.

The above description is intended to be illustrative of the invention and should not be taken to be limiting. Other embodiments within the scope of the claimed invention are possible. Those skilled in the art will readily implement the steps necessary to provide the structures and the methods disclosed herein and will understand that the process parameters and sequence of steps are given by way of example only and can be varied to achieve the desired structure as well as modifications that are within the scope of the invention. Variations and modifications of the embodiments disclosed herein can be made based on the description set forth herein without departing from the scope of the claimed invention. Consequently the invention is intended to be limited only by the scope of the appended claims giving full cognizance to equivalents in all respects.

