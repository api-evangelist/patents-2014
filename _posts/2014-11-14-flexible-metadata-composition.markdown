---

title: Flexible metadata composition
abstract: Various embodiments provide an ability to abstract type resolution between multiple type systems. At least one type can be described in one or more programmatically accessible file(s). In some embodiments, an application using a different type system can programmatically access and resolve a type of the at least one type system without knowledge of a location of where a description of the type resides. Alternately or additionally, type descriptions contained in the one or more programmatically accessible file(s) can be analyzed and restructured into one or more new programmatically accessible file(s) based, at least in part, upon the type descriptions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043305&OS=09043305&RS=09043305
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09043305
owner_city: Redmond
owner_country: US
publication_date: 20141114
---
This application is a continuation of U.S. patent application Ser. No. 13 873 043 filed Apr. 29 2013 which is a divisional of and claims priority to U.S. patent application Ser. No. 13 229 697 filed Sep. 10 2011 the disclosures of which are incorporated by reference herein in their entirety.

Computing devices often run operating systems as a way to manage hardware and or software resources of the computing devices. In some cases an operating system can provide simplified programmatic access to the resources. For example the operating system can include Application Programming Interfaces APIs to expose various components. An application can successfully call an API through a different programming language and or type system than that of the API provided the application knows what types are associated with the API. For example the API can include one or more input and or output parameter s . To call the API the programmer determines not only the API s parameters but what data types are associated with parameters.

As discussed above an API can be described with a different type system than that of a calling programming language. To bridge the differing type systems a programmer typically writes wrapper code to translate between type systems. One way for the programmer to include API access in a program is to include the API definitions into source code through one or more file s and or namespaces. To successfully incorporate the files and or namespaces into the source code the source code can be configured to include a reference to the specific location of the files namespaces e.g. hardcoded path accessing a registry key with the path etc. . If the location file name and or namespace name changes the linkage is broken until the code and or software tools are updated with appropriate changes.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Various embodiments provide an ability to abstract type resolution between multiple type systems. At least one type can be described in one or more programmatically accessible file s . In some embodiments an application using a different type system can programmatically access and resolve a type of the type system without knowledge of a location of where a description of the type resides. Alternately or additionally type descriptions contained in the one or more programmatically accessible file s can be analyzed and restructured into one or more new programmatically accessible file s based at least in part upon the type system descriptions.

Various embodiments provide an ability to abstract type resolution between multiple type systems. An application using one type system can call into a second type system provided the application has knowledge on how to bridge between type systems. For example characteristics of a type system e.g. data types behavior of data types function call parameters events and the like can be described in one or more programmatically accessible file s . An application can access the files and resolve the differing type systems. In some embodiments type resolution can be abstracted such that the application can access the descriptions without prior knowledge of which file to access and or where the files reside.

In the discussion that follows a section entitled Operating Environment is provided and describes multiple environments in which one or more embodiments can be employed. Following this a section entitled Type Resolution Architecture describes an architecture that enables programmatic type system resolution. Next a section entitled Type Description Storage describes various methods that can be used to enable flexible storage of type descriptions. Last a section entitled Example System describes an example system that can be utilized to implement one or more embodiments.

Having provided an overview of various embodiments that are to be described below consider now example operating environments in which one or more embodiments can be implemented.

Environments and include respectively a computing device having one or more processor s and one or more computer readable storage media . The computer readable storage media can include by way of example and not limitation all forms of volatile and non volatile memory and or storage media that are typically associated with a computing device. Such media can include ROM RAM flash memory hard disk removable media and the like. One specific example of a computing device is shown and described below in .

In addition computing devices include operating system s OS and application s . Operating systems represent functionality configured to manage software and or hardware resource s of computing devices . This can include memory management file management services functions resource management peripheral device management and the like. Application s represent software configured to execute on computing devices typically assisted by operating system s . Application s can be implemented in a same and or different type system than that of operating system s as further described below.

Computing devices also include one or more software interface s which represent programmatic access into functions services data and the like provided by software and application s . Software interface s can enable programmatic access into operating system s and or application s . For example application s can access functionality provided by operating system s by calling the software interface s . In some embodiments application s using a different type system than that of the software interface can programmatically resolve type differences as further described below.

In addition computing devices also include one or more metadata file s which represent one or more machine readable file s that include information associated with software interface s operating system s and or application s such as input parameter types parameter calling order relationships between the interfaces and the like. Alternately or additionally software interface s can be associated with peripheral devices connected to computing devices such as a printer a scanner a smart phone and the like. In some embodiments metadata file s can be configured to describe interface s in any suitable way as further described below.

Computing device also includes merge module s . Merge module s represents functionality that can read one or more metadata file s analyze the content of the files and output one or more new metadata file s containing restructured content. In some embodiments the content can be reorganized based at least in part upon type descriptions.

Computing device includes type resolution module s . Type resolution module s represent functionality configured to receive a request to access associated type data and locate type resolution information. In some embodiments type resolution module s can locate without user input the type resolution information independent of the information changing locations. For example type resolution module s can locate without user input interface description information when the information has been moved from a first file to a second file as further described below.

Computing devices can be embodied as any suitable computing device such as by way of example and not limitation a desktop computer a portable computer a notebook computer a handheld computer such as a personal digital assistant PDA cell phone and the like.

Having described example operating environments consider now a discussion of a type resolution architecture configured to enable type resolution independent of location file name and or location.

As programming languages advance technically so do their capabilities. For example applications written in a first programming language can call into software written in a second programming language. Inherently the programming languages have different type systems. Thus in order to successfully call software residing in a different type system the first programming language uses techniques to resolve the varying types. For instance a programmer can manually write wrapper code to convert between the types. Alternately type system definitions can be stored in a file and programmatically accessed.

Programmatically accessing a file containing type definitions enables an application to determine capabilities and descriptions at runtime. However accessing a file implies knowing not only which file to access but the location of the file. If content of the file changes and or location of the file changes applications accessing the file can potentially fail unless properly updated. This can sometimes create an unintentional coupling between the application s and file s .

Various embodiments provide an ability to abstract type resolution between multiple type systems. Information associated with type resolution can be stored in programmatically accessible files. In some embodiments an application using one type system can dynamically resolve a second type system through access to the files. Alternately or additionally the application can access the files without knowledge of which file s to access and or where the file s reside.

Consider which illustrates an example architecture in accordance with one or more embodiments. Architecture includes operating system which can be configured to execute on a computing device. It should be understood that for the sake of brevity operating system is not illustrated in its entirety. Operating system includes one or more operating system component s configured to manage resources associated with a computing device. In some embodiments operating system component s can provide programmatic access to the resources as well as one or more service s and or feature s associated with managing the resources. Operating system component s can also include basic elements associated with operating system as well as complex elements built from the basic elements. While this example illustrates an architecture exposing functionality provided by operating system it is to be appreciated and understood that the architecture can be applied to expose functionality provided by other suitable types of applications without departing from the spirit of the claimed subject matter.

In some embodiments operating system component s can be exposed via one or more interface s illustrated here as operating system interface s . This can be any suitable form of an interface such as an Application Programming Interface API . An application can access functionality provided by operating system component s by calling and or executing operating system interface s as further described below. In some cases the application utilizes a type system different than a type system used to describe operating system interface s . In some cases operating system interface s can include an application binary interface s ABI . An ABI describes at a machine level a binary contract for calling functions methods APIs and the like. The binary contract can include an identification or name associated with a function a signature that can be used to call the function an order of parameters passed to the function and or data types associated with parameters etc. Alternately or additionally the binary contract can include definitions and or rules for exposing behavior associated with at least one type of a type system.

Operating system also includes various metadata . Metadata can include type resolution information that describes various aspects of associated operating system interface s such as version information what methods are available what parameters the interface s take data types of the parameters the order in which to pass the parameters data type behavior and or resolution information etc. In some embodiments the metadata can include hierarchical information associated with an interface such as information describing relationships between interface s and or describing the interface s in an object oriented manner. Metadata can also include class descriptions associated methods and parameters of a class and the like. In some cases the metadata can describe the interface using an abstract type system e.g. a type system that is independent of a specific programming language . Alternately or additionally the metadata can include descriptions of a particular type system such as the abstract type system. In turn the specific programming language s can map descriptions of a particular type system e.g. the abstract type system to the specific programming language s . Further a programmer wanting to determine which interfaces are available can manually and or programmatically access descriptions of each interface. For example to determine what interfaces exist for operating system component s what type system the interfaces are described in and how to call them the programmer can access associated metadata .

Architecture also includes one or more application s . Applications can include one or more application s generated from one or more programming language s such as HTML JavaScript Visual Basic C C and the like. In some embodiments applications include one or more call s into an operating system component. In some cases application s can be configured to first programmatically determine what interface s are available and then make a call into one or more of the determined interface s . In some cases application s accesses the interface s with help from one or more generated language projection module s as further described below.

In one or more embodiments generated language projection module s maps an abstract type definition to a specific programming language. Any suitable programming language can be mapped examples of which are provided above. In some embodiments a generated language projection module can be unique for each programming language. In other embodiments a generated language projection module can be multi purpose and utilized by multiple programming languages. A mapping enables current and future interfaces that are described using the abstract type system to be accessible to a specific programming language without additional programming statements e.g. a wrapper function . The mapping further allows a specific programming language to call an interface in a manner that is native to the specific programming language. Any suitable type of information can be mapped such as classes data types function pointers structures and the like.

Descriptions of the interface s can be used to describe how an application should call an interface as well as describe behavior of a type system associated with the interface. Responsive to the descriptions being located the application can dynamically determine how to call an interface and resolve type system differences between the application and interface. In some embodiments an application using a different type system can programmatically access and resolve a type utilized by the interface without knowledge of a location of where the type description resides. Alternately or additionally how descriptions are grouped can enable automatic type resolution as further described below.

Consider a programmer writing an application using JavaScript. While this example describes an implementation using JavaScript it is to be appreciated and understood that any programming language can be used without departing from the spirit of the claimed subject matter. To access external functionality the programmer can include a statement in source code configured to identify a namespace and or type associated with the functionality. For instance an external type can be included and or described in the source code as follows 

In this particular example Type1 represents the functionality being accessed. This can be any suitable type of functionality examples of which are provided above and below. The above syntax represents a multi level namespace hierarchy traversable to locate Type1. At the highest level Type1 resides in a namespace identified as OperatingSystem . Within OperatingSystem resides a namespace identified as Foo . Similarly within Foo resides a namespace identified as Bar where Type1 resides. Accordingly syntax can be used to identify a logical location of Type1. However a physical location of Type1 e.g. what file Type1 information resides in and or what directory the file resides in can sometimes change. In the past the physical location could be determined by hard coding a path and filename within the application directly or indirectly . Thus if the filename and or path of Type1 information changed any direct or indirect references to the file name and or path utilized by the application would be incorrect until updated. Further until the direct or indirect references were updated the application could potentially not function properly.

Various embodiments provide an ability to abstract type resolution. For example a type can be programmatically resolved by an application without exact knowledge of a location of associated type resolution information. In some embodiments the type resolution information can be relocated without updating applications utilizing the resolution information with new location information. The applications can be configured to locate the type resolution information regardless of which file the type resolution information resides in.

Consider which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method can be implemented by one or more suitably configured software module s executing on one or more computing device s such as type resolution module s of . In some embodiments the method can be performed without user intervention.

Step searches for a file with a filename that matches a type being resolved. This can include searching a plurality of metadata files as described above. Referring to the above syntax illustration responsive to an application accessing OperatingSystem.Foo.Bar.Type1 step searches for a file with the name OperatingSystem.Foo.Bar.Type1 . Any suitable type of search can be performed. For example the search can be configured to look for an exact match between the type and filename a partial match between the type and filename and the like. Alternately or additionally the search can be configured to search in one directory multiple directories and or subdirectories or any combination thereof.

Step determines whether the file exists. Responsive to determining the file exists step sends information indicating the type is a namespace. Responsive to determining the file does not exist step searches for a filename that matches a namespace associated with the type being resolved. In some cases this can include manipulating a string that contains the namespace hierarchy to determine what namespace to search on. In the above example Type1 is illustrated as being located three levels down in a namespace hierarchy. The string can be manipulated to remove the type e.g. Type1 and leave the namespace hierarchy. Here step would search for a name associated with the namespace hierarchy OperatingSystem.Foo.Bar . Similar to above this search can be configured to search for an exact match a partial match search in one directory subdirectories etc.

Step determines whether a file associated with the filename exists. Responsive to determining the file exists step processes the file for the information associated with the type.

Step determines whether information associated with the type is located within the file. Responsive to determining the information associated with the type is within the file step returns the information. For example the information can be returned to a calling program. However responsive to determining the information associated with the type is not within the file the process proceeds to step .

Step searches for a filename that matches a higher level namespace. This can be in response to determining a file does not exist such as in response to step or in response to not locating information associated with a type within a file such as in response to step . A higher level namespace can be determined in any suitable fashion. For instance in the above example the string can be further manipulated to reflect one level up in the namespace hierarchy e.g. OperatingSystem.Foo . Step determines the higher level namespace and searches for a file with an associated name.

Step determines whether a file associated with the filename exists. As in the case of step if the file is determined to exist the process proceeds to steps and or where the file is processed for associated type information.

Responsive to determining the file does not exist step determines whether another namespace hierarchy level exists. This can be determined in any suitable manner. For example the string can be searched for a level separator. In the above example syntax of a . distinguishes between levels of namespace hierarchy.

Responsive to determining another namespace hierarchy level exists the process repeats and the process returns to step to search for a file with the newly determined namespace. Steps and repeat themselves until an appropriate file is found or the top of the namespace hierarchy has been reached and searched. Responsive to determining another namespace hierarchy level does not exist step returns an error. This can include throwing an exception displaying a popup dialog box etc.

Through the use of the method described above multiple files and or locations can be searched for type resolution information. As illustrated a type search can be based at least in part on hierarchical namespace information. describes a type search that starts at a lower namespace hierarchy level e.g OperatingSystem.Foo.Bar.Type1 and traverses up each namespace level until the type is located or the top namespace hierarchy level is reached e.g. OperatingSystem . However this search can execute in any suitable order. In some embodiments a type search can start at a higher namespace hierarchy level e.g. OperatingSystem and traverse down each namespace level until the type is located or the bottom namespace hierarchy level is reached e.g OperatingSystem.Foo.Bar.Type1 . Searching on a namespace hierarchy can abstract where type resolution information can reside and further enable type resolution information to change locations without impact to applications accessing the type resolution information.

Having considered type resolution architecture configured to enable type resolution independent of location file name and or location consider now a discussion of flexible type description storage in accordance with one or more embodiments.

As metadata files can be used to describe various aspects of software interfaces. As described above metadata files can include information describing interfaces in terms of a class hierarchy an abstract type system associated methods properties and events and the like. In some cases associated information can reside in multiple files. For example different metadata files can include information pertaining to a same namespace. While multiple metadata files can give flexibility to developers of the metadata files it can sometimes hinder users of the metadata files when searching. Consider an example where each namespace has its own associated metadata file. From a partitioning standpoint separate files for each namespace can isolate changes to a namespace to an associated file. From a searching standpoint however having to search through multiple files for information can slowdown performance when searching at runtime. Further from a knowledge standpoint keeping track of what information is in what file can be compounded as the number of files increases.

Various embodiments enable type resolution without prior knowledge of a file name and file location of where type resolution information resides. Content of a set of input files can be analyzed and partitioned based at least in part on composition rules. A set of output files can be produced and are configured to include the partitioned content. The output files can enable locating the content without prior knowledge of where the content resides.

As an example consider which illustrates a relationship between descriptive language files metadata files and a merge module in accordance with one or more embodiments. In at least some embodiments modules illustrated in the relationship diagram can be implemented as software hardware or any combination thereof such as merge module s of

In the illustrated and described embodiment Foo.idl represents a descriptive language file configured to describe one or more interface s . In some embodiments an interface can be associated with an operating system and or an application such as operating system interface s and or application s of . The description language files can describe the interfaces using any suitable description markup language and or syntax such as with an Interface Definition Language IDL eXtensible Markup Language XML and the like. In this particular example Foo.idl is representative of an IDL file.

Foo.idl includes descriptions of three types Type Foo.Bar.Type1 Type Foo.Bar.Type2 and Type Foo.Bar.Type3 . While illustrated with three entries it is to be appreciated and understood that any suitable number of descriptions as well as types of descriptions can be included in Foo.idl without departing from the spirit of the claimed subject matter. For instance types can include descriptions of classes interfaces methods properties events and the like. In this example types and are described as being included in the hierarchical namespace of Foo.Bar .

Foo.metadata represents a machine readable metadata file based at least in part on Foo.idl . While not illustrated in some embodiments Foo.metadata can be generated by a compiler from Foo.idl . Similar to Foo.idl Foo.metadata includes descriptions of types Foo.Bar.Type1 Foo.Bar.Type2 and Foo.Bar.Type3 in a format native to a metadata file. Bar.metadata also represents a machine readable metadata file which is based at least in part on Bar.idl . As in the case of Foo.metadata Bar.metadata includes type descriptions Foo.Bar.Type4 Foo.Quux.Type1 and Foo.Quux.Type3 .

Included in is merge module . Merge module can accept one or more input file s and in turn generate one or more output file s based upon a set of criteria and or rules. For example input commands and or rules can be applied to merge module that specify an input directory in which to search for input files an output directory in which to place output files a level of validation to apply what level of namespace hierarchy to consolidate and or partition at how to name output files what number of output files to generate what depth metadata files should be generated at and the like. Criteria and or rules can be given to merge module in any suitable manner such as through a command line and or a makefile that contains one or more rule s .

In this example Foo.metadata and Bar.metadata are inputs to merge module . Merge module parses through the input files and generates output file s as directed. Here merge module generates two output files Foo.Bar.metadata and Foo.Quux.metadata . Foo.Bar.metadata includes types pertaining to the Foo.Bar namespace e.g. Foo.Bar.Type1 Foo.Bar.Type2 Foo.Bar.Type3 and Foo.Bar.Type4 . Similarly Foo.Quux.metadata includes types pertaining to the Foo.Quux namespace e.g. Foo.Quux.Type1 Foo.Quux.Type2 . As in the case above Foo.Bar.metadata and Foo.Quux.metadata represent machine readable metadata files that potentially contain reorganized and or regrouped data from associated input files. Thus merge module can analyze content from multiple files and restructure the content according to a set of criteria.

In some embodiments a file naming convention can be utilized to enable abstract type resolution. For example a namespace hierarchy can be used as the naming convention. In files Foo.Bar.metadata and Foo.Quux.metadata include an associated namespace hierarchy in their file name e.g. Foo.Bar and Foo.Quux respectively . By utilizing this naming convention type information can be searched for based upon its associated namespace rather than a specific file name. Alternately or additionally an output file can include multiple levels of namespace hierarchy data. In Foo.Bar.metadata is illustrated as containing data in the Foo.Bar namespace. However Foo.Bar.metadata can also be configured to include type information residing at a namespace hierarchy level of Foo.Bar.Level1.Level2.Level3 . Thus the naming convention indicates a highest level namespace that can be contained within the file.

Additionally a search algorithm such as that described in can be employed to traverse the different levels of the hierarchical namespace and associated files until an appropriate type is located. By configuring all type information at the same namespace hierarchy level to reside in the same file the information associated with a particular level can be moved from file to file without impact to applications utilizing the information. Information associated with namespace hierarchies can be partitioned in any suitable way. For example multiple hierarchy levels can reside in a same file e.g. Foo.Bar Foo.Bar.Level1 and Foo.Bar.Level2 all reside in a file named Foo.Bar.metadata or each file can have its own associated file e.g. information at the Foo.Bar level resides in Foo.Bar.metadata information at the Foo.Bar.Level1 resides in a Foo.Bar.Level1.metadata file etc. Provided the information is placed according to its associated namespace hierarchy type resolution can be abstracted by removing dependencies on a specific file name.

Consider now which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method can be implemented by one or more suitably configured software module s executing on one or more computing device s such as merge module s of

Step receives one or more input criteria associated with generating one or more output file s . In some embodiments the input criteria can include rule s that specify how to partition information into one or more output files. For example the input criteria can specify one or more namespace hierarchy levels to group together in an output file. Alternately or additionally the input criteria can describe where to find the information such as by specifying what files and or directories to pull information from.

Responsive to receiving the one or more input criteria step receives one or more input file s that include information associated with one or more software interfaces. The information can be any suitable type of information such as descriptions of the software interfaces using an abstract type system object oriented associations methods properties function pointers input and or output parameters type system information and the like. In some embodiments type information can include namespace hierarchy information.

Responsive to receiving the one or more input file s step analyzes the information based at least in part on the one or more input criteria. This can include analyzing the input files s to determine what namespace hierarchy type information exists within each file.

Responsive to analyzing the information step generates at least one output file that includes the information. In some embodiments the output files can include information that has been repartitioned into different files based at least in part on the input criteria. The output file can be configured in any suitable manner examples of which are provided above. For example the output file s can be configured as a metadata file named with a naming convention based upon a namespace hierarchy included in the metadata file. Alternately or additionally the output file s can be configured to include multiple levels of a namespace hierarchy. By grouping namespace hierarchy information together into an output file applications can search for information based upon a namespace hierarchy level rather than a specific filename. This enables flexible partitioning of the information without impact to the applications. As long as an application knows what namespace hierarchy level a particular type resides in associated type information can be located in the output files regardless of how the namespace hierarchy levels are grouped.

Having considered flexible type description storage consider now a discussion of an example system in accordance with one or more embodiments.

Computing device includes one or more processor s or processing unit s one or more memory and or storage component s one or more input output I O devices and a bus that allows the various components and devices to communicate with one another. Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. Bus can include wired and or wireless buses.

Memory storage component represents one or more computer hardware storage media. Component can include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . Component can include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

One or more input output device s allow a user to enter commands and information to computing device and also allow information to be presented to the user and or other components or devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer readable storage media .

 Computer readable storage media include volatile and non volatile removable and non removable hardware media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer readable hardware storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

Various embodiments provide an ability to abstract type resolution between multiple type systems. At least one type can be described in one or more programmatically accessible file s . In some embodiments an application using a different type system can programmatically access and resolve a type of the at least one type system without knowledge of a location of where a description of the type resides. Alternately or additionally type descriptions contained in the one or more programmatically accessible file s can be analyzed and restructured into one or more new programmatically accessible file s based at least in part upon the type descriptions.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

