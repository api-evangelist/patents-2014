---

title: System and method for processing messages using native data serialization/deserialization in a service-oriented pipeline architecture
abstract: A computer-implemented system and method for processing messages using native data serialization/deserialization without any transformation, in a service-oriented pipeline architecture is disclosed. The method in an example embodiment that includes serializing or deserializing the request/response message directly into the format (specific on-the-wire data format or a java object) the recipient expects (either a service implementation or a service consumer or the framework), without first converting into an intermediate format. This provides an efficient mechanism for the same service implementation to be accessed by exchanging messages using different data formats.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09195527&OS=09195527&RS=09195527
owner: eBay Inc.
number: 09195527
owner_city: San Jose
owner_country: US
publication_date: 20140325
---
This application is a continuation of U.S. patent application Ser. No. 12 242 653 filed on Sep. 30 2008 the benefit of priority of which is claimed hereby and of which is incorporated by reference herein in its entirety.

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. The following notice applies to the software and data as described below and in the drawings that form a part of this document Copyright 2006 2008 eBay Inc. All Rights Reserved.

This disclosure relates to methods and systems supporting computing and data processing systems. More particularly the disclosure relates to processing messages using native data serialization deserialization in a service oriented pipeline architecture.

In Services Oriented Architecture SOA there are typically many communicating reusable services that are deployed in several machines. In large scale enterprises like eBay eTrade or Google for example there could be thousands of different services deployed in thousands of machines. It is most common and efficient for these services to communicate with each other. Further external access is also typically provided for some of these services. In a typical model business functions are implemented as re usable services. Service consumers communicate with service producers providers typically using a web services protocol. In communicating with each other various different types of communication protocols may be used for efficiency and optimization reasons. Communication between service providers and service consumers can be accomplished using some pre defined protocol. In the web services case this protocol can be the Simple Object Access Protocol SOAP . SOAP is a protocol for exchanging Extensible Mark up Language XML based messages over computer networks normally using Hypertext Transport Protocol HTTP HTTPS . SOAP often forms the foundation layer of the web services protocol stack providing a basic messaging framework upon which abstract layers can be built. There are several different types of messaging patterns in SOAP but by far the most common is the Remote Procedure Call RPC pattern in which one network node the client sends a request message to another node the server and the server immediately sends a response message to the client.

Although SOAP can provide a communication or messaging protocol that can be used in some SOA implementations sometimes there is a need for communicating using other protocols. For example in some cases it may be beneficial or more efficient to use Representational State Transfer REST style HTTP messaging without any specific message protocol or some other proprietary protocol. Further when not using SOAP as the protocol the data format for exchanging messages doesn t necessarily have to be XML. When various different protocols are used the SOA must either support all protocols and thereby become complex and inefficient or the SOA is compatibility restricted to operation only with one protocol. SOA s that support multiple protocols typically have different and independent message processing models. For example an XML message received via SOAP in a conventional multi protocol SOA is processed differently and independently from the processing performed on an XML message received via a protocol other than SOAP. Thus the conventional multi protocol SOA has some duplicated functionality and inefficiencies in the model and resource utilization.

Increasingly these services are also used by a variety of clients such as a java script exchanging a message in JSON Java Script Object Notation data format or a browser exchanging a message in Name Value NV format and the like. Typical SOA frameworks implement a transformation layer where these other incoming data types or data formats are converted or normalized into a common format e.g. SOAP XML or otherwise and then the common format is processed. Unfortunately this transformation involves additional cost and time and reduces the flexibility of the system when a needed data format is not supported. Thus it would be advantageous to provide a system that did not perform a data format conversion or transformation into a common format.

U.S. Patent Application No. 2005 0223109 describes a system wherein services such as product services real time services and common services are deployed in a services oriented architecture. These services may for example be deployed for use in a variety of enterprise data integration functions.

U.S. Patent Application No. 2007 0011126 describes a service oriented architecture SOA and accompanying method. In one embodiment the SOA includes one or more service requesters coupled to one or more service providers via a bus. The bus includes runtime binding functionality to facilitate interaction between the one or more service requesters and the one or more service providers. A registry which stores information pertaining to a service provided by the one or more service providers communicates with one or more service providers and or requesters and the bus. In a more specific embodiment bus includes a Service Integration Bus SIB that includes a Service Factory SF module for facilitating implementing the runtime binding functionality and for selectively invoking the service. Functionality of the SOA is strategically organized into various tiers and layers including a requester tier a provider tier a business process services tier an infrastructure services tier an SIB layer a persistence layer and so on.

U.S. Patent Application No. 2005 0267947 describes a system including a service bus which can act as an intermediary between a client and a service. Messages to the service bus arrive on a transport and can be processed to determine a destination to route and or publish the message to a transformation to perform on the message and or security processing. The message is then sent out on a transport bound for a service or another service bus. A response to the message can follow an inverse path through the service bus.

Thus a computer implemented system and method for processing messages using native data serialization deserialization in a service oriented pipeline architecture are needed.

In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of some example embodiments. It will be evident however to one of ordinary skill in the art that the present invention may be practiced without these specific details.

As described further below according to various example embodiments of the disclosed subject matter described and claimed herein there is provided a computer implemented system and method for processing messages using native data serialization deserialization in a service oriented pipeline architecture. Various embodiments are described below in connection with the figures provided herein.

In particular as depicted in the various figures included herewith the SOA message processing model is independent of a specific protocol as protocol specific processing is made pluggable e.g. processing modules can be added or removed without requiring a significant level of re design or re configuration . As such duplicated functionality and inefficiencies in the SOA model and resource utilization can be avoided. Additionally new protocols can be added to the SOA seamlessly without having to change the SOA processing model.

Referring to a diagram illustrates an example embodiment of a computer implemented system for processing messages using pluggable protocol processors in a service oriented pipeline architecture. In the example application server system illustrated synchronous or asynchronous messages are received and sent from system either via a staged event driven architecture SEDA interface or a servlet interface for transferring synchronous data streams. The staged event driven architecture SEDA interface decomposes a complex event driven software application into a set of stages connected by queues. This design avoids the high overhead associated with thread based concurrency models and decouples event and thread scheduling from application logic. By performing admission control on each event queue the service can be well conditioned to load preventing resources from being overcommitted when demand exceeds capacity SEDA employs dynamic control to automatically tune runtime parameters such as the scheduling parameters of each stage as well as to manage load for example by performing adaptive load shedding. Decomposing services into a set of stages also enables modularity and code reuse as well as the development of debugging tools for complex event driven applications. System can also use a Quality of Service QoS module to provide various levels of priority for the incoming message streams. Messages with higher levels of priority can be dispatched more quickly into the Service Provider Framework SPF described in more detail below.

A Servlet is an object that receives a request and generates a response based on that request. A Servlet container is a specialized web server that supports Servlet execution. The Servlet container combines the basic functionality of a web server with certain Java Servlet specific optimizations and extensions such as an integrated Java runtime environment and the ability to automatically translate specific Uniform Resource Locators URLs into Servlet requests. Individual Servlets are registered with a Servlet container providing the container with information about what functionality they provide and what URL or other resource locator they will use to identify themselves. The Servlet container is then able to initialize the Servlet as necessary and deliver requests to the Servlet as they arrive. Many containers have the ability to dynamically add and remove Servlets from the system allowing new Servlets to quickly be deployed or removed without affecting other Servlets running from the same container. Servlet containers are also referred to as web containers or web engines. Servlet interface can be implemented as a servlet container in a particular embodiment. Servlet interface can process incoming synchronous messages and dispatch the processed messages into the Service Provider Framework SPF described in more detail below. SPF can receive messages typically a service request and after processing the messages in the manner described below SPF may dispatch the messages to an appropriate service . Prior to being dispatched to services the incoming message can be initially processed by a number of modules in a pipelined architecture each module performing a particular operation on the received message. These processing modules can include a G11N processing module . The term G11N as used herein refers to the operations of internationalization and localization. In computing internationalization and localization also spelled internationalisation and localisation are means of adapting computer software for non native environments especially other nations and cultures. Internationalization is the conventional process of designing a software application so that it can be adapted to various languages and regions without engineering changes. Localization is the conventional process of adapting software for a specific region or language by adding locale specific components and translating text. Due to their length the terms are frequently abbreviated to G11N as shown in . Another processing module of SPF can be logging module . Logging module is used to record various items of information related to the received message for tracking debugging and or archiving purposes. Another processing module of SPF can be rate limiting module . Rate limiting module is used to adjust the flow of messages in a stream to a pre defined rate limit or threshold. Application level caching module of SPF provides an ability to temporarily store application level information that may be accessed by the application more than once. Application level caching module can provide a higher level of efficiency because the cached information does not need to be re acquired through a network access. Security module can be provided in SPF to enforce a pre defined security policy with respect to authentication and authorization. Finally monitoring module can be provided in SPF to enable monitoring of the service invocation consumption status and subsequently to enable alerting conditions and monitoring of compliance with service level agreements SLA s . All these are examples of some of the handlers in the pipeline that control the processing of the message. There are a number of other system level handlers. Service implementers can plug in their own service specific handlers as needed. The list and order of handlers in the pipeline can be configured and customized as necessary thus providing a true pluggable pipeline architecture with improved flexibility.

Messages received by system can be configured for a variety of communication protocols. Although many SOA implementations use SOAP as a communications protocol particular embodiments of system can be used with a communication or messaging protocol that is either a proprietary protocol or some other standard messaging protocol other than SOAP. Most communication protocols for use with SOA implementations whether SOAP or another protocol typically use a common basic messaging structure general this messaging structure consists of a message header followed by a message payload or message body. In most cases the message header contains most of the protocol specific data. The message payload typically contains data content that is generally common or can be made common for all supported communication protocols. For this reason particular embodiments can isolate protocol specific message processing into a set of relatively compact protocol specific message processors one for each protocol supported by system . As will be described in more detail below the protocol specific message processors can be plugged in or added to the system architecture without a significant level of re design or re configuration of the system. Portions of the incoming message that are common to all supported protocols can be efficiently processed in a message pipeline of SPF as described Because the portions of the incoming message processed by the message pipeline of SPF are protocol agnostic i.e. not protocol specific the insertion of a new or different protocol specific message processor does not affect and therefore does not require modification to the message pipeline of SPF . In this manner the embodiments described herein can support a variety of communication protocols in an SOA implementation without causing system re designs or redundancies. These pluggable protocol processors can be registered in a configuration file. In this manner various pluggable protocol processors can be conveniently added i.e. plugged into or removed from the message pipeline of SPF without significant effort.

Referring now to a particular example embodiment of a server side runtime environment or Service Provider Framework SPF is illustrated. SPF can receive incoming messages from a requester server via a framework servlet . The incoming messages can be a server request for a service supported by the SOA. Messages received by SPF can be configured for a variety of different communication protocols. Framework servlet can handle the receipt and queuing of the incoming messages including initialization of appropriate modules. After initial processing the framework servlet forwards the incoming message to a server message processor .

Server Message Processor SMP is the main driver for processing the incoming message. At its initialization time SMP reads all the service configuration files and initializes the appropriate modules service implementation instances and any special handlers etc. Handlers are processing logic components that are plugged into the pipeline in the manner described above. The handlers act on the message typically just the header portion of the message. Examples of these handlers include security logging etc. as shown in and described above. Service configuration files in a particular example embodiment are hierarchical and are consist of three levels Global group and instance specific. The global configuration file is used to configure things that are common to all services in the deployed environment. The group level configuration file is used to configure things that are common to a group of services e.g. a specific domain like Search or Trading etc. . The Instance specific configuration file is used to configure things that are specific only to a particular service. The configuration system of SMP allows configuration of much of the functionality provided by system . For example handlers desired data formats and protocol processors can all be configured by SMP . The SMP manages the processing of the received message through several different but symmetric processing steps. These processing steps include processing a request message using the In Pipeline dispatching the processed request message through a request dispatcher processing a response message using the Out Pipeline and dispatching the processed response message through a response dispatcher . At each of these steps the appropriate protocol processor that matches e.g. is compatible with the protocol of the incoming message is also invoked. If any errors occur at any state of processing the processing flow is intercepted by the Server Message Processor SMP and an appropriate error message is returned. The error message can be sent through the Out Pipeline and response dispatcher . Thus SMP is the main driver for the message processing performed in system .

As part of the processing operations performed by the server message processor the message header of the incoming message can be decoded to determine the particular protocol for which the incoming message is coded or compatible with . Once the specific protocol corresponding to the incoming message is determined a corresponding one of the protocol specific processors can be activated to operate upon the header of the incoming message of the same or compatible protocol type. As mentioned above the specific protocol processor is invoked at each of the processing steps performed by the SMP . The specific protocol processor processes the protocol specific headers e.g. SOAP envelope in the case of SOAP and a context is maintained to reflect the processed information. This context is also made available to the pipeline in case any handler wants to look at the context. Once the specific protocol processor returns then the message is passed through the input request pipeline . The protocol agnostic portion of the incoming message e.g. message payload and transport headers is run through the input pipeline for staged processing. In a particular embodiment the pipeline can include several stages. For example a first stage of pipeline can be a logging stage for handling logging of the incoming message. Logging stage can be used to generate a record for the received message. A second stage of pipeline can be an authentication stage for handling authentication operations on the incoming message. Various types and degrees of message authentication can be implemented at this stage. A third stage of pipeline can be a G11N stage for handling the operations of internationalization and localization on the incoming message. As described above internationalization and localization operations can be used to regionalize a message so appropriate results are produced. Other stages can be added to pipeline to enable the insertion of one or more pluggable processors for handling a variety of data formats and for decoding a message payload coded in a particular data format. It will be apparent to those of ordinary skill in the art upon reading this disclosure that other stages can similarly be added to pipeline in which other operations could similarly be performed on the protocol agnostic portions of the incoming message. Further because of the pipeline architecture of the described embodiment various stages of the pipeline can be performed in parallel thereby increasing efficiency of the system .

Once the protocol agnostic portion of the incoming message is processed by each of the stages of pipeline the message can be dispatched to a corresponding service implementation module via a request dispatcher . At the point where the incoming message is passed to the request dispatcher de serialization of the message payload is performed if de serialization has not already been performed by one of the stages in pipeline . It is beneficial to push de serialization of the message payload to the later stages of processing because de serialization can be a time consuming and expensive process. The service implementation module can then perform the requested service based on the service request.

As the service implementation module generates output in response to the request for service server message processor can perform post processing on the protocol agnostic portion of the output data using an output pipeline . In a manner similar to input pipeline output pipeline can be divided into stages each stage performing an operation on the protocol agnostic portion of the output data. Once the protocol agnostic portion of the output data is processed by each of the stages of pipeline the protocol specific portion of the output data is processed by the one of the protocol specific processors . At this point the output message which can either be an output data message generated in response to the service request or an error message can be dispatched to a transport module via the response dispatcher . Transport module can deliver the output message to a service requester via a selected transport medium protocol. In the case of a synchronous communication the transport module may simply return to the SMP which in turn returns the response to the servlet container.

Referring now to a particular example embodiment of a client side runtime environment or Service Invocation Framework SIF is illustrated. SW can receive incoming messages from a client application requester via an SIF application programming interface API or through a pre generated proxy. The incoming messages can be a client request for a service supported by the SOA. A client message processor receives the incoming message either way.

The Client Message Processor CMP in a particular example embodiment is the main driver for processing the outgoing request message and for handling the received response. This is very much equivalent to the SMP on the server side. The CMP performs processing operations similar to the SMP however the CMP operates on the client side. These processing operations as described above include running the request message through the request pipeline Out pipeline request dispatcher response pipeline In pipeline and response dispatcher . Similar to the processing performed on the server side an appropriate protocol specific processor is also invoked at each of these processing steps to formulate a request message that contains the selected protocol specific envelope. Similarly an appropriate protocol specific processor is also invoked for processing of the protocol specific envelope in the response message as well. Again similar to the server side the client side also uses a hierarchy of configuration files such as global group and instance specific configurations. As described above the CMP is responsible for managing these configurations.

As part of the processing operations performed by the client message processor the message header of the outgoing message needs to be encoded to reflect the selected protocol. To do this a corresponding one of the protocol specific message processors is activated to encode the header of the outgoing message of the same or compatible protocol type. Once the specific protocol processor returns the outgoing message is run through the request pipeline Out pipeline for staged processing of the protocol agnostic portion of the message. In a particular embodiment the pipeline can include several stages. For example a first stage of pipeline can be a logging stage for handling logging of the incoming message. Logging stage can be used to generate a record for the received message. A second stage of pipeline can be an authentication stage for inserting the security credentials authentication coding and the like. As many stages can be added to pipeline as necessary to enable customization of message processing. In fact every portion of processing logic can be added as a stage also referred to as a Handler in the pipeline . Further because of the pipeline architecture of the described embodiment various stages of the pipeline can be performed in parallel thereby increasing efficiency of the system .

Once the protocol agnostic portion of the outgoing message is processed by each of the stages of pipeline the request message is dispatched to a transport factory module via a request dispatcher . The request dispatcher serializes the outgoing message into the wire data format that is selected configured before handing off the message to the transport factory module . The transport factory module delegates transport of the message via one of a plurality of pluggable transport processors . A particular embodiment can offer support for a plurality of transport modes and protocols such as a local transport useful when the client and server are deployed in the same Java Virtual Machine JVM Hypertext Transport Protocol HTTP Simple Mail Transfer Protocol SMTP and the like. The transport factory module sends the request message to the server via the respective one of the pluggable transport processors . The particular pluggable transport processor chosen for transport of the request message can be configured by the CMP . It will be apparent to those of ordinary skill in the art upon reading this disclosure that other specific transport modes protocols can similarly be added to transport factory to enable transport of the processed request message in a variety of ways.

As the service implementation on the server side generates output in response to the request for service the transport factory module receives this response and passes control to the client message processor . Client message processor then invokes the appropriate protocol specific processor for processing the protocol specific portion of the response message. The CMP then runs the response message through the response pipeline In pipeline . In a manner similar to request pipeline response pipeline is also divided into stages each stage performing an operation on the protocol agnostic portion of the incoming response data. At this point the incoming response message which can be output data in response to a service request is dispatched to a response dispatcher . Additionally the client message processor can send a response to the client application requester via the SIF API .

As described further below according to various example embodiments of the disclosed subject matter described and claimed herein there is provided a computer implemented system and method for processing messages using a common interface platform providing native data serialization deserialization in a service oriented pipeline architecture. Various embodiments are described below in connection with the .

In the example embodiments described an SOA framework is implemented as a pipeline based architecture where the incoming request messages are processed and deserialized natively into Java objects that the service implementation is expecting. For example an incoming request message may be coded in a JSON format because the request message is sent from a java script running in a browser. After running this request message through the pipeline handlers as described above various processing can be performed on the request message. Once this processing is complete the request message can be passed to the dispatcher that dispatches the processed request message to the appropriate service implementation. In the various embodiments described herein a Java object for the request message is created directly from the native data format i.e. JSON in this example without first converting or transforming the request message into a commonly known data format and then deserializing the message into the appropriate java object. The described example embodiments avoid the cost and overhead of converting or transforming the request message into a commonly known data format avoid potential loss of data semantics in the conversion process and provide the flexibility of adding support fir more native data formats without having to code transformation logic for each new data format. It will be apparent to those of ordinary skill in the art that the various embodiments of a common interface platform providing native data serialization deserialization described herein can be implemented on a SOA framework that does not use a message pipeline architecture.

In particular as depicted in the example SOA message processing model is independent of a specific message payload data serialization format or structure as a common interface platform can generalize the serialization specific and data format specific processing performed for a particular message. In this manner the serialization specific and data format specific processing performed behind the common interface platform can be made pluggable e.g. processing modules for additional types of serializers de serializers can be added or removed without requiring a significant level of re design or re configuration . As such duplicated functionality and inefficiencies in the SOA model and resource utilization can be avoided. Additionally new deserializers and or data format parsers can be added to the SOA infrastructure seamlessly without having to change the SOA processing model.

Referring to diagrams illustrate an example embodiment of a computer implemented system and method for processing messages using a common interface platform providing native data serialization deserialization in a service oriented pipeline architecture. In the example application system illustrated in requests for message serialization or deserialization can be performed on the request or response message as invoked from pipeline handlers and or request response dispatchers and shown in . Based on the request received the message serialization deserialization logic can obtain one or more of the pluggable serializers or deserializers via a de serialization factory for the corresponding data format. The message serialization deserialization logic can then initiate serialization or deserialization as the case may be on the above obtained serializer deserializer . The pluggable serializer or deserializer can then invoke the corresponding pluggable data format parser . The data format parsers are implemented in one embodiment using the standard Stax Streaming API Application programming interface for XML Extensible Markup Language parser interfaces. Once initiated the particular pluggable serializer deserializers and data format parser selected to service the de serialization request received by the dc serialization processor operates on the input message. The resulting serialized or deserialized message having been parsed by an appropriate data format parser can be cached by the dc serialization processor . The dc serialization processor can then respond to the de serialization request with a pointer to the cached processed message.

In a particular embodiment Java Architecture for XML Binding JAXB can be used as the underlying uniform model in the pluggable serializer deserializer framework and can allow plugging in different Stax parsers e.g. XML stream readers and writers for different data formats JSON NV Name Value Binary XML etc. . JAXB allows Java developers to map Java classes to XML representations JSON is short for JavaScript Object Notation which is a lightweight computer data interchange format. Basically to JAXB it appears that the data is in XML but in fact the data could be in any format. The particular data format details are hidden in the pluggable parser. The serialization of the outgoing response in SPF e.g. see and serialization of the outgoing request in SIF e.g. see can be triggered by calling on the Message Request or Response processor for input output parameters. Similarly the deserialization of the incoming request in SPF e.g. see and deserialization of the incoming response in SIF e.g. see can be triggered by calling on the Message Request or Response processor for input output parameters. This can be called from either a handler in the pipeline or the dispatcher. Either way the de serialized objects can be cached by the de serialization processor . Basically lazy on demand serialization deserialization can be performed using the described embodiments.

Referring now to an event sequence diagram illustrates the operation of the pluggable serializer deserializer framework of a particular embodiment. In an initial operation de serialization processor receives a request for message serialization or deserialization as sent from pipeline handlers and or request response dispatchers and shown in . At operation de serialization processor can access the de serialization factory to obtain access to the appropriate pluggable de serializer corresponding to the message. At operation de serialization processor can initiate one or more of the pluggable serializers or deserializers via the dc serialization factory . At operation the initiated pluggable de serializer can de serialize the message corresponding to the request and create a JAXB context appropriate for the message. The pluggable de serializer can also create and call a JAXB data un marshaller to further process the message. At step the un marshaller or the pluggable de serializer can initiate one or more of the pluggable data format parsers to parse the data format for the message. Once the message has been parsed and de serialized the pluggable de serializer can return the processed message to the dc serialization processor in operation . The de serialization processor can cache the processed message. Subsequently at operation the de serialization processor can respond to the initial request by returning the de serialized and parsed message to the requesting pipeline handlers and or request response dispatchers and .

The example computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes an input device e.g. a keyboard a cursor control device e.g. a mouse a disk drive unit a signal generation device e.g. a speaker and a network interface device .

The disk drive unit includes a machine readable medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory the static memory and or within the processor during execution thereof by the computer system . The main memory and the processor also may constitute machine readable media. The instructions may further be transmitted or received over a network via the network interface device .

Applications that may include the apparatus and systems of various embodiments broadly include a variety of electronic and computer systems. Some embodiments implement functions in two or more specific interconnected hardware modules or devices with related control and data signals communicated between and through the modules or as portions of an application specific integrated circuit. Thus the example system is applicable to software firmware and hardware implementations. In example embodiments a computer system e.g. a standalone client or server computer system configured by an application may constitute a module that is configured and operates to perform certain operations as described herein. In other embodiments the module may be implemented mechanically or electronically. For example a module may comprise dedicated circuitry or logic that is permanently configured e.g. within a special purpose processor to perform certain operations. A module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a module mechanically in the dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations. Accordingly the term module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein. While the machine readable medium is shown in an example embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present description. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media and carrier wave signals. As noted the software may be transmitted over a network using a transmission medium. The term transmission medium shall be taken to include any medium that is capable of storing encoding or carrying instructions for transmission to and execution by the machine and includes digital or analog communications signal or other intangible medium to facilitate transmission and communication of such software.

The illustrations of embodiments described herein are intended to provide a general understanding of the structure of various embodiments and they are not intended to serve as a complete description of all the elements and features of apparatus and systems that might make use of the structures described herein. Many other embodiments will be apparent to those of ordinary skill in the art upon reviewing the above description. Other embodiments may be utilized and derived therefrom such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. The figures provided herein are merely representational and may not be drawn to scale. Certain proportions thereof may be exaggerated while others may be minimized. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

Thus a computer implemented system and method for processing messages using native data serialization deserialization in a service oriented pipeline architecture are disclosed. While the present invention has been described in terms of several example embodiments those of ordinary skill in the art will recognize that the present invention is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. The description herein is thus to be regarded as illustrative instead of limiting.

