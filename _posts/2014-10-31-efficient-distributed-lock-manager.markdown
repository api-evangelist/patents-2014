---

title: Efficient distributed lock manager
abstract: A system for managing a cluster of databases that process shared data, the system including a cluster of database nodes, each node including a memory, and a processor configured to, when it is determined that: (i) a lock on a resource is required by a particular node or process, and (ii) no other lock conflicts with this particular lock, send an asynchronous lock taken (ALT) message to a distributed lock manager (DLM); and without receiving a response or permission from the DLM, taking the lock for a resource for the particular node or process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09400829&OS=09400829&RS=09400829
owner: ORI SOFTWARE DEVELOPMENT LTD.
number: 09400829
owner_city: Ramat Gan
owner_country: IL
publication_date: 20141031
---
This is a Continuation of application Ser. No. 13 468 717 filed May 10 2012 which claims the benefit of U.S. Provisional Application No. 61 519 809 filed May 31 2011. The disclosure of the prior applications is hereby incorporated by reference herein in its entirety.

Two commonly used methods to scale a database are by a shared nothing approach and a shared disk approach.

To scale by a Shared Nothing Approach the data is partitioned to multiple partitions each partition contains a portion of the data and each partition is managed by a single dedicated database server. Scaling is achieved as partitioning reduces the data size for each server and the usage of additional servers for the new partitions.

As within each server multiple threads may operate concurrently the server maintains a lock manager that coordinates between the threads. For example if two threads are to update the same resource such as a row or a block the lock manager may grant update permission to the first thread when the update of the first thread is done the lock manager may provide the permission to the second thread. Without the coordination of the lock manager both threads may update the same resource at the same time whereas these simultaneous updates may lead to erroneous result. If two threads are reading the same data the lock manager may grant both threads read permission while at the same time prevent a third thread from updating the data. When the two threads complete the read process the lock manager can provide the third thread the permission to update the data.

Within a database locks can be granted over different database resources. Examples of such resources are database table partition segment block and row. In addition locks can be of different types. For example 

A request for a lock may be issued by a thread or a process that operates over a particular resource and with the purpose of maintaining the integrity of the data and avoiding the corruption of the data.

A thread or a process requesting a lock request can represent a user using the database a session of the database a particular Node in the cluster or any other type of process or object that operates over the database data or over a resource of the database.

A request for a lock over a resource by said thread or process can be done when there is a need to operate using the resource data and the type of the lock requested depends on the type of operation. Some non limiting examples are as follows 

Within the database server software the Lock Manager is the process that receives the lock requests from the different threads or processes analyzes the requests and provides or denies the grants.

In addition the Lock Manager can place a request which can t be granted on a wait list and provide the grant later in time when the request is not conflicting with granted requests. For example a thread receives a grant for a Write Lock request and a different thread that requests a Read Lock is placed on a wait list. When the first thread releases the lock the Lock Manager grants the Read Lock to the second thread.

Within this application we call the executing database server software with its virtual or physical machine a Database Node or simply a Node . Note we hereon use the term Node and server interchangeably.

A discussion on a Shared Disk Machines and a Shared Nothing Machines is also available by Hector Garcia Molina Jeffrey D. Ullman Jennifer Widom at Database Systems The Complete Book Second Edition pages 986 989.

In a Shared Nothing system all the threads operate within the same Node and therefore share the same memory space. The locking requests of each thread may utilize the shared memory in the Node. For example the request can be placed by the threads on a linked list which is processed by the Lock Manager.

In a Shared Disk Approach the data is not partitioned. Multiple Nodes are connected to a shared storage and each of the servers can access read and or write the shared data. A shared disk solution is implemented as a cluster of Nodes that share the same data. Scaling is achieved by adding computing power by means of adding Nodes which operate concurrently over the data. If more computing power is needed additional database servers Nodes can be added to the cluster.

Compared to a Shared Nothing Approach scaling is provided inherently by the database Cluster the database cluster is built such that more computing power can be added by adding more database servers to the cluster . With a Shared Nothing Approach scaling is done by the developer as the data partitioning needs to be tailored by the developer. The partition of the data needs to achieve even distribution of the data among the servers as well as even distribution of users among the servers. It also needs to consider the composition of the queries. For example the partitioning should be done such that most queries would be satisfied on a single server. These are difficult tasks as sometimes there is no good partitioning approach and it involves considerations which are different for each application. In addition the type of queries may not be known in advance.

An example of the complexity imposed by a Shared Nothing approach is the following 1 the database contains customers and catalog information. 2 Many of the queries are joining customers and catalog information. 3 To scale the customer data is partitioned to multiple partitions. However the developer is now facing the question of where to store the catalog. If the catalog is to be stored on a dedicated server the queries that join the customers and the catalog info would need to retrieve information from two separate servers from the server managing the customer information and the server managing the catalog information. If the catalog information is duplicated on each server every update to the catalog information needs to be executed on each of the servers that maintain the catalog information.

For the developer the Shared Disk Approach offers a simple automated way to scale. When large data sets are managed by a Shared Disk database there is no need to partition the data. Multiple servers have read and write access to the data. To scale more servers are added to the cluster. As each of the Nodes in the cluster may have concurrent processes each of these servers may have a local lock manager similar to the lock manager described above with respect to the Shared Nothing Approach server. However a database system that provides a Shared Disk Approach solution needs in addition to synchronization of multiple threads within each server to synchronize the lock requests at a cluster level as different nodes may have processes that are processing the same data at the same time. To synchronize the requests of different servers a Distributed Lock Manager is used. This lock manager synchronizes requests from multiple nodes in a cluster. As the different servers don t have a shared memory space the lock requests and grants are done by messages that are sent over a network. This process is by far slower than the process of the Local Lock Manager within a server that is based on a shared memory a process of the lock manager based on a shared memory may run in nanoseconds whereas messages over network may be even measured in milliseconds depending on the speed of the network .

There is accordingly a need in the art to reduce the time needed to satisfy lock processes that are done to manage a shared disk and similar database systems.

For clarity of explanation there follows a glossary of additional terms used frequently throughout the description and the appended claims. Some of the terms are conventional and others have been coined 

Database and Database Management System DBMS is explained by Hector Garcia Molina Jeffrey D. Ullman Jennifer Widom at Database Systems The Complete Book Second Edition. See also C.J.Date An Introduction to Database Systems Volume 1 Fourth Edition. See also http endotwikipediadotorg wiki Database and http endotwikipediadotorg wiki Database management system database and Database Management System from Wikipedia .

Node the Database Management System DBMS server software with its virtual or physical machine. We hereon use the term Node and server interchangeably. The Node executes the database management software. Two non limiting examples would be a computer server executing the Oracle database software and a computer server executing the IBM DB2 software. A Node provides management of data such that users are provided with the methods and tools among others to update and query the data. For example a Node executing an Oracle database software such that data manipulation requests such as Insert Update Delete and Select issued by users trigger processes that update and query data. Cluster or a Database Cluster Multiple Database Nodes that provide management of the data. These Nodes may be connected via a network and may provide management of Shared Data. Shared Data Data which is being managed by multiple Nodes.

A relational database is a database that conforms to relational model theory. The software used in a relational database is called a relational database management system RDBMS . In a relational database data is logically partitioned into tables and is organized as rows within the tables. The physical implementation may be different for example rows may be physically stored within blocks within files. Some of the resources of the database may be indexes which are not part of the relational model theory and which may be organized in blocks within files. The examples below may be provided using the logical organization of rows within tables or may be provides using some physical organization such as rows within blocks. However the processes of the invention are not bound to a particular logical or physical organization.

Lock Manager a process that receives lock requests from different processes or threads analyzes and manages the requests such that the integrity of data is maintained. In the context of the invention a Lock Manager may issue particular locks without explicit lock requests when it determines that a particular process or a particular Node is interested with the particular lock.

Local Lock Manager LLM a Lock Manager that analyzes and manages the lock requests of different threads or processes by utilizing a shared memory space. This Lock Manager and the requesting threads or processes exist within the same Node.

A discussion on locking is also available by Hector Garcia Molina Jeffrey D. Ullman Jennifer Widom at Database Systems The Complete Book Second Edition Chapter 18 Concurrency Control section 18.4 Locking Systems with Several Lock Modes pages 905 913.

Distributed Lock Manager DLM a Lock Manager that analyze and manage lock requests of different threads or processes of different Nodes. This Lock Manager and the different threads communicate by sending messages over a network. The DLM manages a Cluster of Nodes. The management of a Local Lock manager or a Distributed Lock Manager together with other processes maintains the integrity of the data. Some databases maintain compliance to the ACID set of rules. ACID atomicity consistency isolation durability is a set of properties that guarantee that database transactions are processed reliably. More details on ACID properties of a database are available at http endotwikipediadotorg wiki ACID From Wikipedia .

A DLM operates by monitoring the processes in the different Nodes. It analyzes lock requests that are issued from different processes or Nodes provides grants to non conflicting requests for example multiple processes may read the same data at the same time and sets an order among conflicting requests. For example a Write Lock is provided to process A a grant for read or write request for process B is delayed until the lock of process A is released.

SQL from Wikipedia sometimes referred to as Structured Query Language is a programming language designed for managing data in relational database management systems RDBMS . SQL was one of the first commercial languages for Edgar F. Codd s relational model as described in his influential 1970 paper A Relational Model of Data for Large Shared Data Banks . http endotwikipediadotorg wiki SQL cite note codd relational model 4

SQL became the most widely used database language. SQL is used also as a data manipulation language DML which is a family of syntax elements similar to a computer programming language used for inserting deleting and updating data in a database. Storage Engine from Wikipedia A Database Engine or storage engine is the underlying software component that a database management system DBMS uses to create read update and delete CRUD data from a database. Most database management systems include their own Application Programming Interface API that allows the user to interact with their underlying engine without going through the user interface of the DBMS.

Many of the modern DBMS support multiple database engines within the same database. For example MySQL supports InnoDB as well as MyISAM and other Storage Engines.

Attention is first directed to showing DBMS client software executed on local computers which are connected via the internet to a private network that is connected to multiple Nodes which can read and write from a shared storage via a private network . As a non limiting example the client software can be MySQL client such as payroll software which is using MySQL as the DBMS that sends SQL queries to one or more of the MySQL servers . Each of the MySQL servers is using a Storage Engine that can read and write data from the shared storage .

As the data on the storage is shared among the Nodes in order to maintain the coherency of the data the Nodes needs to synchronize operations over the shared data The process of the synchronization is done by a Distributed Lock Manager such as the lock manager in .

Once a lock is granted to a Node a Local Lock Manager such as the LLM of Node which is marked in may synchronize the lock among the processes or threads within the Node that requested the lock. For example on a particular Node a thread is doing an Update operation of a particular row of a particular table. This process is evaluated by the LLM to find if another thread on the Node maintains a lock on the row and by the DLM to find if a different Node maintains a conflicting lock. By a different non limiting example and implementation the DLM synchronize the lock requests of different processes within different Nodes as well as synchronizing the requests among different processes of the same Node.

If there are no conflicts the lock is granted by the LLM and DLM indicating a grant of a lock of a particular type on the particular resource. With reference to and as a non limiting example if Node received a grant for a particular lock the grant of the particular lock is maintained as an internal structure within the LLM of Node showing the details of the resource the type of the lock and the details of the process that received the grant whereas the DLM in maintains an internal structure showing the details of the resource the type of the lock and the Node ID which will be Node that received the grant and the details of the process that received the grant.

These data structures are used to evaluate new lock requests for the same resource. When threads release the lock of the resource they notify the LLM that a lock was release and if the lock is released by all threads in the Node the DLM is notified that the locks over the resource within a particular Node were released. In this particular example locks in the LLM are organized to include the resource ID and the ID of the thread requesting the lock whereas in DLM locks are organized to include the resource ID and the Node ID.

Since the LLM and the processes of a particular Node share the same memory space lock requests to the LLM are processes fast The requesting thread may update a linked list with the details of the lock needed. Once the request is placed on the lined list the LLM can evaluate the list and if possible provide the lock. This process may run in nanoseconds. However as the Nodes and the DLM don t share the same memory space lock requests to the DLM are based on messages that utilize the network and may be much slower. Even with a fast network a message may take of a millisecond which is considerably slower than the shared memory process of the LLM. The known approach of acquiring locks with a DLM is by sending a lock request message from the Node requesting a lock to the DLM. When received at the DLM the request is analyzed and if the request is not conflicting with the state of the resource which is held by the DLM the lock is granted by a message which is send from the DLM back to the Node. This process is synchronous as a message is send and the process on the Node that initiated the request is waiting for a returned reply.

To cope with the performance drawback of lock requests via the network Asynchronous Lock Taken hereon ALT message is suggested. This process is detailed and exemplified below ALT a message informing the DLM that a lock over a particular resource was taken. This type of message is used when a Node is able to determine that no other Node is conflicting with this particular lock over the particular resource. In the case of ALT the requestor does not wait for a reply from the DLM.

When a lock request for a particular block is received by the DLM it is processed and a grant message may be send to the Node. In order to transform the Lock Requests for the individual rows to ALT messages DLM replies to the lock request of the block not only with the grant but also with the lock status of the rows which are contained in the block. Therefore a lock request for a data block that contains rows may include the information provided below or part of the information 

When the message with the grant of the block lock arrives at the Node the process in the Node that requested the block lock is able to continue the processing. As will be demonstrated below the additional information allows the Node to operate more efficiently as it may leverage the additional information that was provided with the reply to the lock request of the block. Below is an example of such process 

A user issues a query where different rows are selected by a particular process in the Node and are returned to the user. The processes in the Node and the DLM include the following steps 

The decision if a lock on a particular row is needed and the type of lock to use as in step g above is exemplified below 

To allow the Nodes in a cluster to work efficiently it is needed to minimize the usage of requests that require a reply to the requestor. If the DLM determines that a particular resource is being frequently used by only a single Node DLM may place the resource in an Ownership Mode. The Ownership Mode indicates that only the specified Node is allowed to operate with the resource. That means that only the LLM is needed to provide grants for lock requests for the resource which is marked at Ownership Mode and for the duration of the Ownership Mode . Ownership Mode can be granted to a particular Node over a particular Resource such as a table a block or a row or over particular group of resources such as over all the blocks in a particular segment or all the rows in a particular block . Ownership Mode can be revoked from the Node when a different Node requests a lock over the particular resource or group if resources . If a different Node requests a lock over the resource the following process is needed 

In a similar manner DLM may determine that a particular resource is frequently read by one or more Nodes. It sets the resource to Read Only Mode. If a lock request message for type read is send to the DLM DLM replies with a lock grant and a flag indicating that this resource is in a read mode. The Read Only Mode for the resource is set in the Node such that as long that the Node does not need to acquire a lock that conflicts with the Read Lock such as a Write Lock the Node does not need to send messages to the DLM for that particular resource. If a process in the Node needs a conflicting lock such as a Write Lock over the resource it will send a lock request to the DLM. In that case DLM will send a message to all the Nodes that were notified of the Read Only Mode of the resource. Each of these Nodes would cancel the Read Only Mode and reply with a message that includes the lock state of the particular resource. Once all the relevant Nodes replied the DLM will update its internal structure with the information received and analyze the new lock request to determine if the requested lock can be granted.

When an Ownership Mode or a Read Only Mode over a particular resource is cancelled The Nodes change the mode over the particular resource such that new lock requests needs to be synchronized with the DLM. When the relevant Nodes confirm the mode change they may send a message to the DLM which may include the information about the locks held over the particular resource at the time of the change. The DLM will use the information to construct an internal structure to reflect the locks being held. This process provides the DLM with the information needed to process new lock requests.

The DLM considering the lock state of particular resources may dynamically switch the mode to Ownership Mode or Read Only Mode. When conflicting requests are send to the DLM the DLM may dynamically cancel the Ownership Mode or Read Only Mode.

The DLM by providing particular lock states to Nodes may implicitly or explicitly provide the Nodes with the ability to issue ALT requests on related resources. Below are some non limiting examples 

These examples demonstrate that within a cluster a particular Node or a thread or a process within a Node is able to grant itself a lock on a particular resource without the need to wait for reply from the distributed lock manager. This process is synchronized among the Nodes of the cluster such that if a particular Node is able to grant itself a lock other Nodes need to send a message to the DLM and wait for reply from the DLM for conflicting requests.

In one embodiment the DLM manages the distribution of new blocks between the different Nodes in the cluster. A new block may be used by a Node as a container for new Rows which are added to the database data by the users. An example to a process that adds a new row to the database is a process executing an Insert statement the Insert statement is a user request specified in SQL to instruct the database management software to add a new row to a particular data table.

Therefore when a Node processes requests to add new rows to the database data it requests one or more blocks to accommodate the new rows. This request is send to the DLM. The DLM manages the distribution of blocks among the Nodes of the cluster such that every Node receives unique blocks. Therefore a request from a Node to the DLM to provide a block that will be used as a container for new rows that are to be added to the database is satisfied by the DLM by providing a new and unique one or more block id a Write Lock for the requesting Node on the particular block and a Write Lock for the requesting Node on all the rows that can be placed in the block. By this process if a Node is using a block that was provided by the DLM as a container for new rows there is no need to send a lock requests to the DML for the particular block and there is no need to send a lock request to the DML for the particular rows that are to be added in the block as these locks were granted when the DML distributed the block to the Node.

