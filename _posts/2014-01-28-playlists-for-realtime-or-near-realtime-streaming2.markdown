---

title: Playlists for real-time or near real-time streaming
abstract: Methods and apparatuses for real-time or near real-time streaming of content using transfer protocols such as an HTTP compliant protocol. In one embodiment, a method includes dividing a stream of data, representing the contiguous time based content of a program (e.g. a live video broadcast), into a plurality of distinct media files, and generating a playlist file having a plurality of tags and Universal Resource Indicators (URIs) indicating an order of presentation of the plurality of distinct media files. The plurality of media files and the playlist file can be made available for transmission to a client device which can retrieve the media files using the playlist file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09558282&OS=09558282&RS=09558282
owner: Apple Inc.
number: 09558282
owner_city: Cupertino
owner_country: US
publication_date: 20140128
---
This application is a continuation of U.S. application Ser. No. 13 593 040 filed on Aug. 23 2012 now issued as U.S. Pat. No. 8 650 192 which is a divisional of U.S. patent application Ser. No. 12 479 735 filed on Jun. 5 2009 which claims the benefit of the file dates of the following U.S. provisional applications 

All of these U.S. provisional applications are incorporated herein by reference to the extent that they are consistent with this disclosure.

The present U.S. patent application is related to the following U.S. patent applications each of which is incorporated herein by reference 

Embodiments of the invention relate to data transmission techniques. More particularly embodiments of the invention relate to techniques that allow streaming of data using non streaming protocols such as for example HyperText Transfer Protocol HTTP .

Streaming of content generally refers to multimedia content that is constantly transmitted from a server device and received by a client device. The content is usually presented to an end user while it is being delivered by the streaming server. The name refers to the delivery method of the medium rather than to the medium itself.

Current streaming services generally require specialized servers to distribute live content to end users. In any large scale deployment this can lead to great cost and requires specialized skills to set up and run. This results in a less than desirable library of content available for streaming.

In one embodiment a server device stores at least a portion of content to be streamed. The content is typically a time based stream of images or audio e.g. sounds or music or both an example of a time based stream is a movie in which the order and presentation of images is based on time and hence it can be considered a time based stream. The server includes a segmenter agent to decompose the content to be streamed into segments to be transmitted via packets according to a network protocol and an indexer agent to generate one or more playlist files that can facilitate a client in presenting the segmented user data. A client device is coupled with the server device or another server which stores the segments and playlists and transmits them but does not generate them via a network. The client device has an assembler agent to receive the one or more playlist files and facilitate retrieval of the segmented media files into the content according to the one or more playlist files. The client device can also have an output generator agent to output the content via one or more output components of the client device.

In one embodiment the server device acquires data to be transmitted to the client device. The server device divides the data to be transmitted into multiple media files with a segmenter agent. The server device also stores the multiple segments as individual media files in a memory. The server device further generates one or more playlist files having references to the multiple media files. In response to requests for the data from the client device the server device or another server device transmits the one or more playlist files and at least a subset of the multiple media files over a network to the client device. The multiple media files can be transmitted using a non streaming transfer protocol in response to requests from the client device this protocol may be for example HTTP.

In one embodiment the client device can receive and store the one or more playlist files. The client then can request the segmented media files identified in the playlist file s and download the linked media files. The client device or another client device can then generate an audio and or video output representing the stream of content.

In one embodiment an updated playlist can be dynamically generated by a server and then retrieved by a client. The updated playlist can include ancillary material e.g. advertisements in a sidebar user interface related content alternative versions etc. shown in addition to the program in the original playlist or can include additional portions of the program e.g. the second half of a program which is beyond the first half identified in the original playlist . In one implementation a server can use a rolling method described herein to update the playlist which is then retrieved by the client as an updated playlist.

In one embodiment a playlist can specify a plurality of alternative streams representing the same content these alternative streams may be the same program transmitted at different visual resolutions and hence transmitted at different bit rates or with other different attributes. A server can generate multiple playlists each for one of the alternative streams and can generate a variant playlist which refers to or otherwise specifies the alternative streams. The server or another server can then transmit the variant playlist to a client device and the client device can decide based on current network conditions e.g. the current throughput rate on a network used to transfer the media files which playlist to select from the variant playlist and the client device can download the selected playlist and further download the media files specified by that selected playlist .

In one embodiment a client device can switch from a first playlist in the variant playlist to a second playlist in that variant playlist while receiving and presenting content. For example a client device can be receiving a program using the first playlist and a first bit rate and can determine through measurements of the throughput rate of the network that it can receive content of the same program at a higher second bit rate that content being specified by the second playlist. In this case the client device can request the second playlist receive the second playlist and begin retrieving the media files specified in the second playlist while continuing to present the content specified by the first playlist. The client device can store the media files and the resulting decompressed content in buffers for both playlists and the client device can perform an automatic operation to determine when and how to switch or transition between the two versions of the content. For example a client device can use pattern matching of the audio content in the two versions of the content to find a matching point in the two versions and then cause a switch after identifying a transition in the new content from the second playlist.

In the following description numerous specific details are set forth. However embodiments of the invention may be practiced without these specific details. In other instances well known circuits structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

The present description includes material protected by copyrights such as illustrations of graphical user interface images. The owners of the copyrights including the assignee of the present invention hereby reserve their rights including copyright in these materials. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office file or records but otherwise reserves all copyrights whatsoever. Copyright Apple Inc. 2009.

In one embodiment techniques and components described herein can include mechanisms to deliver streaming experience using non streaming protocols e.g. HTTP and other technologies e.g. Motion Picture Expert Group MPEG streams . For example near real time streaming experience can be provided using HTTP to broadcast a live musical or sporting event live news a Web camera feed etc. In one embodiment a protocol can segment incoming media data into multiple media files and store those segmented media files on a server. The protocol can also build a playlist file that includes Uniform Resource Identifiers URIs that direct the client to the segmented media files stored on a server. When the segmented media files are played back in accordance with the playlist file s the client can provide the user with a near real time broadcast of a live event. Pre recorded content can be provided in a similar manner.

In one embodiment the server can dynamically introduce supplementary or alternative media content e.g. advertisements statistics related to a sporting event additional media content to the main presentation into the broadcast event. For example during client playback of a media event the server can add additional URIs to the playlist file the URIs may identify a location from which a client can download a supplementary media file. The client can be instructed to periodically retrieve from the server one or more updated playlist file s in order to access any supplementary or additional or both media content the server has introduced.

In one embodiment the server can operate in either cumulative mode or in rolling mode. In cumulative mode the server can create a playlist file and append media file identifiers to the end of the playlist file. The client then has access to all parts of the stream from a single playlist file e.g. a user can start at the middle of a show when downloaded. In rolling mode the server may limit the availability of media files by removing media file identifiers from the beginning of the playlist file on a rolling basis thereby providing a sliding window of media content accessible to a client device. The server can also add media file identifiers to the playlist and in rolling mode the server can limit the availability of media files to those that have been most recently added to the playlist. The client then repeatedly downloads updated copies of the playlist file to continue viewing. The rolling basis for playlist downloading can be useful when the content is potentially unbounded in time e.g. content from a continuously operated web cam . The client can continue to repeatedly request the playlist in the rolling mode until it finds an end tag in the playlist.

In one embodiment the mechanism supports bit rate switching by providing variant streams of the same presentation. For example several versions of a presentation to be served can be stored on the server. Each version can have substantially the same content but be encoded at different bit rates. This can allow the client device to switch between bit rates depending on for example a detection of the available bandwidth without compromising continuity of playback.

In one embodiment protection features may be provided to protect content against unauthorized use. For example non sequential media file numbering may be used to prevent prediction. Encryption of media files may be used. Partial media file lists may be used. Additional and or different protection features may also be provided.

Network may be any type of network whether wired wireless e.g. IEEE 802.11 802.16 or any combination thereof. For example Network may be the Internet or an intranet. As another example network may be a cellular network e.g. 3G CDMA . In one embodiment client devices and may be capable of communicating over multiple network types e.g. each device can communicate over a WiFi wireless LAN and also over a wireless cellular telephone network . For example client devices and may be smart phones or cellular enabled personal digital assistants that can communicate over cellular radiotelephone networks as well as data networks. These devices may be able to utilize the streaming mechanisms described herein over either type of network or even switch between networks as necessary.

Server may operate as a HTTP server in any manner known in the art. That is server includes a HTTP server agent that provides content using HTTP protocols. While the example of is described in terms of HTTP other protocols can be utilized in a similar manner. Segmenter and indexer are agents that reside on server or multiple servers to provide content in media files with a playlist file as described herein. These media files and playlist files may be provided over network via HTTP server agent or via other servers using HTTP protocols. Agents as discussed herein can be implemented as hardware software firmware or a combination thereof.

Segmenter may function to divide the stream of media data into multiple media files that may be transmitted via HTTP protocols. Indexer may function to create a playlist file corresponding to the segmented media files so that client devices can reassemble the media files to provide real time or near real time transmission of the content provided by server . In response to one or more requests from a client device HTTP server agent or other servers may transmit one or more playlist files as generated by indexer and media files of content as generated by segmenter . Server may further include optional security agent that provides one or more of the security functions e.g. encryption discussed herein. Server may also include additional components not illustrated in .

Client devices and may receive the playlist files and media files from server over network . Client devices may be any type of electronic device that is capable of receiving data transmitted over a network and generate output utilizing the data received via the network for example wireless mobile devices PDAs entertainment devices consumer electronic devices etc. The output may be any media type of combination of media types including for example audio video or any combination thereof.

Client device can include assembler agent and output generator agent . Similarly client device can include assembler agent and output generator agent . Assembler agents and receive the playlist files from server and use the playlist files to access and download media files from server . Output generator agents and use the downloaded media files to generate output from client devices and respectively. The output may be provided by one or more speakers one or more display screens a combination of speakers and display screens or any other input or output device. The client devices can also include memory e.g. flash memory or DRAM etc. to act as a buffer to store the media files e.g. compressed media files or decompressed media files as they are received the buffer can provide many seconds worth of presentable content beyond the time of content currently being presented so that the buffered content can later be displayed while new content is being downloaded. This buffer can provide presentable content while the client device is attempting to retrieve content through an intermittently slow network connection and hence the buffer can hide network latency or connection problems.

Client devices and may further include optional security agents and respectively that provide one or more of the security functions discussed herein. Client devices and may also include additional components not illustrated in .

In one embodiment the techniques that are described in this application may be used to transmit an unbounded stream of multimedia data over a non streaming protocol e.g. HTTP . Embodiments can also include encryption of media data and or provision of alternate versions of a stream e.g. to provide alternate bit rates . Because media data can be transmitted soon after creation the data can be received in near real time. Example data formats for files as well as actions to be taken by a server sender and a client receiver of the stream of multimedia data are provided however other formats can also be supported.

A media presentation that can be transmitted as a simulated real time stream or near real time stream is specified by a Universal Resource Indicator URI that indicates a playlist file. In one embodiment the playlist file is an ordered list of additional URIs. Each URI in the playlist file refers to a media file that is a segment of a stream which may be a single contiguous stream of media data for a particular program.

In order to play the stream of media data the client device obtains the playlist file from the server. The client also obtains and plays each media data file indicated by the playlist file. In one embodiment the client can dynamically or repeatedly reload the playlist file to discover additional and or different media segments.

The playlist files may be for example Extended M3U Playlist files. In one embodiment additional tags that effectively extend the M3U format are used. M3U refers to Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator MP3 URL and is a format used to store multimedia playlists. A M3U file is a text file that contains the locations of one or more media files for a media player to play.

The playlist file in one embodiment is an Extended M3U formatted text file that consists of individual lines. The lines can be terminated by either a single LF character or a CR character followed by a LF character. Each line can be a URI a blank line or start with a comment character e.g. . URIs identify media files to be played. Blank lines can be ignored.

Lines that start with the comment character can be either comments or tags. Tags can begin with EXT while comment lines can begin with . Comment lines are normally ignored by the server and client. In one embodiment playlist files are encoded in UTF 8 format. UTF 8 8 bit Unicode Transformation Format is a variable length character encoding format. In alternate embodiments other character encoding formats can be used.

In the examples that follow an Extended M3U format is utilized that includes two tags EXTM3U and EXTINF. An Extended M3U file may be distinguished from a basic M3U file by a first line that includes EXTM3U .

EXTINF is a record marker that describes the media file identified by the URI that follows the tag. In one embodiment each media file URI is preceded by an EXTINF tag for example 

The EXT X TARGETDURATION tag can indicate the approximate duration of the next media file that will be added to the presentation. It can be included in the playback file and the format can be 

Each media file URI in a playlist file can have a unique sequence number. The sequence number if present of a URI is equal to the sequence number of the URI that preceded it plus one in one embodiment. The EXT X MEDIA SEQUENCE tag can indicate the sequence number of the first URI that appears in a playlist file and the format can be 

Some media files may be encrypted. The EXT X KEY tag provides information that can be used to decrypt media files that follow it and the format can be 

An encryption method of NONE indicates no encryption. Various encryption methods may be used for example AES 128 which indicates encryption using the Advance Encryption Standard encryption with a 128 bit key and PKCS7 padding see RFC3852 . A new EXT X KEY tag supersedes any prior EXT X KEY tags.

An EXT X KEY tag with a URI parameter identifies the key file. A key file may contain the cipher key that is to be used to decrypt subsequent media files listed in the playlist file. For example the AES 128 encryption method uses 16 octet keys. The format of the key file can be a packed array of 16 octets in binary format.

Use of AES 128 normally requires that the same 16 octet initialization vector IV be supplied when encrypting and decrypting. Varying the IV can be used to increase the strength of the cipher. When using AES 128 encryption the sequence number of the media file can be used as the IV when encrypting or decrypting media files.

The EXT X PROGRAM DATE TIME tag can associate the beginning of the next media file with an absolute date and or time and can include or indicate a time zone. In one embodiment the date time representation is ISO IEC 8601 2004. The tag format can be 

The EXT X ALLOW CACHE tag can be used to indicate whether the client may cache the downloaded media files for later playback. The tag format can be 

The EXT X ENDLIST tag indicates in one embodiment that no more media files will be added to the playlist file. The tag format can be 

The EXT X STREAM INF tag can be used to indicate that the next URI in the playlist file identifies another playlist file. The tag format can be in one embodiment 

The foregoing tags and attributes can be used by the server device to organize transmit and process the media files that represent the original media content. The client devices use this information to reassemble and present the media files in a manner to provide a real time or near real time streaming experience e.g. viewing of a live broadcast such as a music or sporting event to a user of the client device.

Each media file URI in a playlist file identifies a media file that is a segment of the original presentation i.e. original media content . In one embodiment each media file is formatted as a MPEG 2 transport stream a MPEG 2 program stream or a MPEG 2 audio elementary stream. The format can be specified by specifying a CODEC and the playlist can specify a format by specifying a CODEC. In one embodiment all media files in a presentation have the same format however multiple formats may be supported in other embodiments. A transport stream file should in one embodiment contain a single MPEG 2 program and there should be a Program Association Table and a Program Map Table at the start of each file. A file that contains video SHOULD have at least one key frame and enough information to completely initialize a video decoder. Clients SHOULD be prepared to handle multiple tracks of a particular type e.g. audio or video by choosing a reasonable subset. Clients should in one embodiment ignore private streams inside Transport Streams that they do not recognize. The encoding parameters for samples within a stream inside a media file and between corresponding streams across multiple media files SHOULD remain consistent. However clients SHOULD deal with encoding changes as they are encountered for example by scaling video content to accommodate a resolution change.

The server device receives content to be provided in operation . The content may represent live audio and or video e.g. a sporting event live news a Web camera feed . The content may also represent pre recorded content e.g. a concert that has been recorded a training seminar etc. . The content may be received by the server according to any format and protocol known in the art whether streamed or not. In one embodiment the content is received by the server in the form of a MPEG 2 stream however other formats can also be supported.

The server may then store temporarily at least portions of the content in operation . The content or at least portions of the content may be stored temporarily for example on a storage device e.g. hard disk in a Storage Area Network etc. or in memory. Alternatively the content may be received as via a storage medium e.g. compact disc flash drive from which the content may be transferred to a storage device or memory. In one embodiment the server has an encoder that converts if necessary the content to one or more streams e.g. MPEG 2 . This conversion can occur without storing permanently the received content and in some embodiments the storage operation may be omitted or it may be a longer term storage e.g. an archival storage in other embodiments.

The content to be provided is segmented into multiple media files in operation . In one embodiment the server converts a stream into separate and distinct media files i.e. segments that can be distributed using a standard web server. In one embodiment the server segments the media stream at points that support effective decode of the individual media files e.g. on packet and key frame boundaries such as PES packet boundaries and i frame boundaries . The media files can be portions of the original stream with approximately equal duration. The server also creates a URI for each media file. These URIs allow client devices to access the media files.

Because the segments are served using HTTP servers which inherently deliver whole files the server should have a complete segmented media file available before it can be served to the clients. Thus the client may lag in time the broadcast by at least one media file length. In one embodiment media file size is based on a balance between lag time and having too many files.

In one embodiment two session types live session and event session are supported. For a live session only a fixed size portion of the stream is preserved. In one embodiment content media files that are out of date are removed from the program playlist file and can be removed from the server. The second type of session is an event session where the client can tune into any point of the broadcast e.g. start from the beginning start from a mid point . This type of session can be used for rebroadcast for example.

The media files are stored in the server memory in operation . The media files can be protected by a security feature such as encryption before storing the files in operation . The media files are stored as files that are ready to transmit using the network protocol e.g. HTTP or HTTPS supported by the Web server application on the server device or supported by another device which does the transmission .

One or more playlist files are generated to indicate the order in which the media files should be assembled to recreate the original content in operation . The playlist file s can utilize Extended M3U tags and the tags described herein to provide information for a client device to access and reassemble the media files to provide a streaming experience on the client device. A URI for each media file is included in the playlist file s in the order in which the media files are to be played. The server can also create one or more URIs for the playlist file s to allow the client devices to access the playlist file s .

The playlist file s can be stored on the server in operation . While the creation and storing of media files and playlist file s are presented in a particular order in a different order may also be used. For example the playlist file s may be created before the media files are created or stored. As another example the playlist file s and media files may be created before either are stored.

If media files are to be encrypted the playlist file s can define a URI that allows authorized client devices to obtain a key file containing an encryption key to decrypt the media files. An encryption key can be transmitted using a secure connection e.g. HTTPS . As another example the playlist file s may be transmitted using HTTPS. As a further example media files may be arranged in an unpredictable order so that the client cannot recreate the stream without the playlist file s .

If the encryption method is AES 128 AES 128 CBC encryption for example may be applied to individual media files. In one embodiment the entire file is encrypted. Cipher block chaining is normally not applied across media files in one embodiment. The sequence of the media files is use as the IV as described above. In one embodiment the server adds an EXT X KEY tag with the key URI to the end of the playlist file. The server then encrypts all subsequent media files with that key until a change in encryption configuration is made.

To switch to a new encryption key the server can make the new key available via a new URI that is distinct from all previous key URIs used in the presentation. The server also adds an EXT X KEY tag with the new key URI to the end of a playlist file and encrypts all subsequent media files with the new key.

To end encryption the server can add an EXT X KEY tag with the encryption method NONE at the end of the playlist file. The tag with NONE as the method does not include a URI parameter in one embodiment. All subsequent media files are not encrypted until a change in encryption configuration is made as described above. The server does not remove an EXT X KEY tag from a playlist file if the playlist file contains a URI to a media file encrypted with that key. The server can transmit the playlist file s and the media files over the network in response to client requests in operation as described in more detail with respect to .

In one embodiment a server transmits the playlist file to a client device in response to receiving a request from a client device for a playlist file. The client device may access request the playlist file using a URI that has been provided to the client device. The URI indicates the location of the playlist file on the server. In response the server may provide the playlist file to the client device. The client device may the utilize tags and URIs or other identifiers in the playlist file to access the multiple media files.

In one embodiment the server may limit the availability of media files to those that have been most recently added to the playlist file s . To do this each playlist file can include only one EXT X MEDIA SEQUENCE tag and the value can be incremented by one for every media file URI that is removed from the playlist file. Media file URIs can be removed from the playlist file s in the order in which they were added. In one embodiment when the server removes a media file URI from the playlist file s the media file remains available to clients for a period of time equal to the duration of the media file plus the duration of the longest playlist file in which the media file has appeared.

The duration of a playlist file is the sum of the durations of the media files within that playlist file. Other durations can also be used. In one embodiment the server can maintain at least three main presentation media files in the playlist at all times unless the EXT X ENDLIST tag is present.

The server device receives content to be provided in operation . The server may then temporarily store at least portions of the content in operation . Operation can be similar to operation in . The content to be provided is segmented into multiple media files in operation . The media files can be stored in the server memory in operation . The media files can be protected by a security feature such as encryption before storing the files in operation .

One or more playlist files are generated to indicate the order in which the media files should be assembled to recreate the original content in operation . The playlist file s can be stored on the server in operation . While the creation and storing of media files and playlist file s are presented in a particular order in a different order may also be used.

The server or another server can transmit the playlist file s and the media files over the network in response to client requests in operation as described in more detail with respect to .

The playlist file s may be updated by a server for various reasons. The server may receive additional data to be provided to the client devices in operation . The additional data can be received after the playlist file s are stored in operation . The additional data may be for example additional portions of a live presentation or additional information for an existing presentation. Additional data may include advertisements or statistics e.g. scores or data relating to a sporting event . The additional data could be overlaid through translucency on the presentation or be presented in a sidebar user interface. The additional data can be segmented in the same manner as the originally received data. If the additional data constitutes advertisements or other content to be inserted into the program represented by the playlist the additional data can be stored at least temporarily in operation segmented in operation and stored in operation prior to storage of the segmented additional data the segments of the additional data can be encrypted. Then in operation an updated playlist containing the program and the additional data would be generated. The playlist is updated based on the additional data and stored again in operation . Changes to the playlist file s should be made atomically from the perspective of the client device. The updated playlist replaces in one embodiment the previous playlist. As discussed below in greater detail client devices can request the playlist multiple times. These requests enable the client devices to utilize the most recent playlist. In one embodiment the additional data may be metadata in this case the playlist does not need to be updated but the segments can be updated to include metadata. For example the metadata may contain timestamps which can be matched with timestamps in the segments and the metadata can be added to segments having matching timestamps.

The updated playlist may also result in the removal of media files. In one embodiment a server should remove URIs for the media files from the playlist in the order in which they were added to the playlist. In one embodiment if the server removes an entire presentation it makes the playlist file s unavailable to client devices. In one embodiment the server maintains the media files and the playlist file s for the duration of the longest playlist file s containing a media file to be removed to allow current client devices to finish accessing the presentation. Accordingly every media file URI in the playlist file can be prefixed with an EXT X STREAM INF tag to indicate the approximate cumulative duration of the media files indicated by the playlist file. In alternate embodiments the media files and the playlist file s may be removed immediately.

Subsequent requests for the playlist from client devices result in the server providing the updated playlist in operation . In one embodiment playlists are updated on a regular basis for example a period of time related to the target duration. Periodic updates of the playlist file allow the server to provide access to servers to a dynamically changing presentation.

In one embodiment the server can offer multiple playlist files or a single playlist file with multiple media file lists in the single playlist file to provide different encodings of the same presentation. If different encodings are provided playlist file s may include each variant stream providing different bit rates to allow client devices to switch between encodings dynamically this is described further in connection with . Playlist files having variant streams can include an EXT X STREAM INF tag for each variant stream. Each EXT X STREAM INF tag for the same presentation can have the same PROGRAM ID attribute value. The PROGRAM ID value for each presentation is unique within the variant streams.

In one embodiment the server meets the following constraints when producing variant streams. Each variant stream can consist of the same content including optional content that is not part of the main presentation. The server can make the same period of content available for all variant streams within an accuracy of the smallest target duration of the streams. The media files of the variant streams are in one embodiment either MPEG 2 Transport Streams or MPEG 2 Program Streams with sample timestamps that match for corresponding content in all variant streams. Also all variant streams should in one embodiment contain the same audio encoding. This allows client devices to switch between variant streams without losing content.

Referring to the server device receives content to be provided in operation . The server may then at least temporarily store the content in operation . The content to be provided is segmented into multiple media files in operation . Each media file is encoded for a selected bit rate or a selected value of other encoding parameters and stored on the server in operation . For example the media files may be targeted for high medium and low bandwidth connections. The media files can be encrypted prior to storage. The encoding of the media files targeted for the various types of connections may be selected to provide a streaming experience at the target bandwidth level.

In one embodiment a variant playlist is generated in operation with tags as described herein that indicate various encoding levels. The tags may include for example an EXT X STREAM INF tag for each encoding level with a URI to a corresponding media playlist file.

This variant playlist can include URIs to media playlist files for the various encoding levels. Thus a client device can select a target bit rate from the alternatives provided in the variant playlist indicating the encoding levels and retrieve the corresponding playlist file. In one embodiment a client device may change between bit rates during playback e.g. as described with respect to . The variant playlist indicating the various encoding levels is stored on the server in operation . In operation each of the playlists referred to in the variant playlist can also be generated and then stored in operation .

In response to a request from a client device the server may transmit the variant playlist that indicates the various encoding levels in operation . The server may receive a request for one of the media playlists specified in the variant playlist corresponding to a selected bit rate in operation . In response to the request the server transmits the media playlist file corresponding to the request from the client device in operation . The client device may then use the media playlist to request media files from the server. The server provides the media files to the client device in response to requests in operation .

The client device may request a playlist file from a server in operation . In one embodiment the request is made according to an HTTP compliant protocol. The request utilizes a URI to an initial playlist file stored on the server. In alternate embodiments other non streaming protocols can be supported. In response to the request the server will transmit the corresponding playlist file to the client over a network. As discussed above the network can be wired or wireless and can be any combination of wired or wireless networks. Further the network may be a data network e.g. IEEE 802.11 IEEE 802.16 or a cellular telephone network e.g. 3G .

The client device can receive the playlist file in operation . The playlist file can be stored in a memory of the client device in operation . The memory can be for example a hard disk a flash memory a random access memory. In one embodiment each time a playlist file is loaded or reloaded from the playlist URI the client checks to determine that the playlist file begins with a EXTM3U tag and does not continue if the tag is absent. As discussed above the playlist file includes one or more tags as well as one or more URIs to media files.

The client device can include an assembler agent that uses the playlist file to reassemble the original content by requesting media files indicated by the URIs in the playlist file in operation . In one embodiment the assembler agent is a plug in module that is part of a standard Web browser application. In another embodiment the assembler agent may be a stand alone application that interacts with a Web browser to receive and assemble the media files using the playlist file s . As a further example the assembler agent may be a special purpose hardware or firmware component that is embedded in the client device.

The assembler causes media files from the playlist file to be downloaded from the server indicated by the URIs. If the playlist file contains the EXT X ENDLIST tag any media file indicated by the playlist file may be played first. If the EXT X ENDLIST tag is not present any media file except for the last and second to last media files may be played first. Once the first media file to play has been chosen subsequent media files in the playlist file are loaded in one embodiment in the order that they appear in the playlist file otherwise the content is presented out of order . In one embodiment the client device attempts to load media files in advance of when they are required and stores them in a buffer to provide uninterrupted playback and to compensate for temporary variations in network latency and throughput.

The downloaded media file s can be stored in a memory on the client device in operation . The memory in which the content can be stored may be any type of memory on the client device for example random access memory a hard disk or a video buffer. The storage may be temporary to allow playback or may be permanent. If the playlist file contains the EXT X ALLOW CACHE tag and its value is NO the client does not store the downloaded media files after they have been played. If the playlist contains the EXT X ALLOW CACHE tag and its value is YES the client device may store the media files indefinitely for later replay. The client device may use the value of the EXT X PROGRAM DATE TIME tag to display the program origination time to the user. In one embodiment the client can buffer multiple media files so that it is less susceptible to network jitter in order to provide a better user experience.

In one embodiment if the decryption method is AES 128 then AES 128 CBC decryption is applied to the individual media files. The entire file is decrypted. In one embodiment cipher block chaining is not applied across media files. The sequence number of the media file can be used as the initialization vector as described above.

From the memory the content can be output from the client device in operation . The output or presentation may be for example audio output via built in speakers or head phones. The output may include video that is output via a screen or projected from the client device. Any type of output known in the art may be utilized. In operation the client device determines whether there are any more media files in the stored current playlist which have not been played or otherwise presented. If such media files exist and if they have not been requested then processing returns to operation in which one or more media files are requested and the process repeats. If there are no such media files i.e. all media files in the current playlist have been played then processing proceeds to operation which determines whether the playlist file includes an end tag.

If the playlist includes an end tag e.g. EXT X ENDLIST in operation playback ceases when the media files indicated by the playlist file have been played. If the end tag is not in the playlist then the client device requests a playlist again from the server and reverts back to operation to obtain a further or updated playlist for the program.

As discussed in greater detail with respect to a server may update a playlist file to introduce supplementary content e.g. additional media file identifiers corresponding to additional media content in a live broadcast or additional content e.g. content further down the stream . To access the supplementary content or additional content a client can reload the updated playlist from the server. This can provide a mechanism by which playlist files can be dynamically updated even during playback of the media content associated with a playlist file. A client can request a reload of the playlist file based on a number of triggers. The lack of an end tag is one such trigger.

In one embodiment the client device periodically reloads the playlist file s unless the playlist file contains the EXT X ENDLIST tag. When the client device loads a playlist file for the first time or reloads a playlist file and finds that the playlist file has changed since the last time it was loaded the client can wait for a period of time before attempting to reload the playlist file again. This period is called the initial minimum reload delay. It is measured from the time that the client began loading the playlist file.

In one embodiment the initial minimum reload delay is the duration of the last media file in the playlist file or three times the target duration whichever is less. The media file duration is specified by the EXTINF tag. If the client reloads a playlist file and finds that it has not changed then the client can wait for a period of time before retrying. The minimum delay in one embodiment is three times the target duration or a multiple of the initial minimum reload delay whichever is less. In one embodiment this multiple is 0.5 for a first attempt 1.5 for a second attempt and 3.0 for subsequent attempts however other multiples may be used.

Each time a playlist file is loaded or reloaded the client device examines the playlist file to determine the next media file to load. The first file to load is the media file selected to play first as described above. If the first media file to be played has been loaded and the playlist file does not contain the EXT X MEDIA SEQUENCE tag then the client can verify that the current playlist file contains the URI of the last loaded media file at the offset where it was originally found halting playback if the file is not found. The next media file to load can be the first media file URI following the last loaded URI in the playlist file.

If the first file to be played has been loaded and the playlist file contains the EXT X MEDIA SEQUENCE tag then the next media file to load can be the one with the lowest sequence number that is greater than the sequence number of the last media file loaded. If the playlist file contains an EXT X KEY tag that specifics a key file URI the client device obtains the key file and uses the key inside the key file to decrypt the media files following the EXT X KEY tag until another EXT X KEY tag is encountered.

In one embodiment the client device utilizes the same URI as previously used to download the playlist file. Thus if changes have been made to the playlist file the client device may use the updated playlist file to retrieve media files and provide output based on the media files.

Changes to the playlist file may include for example deletion of a URI to a media file addition of a URI to a new media file replacement of a URI to a replacement media file. When changes are made to the playlist file one or more tags may be updated to reflect the change s . For example the duration tag may be updated if changes to the media files result in a change to the duration of the playback of the media files indicated by the playlist file.

The client device can request a playlist file in operation . As discussed above the playlist file may be retrieved utilizing a URI provided to the client device. In one embodiment the playlist file includes listings of variant streams of media files to provide the same content at different bit rates in other words a single playlist file includes URIs for the media files of each of the variant streams. The example shown in uses this embodiment. In another embodiment the variant streams may be represented by multiple distinct playlist files separately provided to the client that each provide the same content at different bit rates and a variant playlist can provide a URI for each of the distinct playlist files. This allows the client device to select the bit rate based on client conditions.

The playlist file s can be retrieved by the client device in operation . The playlist file s can be stored in the client device memory in operation . The client device may select the bit rate to be used in operation based upon current network connection speeds. Media files are requested from the server utilizing URIs included in the playlist file corresponding to the selected bit rate in operation . The retrieved media files can be stored in the client device memory. Output is provided by the client device utilizing the media files in operation and the client device determines whether to change the bit rate.

In one embodiment a client device selects the lowest available bit rate initially. While playing the media the client device can monitor available bandwidth e.g. current network connection bit rates to determine whether the available bandwidth can support use of a higher bit rate for playback. If so the client device can select a higher bit rate and access the media files indicated by the higher bit rate media playlist file. The reverse can also be supported. If the playback consumes too much bandwidth the client device can select a lower bit rate and access the media files indicated by the lower bit rate media playlist file.

If the client device changes the bit rate in operation for example in response to a change in available bandwidth or in response to user input the client device may select a different bit rate in operation . In one embodiment to select a different bit rate the client device may utilize a different list of URIs included in the playlist file that corresponds to the new selected bit rate. In one embodiment the client device may change bit rates during access of media files within a playlist.

If the bit rate does not change in operation then the client device determines whether there are any more unplayed media files in the current playlist which have not been retrieved and presented. If such media files exist then processing returns to operation and one or more media files are retrieved using the URIs for those files in the playlist. If there are no such media files i.e. all media files in the current playlist haven been played then processing proceeds to operation in which it is determined whether the playlist includes an end tag. If it does the playback of the program has ended and the process has completed if it does not then processing reverts to operation and the client device requests to reload the playlist for the program and the process repeats through the method shown in .

Server stream agent includes memory which represents a memory device or access to a memory resource for storing data or instructions. Memory may include memory local to server stream agent as well as or alternatively including memory of the host system on which server stream agent resides. Server stream agent also includes one or more interfaces which represent access interfaces to from an input output interface server stream agent with regard to entities electronic or human external to server stream agent .

Server stream agent also can include server stream engine which represents one or more functions that enable server stream agent to provide the real time or near real time streaming as described herein. The example of provides several components that may be included in server stream engine however different or additional components may also be included. Example components that may be involved in providing the streaming environment include segmenter indexer security and file server . Each of these components may further include other components to provide other functions. As used herein a component refers to routine a subsystem etc. whether implemented in hardware software firmware or some combination thereof.

Segmenter divides the content to be provided into media files that can be transmitted as files using a Web server protocol e.g. HTTP . For example segmenter may divide the content into predetermined fixed size blocks of data in a pre determined file format.

Indexer may provide one or more playlist files that provide an address or URI to the media files created by segmenter . Indexer may for example create one or more files with a listing of an order for identifiers corresponding to each file created by segmenter . The identifiers may be created or assigned by either segmenter or indexer . Indexer can also include one or more tags in the playlist files to support access and or utilization of the media files.

Security may provide security features e.g. encryption such as those discussed above. Web server may provide Web server functionality related to providing files stored on a host system to a remote client device. Web server may support for example HTTP compliant protocols.

Client stream agent includes memory which represents a memory device or access to a memory resource for storing data and or instructions. Memory may include memory local to client stream agent as well as or alternatively including memory of the host system on which client stream agent resides. Client stream agent also includes one or more interfaces which represent access interfaces to from an input output interface client stream agent with regard to entities electronic or human external to client stream agent .

Client stream agent also can include client stream engine which represents one or more functions that enable client stream agent to provide the real time or near real time streaming as described herein. The example of provides several components that may be included in client stream engine however different or additional components may also be included. Example components that may be involved in providing the streaming environment include assembler output generator and security . Each of these components may further include other components to provide other functions. As used herein a component refers to routine a subsystem etc. whether implemented in hardware software firmware or some combination thereof.

Assembler can utilize a playlist file received from a server to access the media files via Web server protocol e.g. HTTP from the server. In one embodiment assembler may cause to be downloaded media files as indicated by URIs in the playlist file. Assembler may respond to tags included in the playlist file.

Output generator may provide the received media files as audio or visual output or both audio and visual on the host system. Output generator may for example cause audio to be output to one or more speakers and video to be output to a display device. Security may provide security features such as those discussed above.

Begin tag can indicate the beginning of a playlist file. In one embodiment begin tag is a EXTM3U tag. Duration tag can indicate the duration of the playback list. That is the duration of the playback of the media files indicated by playback list . In one embodiment duration tag is an EXT X TARGETDURATION tag however other tags can also be used.

Date Time tag can provide information related to the date and time of the content provided by the media files indicated by playback list . In one embodiment Date Time tag is an EXT X PROGRAM DATE TIME tag however other tags can also be used. Sequence tag can indicate the sequence of playlist file in a sequence of playlists. In one embodiment sequence tag is an EXT X MEDIA SEQUENCE tag however other tags can also be used.

Security tag can provide information related to security and or encryption applied to media files indicated by playlist file . For example the security tag can specify a decryption key to decrypt files specified by the media file indicators. In one embodiment security tag is an EXT X KEY tag however other tags can also be used. Variant list tag can indicate whether variant streams are provided by playlist as well as information related to the variant streams e.g. how many bit rate . In one embodiment variant list tag is an EXT X STREAM INF tag.

Media file indicators can provide information related to media files to be played. In one embodiment media file indicators include URIs to multiple media files to be played. In one embodiment the order of the URIs in playlist corresponds to the order in which the media files should be accessed and or played. Subsequent playlist indictors can provide information related to one or more playback files to be used after playback file . In one embodiment subsequent playlist indicators can include URIs to one or more playlist files to be used after the media files of playlist have been played.

Memory tag can indicate whether and or how long a client device may store media files after playback of the media file content. In one embodiment memory tag is an EXT X ALLOW CACHE tag. End tag indicates whether playlist file is the last playlist file for a presentation. In one embodiment end tag is an EXT X ENDLIST tag.

If control input is detected in operation the client device can determine if the input indicates a stop in operation . If the input is a stop the process concludes and playback stops. If the input indicates a rewind or forward request in operation the client device can generate output based on previously played media files still stored in memory in operation . If these files are no longer in a cache then processing reverts to operation to retrieve the media files and repeats the process. In an alternate embodiment playback can support a pause feature that halts playback without concluding playback as with a stop input.

Methods for transitioning from one stream to another stream are further described with reference to . One client device can perform each of these methods or the operations of each of these methods can be distributed across multiple client devices as described herein for example in the distributed case one client device can retrieve the variant playlist and the two media playlists and provide those to another client device which retrieves media files specified by the two media playlists and switches between the two streams provided by the retrieved media files. It will also be understood that in alternative embodiments the order of the operations shown may be modified or there can be more or fewer operations than shown in these figures. The methods can use a variant playlist to select different streams. A variant playlist can be retrieved and processed in operation to determine available streams for a program e.g. a sporting event . Operation can be done by a client device. A first stream can be selected from the variant playlist in operation and a client device can then retrieve a media playlist for the first stream. The client device can process the media playlist for the first stream in operation and also measure or otherwise determine a bit rate of the network connection for the first stream in operation . It will be appreciated that the sequence of operations may be performed in an order which is different than what is shown in for example operation may be performed during operation etc. In operation the client device selects an alternative media playlist from the variant playlist based on the measured bit rate from operation this alternative media playlist may be at a second bit rate that is higher than the existing bit rate of the first stream. This typically means that alternative stream will have a higher resolution than the first stream. The alternative media playlist can be selected if it is a better match than the current playlist for the first stream based on current conditions e.g. the bit rate measured in operation . In operation the alternative media playlist for an alternate stream is retrieved and processed. This typically means that the client device can be receiving and processing both the first stream and the alternative stream so both are available for presentation one is presented while the other is ready to be presented. The client device then selects a transition point to switch between the versions of the streams in operation and stops presenting the first stream and begins presenting the alternative stream. Examples of how this switch is accomplished are provided in conjunction with . In some embodiments the client device can stop receiving the first stream before making the switch.

The method shown in represents one embodiment for determining the transition point this embodiment relies upon a pattern matching on audio samples from the two streams and to determine the transition point. It will be appreciated that alternative embodiments can use pattern matching on video samples or can use the timestamps in the two streams etc. to determine the transition point. The method can include in operation storing content e.g. stream specified by the first media playlist in a buffer the buffer can be used for the presentation of the content and also for the pattern matching operation. The stream includes both audio samples A and video samples B. The video samples can use a compression technique which relies on i frames or key frames which have all necessary content to display a single video frame. The content in stream can include timestamps specifying a time e.g. time elapsed since the beginning of the program and these timestamps can mark the beginning of each of the samples e.g. the beginning of each of the audio samples A and the beginning of each of the video samples B . In some cases a comparison of the timestamps between the two streams may not be useful in determining a transition point because they may not be precise enough or because of the difference in the boundaries of the samples in the two streams however a comparison of the timestamps ranges can be used to verify there is an overlap in time between the two streams. In operation the client device stores in a buffer content specified by the second media playlist this content is for the same program as the content obtained from the first media playlist and it can include timestamps also. In one embodiment timestamps if not present in a stream can be added to a playlist for a stream for example in one embodiment an ID3 tag which includes one or more timestamps can be added to an entry in a playlist such as a variant playlist or a media playlist. The entry may for example be in a URI for a first sample of an audio stream. shows an example of content obtained from the second media playlist and this includes audio samples A and video samples B. In operation the client device can perform a pattern matching on the audio samples in the two streams and to select from the overlap the transition point which can be in one embodiment the next self contained video frame e.g. i frame after the matched audio segments e.g. segments . Beginning with i frame and its associated audio sample presentation of the program uses the second stream obtained from the second media playlist. The foregoing method can be used in one embodiment for both a change from a slower to a faster bit rate and for a change from a faster to a slower bit rate but in another embodiment the method can be used only for a change from a slower to a faster bit rate and another method e.g. do not attempt to locate a transition point but attempt to store and present content from the slower bit rate stream as soon as possible can be used for a change from a faster to a slower bit.

Electronic system includes bus or other communication device to communicate information and processor coupled to bus that may process information. While electronic system is illustrated with a single processor electronic system may include multiple processors and or co processors. Electronic system further may include random access memory RAM or other dynamic storage device referred to as main memory coupled to bus and may store information and instructions that may be executed by processor . Main memory may also be used to store temporary variables or other intermediate information during execution of instructions by processor .

Electronic system may also include read only memory ROM and or other static storage device coupled to bus that may store static information and instructions for processor . Data storage device may be coupled to bus to store information and instructions. Data storage device such as flash memory or a magnetic disk or optical disc and corresponding drive may be coupled to electronic system .

Electronic system may also be coupled via bus to display device such as a cathode ray tube CRT or liquid crystal display LCD to display information to a user. Electronic system can also include an alphanumeric input device including alphanumeric and other keys which may be coupled to bus to communicate information and command selections to processor . Another type of user input device is cursor control such as a touchpad a mouse a trackball or cursor direction keys to communicate direction information and command selections to processor and to control cursor movement on display .

Electronic system further may include one or more network interface s to provide access to a network such as a local area network. Network interface s may include for example a wireless network interface having antenna which may represent one or more antenna e . Electronic system can include multiple wireless network interfaces such as a combination of WiFi Bluetooth and cellular telephony interfaces. Network interface s may also include for example a wired network interface to communicate with remote devices via network cable which may be for example an Ethernet cable a coaxial cable a fiber optic cable a serial cable or a parallel cable.

In one embodiment network interface s may provide access to a local area network for example by conforming to IEEE 802.11b and or IEEE 802.11g standards and or the wireless network interface may provide access to a personal area network for example by conforming to Bluetooth standards. Other wireless network interfaces and or protocols can also be supported.

In addition to or instead of communication via wireless LAN standards network interface s may provide wireless communications using for example Time Division Multiple Access TDMA protocols Global System for Mobile Communications GSM protocols Code Division Multiple Access CDMA protocols and or any other type of wireless communications protocol.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

