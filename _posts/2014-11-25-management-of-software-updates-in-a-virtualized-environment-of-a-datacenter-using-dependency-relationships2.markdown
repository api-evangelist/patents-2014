---

title: Management of software updates in a virtualized environment of a datacenter using dependency relationships
abstract: An approach to managing software components in a datacenter having virtualized components includes maintaining a suitable data construct for representing the virtualized elements. In embodiments, virtualized elements include knowledge relating to instantiations of virtual machines. Management of software components includes traversing a data representation of the datacenter, and assessing the compatibility of the software component with components in the datacenter that relate to the target of the software component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09535684&OS=09535684&RS=09535684
owner: VMware, Inc.
number: 09535684
owner_city: Palo Alto
owner_country: US
publication_date: 20141125
---
This application is a continuation of U.S. application Ser. No. 13 219 479 filed Aug. 26 2011 which issued as U.S. Pat. No. 8 898 676 and is hereby incorporated by reference herein in its entirety.

Information technology IT administrators typically manage their organization s computer systems and associated components such as telecommunications and storage systems in a facility commonly referred to as a datacenter. A large organization may include a wide range of hardware components server machines storage devices communication equipment and so on and software components firmware operating systems applications and so on . Indeed a large datacenter may be distributed over a wide geographic area in different parts of a city in different states or globally in different parts around the world. The term datacenter will be used herein to refer to the hardware and software components that constitute the computing data storage and communication infrastructure of an organization irrespective of whether the components are housed in a single building or distributed among different locations around the world.

Interrelationships between various parts of the datacenter may cause huge headaches for an IT department. In addition to managing large numbers of machines servers storage and so on differences between hardware firmware and software versions may easily create a combinatorial nightmare maintaining interoperability between hosts databases management appliances and other major software components. The combination of different hardware versions and software firmware versions makes upgrading software in the datacenter a difficult process. If any one component does not upgrade successfully or becomes incompatible with other components as a result of the upgrade entire portions of a datacenter may be rendered inoperable.

Further exacerbating the problem is the increasing deployment of virtualized environments within a datacenter. The term virtualization broadly describes the separation of a resource or request for a service from the underlying physical delivery of that service. Virtualization employs a software layer virtualization layer that decouples the physical hardware from the operating system. Virtualization allows multiple virtual machines with heterogeneous operating systems and applications to run in isolation side by side on the same physical machine. A virtual machine is the representation of a physical machine by software. It has its own set of virtual hardware e.g. RAM CPU NIC hard disks etc. upon which an operating system and applications are loaded. The operating system sees a consistent normalized set of hardware regardless of the actual physical hardware components.

More recently virtualization has progressed to encompass systems of computers that include multiple hardware platforms. for example shows an underlying layer of physical components including for example physical servers storage systems and network . Each physical server may be configured with a virtual layer to manage the components as a pool of resources that may be allocated as virtual machines . Each virtual machine may then be installed with any one of a number of OS s. The ESX Server is an example of a virtualization layer . The ESX Server software package may be installed on each physical servers to abstract processor memory storage and networking resources to be provisioned to multiple virtual machines . A number of similarly configured physical servers may be grouped together with connections to the same network and storage systems to provide an aggregate set of resources in a virtual environment. A management server may provide services such as access control performance monitoring and configuration. The management server may unify resources from the individual physical servers to be shared among virtual machines in the virtual environment.

As datacenters become increasingly more modular multi tiered distributed and virtualized the datacenter infrastructure becomes more complex and managing all the interrelated software components that make up the infrastructure becomes increasingly challenging. Dependencies between related components and the compatibility limitations between those components makes for a daunting task when IT administrators must patch or upgrade any components within the system.

In embodiments management of software components in a datacenter that includes a virtualized environment may include producing and maintaining a data construct that adequately represents datacenter components in virtualized architectures. Changing a software component on a target in the datacenter may include identifying from the data construct components in the datacenter related to the target. The action may proceed if none of the related components are deemed to be affected by the software component. In embodiments if a related component is identified as being affected then the action may be denied or a suitable warning may be presented to an IT administrator and the action suspended pending a response from the IT administrator.

In embodiments changing a software component may include installing a software component or removing a software component.

The following detailed description and accompanying drawings provide a more detailed understanding of the nature and advantages of the present invention.

In the following description for purposes of explanation numerous examples and specific details are set forth in order to provide a thorough understanding of disclosed embodiments. Particular embodiments as defined by the claims may include some or all of the features in these examples alone or in combination with other features described below and may further include modifications and equivalents of the features and concepts described herein.

The term change and its various grammatical forms used in connection with software components will be understood to refer to installing a software component e.g. new installation upgrades to existing installed software etc. and to removing a software component e.g. removing installed software downgraded to a lower version removing a patch etc. . The remaining discussion generally refers to installation of a software component as an example. However it will be appreciated that embodiments apply equally to changes in the software components that include removing the software component.

Referring to a datacenter includes a configuration of distributed computing components that are the subject of software component management. The datacenter may include physical servers storage devices and network communication equipment. The datacenter may further include virtualized components that provide one or more virtual environments. A representation of the datacenter may be provided. In embodiments discussed below dependencies among the components of the datacenter include dependencies involving components of the one or more virtual environments. A software source represents a source of software components that may be deployed in the datacenter . Typical software sources may include software vendors external to the datacenter who for example may provide access to their software over the Internet. A software source may include an engineering support group within the datacenter and so on. An update store may be provided to store the software components to be later deployed in the datacenter . The software source may provide probes that can discover new components in the datacenter and update the representation . An updater may coordinate management activity with the datacenter . A user e.g. an IT administrator may access the updater to deploy software components to the datacenter .

Referring to an embodiment of the updater include a software component management server . In particular embodiments the server may facilitate the management of datacenters which include physical components servers data stores that support virtualized environments. The server may learn about and build a representation of the datacenter that allows a user IT administrator to make queries about the datacenter and to make changes to the datacenter.

The software component management server may include a computer connected to I O devices such as display and suitable input device s such as a keyboard a mouse and so on. The computer may include a processor component that includes a processor or a configuration of many processors. A memory component may include dynamic memory e.g. DRAM and static memory e.g. flash memory to store suitable computer programs that cause the processor component to perform steps disclosed herein. A storage device component may provide read write able mass storage capability e.g. hard disk drives and or read only storage e.g. CD discs . The computer may be connected to a storage server via a suitable network interface component for communication over a suitable communication network such as a local network or a public access network. Users may access the server locally via I O devices or remotely via the communication network. A system bus may provide control and or data bus lines to interconnect these elements.

In embodiments the software component management server may include a plurality of processes server processes that execute on the processor component . Referring to the server processes may execute on top of an operating system OS such as Unix or Windows OS and so on. Various implementations of user interfaces UI s may be provided in order to access the server including a graphical UI GUI or a command line interface CLI . Any suitable programming language may be used to develop the GUI . For example the GUI may be a cross platform GUI a more traditional command line interface CLI also referred to as a shell program may be provided to access the server . For example on a Windows OS a PowerShell program may be a suitable CLI. On a Linux system a variety of shell programs are available. The UI s may provide suitable controls such as drop down menus in the case of a GUI and commands in the case of a CLI that allow the user to access software component management services provided by the server such as making queries relating to the datacenter and initiating activities relating to software upgrades in the datacenter.

The UI processes may be spawned on demand by the user. For example the software component management server may host an IT admin web site that serves as the entry point to the GUI . When the user visits the web site the GUI process may be executed to provide software component management services to the incoming user. The UI processes may execute as a background process referred to in Unix parlance as a daemon . For example the CLI s may be a secured login shell program that is running on the server . The user may access the server via the login shell program thus gaining access to the software component management services.

A controller process serves as a locus for communication among the various server processes of the software component management server . The controller process is responsible for exposing a public application programming interface API for the GUI and CLI s . For example the API interface may be a web service based on a design principle known as REST representational state transfer and written for example using WSDL web services description language SOAP simple object access protocol or other web service language. The controller process may provide translation of the API to the semantics of the underlying handler processes as well the routing and messaging of requests within the server . Incoming requests from the UI s may be received and parsed and then dispatched to the appropriate handler process or processes. In embodiments the controller process may itself be a process in the OS and spawned as needed and then exit after an idle period of time.

A state manager stores a representation of the datacenter managed by the software component management server . In embodiments the representation informs the server processes of the various hardware components and software components that constitute the datacenter. Moreover dependency relationships among hardware components and software components are represented and may include dependency relationships among multiple instances of physical servers various software packages installed in each physical server the versions of those multiple software packages virtualized elements and so on. As an example suppose a physical server is running a particular version of a virtualization layer. Suppose further that the virtualization layer has instantiated some number of virtual machines that each virtual machine runs a particular OS and that each OS requires a specific set of drivers. Various dependent relationships may exist for example the virtualization layer may only be suitable i.e. depend on for a particular hardware version of the physical server or may require i.e. depend on some minimum memory configuration of the physical server. The OS may depend on the virtual machines being able to provide a specific version of virtual hardware which in turn may depend on the physical server and so on.

The data construct used to represent a datacenter may be a dependency graph. In embodiments descriptors in the dependency graph may represent components of the datacenter servers data stores software and so on as nodes in the graph and the dependency relationships between components as edges in the graph. In a particular embodiment the descriptors use a representational form known as the resource description framework RDF to represent the dependency graph although representational forms other than RDF may be used for example adjacency matrices relational database tables and the like. The state manager maintains an RDF data store which stores a representation of the datacenter in RDF data units called triples . An RDF triple includes a subject an object and a predicate that relates subject and object. Accordingly the nodes in the dependency graph correspond to the subject and object attributes in the RDF triples and edges in the dependency graph correspond to the predicates.

A depot manager stores registers and otherwise manages the software components that may be installed in the datacenter including new installations upgrades feature additions patches and so on. The depot manager may obtain new versions of software components for subsequent installation in the datacenter. For example the depot manager may periodically communicate with each software vendor e.g. via vendor web sites to check if new software components are available. IT personnel may upload software components to the depot manager and so on. The software components may be stored in a depot data store

In embodiments each software component referred to herein as the payload that may be delivered and installed in the datacenter may be wrapped in a logical package referred to herein as a feature bundle along with metadata and one or more scripts action scripts probe scripts . The payload the metadata and the one or more scripts are logically collectively referred to as the feature bundle and may be stored in the depot data store as a single file or as separate files.

The payload in a feature bundle may be any kind of data that may need to be installed in the datacenter. In an embodiment the payload is software however the payload may be data instead of computer instructions. For example a data payload may be data that specifies a new database schema to re configure an existing database or data use to configure the operation of an application and so on. In the case of software payloads the software may be user level applications background programs device drivers firmware software patches and so on. The software may be in any suitable data format such as binary code WAR web application archive files for Java applications OVF open virtual format files for virtual appliances that execute on virtual machines TAR tape archive files and so on. The payload may be platform neutral e.g. Java WAR files and the like . The payload may be specific to a particular component in the datacenter e.g. firmware specific to a particular version of a disk storage system. A feature bundle may include multiple payloads and suitable metadata and scripts to support different targets and so on.

In embodiments the metadata in a feature bundle may include any information that may be used to describe the relationship of its payload with other components in the datacenter to facilitate compatibility determinations. For example the metadata may include a list of compatible versions of the components that the payload is intended to interact with. The metadata may describe required configurations or settings of the components and so on. As an example consider a feature bundle containing a device driver X as its payload. The associated metadata may indicate that the device driver may operate with storage devices having firmware versions 2 3 and 3.2. The metadata may also indicate that the device driver will only work with storage devices having a maximum storage capacity of 500 GB. The metadata may provide conditions or other predicate information specifying how when and whether upgrade activities may be performed on a target component whether a software component may be downgraded to an earlier version and so on. The metadata is typically created by the author of the feature bundle. In an embodiment however the IT administrator may have access to the metadata in order to add datacenter specific constraints. For example the IT administrator may include temporal constraints in the metadata such as specifying when a target may be taken down. Conditions for when a target can be taken down may be specified in the metadata and so on.

The feature bundle may include one or more scripts . These are programs that are separate from the payload and are employed to perform various tasks relating to the payload in the feature bundle and may be used to maintain the dependency graph. In embodiments the software component management server may define a scripting framework that may be exposed to software vendors to facilitate development of suitable scripts to integrate their software components with the datacenter without having to burden the IT administrators in the datacenter with such tasks. The terms software vendor and vendor may refer to third party commercial providers of the software to engineering and support staff employed by the datacenter who might develop and deploy software to the datacenter and so on basically any supplier of software components for deployment in the datacenter may be referred to as a vendor.

One class of scripts is referred to as action scripts. Typically action scripts are provided by the software vendor since the vendor is likely to know precisely what steps and sequence of steps are needed to properly install the payload in a target which may involve installing a new version of software upgrading a portion of the software patching the software and so on. An action script may be provided to uninstall the payload. Still another action script may be provided to control the target to perform a dry run of the newly installed payload to configure the target after the installation and so on.

Another class of scripts is called probe scripts. In an embodiment probe scripts allow a feature bundle to add new node types and instances of those node types as well as edges to the dependency graph thus extending the data graph s representation of the datacenter to include additional components in the datacenter. For example suppose a datacenter is configured with storage devices called SANs storage area network and that there is presently no representation of SANs in the dependency graph of the datacenter this situation may arise for example if the SANs are newly installed and the dependency graph was not updated. Suppose further that a software upgrade requires knowledge about SANs as an integral part of its dependency calculations. A suitable probe script may be provided to define a new node type in the dependency graph to represent SANs. The probe script may include logic e.g. executable instructions script language etc. to discover all SAN instances in the datacenter. For each SAN the probe script may generate as many RDF triples as needed to adequately describe the SAN and its dependency relation with other components in the datacenter and store those triples in the RDF data store . In this way the dependency graph may be dynamically extended.

A resolver may receive a user request to perform a task in the datacenter. The task may be a request to change a software component such as installing a software component e.g. new installation an upgrade etc. or removing a software component e.g. downgrading to a lower version . In embodiments user queries may be expressed in an RDF query language called SPARQL. The resolver processes the query against the RDF data store by communicating with the RDF data store to obtain one or more RDF triples relating to the user request and using metadata in the feature bundles associated with the nodes identified by the retrieved triples to resolve the query. An output of the resolver is a target graph which constitutes those components in the datacenter that are affected by the requested task. In embodiments the resolver may identify targets based on the resulting target graph that also require change s as a consequence of the requested task. For example if the user requests target should be upgraded from version X to Y the resolver may discover that target must also be upgraded from version B to C to maintain compatibility. A more detailed description of processing in the resolver is given below.

A remediation engine may generate a workflow in response to a user request to perform a task. As explained the resolver may produce a target graph in response to receiving the requested task that identifies at least the target of the requested task and zero or more components that are affected by the requested task. The resolver may pass the target graph to the remediation engine to generate the workflow. In embodiments the workflow includes the action scripts contained in the feature bundles.

In embodiments input to the remediation engine for workflow generation is the target graph containing a list of target nodes. Transformation of the target graph into a workflow may include accessing the feature bundle from the depot data store corresponding to the upgrade information associated with a node in the target graph. The remediation engine may use the metadata in the feature bundle to determine if the upgrade may be performed on that node. For example the metadata may inform that version X can be upgraded directly to version Z or that version Y must first be installed in order to upgrade from version X to version Z. If the upgrade is permitted then the remediation engine may incorporate the action script from the feature bundle into the workflow . A complete workflow may be compiled by repeating the foregoing for each node in the target graph . Processing in the remediation engine will be discussed in more detail below.

A script engine may perform the general task of executing scripts. As explained above the resolver may produce a target graph in response to receiving a task request from the user. The remediation engine may produce a workflow from the target graph . The script engine may process action scripts in the workflow to effect the requested task. For example the script engine may coordinate with the remediation engine to sequentially execute each action script in the workflow

In embodiments the script engine may execute the probe scripts contained in each feature bundle stored in the depot data store . For example the script engine may access each feature bundle in sequence obtain the probe script and execute it. Some probe scripts may be executed concurrently. Instructions that constitute the probe script may interact with a component in the datacenter to learn about its configuration. The probe script may then assemble that information into one or more RDF triples and then communicate the triples to the state manager for storage in the RDF data store . In this way the dependency graph of the datacenter may be automatically updated and extended as new components are discovered.

The controller process may employ a set of housekeeping tasks . These tasks may be scheduled entities using the underlying primitives of the OS to execute at a particular time e.g. cron on Linux or Task Scheduler on Windows . These tasks may provide caching of metadata for various feature bundles packages purging stale targets from the RDF data store and so on.

In an embodiment dependency relationships among components that include a virtual environment in a datacenter may be represented. In for example the virtual layer instantiates two instances of virtual machines . TABLE II represents this fact with the following triples 

It was explained above that the resolver may receive a user request to perform a task. In embodiments a task request may specify an action and a target. The target identifies a component in the datacenter on which the action is to be performed. The resolver may resolve the request by walking the edges of the dependency graph and identifying components that may be affected conflicts and attempt to resolve any conflicts.

A discussion of high level processing steps for the resolver will be given in connection with the flow shown in and in the context of the following example taken from . Suppose a new driver is available for the virtualization layer to replace the currently installed driver at version v1.2 . Accordingly in a step the resolver receives a request to make a change to a software component namely the installed driver . The request may specify 1 the target namely driver v1.2 in the dependency graph 2 the desired change e.g. install and 3 the feature bundle that contains the new driver.

In a step the resolver identifies all the components that have a dependency relationship with the target. Thus in our example the resolver may access RDF data store to retrieve all RDF triples in which the target namely driver v1.2 appear as either the source in the triple or the object in the triple as depicted in TABLE III 

Next the resolver in a loop tests the compatibility between the target and each of the components identified in step . Accordingly in a step the resolver may access the depot data store to call up the feature bundle for the currently installed driver the feature bundle for the proposed new driver and the feature bundle for the currently installed HBA component the first component to be tested . In a decision step compatibility between the currently installed HBA and the new driver may be determined from information conveyed in one or more RDF triples that relate driver and HBA the metadata contained in the feature bundles for the proposed new driver the currently installed driver the currently installed HBA and so on. For example the metadata contained in the feature bundles may provide information about what version or versions of the HBA that the new driver will work with. Suppose for example the metadata in the feature bundle for the new driver indicated that the new driver is compatible with HBA rev or higher. Using the metadata information and the triples TABLE III obtained from the RDF data store the resolver may determine that the currently installed HBA component in the physical server namely HBA rev would be affected by virtue of being at the wrong rev level and thus incompatible with the new driver.

If the outcome of step is positive i.e. the upgrade to the target is compatible with the component being tested then in a step the loop is repeated in order to test the next component identified in step .

If the outcome of step is negative i.e. the upgrade to the target is not compatible with the component being tested and so a conflict arises as is the case for the HBA in the running example then an inquiry may be made in a step as to whether the conflict may be resolved. For example the metadata for the new driver identifies compatible revs of the HBA. The inquiry made in step may involve the resolver searching the depot data store for any firmware upgrades that may bring the HBA to a compatible rev level.

If the outcome of the inquiry is that the conflict between the component being tested and the target cannot be resolved then this fact may be logged in a result buffer step . In the running example if the rev level of the HBA cannot be upgraded then information relating to this fact may be logged in the result buffer. Processing may then proceed with the next component step .

If the outcome of the inquiry is that the conflict may be resolved then in a step a node may be added to the target graph identifying the current state of the component being tested and a desired state. In the running example if a firmware upgrade for the HBA is available then the resolver may add a node in the target graph identifying the current state of the HBA and the new rev level for the HBA. Processing may then proceed with the next component step .

When the loop has completed a determination step is made whether any conflicts were logged at step . If conflicts were logged then the resolver may display step suitable error messages to the IT administrator indicating the conflicting components what the conflicts were and so on. Processing of the requested task may then be aborted. In embodiments the IT administrator may inform the system to nonetheless proceed with the requested change to the software component because for example they may have knowledge about the system that allows them to make an informed decision to proceed with the change despite the identified conflicts.

If the determination in step indicates that no conflicts were identified then the processing of the requested task may proceed. Accordingly the resolver may pass the target graph onto the remediation engine in a step .

As explained above the remediation engine generates a workflow from the target graph received from the resolver . Referring to in an embodiment the remediation engine receives the target graph from the resolver in a step .

The target graph may be transformed into a workflow by retrieving the feature bundle action scripts from the depot data store . For each node in target graph the feature bundle action script provides the remediation actions with ordering information if necessary for the feature bundle. Each action script may specify pre and or post remediation actions e.g. download the binary files staging entering maintenance mode reboot etc.

In an embodiment the transformation from target graph to workflow needs two passes to the feature bundle action scripts. In a step a first pass is made where the feature bundle for each node in the target graph is retrieved from the depot data store . The action script from each retrieved feature bundle is accessed to obtain the actions for each target node remediation and compiled into a workflow.

In a step a second pass is made to identify any dependencies between different target nodes and different feature bundles. For example low level device drivers may need to be installed before installing application level software.

In embodiments the remediation engine may detect circular dependencies in the workflow. In a step if any circularities are detected then in step the ordering needed to resolve the circularities may be provided by the user. In a step after any circularities have been resolved the remediation engine may present the compiled workflow to the user thus completing the workflow generation stage of processing in the remediation engine .

The user may review the generated workflow and specify remediation options for the workflow e.g. scheduling maintenance mode options etc. . Alternatively the user may specify the remediation options independently for each action and each node.

After the user specifies the remediation options for the workflow the remediation engine may receive a request step from the user to initiate the workflow. In a step the remediation engine may maintain an action queue and initiate via the script engine the execution of each action and monitor the execution conditions for each action. Upon completion of the action scripts in the workflow processing of the user s requested task may be deemed to be have concluded.

Various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments may be useful machine operations. In addition one or more embodiments also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

Various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable storage media. The term computer readable storage medium refers to any data storage device that may store data which may thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a non transitory computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs a CD ROM a CD R a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium may also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

These and other variations modifications additions and improvements may fall within the scope of the appended claims s . As used in the description herein and throughout the claims that follow a an and the includes plural references unless the context clearly dictates otherwise. Also as used in the description herein and throughout the claims that follow the meaning of in includes in and on unless the context clearly dictates otherwise.

The above description illustrates various embodiments along with examples of how they may be implemented. The above examples and embodiments should not be deemed to be the only embodiments. Based on the above disclosure and the following claims other arrangements embodiments implementations and equivalents may be employed without departing from the scope of the invention as defined by the claims.

