---

title: Method and node for employing network connections over a connectionless transport layer protocol
abstract: A method of establishing a network connection between two nodes of a communication network via a connectionless transport layer communication protocol is presented. In the method, a plurality of data packets is exchanged between a first node and a second node. Each of the data packets comprises a header and a payload formatted according to the connectionless protocol. The connectionless protocol payload of the data packets includes a separate header comprising a first port indicator for the first node and a second port indicator for the second node. The separate header of at least one of the data packets includes an indication to establish a connection between the first node and the second node. In response to the exchange of data packets, the first and second nodes establish the connection, wherein the first port indicator and the second port indicator are associated with the established connection between the nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09049144&OS=09049144&RS=09049144
owner: Sling Media PVT LTD
number: 09049144
owner_city: Bangalore
owner_country: IN
publication_date: 20140609
---
This Application is a continuation of U.S. Non Provisional application Ser. No. 12 405 062 filed Mar. 16 2009.

The Internet has become an important and often critical communication network for transporting data of many kinds including textual audio and visual data between distinct nodes of the network. The transfer of this data within the Internet is facilitated by a stack of architectural layers with each layer providing a corresponding type of functionality required of the network to transport the data. Each of these layers at least roughly corresponds to one or more of the seven layers of the Open Systems Interconnection OSI Reference Model which identifies seven different layers i.e. the physical layer the data link layer the network layer the transport layer the session layer the presentation layer and the application layer in ascending order only one of which represents the actual physical network connection. The remaining layers describe the various types of data and associated control information being generated and transferred within the network.

While different portions of the Internet often utilize diverse physical and data link layers much of the Internet employs some version of the Internet Protocol IP for the network layer. Above the IP layer however several different options exist for the transport layer. Two of the more popular options are the Transmission Control Protocol TCP and the User Datagram Protocol UDP . Generally TCP provides for logical connections to be established between two end nodes of the network for subsequent data transfer therebetween. Also TCP provides a data packet acknowledgement timeout and retransmission mechanism as well as a packet sequencing facility to protect against data loss. Conversely UDP does not provide an acknowledgement timeout or retransmission mechanism does not explicitly facilitate data packet sequencing and does not establish a logical connection between two communicating network nodes. Accordingly due to its lower overhead UDP is often utilized in situations in which data loss is less important than any additional delay that may be incurred by using TCP for data packet transmission. Oppositely TCP is typically employed in scenarios in which data reliability and integrity are important considerations.

Many network connected computer systems provide a software sockets application programming interface API to allow software applications executing on the system to employ UDP TCP and other types of transport layers to communicate with other nodes on the network. One such API is the Berkeley Software Distribution BSD Sockets API which provides a number of functions that may be called by applications to create and terminate connections over a network with another node exchange data over such connections and perform related activities using TCP UDP or another transport layer implementation.

While the use of TCP UDP the BSD sockets API and other typical implementations of the various architectural layers of the Internet is widely accepted use of these standard communication tools by two communication network nodes may not adequately address some specific data characteristics network environments and other concerns.

The enclosed drawings and the following description depict specific embodiments of the invention to teach those skilled in the art how to make and use the best mode of the invention. For the purpose of teaching inventive principles some conventional aspects have been simplified or omitted. Those skilled in the art will appreciate variations of these embodiments that fall within the scope of the invention. Those skilled in the art will also appreciate that the features described below can be combined in various ways to form multiple embodiments of the invention. As a result the invention is not limited to the specific embodiments described below but only by the claims and their equivalents.

In the method a plurality of data packets are exchanged between the first node and the second node of the network operation . As suggested in the data packets transmitted from the first node to the second node may be transmitted over a different path through the network than those packets traveling in the opposing direction. Each of the data packets includes a header and a payload formatted according to a connectionless transport layer communication protocol. Generally a data packet header is control and or status information related to the payload residing in the data packet and is currently positioned at the end of the data packet although other locations within the data packet are possible. Further the connectionless protocol payload includes a separate header including a first port indicator for the first node and a second port indicator for the second node . In one embodiment a port number may be any indicator or value designating a logical input or pathway of a node identified with a particular set of communications. Also the separate header of at least one of the data packets includes an indication to establish a connection between the first node and the second node .

In response to the exchange of the data packets the first node and the second node establish the connection between the first node and the second node wherein the first port indicator and the second port indicator are associated with the established connection operation . In another embodiment a computer readable storage medium may have encoded thereon instructions for a processor or other control circuitry to direct a device to implement the method .

Use of the method may thus allow the nodes to establish a connection therebetween by way of a standard connectionless protocol such as UDP thereby circumventing a standard connection protocol such as TCP while still employing the network layer IP standard logic commonly provided in many communication devices. Accordingly a communication protocol layer developed for a particular communication environment such as the streaming of video data packets across the network may be employed in lieu of the TCP protocol by employing the connectionless UDP protocol and underlying network layers as a data transmission mechanism. Further the new transport layer may address communication situations associated with the nature of the data being transferred the type of communication links being employed and other characteristics that are not handled efficiently by a more standardized transport layer connection protocol.

The software hierarchy includes an application a sockets module a reliability module a connectivity module and a transport network layer protocol stack such as a TCP IP stack including support for a connectionless transport layer protocol such as UDP. The application may be any application level software requiring access to a communication network. In one specific implementation the application may be an audio video stream source and or display application thus necessitating access to the communication network for the transmission and or reception of audio video data. For example an audio video destination such as a computer system a personal digital assistant PDA or a mobile communication device may attempt to establish a communication connection with a video source node such as a Slingbox by Sling Media Inc. coupled to a satellite or cable set top box so that the destination node may stream video from the set top box via the source node over the network. In this case the source node may be viewed as a server node while the destination node may be regarded as a client node with both the server node and the client node each separately implementing the software hierarchy of .

The sockets module provides an application programming interface API through which the application of the client or server device may access the network including the establishment of connections and transfer of data over such connections. Such an interface is often facilitated by way of a set of function calls provided by the sockets module such as those shown in and explained in greater detail below. Generally a socket is an endpoint of a communication path through the network defined by a node address such as an IP address and a port number. The sockets module allows the application to create one or more such sockets request a connection to another node using the socket transmit and or receive data via the socket free the socket and other applicable tasks. Accordingly the sockets module implements many of the operations discussed in greater detail below concerning establishment and termination of one or more connections by way of a packet based handshaking protocol using a connectionless transport layer protocol retransmission of lost handshaking packets and other functionality.

The sockets module accesses the reliability module to facilitate various protection mechanisms for the user data being transferred over an established connection between network nodes. In one implementation such mechanisms may include but are not limited to sequencing of the user data packets to facilitate their proper ordering at the receiving node acknowledgment or non acknowledgment and retransmission of lost user data packets and other functionality not provided by a connectionless transport layer protocol such as UDP. Further the reliability module may implement such protections as a replacement for the standard TCP layer. For example an example of such a reliability module may be as described in U.S. patent application Ser. No. 12 404920 entitled Method and Node for Transmitting Data over a Communication Network Using Negative Acknowledgment filed Mar. 16 2009 which is hereby incorporated herein by reference in its entirety.

As shown in the sockets module may further interface with a connection module which may facilitate the creation of tunnels or other mechanisms for maintaining a viable communication path between two network nodes.

The sockets module also communicates with the standardized transport network protocol stack such as a TCP IP stack which incorporates a connectionless transport layer protocol such as UDP. In the embodiments discussed herein the sockets module employs the UDP portion of the TCP IP stack thus circumventing TCP while implementing the connection handshake mechanism described below. Also sequencing and retransmission capabilities supplied by the reliability module may also be implemented in lieu of the corresponding functionality normally provided in TCP. Thus the functionality provided by the sockets module the reliability module and the connectivity module may be tailored to address various aspects of specific communication environments more efficiently than that provided by TCP.

As shown in the application communicates with the sockets module by way of function calls without having to engage in the specific details of the other modules provided in the software hierarchy . In turn the sockets module handles the required communications with the other modules primarily in response to the function calls . In one implementation a general control path between the sockets module and the reliability module as well as between the sockets module and each of the connectivity module and the protocol stack allows the sockets module to control each resulting protocol layer involving in network communications with another node.

In one implementation the sockets module may handle a number of asynchronous events such as those initiated by communication activity of another node on the network. For example the sockets module may respond to attempts by the other node to establish a new connection terminate an existing connection or to transmit data to the node employing the sockets module . Such events may be serviced by way of interrupt control polling or other asynchronous event handling means.

The control circuitry is configured to generate and transmit data packets via the communication interface to one or more other nodes as well as to receive and process data packets from those nodes by way of the interface . The structure and use of those packets is discussed in greater detail below. The control circuitry may include one or more processors such as a microprocessor microcontroller or digital signal processor DSP configured to execute instructions directing the processor to perform the functions and facilitate the communication discussed in greater detail below. The control circuitry may also include memory or data storage adapted to contain such instructions. In another implementation the control circuitry may be strictly hardware based logic or may include a combination of hardware firmware and or software elements.

In both the first client node and the second server node are presumed to reside in the CLOSED state indicating that no connection is current established between the nodes . To enable communication with the opposing node each of the nodes employs their respective connectivity module to create a tunnel or other communication path via the transport network layer thus placing both nodes into the TUNNEL CREATED state . In one implementation the tunnel or path is identified by way of a device address such as an IP address for each of the nodes . Alternatively the tunnel may be identified by way of a finder ID for at least one of the nodes . In one example the finder ID may be a logical identifier associated with one of the nodes that may be used to determine the IP address for that node by way of a look up table.

After the creation of the tunnel or path the first node transmits a SYN data packet thus initiating a handshake with the second node to establish a connection. The SYN data packet as well as all subsequent data packets involving the same connection identify a local port indicator associated with the first node and a remote port indicator associated with the second node . Thus the particular connection to be established is identified by way of these port indicators thus allowing multiple connections to be established between the nodes at any particular time. In one embodiment each port indicator may be selected by the application of the node or may be generated randomly or by other means by the sockets module .

As a result of transmitting the SYN data packet to the second node the first node assumes the SYN SENT state and awaits an affirmative response from the second node . In one embodiment the application initiates the handshake by way of the sConnect function call described earlier.

In response to receiving the SYN data packet the second node transitions to the SYN RECEIVED state . In one embodiment the second node employs the sListen function to enable its sockets module prior to transmission of the SYN data packet to receive the SYN data packet . Thereafter the second node transfers a SYN ACK data packet to the first node to continue the handshake and assumes the SYN ACK SENT state . In one implementation once the SYN data packet is received the sockets module notifies the application which in turn calls the sAccept module to transmit the SYN ACK data packet .

To implement error recovery in the case of a missing or defective SYN data packet or SYN ACK data packet either of which would cause the first node to not receive the SYN ACK packet the first node may implement a timeout period that is initiated after the SYN data packet is transmitted. If the first node then does not receive the SYN ACK data packet during the timeout period the first node may return to the TUNNEL CREATED state retransmit the SYN data packet and transition again to the SYN SENT state . In one implementation the first node may retransmit the SYN data packet several times up to some maximum number while a corresponding SYN ACK data packet is not received. In a further embodiment the time period may be different for two or more of the possible retransmissions of the SYN data packet with the time periods possibly increasing or decreasing for each successive retransmission.

Presuming that the first node successfully received the SYN ACK data packet the first node would then complete the handshake by transmitting an ACK data packet to the second node to confirm receipt of the SYN ACK data packet and transition from the SYN SENT state to the CONNECTION ESTABLISHED state . Correspondingly upon receiving the ACK data packet the second node also assumes the CONNECTION ESTABLISHED state thus placing both nodes in agreement that a communication connection has been established therebetween.

Similar to the retransmission scheme employed by the first node for the SYN data packet discussed above the second node may implement error recovery in the case of a missing or defective SYN ACK data packet or ACK data packet either of which may prevent the second node from properly receiving the ACK packet . More specifically the second node may implement a timeout period that is initiated after the second node transmits the SYN ACK data packet . If the second node then does not receive the ACK data packet during the timeout period the second node may then return to the SYN RECEIVED state retransmit the SYN ACK data packet and again assume the SYN ACK SENT state . In one example the second node may retransmit the SYN ACK data packet a number of times up to some maximum value while a corresponding ACK data packet is not received. In another implementation the time period may be different for two or more of the possible retransmissions of the SYN ACK data packet with the time periods possibly increasing or decreasing for each successive retransmission. Further the number of transmissions and the associated time periods may be different from those used for retransmission of the SYN data packet .

Presuming instead that the second node successfully received the ACK data packet both of the nodes operate within the CONNECTION ESTABLISHED state . Further the connection is identified in the nodes by way of the port indicators associated with each of the nodes . During this state transfer of user data packets such as data packets containing audio video data as mentioned above may then occur between the nodes . In this scenario since the first node has already received the SYN ACK data packet from the second node and since the mechanism shown in does not require the second node to issue an acknowledgment for the ACK data packet a retransmission scheme for the ACK data packet is generally not required. However in some implementations the first node may be configured to transmit an ACK data packet in response to receiving a SYN ACK data packet from the second node after the first node has already attained the CONNECTION ESTABLISHED state .

While in the CONNECTION ESTABLISHED state the sockets module facilitates the sending and receiving of data by way of the sSend and sRecv functions which involve use of the reliability module for sending and receiving the data in data packets under a scheme which may include sequencing positive and or negative acknowledge and other protection mechanisms as mentioned above.

Once either one of the nodes has determined that the data transfers are complete and that the connection should be terminated that node may begin terminating or closing the connection. Presuming the application of the first node has made this determination the application may initiate the termination of the connection by first using the sCloseSocket function call which in turn causes the first node to enter the CLOSING state initiate a FIN data packet and transitions the first node to the FIN SENT state . Presuming the second node successfully receives the FIN data packet the second node assumes the FIN RECEIVED state sends a FIN ACK data packet to the first node and arrives at the CLOSED state indicating that the connection has been terminated. Further once the first node receives the FIN ACK data packet the first node also enters the CLOSED state thus confirming that the connection is terminated.

In one implementation similar to others discussed above while in the FIN SENT state after issuing the FIN data packet if the first node does not receive a corresponding FIN ACK data packet within a predetermined time period the first node may return to the CLOSING state retransmit the FIN data packet and proceed to the FIN SENT state again to await an associated FIN ACK data packet . As before retransmissions may continue for a predefined number of attempts while awaiting the FIN ACK data packet with a potentially different time period associated with each retransmission.

Given the foregoing connection establishment data transfer and data termination mechanism at least six different types of data packets may be employed including the SYN packet the SYN ACK packet the ACK packet the DATA packet the FIN packet and the FIN ACK packet . An example format of a packet for each of these packet types is depicted in . In this example a header is added at each of several different communication protocol layers as the packet is passed downward through the levels before the packet is transmitted to another node . In the particular example of in the case of a DATA packet being generated for transmission to another node the reliability module may assemble a packet of user data with a leading reliability module header which may incorporate data allowing the reliability module to perform the sequencing positive and or negative acknowledgment and other data protection mechanisms described earlier.

As the packet is transferred from the reliability module to the sockets module the sockets module attaches a separate sockets layer header providing data capable of supporting the various functions attributed above to the sockets module . In the example of this header is applied to the end of the user data in the data packet although other locations for the sockets layer header may be utilized in other implementations. This data is described in greater detail below. The packet is then forwarded to the transport network layer which attaches a connectionless protocol layer header such as a UDP header to the packet before transmitting the packet over the network to another node. In some embodiments other headers and data not illustrated in may also be added to the packet .

In the sockets layer header provided by the sockets module includes a length in bytes of the header a header type a local port indicator a remote port indicator a bitmask and an optional field . The header type indicates which type of packet i.e. SYN SYN ACK ACK DATA FIN or FIN ACK is represented by the data packet . In one implementation the reliability module header and the user data of are present only if the header type indicates a DATA packet . The header type may indicate which type of packet by way of bitwise representation by bit encoded representation or by some other means of representation.

The local port indicator and the remote port indicator denote a particular port for the node originating the packet and a specific port for the node receiving the packet respectively. The connectionless protocol header such as a UDP header may also include port indicators such as a source port indicator and a destination port indicator. In UDP such port indicators are typically 16 bits in length with each port identifying a software structure configured to exchange data specifically associated with a particular application or service. Depending on the implementation the port indicators of the sockets layer header may or may not correspond to the port indicators of the connectionless protocol header . For example the local port indicator and the source port of the connectionless protocol header may be the same as well as the remote port indicator and the destination port of the connectionless protocol header if the two connected nodes reside on the same LAN. Thus within a single LAN the connection between the two nodes may be designated by way of an IP address and a port indicator as designated in both the connectionless protocol header and the sockets layer header .

In another example the two communicating nodes may reside in separate LANs thus communicating over a WAN. In that scenario a finder ID may be employed to identify at least one or both of the nodes . In that case the port indicator associated with that node may be a logical port indicator not associated with a port of the connectionless protocol header . In one example the logical port indicator may be generated at random thus reducing the likelihood that the logical port indicator will be identical to another logical port indicator associated with another connection between the nodes .

Use of the local port indicator and the remote port indicator whether they refer to logical ports or to ports of the connectionless protocol header facilitates concurrent multiplexing of different data streams being transmitted or received by a single node . More specifically each separate port of a node as identified in the sockets layer header may be associated with a separate connection with another node . Accordingly each connection may be established used and terminated in parallel with other connections involving the same node thus allowing the node to service or process several different data streams simultaneously.

The bitmask may be employed as a mask to condition data provided in the optional field . In one embodiment the optional field may include a session identifier for each of the nodes associated with a connection. In the example depicted in each of the packet types i.e. SYN SYN ACK ACK DATA FIN and FIN ACK may include in the sockets layer header a local session identifier for the node issuing the data packet and a remote session identifier associated with the node receiving the packet . In the case of the SYN packet the remote session identifier is set to zero as the remote session identifier associated with the node receiving the SYN packet is yet to be determined These session identifiers which may be generated randomly for each session may distinguish different sessions existing at different times over the same port of a node . For example a first stream of audio video data may be carried over a connection from the second node to the first node via a particular port of the first node . At the conclusion of that stream that connection may be terminated. Another connection involving the same port of the first node may then be established to carry another audio video stream thus representing a different session. By employing different session identifiers for the two sessions the first node may safely ignore or discard late arriving packets of the previous session based on the older session identifier included in the sockets layer header of the older packets .

At least some embodiments as described herein for establishing connections between two network nodes by way of a connectionless communication protocol may provide a number of advantages. Overall establishing connections in such a manner allows the use of a standard connectionless transport layer such as UDP with its minimal communication overhead as well as its associated network IP layer while incorporating connection mechanisms that potentially surpass the connection performance normally associated with TCP such as by providing handshaking retry mechanisms robust support for multiple concurrent connections and other advantages. Further software or firmware implementing the various embodiments discussed herein may further facilitate deployment of advanced data reliability schemes that may perform better than TCP in certain challenging communication environments.

While several embodiments of the invention have been discussed herein other implementations encompassed by the scope of the invention are possible. For example while various embodiments have been described primarily within the context of network connections carrying audio video stream communications any other form of data that may be transmitted and received by nodes of a communication network such as an IP network may be transferred via connections established according to the various concepts described herein. In addition aspects of one embodiment disclosed herein may be combined with those of alternative embodiments to create further implementations of the present invention. Thus while the present invention has been described in the context of specific embodiments such descriptions are provided for illustration and not limitation. Accordingly the proper scope of the present invention is delimited only by the following claims and their equivalents.

