---

title: Correlating hypervisor data for a virtual machine with associated operating system data
abstract: The disclosed embodiments relate to a system for analyzing the performance virtual machines. During operation, the system obtains hypervisor data for a set of virtual machines, wherein the hypervisor data was received from one or more hypervisors while the set of virtual machines was running on the hypervisors. The system also obtains operating system data for the set of virtual machines, wherein the operating system data was received from a set of operating systems while the set of operating systems was running on the set of virtual machines. Next, the system correlates hypervisor data for a virtual machine with corresponding operating system data for the virtual machine. Finally, the system presents the correlated hypervisor data and operating system data for the virtual machine to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471362&OS=09471362&RS=09471362
owner: SPLUNK INC.
number: 09471362
owner_city: San Francisco
owner_country: US
publication_date: 20141028
---
This application claims priority under 35 U.S.C. 119 e to U.S. Provisional Application Ser. No. 62 054 264 entitled Correlating Hypervisor Data for a Virtual Machine with Associated Operating System Data by inventors Alok A. Bhide and Adrian Hall filed on Sep. 23 2014 the contents of which are herein incorporated by reference.

The disclosed embodiments generally relate to techniques for analyzing performance in computer systems. More specifically the disclosed embodiments relate to a technique for correlating hypervisor data for a virtual machine with associated operating system data.

Organizations are increasingly relying on cloud based computing systems to perform large scale computational tasks. Such cloud based computing systems are typically operated by hosting companies that maintain a sizable computational infrastructure often comprising thousands of servers sited in geographically distributed data centers. Customers typically buy or lease computational resources from these hosting companies. The hosting companies in turn provision computational resources according to the customers requirements and then enable the customers to access these resources.

Cloud based computing systems often provide a virtualized computing environment wherein tasks run on virtual machines that execute on underlying physical host systems. Such virtualized computing environments enable computational tasks to be easily moved among host systems to facilitate load balancing and fault tolerance. However they also complicate the process of diagnosing and resolving performance problems because such performance problems can arise at the virtual machine level at the host system level and also between virtual processes that run inside the virtual machines.

Existing performance monitoring tools for virtual machines typically operate by gathering virtual machine performance parameters from a hypervisor which is responsible for instantiating and executing virtual machines on an underlying host system. For example virtual machine performance parameters can specify processor utilization or memory utilization parameters for virtual machines that are executing on the hypervisor. However these virtual machine performance parameters do not tell the whole story. To determine the root cause of a performance problem it is often advantageous to analyze performance parameters for virtual processes that run inside operating systems within the virtual machines.

Unfortunately such virtual process performance parameters cannot be obtained from the hypervisor. It is typically necessary for an administrator to obtain such virtual process performance parameters from another diagnostic tool that gathers process level performance parameters from operating systems that execute within the virtual machines. Note that these operating systems keep track of different types of performance data within the virtual machine including performance parameters for virtual processes that run within the virtual machines. Even when such process level performance parameters can be gathered it is difficult to correlate these process level performance parameters with virtual machine performance parameters obtained from a hypervisor.

Hence what is needed is a system that facilitates efficiently analyzing performance parameters for virtual machines together with performance parameters for associated virtual processes without the drawbacks of existing techniques.

The disclosed embodiments relate to a performance monitoring system that facilitates correlating hypervisor performance data for virtual machines with associated operating system data for virtual processes that execute on the virtual machines. This performance monitoring system is described in more detail below but first we describe the structure of an event based system in which this performance monitoring system operates.

Modern data centers often comprise thousands of host computer systems that operate collectively to service requests from even larger numbers of remote clients. During operation these data centers generate significant volumes of performance data and diagnostic information that can be analyzed to quickly diagnose performance problems. In order to reduce the size of this performance data the data is typically pre processed prior to being stored based on anticipated data analysis needs. For example pre specified data items can be extracted from the performance data and stored in a database to facilitate efficient retrieval and analysis at search time. However the rest of the performance data is not saved and is essentially discarded during pre processing. As storage capacity becomes progressively cheaper and more plentiful there are fewer incentives to discard this performance data and many reasons to keep it.

This plentiful storage capacity is presently making it feasible to store massive quantities of minimally processed performance data at ingestion time for later retrieval and analysis at search time. Note that performing the analysis operations at search time provides greater flexibility because it enables an analyst to search all of the performance data instead of searching pre specified data items that were stored at ingestion time. This enables the analyst to investigate different aspects of the performance data instead of being confined to the pre specified set of data items that was selected at ingestion time.

However analyzing massive quantities of heterogeneous performance data at search time can be a challenging task. A data center may generate heterogeneous performance data from thousands of different components which can collectively generate tremendous volumes of performance data that can be time consuming to analyze. For example this performance data can include data from system logs network packet data sensor data and data generated by various applications. Also the unstructured nature of much of this performance data can pose additional challenges because of the difficulty of applying semantic meaning to unstructured data and the difficulty of indexing and querying unstructured data using traditional database systems.

These challenges can be addressed by using an event based system such as the SPLUNK ENTERPRISE system produced by Splunk Inc. of San Francisco Calif. to store and process performance data. The SPLUNK ENTERPRISE system is the leading platform for providing real time operational intelligence that enables organizations to collect index and harness machine generated data from various websites applications servers networks and mobile devices that power their businesses. The SPLUNK ENTERPRISE system is particularly useful for analyzing unstructured performance data which is commonly found in system log files. Although many of the techniques described herein are explained with reference to the SPLUNK ENTERPRISE system the techniques are also applicable to other types of data server systems.

In the SPLUNK ENTERPRISE system performance data is stored as events wherein each event comprises a collection of performance data and or diagnostic information that is generated by a computer system and is correlated with a specific point in time. Events can be derived from time series data wherein time series data comprises a sequence of data points e.g. performance measurements from a computer system that are associated with successive points in time and are typically spaced at uniform time intervals. Events can also be derived from structured or unstructured data. Structured data has a predefined format wherein specific data items with specific data formats reside at predefined locations in the data. For example structured data can include data items stored in fields in a database table. In contrast unstructured data does not have a predefined format. This means that unstructured data can comprise various data items having different data types that can reside at different locations. For example when the data source is an operating system log an event can include one or more lines from the operating system log containing raw data that includes different types of performance and diagnostic information associated with a specific point in time. Examples of data sources from which an event may be derived include but are not limited to web servers application servers databases firewalls routers operating systems and software applications that execute on computer systems mobile devices and sensors. The data generated by such data sources can be produced in various forms including for example and without limitation server log files activity log files configuration files messages network packet data performance measurements and sensor measurements. An event typically includes a timestamp that may be derived from the raw data in the event or may be determined through interpolation between temporally proximate events having known timestamps.

The SPLUNK ENTERPRISE system also facilitates using a flexible schema to specify how to extract information from the event data wherein the flexible schema may be developed and redefined as needed. Note that a flexible schema may be applied to event data on the fly when it is needed e.g. at search time rather than at ingestion time of the data as in traditional database systems. Because the schema is not applied to event data until it is needed e.g. at search time it is referred to as a late binding schema. 

During operation the SPLUNK ENTERPRISE system starts with raw data which can include unstructured data machine data performance measurements or other time series data such as data obtained from weblogs syslogs or sensor readings. It divides this raw data into portions and optionally transforms the data to produce timestamped events. The system stores the timestamped events in a data store and enables a user to run queries against the data store to retrieve events that meet specified criteria such as containing certain keywords or having specific values in defined fields. Note that the term field refers to a location in the event data containing a value for a specific data item.

As noted above the SPLUNK ENTERPRISE system facilitates using a late binding schema while performing queries on events. A late binding schema specifies extraction rules that are applied to data in the events to extract values for specific fields. More specifically the extraction rules for a field can include one or more instructions that specify how to extract a value for the field from the event data. An extraction rule can generally include any type of instruction for extracting values from data in events. In some cases an extraction rule comprises a regular expression in which case the rule is referred to as a regex rule. 

In contrast to a conventional schema for a database system a late binding schema is not defined at data ingestion time. Instead the late binding schema can be developed on an ongoing basis until the time a query is actually executed. This means that extraction rules for the fields in a query may be provided in the query itself or may be located during execution of the query. Hence as an analyst learns more about the data in the events the analyst can continue to refine the late binding schema by adding new fields deleting fields or changing the field extraction rules until the next time the schema is used by a query. Because the SPLUNK ENTERPRISE system maintains the underlying raw data and provides a late binding schema for searching the raw data it enables an analyst to investigate questions that arise as the analyst learns more about the events.

In the SPLUNK ENTERPRISE system a field extractor may be configured to automatically generate extraction rules for certain fields in the events when the events are being created indexed or stored or possibly at a later time. Alternatively a user may manually define extraction rules for fields using a variety of techniques.

Also a number of default fields that specify metadata about the events rather than data in the events themselves can be created automatically. For example such default fields can specify a timestamp for the event data a host from which the event data originated a source of the event data and a source type for the event data. These default fields may be determined automatically when the events are created indexed or stored.

In some embodiments a common field name may be used to reference two or more fields containing equivalent data items even though the fields may be associated with different types of events that possibly have different data formats and different extraction rules. By enabling a common field name to be used to identify equivalent fields from different types of events generated by different data sources the system facilitates use of a common information model CIM across the different data sources.

During operation the forwarders identify which indexers will receive the collected data and then forward the data to the identified indexers. Forwarders can also perform operations to strip out extraneous data and detect timestamps in the data. The forwarders next determine which indexers will receive each data item and then forward the data items to the determined indexers .

Note that distributing data across different indexers facilitates parallel processing. This parallel processing can take place at data ingestion time because multiple indexers can process the incoming data in parallel. The parallel processing can also take place at search time because multiple indexers can search through the data in parallel.

System and the processes described below with respect to are further described in Exploring Splunk Search Processing Language SPL Primer and Cookbook by David Carasso UM Research 2012 and in Optimizing Data Analysis With a Semi Structured Time Series Database by Ledion Bitincka Archana Ganapathi Stephen Sorkin and Steve Zhang SLAML each of which is hereby incorporated herein by reference in its entirety for all purposes.

Next the indexer determines a timestamp for each event at block . As mentioned above these timestamps can be determined by extracting the time directly from data in the event or by interpolating the time based on timestamps from temporally proximate events. In some cases a timestamp can be determined based on the time the data was received or generated. The indexer subsequently associates the determined timestamp with each event at block for example by storing the timestamp as metadata for each event.

Then the system can apply transformations to data to be included in events at block . For log data such transformations can include removing a portion of an event e.g. a portion used to define event boundaries extraneous text characters etc. or removing redundant portions of an event. Note that a user can specify portions to be removed using a regular expression or any other possible technique.

Next a keyword index can optionally be generated to facilitate fast keyword searching for events. To build a keyword index the indexer first identifies a set of keywords in block . Then at block the indexer includes the identified keywords in an index which associates each stored keyword with references to events containing that keyword or to locations within events where that keyword is located . When an indexer subsequently receives a keyword based query the indexer can access the keyword index to quickly identify events containing the keyword.

In some embodiments the keyword index may include entries for name value pairs found in events wherein a name value pair can include a pair of keywords connected by a symbol such as an equals sign or colon. In this way events containing these name value pairs can be quickly located. In some embodiments fields can automatically be generated for some or all of the name value pairs at the time of indexing. For example if the string dest 10.0.1.2 is found in an event a field named dest may be created for the event and assigned a value of 10.0.1.2. 

Finally the indexer stores the events in a data store at block wherein a timestamp can be stored with each event to facilitate searching for events based on a time range. In some cases the stored events are organized into a plurality of buckets wherein each bucket stores events associated with a specific time range. This not only improves time based searches but it also allows events with recent timestamps that may have a higher likelihood of being accessed to be stored in faster memory to facilitate faster retrieval. For example a bucket containing the most recent events can be stored as flash memory instead of on hard disk.

Each indexer is responsible for storing and searching a subset of the events contained in a corresponding data store . By distributing events among the indexers and data stores the indexers can analyze events for a query in parallel for example using map reduce techniques wherein each indexer returns partial responses for a subset of events to a search head that combines the results to produce an answer for the query. By storing events in buckets for specific time ranges an indexer may further optimize searching by looking only in buckets for time ranges that are relevant to a query.

Moreover events and buckets can also be replicated across different indexers and data stores to facilitate high availability and disaster recovery as is described in U.S. patent application Ser. No. 14 266 812 filed on 30 Apr. 2014 and in U.S. application patent Ser. No. 14 266 817 also filed on 30 Apr. 2014.

Then at block the indexers to which the query was distributed search their data stores for events that are responsive to the query. To determine which events are responsive to the query the indexer searches for events that match the criteria specified in the query. This criteria can include matching keywords or specific values for certain fields. In a query that uses a late binding schema the searching operations in block may involve using the late binding scheme to extract values for specified fields from events at the time the query is processed. Next the indexers can either send the relevant events back to the search head or use the events to calculate a partial result and send the partial result back to the search head.

Finally at block the search head combines the partial results and or events received from the indexers to produce a final result for the query. This final result can comprise different types of data depending upon what the query is asking for. For example the final results can include a listing of matching events returned by the query or some type of visualization of data from the returned events. In another example the final result can include one or more calculated values derived from the matching events.

Moreover the results generated by system can be returned to a client using different techniques. For example one technique streams results back to a client in real time as they are identified. Another technique waits to report results to the client until a complete set of results is ready to return to the client. Yet another technique streams interim results back to the client in real time until a complete set of results is ready and then returns the complete set of results to the client. In another technique certain results are stored as search jobs and the client may subsequently retrieve the results by referencing the search jobs.

The search head can also perform various operations to make the search more efficient. For example before the search head starts executing a query the search head can determine a time range for the query and a set of common keywords that all matching events must include. Next the search head can use these parameters to query the indexers to obtain a superset of the eventual results. Then during a filtering stage the search head can perform field extraction operations on the superset to produce a reduced set of search results.

Upon receiving search query query processor sees that search query includes two fields IP and target. Query processor also determines that the values for the IP and target fields have not already been extracted from events in data store and consequently determines that query processor needs to use extraction rules to extract values for the fields. Hence query processor performs a lookup for the extraction rules in a rule base wherein rule base maps field names to corresponding extraction rules and obtains extraction rules wherein extraction rule specifies how to extract a value for the IP field from an event and extraction rule specifies how to extract a value for the target field from an event. As is illustrated in extraction rules can comprise regular expressions that specify how to extract values for the relevant fields. Such regular expression based extraction rules are also referred to as regex rules. In addition to specifying how to extract field values the extraction rules may also include instructions for deriving a field value by performing a function on a character string or value retrieved by the extraction rule. For example a transformation rule may truncate a character string or convert the character string into a different data format. In some cases the query itself can specify one or more extraction rules.

Next query processor sends extraction rules to a field extractor which applies extraction rules to events in a data store . Note that data store can include one or more data stores and extraction rules can be applied to large numbers of events in data store and are not meant to be limited to the three events illustrated in . Moreover the query processor can instruct field extractor to apply the extraction rules to all the events in a data store or to a subset of the events that has been filtered based on some criteria.

Next field extractor applies extraction rule for the first command Search IP 10 to events in data store including events . Extraction rule is used to extract values for the IP address field from events in data store by looking for a pattern of one or more digits followed by a period followed again by one or more digits followed by another period followed again by one or more digits followed by another period and followed again by one or more digits. Next field extractor returns field values to query processor which uses the criterion IP 10 to look for IP addresses that start with 10 . Note that events and match this criterion but event does not so the result set for the first command is events .

Query processor then sends events to the next command stats count target. To process this command query processor causes field extractor to apply extraction rule to events . Extraction rule is used to extract values for the target field for events by skipping the first four commas in events and then extracting all of the following characters until a comma or period is reached. Next field extractor returns field values to query processor which executes the command stats count target to count the number of unique values contained in the target fields which in this example produces the value 2 that is returned as a final result for the query.

Note that query results can be returned to a client a search head or any other system component for further processing. In general query results may include a set of one or more events a set of one or more values obtained from the events a subset of the values statistics calculated based on the values a report containing the values or a visualization such as a graph or chart generated from the values.

After the search is executed the search screen can display the results through search results tabs wherein search results tabs includes an events tab that displays various information about events returned by the search a statistics tab that displays statistics about the search results and a visualization tab that displays various visualizations of the search results. The events tab illustrated in displays a timeline graph that graphically illustrates the number of events that occurred in one hour intervals over the selected time range. It also displays an events list that enables a user to view the raw data in each of the returned events. It additionally displays a fields sidebar that includes statistics about occurrences of specific fields in the returned events including selected fields that are pre selected by the user and interesting fields that are automatically selected by the system based on pre specified criteria.

The above described system provides significant flexibility by enabling a user to analyze massive quantities of minimally processed performance data on the fly at search time instead of storing pre specified portions of the performance data in a database at ingestion time. This flexibility enables a user to see correlations in the performance data and perform subsequent queries to examine interesting aspects of the performance data that may not have been apparent at ingestion time.

However performing extraction and analysis operations at search time can involve a large amount of data and require a large number of computational operations which can cause considerable delays while processing the queries. Fortunately a number of acceleration techniques have been developed to speed up analysis operations performed at search time. These techniques include 1 performing search operations in parallel by formulating a search as a map reduce computation 2 using a keyword index 3 using a high performance analytics store and 4 accelerating the process of generating reports. These techniques are described in more detail below.

To facilitate faster query processing a query can be structured as a map reduce computation wherein the map operations are delegated to the indexers while the corresponding reduce operations are performed locally at the search head. For example illustrates how a search query received from a client at search head can split into two phases including 1 a map phase comprising subtasks e.g. data retrieval or simple filtering that may be performed in parallel and are mapped to indexers for execution and 2 a reduce phase comprising a merging operation to be executed by the search head when the results are ultimately collected from the indexers.

During operation upon receiving search query search head modifies search query by substituting stats with prestats to produce search query and then distributes search query to one or more distributed indexers which are also referred to as search peers. Note that search queries may generally specify search criteria or operations to be performed on events that meet the search criteria. Search queries may also specify field names as well as search criteria for the values in the fields or operations to be performed on the values in the fields. Moreover the search head may distribute the full search query to the search peers as is illustrated in or may alternatively distribute a modified version e.g. a more restricted version of the search query to the search peers. In this example the indexers are responsible for producing the results and sending them to the search head. After the indexers return the results to the search head the search head performs the merging operations on the results. Note that by executing the computation in this way the system effectively distributes the computational operations while minimizing data transfers.

As described above with reference to the flow charts in event processing system can construct and maintain one or more keyword indices to facilitate rapidly identifying events containing specific keywords. This can greatly speed up the processing of queries involving specific keywords. As mentioned above to build a keyword index an indexer first identifies a set of keywords. Then the indexer includes the identified keywords in an index which associates each stored keyword with references to events containing that keyword or to locations within events where that keyword is located. When an indexer subsequently receives a keyword based query the indexer can access the keyword index to quickly identify events containing the keyword.

To speed up certain types of queries some embodiments of system make use of a high performance analytics store which is referred to as a summarization table that contains entries for specific field value pairs. Each of these entries keeps track of instances of a specific value in a specific field in the event data and includes references to events containing the specific value in the specific field. For example an exemplary entry in a summarization table can keep track of occurrences of the value 94107 in a ZIP code field of a set of events wherein the entry includes references to all of the events that contain the value 94107 in the ZIP code field. This enables the system to quickly process queries that seek to determine how many events have a particular value for a particular field because the system can examine the entry in the summarization table to count instances of the specific value in the field without having to go through the individual events or do extractions at search time. Also if the system needs to process all events that have a specific field value combination the system can use the references in the summarization table entry to directly access the events to extract further information without having to search all of the events to find the specific field value combination at search time.

In some embodiments the system maintains a separate summarization table for each of the above described time specific buckets that stores events for a specific time range wherein a bucket specific summarization table includes entries for specific field value combinations that occur in events in the specific bucket. Alternatively the system can maintain a separate summarization table for each indexer wherein the indexer specific summarization table only includes entries for the events in a data store that is managed by the specific indexer.

The summarization table can be populated by running a collection query that scans a set of events to find instances of a specific field value combination or alternatively instances of all field value combinations for a specific field. A collection query can be initiated by a user or can be scheduled to occur automatically at specific time intervals. A collection query can also be automatically launched in response to a query that asks for a specific field value combination.

In some cases the summarization tables may not cover all of the events that are relevant to a query. In this case the system can use the summarization tables to obtain partial results for the events that are covered by summarization tables but may also have to search through other events that are not covered by the summarization tables to produce additional results. These additional results can then be combined with the partial results to produce a final set of results for the query. This summarization table and associated techniques are described in more detail in U.S. Pat. No. 8 682 925 issued on Mar. 25 2014.

In some embodiments a data server system such as the SPLUNK ENTERPRISE system can accelerate the process of periodically generating updated reports based on query results. To accelerate this process a summarization engine automatically examines the query to determine whether generation of updated reports can be accelerated by creating intermediate summaries. This is possible if results from preceding time periods can be computed separately and combined to generate an updated report. In some cases it is not possible to combine such incremental results for example where a value in the report depends on relationships between events from different time periods. If reports can be accelerated the summarization engine periodically generates a summary covering data obtained during a latest non overlapping time period. For example where the query seeks events meeting a specified criteria a summary for the time period includes only events within the time period that meet the specified criteria. Similarly if the query seeks statistics calculated from the events such as the number of events that match the specified criteria then the summary for the time period includes the number of events in the period that match the specified criteria.

In parallel with the creation of the summaries the summarization engine schedules the periodic updating of the report associated with the query. During each scheduled report update the query engine determines whether intermediate summaries have been generated covering portions of the time period covered by the report update. If so then the report is generated based on the information contained in the summaries. Also if additional event data has been received and has not yet been summarized and is required to generate the complete report the query can be run on this additional event data. Then the results returned by this query on the additional event data along with the partial results obtained from the intermediate summaries can be combined to generate the updated report. This process is repeated each time the report is updated. Alternatively if the system stores events in buckets covering specific time ranges then the summaries can be generated on a bucket by bucket basis. Note that producing intermediate summaries can save the work involved in re running the query for previous time periods so only the newer event data needs to be processed while generating an updated report. These report acceleration techniques are described in more detail in U.S. Pat. No. 8 589 403 issued on Nov. 19 2013 and U.S. Pat. No. 8 412 696 issued on Apr. 2 2011.

Note that all of these virtual machines and and associated hypervisors and operate under control of a management server which is referred to as a virtual center . Virtual center performs operations to facilitate centralized management operational automation resource optimizations and high availability for the virtual machines and which execute on hypervisors and . Virtual center additionally obtains performance related data from hypervisors and . This performance related data is sent to a forwarder which forwards the performance related data to an indexer wherein indexer stores the data in data store . In some embodiments forwarder obtains this performance related data by making calls through an application programming interface API provided by virtual center .

The performance related data obtained from hypervisors and is referred to as hypervisor data . For example hypervisor data can include but is not limited to resource utilization parameters for virtual machines resource utilization parameters for physical hosts performance metrics for virtual machines and performance metrics for physical hosts.

The system also obtains performance related data from operating systems within the virtual machines. To illustrate how this performance related data is gathered the internal structure for a specific virtual machine is illustrated in . The specific virtual machine includes an operating system which is responsible for managing the execution of various applications and processes . For example operating system can include the Linux operating system. A special forwarder is installed on operating system to forward performance related data to indexer .

This performance related data obtained from inside virtual machine operating systems is referred to as operating system OS data . For example OS data can include but is not limited to resource utilization parameters for virtual processes running inside the virtual machines performance metrics for the virtual processes identifiers for owners associated with the virtual processes and performance data obtained from the set of operating systems and log data from operating system logs maintained by the set of operating systems. Note that this log data can include data from underlying system logs security logs for authentication configuration change logs and Internet information services IIS logs.

It can also be useful to know which owners are associated with specific virtual processes. For example an owner of a process that executes inside a virtual machine is typically an administrator or a service owner. Hence when the system determines that a standard user who is not an administrator or a service owner is running a process on a virtual machine the system can determine that this circumstance is a security exception and can deal with the process accordingly.

Another piece of software which is referred to as a technology add on TA is installed over special forwarder . TA specifies how to collect OS data including specifying the sources of the OS data and the frequency of collection. For example OS data can be collected from various operating system logs such as an event log a security log or an event scheduling cron log. The OS data can also be collected from internal operating system kernel data structures to obtain information about the performance of specific virtual processes. TA directs the collected OS data to special forwarder and special forwarder in turn forwards OS data to indexer .

Next the system correlates the hypervisor data for a virtual machine with corresponding operating system data for the virtual machine step . For example the system can match hypervisor data for a virtual machine with corresponding operating system data for the same virtual machine by identifying the data with reference to a medium access control MAC address associated with the virtual machine.

Note that a MAC address can serve as a unique identifier for the virtual machine. Hence if a MAC address is stored along with the performance data by the hypervisor and also by the operating system the MAC address can subsequently be used to identify the virtual machine that generated the performance data. This enables the system to correlate hypervisor and operating system performance data for the virtual machine. For example suppose the system retrieves an event containing memory utilization performance data from the hypervisor wherein the event includes a MAC address for the virtual machine. Additionally suppose the system retrieves another event containing memory utilization performance data from an operating system in the same virtual machine wherein the event also includes the MAC address for the virtual machine. In this example the system can match the events based on the MAC address for the virtual machine and can display the corresponding data from the hypervisor and from the operating system together in a single display for the virtual machine as is described in more detail below with reference to . Note that this type of correlation can be performed automatically or manually.

The system can additionally use other types of information to identify a virtual machine that generated the data such as 1 one or more IP addresses for the virtual machine and 2 a host name identifying a physical host on which the virtual machine executes. Also note that to uniquely identify a host the system can use one or more MAC addresses plus one or more IP addresses. Because a MAC address is unique on a network it is also unique within a hypervisor and hence can be used for correlation. 

Next the system presents the correlated hypervisor data and operating system data for the virtual machine to a user step . For example the system can present the hypervisor and operating system data together in a single view to enable the user to understand relationships between the hypervisor data and operating system data. In another example the system facilitates executing a single query which is specified in a query language wherein the single query operates on both the hypervisor data and the operating system data for the set of virtual machines to generate a query result. In yet another example the system can use the hypervisor data and the operating system data to establish a baseline to facilitate subsequently determining when the system undergoes a noteworthy change.

The information that is presented in this way can be quite useful. For example the information can enable an administrator to determine whether an application is using more memory than it has been allocated and to make a decision about whether the memory allocation needs to be increased for this application. In another example the administrator can determine that a process is a rogue process that should not be running on a virtual machine and can take steps to shut down the rogue process.

In some embodiments the system additionally computes differences between performance metrics in the hypervisor data and corresponding performance metrics in the operating system data step and the system presents the computed differences to the user step . Note that informing the user about a significant difference between a performance metric that appears in the hypervisor data and the same performance metric that appears in the operating system data makes the user aware of an uncertainty in measuring the performance metrics and thereby enables the user to look for a cause of the discrepancy. A number of factors can cause this type of discrepancy including the overhead involved in running the operating system on the virtual machine and the overhead involved in running the virtual machine itself on the hypervisor.

The middle section of display presents a memory utilization graph which includes a solid line representing memory utilization for the entire virtual machine as a percentage of the total memory that has been allocated to the virtual machine. Note that line is constructed from information obtained from hypervisor data . Memory utilization graph also includes a dashed line representing memory utilization for a selected process as a percentage of the total memory that has been allocated to the virtual machine. Note that dashed line is constructed from information obtained from OS data .

The bottom section of display presents a CPU utilization graph which includes a solid line representing CPU utilization for the entire virtual machine as a percentage of the total CPU capacity that has been allocated to the virtual machine. This solid line is constructed from information obtained from hypervisor data . CPU utilization graph also includes a dashed line representing CPU utilization for a selected process as a percentage of the total CPU capacity that has been allocated to the virtual machine. Note that dashed line is constructed from information obtained from OS data .

When a user selects one of processes within top section the system displays the corresponding memory utilization and CPU utilization information for the selected process in the graphs that appear in the middle section and bottom section of display . This enables the user to determine for example whether an increase in CPU utilization for the virtual machine can be attributed to an increase in CPU utilization for a specific process. The user can also double click on one of the processes in top section to expose other types of operating system level information for the process.

The display illustrated in is merely an example of a type of display that can be used to present both hypervisor data and operating system data for a virtual machine at the same time. In general many different types of user interface can be used. For example the system can provide a workflow that lets a user drill down from the perspective of the specific applications and processes into virtual machines associated with the specific applications and processes as opposed to drilling down starting from a virtual machine hierarchy. This enables an administrator to more easily investigate the root cause of performance problems for specific applications and processes.

The preceding description was presented to enable any person skilled in the art to make and use the disclosed embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the disclosed embodiments. Thus the disclosed embodiments are not limited to the embodiments shown but are to be accorded the widest scope consistent with the principles and features disclosed herein. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present description. The scope of the present description is defined by the appended claims.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing code and or data now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored on a non transitory computer readable storage medium as described above. When a system reads and executes the code and or data stored on the non transitory computer readable storage medium the system performs the methods and processes embodied as data structures and code and stored within the non transitory computer readable storage medium.

Furthermore the methods and processes described above can be included in hardware modules. For example the hardware modules can include but are not limited to application specific integrated circuit ASIC chips field programmable gate arrays FPGAs and other programmable logic devices now known or later developed. When the hardware modules are activated the hardware modules perform the methods and processes included within the hardware modules.

