---

title: Bidi extension for connected devices
abstract: Bidirectional (bidi) extension techniques for USB and/or other similar busses/connections are described in which an interface is provided to enable bidirectional communication with connected devices. The interface may be implemented as an operating system component to handle bidi communication for devices from multiple different independent hardware vendors (IHVs). Device drivers for different devices can be configured to include extension files in accordance with an established schema for bidi communication. The extension files describe supported bidi attributes, capabilities of the device, and how to make calls into the device. The interface operates to detect the extension files and set-up a corresponding device for bidi communication. Applications then interact through the interface to access, retrieve, and set configuration and status data for connected devices. The use of extension files enable creation of architecture independent devices drivers that can be used across different platforms with substantially no changes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09223733&OS=09223733&RS=09223733
owner: Microsoft Technology Licensing, LLC
number: 09223733
owner_city: Redmond
owner_country: US
publication_date: 20141201
---
This Application is a continuation of and claims priority under 35 U.S.C. 120 to U.S. patent application Ser. No. 13 228 292 filed on Sep. 8 2011 titled Bidi Extension for Connected Devices the disclosure of which is incorporated by reference herein in its entirety.

Universal Serial Bus USB is one way in which users may connect devices to their computers. For USB connected devices a standard way does not exist to define retrieve or provide rich device status and configuration information over a USB connection. As a result hardware developers are forced to create custom device specific software such as port monitors and language monitors designed to handle communication of status and configuration for devices on an individual basis. Such device specific software is traditionally developed using complex binary coding. Moreover duplicate efforts are performed by different hardware developers to create their own custom solutions. As such use of many different custom solutions may increase development costs cause driver reliability issues and contribute to instability of a computing platform.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Bidirectional bidi extension techniques for USB and or similar busses protocols are described in which an interface is provided to enable bidirectional communication with connected devices. The interface may be configured as a bidi extender that is incorporated as an operating system component. The bidi extender is designed to support bidi communications between a computing device and connected devices of multiple different independent hardware vendors IHVs . The bidi extender implements an architecture independent extension schema to access and define status and configuration data for connected devices. In one approach the bidi extender detects extension files included with a device driver in accordance with the schema and employs the files to initialize the device for bidirectional communication. In at least some embodiments the bidi extender supports extension files defined using script based programming languages such as JavaScript and or extensible mark up language XML . Applications may then invoke the bidi extender to request data for a device set values for device specific data and or register to receive change notifications regarding the data.

Bidirectional bidi extension techniques are described in which an interface is provided to enable bidirectional communication with connected devices. For example a USB bidi extender may be provided as a component of a print subsystem to handle bidi communication for USB printers from multiple different independent hardware vendors IHVs . Bidi communication can be used to obtain set supported bidi values for configuration and status data which in the case of printers may include items such as ink levels print job status paper tray types printer functions and so forth. Printer drivers for the printers can be configured to include one or more extension files in accordance with an established extension schema for USB bidi communication. The extension files describe supported bidi values actions and or queries capabilities of the device and how to make calls into the device to manipulate data. The USB bidi extender operates to detect the extension files and set up a corresponding device for bidi communication according to the extension files. Applications may then interact through the USB bidi extender to access retrieve and set configuration and status data for the USB connected devices.

Although examples of USB connected devices are provided throughout this document the bidi extension techniques are not limited to USB or USB connected devices. Rather the techniques are equally applicable to similar busses connections and devices that make use of various send receive protocols to connect and communicate with peripheral devices from IHVs such as transmission control protocol TCP direct serial connections and or wireless technologies such as Bluetooth . Thus a bidi extender may also be configured and provided for other similar types of busses connections and devices that operates in a comparable manner to the USB bidi extender s for USB devices discussed by way of example herein.

In the discussion that follows a section titled Operating Environment is provided and describes an example environment in which one or more embodiments can be employed. Next a section titled Example USB Bidi Extension Techniques describes example details and procedures for bidi extension in accordance with one or more embodiments. Last a section titled Example System describes an example system that can be utilized to implement one or more embodiments.

The computing device can also be connected over a network to a service provider to access and interact with various resources . The resources can include any suitable combination of services and or content typically made available over a network by one or more providers. Some examples of services include but are not limited to a search service a messaging service to send receive messages a network printing service and a social networking service. Content may include various combinations of text video ads audio multi media streams animations images webpages web applications device applications and the like.

To further illustrate the example operating environment consider now which depicts aspects of the example computing device and an example USB device of in greater detail. In this example the USB device is illustrated as a USB printer however the techniques described herein are applicable to various different types of USB devices.

The computing device of includes one or more processors one or more computer readable media and one or more applications an operating system a USB bidi extender and one or more device drivers that reside on the computer readable media and which are executable by the processor s . As discussed in greater detail below the USB bidi extender represents an interface that enables bidi communication between the applications and devices corresponding to the device drivers . The device drivers provide interfaces between the operating system and hardware devices to process commands format data and otherwise enable interaction with the hardware devices in ways that the device is able to understand.

The USB device is depicted as having one or more processors and one or more computer readable media . In addition the USB device includes configuration data and status data residing on the computer readable media and which can be provided over the USB connection to the computing device using USB bidi extension techniques described herein. Configuration data describes various functional capabilities of the device. For a printer device this may include types of paper trays printing functions memory processing capacity and so forth. The status data represents device specific status information. For a printer device this may include ink levels print job status paper tray status printing error information connection data and so forth.

Computer readable media as used herein can include by way of example and not limitation all forms of volatile and non volatile memory and or storage media that are typically associated with a computing device. Such media can include read only memory ROM random access memory RAM flash memory hard disk removable media and the like. One such configuration of a computer readable media is signal bearing communication media that is configured to transmit computer readable instructions e.g. as a carrier wave to the hardware of the computing device such as via a network. The computer readable media may also be configured as computer readable storage media that excludes signals per se. Thus computer readable media includes both computer readable storage media and communication media further examples of which can be found in the discussion of the example computing system of .

In operation as will be described in detail below the computing device through the USB bidi extender implements an extension schema to enable bidi communication with the USB devices . To do so the computing device may expose the USB bidi extender that represents functionality to configure devices for bidi communications handle requests from applications and provide the applications with requested data from USB connected devices using techniques described herein. Although depicted separately the USB bidi extender may be provided as an integrated component of the operating system . For example when implemented to handle bidi communication for USB printers the USB bidi extender may be provided as a component of a print subsystem.

Having described an example operating environment consider now a discussion of example USB bidi extension techniques in accordance with one or more embodiments.

This section discusses details regarding example USB bidi extension techniques that may implemented by way of a suitably configured device such as the example computing devices of . In the discussion that follows an example printer implementation is discussed in relation to . Following this some example procedures for USB bidi extension are discussed in relation to .

Consider which illustrates an example printing environment that enables bidi communication in accordance with one or more embodiments. Here the example printing environment includes a print subsystem that may be provided as part of the operating system of a computing device. The print subsystem further includes a print spooler used to manage and queue print jobs from applications and a port monitor . In addition a printer driver and a corresponding USB printer connected to the print subsystem by way of a USB connection are depicted. Other suitable send receive protocols and technologies may also be used to connect other kinds of devices for which bidi extension techniques may be implemented in substantially the same manner as for the USB device connections examples described herein.

The port monitor is configured to communicate with a device connected to a port. The port monitor also operates to manage multiple ports including creating the ports opening closing of ports assigning ports and so forth. A port refers to a logical name that represents a connection to a particular device such as a network address e.g. TCP IP address or in this example the USB connection to the USB printer . Generally data that passes through the port monitor is provided in a form that may be understood by the destination device. In this example a USB bidi extender is provided as a component of the port monitor . The USB bidi extender may also be provided as a component of the print subsystem or operating system or even as a standalone component.

The USB bidi extender operates to configure the USB printer for bidi communication and provides an interface for applications to access use and or update data for the printer. The USB bidi extender may do so in accordance with a bidi extension schema that establishes a hierarchy of device attributes e.g. values actions queries that may be passed between and or employed by a USB device and a computing device . The bidi extension schema defines the different attributes as well as extension files and request response formats used to implement bidi communication.

In one approach the USB bidi extender is configured to detect and interpret various extension files that may be included within device drivers . When a hardware developer includes the extension files in the driver for a device the USB bidi extender knows to set up the device for bidi communication over USB. Generally speaking the extension files are configured to provide a list of supported bidi attributes e.g. values actions queries device configuration and capability information and information describing how to make calls into a corresponding device to access status and configuration data through the attributes.

Accordingly to take advantage of the bidi communication functionality provided by the USB bidi extender a developer may incorporate one or more extension files defined by the schema as part of a device driver. Using formats defined by the schema the developer creates compatible extension files that are used by the USB bidi extender to set up a corresponding device.

Extension files employed to enable USB bidi extension techniques may be configured in any suitable way. To simplify development the USB bidi extender may be configured to support extension files written using script based programming languages. Examples of suitable scripting languages that can be used to implement extension files include but are not limited to JavaScript European Computer Manufacturer s Association ECMA Script Extensible Markup Language XML or other markup language script and Asynchronous JavaScript and XML AJAX . Using scripting languages instead of binary code allows developers to quickly and cheaply create USB device drivers that are compatible with bidi communication. In addition the script based extension files provide a processor architecture independent way to access and define configuration status data. Thus development of custom binary code and independent binaries for different platforms may be avoided.

By way of example the printer driver of is illustrated as including a bidi extension file and a script extension file . In this example the bidi extension file represents a list describing the types of attributes that are supported by the corresponding printer. In some embodiments the bidi extension file is be configured as an XML file that encodes a list of supported attributes. The script extension file represents a script based file configured to describe various functionality and capabilities of a device and to define entry points used to call into the device. The entry points may include functions that can be executed to obtain appropriate data from a device. In one particular example the script extension file is implemented using JavaScript.

The USB bidi extender can detect and use the bidi extension file and script extension file to initialize bidi communication for the USB printer . In general initialization of bidi communication for a USB device involves creating a table or database of attributes that can be queried e.g. supported attributes and loading script from the extension files that can be executed via the USB bidi extender to obtain current values for the attributes. In the example of the USB bidi extender includes or otherwise makes use of bidi schema objects that represent a table of attributes created using the bidi extension file . A table for the USB printer may be constructed for example by parsing an XML attribute list encoded in the bidi extension file . In addition the USB bidi extender includes or otherwise makes use of script host objects that represent host objects to which the script extension file can be loaded for execution by the USB bidi extender . Further the USB bidi extender may create port access objects to facilitate communication with a device via an appropriate port. Generally the port access objects are created on demand and provide an interface between the port monitor and script based code employed by the USB bidi extender . Additional details regarding operation of a USB bidi extender and other aspects of techniques for USB bidi extension are discussed in relation to the following example procedures.

Procedures are now described for USB bidi extension that may be implemented using the previously described systems and devices. The procedures are shown as sets of blocks that are not necessarily limited to the particular order shown. The procedures can be performed in connection with any suitable hardware software firmware or combination thereof. In at least some embodiments the procedures can be performed by a suitably configured computing device such as the ones described above. In addition or alternatively the procedures may be implemented through an operating system interface such as the USB bidi extender described herein.

Requests from applications for status and configuration data for the USB connected devices are handled through the operating system interface block and requested status and configuration data is returned to the applications in response to the requests block . For instance the USB bidi extender can receive and process requests from applications . The USB bidi extender can format and submit queries to USB connected devices on behalf of the applications . Data obtained in response to the queries may be translated by the USB bidi extender into an appropriate format for the applications and returned back to the applications . In this manner values for different supported bidi attributes can be manipulated through a suitably configured USB bidi extender that operates to set up bidi communications with USB devices.

A driver for the device is examined to determine whether the driver includes extension files to support bidi communication block and based on the examination a decision is made as to whether the driver supports bidi block . For example the USB bidi extender is operable to detect and process various extension files in a driver. Inclusion of appropriate extension files such as the example bidi extension file and or script extension file is indicative of support for bidi communication.

If bidi is not supported then the USB bidi extender and or port monitor may configure the USB port without support for bidi block . In this case the corresponding device will be unable to provide status and configuration data through the USB bidi framework described herein.

On the other hand if bidi is supported then the USB bidi extender and or port monitor may configure the USB port to enable bidi communication block . This occurs using the extension files that are detected within the driver to set up the port assigned to the device for bidi communication. The corresponding device will then be able to provide status and configuration data through the USB bidi framework.

In one approach the USB bidi extender creates script based objects representing the port device to implement bidi communication for the device. In general the script based objects operate as an interface to handle corresponding script based requests communication and data for bidi interaction between a computing device and a USB device . Moreover the objects are used to execute script and act as an intermediary between applications the operating system and USB devices. This may involve translating commands and data back and forth between script based formats native operating system formats and formats understandable by different applications and devices. As mentioned the USB bidi framework may employ JavaScript or other suitable scripting languages to initialize USB ports and corresponding devices for bidi communication. Some example details regarding operations that may be employed to configure a port device per block may be found in the following discussion of .

In particular depicts a flow diagram that describes a procedure showing example operations to configure a port for bidi communication in accordance with one or more embodiments. In at least some embodiments the example procedure is performed by a USB bidi extender as described herein. To do so the bidi extender may reference and make use of XML and or JavaScript extension files that are incorporated with a driver for a compatible USB device. A bidi port object is created for a device block . For instance a port monitor may be configured to generate a bidi port object for each port device combination managed by the port monitor .

For example the USB bidi extender can search a driver for a device to discover extension files as previously discussed. If one or more extension files are present the device supports USB bidi communications and the USB bidi extender creates a corresponding bidi port object for the device. The bidi port object is configured to manage polling of schema values for ports devices that support queries for the values. The bidi port object can contain a list of extended schema values supported by the device as defined in a bidi extension file and a link to a script extension file having script executable to poll for the schema values. Thus the bidi port object acts as an abstraction of the port that applications and other entities can invoke interact with to gain access to the corresponding port device.

A script host object for the device is created block and a script extension file is loaded that describes bidi entry points for the device block . For instance the bidi port object may create a script host object for the particular port device. More generally a different script host object is created for each port device combination. The script host object provides an execution environment for corresponding script. Thus a script extension file may be loaded from the device driver to the script host object where it is hosted . When invoked the JavaScript or other script loaded to the script host object is configured to handle processing to call appropriate entry points e.g. functions APIs executable code to get set or otherwise manipulate particular schema values.

A query is made to obtain a list of supported bidi attributes block and schema objects are produced for the supported bidi attributes block . For instance a bidi extension file contained in a driver may be processed in any suitable way to obtain the list of supported bidi attributes including supported schema values actions and queries. The bidi attributes represent different configuration and status data for a device that may be obtained and or manipulated using the techniques discussed herein as well as actions queries that can be performed on the configuration and status data. In one approach JavaScript loaded into the script host object operates to call an appropriate function or other suitable entry point to get a list of bidi attributes supported by a device as defined in the bidi extension file . In some cases an XML based list is returned though interaction with the bidi extension file which can be used to construct an array of schema objects.

The USB bidi extender can then process through the XML based list to create schema objects for each supported attribute. The result is a table or database of schema objects representing bidi attributes supported by a device. Pre processing to create the table or database in this manner may be employed to avoid on demand processing for each request. Additionally a cached list of supported attributes enables the USB bidi extender and or applications to quickly discover the supported attributes. The schema objects also provide parameters used to set obtain cache or otherwise manipulate values for the configuration and status data.

At this point the bidi port object created per block is configured to support bidi schema actions queries to manipulate the configuration and status data for a device including getting and or setting of schema values through the created schema objects. Applications can request such data through a USB bidi extender configured to handle bidi requests for USB devices as previously described. Example techniques to access and make use of the example USB bidi extender and schema objects just described can be found in relation to the following example procedure.

In particular depicts a flow diagram that describes a procedure showing example operations for bidi communications with a USB connected device. A request is obtained from an application for configuration status data from a USB connected device block . For example an application may call into the USB bidi extender to initiate processing to obtain values for selected schema objects. In at least some embodiments the call is configured as an API call made to an API exposed by the USB bidi extender . Additionally or alternatively the USB bidi extender may be configured to periodically poll connected devices to obtain updates to configuration status data. The USB bidi extender may then automatically provide notifications of the polled data back to applications that register to receive updates for a particular device. The polling and notifications can occur without initiation by an application. Thus updates to configuration status data can be initiated in response to explicit requests and or through periodic polling conducted automatically by the USB bidi extender .

In response to a request and or when configuration status data is otherwise to be provided to an application a determination is made regarding whether cached schema data is available block . If data is cached the cached schema data is returned to the application block . Here the USB bidi extender first checks to see if current values for requested data are available. For instance values may have been recently cached in connection with another request or based on polling by the USB bidi extender . If current values are available the USB bidi extender may return the values right away so that the application does not have to wait for processing to update the data. The USB bidi extender may then proceed to update the configuration status data to ensure that values provided to application have not changed.

Thus as shown in the framework may proceed to update cached data or obtain new data if data was unavailable per block . To do so a bidi schema query is formatted based on the request as defined by a device specific script extension file block . For example the table or database of schema objects e.g. XML list of supported attributes can be used to determine which values are to be updated for a given request or polling operation. The script host object includes script that can be invoked to call into the appropriate functions or other suitable entry points of a device to obtain current values for selected bidi schema objects.

Accordingly The USB bidi extender can operate to call into script that is loaded to a script host object with selected bidi schema objects and also with a port access object used to communicate with the device in a native way. In other words the port access object may translate between the script based commands operations implemented by the script host object and communication formats used by the port monitor operating system and or USB devices . In this way the device can be queried to obtain updated schema object values for configuration status data block .

Using updated values that are returned in response to the query a determination is made as to any changes in the schema object values block . If values have changed the application may be notified of the changes block . This involves returning the updated values back to the requesting application. Otherwise the current schema object values are cached block and may be used to handle subsequent requests.

For example a combination of requests on demand by applications and or periodic polling by the USB bidi extender can be employed to obtain updated configuration status data for USB devices over a USB connection . In at least some embodiments cached data if available can be returned to a requester first to reduce dwell time. Then the USB bidi extension framework can update data in the background and provide notifications of any changes to the application. Notifications may also be provided to applications that register for configuration status notifications for a particular USB device whenever corresponding data is polled or updated. Additionally any changes to the data determined through an update can be cached so that the most current data is available quickly from the USB bidi extension framework. The data is cached by updating values associated with corresponding bidi schema objects to reflect the most current values.

Having described some example details regarding USB bidi extension techniques consider now a discussion of an example system to implement the described techniques in accordance with one or more embodiments.

The example computing device includes one or more processors or processing units one or more computer readable media which may include one or more memory and or storage components one or more input output I O interfaces for input output I O devices and a bus that allows the various components and devices to communicate one to another. Computer readable media and or one or more I O devices may be included as part of or alternatively may be coupled to the computing device . The bus represents one or more of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. The bus may include wired and or wireless buses.

The one or more processors are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example processors may be comprised of semiconductor s and or transistors e.g. electronic integrated circuits ICs . In such a context processor executable instructions may be electronically executable instructions. The memory storage component represents memory storage capacity associated with one or more computer readable media. The memory storage component may include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . The memory storage component may include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

Input output interface s allow a user to enter commands and information to computing device and also allow information to be presented to the user and or other components or devices using various input output devices. Examples of input devices include a keyboard a touchscreen display a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software hardware fixed logic circuitry or program modules. Generally such modules include routines programs objects elements components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. The computer readable media may include a variety of available medium or media that may be accessed by a computing device. By way of example and not limitation computer readable media may include computer readable storage media and communication media. 

 Computer readable storage media may refer to media and or devices that enable persistent and or non transitory storage of information in contrast to mere signal transmission carrier waves or signals per se. Thus computer readable storage media refers to non signal bearing media. Computer readable storage media also includes hardware elements having instructions modules and or fixed device logic implemented in a hardware form that may be employed in some embodiments to implement aspects of the described techniques.

The computer readable storage media includes volatile and non volatile removable and non removable media and or storage devices implemented in a method or technology suitable for storage of information such as computer readable instructions data structures program modules logic elements circuits or other data. Examples of computer readable storage media may include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage hard disks magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices hardware elements e.g. fixed logic of an integrated circuit or chip or other storage device tangible media or article of manufacture suitable to store the desired information and which may be accessed by a computer.

 Communication media may refer to a signal bearing medium that is configured to transmit instructions to the hardware of the computing device such as via a network. Communication media typically may embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier waves data signals or other transport mechanism. Communication media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

Combinations of any of the above are also included within the scope of computer readable media. Accordingly software hardware or program modules including the USB bidi extender device drivers port monitor operating system applications and other program modules may be implemented as one or more instructions and or logic embodied on some form of computer readable media.

Accordingly particular modules functionality components and techniques described herein may be implemented in software hardware firmware and or combinations thereof. The computing device may be configured to implement particular instructions and or functions corresponding to the software and or hardware modules implemented on computer readable media. The instructions and or functions may be executable operable by one or more articles of manufacture for example one or more computing devices and or processors to implement techniques for USB bidi extension as well as other techniques. Such techniques include but are not limited to the example procedures described herein. Thus computer readable media may be configured to store or otherwise provide instructions that when executed by one or more devices described herein cause various techniques for USB bidi extension.

In accordance with the foregoing detailed description an interface may be provided to enable bidirectional communication with USB connected devices. The interface may be configured as a USB bidi extender that is incorporated as an operating system component and designed to support bidi communications for USB devices. The USB bidi extender supports and employs extension files defined using script based programming to set up USB devices for bidi communications. Applications may then invoke the USB bidi extender to request data for a device set values for device specific data and or register to receive change notifications regarding the data.

Although the embodiments have been described in language specific to structural features and or methodological acts it is to be understood that the embodiments defined in the appended claims are not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as example forms of implementing the claimed embodiments.

