---

title: System and method of a hardware shadow for a network element
abstract: A method and apparatus of a device that uses a hardware shadow for a central processing unit failover is described. In an exemplary embodiment, a device receives a signal that the active central processing unit has failed, where the active central processing unit controls the processing functions of the network element and the network element includes a hardware forwarding engine and a hardware shadow. The hardware shadow additionally includes multiple shadow tables. For each shadow table, the device copies data from that shadow table to a corresponding table in the hardware forwarding engine, where the hardware shadow is a copy of the data stored in hardware tables for the hardware forwarding engine. In response to the copying, the device further switches control of the network element processing functions from the active central processing unit to a standby central processing unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09594612&OS=09594612&RS=09594612
owner: Arista Networks, Inc.
number: 09594612
owner_city: Santa Clara
owner_country: US
publication_date: 20140505
---
Applicant claims the benefit of priority of prior provisional application Ser. No. 61 841 190 filed Jun. 28 2013 the entirety of which is incorporated by reference.

This invention relates generally to data networking and more particularly to using a hardware shadow to support a failover from an active central processing unit to a standby central processing unit.

A network element can include two different planes that are used to process network traffic a control plane and a data plane. The data plane receives processes and forwards network traffic using various configuration data e.g. forwarding security quality of service QoS and other network traffic processing information . For example for each received packet of the network traffic the data plane determines a destination address of that packet looks up the requisite information for that destination in one or more tables stored in the data plane and forwards the packet out the proper outgoing interface. The control plane controls these processing functions of the data plane by configuring the data plane managing data collected by the data plane monitoring the data plane and other management functions. The control plane gathers the configuration data from different sources e.g. locally stored configuration data via a command line interface or other management channel such as Simple Network Management Protocol SNMP and configures the data plane using this configuration data.

In addition the control plane will include multiple central processing units CPUs to control the processing functions of the network element. There can be an active CPU that is actively controlling the processing functions of the network element and a standby CPU that takes over control of the network element processing in the event of a CPU failure of the active CPU. The active CPU could fail due to a hardware failure of the CPU itself or a component that the active CPU uses e.g. memory controller bus or another hardware component . Alternatively the active CPU may fail due to a software failure.

In the event of the active CPU failure the standby CPU takes over the control of the network element processing functions. In this case the data plane can continue to operate while the standby CPU takes control. In order for the standby CPU to assume control of the network element processing functions the standby CPU of the control plane will need access to the hardware tables of the data plane. The control plane uses these hardware tables to configure the data plane monitor the data plane gather statistics of the data plane and other functions. In order to access the hardware tables the standby CPU builds a software index that allows the standby CPU to access the data in the hardware tables. The standby CPU can either build the software index from scratch upon a CPU failure or can actively build and maintain the software index prior to the CPU failure. Building the software index from scratch can take a long time and interrupt the ability of the control plane to function. Building and maintaining the software index prior to the CPU failure can remove this control plane downtime however building and maintaining a standby software index can be a complicated process that is difficult to implement and can lead to version problems because the active software index has one version or structure and the standby software index has another version or structure.

A method and apparatus of a device that uses a hardware shadow for a central processing unit failover is described. In an exemplary embodiment a device receives a signal that the active central processing unit has failed where the active central processing unit controls the processing functions of the network element and the network element includes a hardware forwarding engine and a hardware shadow. The hardware shadow includes multiple shadow tables. For each shadow table the device copies data from that shadow table to a corresponding hardware table in the hardware forwarding engine where the hardware shadow is a copy of the data stored in hardware tables for the hardware forwarding engine. In response to the copying the device further switches control of the network element processing functions from the active central processing unit to a standby central processing unit.

In another embodiment the device receives a hardware shadow update where the hardware shadow is used as part of passing control of processing functions of the network element from an active central processing unit to a standby central processing unit in response to a failure occurring with the active central processing unit. In addition the hardware shadow includes configuration data for one of a plurality of hardware forwarding engines of the network element. Furthermore the hardware shadow update is an update to one of a plurality of shadow tables of the hardware shadow. The device further applies the update to the hardware shadow for the one of the plurality of hardware shadow tables.

In a further embodiment the device receives a signal that the active central processing unit has failed where the active central processing unit controls the processing functions of the network element and the network element includes a hardware forwarding engine. In addition the network element includes a hardware shadow and a partial software index for a standby central processing unit. Furthermore for each hardware table in the plurality of hardware tables referenced by the partial software index the device switches control to the standby central processing unit of a processing function of the network element that utilizes data stored in that hardware table. In addition for each shadow table in a plurality of shadow tables in the hardware shadow the device copies data from that shadow table to a corresponding table in the hardware forwarding engine where the hardware shadow is a copy of the data stored in a plurality of hardware tables for the hardware forwarding engine and is data not referenced by the partial software index. Furthermore and in response to the copying the device switches control to the standby central processing unit of a processing function of the network element that utilizes data associated with that shadow table.

In another embodiment the device receives an update where the update is an update for one of a hardware shadow and a partial software index. In addition the hardware shadow is used to failover control of processing functions of the network element from an active central processing unit to a standby central processing unit the hardware shadow includes configuration data for one of a plurality of hardware forwarding engines of the network element and the partial software index references data stored in a plurality of hardware tables and not stored in the hardware shadow. Furthermore the device determines if the update is for the hardware shadow or the partial software index. If the update is for the hardware shadow the device applies the update to one of the plurality of hardware shadow tables of the hardware shadow. If the update is for the partial software index the device applies the update to the partial software index.

A method and apparatus of a device that uses a hardware shadow for a central processing unit failover is described. In the following description numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known components structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

In the following description and claims the terms coupled and connected along with their derivatives may be used. It should be understood that these terms are not intended as synonyms for each other. Coupled is used to indicate that two or more elements which may or may not be in direct physical or electrical contact with each other co operate or interact with each other. Connected is used to indicate the establishment of communication between two or more elements that are coupled with each other.

The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software such as is run on a general purpose computer system or a dedicated machine or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in different order. Moreover some operations may be performed in parallel rather than sequentially.

The terms server client and device are intended to refer generally to data processing systems rather than specifically to a particular form factor for the server client and or device.

A method and apparatus of a device that uses a hardware shadow for a CPU failover is described. In one embodiment a device includes a control plane and a data plane. The data plane receives processes and forwards network data using various configuration data while the control plane controls the processing functions of the data plane and other processing functions of the network element. In one embodiment the data plane includes one or more hardware forwarding engines that are used to process the network data received and transmitted by the network element. Each of these hardware forwarding engines includes one or more hardware tables that are used to store the configuration data for the hardware forwarding engines gather monitoring data about that hardware forwarding engine and store other information for the hardware forwarding engine. In one embodiment the control plane includes two CPUs an active CPU to control the network element processing functions and a standby CPU to take over this control in the event that the active CPU fails. While the active CPU is functioning the active CPU sends updates to the standby CPU regarding the hardware tables for the hardware forwarding engines. The standby CPU uses these updates to build and maintain a hardware shadow of the data that is stored in the hardware tables.

In one embodiment the hardware shadow is a copy of the data values stored in the hardware tables but does not necessarily need to be in the same structure as the data stored in the hardware tables. In one embodiment the hardware shadow includes one or more tables that are copies of the tables in the hardware tables. For example and in one embodiment the hardware shadow can include a routing table a media access control MAC address table an access control list ACL and or other tables. In addition the standby CPU builds and maintains a software index for that hardware shadow which allows the standby CPU to access the data in the hardware table. Upon failure of the active CPU the standby CPU copies the data in hardware shadow to the hardware tables and uses the standby software index to access the data in the hardware tables.

In one embodiment the hardware forwarding engines continue to process network data during the data copying from the hardware shadow to the hardware tables. In order to maintain a consistent state for processing functions that use one of the tables during the data copying the standby CPU inserts a safe rule into a hardware table that is to be updated with data from the hardware shadow. In one embodiment the safe rule puts this processing function in a consistent state during the time when the data is copied over from the hardware shadow table to the corresponding table in the hardware table. For example and in one embodiment the safe rule can be a rule to drop all packets processed during this time period. The safe rule is removed by the time the data copying for that hardware table is completed. In another embodiment co processors are used to speed up the data copying. In another embodiment a safe rule is not used. Instead the hardware tables are updated in a safe order that allows a consistent state to be maintained while the tables are being updated.

In one embodiment a hybrid approach is used to support a CPU failover. In this embodiment the standby CPU maintains a partial software index for some of the data stored in the hardware tables and uses a hardware shadow for the rest of the data stored in the hardware tables. For example and in one embodiment the standby CPU builds and maintains a partial software index for one or more of the large hardware tables e.g. routing table MAC address table ACL and or other large tables and uses the hardware shadow for other tables in the hardware. Upon a CPU failover the standby CPU uses the partial software index to directly access the data for these tables referenced by the partial software index. In addition the standby CPU copies the data in the hardware shadow to the hardware tables and uses the standby software index to access the data in the hardware tables.

In one embodiment the control plane gathers the management data from different sources e.g. locally stored configuration data via a command line interface or other management channel e.g. SNMP Simple Object Access Protocol SOAP Representational State Transfer type Application Programming Interface RESTful API Hypertext Transfer Protocol HTTP HTTP over Secure Sockets layer HTTPs Network Configuration Protocol NetConf Secure Shell SSH and or another management protocol and writes this configuration data to hardware table s . In one embodiment the control plane includes an active central processing unit CPU A a standby CPU B an active software index A and a standby software index B. In one embodiment the active CPU A is a CPU that is used to control the processing functions of the network element . For example and in one embodiment the active CPU A controls the configuration of the hardware forwarding engine s retrieves the stored monitoring data retrieves stored statistics retrieves stored activity bits and retrieves current status of the hardware forwarding engines e.g. link status interrupts error indication and or retrieves learned mac addresses . In one embodiment the active CPU A uses the active software index A to access the hardware table s in one of the hardware forwarding engine s . In one embodiment the active software index A is a set of tables that is used by the active CPU A to reference each individual table in the hardware tables . For example and in one embodiment the active software index A includes pointers offsets and or other references that the active CPU A uses to access the data stored in the hardware table s .

In one embodiment the active CPU A can fail. For example and in one embodiment the active CPU A can fail due to a hardware problem in the CPU itself or in a hardware component the active CPU A uses e.g. memory bus or other hardware component . Alternatively the active CPU A can fail due to a software problem. In the case of failure the standby CPU B takes over control of the network processing. During failover the hardware forwarding engines continue to process network data while the control of the network processing is switched over from the active CPU A to the standby CPU B. In one embodiment the standby CPU B maintains a standby software index B that the standby CPU B uses in case of a CPU failover. Similar to the active software index A the standby software index B can be a set of tables that is used by the standby CPU B to reference each individual table in the hardware table s . For example and in one embodiment the standby software index B includes pointers offsets and or other references that the standby CPU B uses to access the data stored in the hardware table s . In this embodiment the standby software index B is an exact copy of the active software index A both in terms of the data stored in the index and the structure of the index. In one embodiment the active CPU A sends state updates for the standby software index B to the standby CPU B. The standby CPU B uses these state updates to update the standby software index B. Upon a failure of the active CPU A the standby CPU B assumes control of the network element processing functions by using the standby software index B to access the hardware table s of the hardware forwarding engine s .

In one embodiment where the two indices A B are exact copies it is difficult to maintain the standby software index B. For example and in one embodiment maintaining the standby software index B is complex and prone to software errors. In addition there are problems because if the version of software on the standby is different from the version of software on the active the standby software index B may be expected to take a different form than the active software index.

In one embodiment the control plane includes an active central processing unit CPU A a standby CPU B an active software index A a shadow software index B and a hardware shadow . In one embodiment the active CPU A is a CPU that is used to control the processing functions of the network element . For example and in one embodiment the active CPU A controls the configuration of the hardware forwarding engines retrieves the stored monitoring data retrieves stored activity bits and retrieves current status of the hardware forwarding engines e.g. link status interrupts error indication and or retrieves learned mac addresses . In one embodiment the active CPU A uses the active software index A to access the hardware tables in one of the hardware forwarding engine s . In one embodiment the active software index A is a set of tables that is used by the active CPU A to reference each individual table in the hardware tables . For example and in one embodiment the active software index A includes pointers offsets and or other references that the active CPU A uses to access the data stored in the hardware table s .

In one embodiment the hardware shadow is a copy of the data stored in the hardware tables . For example and in one embodiment the hardware shadow includes tables such as a routing table a MAC table ACL and other tables that are found in the hardware tables . In one embodiment the hardware shadow is a representation of the data stored in the hardware tables . In this embodiment the hardware shadow does not need to have the same order as the hardware tables but has the same data. For example and in one embodiment the routing table entries in the hardware shadow are a permutation of the data of the routing table that is in the hardware tables . That is in this example the entries are the same but the ordering of the entries in the tables is different. In another embodiment the entries in the hardware shadow are neither in the same format nor in the same order as the entries in the hardware but correlate with the entries in the hardware table. That is given an entry read from the hardware one can check if it is present in the hardware shadow and vice versa.

In one embodiment the control plane also includes a shadow software index B. In this embodiment the standby CPU B uses the shadow software index B to access the data in the hardware shadow . For example and in one embodiment the shadow software index B includes pointers offsets and or other references that the standby CPU B uses to access the data stored in the hardware shadow . Because the hardware shadow is not an exact copy of the hardware table s the shadow software index B is different from the active software index A. In one embodiment the active CPU A sends state updates for the hardware shadow to the standby CPU B. In this embodiment the state updates include updates to the data stored in the hardware table s . In one embodiment the software index messages passed from the active CPU A to standby CPU B are state update messages instructing the standby CPU B to update its management state without indicating specifically where in the hardware tables the corresponding forwarding engine state is to be placed. In one embodiment the standby CPU B uses the message contents to update its software index but not the hardware shadow. In this embodiment the hardware shadow is updated by separate hardware shadow update messages as described below for the corresponding table coming from the active CPU A. In another embodiment the standby CPU B uses the generic state message to update its software index and its hardware shadow using similar software as is run on the active CPU A. The difference is that with the standby CPU B the standby CPU B writes to the hardware shadow but not to the real hardware. In this embodiment the software index normally indicates precisely where and how a route MAC address or other hardware table entry is stored in the hardware.

For example and in one embodiment the updates sent by the active CPU A to the standby CPU B are generic state updates. In this example a generic state update describes the action taken for the update without specifying the location or format of the data modified or stored in a hardware table. A generic state update can be of the form of add route 1.2.3.0 24 with next hop ROUTER2 or delete route 3.4.5.6 32. These are high level updates that describe the action to be taken and are independent with how the data is represented in the hardware the data structures or the software storage format that is used to record them in the software index. Other examples of a generic state update can be insert MAC address 4.5.6 on port 33 in VLAN 99 or delete MAC address 4.5.6 in VLAN 99 . Thus the generic state updates are high level and without an indication of how the update is programmed in hardware or an assumption about how the state is translated to and stored in the software index of the standby CPU B. This has two key benefits. One this allows the software that manages the software index on the active CPU A and standby CPU B to be different. Two the exchange of state updates does not depend on how the standby updates its software index.

Alternatively the updates can be at a hardware shadow level. At this level an update would include the action to be taken and the location of the data in the hardware table. For example and in one embodiment the active CPU A would send updates to the standby CPU B such as put entry 1.2.3.0 24 pointing at ROUTER2 at index 6789 in the hardware routing table. Alternatively the shadow could be location independent saying put entry 1.2.3.0 24 at ROUTER2 into the hardware routing table . In this example the format is the same or close to the hardware representation. Because the format is the same or close the content and structure of the hardware shadow would not be that different between the active and standby even if they are running different software versions.

In one embodiment a useful aspect having the generic state and hardware shadow updates is that these two types of updates can be going on while the active CPU A is running. Upon a switchover a reconciliation takes place between a what is in the hardware shadow and the hardware a first reconciliation and b what is in the hardware shadow and what is in the software index a second reconciliation .

In one embodiment the first reconciliation simply pushes the hardware shadow to the hardware. This is a straight forward operation and can use bulk updates as described in below. The push of the shadow to the hardware can also use a coprocessor which enables the push to run in the background asynchronously from the main CPU. Furthermore if the hardware shadow on the standby CPU B closely tracks what is actually in the hardware then little if any changes will be made to the state in the hardware forwarding engine tables. It is possible that updates can be lost if made to the hardware before the active CPU A crashed and prior to the update being applied to the hardware shadow on the standby CPU B. This can be minimized by making sure that the active CPU A sends frequent updates to the standby CPU B.

In an alternative embodiment the updates at the hardware shadow can be elided if at the point of a switchover from active CPU A to standby CPU B the standby CPU CPU B is willing to read the hardware of the hardware forwarding engine into the local hardware shadow. This alternative embodiment may be useful when reading the hardware is fast either because the tables are small or because the number of hardware forwarding engines managed by the system is small. If there are a large number of hardware forwarding engines managed by the active CPU A and or standby CPU B after switchover then it can be expensive to rebuild the hardware shadow after a switchover. In that case the shadow can greatly accelerate the takeover.

In another embodiment the second reconciliation is to check that each entry in the hardware is also in the software index and vice versa. In this embodiment this reconciliation is used to make sure that the software index is consistent with the hardware shadow as the software index may need to maintain data structures that record which hardware forwarding engine table entries are free and in use. The second reconciliation phase makes this state in the software index consistent with the state in the hardware shadow. This rebuilding of the software index is further described in below.

After the first reconciliation the hardware shadow is synchronized with the hardware. Thus in the second reconciliation standby CPU B does not have to read from the hardware and instead refers to the hardware shadow.

In a further embodiment of the hardware shadow updates described above the active supervisor can write directly into the hardware shadow of the standby supervisor over a shared bus. For example and in one embodiment the active CPU A and standby B may be connected with a point to point PCIe link in which the DRAM of the standby CPU B is directly addressable by the active CPU A. In addition other connections could be used or a reliable transport protocol e.g. transport control protocol TCP or stream control transport protocol SCTP running over IP over Ethernet could also carry the updates to the shadow from active to standby .

At block process updates the hardware shadow. In one embodiment process determines which table the update is for and updates that table accordingly. For example and in one embodiment if process receives an update to add an entry to a routing table process determines which routing table is to be updated and adds that entry to that routing table. In this embodiment because the data in the hardware shadow table does not have to have the same structure or order as the corresponding table in the hardware table s process can update this entry in the same or different structure. In one embodiment the hardware shadow has the same or similar order as the data in the corresponding table of the hardware tables process can update this entry using the structural information in the update. For example and in one embodiment for an update that is put entry 1.2.3.0 24 with next hop ROUTER2 at index 6789 in the hardware routing table process would put the entry in the shadow of the hardware routing table at index 6789 but not in the actual hardware table .

In another embodiment if the update were to delete an entry process locates the entry for that table in the hardware shadow. Once the entry was located process deletes the entry and updates the hardware table accordingly. For example and in one embodiment process deletes this entry leaving an empty space in that table. In another example process could delete that entry and compact the table so that there are no empty entries in that table. In a further example of an embodiment if the update is to modify an existing entry process would find that entry in the corresponding table and modify the entry accordingly. As a further example the update can be a modification to a MAC address port association. For example the MAC address may have switched ports from Port 1 to Port 2. In this example process updates the port association for that MAC address in the MAC address table accordingly in hardware shadow.

Process updates the shadow software index of block . An update to the hardware shadow does not need to update the shadow software index e.g. this can be delayed until second reconciliation time . In one embodiment the update to the software index could be done earlier in order to reduce the amount of work done in the second reconciliation phase. In this embodiment the software index is updated to record what high level entry is at what location in the hardware table. In this embodiment the shadow can be the inverse of information in the software index. The shadow will say that entry 6789 of Table T contains hardware bits 0x0102030018. The software index is updated by inverting the hardware shadow and translating the hardware bits 0x0102030018 into some meaningful high level state e.g. the route 1.2.3.0 24 . Furthermore to show how the software index is updated in response to a shadow update when a shadow update indicates that table entry 6789 stores hardware route 1.2.3.0 24 then the software index is updated to associate 1.2.3.0 24 with table entry 6789.

At block process copies data from the hardware shadow table to the corresponding hardware table in the hardware forwarding engine. In one embodiment the copying can be done using a coprocessor associated with that hardware forwarding engine. In this embodiment the coprocessor does bulk data copying which can be faster than element by element copy using a CPU. In one embodiment the coprocessor copies the data by accessing the data from the DRAM memory in the network element where the hardware shadow table is stored. In this embodiment the coprocessor uses a peripheral component interface PCI bus to copy the data over to the hardware tables. In another embodiment process copies the data in bulk by the coprocessor asynchronously so as to allow the standby CPU to perform other processing tasks while the copying from shadow to hardware is taking place. In one embodiment the safe rule for the target hardware table is overwritten by the time the data copying is completed. The processing loop ends at block .

At block upon completion of the data copying in the processing loop above process signals that the standby CPU is the new active CPU and has assumed control of the processing functions for the network element. At block process rebuilds the software index for the standby CPU. In one embodiment this is the second reconciliation described above. In one embodiment the software index for the standby CPU is the shadow software index that the standby CPU built and maintained prior to the CPU failover. For example and in one embodiment process uses the shadow software index that was built and maintained as described in above.

As described above process can take advantage of a coprocessor to do bulk data copying from the shadow hardware table to the hardware tables in the hardware forwarding engine. In this embodiment the coprocessor accelerates data copying. is a block diagram of one embodiment of a network element configured to use a co processor for bulk updating of hardware table s from a hardware shadow. As in in the network element includes a data plane and a control plane . In addition the control plane includes an active CPU A active software index A standby CPU B shadow software index B and hardware shadow . In one embodiment the active software index A standby CPU B shadow software index B and hardware shadow are stored in memory . Memory can be DRAM type memory or another type of memory. In addition in the active CPU A has failed resulting in a CPU failure signal being sent to the standby CPU B. In one embodiment the standby CPU B receives this signal and begins the process of assuming control of the network element processing functions. In this embodiment during the failover the hardware forwarding engines continue to process network data. In one embodiment because the data in the hardware shadow has a different order than the data stored in the hardware table s the data from the hardware shadow is copied using co processor s to the hardware table s . In one embodiment the data is copied using bulk data transfers with co processor s using a PCI bus that interconnects the co processor s with the memory . In this embodiment using the bulk data transfers speed up the process of copying the data from the hardware shadow table to the hardware table s and lessens the time in which the hardware table s is being updated.

In one embodiment the hardware shadow table includes a copy of the data stored in the hardware table s . However the data in hardware shadow table is not necessarily in the same order as the data stored in a corresponding hardware table. is a block diagram of one embodiment of a hardware table and a corresponding hardware shadow table . In the hardware table has the entries A C in the order of entry A entry B and entry C. In contrast hardware shadow table is a permutation of the entries because the hardware shadow table has the same entries but in a different order. For example and in one embodiment the hardware shadow table has the entries A C in the order of entry C entry B and entry A.

As per above the entry order of the data in the hardware shadow tables may not be the same as the entry order in a corresponding table in the hardware tables. For example and in one embodiment if the active CPU A was sending high level updates to the standby CPU B to update the software index of the standby CPU B but it is not sending the hardware shadow updates. In this example the standby CPU B in this case is building its local hardware shadow using its own software which may be a different version than that which is running on the active and as a result the shadow that it built locally is different from the way the tables were programmed by the active CPU B.

Consequently during the copying of the data to a hardware table the hardware table may have different entries and a processing function relying on this table may have undesired behavior during the time in which the hardware table is being copied. In order to alleviate the potentially undesired behavior a safe rule can be added to the target hardware table that leaves the hardware table in a consistent state during the data copying. is a block diagram of one embodiment of a hardware table being updated using a safe rule. In the hardware table includes a safe rule as the initial entry in the table. The next entry is an existing entry which is an entry that existed prior to the data copying. The final entry is a new entry . In one embodiment the safe rule is a rule that leaves the hardware in a consistent state such that the behavior of a processing function that uses this table is consistent during the data copying. For example and in one embodiment a safe rule could be a rule to drop all packets forward all packets to the CPU for software processing forwards the packets temporarily to a different hardware forwarding engine in the same system where that other hardware forwarding engine s tables are not being updated at the same time. Sending the packets to the CPU allows for slow but correct forwarding. Sending the packets to another hardware forwarding engine allows for correct forwarding with little performance drag but can be done by a network element with more than one hardware forwarding engine. While in one embodiment the safe rule is illustrated as an entry in the hardware table in alternate embodiments the safe rule can be in another type of data structure e.g. a rule associated with that table but not stored in the table etc. . In one embodiment the safe rule is overwritten or otherwise removed upon completion of the data copying for that hardware table . In another embodiment instead of using a safe rule the hardware tables are updated in a safe order that allows for a consistent state to be maintained while the table is being updated.

In one embodiment the hardware shadow does not store the data in the same order as the data in the hardware tables the hardware shadow data is copied over to the hardware table upon a CPU failover. This copying of the hardware shadow data can take some time to update the hardware tables. In order to alleviate the copying time a hybrid hardware shadow scheme can be employed. In one embodiment the hardware tables can include a few large tables e.g. routing table MAC address table and or ACL and many smaller other tables. In this embodiment a standby software index is built for the one or more large tables and a reconciliation at failover time is done in which entries in the software index are associated with their corresponding location s in hardware. This is done by examining the contents of the hardware shadow and using this state to update pointers in the software index. In this embodiment the hardware shadow is maintained on the standby by the process and update messages that are described in above.

In this embodiment associating the hardware entries with entries in the software index may also be wholly or partially performed before the switchover by monitoring updates to the hardware shadow. In one embodiment this is desirable in order to reduce the amount of work that is done at switchover time.

In an alternative embodiment the reconciliation can take place by reading the hardware to learn which entry is stored where in the hardware tables. This however is slow by comparison with reading the hardware shadow e.g. can be up to 100 1000 times slower . Thus there is an incentive to maintaining and reading from the hardware shadow rather than reading from the hardware.

In one embodiment using a partial software index eliminates some or all of the time spent copying the hardware shadow to hardware reduces or eliminates the need for a disruptive copy from shadow to hardware performed on a switchover which means no disruption in packet forwarding and the use of a safe rule is not needed . In addition using a hardware shadow in conjunction with the partial software index helps because this combination accelerates the reconciliation process that is done upon a switchover.

In one embodiment for the other hardware tables a hardware shadow is built and maintained by management software running on the standby and upon becoming active after a failover the newly active software initiates a copy to the hardware tables from the shadow software index. In this embodiment upon a CPU failover the standby partial software index is used for access to the one or more large tables in the hardware table and the other tables are updated with the data stored in the hardware shadow table.

In one embodiment the standby CPU B uses a hybrid approach for maintaining hardware table information. In this embodiment the standby CPU B builds and maintains a partial software index that the standby CPU B will use to access one or some of the tables in the hardware table s . For example and in one embodiment the standby CPU B builds and maintains a partial software index for one or more of the large tables in the hardware table s e.g. routing table MAC address table ACL etc. . In one embodiment the partial software index is a software index like the standby software index of above but is used for some of the hardware table s and not all of these tables. In one embodiment and in addition to the partial software index the standby CPU B builds and maintains a hardware shadow that is used to keep a copy of the data in the hardware table s that are not referenced by the partial software index . In this embodiment upon a CPU failover the standby CPU B uses the partial software index to access the data in the hardware table s that are referenced by the partial software index and uses the hardware shadow to update the data in the hardware table s that are not referenced by the partial software index. In one embodiment the hardware shadow is used to reconcile with the partial software index upon the standby CPU B becoming active. The reconciliation is done to make sure that the partial software index properly records where in the hardware any given entry is stored. In one embodiment the standby CPU B can use a safe rule during the data copying as described above. In one embodiment the standby CPU B includes a hybrid hardware shadow update module that updates the hardware shadow and partial software index.

In response to the active CPU failure an active CPU failure signal is sent to the standby CPU B. In one embodiment the standby CPU B receives this signal and begins the process of assuming control of the network element processing functions. In this embodiment during the failover the hardware forwarding engines continue to process network data. In one embodiment because the data in the hardware shadow has a different order than the data stored in the hardware table s the data from the hardware shadow is copied to the corresponding hardware table s . In one embodiment the data is copied using bulk data transfers with co processors. In another embodiment the one or more of hardware table s are inserted with a safe rule that allows the processing functions associated with that hardware table to be in a consistent state during the copying of the data.

In one embodiment because the partial software index references data in one or more tables in the hardware table s the standby CPU B uses this partial software index to access the data in these tables in the hardware table s . For example and in one embodiment the partial software index may reference data in a routing table MAC address table and or ACL table. In one embodiment by using the partial software index for some and not all of the tables in the hardware table s the complexity of a full software index is reduced. In addition by using the partial software index for large hardware tables the data copying time is reduced for the tables supported by the hardware shadow . Handling of a failover with a partial software index is further descried in below. In one embodiment the standby CPU B includes a hybrid hardware shadow failover module that uses the hardware shadow and partial software index for CPU failover.

In another embodiment the update can be a management state update to the partial software index such as the partial software index described in above. In one embodiment the update can be Route 192.168.1.0 24 with destination ROUTER1 got added to the routing table. Or MAC M in VLAN V is now on port P .

At block process determines if the update is for the hardware shadow. If the update is not for the hardware shadow and for the partial software index execution proceeds to block below. If the update is for the hardware shadow process updates the hardware shadow at block . In one embodiment process determines which table the update is for and updates that table accordingly. In another embodiment if the update were to delete an entry process locates the entry for that table in the hardware shadow. Once the entry was located process deletes the entry and updates the hardware table accordingly. In a further example of an embodiment if the update is to modify an existing entry process would find that entry in the corresponding table and modify the entry accordingly. Process updates the shadow software index of block . In one embodiment the shadow software index is updated using generic state updates as described in above.

At block process updates the partial software index. In one embodiment process updates the partial software index to indicate the management state change e.g. insert delete or modify an entry .

Process performs a processing loop block block for each table in the hardware shadow to copy the data from that table in the hardware shadow to a corresponding table in the hardware tables. At block process sets a safe rule in the hardware table that corresponds to the table in the hardware shadow being operated on by process . In one embodiment process sets the safe rule for tables that could affect them and any processing function associated with that table. In one embodiment the safe rule puts the processing function in a consistent state during the time when the data is copied over from the hardware shadow table to the corresponding table in the hardware table. While in one embodiment a safe rule is added for each table in the hardware table that is receiving data from the hardware shadow tables in alternate embodiments the safe rule is added to one or some of the tables in the hardware tables during the copy of the data.

At block process copies data from the hardware shadow table to the corresponding hardware table in the hardware forwarding engine. In one embodiment the copying can be done using a coprocessor associated with that hardware forwarding engine. In this embodiment the coprocessor does bulk data copying which can be faster than element by element copy using a CPU. In one embodiment the coprocessor copies the data by accessing the data from the DRAM memory in the network element where the hardware shadow table is stored. In this embodiment the coprocessor uses a PCI bus to copy the data over to the hardware tables. In one embodiment the safe rule for the target hardware table is overwritten at the end of the data copying. The processing loop ends at block .

At block upon completion of the copying of the data in the processing loop above process signals that the standby CPU is the new active CPU and has assumed control of the processing functions for the network element. At block process rebuilds the software index for the standby CPU. In one embodiment the software index for the standby CPU is the shadow software index that the standby CPU built and maintained prior to the CPU failover. For example and in one embodiment process uses the shadow software index that was built and maintained as described in above.

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to a microprocessor s and a ROM Read Only Memory and volatile RAM and a non volatile memory . The microprocessor may retrieve the instructions from the memories and execute the instructions to perform operations described above. The bus interconnects these various components together and also interconnects these components and to a display controller and display device and to peripheral devices such as input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art. In one embodiment the system includes a plurality of network interfaces of the same or different type e.g. Ethernet copper interface Ethernet fiber interfaces wireless and or other types of network interfaces . In this embodiment the system can include a forwarding engine to forward network data received on one interface out another interface.

Typically the input output devices are coupled to the system through input output controllers . The volatile RAM Random Access Memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory.

The mass storage is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD ROM RAM or a flash memory or other types of memory systems which maintain data e.g. large amounts of data even after power is removed from the system. Typically the mass storage will also be a random access memory although this is not required. While shows that the mass storage is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem an Ethernet interface or a wireless network. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art.

Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine executable instructions that cause a machine that executes these instructions to perform certain functions. In this context a machine may be a machine that converts intermediate form or abstract instructions into processor specific instructions e.g. an abstract execution environment such as a process virtual machine e.g. a Java Virtual Machine an interpreter a Common Language Runtime a high level language virtual machine etc. and or electronic circuitry disposed on a semiconductor chip e.g. logic circuitry implemented with transistors designed to execute instructions such as a general purpose processor and or a special purpose processor. Processes taught by the discussion above may also be performed by in the alternative to a machine or in combination with a machine electronic circuitry designed to perform the processes or a portion thereof without the execution of program code.

The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be kept in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as receiving switching determining copying inserting signaling applying updating or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention.

