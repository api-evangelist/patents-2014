---

title: Utilizing special purpose elements to implement a FSM
abstract: Apparatus, systems, and methods for a compiler are described. One such compiler generates machine code corresponding to a set of elements including a general purpose element and a special purpose element. The compiler identifies a portion in an arrangement of relationally connected operators that corresponds to a special purpose element. The compiler also determines whether the portion meets a condition to be mapped to the special purpose element. The compiler also converts the arrangement into an automaton comprising a plurality of states, wherein the portion is converted using a special purpose state that corresponds to the special purpose element if the portion meets the condition. The compiler also converts the automaton into machine code. Additional apparatus, systems, and methods are disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471290&OS=09471290&RS=09471290
owner: Micron Technology, Inc.
number: 09471290
owner_city: Boise
owner_country: US
publication_date: 20140905
---
This patent application is a continuation of U.S. application Ser. No. 13 357 496 filed Jan. 24 2012 now issued as U.S. Pat. No. 8 843 911 which claims the benefit of priority under 35 U.S.C. Section 119 e to U.S. Provisional Patent Application Ser. No. 61 436 022 filed on Jan. 25 2011 all which are hereby incorporated by reference herein in their entirety.

A finite state machine FSM also referred to as a finite state automaton automaton or simply a state machine is a representation of states transitions between states and actions. A finite state machine can be used to design digital logic computer programs or images for a parallel machine. A finite state machine is a model of behavior composed of a finite number of states transitions between those states and outputs. A finite state machine can be represented as a graph where vertices of the graph correspond to states of the FSM and edges of the graph correspond to transitions between the states which occur due to one or more inputs to the finite state machine. Finite state machines can also have probabilistic transitions fuzzy states or other oddities. A finite state machine can function as a finite internal memory having an input feature and an optional output feature. Finite state machines having an output can be referred to as finite state transducers.

Applications of finite state machines include electronic design automation communication protocol design biology and artificial intelligence research and linguistics to describe the grammars of natural languages.

The following description and the drawings sufficiently illustrate specific embodiments to enable those skilled in the art to practice them. Other embodiments may incorporate structural logical electrical process and other changes. Portions and features of some embodiments may be included in or substituted for those of other embodiments. Embodiments set forth in the claims encompass all available equivalents of those claims.

This document describes among other things a compiler that converts source code into a machine code implementation of a finite state machine. The machine code can correspond to a target device in that the machine code is configured to implement the functions described by the source code on the target device. In an example the target device is a parallel machine and the machine code comprises an image for the parallel machine. In another example the target device comprises a computer having a Von Neumann architecture and the machine code comprises instructions for execution by a processor in the computer.

In any case the compiler can compile the source code into machine code that implements a finite state machine embodying the functions described by the source code. In the process of compiling the source code the compiler converts the source code into an automaton. Using the automaton the compiler can identify and combine redundancies in the source code in order to optimize the resultant finite state machine implemented by the machine code. Additionally the compiler can identify and map portions of the automaton to elements corresponding to the target device. When the target device is a parallel machine the elements can comprise hardware elements of the parallel machine. When the target device is a computer having a Von Nuemann architecture the elements can comprise instructions for execution by a processor. During the mapping certain portions of the finite state machine can be mapped to specific e.g. special purpose elements in order to for example improve the performance of the resultant machine code.

FSMs can be divided into two classes deterministic and non deterministic. A deterministic FSM has a single path of execution at a given time while a non deterministic FSM has multiple concurrent paths of execution. A non deterministic FSM with N states can typically be converted into a deterministic FSM with worst case 2 to the N states. This exponential state expansion from non deterministic to deterministic FSM however often makes the non deterministic FSM the most practical implementation with finite machine resources and time.

The FSM is an example of a deterministic FSM and this deterministic FSM may be a part of a larger non deterministic FSM. For example illustrates a non deterministic FSM of which the deterministic FSM makes up a portion. The FSM adds monitoring of a pipe pressure to the water level maintaining FSM . In FSM the pipe pressure is monitored while the pump is running and the pump is stopped if the pipe pressure is overloaded for a fixed period of time. In the FSM when the pipe pressure is overloaded while the pump is activated at state the FSM transitions to state where a timer is started. Additionally when the pipe is overloaded state transitions to itself to maintain the pump in the ON state. Accordingly at this position in the FSM both state the Pump ON state and state the Timer ON state are active concurrently. Since states and can be active concurrently multiple paths of execution are present and the FSM is accordingly non deterministic. From state the FSM transitions to state when the pressure in the pipe is no longer overloaded. Also the FSM transitions from both state and state to state to set the pump in the OFF state when the timer expires.

In an example the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings the source code can include a plurality of regular expressions regexes . A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains such as programming languages text editors network security and others. In an example the regular expressions supported by the compiler include search criteria for the search of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes printable and non printable within the data. In an example the compiler can support multiple different source code languages for implementing regexes including Perl e.g. Perl compatible regular expressions PCRE PHP Java and .NET languages.

Referring back to at block the compiler can parse the source code to form an arrangement of relationally connected operators. Parsing source code can create a generic representation of the source code. In an example the generic representation comprises an encoded representation of the regexes in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree also known as an abstract syntax tree in other examples however a concrete syntax tree or other arrangement can be used.

Since as mentioned above the compiler can support multiple languages of source code parsing converts the source code regardless of the language into a non language specific representation e.g. a syntax tree. Thus further processing blocks by the compiler can work from a common input structure regardless of the language of the source code.

The syntax tree includes a plurality of operators that are relationally connected. The syntax tree can include multiple different types of operators where different types of operators correspond to different functions implemented by the source code. That is different operators can correspond to different functions implemented by the regexes in the source code.

At block the syntax tree is converted into an automaton. An automaton comprises a software model of a FSM and can accordingly be classified as deterministic or non deterministic. A deterministic automaton has a single path of execution at a given time while a non deterministic automaton has multiple concurrent paths of execution. The automaton comprises a plurality of states. In order to convert the syntax tree into an automaton the operators and relationships between the operators in the syntax tree are converted into states with transitions between the states.

In an example the automaton comprises general purpose states and special purpose states. The general purpose states and special purpose states correspond to general purpose elements and special purpose elements supported by a target device for which the compiler is generating machine code. Different types of target devices can support different types of general purpose elements as well as one or more different types of special purpose elements. A general purpose element can typically be used to implement a broad range of functions while a special purpose element can typically be used to implement a more narrow range of functions. In an example however a special purpose element can achieve for example greater efficiency within its narrow range of applicability. Accordingly a special purpose element can be used to for example reduce the machine cycles or the machine resources required to implement certain functions in the target device. In some examples the target device supports solely special purpose elements wherein multiple different types of special purpose elements are supported.

The type of target device can largely control the type of elements that are supported by the target device. In one example the target device is a computer having a Von Nuemann architecture and the elements supported include an instruction set corresponding to a processor of the computer. The instruction set can include general purpose instructions such as add subtract read and write as well as specialized instructions such as multiple store and movement of large blocks of memory. In another example the target device is a parallel machine as described below with respect to . The elements supported by the parallel machine include the hardware elements of the parallel machine. The hardware components can include general purpose elements such as state machine elements as well as special purpose elements such as a counter. In some examples particularly the parallel machine examples the target device can support a large number of general purpose elements compared to a relatively small number of special purpose elements. Accordingly in some examples most functions will be implemented with the general purpose elements while fewer selected functions are implemented with the special purpose elements.

In order to utilize the elements of the target device effectively the compiler converts appropriate portions of the syntax tree using special purpose states in the automaton that correspond to special purpose elements supported by the target device. Portions of the syntax tree not converted using special purpose states can be converted into general purpose states corresponding to general purpose elements supported by the target device. The compiler can analyze the syntax tree to determine which portions can be converted using special purpose states and which portions should be converted into general purpose states. In some examples most of the automaton is converted into one or more general purpose states while a smaller percentage is converted using one or more special purpose states.

Converting some portions of the automaton using special purpose states can for example reduce the number of states and or simplify the automaton and therefore simplify the FSM implemented by the machine code. For example certain portions of the syntax tree if converted using general purpose states without any special purpose states can result in a large number of states. In order to reduce the number of states these same portions may be converted using one or more special purpose states possibly in combination with one or more general purpose states. A small number of special purpose states may be able to take the place of a large number of general purpose states. Since the number of general purpose states often corresponds to the number of general purpose elements used by the resulting machine code reducing the number of general purpose states can reduce the complexity and increase the efficiency of the resultant machine code due to fewer general purpose elements used.

In any case the compiler converts certain portions in the syntax tree into certain types of states and other portions in the syntax tree into other types of states. Since the type of state corresponds to a type of element supported by the target device the conversion can have the effect of mapping certain functions implemented by the source code to a specific type of element supported by the parallel machine. In examples where the target device is a computer having a Von Nuemann architecture certain functions in the source code can be mapped to specific types of instructions of the instruction set supported by the Von Nuemann computer. In examples where the target device is a parallel machine certain functions of the source code can be mapped to general purpose elements such as state machine elements and other functions can be mapped to special purpose elements such as counters. Additional detail regarding converting the syntax tree into an automaton is provided below with respect to .

Once the automaton has been formed at block the automaton can be optimized to among other things reduce its complexity and size. The automaton can be optimized by combining equivalent states among other things.

At block the automaton is converted into machine code for a target device. Each portion of the automaton is converted into machine code corresponding to the elements of the target device as mapped at block . In one example the machine code comprises executable instructions for a processor in a Von Nuemann architecture. Here the machine code can comprise an executable program. In another example the machine code can comprise bits for programming of hardware elements in a parallel machine. Here the machine code can comprise an image for loading onto the parallel machine.

At block the machine code can be published by the compiler. In an example the machine code can be published by saving the machine code to a computer readable medium. In another example the machine code can be published by sending the machine code to another device such as a programming device for loading the machine code onto a parallel machine. In yet another example the machine code can be published by loading the machine code onto a parallel machine. In still another example the machine code can be published by displaying the machine code on a display device.

In an example the compiler can be implemented by instructions for a computer having a Von Nuemann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler. For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor. An example computer having a Von Nuemann architecture is shown in and described below.

In an example the portions of the syntax tree that correspond to special purpose states are identified based on functions of the operators in the syntax tree. In fact the functionality of the operators identified by the compiler can correspond to the specific functionality that the special purpose element of the target device is intended to implement. In an example the compiler can identify quantifications in the syntax tree as corresponding to a special purpose element when the target device supports a counter as a special purpose element. More detail regarding quantifications and counters is provided with respect to .

At block once a portion has been identified as corresponding to a special purpose element the identified portion may be further analyzed to determine whether it meets certain conditions in order to be mapped to a special purpose element. In an example the condition includes whether an automaton corresponding to the identified portion is deterministic. That is the condition corresponds to whether the identified portion if converted into an automaton of general purpose states is deterministic regardless of whether a larger automaton e.g. an automaton formed based on the entire syntax tree of which the identified portion is a part is deterministic. If the automaton corresponding to the identified portion is deterministic then at block the identified portion is converted using one or more special purpose states. If the automaton is not deterministic then at block the identified portion is converted using one or more general purpose states without any special purpose states. In other examples the automaton can convert the identified portion using a first type of special purpose state when the identified power is deterministic and another type of special purpose state when the identified portion is not deterministic. In still other examples other conditions can be used to determine what type of states to use when converting the identified portion of the syntax tree.

In an example in order to determine whether an identified portion of the syntax tree is deterministic at block the compiler can determine whether the identified portions if converted into an automaton have only one active state at a given time. This can be determined by for example finding out whether there are any interference conditions with the identified portions. For example where the identified portion is a quantification the compiler can analyze the automaton to determine whether the automaton meets a no re entrance condition or a no prefix condition. Additional detail regarding the no re entrance and no prefix interference conditions is provided below with respect to .

Using these determinations each operator in the syntax tree can be converted into one or more states of an automaton. Some operators can be converted as described above by identifying specific functions implemented by the operators and converting those functions when appropriate using one or more special purpose states in the automaton. Operators that are not converted using one or more special purpose states can be converted by default into one or more general purpose states. For example the syntax tree can be analyzed to identify and map all applicable operators to a counter in a parallel machine. Once all applicable operators have been mapped to one or more counters the remaining operators can be mapped to one or more state machine elements. In other examples all portions of the syntax tree are mapped by identifying one or more specific elements corresponding to the particular portion.

The description below with respect to pertains to example embodiments of implementing a FSM using special purpose elements in a parallel machine. In an example the special purpose elements of the parallel machine include counters. The counters are intended to implement quantifications in the source code. The description with reference to pertains to example parallel machines and the description with respect to describes a compiler to generate machine code to program the parallel machine.

The parallel machine includes a plurality of programmable elements including general purpose elements and special purpose elements . A general purpose element can include one or more inputs and one or more outputs . A general purpose element can be programmed into one of a plurality of states. The state of the general purpose element determines what output s the general purpose elements will provide based on a given input s . That is the state of the general purpose element determines how the programmable element will react based on a given input. Data input to the data input port can be provided to the plurality of general purpose elements to cause the general purpose elements to take action thereon. Examples of a general purpose element can include a state machine element SME discussed in detail below and a configurable logic block. In an example a SME can be set in a given state to provide a certain output e.g. a high or 1 signal when a given input is received at the data input port . When an input other than the given input is received at the data input port the SME can provide a different output e.g. a low or 0 signal . In an example a configurable logic block can be set to perform a Boolean logic function e.g. AND OR NOR ext. based on input received at the data input port .

The parallel machine can also include a programming interface for loading a program e.g. an image onto the parallel machine . The image can program e.g. set the state of the general purpose elements . That is the image can configure the general purpose elements to react in a certain way to a given input. For example a general purpose element can be set to output a high signal when the character a is received at the data input port . In some examples the parallel machine can use a clock signal for controlling the timing of operation of the general purpose elements . In certain examples the parallel machine can include special purpose elements e.g. RAM logic gates counters look up tables etc. for interacting with the general purpose elements and for performing special purpose functions. In some embodiments the data received at the data input port can include a fixed set of data received over time or all at once or a stream of data received over time. The data may be received from or generated by any source such as databases sensors networks etc coupled to the parallel machine .

The parallel machine also includes a plurality of programmable switches for selectively coupling together different elements e.g. general purpose element data input port output port programming interface and special purpose elements of the parallel machine . Accordingly the parallel machine comprises a programmable matrix formed among the elements. In an example a programmable switch can selectively couple two or more elements to one another such that an input of a general purpose element the data input port a programming interface or special purpose element can be coupled through one or more programmable switches to an output of a general purpose element the output port a programming interface or special purpose element . Thus the routing of signals between the elements can be controlled by setting the programmable switches . Although illustrates a certain number of conductors e.g. wires between a given element and a programmable switch it should be understood that in other examples a different number of conductors can be used. Also although illustrates each general purpose element individually coupled to a programmable switch in other examples multiple general purpose elements can be coupled as a group e.g. a block as illustrated in to a programmable switch . In an example the data input port the data output port and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements.

In an example a single parallel machine is implemented on a physical device however in other examples two or more parallel machines can be implemented on a single physical device e.g. physical chip . In an example each of multiple parallel machines can include a distinct data input port a distinct output port a distinct programming interface and a distinct set of general purpose elements . Moreover each set of general purpose elements can react e.g. output a high or low signal to data at their corresponding input data port . For example a first set of general purpose elements corresponding to a first parallel machine can react to the data at a first data input port corresponding to the first parallel machine . A second set of general purpose elements corresponding to a second parallel machine can react to a second data input port corresponding to the second parallel machine . Accordingly each parallel machine includes a set of general purpose elements wherein different sets of general purpose elements can react to different input data. Similarly each parallel machine and each corresponding set of general purpose elements can provide a distinct output. In some examples an output port from first parallel machine can be coupled to an input port of a second parallel machine such that input data for the second parallel machine can include the output data from the first parallel machine .

In an example an image for loading onto the parallel machine comprises a plurality of bits of information for setting the state of the programmable elements programming the programmable switches and configuring the special purpose elements within the parallel machine . In an example the image can be loaded onto the parallel machine to program the parallel machine to provide a desired output based on certain inputs. The output port can provide outputs from the parallel machine based on the reaction of the programmable elements to data at the data input port . An output from the output port can include a single bit indicating a match of a given pattern a word comprising a plurality of bits indicating matches and non matches to a plurality of patterns a word comprising a plurality of bits indicating a plurality of active and inactive states and a state vector corresponding to the state of all or certain programmable elements at a given moment.

Example uses for the parallel machine include pattern recognition e.g. speech recognition image recognition etc. signal processing imaging computer vision cryptography and others. In certain examples the parallel machine can comprise a finite state machine FSM engine a field programmable gate array FPGA and variations thereof. Moreover the parallel machine may be a component in a larger device such as a computer pager cellular phone personal organizer portable audio player network device e.g. router firewall switch or any combination thereof control circuit camera etc.

The FSM engine includes a plurality of programmable elements including general purpose elements and special purpose elements. The general purpose elements can be programmed to implement many different functions. These general purpose elements include SMEs shown in that are hierarchically organized into rows shown in and blocks shown in . To route signals between the hierarchically organized SMEs a hierarchy of programmable switches is used including inter block switches shown in intra block switches shown in and intra row switches shown in . A SME can correspond to a state of a FSM implemented by the FSM engine . The SMEs can be coupled together by using the programmable switches as described below. Accordingly a FSM can be implemented on the FSM engine by programming the SMEs to correspond to the functions of states and by selectively coupling together the SMEs to correspond to the transitions between states in the FSM.

In an example the input block the output block and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements. Accordingly bits from the image stored in the registers corresponding to the programming interface can be loaded on the SMEs . Although illustrates a certain number of conductors e.g. wire trace between a block input block output block and an inter block switch it should be understood that in other examples fewer or more conductors can be used.

In an example the row includes a first and second plurality of row interconnection conductors . In an example an input of a GOT can be coupled to one or more row interconnection conductors and an output can be coupled to one row interconnection conductor . In an example a first plurality of the row interconnection conductors can be coupled to each SME of each GOT within the row . A second plurality of the row interconnection conductors can be coupled to one SME of each GOT within the row but cannot be coupled to the other SME of the GOT . In an example a first half of the second plurality of row interconnection conductors can couple to first half of the SMEs within a row one SME from each GOT and a second half of the second plurality of row interconnection conductors can couple to a second half of the SMEs within a row the other SME from each GOT . The limited connectivity between the second plurality of row interconnection conductors and the SMEs is referred to herein as parity .

In an example the row can also include a special purpose element such as a counter a programmable Boolean logic element a field programmable gate array FPGA an application specific integrated circuit ASIC a programmable processor e.g. a microprocessor and other elements. Additionally in an example the special purpose element is different in different rows . For example four of the rows in a block can include Boolean logic as the special purpose element and the other eight rows in a block can include a counter as the special purpose element .

In an example the special purpose element includes a counter also referred to herein as counter . In an example the counter comprises a 12 bit programmable down counter. The 12 bit programmable counter has a counting input a reset input and zero count output. The counting input when asserted decrements the value of the counter by one. The reset input when asserted causes the counter to load an initial value from an associated register. For the 12 bit counter up to a 12 bit number can be loaded in as the initial value. When the value of the counter is decremented to zero 0 the zero count output is asserted. The counter also has at least two modes pulse and hold. When the counter is set to pulse mode the zero count output is asserted during the first clock cycle when the counter decrements to zero and at the following clock cycles the zero count output is no longer asserted even if the counting input is asserted. This state continues until the counter is reset by the reset input being asserted. When the counter is set to hold mode the zero count output is asserted during the first clock cycle when the counter decrements to zero and stays asserted when the counting input is asserted until the counter is reset by the reset input being asserted.

In an example a state machine element comprises a plurality of memory cells such as those often used in dynamic random access memory DRAM coupled in parallel to a detect line . One such memory cell comprises a memory cell that can be set to a data state such as one that corresponds to either a high or a low value e.g. a 1 or 0 . The output of the memory cell is coupled to the detect line and the input to the memory cell receives signals based on data on the data stream line . In an example an input on the data stream line is decoded to select one of the memory cells . The selected memory cell provides its stored data state as an output onto the detect line . For example the data received at the data input port can be provided to a decoder not shown and the decoder can select one of the data stream lines . In an example the decoder can convert an ACSII character to 1 of 256 bits.

A memory cell therefore outputs a high signal to the detect line when the memory cell is set to a high value and the data on the data stream line corresponds to the memory cell . When the data on the data stream line corresponds to the memory cell and the memory cell is set to a low value the memory cell outputs a low signal to the detect line . The outputs from the memory cells on the detect line are sensed by a detect circuit . In an example the signal on an input line sets the respective detect circuit to either an active or inactive state. When set to the inactive state the detect circuit outputs a low signal on the respective output regardless of the signal on the respective detect line . When set to an active state the detect circuit outputs a high signal on the respective output line when a high signal is detected from one of the memory cells of the respective SME . When in the active state the detect circuit outputs a low signal on the respective output line when the signals from all of the memory cells of the respective SME are low.

In an example an SME includes 256 memory cells and each memory cell is coupled to a different data stream line . Thus an SME can be programmed to output a high signal when a selected one or more of the data stream lines have a high signal thereon. For example the SME can have a first memory cell e.g. bit set high and all other memory cells e.g. bits set low. When the respective detect circuit is in the active state the SME outputs a high signal on the output when the data stream line corresponding to bit has a high signal thereon. In other examples the SME can be set to output a high signal when one of multiple data stream lines have a high signal thereon by setting the appropriate memory cells to a high value.

In an example a memory cell can be set to a high or low value by reading bits from an associated register. Accordingly the SMEs can be programmed by storing an image created by the compiler into the registers and loading the bits in the registers into associated memory cells . In an example the image created by the compiler includes a binary image of high and low e.g. 1 and 0 bits. The image can program the FSM engine to operate as a FSM by cascading the SMEs . For example a first SME can be set to an active state by setting the detect circuit to the active state. The first SME can be set to output a high signal when the data stream line corresponding to bit has a high signal thereon. The second SME can be initially set to an inactive state but can be set to when active output a high signal when the data stream line corresponding to bit has a high signal thereon. The first SME and the second SME can be cascaded by setting the output of the first SME to couple to the input of the second SME . Thus when a high signal is sensed on the data stream line corresponding to bit the first SME outputs a high signal on the output and sets the detect circuit of the second SME to an active state. When a high signal is sensed on the data stream line corresponding to bit the second SME outputs a high signal on the output to activate another SME or for output from the FSM engine .

In an example the compiler includes an application programming interface API that allows software developers to create images for implementing FSMs on the FSM engine . The compiler provides methods to convert an input set of regular expressions in the source code into an image that is configured to program the FSM engine . The compiler can be implemented by instructions for a computer having a Von Nuemann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler. For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor. An example computer having a Von Nuemann architecture is shown in and described below.

At block regular expressions are parsed to form a syntax tree. Parsing creates a generic representation of the source code as explained above with respect to . In addition parsing can take into account regexes that are and are not supported by the FSM engine . Regexes that are supported can be converted into the appropriate machine code implementations however regexes that are not supported can for example generate an error or be converted into supported machine code that is close in functionality to the non supported regex.

At block the syntax tree is converted into an automaton. As mentioned above with respect to converting the syntax tree converts the syntax tree into an automaton comprising a plurality of states. In an example the automaton can be converted based partly on the hardware of the FSM engine .

In an example input symbols for the automaton include the symbols of the alphabet the numerals 0 9 and other printable characters. In an example the input symbols are represented by the byte values 0 through 255 inclusive. In an example an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example the data accepted e.g. matched by an automaton is the set of all possible data which when input sequentially into the automaton will reach a final state. Each symbol in the data accepted by the automaton traces a path from the start state to one or more final states. The data accepted by a regular expression is the set of all possible character strings which match the regular expression. Given a regular expression R denote the accepted data of R as R .

In an example the automaton comprises general purpose states as well as special purpose states. In an example where the compiler is generating machine code for the FSM engine the general purpose states can correspond to SMEs and the general purpose states are accordingly referred to herein as SME states . Moreover when the compiler is generating machine code for the FSM engine a special purpose states can correspond to a counter and is accordingly referred to herein as a counter state . In an example the SME states in the automaton map 1 1 to SMEs e.g. SME in the FSM engine with the exception of the starting state of the automaton which does not map to a SME. The counters may or may not map 1 1 to counter states.

In an example special transition symbols outside the input symbol range may be used in the automaton. These special transition symbols can be used for example to enable use of special purpose elements . Moreover special transition symbols can be used to provide transitions that occur on something other than an input symbol. For example a special transition symbol may indicate that a first state is to be enabled e.g. transitioned to when both a second state and a third state are enabled. Accordingly the first state is activated when both the second state and the third state are activated and the transition to the first state is not directly dependent on an input symbol. Notably a special transition symbol that indicates that a first state is to be enabled when both a second state and a third state are enabled can be used to represent a Boolean AND function performed for example by Boolean logic as the special purpose element . In an example a special transition symbol can be used to indicate a counter state has reached zero and thus transitions to a downstream state.

In an example an automaton can be constructed using one of the standard techniques such as Glushkov s method. In an example the automaton can be an free homogeneous automaton. Additional detail regarding converting the syntax tree into an automaton is provided with respect to and below.

At block once the syntax tree has been converted to an automaton the automaton is optimized. The automaton can be optimized to among other things reduce its complexity and size. The automaton can be optimized by combining redundant states.

At block the optimized automaton is converted into a netlist. Converting the automaton into a netlist maps each state of the automaton to an instance of a hardware element e.g. SMEs special purpose elements on the FSM engine . Also the connections between the instances are determined to create the netlist.

At block the netlist is placed to select a specific hardware element of the target device e.g. SMEs special purpose elements for each instance of the netlist. In an example placing selects each specific hardware element based on general input and output constraints for of the FSM engine .

At block the placed netlist is routed to determine the settings for the programmable switches e.g. inter block switches intra block switches and intra row switches in order to couple the selected hardware elements together to achieve the connections described by the netlist. In an example the settings for the programmable switches are determined by determining specific conductors of the FSM engine that will be used to connect the selected hardware elements and the settings for the programmable switches. Routing can take into account more specific limitations of the connections between the hardware elements that placement at block . Accordingly routing may adjust the location of some of the hardware elements as determined by the global placement in order to make appropriate connections given the actual limitations of the conductors on the FSM engine .

Once the netlist is placed and routed the placed and routed netlist can be converted into a plurality of bits for programming of a FSM engine . The plurality of bits are referred to herein as an image.

At block an image is published by the compiler. The image comprises a plurality of bits for programming specific hardware elements and or programmable switches of the FSM engine . In embodiments where the image comprises a plurality of bits e.g. 0 and 1 the image can be referred to as a binary image. The bits can be loaded onto the FSM engine to program the state of SMEs the special purpose elements and the programmable switches such that the programmed FSM engine implements a FSM having the functionality described by the source code. Placement block and routing block can map specific hardware elements at specific locations in the FSM engine to specific states in the automaton. Accordingly the bits in the image can program the specific hardware elements and or programmable switches to implement the desired function s . In an example the image can be published by saving the machine code to a computer readable medium. In another example the image can be published by displaying the image on a display device. In still another example the image can be published by sending the image to another device such as a programming device for loading the image onto the FSM engine . In yet another example the image can be published by loading the image onto a parallel machine e.g. the FSM engine .

In an example an image can be loaded onto the FSM engine by either directly loading the bit values from the image to the SMEs and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs and other hardware elements . In an example the hardware elements e.g. SMEs other elements programmable switches of the FSM engine are memory mapped such that a computer e.g. a programming device coupled to or integral with the computer can load the image onto the FSM engine by writing the image to one or more memory addresses.

One type of regex that can be described in the source code includes a quantification. Quantifications are well known in the art and are used to describe repeated patterns. As an example A B n1 n2C is a general regular expression where A B and C are sub expressions and B n1 n2 comprises a quantification. As described herein upper case letters are used to represent regular expressions or a portion of a regular expression e.g. a sub expression . Double quotation marks may be added around regular expressions or sub expressions to avoid confusion. Accordingly an upper case letter describing an expression can correspond to a search string for multiple input symbols. For example the expression A can correspond to the input string abbc .

Moreover it should be understood that the terms expression and sub expression are used herein for relational description only e.g. a sub expression is a portion of an expression and that the terms expression and sub expression should not be limited to any specific length syntax or number of characters. In particular source code can include a large number of characters including meta characters and search characters of which the entire set of characters or any individual portion thereof can be considered an expression . For example each of the following can be considered an expression a bb d 5 20c b 0 10 b d and b .

A quantification is expressed in regex as B n1 n2 where B is a sub expression and n1 and n2 are integers specifying how many times the preceding sub expression is allowed to occur. B is referred to herein as a repeated sub expression since B is a sub expression that is repeated the number of times specified by n1 and n2. To match the quantification B n1 n2 the repeated sub expression B must be matched from n1 to n2 number of times. For example the regex B 5 7 would require the sub expression B to be matched 5 6 or 7 times. In the regex A B n1 n2C the sub expression A is referred to herein as a drive expression since the sub expression A when matched transitions to a quantification. Additionally to continue repeating and incrementing the count for the quantification the repeated sub expression s of the quantification must be matched consecutively. That is when a repeated sub expression is not matched during a given loop of the quantification the quantification ends. In an example the symbol also corresponds to quantification where the symbol preceding the can be identified either one or zero times.

When the target device is the FSM engine the method can identify and map certain quantifications to the counters on the FSM engine . Implementing certain quantifications with the counters can result in efficiencies over implementing the quantifications with the state machine elements . Accordingly the automaton and the resulting image for the FSM engine can be simplified. For example portions of the syntax tree implementing quantifications can require a large amount of SMEs to implement. In an example however some of these quantifications can be implemented using a counter with fewer states than would be required by SMEs .

At block the compiler identifies portions of the syntax tree that correspond to a quantification for possible implementation with the counters in the FSM engine . If the portion of the syntax tree does not correspond to a quantification the method proceeds to block where the portion is converted into general purpose states for implementation with SMEs . If the portion of the syntax tree does correspond to a quantification the quantification is further analyzed to determine whether the identified portion can be implemented with the counters .

Prior to making the determination of whether a quantification can be possibly implemented with a counter if B includes empty string the quantification of Bn1 n2 is rewritten as B 0 n2 where B is the no empty string version of B B B . For example bc 10 20 can be rewritten to bc 0 20 since these regexes accept the exact same data. Then for a given quantification Bn1 n2 the quantification can possibly be implemented with a counter method proceeds to block or alternatively implemented with SMEs and no counter method proceeds to block according to the following conditions 

At block once the compiler has identified a quantification that can possibly be implemented with a counter the compiler determines whether a portion of the syntax tree corresponding to the identified portion is deterministic. When the identified portion is deterministic the identified portion can be implemented with one or more counters and the method proceeds to block where the identified portion is converted into one or more counter states along with one or more SME states. When the identified portion is non deterministic the identified portion is not implemented using a counter and the method proceeds to block where the identified portion is converted into one or more SME states.

Generally block and block correspond to the two ways to convert a quantification into an automaton. At block the quantification is converted using one or more counter states possibly in conjunction with one or more SME states to implement the quantification as a loop. At block the quantification is converted by unrolling the quantification which includes using SME states and no counter states. Unrolling comprises rewriting the quantification with non quantification syntax. For example the regex b c 1 2 can be unrolled as b c b c . The merits of unrolling include 1 the resulted automaton is a directed acyclic graph DAG and can be easy to analyze and implement and 2 the resulting automaton can be implemented with general purpose elements especially state machine elements instead of special purpose elements. However the number of general purpose states and thus state machine elements used to implement the unrolled quantification is linear to n1 and n2. Thus the number of states may be large when n1 or n2 is a large number. In particular real life resources are limited thus in some examples this unrolling technique is used for only a limited category of quantifications.

When the target device however has a special purpose element designed to implement a counting function such as a counter unrolling can be avoided in certain instances. The merit of this method is that fewer copies of a repeated expression are needed in the automaton and the number of copies is independent of n1 and n2. Therefore significant resources can be saved. For example one or more counters can be used to implement the quantification by creating a loop with the repeated expression s and the one or more counters . Each time the repeated expression s is matched a counter can be incremented or decremented . The repeated expression s can then be re activated to search for another match. When the counter has be incremented or decremented equal to a number of times stated by the quantification the counter can activate the state s following the quantification. Accordingly the quantification can be implemented with fewer SMEs since the SMEs used to implement the repeated expression s are re used. However due to the parallelism of the entire automaton e.g. corresponding to the entire syntax tree that is multiple states that can be active at the same time the counters in some examples can only be used with quantifications that correspond to deterministic portions of the entire automaton.

The regex A B n1 n1C is converted into a several SME states and a counter state . The SME states correspond to the sub expressions A B and C . The SME states can be implemented with SMEs while the counter state can be implemented with a counter . When the automaton is implemented on the FSM engine a counter corresponding to the counter state is initially loaded with the value n1 and set to assert the zero count output when the value in the counter reaches zero. When n1 equals n2 the counter can be set to Stop 0 and Pulse Output mode which means that the counter will assert its output once its value reaches zero and the counter will remain at zero and not issue any signal until the counter is reset.

The automaton begins at state and transitions to state upon matching the sub expression A . While at state each time the sub expression B is matched the IN port of the counter state is activated and the counter state decrements by one. Additionally each time the sub expression B is matched state activates itself as well as activating state . When the counter state reaches zero the output is activated and the automaton will then search for the sub expression C . In the following cycle two scenarios will occur the first scenario occurs when B is matched. When B is matched the counter state is reset and its value is set back to n1. Accordingly the next time the sub expression A is matched the process starts over from state . In the second scenario the self loop of state is still active and the IN port of the counter continues to be triggered on a match of the sub expression B . Since the counter state is configured in pulse mode the counter state will not activate its output again although the self loop of state remains active.

The negated version of the sub expression B is also referred to herein as B . In an example the negated version of the sub expression B is used to activate the reset port of the counter state . This is because since B is the repeated expression of the quantification B n1 n1 when anything other than B e.g. the negated version of B is received at the input once state has been activated the quantification ends and the counter is accordingly reset. Accordingly once state is activated the counter state is reset and the quantification is not matched when the negated version of the sub expression B is matched. In an example the repeated expression s are negated using standard automaton theory.

Although a single counter state is illustrated and described to implement a quantification when n1 equals n2 it should be recognized that multiple counters can be cascaded as to account for numbers larger than supported by a single counter .

The counter state is initially set to n1 and the counter state is initially set to n2. The automaton transitions from state to state when the sub expression A is matched. Once state is activated the IN port of both counter state and counter state are activated each time that the sub expression B is matched. Accordingly both counter state and counter state are decremented by one. When counter state reaches zero its output is activated and the automaton then searches for a match of the sub expression C and activate state . Once the sub expression B has been matched n1 times the value of the counter state is n2 n1. Later on each time that the sub expression B is matched the IN port of counter state is activated and value of counter state remains at zero and its output is still activated. Meanwhile the counter state continues to be decremented. When the sub expression B is matched n2 times the counter state also reaches zero and its output is activated which drives the reset port of counter state . Since the counter state to counter state latency is two cycles the counter state continues activating its output to state . In the next cycle the counter state is reset from the output of counter state and no output is asserted from the counter state . In the following cycle two scenarios will occur. In the first scenario B is matched. Both counter state and counter state are reset by state and their values are set to n1 and n2 respectively. Accordingly the next time state is active and the next time the sub expression A is matched state is activated and the counter states being decrementing again. In the second scenario the self loop of state remains activated and both counter states IN ports are activated. Since the counter state continually activates its output the counter state is continually reset and does not activate its output as long as the self loop of state is active.

In addition a match of the sub expression B while state is active activates the state . Once state is activated and B is matched the counter states are reset and the quantification is not matched. The negated version of the sub expression B is used since B is the repeated expression of the quantification B n1 n2 . Accordingly the expression B at state can be matched repeatedly for from n1 to n2 number of times. Although a single counter is illustrated and described to implement the lower e.g. n1 and upper e.g. n2 thresholds respectively it should be recognized that multiple counters can be cascaded as known to those skilled in the art to count for numbers larger than supported by a single counter.

Prior to converting a quantification using a counter state the compiler at block determines whether an automaton corresponding to the quantification is deterministic. In an example the automaton is deterministic when the expression meets both the no prefix the no re entrance conditions discussed below. That is in order for a quantification to be mapped to a counter the quantification should meet the no prefix and no re entrance conditions as discussed below.

Referring to automaton of the no re entrance condition requires that the edge from state to state cannot be activated while the counter state is active e.g. while the counter state is counting . That is it is determined whether the drive expression for the quantification can be matched while the quantification is already being processed. Matching a drive expression means that the states immediately prior to the quantification will transition to the states corresponding to the quantification. Accordingly the quantification will be re entered while a counter state is still processing a repeated expression. Since in this example of the FSM engine a counter can only implement a single loop at any given time transitioning to a quantification while a loop is already being processed can cause the counter to count incorrectly during a given loop.

The automaton corresponds to the regular expression abb b c 1 2 and includes a starting state and final states . The final states are identified in as double circles. The starting state is initially activated and transitions to state upon the input symbol a . State transitions to both state and state on the input symbol b . State transitions to state on the input symbol b and state transitions to state on either the input symbol b or c . The automaton transitions from state to state on either the input symbol b or c .

The automaton comprises the automaton for the regex abb b c 1 2 which is to be checked for compliance with the no re entrance condition. The automaton comprises the automaton of the derived regex SS abb b c 2 from the regex abb b c 1 2 of automaton . SS M N is defined as a regex derived from M N. The deriving steps include 1 concatenate M and N the result is denoted as MN . 2 Construct the automaton for MN denoted as A MN . 3 Modify A MN as following a Make the starting state of A MN drive all other states and b make all states corresponding to N as final states. Finally 4 denote the regex for the modified automaton as SS M N . The accepted data of SS M N is composed of the sub strings that start from any state of MN and end at any state of N.

The no re entrance condition can be defined as follows. Given a regular expression with a quantification ABn1 n2C the no re entrance condition requires that SS A Bn1 n2 A . In other words once the sub expression A is matched and the counter state begins to count to meet the no re entrance condition the edge from state to state will not be activated again until Bn1 n2 is done either match or fail . For example abb abb SS abb b c 2 and thus abb b c 1 2 will not be correctly implemented with a counter .

Referring now to the no prefix condition will be explained with reference to the automaton . The no prefix condition states that any string of B should not be the prefix of another string of B which is to guarantee that B does not cause the counter s to count more than once. In other words a quantification is not implemented as and thus converted to a counter when a first repeated sub expression of the quantification is a prefix of a second repeated sub expression of the quantification. The formal statement is For all l l B l l we require l. l. .

For example the regex a b bc 3 does not meet the no prefix condition. Accordingly the regex a b bc 3 would not be converted using a counter state and thus would not be implemented with a counter . Instead the regex a b bc 3 would be converted into general purpose states without any counter states.

If the regex a b bc 3 were implemented with a counter the input abbc would be falsely matched. For example the automaton is the result of a hypothetical conversion of the regex a b bc 3 using a counter state . As described below this conversion results in incorrect performance of the counter state . State is initially activated and at the input a state activates state . With state activated at the input b state activates states and re activates itself state . Also at the input b state activates the IN port of the counter where the initial value of the counter state is at 3 and is then reduced to 2. With the states and activated the IN port of the counter state is activated by state again at another input b and the value in the counter state is reduced to 1. At this point state and are activated. Then an input value c causes the IN port of the counter state to be activated by state to reduce the value in the counter to 0. With the value in the counter at zero the output is activated and state is activated indicating a match. This match however is a false positive since the input abbc has caused a match when the sequence abbc does not meet the regex a b bc 3 . Accordingly the regex a b bc 3 does not meet the no prefix condition and should not be converted using a counter state and implemented with a counter .

If the quantification meets both the no prefix condition and the no re entrance condition at block then the quantification is converted using a special purpose counter state at block . The quantification can be converted as described with respect to above. If however the quantification does not meet either the no prefix or the no re entrance condition the quantification is converted at block by unrolling the quantification and converting to general purpose states and no counter state . The quantification is accordingly implemented with SMEs and not a counter .

Method examples described herein can be machine or computer implemented at least in part. Some examples can include a computer readable medium or machine readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code such as microcode assembly language code a higher level language code or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further the code may be tangibly stored on one or more volatile or non volatile computer readable media during execution or at other times. These computer readable media may include but are not limited to hard disks removable magnetic disks removable optical disks e.g. compact disks and digital video disks magnetic cassettes memory cards or sticks random access memories RAMs read only memories ROMs and the like.

Thus other embodiments can be realized. For example an article of manufacture such as a computer a memory system a magnetic or optical disk some other storage device or any type of electronic device or system can include one or more processors coupled to a computer readable medium such as a memory e.g. removable storage media as well as any memory including an electrical optical or electromagnetic conductor having instructions stored thereon e.g. computer program instructions which when executed by the one or more processors result in performing any of the actions described with respect to the methods above.

The computer can take the form of a computer system having a processor coupled to a number of components directly and or using a bus . Such components can include main memory static or non volatile memory and mass storage . Other components coupled to the processor can include an output device such as a video display an input device such as a keyboard and a cursor control device such as a mouse. A network interface device to couple the processor and other components to a network can also be coupled to the bus . The instructions can further be transmitted or received over the network via the network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP . Any of these elements coupled to the bus can be absent present singly or present in plural numbers depending on the specific embodiment to be realized.

In an example one or more of the processor the memories or the storage device can each include instructions that when executed can cause the computer to perform any one or more of the methods described herein. In alternative embodiments the computer operates as a standalone device or can be connected e.g. networked to other devices. In a networked environment the computer can operate in the capacity of a server or a client device in server client network environment or as a peer device in a peer to peer or distributed network environment. The computer can include a personal computer PC a tablet PC a set top box STB a Personal Digital Assistant PDA a cellular telephone a web appliance a network router switch or bridge or any device capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that device. Further while only a single computer is illustrated the term computer shall also be taken to include any collection of devices that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The computer can also include an output controller for communicating with peripheral devices using one or more communication protocols e.g. universal serial bus USB IEEE 1394 etc. The output controller can for example provide an image to a programming device that is communicatively coupled to the computer . The programming device can be configured to program a parallel machine e.g. parallel machine FSM engine . In other examples the programming device can be integrated with the computer and coupled to the bus or can communicate with the computer via the network interface device or another device.

While the computer readable medium is shown as a single medium the term computer readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database or associated caches and servers and or a variety of storage media such as the processor registers memories and the storage device that store the one or more sets of instructions . The term computer readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the computer and that cause the computer to perform any one or more of the methodologies of the present invention or that is capable of storing encoding or carrying data structures utilized by or associated with such a set of instructions. The term computer readable medium shall accordingly be taken to include but not be limited to tangible media such as solid state memories optical and magnetic media.

The Abstract is provided to comply with 37 C.F.R. Section 1.72 b requiring an abstract that will allow the reader to ascertain the nature and gist of the technical disclosure. It is submitted with the understanding that it will not be used to limit or interpret the scope or meaning of the claims. The following claims are hereby incorporated into the detailed description with each claim standing on its own as a separate embodiment.

Example 1 includes a computer implemented method for generating machine code corresponding to a set of elements including a general purpose element and a special purpose element the method comprising determining whether a portion in an arrangement of relationally connected operators meets a condition to be mapped to a special purpose element mapping the portion to a special purpose element if the portion meets the condition and converting the arrangement of relationally connected operators into machine code.

Example 2 includes a computer readable medium including instructions which when executed by the computer cause the computer to perform operations comprising identifying a portion in an arrangement of relationally connected operators that corresponds to a special purpose element for a target device wherein the target device also includes a general purpose element determining whether the portion meets a condition to be mapped to the special purpose element converting the arrangement into an automaton comprising a plurality of states wherein the portion is converted using a special purpose state that corresponds to the special purpose element if the portion meets the condition and converting the automaton into machine code.

Example 3 includes a computer comprising a memory having software stored thereon and a processor communicatively coupled to the memory wherein the software when executed by the processor causes the processor to compile regular expressions into code for a target device wherein the target device supports a first type of element and at least one other type of element wherein compile includes map a first regular expression that corresponds to the first type of element to the first type of element and wherein compile includes map a second regular expression that does not correspond to the first type of element to the at least one other type of element.

Example 4 includes a system comprising a computer configured to identify a portion in an arrangement of relationally connected operators that corresponds to a special purpose element of a target device wherein the target device also includes a general purpose element determine whether the portion meets a condition to be mapped to the special purpose element convert the arrangement into an automaton comprising a plurality of interconnected states wherein the portion is converted into a special purpose state that corresponds to the special purpose element if the first portion meets the condition and convert the automaton into machine code and a device for programming a parallel machine the device configured to load the machine code onto the parallel machine.

In Example 5 the subject matter of any of Examples 1 4 can optionally include wherein the machine code comprises an image for a parallel machine.

In Example 6 the subject matter of any of Examples 1 5 can optionally include wherein the set of elements include a set of instructions for execution on a processor and wherein the special purpose element includes a special purpose instruction.

In Example 7 the subject matter of any of Examples 1 6 can optionally include identifying a portion in the arrangement of relationally connected operators that corresponds to a special purpose element wherein determining whether a portion meets a condition determines whether the portion that is identified meets a condition wherein mapping includes converting the arrangement into an automaton comprising a plurality of states wherein the portion is converted using a special purpose state that corresponds to the special purpose element if the portion meets the condition and wherein converting the arrangement includes converting the automaton into machine code.

In Example 8 the subject matter of any of Examples 1 7 can optionally include wherein identifying a portion in the arrangement that corresponds to a special purpose element comprises identifying an operator of the relationally connected operators that can be implemented using the special purpose element.

In Example 9 the subject matter of any of Examples 1 8 can optionally include wherein converting the arrangement into an automaton comprises converting each of the operators in the arrangement into one or more of the plurality of states.

In Example 10 the subject matter of any of Examples 1 9 can optionally include wherein the portion is converted using a general purpose state and not using a special purpose state that corresponds to a special purpose element if the portion does not meet the condition wherein the general purpose state corresponds to the general purpose element.

In Example 11 the subject matter of any of Examples 1 10 can optionally include wherein the portion comprises a first portion and wherein a second portion of the arrangement is converted using a general purpose state and not using a special purpose state that corresponds to a special purpose element if the second portion is not identified as corresponding to a special purpose element where the general purpose state corresponds to a general purpose element.

In Example 12 the subject matter of any of Examples 1 11 can optionally include wherein the set of elements includes a set of hardware elements of a parallel machine wherein the general purpose element comprises a programmable element and wherein the special purpose element includes a counter.

In Example 13 the subject matter of any of Examples 1 12 can optionally include wherein the programmable element comprises a state machine element.

In Example 14 the subject matter of any of Examples 1 13 can optionally include wherein the state machine element includes a memory cell.

In Example 15 the subject matter of any of Examples 1 13 can optionally include wherein the memory cell comprises a volatile memory cell.

In Example 16 the subject matter of any of Examples 1 15 can optionally include further comprising publishing the machine code.

In Example 17 the subject matter of any of Examples 1 16 can optionally include wherein publishing the machine code includes loading the machine code onto a parallel machine.

In Example 18 the subject matter of any of Examples 1 17 can optionally include wherein publishing the machine code includes storing the machine code on a computer readable medium.

In Example 19 the subject matter of any of Examples 1 18 can optionally include wherein the instructions cause the computer to perform operations comprising converting source code into the arrangement and publishing the machine code.

In Example 20 the subject matter of any of Examples 1 19 can optionally include wherein determining whether the portion meets a condition to be mapped to a special purpose element comprises determining whether the portion is deterministic.

In Example 21 the subject matter of any of Examples 1 20 can optionally include wherein identifying a portion of the arrangement includes identifying a quantification and wherein determining whether the portion is deterministic includes determining whether a drive expression for the quantification can be matched while the quantification is being processed.

In Example 22 the subject matter of any of Examples 1 21 can optionally include wherein identifying a portion of the arrangement includes identifying a quantification and wherein determining whether the portion is deterministic includes determining whether a repeated expression of the quantification is a prefix of another repeated expression of the quantification.

In Example 23 the subject matter of any of Examples 1 22 can optionally include wherein identifying a portion in the arrangement includes identifying a quantification.

In Example 24 the subject matter of any of Examples 1 23 can optionally include wherein determining whether the portion is deterministic includes determining whether a drive expression for the quantification can be matched while the quantification is being processed and determining whether a repeated expression of the quantification is a prefix of another repeated expression of the quantification.

In Example 25 the subject matter of any of Examples 1 24 can optionally include wherein the special purpose element includes a counter having a corresponding counter state in the automaton and the general purpose element includes a state machine element having a corresponding state machine element state in the automaton.

In Example 26 the subject matter of any of Examples 1 25 can optionally include wherein when the portion corresponds to a quantification and the portion is deterministic the portion is implemented as a loop comprising a repeated expression of the quantification and a counter state wherein the counter state is configured to count a number of times the repeated expression is matched and wherein the counter state activates a downstream state when the repeated expression is matched a number of times specified by the quantification.

In Example 27 the subject matter of any of Examples 1 26 can optionally include wherein the loop is exited by a match with a negated version of the repeated expression.

In Example 28 the subject matter of any of Examples 1 27 can optionally include wherein when the quantification can be matched with a single number of loops configuring the repeated expression to assert a counting input of the counter state configuring a negated version of the repeated expression to reset the counter state and configuring the counter state to assert an output when the counting input has been asserted a number of times equal to the number of loops without the counter state being reset.

In Example 29 the subject matter of any of Examples 1 28 can optionally include wherein when the quantification can be matched with a multiple number of loops configuring the repeated expression to assert a counting input of a first counter state and a counting input of a second counter state configuring the repeated expression to assert a reset input of the first counter state and a reset input of the second counter state configuring the first counter state to assert an output when the counting input of the first counter state has been asserted a number of times equal to a low threshold of the multiple number of loops without the first counter state being reset and configuring the second counter state to assert an output of the second counter state when the counting input of the second counter state has been asserted a number of times equal to a high threshold of the multiple number of loops without the second counter state being reset wherein the output of the second counter state is configured to assert the reset input of the first counter state.

In Example 30 the subject matter of any of Examples 1 29 can optionally include wherein the target device comprises a parallel machine and the first type of element is a first type of hardware element and the at least one other type of element includes a second type of hardware element.

In Example 31 the subject matter of any of Examples 1 30 can optionally include wherein the second type of hardware element can receive an input stream and provide an output as a function of the input stream and wherein the first type of hardware element does not receive the input stream and provides an output as a function of inputs from other elements of the target device.

In Example 32 the subject matter of any of Examples 1 31 can optionally include wherein the first type of element is a counter and the second type of element is a state machine element.

In Example 33 the subject matter of any of Examples 1 32 can optionally include determining whether a regular expression is of a type that corresponds to the first type of element and when the regular expression is not of a type that corresponds to the first type of element map the regular expression to the at least one other type of element.

In Example 34 the subject matter of any of Examples 1 33 can optionally include wherein determine whether a regular expression is of a type that corresponds to the first type of element includes determining whether the regular expression is a quantification and when the regular expression is not of a quantification map the regular expression to the at least one other type of element.

In Example 35 the subject matter of any of Examples 1 34 can optionally include determining whether the quantification is deterministic when the quantification is deterministic map the regular expression to the first type of element and when the quantification is not deterministic map the regular expression to the at least one other type of element.

In Example 36 the subject matter of any of Examples 1 35 can optionally include wherein determine whether the quantification is deterministic includes determine whether a drive expression for the quantification can be matched while the quantification is being processed and whether a repeated expression of the quantification is a prefix of another repeated expression of the quantification.

In Example 37 the subject matter of any of Examples 1 36 can optionally include wherein compile includes parsing the regular expressions to form a syntax tree converting the syntax tree into an automaton converting the automaton into a netlist placing instances of the netlist and routing connections between the instances of the netlist.

In Example 38 the subject matter of any of Examples 1 37 can optionally include wherein the regular expressions comprise criteria for searching unstructured data.

In Example 39 the subject matter of any of Examples 1 38 can optionally include wherein determine whether the portion meets a condition to be mapped to a special purpose element comprises determine whether the portion is deterministic.

In Example 40 the subject matter of any of Examples 1 39 can optionally include wherein identify a portion of the arrangement includes identify a quantification and wherein determine whether the portion is deterministic includes determine whether a drive expression for the quantification can be matched while the quantification is being processed and whether a repeated expression of the quantification is a prefix of another repeated expression of the quantification.

Example 41 includes a parallel machine programmed by an image produced using the subject matter of any of claims 1 40.

