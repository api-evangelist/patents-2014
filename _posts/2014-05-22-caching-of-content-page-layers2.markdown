---

title: Caching of content page layers
abstract: Server systems are disclosed that receive content request and respond with hardware-independent graphics commands instead of, or in addition to, unprocessed content items. Some server systems may act as intermediaries between user devices and content sources. The server systems can obtain content pages from content sources, process the content pages (e.g., using a headless browser), and provide hardware-independent graphics commands (e.g., vector graphics commands, that do not require specialized graphics hardware for execution) to user devices in response to requests for content. The hardware-independent graphics commands can be executed by client browsers to generate a representation of the content page that is the same or substantially the same as the representation that would have been generated by processing the content pages locally. A user device in receipt of such hardware-independent graphics commands can execute them without performing traditional content page processing, thereby improving user-perceived page load times.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09563929&OS=09563929&RS=09563929
owner: Amazon Technologies, Inc.
number: 09563929
owner_city: Seattle
owner_country: US
publication_date: 20140522
---
The present application s Applicant is concurrently filing the following U.S. patent applications on May 22 2014 

When a user requests a web page or other content page via a browser the user typically experiences a noticeable delay before the page is fully or even partially displayed. Various factors can contribute to this delay. These factors include for example 1 the speed of the wireless or wired connection between the user s device and the Internet 2 the location of and load on the origin server that hosts the page 3 the size of the page including any embedded graphics 4 whether and the extent to which the page includes embedded objects that need to be separately retrieved possibly from different domains once the page s HTML has been loaded 5 the complexity of the page s coding including any scripts and 6 the processing power of the user s device. When the delay is significant e.g. several seconds or more the task of browsing can be frustrating for users.

Various methods exist for reducing the delay experienced by users. Some methods include the use of caching proxy servers which store recently retrieved versions of content and provide the content to users faster than origin servers. For example a caching proxy may be located closer in either a geographic or networking sense to a client device or the caching proxy may have a faster network connection to the client device or the origin server. Origin servers may also deploy certain content onto content delivery network CDN servers. Client devices requesting the content may be directed to the closest CDN server or to a CDN server that can otherwise provide the requested content faster than the origin server. Other methods of reducing the delay experienced by users include the use of proxy servers or other intermediary systems that compress or re format content. Such processed content may be transferred to client devices faster or may require less processing by the client devices to render the content.

The present disclosure involves an architecture in which the functions of a network content browsing system e.g. a web browser application are distributed among a browser component running on a server and a browser component running on a user device. The server based browser component can obtain content and generate graphics commands that can be executed to display a representation of the content. The graphics commands may not be markup commands such as Hypertext Markup Language HTML commands but may instead be hardware independent graphics commands for painting to a display such as vector graphics commands that are not device specific or graphics processing unit GPU specific e.g. they can be executed on a variety of different devices and in different operating environments as long as the appropriate graphics library is present . For example the hardware independent graphics commands may be software based graphics commands targeted at a particular multi platform software library or application programming interface API that provides abstraction from specific hardware requirements. The sever based browser component does not need to execute the graphics commands to display the content but may instead or additionally provide the graphics commands to the browser component running on the user device. In this configuration the server based browser component may be referred to as a headless browser and the browser component running on the user device may be referred to as a client browser. The client browser can execute the graphics commands to display requested content without the content processing that would normally be required on the user device.

Conventional browser applications executing on a user device typically request content at a particular network address e.g. www.abc.xyz directly from an origin server at the network address indirectly from a content delivery network CDN server configured to provide content on behalf of the origin server via an intermediary system such as a proxy or though some other route. The requested content may be received in the form of an HTML file which is then parsed by the browser application to identify any objects e.g. images videos style sheets script files etc. referenced by the HTML file. The referenced objects are then retrieved in a manner that is similar or identical in many respects to the retrieval of the HTML file. The browser application constructs a Document Object Model DOM tree based on the parsed HTML file and the referenced objects. The DOM tree includes nodes for each element of the requested content e.g. individual HTML tags referenced objects scripts etc. . A render tree is constructed using style information e.g. from referenced cascading style sheets and the visual elements from the DOM tree in the order in which they are to be displayed. The purpose of the render tree is to enable painting of the elements in the correct order. The render tree is traversed and a paint command is executed for each node in order to display content on the screen.

Performance of such a conventional browser application is typically dependent upon the latencies and resource requirements associated with each of the processes summarized above. If a user device has a low bandwidth network connection then retrieval of the content may introduce substantial latency before much of the processing to be performed on the user device may begin. If a user device does not have enough computing resources e.g. CPU capacity available memory etc. the processing of content after it is retrieved may introduce substantial latency before or during painting of the content to the user device display.

Some aspects of the present disclosure relate to splitting the graphics pipeline of a browser application among server based and client based browser components e.g. between a headless browser and a client browser . The server or servers on which a headless browser instance is running may have access to a network connection that is substantially faster than the network connection available to the user device and can therefore retrieve content much more quickly than the user device. Alternatively or in addition the server s may have substantially more computing resources than the user device and may therefore perform the content processing summarized above and described in greater detail below much more quickly and efficiently than the user device. As a result of the faster network connection and or greater available computing resources a headless browser instance running on a server may be able to produce paint commands faster than a conventional browser application executing on a user device. The paint commands can be transmitted to a user device in the form of hardware independent graphics commands where they can be executed by a client browser instance to display requested content. Advantageously the transmission of such hardware independent graphics commands to a user device may require less bandwidth than the retrieval of unprocessed content items by the user device further reducing the time required for the user device to receive and display requested content and further improving user perceived performance.

In some embodiments the hardware independent graphics commands that are generated by the headless browser are vector graphics commands such as Skia commands or OpenGL commands. The vector graphics commands may be transmitted to a client browser running on a user device. For example Skia commands for displaying a content page or some portion thereof may be recorded as a Skia SkPicture which can be stored and or transmitted to a client browser. As long as the client browser has access to the proper graphics library to execute them the vector graphics commands may be executed by the client browser to display a representation of the requested content that is identical or substantially identical to the representation that would have been displayed if the client browser retrieved and processed the requested content locally. For example users may be able to zoom the display of the user device in on text or vector graphic objects without any pixilation of the display. As another example users may pan and scroll the content highlight and copy text etc.

Additional aspects of the present disclosure relate to updating the display of content to account for any changes to the display e.g. to update areas which are no longer current or valid such areas may be referred to as damaged or dirty areas . Rather than generating transferring and executing hardware independent graphics commands to re paint the entire display the display may be updated using hardware independent graphics commands for the specific object area or layer that is damaged. In some embodiments interaction information regarding user actions performed on the content e.g. scrolling zooming clicking etc. may be transmitted to the headless browser. The headless browser may then perform the same actions to its representation of the requested content determine which portion s of the display has changed if any and generate hardware independent graphics commands for the changed portion s only rather than for the entire content page or currently displayed portion thereof. The hardware independent graphics commands may then be provided to the user device which can execute them to update the representation of content that is displayed on the user device. For example a user may move the mouse cursor over a particular object such as a button of a web page. The onmouseover event handler for that particular object may be associated with code that modifies the appearance of the object. The headless browser can execute the code and generate hardware independent graphics commands to modify the appearance of the object accordingly e.g. draw a rectangle with certain properties at a particular screen location identified by specific coordinates . The hardware independent graphics commands can be transmitted to the client browser which executes the graphics commands and draws the appropriate rectangle.

Further aspects of the present disclosure relate to separating content into layers to facilitate the update features described above and in greater detail below and to provide additional bandwidth conservation functionality to the client browser. A content page may include multiple e.g. two or more distinct areas which can or should be handled independently from one another. The distinct areas may correspond to different visual objects frames files or the like. The headless browser can define a layer for each of the distinct areas or for combinations thereof and can produce a separate set of hardware independent graphics commands e.g. a separate SkPicture for each layer. In some embodiments two or more layers may partially or completely overlap in two dimensional space e.g. the layers may include the same area defined by the coordinates x y to x y . Individual layers may be associated with layout information that indicates the order of the layers in a third dimension e.g. a z index . In some embodiments no layers of a content page overlap. In one example content page the page may have a header area and a separate body area. The body area may be scrollable or otherwise changeable while the header area is to remain stationary or unchanged. Rather than requiring updated Skia commands to be generated in response to every scrolling event associated with the body area in order to maintain the appearance of a stationary header area the two areas may be defined as two separate SkPictures. The client browser can be configured to compose the separate SkPictures into a single display while allowing users to interact with the content represented by each SkPicture separately. In this example a user may scroll the body area and only the portion of the display corresponding to the body area may change. In some embodiments an SkPicture corresponding to the body area in its entirety may be provided to the client browser reducing or eliminating the need for any updated Skia commands to be generated by the headless browser in response to scrolling interactions.

Still further aspects of the present disclosure relate to caching at a server side cache and or a client side cache individual layers e.g. the SkPictures or other discrete sets of hardware independent graphics commands for individual layers . Individual layers may be assigned various properties such as an identifier and a time to live TTL value. Illustratively the identifier may be based on a hash of the graphics commands for the layer layout information regarding the size and position of the layer on the composed display of the content page etc. When a client browser receives layers for a requested content page the client browser can store the layers in a client side cache in addition to executing the graphics commands. In response to subsequent requests for the content page the headless browser can provide identifiers of layers that are present in the client side cache and can thereby reduce bandwidth usage by avoiding the transmission of graphics commands that are already present at the client. In some embodiments the headless browser can provide identifiers of some or all layers of a content page without prior knowledge of which layers may be cached at the client and the client browser can return a cache miss notification or otherwise retrieve the layers that are not in the client side cache. In some embodiments cached layers for one page may be re used for other pages. For example multiple e.g. two or more pages of a particular domain may include the same header or other portion. The client browser can obtain from the client side cache the layer corresponding to that portion originally received in response to a request for a first page even when the client browser is displaying a second page for the first time. In some embodiments the server may cache a layer in a server side cache in response to a request from a first client browser and may provide the cached layer or unique layer identifier to a second client browser thereby reducing latency by avoiding the repeated retrieval of content pages and generation of hardware independent graphics commands.

Although aspects of the embodiments described in the disclosure will focus for the purpose of illustration on a distributed browsing system with separate server based and client based browser components designed specifically to work in conjunction with one another e.g. a headless browser instance running on a server and a corresponding client browser instance running on a user device one skilled in the art will appreciate that the techniques disclosed herein may be applied to any number of services processes or applications. In some embodiments an existing browser application that runs on a user device may be configured to receive hardware independent graphics commands from a server in lieu of unprocessed content files. For example a browser plug in or extension may be installed on a user device to facilitate communication with a headless browser receive Skia commands and execute the Skia commands thereby bypassing the parsing DOM tree construction rendering processes that would normally be performed by the browser application. In some embodiments browsers executing on user devices may be designed to receive either conventional content files or hardware independent graphics commands or a combination thereof . For example the browser may determine whether to request content files or hardware independent graphics commands based on current conditions and performance metrics data regarding prior browsing sessions or the like. Alternatively or in addition an intermediary system may determine whether to provide content files or hardware independent graphics commands based on current conditions performance metrics prior browsing sessions or the like.

Furthermore although the examples in the present disclosure focus on the generation transmission and execution of Skia commands the systems and processes herein may be used with any hardware independent graphics commands or other non device specific non GPU reliant graphics commands as long as both the client browser or browser extension and headless browser each have access to the necessary graphics processing components and libraries.

Various aspects of the disclosure will now be described with regard to certain examples and embodiments which are intended to illustrate but not limit the disclosure.

As will be appreciated by those of skill in the relevant art the network environment may include any number of distinct user devices and or content sources . In addition multiple e.g. two or more intermediary systems may be used. For example separate intermediary systems may be located so that they are close in either a geographical or networking sense to groups of current or potential user devices or content sources . In such a configuration a user device may request content via the intermediary system to which it is closest rather than all user devices requesting content via a single intermediary system .

The user devices can include a wide variety of computing devices including personal computing devices terminal computing devices laptop computing devices tablet computing devices electronic reader devices mobile devices e.g. mobile phones media players handheld gaming devices etc. wearable devices with network access and program execution capabilities e.g. smart watches or smart eyewear wireless devices set top boxes gaming consoles entertainment systems televisions with network access and program execution capabilities e.g. smart TVs and various other electronic devices and appliances. Individual user devices may execute a client browser application to communicate via the network with other computing systems such as the intermediary system or content sources and in order to request and display content.

Illustratively a user may use a client browser to request network accessible content e.g. content pages images video etc. hosted or provided by a content source such as an origin content server or a CDN server . The user device or client browser may be associated with the intermediary system or otherwise configured to request the content through and receive hardware independent graphics commands from the intermediary system rather than communicating directly with the content source. The client browser may include a remote graphics module that receives remotely generated hardware independent graphics commands such as Skia commands generated by the intermediary system . The remote graphics module or some other module of the client browser can execute the remote generated hardware independent graphics commands to display a representation of the requested content on the user device . Advantageously the remote graphics module may facilitate the display of graphical representations of requested content on the user device without requiring the user device to receive content files e.g. HTML files JPEG images etc. directly or indirectly from content sources and .

In some embodiments the browser application running on the user device may be a conventional web browser that is not specifically designed or configured to execute remotely generated graphics commands and other display commands. For example the browser may use or otherwise be associated with a remote graphics module that is not integrated with the browser such as a browser add in or extension. In some embodiments applications other than a browser may include or use a remote graphics module or some similar module to execute graphics commands generated by an intermediary system . For example content aggregators or other specialized content display applications for mobile devices e.g. Flipboard may utilize a remote graphics module .

The intermediary system can be a computing system configured to retrieve content on behalf of user devices and generate hardware independent graphics commands for execution by the user devices . For example the intermediary system can be a physical server or group of physical servers that may be accessed via the network . In some embodiments the intermediary system may be a proxy server a system operated by an internet service provider ISP and or some other device or group of devices that retrieve content on behalf of user devices .

The intermediary system may include various modules components data stores and the like to provide the content retrieval and processing functionality described herein. For example the intermediary system may include a server based browser application or some other content rendering application to process content retrieved from content sources. Such a content rendering application may be referred to as a headless browser . A headless browser does not or is not required to cause display of content by a graphical display device of the server on which the headless browser is executing. In some embodiments the headless browser can provide hardware independent graphics commands to separate user devices . Illustratively the headless browser may obtain requested content from an origin content server and or CDN server obtain additional items e.g. images and executable code files referenced by the requested content execute code e.g. JavaScript that may be included in or referenced by the content generate hardware independent graphics commands to display a graphical representation of the content and transmit the hardware independent graphics commands to the user device . By performing some or all of these operations on the intermediary system rather than the user device the substantial computing resources and high speed network connections typically available to network based server systems may be leveraged to perform the operations much more quickly.

The headless browser may include various modules to provide the functionality described above and in greater detail below. For example the headless browser may include a content processing module that parses content files and generates a DOM tree and or render tree representation of the content a graphics processing module that receives the DOM render tree representation and generates hardware independent graphics commands e.g. Skia commands to render a graphical representation of the content on a user device and an interaction processing module that communicates with the client browser to receive information regarding interactions with the content on the user device and to update the graphical representation of the content if necessary. In some embodiments a headless browser may include additional or fewer modules than those shown in .

The intermediary system may include additional modules components data stores and the like to provide the features described above and in greater detail below. For example the intermediary system may include a cache that stores content items received from content sources and hardware independent graphics commands generated by the headless browser and the like. The intermediary system may also include a logged user behaviors data store that stores information about user requests and interactions with content.

In some embodiments the cache may store representations of content pages generated by the headless browser together with any hardware independent graphics commands or interactivity instructions for a predetermined period of time after the content page request or after connection between the user device and the intermediary system has terminated. Accordingly if the user of the user device requests the content page again within the predetermined time period the hardware independent graphics commands and any other data can be retrieved from the cache and delivered to user device without the need to re generate the hardware independent graphics commands. In some embodiments persistence of hardware independent graphics commands in the cache can reduce user perceived page load times for recently requested pages. For instance if a user device runs out of battery power or otherwise powers down in the middle of a browsing session the hardware independent graphics commands may be quickly re delivered to the user device upon powering on and reestablishing connection with the intermediary system . In some embodiments interactions stored in the logged user behaviors data store can be used to deliver hardware independent graphics commands reflecting previous user interactions with the page. In other embodiments the cache may store hardware independent graphics commands representing a most recent visual representation displayed on the user device .

The intermediary system may be a single computing device or it may include multiple distinct computing devices such as computer servers logically or physically grouped together to collectively operate as an intermediary system. The components of the intermediary system can each be implemented as hardware such as a server computing device or as a combination of hardware and software. In addition the modules and components of the intermediary system can be combined on one server computing device or separated individually or into groups on several server computing devices. In some embodiments the intermediary system may include additional or fewer components than illustrated in .

In some embodiments the features and services provided by the intermediary system may be implemented as web services consumable via the communication network . In further embodiments the intermediary system is provided by one more virtual machines implemented in a hosted computing environment. The hosted computing environment may include one or more rapidly provisioned and released computing resources which computing resources may include computing networking and or storage devices. A hosted computing environment may also be referred to as a cloud computing environment.

The origin content servers and CDN servers can correspond to logical associations of one or more computing devices for hosting content and servicing requests for the hosted content over the network . For example a content server or CDN server can include a web server component corresponding to one or more server computing devices for obtaining and processing requests for content such as content pages from user devices the intermediary system or other devices or service providers. In some embodiments one or more content servers may be associated one or more CDN service providers e.g. entities that manage multiple CDN servers application service providers etc.

As shown in a request for a content page may be initiated by a user device and transmitted to an intermediary system at 1 . The request may be issued in response to user entry of a network address such as a uniform resource locator URL activation of a link or bookmark initiation of a browsing session that causes a request for a predetermined home page or the like. The request that is transmitted to the intermediary system may be a standardized request such as an HTML GET request that requests a resource at a particular location. In some embodiments the request may be a request for hardware independent graphics commands that may be executed.

The intermediary system may instantiate a headless browser to service the request from the client browser . For example the intermediary system may identify a server with available resources to handle the request and the request can be routed to that server for processing by a headless browser instance . In some embodiments a headless browser instance may be launched on the intermediary system when a client browser instance is launched on a user device e.g. a notification may be provided to the intermediary system when a user launches a client browser instance or in response to some other event. In some embodiments one or more headless browser instances may already be running on the intermediary system so that they are ready to process requests immediately.

The headless browser instance may retrieve the requested content from an appropriate content source at 2 . The content source may be the origin content server a CDN server a proxy server or some other source. In some embodiments the requested content may already be present in storage of the intermediary system . For example the intermediary system may include a cache as shown in . In such cases the requested content may be retrieved from the cache rather than the content source .

The headless browser may process the content at 3 6 as described in greater detail below with respect to . The headless browser can parse the requested content item and construct a DOM tree at 3 and apply styles and other visual configuration properties to the DOM tree elements to construct a render tree at 4 .

At 5 the headless browser can determine whether particular elements in the render tree should be rendered separately or whether all elements of the render tree should be bundled into a single picture. For some content pages separating elements of a content page into multiple e.g. two or more different groups or layers can provide several advantages over bundling every element into a single picture. For example certain elements may be dynamic in nature and may therefore require updating more often than other elements or in response to different events than other elements. Such dynamic elements may therefore be processed by the headless browser separate from other elements of the page. Examples of elements that may trigger creation of a new layer to separate them from the rest of the content page for processing purposes include elements with animation videos GIFs etc. The processing of a render tree into its constituent layers is described in greater detail below with respect to .

At 6 the headless browser can generate hardware independent graphics commands from the render tree such as Skia commands for drawing to a canvas. The generated Skia commands can be recorded for future execution or playback on the user device . For example Skia commands for some or all of the content page can be recorded as an SkPicture. In some embodiments Skia commands may be grouped together into separate SkPictures for each separate layer of the content page determined above. As a result processing of a single content page may produce any number of individual SkPictures each including Skia commands to paint a representation of a corresponding portion of the content page. The SkPictures or other sets of hardware independent graphics commands can be packaged for transmission to the requesting user device . In some embodiments SkPictures can be serialized into a format that is suitable for persistent storage e.g. on a hard disk or transmission as a file to the requesting user device at 7 . In other embodiments the SkPictures can be transmitted over a TCP connection or some other connection in binary form to the user device at 7 .

After receiving the hardware independent graphics commands e.g. Skia commands from the intermediary system the user device can execute the commands at 8 . For example the client browser can play back the Skia commands in order to paint a representation of the requested content page to a display of the user device . Advantageously the representation of the requested content page that is painted by the user device may be identical or substantially identical e.g. any differences may not be noticeable to a user to the representation that would have been displayed by the intermediary system if the headless browser was connected to a display. The representation of the requested content page may also be identical or substantially identical to the representation that would have been generated if the client browser had received the base resource and embedded resources in unprocessed format and constructed the DOM tree and render tree locally.

A user of the user device can interact with the representation of the content page at 9 in a manner that is similar or identical to any user interaction that may occur with a locally processed version of a content page. For example the user may scroll pan and zoom in on portions of the displayed representation. Because the representation is generated using vector graphics commands the scrolling panning and zooming may be displayed naturally e.g. no pixilation on vector graphics or text that would not have also been present when interacting with a locally generated version . In some embodiments the vector graphics commands provided to the client browser may include commands for displaying a representation of the entirety of the requested content page or some large portion thereof. In such cases the scrolling panning zooming and certain other interactions may be processed exclusively by the client browser without any request for or receipt of updated graphics commands from the headless browser .

In some embodiments data regarding user interactions with the representation of content may be provided to the intermediary system at 10 so that the intermediary system can synchronize its representation of the content accordingly. The synchronization data may include data indicating how a user has modified the current display of the representation such as the coordinates of the current viewport a zooming factor or the like. The headless browser can use the synchronization data to update its own representation of the content to mirror the current display on the client browser . For example as described in greater detail below some user interactions may require updates to the displayed content representation. It may be beneficial or necessary that the headless browser have knowledge of the current or immediately preceding display on the client browser so that the headless browser can generate updated hardware independent graphics commands.

At 14 the interaction processing module or some other module or component of the headless browser can update the representation of content on the intermediary system . The update can be based on the synchronization information received from the client browser . For example the headless browser may automatically mimic on the intermediary system a user interaction with the content on the client browser . In the examples above the interaction can trigger JavaScript code which executes on the headless browser to modify a portion of the display. In some cases events other than user interactions with the representation of the content on the user device can cause a visual change to the content page executing on the headless browser . For example JavaScript code may execute on the headless browser without any user intervention animations may execute on the headless browser dynamic updates to the content may be provided to the headless browser by the content source etc. In these and other cases the visual representation of the current page can be changed on the headless browser which can trigger a process for updating the visual representation of the content page on the client browser .

In some cases a user interaction or some other event may cause retrieval of additional content. For example if a user activates a link to a different content item the headless browser may retrieve the linked content item from the appropriate content source at 15 . In some embodiments activation of a link on a client browser may cause transmission of synchronization data including the underlying network address associated with the link. In other embodiments activation of a link on a client browser causes transmission of synchronization data regarding the location of a mouse cursor or a user s finger tap when the mouse button was clicked or the screen tapped . The headless browser then performs the same action to determine that a link was activated. The headless browser can then access the underlying network address and request the linked content item from the appropriate server .

After the requested content is received and processed the triggered script is executed or updates to the display are otherwise determined in response to the user interaction or some other event the headless browser can generate hardware independent graphics commands at 16 to update the display accordingly. The hardware independent graphics commands can be transmitted to the client browser at 17 and executed by the client browser at 18 . The interactions shown in may be repeated as necessary in order to respond appropriately to user requests and interactions with content representations received from the headless browser .

In some embodiments hardware independent graphics commands may be generated at 16 to update only a portion of the representation of the content on the client browser e.g. only the portion of the content page that is visually different rather than causing repainting of the entire content page. For example if the content page has been segmented into layers as described in greater detail below only hardware independent graphics commands for the layer s that have changed may be transmitted to the user device hardware independent graphics commands for layers which have not changed may not be generated or may be generated but not transmitted to the user device . This can save transmission resources and improve speed when only a portion of the page has changed visually because fewer hardware independent graphics commands are transmitted to the client browser .

In response to a request for a content page received from a client browser the headless browser can obtain the requested content page. For example the headless browser can obtain a base resource such as an HTML file from a network address provided with the request for the content page from a local cache or from some other location as described above. At the content processing module can parse the HTML file in order to identify and retrieve any resources referenced by or embedded in the HTML file. The content processing module can construct the DOM tree based on a DOM definition or specification. For example the content processing module can convert elements of the embedded resources and HTML file into DOM nodes. At the content processing module can also parse any available style data such as style data obtained from a referenced CSS file or style data included in the HTML file . Parsed style data together with markup instructions in the HTML file can be used create the render tree in a process that may be referred to as attachment .

The render tree can include nodes for each element to be displayed. For example the render tree may include nodes for rectangles and their corresponding visual attributes such as color and dimensions e.g. width height . The rectangles are placed in the render tree in the proper order in which they are to be displayed. The render tree can also undergo a layout process . During layout individual nodes in the render tree can be assigned coordinates or other positional data indicating where the corresponding shape is to appear when displayed.

In the compositing stage or prior thereto the graphics processing module or some other module of the headless browser can determine whether particular nodes of the render tree should be handled separately from the rest of the render tree . By separating individual nodes or groups of nodes and handling them separately any changes to the display of objects corresponding to those nodes may be handled separately from other objects of the content page.

In the painting stage the client browser can execute the hardware independent graphics commands received from the intermediary system . For example the client browser can use a software library on the user device to execute the commands to paint a representation of the requested content page to a display of the user device .

To avoid unnecessary processing by the headless browser and to reduce network traffic to the user device one or more of the objects of the content page can be separated into their own portions referred to herein as layers. Different layers of a content page can encompass different two dimensional areas of the content page e.g. cover different ranges of coordinates without overlapping . In some cases one layer may partially or completely overlap another layer e.g. a background layer may be partially overlapped by any number of other layers each of which may partially or completely overlap other layers etc. . Hardware independent graphics commands for individual layers can be generated such that they can be combined into a single representation by the client browser while also allowing repainting of a single layer separately from the other layers of the content page. In this way the representation of a single object can be updated separately from other objects and without re processing and or re painting of the other objects. In some embodiments as described above the hardware independent graphics commands may be Skia commands. Each individual layer may correspond to a different SkPicture which includes Skia commands that can be executed to display a representation of the object. Individual SkPictures can be generated stored transmitted executed and updated independently from other SkPictures even when multiple SkPictures are used to generate a single display on a user device .

The process begins at block . The process may begin upon receipt of a request from a client browser for a content page. The intermediary system may instantiate a headless browser instance to process and respond to the request or the intermediary system may assign the request to an existing headless browser instance. In some embodiments the client browser may be assigned to a particular headless browser instance for an entire browsing session or some portion thereof or the client browser may be reconnected to a headless browser instance after a period of inactivity.

At block the headless browser or some other module or component can obtain the requested content. As described in greater detail above the headless browser may obtain a base resource for the requested content from a content server e.g. origin server or CDN server and or a server side cache process the base resource to identify referenced resources obtain and process the referenced resources etc. The headless browser can generate a render tree model or some other processed version of the content.

At block the headless browser or some other module or component can determine whether to segment visual portions of the page into separate layers. is a flow diagram of an example process for using rules to segment visual portions of a content page into separate layers. Illustratively the process can be used to determine which nodes of a render tree should be separated out into individual layers based on the application of a set or cascade of segmentation rules. The specific rules shown in are illustrative only and are not intended to be limiting. In some embodiments the process may use fewer rules additional rules different rules etc.

The process begins at block . The headless browser may execute the process for each node in the render tree or for some subset thereof.

At decision block the graphics processing module or some other module or component can determine whether the current node includes object with a 3D or perspective transform. For example the object may have a CSS property for perspective transform. If the node includes such an object then the node should be rendered in a separate layer and the process proceeds to block . Otherwise the process continues to the subsequent rules at decision blocks below.

At decision block the graphics processing module or some other module or component can determine whether the current node includes an image animation video or canvas object. For example the node may include an animated GIF file or a video that was referenced by an HTML tag. The process can proceed to block where a separate layer is defined for the node. The separate layer in this case may include hardware independent graphics commands that cause display of the video in its native form or some optimized version thereof rather than hardware independent graphics commands for each frame of the video. In the case of Skia commands an SkPicture may be generated that is a wrapper for the video object. Transfer of such an SkPicture to the client browser may also include transfer of the video object in its native form. In some cases the video object or other object wrapped in a Skia command may be modified e.g. downscaled to reduce bandwidth or provide some other benefit . The video object itself may be transmitted to the client browser to reduce or eliminate the need for constant re generation and re transmission of Skia commands to the client browser in order to display the video while it is playing. By providing the video itself the video can be displayed and controlled e.g. paused reviewed scrubbed etc. by the client browser without requiring the additional processing of Skia commands. The same or a similar process may be performed for certain images interactive canvasses etc.

At decision block the graphics processing module or some other module or component can determine whether the current node includes references or requires processing by a composited plugin e.g. Flash . If the node includes such content a separate layer may be defined for the node.

At decision block the graphics processing module or some other module or component can determine whether the current node includes animation such as CSS animation for opacity or other effects such as accelerated CSS filters. If the node includes such content a separate layer may be defined for the node.

At decision block the graphics processing module or some other module or component can determine whether the current node includes certain interactive controls such as the drop down list shown in . Other examples of interactive controls include check boxes radio buttons command buttons and the like. If the node includes such an interactive control a separate layer may be defined for the node. The separate layer may include hardware independent graphics commands to paint the interactive control and may also include or reference metadata regarding how to respond to user interactions with the control. For example if the interactive control is a drop down list the layer may include data regarding the list of options to be presented when a user activates the drop down list. In this way the client browser can update the display of the content page at the user device without requiring round trip communication with the server to obtain graphics commands to update the display of the control. Synchronization data may still be transmitted to the server so that the representation of the content page in the headless browser can be updated to reflect the user interaction and modified display.

At decision block the graphics processing module or some other module or component can determine whether the current node has a descendent for which a separate layer has been defined. For example the element of the current node has a child element that has its own layer. If the node includes such an element a separate layer may be defined for the node.

At decision block the graphics processing module or some other module or component can determine whether the current node has a sibling with a lower z index for which a separate layer has been defined. For example the element of the current node is to be rendered on top of a separate layer. If the node includes such an element a separate layer may be defined for the node.

At block the graphics processing module or some other module or component can segment the current node into its own layer based on a decision made at one of decision blocks or based on the application of some other rule. The layer defined or generated for the current node at block can be separate from any other layers defined or generated at block for any other nodes of the content page or separate from a general layer associated with the content page. For example the layer may be or correspond to a separate SkPicture for the node.

If the process proceeds through decision blocks or blocks for any other rules without finding a rule satisfied by the current node then the element of the current node may be bundled with elements from other such nodes for rendering in a single SkPicture.

Returning to once the process of defining separate layers for individual elements of the render tree has been optionally performed the render tree can be traversed and hardware independent graphics commands can be generated for the individual nodes of the render tree. When Skia commands are used the Skia commands can be recorded as SkPictures and separate SkPictures can be recorded for each layer if there are multiple layers. Layout information can be generated to indicate to the client browser how the various SkPictures are to be composited for display.

At block the headless browser or some other module or component can generate layer identifiers for each layer defined in block or for some subset thereof. The layer identifiers can be used to uniquely identify layers cached either at the intermediary system or at the user device . In some embodiments the layer identifiers may be based on a hash of some or all of the graphics commands generated for the layer. For example once hardware independent graphics commands for a particular layer have been generated as an SkPicture or some other discrete unit of hardware independent graphics commands for a particular visual portion of a content page the SkPicture can be hashed to generate a layer identifier. In some embodiments the layer identifiers may be based on layout information associated with the layers. For example an identifier of a particular layer can be generated using a display coordinate size and or boundary of the layer. The layout information may also be hashed to generate the layer identifier.

In addition to the layer identifiers other properties may be generated for the layers. In some embodiments a TTL value may be generated or determined for each individual layer all layers associated with a content page all layers associated with a domain etc. For example the TTL value for a particular layer may be based on a TTL value of a resource e.g. image in the visual portion of the page represented by the layer. In some embodiments the TTL value may be independent of any TTL value associated with objects in the layer or content page. For example the TTL value may be based on an analysis of how often the visual content of the layer changes as observed by the intermediary system when processing the content page previously for the same user or client browser or for other users or client browsers .

At decision block the headless browser or some other module or component can determine whether one or more layers for the currently requested content page have been cached at the client browser or at a cache accessible to the client browser . In some embodiments the headless browser may maintain or otherwise have access to information regarding which layers have been provided to the client browser such as a listing of layer identifiers. The headless browser can determine for the layers of the requested content page which layers have been previously provided to the client browser and which of those layers is valid based on the TTL . In some embodiments the headless browser may transmit layer identifiers of each layer of the content page and may exclude high level graphics commands for each layer of the content page. The client browser can then request only those layers which are not present in the client cache. In this way total bandwidth may be minimized because no hardware independent graphics commands are sent unless they are needed. In some embodiments the client browser may send layer identifiers of some or all layers currently in the client side cache and the headless browser can then determine which layers to transmit to the client browser e.g. transmit only those layers not in the client side cache . For example the client browser may provide to the intermediary system in connection with a content page request layer identifiers for layers associated with the requested content page or the domain of the requested content page.

At block the headless browser or some other module or component can send to the client browser the layers e.g. the SkPictures or other sets of hardware independent graphics commands and corresponding layer identifiers for any layers that have not been previously provided to the client browser or for any layers that are invalid . In some embodiments the layer identifiers may not be sent to the client browser . Instead the client browser may generate the layer identifier locally. For example the client browser may use the same hashing algorithm as the headless browser and can therefore reference cache and otherwise work with the layer using the same layer identifier as the headless browser .

The hardware independent graphics commands for any given layer may have been generated in response to the current content request or they may be retrieved from a server side cache. In some embodiments the hardware independent graphics commands sent to the client browser for one or more layers of the currently requested content page may have been cached at the server side cache in connection with processing a request from a different user device for the content page or they may have been cached at the server side cache in connection with processing a request for a different content page altogether. For example multiple e.g. two or more content pages associated with a particular domain may share one or more common visual portions. Processing of the pages as described herein may therefore result in an identical or substantially identical set of hardware independent graphics commands for a layer that corresponds to the common visual portion. Hardware independent graphics commands generated for the layer corresponding to the common visual portion of one content page may be provided in response to requests for the other content pages that share the common visual portion. Because the hardware independent graphics commands may be identical the layer identifier based on the hash of the graphics commands or based on the layout properties of the layer may also be identical. In this way a layer identifier based on hardware independent graphics commands or other properties of the layer facilitates the use of the cached hardware independent graphics commands for the layer for each of the multiple pages.

At block the headless browser or some other module or component can send to the client browser the layer identifiers of any layers that have been previously provided to the client browser and which are still valid . In some embodiments the layer identifiers of certain layers may be provided instead of the hardware independent graphics commands even though the currently requested content page has never before been requested by the current client browser e.g. as long as the layer identified by the identifier has been previously provided to the client browser such as in response to a request for a different page .

At block the headless browser or some other module or component can update the server side cache with hardware independent graphics commands for layers of the currently requested content page.

The process begins at block . The client browser may execute the process in response to a request for content such as user input of a URL activation of a link or bookmark etc. At block the client browser can send a request for content to the intermediary system . In some embodiments as described above the client browser may provide layer identifiers or other information regarding which layers are currently in the client side cache e.g. layer identifiers for all valid layers in the cache layer identifiers for layers associated with the same domain as the requested content page layers associated with the requested content page etc. . For example the client browser may provide layer identifiers bundled with content page requests subsequent to content page requests or at some other time such as at the beginning of a browsing session.

At block the client browser can receive a response from the intermediary system . The response may include hardware independent graphics commands in lieu of unprocessed content items. In some embodiments as described above the content page may have been segregated into layers at the intermediary system . The hardware independent graphics commands for the individual layers may be sufficient to prepare a composite display of the multiple layers. For example the hardware independent graphics commands may reference coordinates or other location indicators that can be used to paint objects in the appropriate location on the display. In some embodiments the coordinates for hardware independent graphics commands of a layer may reference relative positions within the layer itself rather than positions within the overall composite display. In such cases layout information may be included in the response which indicates how the layers are to be composited for display by the client browser .

At decision block the remote graphics module or some other module or component can determine whether the response excludes hardware independent graphics commands for the requested content page or for some portion thereof e.g. one or more layers . If the response does not include hardware independent graphics commands for one or more layers of the content page the process can proceed to decision block .

At decision block the remote graphics module or some other module or component can determine whether the excluded hardware independent graphics commands have been cached in a client side or client accessible cache. In some embodiments the remote graphics module can use a layer identifier provided by the headless browser to query the cache for an excluded layer. As described above the hardware independent graphics commands for a particular layer may have been previously provided to the client browser in response to previous requests for the currently requested content page or some other content page. If the hardware independent graphics commands for all of the excluded layers are in the cache and are valid then the process can proceed to paint a representation of the content page at block . Otherwise if one or more of the excluded layers are not in the cache or are not valid then the process can proceed to obtain the excluded layers at block .

At block the remote graphics module or some other module or component can notify the intermediary system of the cache miss or can otherwise request the hardware independent graphics commands for the excluded portion s not found in the client side cache. For example the remote graphics module can transmit a notification including the layer identifier s of the excluded layer s to the intermediary system . The intermediary system can then provide the excluded layer s e.g. the hardware independent graphics commands for the excluded layers .

At block the remote graphics module or some other module or component can paint a representation of the requested content page by executing the high level graphics commands obtained from the intermediary system and or the client side cache.

At block a user may initiate some interaction with the displayed representation. Synchronization data regarding the user interaction or other modification to the displayed representation may be transmitted to the intermediary system . For example if a user has scrolled the content page or a portion thereof coordinates of the position to which the user scrolled coordinates corresponding to the current portion of the representation displayed in the viewport or some other information may be provided to the intermediary system .

At decision block the client browser can determine whether an update or some other information has been received from the intermediary system . The update may include hardware independent graphics commands generated by the interaction processing module or some other module or component of the intermediary system for the entire content page or for some portion thereof such as one or more layers. For example the headless browser may apply synchronization data to an instance of the content page that it is maintaining or the headless browser may otherwise perform some operation e.g. execution of JavaScript that causes some portion of the page e.g. one layer to change visually. Hardware independent graphics commands for that particular layer can be provided to the client browser without providing hardware independent graphics commands for other layers that have not changed visually. By providing graphics commands for only those layers that have changed bandwidth may be conserved. If an update or other information has been received the process may return to decision block for processing. Otherwise the process may return to block to process additional user interactions or end at block if no user interactions are received or of the client browser has been terminated.

In some embodiments hardware independent graphics commands are not cached by the intermediary system or by the user device . Instead the hardware independent graphics commands for a requested content page are generated in response to a request and provided to the client browser for execution without querying a cache generating a layer identifier etc.

In some embodiments origin servers CDN servers and other content sources may implement the systems and techniques described herein to provide hardware independent graphics commands directly to user devices . In this embodiment a client browser may provide information identifying it as capable of receiving and executing hardware independent graphics commands or the origin server may determine that the client browser is capable using other means. For example an origin server may launch a headless browser instance that maintains a representation of a content page hosted by the origin server. The headless browser instance can generate hardware independent graphics commands and a request for the content page can be served using the hardware independent graphics commands instead of the unprocessed content items. As another example the origin server may store hardware independent graphics commands e.g. serialized SkPictures that it transmits to client browsers in response to content requests. In this example the origin server may not execute a headless browser that produces the hardware independent graphics commands in response to content requests. The origin server may still use a headless browser to process user interactions provided updated graphics commands etc.

Depending on the embodiment certain acts events or functions of any of the processes or algorithms described herein can be performed in a different sequence can be added merged or left out altogether e.g. not all described operations or events are necessary for the practice of the algorithm . Moreover in certain embodiments operations or events can be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors or processor cores or on other parallel architectures rather than sequentially.

The various illustrative logical blocks modules routines and algorithm steps described in connection with the embodiments disclosed herein can be implemented as electronic hardware or combinations of electronic hardware and computer software. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or as software that runs on hardware depends upon the particular application and design constraints imposed on the overall system. The described functionality can be implemented in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the disclosure.

Moreover the various illustrative logical blocks and modules described in connection with the embodiments disclosed herein can be implemented or performed by a machine such as a general purpose processor device a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor device can be a microprocessor but in the alternative the processor device can be a controller microcontroller or state machine combinations of the same or the like. A processor device can include electrical circuitry configured to process computer executable instructions. In another embodiment a processor device includes an FPGA or other programmable device that performs logic operations without processing computer executable instructions. A processor device can also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration. Although described herein primarily with respect to digital technology a processor device may also include primarily analog components. For example some or all of the signal processing algorithms described herein may be implemented in analog circuitry or mixed analog and digital circuitry. A computing environment can include any type of computer system including but not limited to a computer system based on a microprocessor a mainframe computer a digital signal processor a portable computing device a device controller or a computational engine within an appliance to name a few.

The elements of a method process routine or algorithm described in connection with the embodiments disclosed herein can be embodied directly in hardware in a software module executed by a processor device or in a combination of the two. A software module can reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of a non transitory computer readable storage medium. An exemplary storage medium can be coupled to the processor device such that the processor device can read information from and write information to the storage medium. In the alternative the storage medium can be integral to the processor device. The processor device and the storage medium can reside in an ASIC. The ASIC can reside in a user terminal. In the alternative the processor device and the storage medium can reside as discrete components in a user terminal.

For example the processes and described with respect to may be embodied in a set of executable program instructions stored on one or more non transitory computer readable media such as one or more disk drives or solid state memory devices of the user device or a computing system with which the intermediary system is associated. When a process or is initiated the executable program instructions can be loaded into memory such as RAM and executed by one or more processors of the user device or computing system. In some embodiments the computing system may include multiple computing devices such as servers and the processes or portions thereof may be executed by multiple servers serially or in parallel.

Conditional language used herein such as among others can could might may e.g. and the like unless specifically stated otherwise or otherwise understood within the context as used is generally intended to convey that certain embodiments include while other embodiments do not include certain features elements and or steps. Thus such conditional language is not generally intended to imply that features elements and or steps are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding with or without other input or prompting whether these features elements and or steps are included or are to be performed in any particular embodiment. The terms comprising including having and the like are synonymous and are used inclusively in an open ended fashion and do not exclude additional elements features acts operations and so forth. Also the term or is used in its inclusive sense and not in its exclusive sense so that when used for example to connect a list of elements the term or means one some or all of the elements in the list.

Disjunctive language such as the phrase at least one of X Y Z unless specifically stated otherwise is otherwise understood with the context as used in general to present that an item term etc. may be either X Y or Z or any combination thereof e.g. X Y and or Z . Thus such disjunctive language is not generally intended to and should not imply that certain embodiments require at least one of X at least one of Y or at least one of Z to each be present.

While the above detailed description has shown described and pointed out novel features as applied to various embodiments it can be understood that various omissions substitutions and changes in the form and details of the devices or algorithms illustrated can be made without departing from the spirit of the disclosure. As can be recognized certain embodiments described herein can be embodied within a form that does not provide all of the features and benefits set forth herein as some features can be used or practiced separately from others. The scope of certain embodiments disclosed herein is indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

