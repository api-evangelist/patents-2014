---

title: Load scheme for shared register in GPU
abstract: Techniques are described for determining whether data of a variable for each of a plurality of graphics items is same. If determined that the data is the same, the techniques store the data in a storage location of a specialized shared general purpose register that is associated with the variable.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09633411&OS=09633411&RS=09633411
owner: QUALCOMM Incorporated
number: 09633411
owner_city: San Diego
owner_country: US
publication_date: 20140626
---
This disclosure relates to data storage and more particularly to data storage techniques in registers.

Processing units such as graphics processing units GPUs include processing elements and a general purpose register GPR that stores data for the execution of an instruction. In some examples a processing element executes instructions for processing one item of data and respective processing elements store the data of the item or the resulting data of the item from the processing in the GPR. An item of data may be the base unit on which processing occurs. For instance in graphics processing a vertex of a primitive is one example of an item and a pixel is another example of an item. There is graphics data associated with each vertex and pixel e.g. coordinates color values etc. .

There may be multiple processing elements within a processor core of the processing element allowing for parallel execution of an instruction e.g. multiple processing elements execute the same instruction at the same time . In some cases each of the processing elements stores data of an item in the GPR and reads the data of the item from the GPR even if the data is the same for multiple items.

In general the disclosure describes techniques for storing uniform data in a shared general purpose register SGPR of a graphics processing unit GPU . Each processing unit of a processing core may read or write data of an item also referred to as a fiber which is a base unit on which processing occurs. Each item may be associated with multiple variables and these variables of an item together form the data of a fiber.

In some examples a plurality of items referred to as a wave may have some data that is the same for each of the items in the wave. The techniques described in this disclosure may determine whether at least some data of the items in a wave is the same. In such cases the processing core may store the data which is the same for all items in a wave in the SGPR and instructions executing on the processing core may read the data from the SGPR. In this way rather than reading and writing data to GPRs of each of the items the techniques may read and write data from the SGPR which may reduce the number of times the GPR is accessed and thereby reduce power consumption.

In one example the disclosure describes a method of storing data the method comprising determining whether data of a variable for a plurality of graphics items is the same wherein the variable is needed for processing each of the plurality of graphics items wherein the plurality of graphics items are processed with respective processing elements of a shader core of a graphics processing unit GPU during execution of a shader program and wherein each of the graphics items is a base unit on which processing occurs storing the data in a storage location of a shared general purpose register SGPR associated with the variable if the data of the variable of the plurality of graphics items is the same and storing data for the variable of each of the plurality of graphics items in multiple storage locations of a general purpose register GPR separate from the SGPR if the data of the variable of at least two of the plurality of graphics items is not the same.

In one example the disclosure describes a device for processing data the device comprising a graphics processing unit GPU the GPU comprising a shader core the shader core comprising a control unit a plurality of processing elements a shared general purpose register SGPR and a general purpose register GPR wherein the control unit is configured to determine whether data of a variable for a plurality of graphics items is the same wherein the variable is needed for processing each of the plurality of graphics items wherein the plurality of graphics items are processed with respective processing elements of the shader core of the GPU during execution of a shader program and wherein each of the graphics items is a base unit on which processing occurs store the data in a storage location of the SGPR associated with the variable if the data of the variable of the plurality of graphics items is the same and store data for the variable of each of the plurality of graphics items in multiple storage locations of the GPR separate from the SGPR if the data of the variable of at least two of the plurality of graphics items is not the same.

In one example the disclosure describes a graphics processing unit GPU comprising a shader core the shader core comprising a plurality of processing elements a shared general purpose register SGPR a general purpose register GPR separate from the SGPR and a control unit configured to determine whether data of a variable for a plurality of graphics items is the same wherein the variable is needed for processing each of the plurality of graphics items wherein the plurality of graphics items are processed with respective processing elements of the shader core of the GPU during execution of a shader program and wherein each of the graphics items is a base unit on which processing occurs store the data in a storage location of the SGPR associated with the variable if the data of the variable of the plurality of graphics items is the same and store data for the variable of each of the plurality of graphics items in multiple storage locations of the GPR separate from the SGPR if the data of the variable of at least two of the plurality of graphics items is not the same.

In one example the disclosure describes a computer readable storage medium having instructions stored thereon that when executed cause one or more processors to determine whether data of a variable for a plurality of graphics items is the same wherein the variable is needed for processing each of the plurality of graphics items wherein the plurality of graphics items are processed with respective processing elements of a shader core of a graphics processing unit GPU during execution of a shader program and wherein each of the graphics items is a base unit on which processing occurs store the data in a storage location of a shared general purpose register SGPR associated with the variable if the data of the variable of the plurality of graphics items is the same and store data for the variable of each of the plurality of graphics items in multiple storage locations of a general purpose register GPR separate from the SGPR if the data of the variable of at least two of the plurality of graphics items is not the same.

In one example the disclosure describes a device for processing data the device comprising a graphics processing unit GPU the GPU comprising a shader core the shader core comprising a control unit a plurality of processing elements a shared general purpose register SGPR and a general purpose register GPR wherein the control unit comprises means for determining whether data of a variable for a plurality of graphics items is the same wherein the variable is needed for processing each of the plurality of graphics items wherein the plurality of graphics items are processed with respective processing elements of the shader core of the GPU during execution of a shader program and wherein each of the graphics items is a base unit on which processing occurs means for storing the data in a storage location of the SGPR associated with the variable if the data of the variable of the plurality of graphics items is the same and means for storing data for the variable of each of the plurality of graphics items in multiple storage locations of the GPR separate from the SGPR if the data of the variable of at least two of the plurality of graphics items is not the same.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description drawings and claims.

Parallel processing units such as graphics processing unit GPUs that are configured to perform many operations in parallel e.g. at the same time include one or more processor cores e.g. shader cores for a GPU that execute instructions of one or more programs. For ease of description the techniques described in the disclosure are described with respect to a GPU or a general purpose GPU GPGPU . However the techniques described in this disclosure may be extended to parallel processing units that are not necessarily GPUs or GPGPUs as well as non parallel processing units e.g. ones not specifically configured for parallel processing .

The GPU may be designed with a single instruction multiple data SIMD structure. In the SIMD structure a shader core includes a plurality of SIMD processing elements where each SIMD processing element executes instructions of the same program but on different data. A particular instruction executing on a particular SIMD processing element is referred to as a thread. Each SIMD processing element may be considered as executing a different thread because the data for a given thread may be different however the thread executing on a processing element is the same instruction of the same program as the instruction executing on the other processing elements. In this way the SIMD structure allows the GPU to perform many tasks in parallel e.g. at the same time .

In the SIMD structure the shader core processes multiple fibers simultaneously using the same operation defined by the single instruction. A fiber refers to a basic item for which processing occurs. For example for a vertex shader executing on the shader core a fiber would be a vertex. For a pixel or fragment shader executing on the shader core a fiber would be a pixel.

Part of SIMD processing includes reading and writing of data needed for processing the multiple fibers. One example of data needed for processing multiple fibers is attribute data of the fibers e.g. attribute data of a vertex or attribute data of a pixel . For ease of illustration the techniques are described with respect to attribute data but the techniques are not so limited. The techniques can be extended to various other data types and generally to data that is needed for processing a fiber. This data may also include values such as counter values or other types of values that are needed for processing a fiber.

For example to process a fiber the shader core may process a plurality of variables associated with the fiber. One example of the variables associated with a fiber is the attributes associated with a fiber. One example of the data of a variable is the attribute data of an attribute.

In some shader core designs the shader core reads data that is the same for most of the fibers i.e. uniform data over and over again. For instance data of one or more variables e.g. attribute data of one or more attributes that needs be read for the fibers is non divergent. The shader core then stores this data in storage locations assigned to the fiber within a general purpose register GPR where the GPR is located within the shader core.

As one example each fiber is associated with a plurality of attribute data. For a vertex or a pixel the attribute data includes coordinates color data opacity etc. as a few examples. However there are other types of data needed to process the fiber as well and the techniques are applicable to such data types. While all of the attribute data may be not be the same for a plurality vertices or pixels in some cases some of the attribute data may be same for the plurality of vertices or pixels. The data e.g. attribute data in this example that is the same for the plurality of vertices or pixels is referred to as uniform data. The data that is different for at least two of the vertices or pixels is referred to as divergent data i.e. the data for one vertex is different than the data for at least one other vertex .

Rather than reading the uniform data over and over again for storage in the GPRs and repetitively reading the GPRs for the uniform data the techniques described in this disclosure determine whether data to be read for a plurality of fibers the plurality of fibers being referred to as a wave is non divergent. If the data to be read for the wave is non divergent the techniques described in disclosure read the uniform data one time e.g. a single time for storage in a specialized shared general purpose register SGPR . The shader core then reads the uniform data from the SGPR rather than repeatedly accessing the GPR. The SGPR is a shared GPR in the sense that the SGPR stores data that is needed for all of the fibers of the wave e.g. stores attribute data that is shared by all of the fibers of a wave .

The number of fibers that form a wave may be a function of the parallel processing capabilities of the shader core. For instance if the shader core is configured to process thirty two fibers as merely one example simultaneously then the number of fibers in a wave equals thirty two.

There may be various ways in which to determine whether some data of the fibers is uniform across a wave. As one example the compiler executing on a processor may determine whether a particular instruction of a shader program will require access to uniform data for a wave e.g. an attribute that is the same for the fibers in the wave . In this case the compiler may encode an instruction indicating the uniform data access. Hardware of the GPU may read this instruction and store the uniform data in the SGPR for the wave e.g. store the attribute data that is the same for all of the fibers in the wave in the SGPR .

The compiler may not always be able to determine whether data access is uniform across a wave for a particular instruction. However the compiler may be able to determine that there is a likelihood for a particular instruction to require accessing uniform data across a wave. In such examples the compiler may encode an instruction identifying a particular instruction as a candidate for using the SGPR. For the identified instruction hardware of the GPU may determine whether memory addresses to be accessed for data of the fibers of a wave are the same. If the memory addresses are the same the hardware may set an SGPR flag value as 1 retrieve the data once and store the uniform data in the SGPR. When the data is needed for processing the hardware may read the flag value and determine whether the data should be read from the SGPR or the GPR.

In this way the techniques described in this disclosure may reduce the number of times the GPR needs to be accessed. This in turn may increase power and processing efficiencies. For example the GPR may be a relatively large memory storage unit that stores the data e.g. values for all variables e.g. attributes needed for a plurality of different fibers. One SGPR on the other hand may store the data for a single variable e.g. single attribute that is the same for a wave of fibers. Accordingly the SGPR may be smaller in size than the GPR. In some cases accessing the SGPR may require less power than accessing the GPR. By reducing the number of times the GPR needs to be accessed by accessing the SGPR instead the techniques may reduce the amount of power the GPU consumes.

As described above a fiber refers to a base unit on which processing occurs. To avoid confusion this disclosure refers to a fiber as a graphics item to indicate a base item on which a GPU performs processing. Accordingly a plurality of graphics items may form a graphics wave. However in some examples the GPU may not necessarily perform graphics operations. For such cases the term graphics item is meant to refer to a base unit on which the GPU performs processing even if such a graphics item is not for graphics processing. In other words a graphics item is a base unit on which the GPU performs processing and examples of a graphics item include an item for graphics related processing or for non graphics related processing.

In the example of device includes processor graphics processing unit GPU and system memory . In some examples such as examples where device is a mobile device processor and GPU may be formed as an integrated circuit IC . For example the IC may be considered as a processing chip within a chip package such as a system on chip SoC . In some examples processor and GPU may be housed in different integrated circuits i.e. different chip packages such as examples where device is a desktop or laptop computer. However it may be possible that processor and GPU are housed in different integrated circuits in examples where device is a mobile device.

Examples of processor and GPU include but are not limited to one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Processor may be the central processing unit CPU of device . In some examples GPU may be specialized hardware that includes integrated and or discrete logic circuitry that provides GPU with massive parallel processing capabilities suitable for graphics processing. In some instances GPU may also include general purpose processing capabilities and may be referred to as a general purpose GPU GPGPU when implementing general purpose processing tasks i.e. non graphics related tasks .

For purposes of illustration the techniques described in this disclosure are described with GPU . However the techniques described in this disclosure are not so limited. The techniques described in this disclosure may be extended to other types of parallel processing units e.g. processing units that provide massive parallel processing capabilities even if not for graphics processing . Also the techniques described in this disclosure may be extended to processing units not specifically configured for parallel processing.

Processor may execute various types of applications. Examples of the applications include web browsers e mail applications spreadsheets video games or other applications that generate viewable objects for display. System memory may store instructions for execution of the one or more applications. The execution of an application on processor causes processor to produce graphics data for image content that is to be displayed. Processor may transmit graphics data of the image content to GPU for further processing.

As an example the execution of an application on processor causes processor to produce vertices of primitives where the interconnection of primitives at respective vertices forms a graphical object. In this example the graphics data that processor produces are the attribute data for the attributes of the vertices. For example the application executing on processor may generate color values opacity values coordinates etc. for the vertices which are all examples of attributes of the vertices. There may be additional attributes as well and in some examples the application need not produce all of the example attributes. In general the techniques are extendable to data types e.g. counters other than attribute data and the techniques should not be considered limited to attribute data or limited to examples of attribute data such as color values opacity values coordinates etc.

In some non graphics related examples processor may generate data that is better suited to be processed by GPU . Such data need not be for graphics or display purposes. For instance processor may output data on which matrix operations need to be performed by GPU and GPU may in turn perform the matrix operations.

In general processor may offload processing tasks to GPU such as tasks that require massive parallel operations. As one example graphics processing requires massive parallel operations and processor may offload such graphics processing tasks to GPU . However other operations such as matrix operations may also benefit from the parallel processing capabilities of GPU . In these examples processor may leverage the parallel processing capabilities of GPU to cause GPU to perform non graphics related operations.

Processor may communicate with GPU in accordance with a particular application processing interface API . Examples of such APIs include the DirectX API by Microsoft the OpenGL or OpenGL ES by the Khronos group and the OpenCL however aspects of this disclosure are not limited to the DirectX the OpenGL or the OpenCL APIs and may be extended to other types of APIs. Moreover the techniques described in this disclosure are not required to function in accordance with an API and processor and GPU may utilize any technique for communication.

Device may also include display user interface and transceiver module . Device may include additional modules or units not shown in for purposes of clarity. For example device may include a speaker and a microphone neither of which are shown in to effectuate telephonic communications in examples where device is a mobile wireless telephone. Furthermore the various modules and units shown in device may not be necessary in every example of device . For example user interface and display may be external to device in examples where device is a desktop computer. As another example user interface may be part of display in examples where display is a touch sensitive or presence sensitive display of a mobile device.

Display may comprise a liquid crystal display LCD a cathode ray tube CRT display a plasma display a touch sensitive display a presence sensitive display or another type of display device. Examples of user interface include but are not limited to a trackball a mouse a keyboard and other types of input devices. User interface may also be a touch screen and may be incorporated as a part of display . Transceiver module may include circuitry to allow wireless or wired communication between device and another device or a network. Transceiver module may include modulators demodulators amplifiers and other such circuitry for wired or wireless communication.

System memory may be the memory for device . System memory may comprise one or more computer readable storage media. Examples of system memory include but are not limited to a random access memory RAM an electrically erasable programmable read only memory EEPROM flash memory or other medium that can be used to carry or store desired program code in the form of instructions and or data structures and that can be accessed by a computer or a processor.

In some aspects system memory may include instructions that cause processor and or GPU to perform the functions ascribed in this disclosure to processor and GPU . Accordingly system memory may be a computer readable storage medium having instructions stored thereon that when executed cause one or more processors e.g. processor and GPU to perform various functions.

In some examples system memory may be a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that system memory is non movable or that its contents are static. As one example system memory may be removed from device and moved to another device. As another example memory substantially similar to system memory may be inserted into device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

For example as described in more detail elsewhere in this disclosure system memory may store the code for a compiler that executes on processor that performs techniques of one or more examples described in this disclosure. System memory may also store code for shader programs e.g. a vertex shader a pixel or fragment shader a compute shader etc. that execute on a shader core of GPU .

For example a compiler executing on processor may determine whether data for a variable e.g. attribute date for an attribute of a plurality of graphics items is the same or has a likelihood to be the same. The compiler may indicate whether the data of the plurality of graphics items is the same or has a likelihood to be the same. GPU may receive the indication and a shader core of GPU may read and write the data that is the same for the plurality of graphics items from a specialized shared general purpose register SGPR rather than a GPR of the shader core.

The term graphics item is used in this disclosure to refer to a base unit on which GPU performs parallel processing. GPU may process a plurality of graphics items in parallel e.g. at the same time . For example a vertex shader may process a vertex and GPU may execute a plurality of instances of the vertex shader in parallel to process a plurality of vertices at the same time. Similarly a pixel or fragment shader may process a pixel of a display and GPU may execute a plurality of instances of the pixel shader in parallel to process a plurality of pixels of the display at the same time. A vertex and a pixel are examples of a graphics item.

For non graphics related applications the term graphics item also refers to smallest unit on which GPU performs processing. However such processing may not be graphics related. According the term graphics item is meant to refer to items that a graphics processing unit e.g. GPU or a general purpose graphics processing unit e.g. examples where GPU is functioning as a GPGPU is to process in parallel. The graphics item may be used for graphical or non graphical purposes.

In some cases the term fiber is referred to as a base unit on which GPU performs processing. The term fiber is synonymous with graphics item. The massive parallel processing capabilities of GPU allows GPU to process a plurality of fibers at the same time. A plurality of fibers that GPU processes at the same time is referred to as a wave. In this disclosure a graphics wave is synonymous with a wave of fibers. In other words a plurality of graphics items form a graphics wave.

As described above GPU provides massive parallel processing capabilities. One way in which GPU provides such parallel processing capabilities is via a single instruction multiple data SIMD structure. In the SIMD structure GPU executes a plurality of instances of the same program. For instance graphics processing and some non graphics related processing require the same operations to be performed but on different data.

For example GPU may execute shader programs referred to simply as shaders that perform graphics or non graphics related tasks. GPU includes at least one shader core and the shader programs execute on the shader core. For brevity and ease of description GPU is described as performing graphics related tasks but may similarly perform non graphics related tasks. GPU may execute multiple instances of the shader program to process multiple graphics items at one time. One example of a shader program is a vertex shader. GPU may execute multiple instances of the vertex shader to process multiple vertices at one time e.g. in parallel . In general the operations that need to be performed for a vertex are the same as the operations that need to be performed for other vertices.

Although the operations that need to be performed for the vertex is the same one or more attribute data of each of the vertices may be different. For example each graphics item e.g. a vertex or a pixel is associated with a plurality of attributes. Each attribute includes attribute data. As an example a vertex of a primitive or a pixel of a display may be defined by coordinates e.g. x y z w . Each of the vertices and pixels may also be defined by colors e.g. a red component a green component blue component RGB . There may also be an opacity value for each vertex or pixel e.g. an alpha value . The coordinates color and opacity are all examples of attributes of a graphics item e.g. fiber and there may be more or fewer attributes than the examples.

As described above the attributes should not be considered limited to coordinates color and opacity. Coordinates color and opacity are provided merely to assist with understanding. However for some cases the attributes of a graphical item may be limited to specific data types e.g. due to the manner in which a shader program is programmed or due to the manner in which GPU is designed .

In general each graphics item may be associated with a plurality of variables and the plurality of variables is needed for processing each of the graphics items. One example of the plurality of variables is the attributes associated with a vertex or pixel. For each variable there may be data e.g. values that define the variable. One example of the data is the attribute data associated with each attribute. In this example the attributes associated with the vertices or pixels are needed for processing each of the vertices and pixels. To process the attributes GPU processes the attribute data of the attributes.

For ease of description the techniques are described with reference to attribute data associated with attributes needed for processing a vertex or a pixel. However the techniques described in this disclosure are applicable generally to data associated with variables needed to process a graphics item and the attribute data associated with attributes for a vertex or a pixel is provided for ease of understanding.

For instance one of the functions of the vertex shader is to multiply the coordinates with a projection matrix PRJ matrix. This PRJ matrix may be an example of the attribute of the vertices. For many vertices in a graphical object the PRJ matrix may be the same. For instance the color values and the coordinates may be different but the PRJ matrix may be the same. This PRJ matrix may be considered as an example of OpenGL vertex instance data.

In the techniques described in this disclosure a shader core of GPU may be configured to determine whether attribute data for one or more attributes is the same for a plurality of graphics items e.g. the graphics items of a graphics wave . If the attribute data is the same the shader core of GPU may store the attribute data in a shared general purpose register SGPR that is shared by processing elements of the shader core of GPU so that the attribute data can be read from the SGPR rather than a GPR of the processing elements.

For example to execute the multiple instances of a shader program the shader core of GPU includes a plurality of processing elements and each processing element may execute one instruction of one instance of the shader program. For example each processing element may execute a first instruction of the shader program at the same time. In this sense each processing element may be considered as executing a thread of the shader program where the thread is one instruction of the shader program for a given graphics item.

In some examples a general purpose register GPR stores data for the variables of the graphics items that are to be processed by the processing elements. For instance each processing element may execute instructions to process one graphics item and the GPR stores the attribute data for the attributes of the graphics items that are to be processed by respective processing elements. As described in more detail if the attribute data of an attribute is the same for all graphics items in a graphics wave and the attributed data is stored in the SGPR there may be computational and power efficiency gains by accessing the data from the SGPR rather than the GPR. To assist with understanding the following describes an example of storage in a GPR.

As an example shader core may include thirty two processing elements and each may execute one instance of a shader program to process one graphics item. GPR may store data for the graphics items. For instance GPR may store attribute data for nine attributes for thirty two graphics items. However GPR may store data for more or less than nine attributes for the thirty two graphics items. Also GPR may store data that is not associated with an attribute of the graphics items but is the data for a variable needed for processing the graphics items.

In the example illustrated in the graphics items e.g. fibers are identified as P P which may be vertices. The attribute is identified by the variable following the graphics item identifier. For example P.X refers to the x coordinate for the P graphics item P.Y refers to the y coordinate for the P graphics item and so forth. P.R P.G P.B and P.A refer to the red component green component blue component and opacity of the P graphics item respectively. The other graphics items e.g. P P are similarly identified.

In other words in vertices P P are each associated with a plurality of variables. As one example each of vertices P P is associated with a variable that identifies the x coordinate P.X to P.X . Each of vertices P P is associated with a variable that identifies the y coordinate P.Y to PY and so forth. Each one of these variables is needed for processing each of the plurality of graphics items. For instance the variable that identifies the x coordinate is needed for processing each of vertices P P.

As also illustrated in each of the graphics items also includes a PRJ attribute. The PRJ attribute is a projection matrix that a vertex shader executing on processing elements of shader core may utilize. In this example the PRJ attribute is another variable that is needed for processing each of vertices P P. For example the vertex shader may multiply the projection matrix with the respective coordinates e.g. multiply P.PRJ with P.X P.Y P.Z and P.W .

In this sense GPR may be considered as being both deep and wide. For instance GPR can store attribute data for many attributes e.g. deep and can store attribute date for many graphics items e.g. wide . While having deep and wide GPRs may be beneficial there may also be some potential drawbacks. For example for larger sized GPR the time needed for accessing values e.g. data may be greater than for smaller sized GPRs causing extra data read pipelines in the processing element e.g. the processing element being idle while data is being read . Also accessing the GPR requires the processing element and hence GPU to consume power and the amount of power consumption may be proportional to the size of the GPR.

It should be understood that there may be various units in which GPU may store data e.g. values . GPU may store data in system memory or may store data in local memory e.g. cache . GPR of shader core is distinct from both system memory and the local memory of GPU . For example system memory is accessible by various components of device and these components use system memory to store data. The local memory of GPU is accessible by various components of GPU and these components use the local memory of GPU to store data. GPR however may only be accessible by components of shader core and may only store data for the processing elements of shader core .

For instance the local cache memory of GPU may require GPU to determine cache hits and the cache memory may be associated in various ways to system memory . This may require GPU to perform various cache hit miss tests use tags to maintain addresses and various other storage managing tasks with the cache memory. GPR on the other hand may be local to within and dedicated to shader core and may not need special memory management like local cache memory or system memory .

In some cases the attribute data for one or more attributes of the graphics items stored in GPR may be the same. For example each of graphics items P P may be considered as a fiber and graphics items P P may be considered as a wave also referred to as a graphics wave . In some examples the attribute data for one or more attributes in a graphic wave may be the same.

For instance graphics items P P may be vertices and may form a vertex wave of thirty two vertices. In some cases a projection matrix PRJ matrix may be the same for all thirty two vertices. As an example the application executing on processor may determine that GPU should render a bowl turned 90 so that the open side of the bowl is facing the viewer. In this example the projection for many of the vertices inside the bowl may be the same but the projection for some of the vertices on the edge e.g. near or on the rim of the bowl may be different. In this example if graphic items P P are inside the bowl then the PRJ matrix for P P is the same e.g. P.PRJ is the same as P.PRJ P.PRJ .

In some techniques regardless of whether the attribute data for an attribute is the same across the graphics wave shader core requests the attribute data and stores the attribute data in GPR . For example shader core executes instructions to retrieve the attribute data on a per graphics item basis for storage in GPR . Shader core may issue memory requests for the attribute data for each graphics item e.g. each fiber serially and store the attribute data per graphics item e.g. per fiber into GPR . However for a SIMD structure such as that of shader core it may not be power efficient to store uniform data per wave in per graphics item e.g. per fiber GPR e.g. store attribute data that is the same for the graphics items of a graphics wave .

For instance for the P.PRJ to P.PRJ attribute data in some techniques shader core may issue memory requests serially for P.PRJ to P.PRJ. As an example a memory storage unit external to shader core may store the projection matrix. This memory storage unit external to shader core may be a local memory of GPU or even system memory . Shader core may issue memory requests to this memory storage unit for each graphics item P P to receive the projection matrix for each graphics item P P.

For example shader core executes a first instruction to request the projection matrix for graphics item P based on the memory address where the projection matrix for graphics item P is stored. Shader core executes a second instruction to request the projection matrix for graphics item P based on the memory address where the projection matrix for graphics item P is stored and so forth. If the projection matrix is the same for graphics items P P then the memory address in the respective instructions requesting the projection matrix for each of graphics items P P is likely to be same.

Shader core may then receive each one of P.PRJ to P.PRJ attribute data and store P.PRJ to P.PRJ attribute data in GPR as illustrated in . In this example the PRJ matrix may be considered as a constant load e.g. data that is uniform for the graphics items of a graphics wave . In many cases the constant load for a constant buffer load e.g. for loading attribute data into GPR is non divergent e.g. P.PRJ to P.PRJ are uniform meaning the same . However shader core may nevertheless request and read the projection matrix multiple times and store the same projection matrix as P.PRJ to P.PRJ in GPR .

In accordance with the techniques described in this disclosure GPU may be configured to determine whether data for one or more variables of graphics items in a graphic wave is uniform across the graphic wave. In such examples rather than storing the uniform data for the one or more variables in GPR GPU may store the uniform data in a specialized shared GPR SGPR .

For instance shader core may include an SGPR. The SGPR may include a plurality of storage locations where each storage location is associated with one attribute of the plurality of attributes of the graphics items. For instance as illustrated in each graphics item P P includes nine attributes PRJ x y z w R G B and A . In this example the SGPR may include nine storage locations where the first location of the SGPR is associated with PRJ attribute the second location of the SGPR is associated with the x coordinate and so forth.

As an illustrative example the first storage location of the SGPR may be associated with the first two rows of GPR for P.PRJ to P.PRJ. The second storage location of the SGPR may be associated with the next two rows for GPR for P.X to P.X and so forth. It should be understood that the first two storage locations of the SGPR being associated with the first two groups of two rows of GPR is provided for purposes of illustration and should not be considered limiting.

In some examples the first storage location of the SGPR may be associated with the Nth grouping of two rows of GPR . As another example rather than thirty two graphics items in a graphics wave there may be only sixteen graphics items in a graphics wave e.g. fibers P P are processed in parallel and fibers are not processed in parallel with P P . In this example the first storage location of the SGPR may be associated with the first row of GPR and so forth however like before any storage location in the SGPR may be associated with any grouping of attributes. In other words one storage location in the SGPR is associated with one variable for the graphics items in a graphics wave.

In this manner the SGPR may be smaller than the GPR. For example the SGPR may be as deep as the GPR but may not be as wide. In the above example the SGPR included storage locations for each of the attribute and therefore the SGPR may be as deep as the GPR. However each row of the SGPR may be configured to store only one attribute data for one attribute. For example in two rows of GPR can store up to thirty two x coordinates e.g. thirty two scalar data per wave if each x coordinate requires eight bits then the two rows of GPR store 256 bits 8 32 or 128 bits per row. If the x coordinates are the same for each of graphics items P P then the SGPR may store a single 8 bit value. Accordingly where each row of GPR may be 128 bits wide each row of the SGPR may be only 8 bits wide.

As described above if the data for a variable of the graphics items in a graphics wave is uniform GPU stores the data in the SGPR. For example assume the PRJ matrix is the same for the graphics wave. In this example a shader core of GPU may store the attribute data e.g. PRJ matrix in a storage location of the SGPR associated with the attribute e.g. PRJ if the attribute data of the attribute of the plurality of graphics items is the same. In some examples it may be possible for GPU to store the uniform attribute data in the SGPR and in GPR . When GPU needs to read the attribute data GPU may read the attribute data e.g. PRJ matrix from the SGPR rather than GPR.

The above described an example where the PRJ matrix may be stored in the SGPR. The PRJ matrix is generally associated with graphical functions. However the techniques described in this disclosure are not so limited only to graphical functions.

For instance in some examples the techniques may also be usable for OpenCL per work group WG constant data such as work group identifier WG ID . For example in OpenCL a program that executes on GPU is referred to as a kernel and a kernel may be split into multiple work groups where one work group executes at a time per processing element of a shader core of GPU described in more detail below as indicated by the WG ID. The kernel may use the WG ID to compute each work item ID and address for loading storing of the data needed for the work item. The WG ID may be constant e.g. uniform or the same for all work items in a work group. In some examples the WG ID may be loaded into the SGPR to save GPR file foot print and save access power.

Moreover the techniques described in this disclosure may be extended for purposes in graphical applications other than storage of the PRJ matrix. For example the techniques described in this disclosure may be extended for the loading of graphics instance identifier ID and instance data. For instance in OpenGL a drawInstancePrimitives function may be split into multiple instances when executed e.g. a compiler as described in may split this function into multiple instances . For each instance of the drawInstancePrimitives there is an instance ID and some attribute data e.g. could be a variety of vertex attribute data type that is common e.g. the same or uniform to all objects in the instance. A vertex shader may apply these common attributes and instance ID and therefore it may be possible to store these common attributes and instance ID in the SGPR rather than GPR to achieve power savings as well as a reduction in the amount of data stored in the GPR.

In this way with the SGPR the techniques may reduce the number of times GPR needs to be accessed both for writing data to and reading data from. Rather when available the techniques may read the uniform data for a graphics wave from the SGPR. Accessing the SGPR may require less power than access GPR due to the smaller size of the SGPR. Also because GPU may determine whether the data is uniform e.g. the same for a variable of the graphics items in a graphics wave when the data is requested the techniques may reduce the number of times load instructions e.g. instruction to retrieve attribute data need to be executed.

For instance the techniques described in this disclosure promote power saving by reducing per fiber access for uniform data to per wave access for uniform data. Also the techniques described in this disclosure promote performance enhancement by reducing redundant per fiber constant load instruction e.g. reducing load instruction for uniform data processing as well as reducing the issuance and writing back cycles that are wasted for repetitive storing of data that is the same for the entire graphics wave.

As described above the software or firmware executing on GPU may be referred to as shader programs or simply shaders and the shader programs may execute on shader core of GPU . Although only one shader core is illustrated in some examples GPU may include one or more shader cores similar to shader core . Fixed function pipeline includes the fixed function units. Shader core and fixed function pipeline may transmit and receive data from one another. For instance the processing pipeline may include shader programs executing on shader core that receive data from a fixed function unit of fixed function pipeline and output processed data to another fixed function unit of fixed function pipeline .

Shader programs provide users with functional flexibility because a user can design the shader program to perform desired tasks in any conceivable manner. The fixed function units however are hardwired for the manner in which the fixed function units perform tasks. Accordingly the fixed function units may not provide much functional flexibility.

Examples of the shader programs include vertex shader fragment shader and compute shader . Vertex shader and fragment shader may be shader programs for graphics related tasks and compute shader may be a shader program for a non graphics related task. In some examples only graphics related shader programs like vertex shader and fragment shader may be used. In some examples only non graphics related shader programs like compute shader may be used. There are additional examples of shader programs such as geometry shaders which are not described for purposes of brevity.

Graphics driver executing on processor may be configured to implement an application programming interface API . In such examples the shader programs e.g. vertex shader fragment shader and compute shader may be configured in accordance with the same API as graphics driver . Although not illustrated system memory may store the code for graphics driver that processor retrieves from system memory for execution. Graphics driver is illustrated in a dashed box to indicate that graphics driver is software executing on hardware e.g. processor in this example. However some or all of the functionality of graphics driver may be implemented as hardware on processor .

In some examples system memory may store the source code for one or more of vertex shader fragment shader and compute shader . In these examples compiler executing on processor may compile the source code of these shader programs to create object or intermediate code executable by shader core of GPU during runtime e.g. at the time when these shader programs need to be executed on shader core . In some examples compiler may pre compile the shader programs and store the object or intermediate code of the shader programs in system memory .

System memory may store the code for compiler that processor retrieves from system memory for execution. In the example of compiler is illustrated in a dashed box to indicate that compiler is software executing on hardware e.g. processor in this example. However some functionality of compiler may be implemented as hardware on processor in some examples.

Graphics driver may be configured to allow processor and GPU to communicate with one another. For instance when processor offloads graphics or non graphics processing tasks to GPU processor offloads such processing tasks to GPU via graphics driver .

As an example processor may execute a gaming application that produces graphics data and processor may offload the processing of this graphics data to GPU . In this example processor may store the graphics data in system memory and graphics driver may instruct GPU with when to retrieve the graphics data from where to retrieve the graphics data in system memory and when to process the graphics data. Also the gaming application may require GPU to execute one or more shader programs. For instance the gaming application may require shader core to execute vertex shader and fragment shader to generate images that are to be displayed e.g. on display of . Graphics driver may instruct GPU when to execute the shader programs and instruct GPU with where to retrieve the graphics data needed for the shader programs. In this way graphics driver may form the link between processor and GPU .

Graphics driver may be configured in accordance to an API although graphics driver does not need to be limited to being configured in accordance with a particular API. In an example where device is a mobile device graphics driver may be configured in accordance with the OpenGL ES API. The OpenGL ES API is specifically designed for mobile devices. In an example where device is a non mobile device graphics driver may be configured in accordance with the OpenGL API.

Shader core may be configured to execute many instances of the same instruction of the same shader program in parallel. For example graphics driver may instruct GPU to retrieve vertex values for a plurality of vertices and instruct GPU to execute vertex shader to process the vertex values of the vertices. In this example shader core may execute multiple instances of vertex shader and do so by executing one instance of vertex shader on one processing element of shader core for each of the vertices.

Each processing element of shader core may execute the same instruction of vertex shader at the same instance however the particular vertex values may be different because each processing element is processing a different vertex. As described above each processing element may be considered as executing a thread of vertex shader where a thread refers to one instruction of vertex shader that is processing a particular vertex. In this manner shader core may execute many instances of vertex shader to process vertex values of a plurality of vertices in parallel e.g. at the same time .

Shader core may similarly execute many instances of fragment shader to process pixel values of a plurality of pixels in parallel or execute many instances of compute shader to process many non graphics related data in parallel. In this manner shader core may be configured in single instruction multiple data SIMD structure. For ease of description the following is described with respect to a generic shader program examples of which include vertex shader fragment shader compute shader and other types of shaders such as geometry shaders.

In the techniques described in this disclosure SGPR may store data e.g. attribute data for a variable e.g. an attribute for graphics items in a graphics wave that are uniform. There may be various ways in which to determine whether the data is uniform across the graphics wave.

For example compiler may be aware of SGPR i.e. SGPR is visible to compiler . In other words compiler is designed with functionality the uses SGPR . In some examples compiler may ensure that instead of storing per wave uniform data into per fiber GPR that shader core stores per wave uniform data in SGPR e.g. thirty two scalar data per wave . Compiler may utilize different example techniques to allow constant load for non divergent data into SGPR .

As one example while compiling a shader program e.g. vertex shader fragment shader or compute shader compiler may determine whether the shader program requires accessing uniform data. In this context a shader program requiring access to uniform data means that each thread of the shader program executing on respective processing elements of shader core each requests the same data for at least one variable of the graphics items.

For example compiler may generate uniform data such as a for loop counter. This for loop counter may be the same for all execution instances of the shader program which means that the for loop counter is the same for processing each graphics item. This for loop counter may be an example of data of a variable for the graphics items. In this example compiler may determine that the for loop counter is data for a variable of the graphics items that is uniform across all graphics items in the graphics wave.

As another example the shader program may include branching instructions e.g. if then else instructions . For some particular branch the shader program may include an instruction that sets one or more variables equal to a constant value e.g. an instruction that sets all x y z and w coordinates equal to 0 . In this example compiler may determine that the constant value is data for a variable of the graphics items that is uniform across all graphics items in the graphics wave.

If compiler determines that the shader program requires accessing uniform data across the graphics wave compiler may include an explicit instruction that indicates to shader core that the data is uniform across the graphics wave. In this example shader core may issue a request for the uniform data from memory e.g. local memory or system memory for the variable for a first graphics item and may store the data in SGPR rather than GPR . However because the data for the variable is the same for the graphics wave shader core may not issue a request for the other graphics items. For example shader core may convert per graphics item e.g. per fiber constant load to a per wave constant load and the store the data to SGPR . In this manner shader core may not need to issue unnecessary memory requests which saves per fiber instruction processing cycles memory request issuing cycles and return data writing back cycles.

As described above SGPR may include a plurality of storage locations where each storage location is associated with a single variable e.g. attribute of the variables e.g. attributes of the graphics items that form the graphics wave. As also described above SGPR is viewable by compiler . For example compiler may assign each of the storage locations of SGPR with a unique identifier SGPR ID . Compiler may transmit the SGPR ID for the storage location associated with the attribute which has the uniform attribute data. Shader core may then store the uniform attribute data for the graphics wave in the SGPR storage location identified by the SGPR ID.

In these examples for instructions that use the data the processing elements of shader core may retrieve the data from the SGPR ID associated with the storage location for the attribute. In such examples the techniques may further reduce power consumption by not accessing GPR and accessing SGPR instead.

In examples where compiler determines that data of the graphics items of a graphics wave are divergent e.g. non uniform compiler may not include the instructions indicating the uniform data access. In these examples shader core may request the data for each of the graphics items and store the data in GPR . For example shader core may request from memory the attribute data for the first attribute of a first graphics item request from memory the attribute data for the first attribute of a second graphics item and so forth. In the uniform attribute data scenario shader core may request attribute data only once for the graphics items of the graphic wave and store the attribute data in SGPR .

In some cases compiler may not determine that data for a variable is uniform across the graphics wave but may not also determine that data for a variable is necessarily divergent in the graphics wave. In other words compiler may determine that there is a likelihood that attribute data for an attribute is uniform e.g. MAYBE there is uniform access for the attribute data of a particular attribute .

In such examples compiler may alias the storage locations of SGPR with the attributes of the graphics items stored in GPR and indicate such aliasing to shader core . As one example assume each graphics item is associated with eight attributes. In this example compiler may alias identifiers IDs R R with GPR IDs e.g. with attributes of the graphics item . In this example IDs R R may be reserved identifiers and shader core may be configured to determine that when IDs R R are used then compiler determined that there is a likelihood that attribute data for at least one of the attributes of the graphics items is the same.

The aliasing of storage locations of SGPR and GPR may mean that compiler may access and allocate both SGPR space and GPR space for destination. In other words compiler may allow for data to be stored in SGPR or GPR . For example compiler may include instructions in the shader program that indicate that an attribute data should be stored to one of these identifiers. If shader core determines that the attribute data is uniform shader core may store the attribute data to the storage location of SGPR identified by the aliasing identifier. If shader core determines that the attribute data is divergent shader core may store the attribute data to GPR based on the aliasing identifier. An example of the use of the aliasing identifier is described in the more detail with respect to .

As described above shader core may be configured to determine whether the data is uniform or divergent. There may be various ways in which shader core may determine whether data is uniform or divergent. As one example shader core may monitor the memory addresses requested by each of the processing elements for each of the variables. These memory addresses may be for a memory address of local memory of GPU or memory address of system memory .

If the memory addresses are the same shader core may determine that the data for a variable of each of the graphics items being processed by respective processing elements of shader core is uniform. For instance if the memory address of where the data is to be retrieved from is the same for each of the graphics items then it may be likely that data being requested for by the processing elements processing the graphics items is the same.

In some examples if shader core determines that the memory addresses for data of a variable of the graphics items of a graphics wave is the same shader core may assert a uniform valid flag e.g. set a uniform valid flag equal to 1 that indicates that the data of a variable is uniform. Then when writing the requested data shader core may first determine the value of the uniform valid flag and store the uniform data e.g. one instance of the data in the storage location of SGPR identified by the aliasing identifier if the uniform valid flag is asserted.

The uniform valid flag is associated with the SGPR storage location associated with the aliasing identifier. For example each storage location of SGPR may also be associated with a uniform valid flag. If the attribute data for an attribute associated with a particular storage location of SGPR is uniform as determined by shader core shader core may assert e.g. set flag value to 1 the uniform valid flag associated with that storage location. If the attribute data for an attribute associated with a particular storage location of SGPR is divergent as determined by shader core shader core may not assert the uniform valid flag e.g. set a uniform valid flag equal to 0 associated with that storage location.

For instance if shader core determines that at least one memory address for attribute data of an attribute of the graphics items is not the same as the others shader core may not assert the uniform value. Then when writing the requested attribute data shader core may first determine the value of the uniform valid flag and store the attribute data e.g. the divergent attribute data of an attribute of each of the graphics items in the storage locations of GPR associated with the aliasing identifier if the uniform valid flag is not asserted.

In some examples for instructions of the shader program that then use the attribute data compiler may include as an operand the aliasing identifier of the storage location of SGPR associated with the attribute data in these instructions. Shader core then reads the uniform valid flag value and determines whether the attribute data is stored in SGPR or GPR . For instance if the uniform valid flag is asserted shader core may determine that the attribute data is stored in the SGPR and if the uniform valid flag is not asserted shader core may determine that the attribute data is stored in GPR .

Control unit may control the functionality of shader core . For example control unit may retrieve the instructions that are to be executed by processing elements and store the instructions in instructions store . Also control unit may retrieve the attribute data that processing elements are to process and store the attribute data in GPR and or SGPR .

For example as illustrated control unit includes uniform logic detection unit . Uniform logic detection unit may be hardware of shader core software executing on shader core or a combination of the two. Although uniform logic detection unit is illustrated as being part of control unit the techniques described in this disclosure are not so limited. In general uniform logic detection unit is illustrated to assist with understanding and may be separate unit from control unit a specialized unit within control unit or integrated with control unit .

In the techniques described in this disclosure uniform logic detection unit is one example of the unit configured to implement the example techniques. For instance each one of processing elements may process one graphics item. To process respective graphics items each one of processing elements may execute instances of the shader program.

For example each one of processing elements may execute an instruction that requests data e.g. attribute data for a variable e.g. attribute of each of the graphics items being processed by respective processing elements . Uniform logic detection unit may determine whether the instructions requesting the data are requesting the data from the same memory address where the memory address is for local memory of GPU or system memory . If uniform logic detection unit determines that the memory address for the data for the variable of each of the graphics items is the same uniform logic detection unit may issue the request for the data one time and retrieve the data one time rather than retrieve data multiple times for each multiple requests of the data.

Uniform logic detection unit may also assert the uniform valid flag for the storage location within SGPR associated with the variable and write the retrieved data to the storage location of SGPR . In some examples uniform logic detection unit may not write the data to GPR although writing to GPR may still be possible . Then when each of processing elements executes an instruction that requires the data of the variable control unit may retrieve the data from the storage location of SGPR associated with the variable. For example only one request to SGPR may be needed to retrieve the data for all processing elements at one time.

If uniform logic detection unit determines that the memory address for at least one of the requested data is different e.g. at least two of the memory addresses are different from one another uniform logic detection unit may issue each one of the requests for the data and may not store the data in SGPR and may instead store the data in GPR . Then when each of processing elements executes an instruction that requires the data of the variable control unit may retrieve the data from the storage locations of GPR . For example multiple requests e.g. one for each processing elements may be needed to retrieve the data for each one of processing elements .

Instruction store may be memory capable of storing instructions such as but not limited to volatile memory non volatile memory a cache random access memory RAM static RAM SRAM dynamic RAM DRAM etc. Control unit may be hardwired circuitry of shader core that controls the components of shader core . However it may be possible for control unit to be formed at least in part by software or firmware executing on hardware of shader core .

Processing elements are configured to execute threads of a shader program. Each of processing elements may execute a different thread. For example each of processing elements may execute an instance of an instruction of a shader program with respect to potentially different graphics items. Processing elements may be single instruction multiple data SIMD processing elements. SIMD processing elements refer to processing elements that when activated are configured to execute the same instruction at the same time with respect to different data. This may allow processing elements to execute a plurality of threads of a shader program in parallel with respect to different data items. In some cases each of processing elements may execute instructions of a shader program based on a common program counter that points to an instruction contained in instruction store .

If one or more of processing elements are deactivated by control unit then such processing elements do not execute a program instruction for a given instruction cycle. In some cases control unit may deactivate one or more of processing elements to implement conditional branch instructions where the branching condition is satisfied for some threads and not satisfied for other threads.

In some examples each of processing elements may include and or correspond to one or more arithmetic logic units ALUs . In further examples each of processing elements may implement ALU functionality. ALU functionality may include addition subtraction multiplication etc.

It should be understood that illustrate only a portion of GPR and particularly only the portion of GPR that maps to SGPR . In general GPR is configured to store additional data that does not map to a storage location of SGPR . For instance GPR is a general register used for a variety of storage purposes while SGPR may be used in some non limiting examples to store only data that is uniform or has a likelihood of being uniform across a graphics wave. In other words of all the data that is stored in GPR it may be possible for a portion of such data to be stored in SGPR . For ease of illustration illustrate the data of GPR that can be stored in SGPR where in the data is uniform for storage in SGPR and where in the data is not uniform and cannot be stored in SGPR .

In these examples each of graphics items P P are associated with variables R R and similarly each of graphics items P P are associated with variables R R. In the examples illustrated in IDs R R are associated with variables R R respectively. It should be understood that IDs R R being associated with variables R R is merely one example and IDs R R may be associated with any one of variables R R. In W refers to the graphics wave that includes graphics items P P and in W refers to the graphics wave that includes graphics items P P.

In processing elements A D only four processing elements may be needed of shader core may implement the following instructions 

In the example of the first storage location of SGPR is associated with variable R and has the SGPR ID of R. In the example of the first storage location of SGPR is associate with variable R and has the SGPR ID of R. In four processing elements of shader core are each processing respective graphics items P P at the same time and in four processing elements of shader core are each processing graphics items P P at the same time.

In the examples of each of the four processing elements of shader core executes the LDC R m x instruction to issue a request to load the value stored at memory location x. The memory address for memory location x is for the data of variable R for graphics items P P in and for the data of variable R for graphics items P P. Uniform logic detection unit may determine whether the address for memory location x is the same for all of the memory requests from the four processing elements .

Assume that in the example of the address for memory location x is the same for the four processing elements and in the example of the address for memory location x is different for at least one of the four processing elements e.g. there are at least two addresses that are different from one another . Accordingly in the example of shader core e.g. uniform logic detection unit of control unit may determine that the memory address for the data of variable R is the same for graphics items P P and in the example of shader core e.g. uniform logic detection unit of control unit may determine that the memory address for the data of at least one variable R is different for graphics items P P e.g. the memory address for the data of at least two variables R is different from each other .

In the example illustrated in shader core e.g. via control unit may load the data of variable R to the first storage location of SGPR which is identified as R rather than as R in storage locations of GPR reserved for graphics items P P. In this example shader core e.g. via control unit may issue one read request and not issue a read request for each of the processing elements processing respective ones of graphics items P P. Also in this example shader core e.g. via control unit may write the data for variable R once and not write the data for variable R four times. Then for the next instruction R R 1 processing elements A D of shader core may read the value of variable R from SGPR rather that read the data four times from GPR . In this way the techniques may save memory request issuing cycles and return data by writing cycles if the constant load in a wave is uniform.

In the example illustrated in shader core e.g. via control unit may load the data of each variable R identified by the memory address of memory location x to storage locations of GPR . For example shader core e.g. via control unit may execute each of the four requests for the attribute data for variable R for graphics items P P because the memory location x is different for at least one of the four graphics items P P. Then for the next instruction R R 1 processing elements A D of shader core may read the respective data of variable R from GPR for each respective storage location for graphics items P P.

As described above SGPR is smaller than GPR . As one example SGPR may include one column and the same number of rows as GPR . In this way SGPR may be as deep as GPR but may not be as wide. As illustrated in one row of SGPR can store thirty two bits but one row of GPR can store 128 bits. As another example it may be possible for SGPR to include a plurality of columns where the number of columns is based on the number of attributes and include one row. In general each storage location of SGPR is associated with a variable and may be configured to store the data for respective variable of respective graphics items if the data for the respective variables is the same.

In general the variable of a plurality of graphics items refers to a variable that is needed for processing each of the plurality of graphics items. As one example each of the plurality of graphics items may be associated with an x y z and w coordinate a red component value a green component value a blue component value and an opacity value. In this example the x y z and w coordinates are each one example of a variable that is needed for processing each of the plurality of graphics items the red green and blue component and opacity values are each also one example of a variable that is needed for processing each of the plurality of graphics items. As another example a counter value may be a variable that is needed for processing each of the plurality of graphics items.

In some examples the data of the variable e.g. the value of the variable may be different for the plurality of graphics items. For instance one of the red green or blue component values for at least one of the graphics items may be different than the red green or blue component values for the other graphics items of the plurality of graphics items may be different. However in some examples the data of the variable may be the same for the plurality of graphics items. For instance a PRJ matrix values of a PRJ matrix may be the same for all of the plurality of graphics items. In the techniques described in this disclosure if the data of the variable is the same for a plurality of graphics items the data may be stored in the SGPR which reduces access times and promotes power efficiency gains.

In some examples control unit of shader core may determine whether an instruction in a shader program included by compiler indicates that the data of the variable of the plurality of graphics items is the same to determine whether the data of the variable of the plurality of graphics items is the same. As another example control unit via uniform logic detection unit may determine whether memory addresses requested by processing elements for the data of the variable for processing respective graphics items is the same. In these examples control unit may determine that the data of the variable is the same for all of the graphics items if all of the memory addresses are the same and control unit may determine that the data of the variable is not the same for at least one of the graphics items if all of the memory addresses are not the same e.g. there are at least two graphics items with different data .

Shader core e.g. via control unit may store the data in a storage location of SGPR associated with the variable if the data of the variable of the plurality of graphics items is the same 102 . For example in the first storage location of SGPR identified as R is associated with variable R for graphics items P P. Also R is associated with the storage locations of GPR that store the data of variable R for graphics items P P. In this way if data is stored in SGPR R refers to the first storage location of SGPR . If data is stored in GPR R refers to the storage locations of GPR that store data for variable R for respective graphics items P P.

In some examples if the data of the variable of the plurality of graphics items is the same control unit may issue only one request for the data from a memory address that is the same for the variable for all of the graphics items. Control unit may then retrieve the data only once for storage in the storage location of SGPR associated with the variable. In some examples control unit may assert a uniform valid flag if determined that the data of the variable of the plurality of graphics is the same. In some of these examples control unit may store the data in the storage location of the SGPR if the uniform valid flag is asserted.

Shader core e.g. via control unit may store data for the variable of each of the plurality of graphics items in multiple storage locations of GPR if the data of the variable of at least two of the plurality of graphics items is not the same 104 e.g. there are at least two graphics items whose data is different from each other . For example as illustrated in control unit may store the data for the variable for each of processing elements in storage locations of GPR .

Control unit may also receive a request for the stored data of the variable from each of processing elements for processing respective graphics items. If the data is the same control unit may issue only one request for the data from SGPR . If the data is not the same control unit may issue requests from all of processing elements for the data from GPR .

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored on or transmitted over as one or more instructions or code a computer readable medium and executed by a hardware based processing unit. Computer readable media may include computer readable storage media which corresponds to a tangible medium such as data storage media. In this manner computer readable media generally may correspond to tangible computer readable storage media which is non transitory. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer readable medium.

By way of example and not limitation such computer readable storage media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. It should be understood that computer readable storage media and data storage media do not include carrier waves signals or other transient media but are instead directed to non transient tangible storage media. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

Instructions may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition in some aspects the functionality described herein may be provided within dedicated hardware and or software modules configured for encoding and decoding or incorporated in a combined codec. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs e.g. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

