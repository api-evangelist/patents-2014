---

title: System, method, and computer program product for implementing software-based scoreboarding
abstract: A system, method, and computer program product are provided for implementing a software-based scoreboarding mechanism. The method includes the steps of receiving a dependency barrier instruction that includes an immediate value and an identifier corresponding to a first register and, based on a comparison of the immediate value to the value stored in the first register, dispatching a subsequent instruction to at least a first processing unit of two or more processing units.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09612836&OS=09612836&RS=09612836
owner: NVIDIA Corporation
number: 09612836
owner_city: Santa Clara
owner_country: US
publication_date: 20140203
---
The present invention relates to processor architectures and more particularly to mechanisms to handle register dependencies.

Processors are designed to execute instructions and store results in registers the results possibly being utilized as operands for subsequent instructions. Parallel processing architectures such as today s graphics processing units GPUs include a large number of parallel execution units configured to execute a large number of threads in parallel. The GPUs may also implement pipelined execution units that enable multiple long latency operations to be in flight at the same time. Many processors execute instructions in order relative to the order of the instructions defined by the program. However some processors allow for out of order execution of instructions. Due to the possibility that some instructions may depend on previously executed instructions and that strict ordering of instruction execution may not be adhered to by the processor processors may be required to implement some form of scheduling mechanism to ensure that register dependencies are managed properly. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for implementing a software based scoreboarding mechanism. The method includes the steps of receiving a dependency barrier instruction that includes an immediate value and an identifier corresponding to a first register and based on a comparison of the immediate value to the value stored in the first register dispatching a subsequent instruction to at least a first processing unit of two or more processing units.

Conventional processing units execute a series of instructions in order. The order in which the instructions are executed matches the order of the instructions in the program. More recently some processing units enable out of order execution where some instructions are executed in a different order than the order of the instructions in the program. To enable the management of dependencies between instructions various techniques may be implemented in the architecture of the processing unit.

One such technique is to utilize a scoreboarding mechanism. One way to implement a scoreboarding mechanism is to increment a counter in response to a specific event and decrement the counter in response to a related event. The value of the counter can then be analyzed to indicate what events have occurred at a particular point in time. For example a counter may be incremented when an instruction is dispatched and decremented when a result for the instruction has been written to a destination register. Consequently an instruction that depends on the result of a previously issued instruction can be delayed until the counter reaches zero to ensure that the result is available during execution. Prior art techniques implement scoreboarding automatically within the hardware. In other words the software does not control operation of the scoreboarding hardware. However such techniques may be expensive in terms of circuit complexity layout footprint and power consumption. A software based approach to scoreboarding is described more fully below.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

As also shown in each SM includes a number N of pipelined execution units . The pipelined execution units may include the cores the DPUs the SFU or the LSUs as well as any other type of execution unit coupled or decoupled. In the context of the present disclosure a decoupled pipeline is any execution unit that can execute instructions out of order thereby exhibiting a behavior where a result of an instruction dispatched to the execution pipeline will be written to the destination register an unknown number of clock cycles after the instruction has been dispatched by the scheduler unit . In contrast a coupled pipeline is any execution unit that executes instructions in order thereby exhibiting a behavior where a result of an instruction dispatched to the execution pipeline will be written to the destination register a known number of clock cycles after the instruction has been dispatched by the scheduler unit . In one embodiment a decoupled pipeline may include a FIFO that temporarily stores dispatched instructions for a number of clock cycles until the corresponding pipelined execution unit is available to execute the instructions. The pipelined execution units are coupled to a read crossbar and a write crossbar which are part of the interconnect network . Although not shown explicitly each of the pipelined execution units may be coupled to a plurality of collectors for storing operands as input to the datapath for the pipelined execution unit .

In one embodiment a scoreboard register may be utilized to ensure register dependencies are managed properly by the scheduling unit . A particular scoreboard register may be utilized for a particular type of instruction. For example a scoreboard register may be utilized for each texture instruction of a thread. Each time a texture instruction is dispatched to a texture unit the scoreboard register is incremented. Once the texture unit has written a value for the texture operation to a destination register i.e. one of the registers specified by the instruction the scoreboard register is decremented. For any subsequent instructions that have a dependency on the destination register the scheduler unit is configured to not dispatch the subsequent instruction until the corresponding scoreboard register stores a value of zero 0 . However the scoreboarding mechanism described above is expensive in terms of power and die area. For example a scoreboard register may be required for each different type of pipelined execution unit .

It will be appreciated that as described herein scoreboard registers are incremented when an instruction is dispatched and decremented when an operation is completed i.e. either reading a value from a source operand or writing a value to a destination register . Then the scoreboard registers are checked to make sure the value of the scoreboard registers are equal to zero. In another embodiment the scoreboard registers are decremented when an instruction is dispatched and incremented when an operation is completed i.e. either reading a value from a source operand or writing a value to a destination register . In such an embodiment the scoreboard registers may be checked to make sure the value of the scoreboard registers are equal to a value other than zero such as a maximum value of the scoreboard register . It will be appreciated that the particular implementation does not depend on whether the scoreboard registers have a nominal value of zero sixty three or some other value as long as the scoreboard registers are either incremented and decremented in a specific manner and the scoreboard registers are checked to determine whether they contain a value equal to the nominal value.

In another embodiment a limited number of scoreboard registers may be defined that are generalized to be used by different types of pipelined execution units i.e. a particular scoreboard register is not implemented per set of related pipelined execution units . A compiler not explicitly shown is configured to select which scoreboard register to associate with a particular instruction that is to be dispatched to a decoupled pipeline e.g. a texture unit an LSU etc. . Thus the compiler is configured to demarcate dependency arcs in the program using the plurality of scoreboard registers the older instruction generates a particular scoreboard and a newer instruction consumes the particular scoreboard.

For each instruction included in a program e.g. a shader the compiler may specify a scoreboard register e.g. register in the plurality of scoreboard registers to associate with the instruction. In other words when the scheduler unit schedules an instruction the scheduler unit increments the scoreboard register associated with the destination register of the instruction. When the pipelined execution unit has finished executing the instruction and written an output value to the destination register the scheduler unit decrements the scoreboard register associated with the destination register of the instruction. In one embodiment the instruction includes a write dependency bit mask e.g. 6 bits that indicates which scoreboard register is associated with the destination register of the instruction. The number of bits in the write dependency bit mask may reflect the number of scoreboard registers implemented for a particular warp. A particular scoreboard register may be specified by the compiler by setting a single bit i.e. logical TRUE of the write dependency bit mask for the instruction. Although the embodiment described above only allows for a single scoreboard register associated with the destination register to be specified for a given instruction some embodiments may enable multiple scoreboard registers to be associated with one or more destination registers. For example multiple bits in the write dependency bit mask may be used to specify multiple scoreboard registers .

The scheduler unit checks the scoreboard register s for any subsequent instruction that depends on the value in the destination register of the instruction. If the scoreboard registers do not store a value of zero when checked by the scheduler unit then the scheduler unit delays the dispatch of the subsequent instruction until the specified scoreboard registers store a value of zero. In another embodiment logic external to the scheduler unit may increment and or decrement the particular scoreboard register s specified by an instruction.

In addition to specifying one or more scoreboard registers associated with the destination register s for an instruction the compiler may also specify one or more scoreboard register s that are associated with the source operands of the instruction. The instruction may include a second read dependency bit mask that specifies which of the scoreboard registers are associated with the one or more source operands. The scoreboard registers associated with the source operands may be different from the scoreboard register s associated with the destination register for the instruction. In one embodiment a single scoreboard register is associated with each of the one or more source operands for an instruction. The scoreboard registers associated with the source operands may be incremented by the scheduler unit when the instruction is dispatched to a decoupled pipeline and decremented by the scheduler unit when the source operands for the instruction are read from the register file . In another embodiment logic external to the scheduler unit may increment and or decrement the scoreboard registers .

In another embodiment each of the instructions may encode an index of the scoreboard registers associated with either the destination register or the one or more source operands using a different number of bits. For example unlike a bit mask where each bit of the bit mask corresponds to a particular scoreboard register the instruction may encode an index of the scoreboard register associated with the destination register or the source operands in a smaller number of bits e.g. 3 bits may be used to encode an index of 0 7 corresponding to eight or fewer scoreboard registers . In such embodiments a special index e.g. 0b111 may be used to indicate no scoreboard register is specified. This type of encoding is possible because in one embodiment only a single scoreboard register can be associated with a destination register or the one or more source operands at a time.

It will be appreciated that the scoreboard register associated with the destination register for an instruction protects from a RAW Read After Write also known as a dependency or a WAW Write After Write hazard. In a RAW a dependent subsequent instruction attempts to read a source operand from a destination register of a previous instruction. In a WAW two instructions may be associated with the same destination register and the order that the instructions write to the destination register may be switched when compared with the order of the instructions in the program. When the first instruction is dispatched by the scheduler unit the scoreboard register associated with the destination register of the first instruction is incremented. The scheduler unit then prevents the subsequent instruction from being dispatched until the previously issued instruction has completed execution and a result is available in the destination register. These types of hazards exist because the latency of the decoupled pipelines is not known relative to when the instruction is dispatched by the scheduler unit .

It will be appreciated that the scoreboard register s associated with the source operands for an instruction protects from a WAR Write After Read hazard also known as an anti dependency where a dependent subsequent instruction attempts to write to a destination register specified as a source operand for an instruction before the pipelined execution unit executing the instruction has read the value in the destination register for one of the source operands. When the first instruction is dispatched by the scheduler unit the scoreboard registers associated with the source operands of the first instruction are incremented. The scheduler unit then prevents the subsequent instruction from being dispatched until the pipelined execution unit has read the values from the source operands. These types of hazards exist because the decoupled pipelines may not read the source operands for an instruction in the same clock cycle that the instruction is dispatched by the scheduler unit .

As described above the write dependency bit mask and the read dependency bit mask are defined in the instruction for producing scoreboards when the instruction is dispatched. In other words these bit masks are used to generate scoreboards and to manage dependencies of subsequently issued instructions. However an instruction may also be a consumer of scoreboards. In one embodiment an instruction includes an operand bit mask that is utilized to check one or more scoreboard registers associated with the operands for an instruction both the destination register operand to protect against WAW hazards and the one or more source operands to protect against RAW hazards . Unlike the write dependency bit mask and the read dependency bit mask which may only specify a single scoreboard the operand bit mask may specify one or more scoreboards. Each of the scoreboards associated with the operand bit mask is checked by the scheduler unit prior to the instruction being dispatched for execution. In another embodiment multiple scoreboard registers may be specified using a list of scoreboard indices. For example nine bits may be utilized to specify up to three different scoreboards using the indices between 0 and 7.

In one embodiment the operand bit mask may include a plurality of bits each bit corresponding to one of the scoreboard registers . For each operand the compiler may set a bit corresponding to a scoreboard register associated with the operand. It will be appreciated that two or more operands may be associated with the same scoreboard register . For example the compiler may set the operand bit mask as 0b001101 which corresponds to scoreboard registers and . When the scheduler unit selects an instruction from a particular warp to be dispatched the scheduler unit checks each scoreboard register corresponding to a set bit in the operand bit mask. In one embodiment each of the checked scoreboard registers should have a value of zero prior to the scheduler unit dispatching the instruction to a pipelined execution unit . Thus the operand bit mask enables the scheduler unit to check if dependencies for the current instruction have been resolved by either the operands being read from or written to by a previously dispatched instruction.

In another embodiment each of the instructions may specify a specific value of a scoreboard register that enable an instruction to be dispatched by the scheduler unit . In other words the scheduler unit may not be configured to dispatch an instruction only when the scoreboard register reaches a value of zero but rather when the scoreboard register reaches a value of one or two and so forth. The compiler may be able to take advantage of the partial ordering of instructions within decoupled pipelines. Even though the decoupled pipelines execute instructions out of order each instruction executed by a particular decoupled pipeline is executed in order with respect to the other instructions dispatched to the decoupled pipeline. In other words partial ordering can be exploited by knowing that certain events associated with a program are guaranteed to occur in order.

For example a program may include three texture operations. Because each of the texture operations are issued to the same decoupled pipeline i.e. a texture unit the texture operations are going to be executed in order with respect to the other texture operations. As such the compiler knows that the source operands for a first texture operation will be read prior to the source operands for a second texture operation which are read prior to the source operands for a third texture operation and so forth. Similarly the compiler knows that the result for the first texture operation will be written to a destination register prior to the result for the second texture operation being written to a destination register which is written prior to the result for the third texture operation being written to a destination register and so forth. There is no guarantee in ordering however between when the result of one texture operation is written to a destination register and when the source operands for a subsequently dispatched texture operation are read from the register file .

The characteristics of such partial ordering may be exploited by the compiler to reduce the number of scoreboard registers that need to be produced and consumed. As discussed above when an instruction depends on two previously issued instructions from the same decoupled pipeline only the last of those previously issued instructions needs to generate a scoreboard in order to ensure that both of the instructions have completed execution. The one or more other previously issued instructions are implied to have completed execution because the decoupled pipeline executes all instructions received by the decoupled pipeline in order.

In addition the compiler may specify that a particular scoreboard must only have a value less than or equal to some number before a particular instruction is dispatched by the scheduler unit . While a set of instructions may utilize a single scoreboard to track dependencies between instructions some instructions in the set of instructions may be dispatched to a particular decoupled pipeline thereby ensuring that once a scoreboard stores a value below some threshold value then at least one of the instructions in the set of instructions has completed execution. The source operands bit mask i.e. req n is interpreted to require that the specified scoreboard registers have a value of zero before the instruction may be dispatched. However in some cases an instruction is only dependent on one or more instructions in the set of instructions that are associated with a particular scoreboard register and the dependencies may have been resolved even when the scoreboard register stores a value greater than zero. An example of a program utilizing this concept is shown in more detail below in .

In contrast with including a source operands bit mask in subsequent dependent instructions which would require the associated scoreboards to each contain a value of zero before the dependent instruction can be dispatched a dependency barrier instruction i.e. DEPBAR may be included in the code that stalls the program until one or more scoreboard registers have a value that is less than an immediate value included as an operand to the dependency barrier instruction. The dependency barrier instruction can exploit the partial ordering of instructions transmitted to a particular decoupled pipeline in order to manage dependencies with a reduced number of scoreboard registers while also not unnecessarily slowing down the execution of the program.

As shown in the first dependency barrier instruction is included after the three texture instructions and requires that the first scoreboard register e.g. SB have a value that is less than or equal to two. The first dependency barrier instruction is ordered before the first floating point multiply instruction which depends on the source operand stored in R that is written as a result of the execution of the first texture operation. At the time that the scheduler unit decodes the first dependency barrier instruction each of the three texture instructions will have been dispatched to the texture units . Thus the first scoreboard register will have been incremented three times. During the intervening time zero or more of the texture operations may have been executed by the texture units thus causing the first scoreboard register to be decremented. If the first scoreboard register holds a value of two then the scheduler unit knows that the first texture instruction has been executed and the output value was written to the destination register R. Thus the first floating point multiply instruction can be dispatched to the floating point multiplication unit because all dependencies for that instruction have been resolved. Using the dependency barrier instruction enables some dependent instructions to be dispatched prior to completion of all of the texture operations associated with the first scoreboard register .

The pseudocode further includes a second DEPBAR instruction that requires the first scoreboard register to be less than or equal to 1 followed by a second FMUL instruction that utilizes a source operand register R that was written as a destination register of the second texture instruction. The pseudocode also includes a third DEPBAR instruction that requires the first scoreboard register to be equal to zero followed by a third FMUL instruction that utilizes a source operand register R that was written as a destination register of the third texture instruction. It will be appreciated that the third DEPBAR instruction is equivalent to utilizing a source operands bit mask identifying the first scoreboard register in the third FMUL instruction because the DEPBAR instruction includes an immediate value of 0 which is the same value that will be checked against using the req 0x1 instruction suffix. It will be appreciated that in other exemplary programs multiple DEPBAR instructions may by associated with multiple scoreboard registers and potentially multiple different and distinct decoupled pipelines.

At step the compiler determines a minimum distance from a root node i.e. the dependency barrier instruction to a node of the program i.e. the previously issued instruction . The distance is computed based on the number of scoreboards that are produced and consumed for a particular decoupled pipeline. One technique for computing the minimum distance of a node is described below in conjunction with . At step the compiler assigns the immediate value to be less than the minimum distance.

Determining the immediate value for a dependency barrier instruction is simple if the referenced scoreboard register is only associated with instructions dispatched to a single decoupled pipeline i.e. a virtual queue and the referenced scoreboard is only utilized for write dependencies or read dependencies but not both. In this case the immediate value is simply determined by counting the number of scoreboards generated between the root node and the node associated with the dependent read or the dependent write. However the general case becomes more complicated when instructions associated with the same scoreboard register may be dispatched to multiple decoupled pipelines meaning the instructions associated with a single scoreboard register may be executed out of order .

In one embodiment a dependency barrier instruction should not be utilized in the cases where a single scoreboard is associated with multiple decoupled pipelines. However a dependency barrier instruction can include a non zero immediate value and also be associated with a scoreboard register used for multiple decoupled pipelines when the minimum distance for the node in the first decoupled pipeline is greater than the immediate value and the total depth of any other decoupled pipeline associated with the scoreboard register is less than the position of the node in the first decoupled pipeline.

Further determining the minimum distance becomes more complicated when read dependencies and write dependencies are combined using the same scoreboard register . In such cases the compiler may construct a directed graph that represents all possible paths the hardware can take when processing the instructions and producing and consuming scoreboards and look for all operations that are common to those paths based on a particular immediate value. Such operations having a distance greater than the immediate value in all possible paths are considered completed and all other operations are potentially outstanding.

Take two cases a fully pipelined case where every read for the series of operations is completed and then every write for the series of operations is completed subsequent to all of the reads and a non pipelined case where a read followed by a write is completed for each operation in the series of operations in order. In the case of a write dependency the minimum distance to a node will be given by the fully pipelined case where all nodes are read and then all nodes are written. Therefore counting the number of write dependency scoreboards produced between the root node and a particular node will provide the maximum immediate value that can be assigned to the dependency barrier instruction to guarantee that an instructions destination register has been written. In the case of a read dependency the minimum distance to a node will be the minimum of the distance in the fully pipelined case and the non pipelined case. For a read dependency in a fully pipelined case the distance from the root node to the node is given by summing a count of the write dependency scoreboards produced by a series of operations dispatched to a particular decoupled pipeline including operations ordered before as well as after the particular node added to a count of the read dependency scoreboards produced by a series of operations dispatched between the root node and the particular node. For a read dependency in a non pipelined case the distance from the root node to the node is given by summing all of the read dependency scoreboards and write dependency scoreboards produced by a series of operations dispatched between the root node and the particular node.

At step the compiler calculates a sum of a number of read dependency scoreboards corresponding to the particular scoreboard register between the dependency barrier instruction and the node and a number of write dependency scoreboards corresponding to the particular scoreboard register between the dependency barrier instruction and the node. At step the compiler calculates a sum of a number of read dependency scoreboards corresponding to the particular scoreboard register between the dependency barrier instruction and the node and a number of write dependency scoreboards corresponding to the particular scoreboard register associated with a particular decoupled pipeline. At step the compiler determines the minimum distance by taking the minimum of the sum from step and the sum from step .

As shown in a first node represents the write dependency scoreboard for the first texture operation a second node represents the read dependency scoreboard for the second texture operation a third node represents the write dependency scoreboard for the second texture operation and a fourth node represents the read dependency scoreboard for the third texture operation. The root node represents the dependency barrier instruction. In the non pipelined case the order of the events follows node to node to node to node to the root node . In other words the source operands for the first texture operation are read then the destination register for the first texture operation is written i.e. node then the source operands for the second texture operation are read i.e. node then the destination register for the second texture operation is written i.e. node then the source operands for the third texture operation are read i.e. node and finally the destination register for the third texture operation is written. Conversely in the fully pipelined case the order of the events follows node to node to node to node to the root node . In other words the source operands for the first texture operation are read then the source operands for the second texture operation are read i.e. node then the source operands for the third texture operation are read i.e. node then the destination register for the first texture operation is written i.e. node then the destination register for the second texture operation is written i.e. node and finally the destination register for the third texture operation is written.

In order to ensure that an operation has been completed is simply determined based on the minimum distance in the two cases between the root node and the node of interest. For example the operations associated with node and node are only 1 step away from the root node therefore any immediate value greater than or equal to 1 does not ensure that either of these operations i.e. the source operands for the third texture operation are read or the destination register for the second texture operation is written have completed. In contrast the minimum distance between the root node and either nodes or is two so a dependency barrier instruction having an immediate value of 1 ensures that the operations associated with these nodes will have completed.

It will be appreciated that the order of the operations represented by the directed graph may be completed in any order represented by the arrows. In other words all reads may be completed before any writes or writes may be completed before each subsequent read or some mixture of the two. In one embodiment a compiler may be configured to generate a directed graph for a plurality of instructions preceding a dependency barrier instruction in order to determine a minimum distance between a root node and a node of interest i.e. a node associated with an operation that the dependency barrier instruction is inserted for in order to ensure that the operation has been completed .

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

