---

title: Externally initiated application session endpoint migration
abstract: In storage networks (e.g., SAN and NAS), various reasons can arise for migrating an application layer communication session endpoint to a different host. To achieve scalability and robustness, the migration can be enacted externally and carried out at a middlebox at the transport layer. When a migration is triggered to migrate an application layer communication session endpoint from a host A to a host B, the middlebox coordinates network address translation with a transport protocol reset mechanism to switch the connection to host B and close the connection on host A with minimal disruption to the non-migrating application layer communication session endpoint using the connection. At the application layer, the non-migrating application layer communication session endpoint will initiate a new connection in response to detecting the reset, and retry any operation that was aborted as a result of the connection switch.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09635114&OS=09635114&RS=09635114
owner: NetApp, Inc.
number: 09635114
owner_city: Sunnyvale
owner_country: US
publication_date: 20140311
---
Embodiments of the inventive subject matter generally relate to the field of computer networking and more particularly to migrating an endpoint of an application session.

The Open Systems Interconnection OSI model is a conceptual model that logically partitions inter system communication functionality into layers. The higher layers correspond to user level or near user level applications that uses the services provided by protocols of the lower layers. The applications access the lower layer services by calling Application Programming Interface API functions defined for an implementation of a lower layer protocol. For instance an application running in a particular operating system will bind to an address and port create a connection communicate over the connection and close the connection using functions of a sockets API provided by the operating system. Each of the socket API functions invokes program code that operates in accordance with the lower layer protocol such as the transmission control protocol.

The transmission control protocol TCP is a connection oriented transport layer protocol that provides reliable byte stream delivery between two network hosts. The transmission control protocol TCP is coupled with the Internet Protocol IP and numerous other protocols as a suite of networking protocols. This suite of protocols is often referred to as a TCP IP protocol suite. TCP IP employs an abstraction of 4 layers similar to some of the layers in the Open Systems Interconnect OSI 7 layer reference model. Layer 4 of TCP IP corresponds to layers 5 7 of the OSI reference mode. Although a TCP IP protocol suite may include a network interface protocol e.g. PPP or SLIP the network interface layer or data link layer typically is not implemented by a TCP IP stack i.e. code implementing the TCP IP protocol because the TCP IP stack relies upon another protocol e.g. Ethernet . While the IP governs network protocol issues e.g. addressing routing and datagram packaging the TCP governs transport protocol issues. These issues include establishing managing and terminating connections reliability quality of service flow control and congestion avoidance and addressing multiplexing.

In TCP a connection is established between hosts with a 3 way handshake. The 3 way handshake involves an exchange of 3 messages between hosts. The TCP messages have the same structure but will have either a SYN flag set an ACK flag set or both flags set. The flag defines the message. To initiate the 3 way handshake a first host sends a synchronization message SYN to the second host. The SYN includes a sequence number field. The sequence number field indicates an initial sequence number ISN X when set in a SYN message. The second host responds to the SYN with a SYN ACK message i.e. both the SYN flag and the ACK flag are set . This SYN ACK message builds upon the SYN message and establishes the sequencing used for other features and functionality of TCP e.g. reliability . The sequence number field of the SYN ACK will have an ISN Y for the second host while an acknowledgement number field of the SYN ACK will have a number that is the sequence number expected by the second host to be received from the next message from the first host X 1 . This acknowledgement number is the sequence number from the SYN message incremented by one. In response to the SYN ACK the first host will respond with an ACK. This ACK from the first host may already carry data whereas the previous messages did not. In addition the ACK from the first host has a sequence number X 1 and an acknowledgement number Y 1. The connection is established after this ACK has been sent from the first host to the second host. A connection is identified with the addresses and ports of both hosts.

TCP also provides for a handshake exchange to close an established connection. Each side of a connection terminates independently. A first host sends a message with the FIN flag set to a second host of a connection. The second host acknowledges the FIN message with an ACK message. At this point the connection is half closed. When ready the second host will send a FIN message to the first host. The first host then responds with an ACK. After the second host receives and processes the ACK from the first host in response to the second host s FIN message the connection between the first and second hosts has been closed. This FIN handshake closes a connection in an ordered manner. TCP also provides a connection reset mechanism and defines a reset flag in the structure of a TCP message. A host will utilize the reset mechanism when an error is detected e.g. receipt of a data message for a connection that is not open receipt of a SYN ACK for which a SYN was not sent . When a host receives RST the host will abort the connection identified by the RST possibly after checking the validity of the RST.

The description that follows includes example systems methods techniques instruction sequences and computer program products that embody techniques of the inventive subject matter. However it is understood that the described embodiments may be practiced without these specific details. For instance although examples refer to TCP embodiments are not so limited. The inventive subject matter can be employed in embodiments that use other transport protocols that provide a reset mechanism. In other instances well known instruction instances protocols structures and techniques have not been shown in detail in order not to obfuscate the description.

In storage networks e.g. SAN and NAS various reasons can arise for migrating an endpoint of an application layer communication session to a different host e.g. file server storage controller tape drive controller etc. . As examples a session endpoint associated with host A may be migrated to host B for load balancing to perform maintenance on host A to migrate to hosts newly added to a cluster in a failover scenario etc. To achieve scalability and robustness the migration can be enacted from an external device and carried out by a middlebox at the transport layer. This migration allows an application layer session to persist through a change of an endpoint of the underlying connection. When a migration is triggered to migrate an application session endpoint from a host A to a host B the middlebox coordinates network address translation with a transport protocol reset mechanism to switch the connection to host B and close the connection on host A with minimal disruption to the non migrating application session endpoint using the connection. At the application layer the non migrating application session endpoint e.g. an application process will initiate a new connection in response to detecting the reset and retry any operation that was aborted as a result of the connection switch.

At A the migration controller communicates a request to migrate an application session endpoint of the connection 192.0.2.0 49155 198.51.100.6 55000 from server to server . The server has a network address 198.51.100.1. The request indicates the addresses and ports of the hosts corresponding to the connection that supports the application session endpoint being migrated. For this example the request indicates the address and port for client 192.0.2.0 49155 and the address and port for server 198.51.100.6 55000 . The request specifies both hosts addresses and ports since multiple connections can exist concurrently between hosts. The request also indicates the server as the TO address i.e. the address to which the application session endpoint is being migrated .

After receiving the request the middlebox commences B and B. At B the middlebox configures network address translation rules for both directions of the connection. The middlebox configures the network address translation rules to change 198.51.100.6 55000 to 198.51.100.1 55000 when server is a destination for data of the connection and change 198.51.100.1 55000 to 198.51.100.6 55000 when server is a source for data of the connection. Although this illustration uses the same port numbers between the hosts embodiments are not limited to translating with the same port numbers. In some cases an application session endpoint may be allowed a range of port numbers. Thus the address translation can use different port numbers that are valid for the corresponding application session endpoint. The middlebox installs the network address translation rules in a connection table . The connection table indicates the connections that traverse the middlebox . At B the middlebox leverages a reset mechanism of TCP to close the connection at the server . The middlebox creates an ACK as if from the client and sends it to the server to solicit an ACK from the server . The middlebox then sends a RST as if from the client to the server with an appropriate sequence number derived from the ACK from the server . The server closes the connection after receiving the RST from the middlebox .

After these operations data traffic associated with the connection 192.0.2.0 49155 198.51.100.6 55000 i.e. data traffic to and from the application layer process in this illustration actually traverses a de facto connection between the client and the server with the address translations. At C the application layer process migrates from the server to the server . As discussed earlier this migration may involve instantiating the application layer process . Or the application layer process may already be running at the server . If the application layer protocol of the application layer processes is stateful then the migration controller can direct the application layer process to communicate state information to the server . If the application layer process is to be instantiated the migration controller can direct the server to instantiate the application layer process . Although depicted as C the migration controller can direct any exchange of state information or instantiation of a process at a different time that precedes eventual receipt of data at the server . At C the client transmits a data message . The data message indicates the connection 192.0.2.0 49155 198.51.100.6 55000. At D the middlebox transmits a message to the server after the configured address translation rules have been applied to the message . The message indicates a connection 192.0.2.0 49155 198.51.100.1 55000. At E the server responds to the message with a message . The message indicates the connection 198.51.100.1 55000 192.0.2.0 49155. After the middlebox applies the network address translation rules installed in the connection table to the message the middlebox will send a corresponding message that indicates the connection 192.0.2.0 49155 198.51.100.6 55000 to the client .

The illustration of is meant to introduce the inventive subject matter and should not be used to limit scope of the claims or embodiments. For instance a host may be a client in one context and a server in another context. In addition a host can function as both a client and a server. This illustration refers to host as a client host as a server and host as a server in an effort to simplify the illustration. The migration controller may be a separate network device e.g. an OpenFlow controller . The migration controller may be software executing on the middlebox hardware of the middlebox or a combination of hardware and software on the middlebox . Implementations may use an OpenFlow flow table and install the network address translation rules into the flow table. For instance the migration controller may send the network address translation rule to the middlebox and identify connections e.g. 192.0.2.0 49155 198.51.100.6 55000 affected by a migration. The middlebox then installs the rule into the flow table entries corresponding to the connections. In some implementations the middlebox modifies the flow corresponding to one direction of a connection being migrated and adds a flow for the reverse direction of the connection.

The application layer process and TCP layer at the client are unaware that the connection with the from host has been reset by the from host . The TCP layer at the client proceeds to send a next segment with data depicted as DATA SEGMENT in based on the previous exchanges with the from host and or based on a current request of the supported application layer process. When the client sends the next segment the middlebox modifies the segment in accordance with the network address translation rules. The middlebox modifies the IP header to change the destination from the network address of the from host to the network address of the to host . In addition the middlebox modifies the TCP header to change the destination port unless the same destination port is being used by the to host as was used for the connection between the client and the from host . Accordingly the segment is sent to the to host by the middlebox instead of being sent to the from host . The to host does not recognize the connection identified by the received segment since a connection has not been established between the client and the to host . Therefore the to host sends the client a RST with the sequence number corresponding to the received segment i.e. using the ACK number of the received segment . However the middlebox applies the network address translation rules to the RST. The middlebox changes the network address indicated in the RST from the network address for the to host to the network address for the from host . In addition the middlebox changes the destination port of the RST to indicate the port of the connection between the client and the from host unless the port number is the same. The client validates the sequence number of the RST and performs operations for resetting the connection. The application layer process that was using the connection detects the reset. Accordingly the application layer process will invoke the functions of the transport layer to open a new connection for the application layer process. In some cases the reset may interrupt an operation being performed by the application layer process. In those cases the application layer process may attempt to retry the interrupted operation. Retrying the interrupted operation or continuing with operations involves re establishing a connection. The application layer process causes the client to send a SYN that initiates a 3 way handshake between the client and from the perspective of the client the from host . However this 3 way handshake will actually be between the client and the to host because of the address translation rules being applied at the middlebox . The client may or may not use the same source port for reconnection. All of these segments traverse the middlebox which applies the address translation rules to any segments that identify the connection between the client and the from host . Thus the client perceives the connection as between the client and the from host while the to host perceives the connection as between the client and the to host .

Although some migrations endure e.g. due to failover other migrations are temporary. In the cases of load balancing or maintenance for example the application session endpoint may be migrated to yet another host which may include migration back to the original host. If the connection had not been closed on the original host then a connection with the same network addresses and ports may not be established without disrupting the application layer process e.g. a network file system application process that relies on the connection. depicts a sequence diagram of an example middlebox based migration back to the from host of . Block arrows with hash marks depict communications over the established connection between the client and the to host . The TO address translation rules are applied to communications that indicate the connection previously between the client and the from host as identified by address and port pairs. At some point a migration is triggered which results in the network address translation rules being removed or deactivated. The middlebox sends an ACK with an ACK number and a SEQ . The middlebox randomly selects or generates these numbers. If these numbers are expected by the to host then the to host may not respond. In addition the to host may not respond if the segments are lost e.g. due to congestion . To account for the possibility of a host not responding to a spoofed message the middlebox uses a timer to trigger another spoofed message if a response to the spoofed ACK is not received within a predefined time period. In that case the middlebox at least generates a different ACK number if not both numbers. This spoofed ACK is also depicted in as ACK because it is a spoofed ACK. The middlebox creates the spoofed ACK by writing the source port as the port of the client that partly identifies the affected connection and the address of the source as the address of the client . In response to the spoofed ACK the to host sends an ACK with an appropriate ACK number and SEQ in this example 132 and 7 based on previous exchanges with the client . The middlebox intercepts this ACK from the to host . The middlebox spoofs a reset message depicted as RST in with the sequence number as 132 and ACK as 8. Since the spoofed reset message has the appropriate sequence number as expected by the to host from the client the to host resets the connection.

Similar to the first migration the application layer process and the TCP stack at the client are unaware of the connection reset by the to host . When the client sends the next segment address translation rules are not applied to the segment at the middlebox because the address translation rules have been deactivated or removed. Since the address translation rules are not applied to the segment the segment is delivered to the indicated recipient which is the from host . But the from host does not recognize the connection indicated by the segment since the from host previously reset the connection with the client which resulted in the connection being closed from the perspective of the from host . Therefore the from host sends the client a RST that has a proper SEQ based on the received segment. The client validates the sequence number of the RST and performs operations to reset the connection. At this point the application layer process will re try an operation that was interrupted by the connection reset if any and will attempt to re establish the connection identified with the same destination port and address pair as previously used. The client may or may not use the same source port for reconnection. The client sends a SYN that initiates a 3 way handshake between the client and the from host .

At block the middlebox locates the connection in a connection table. For example a connections table or a flow table is searched for an entry that matches the IP addresses and port numbers that identify the connection. In some cases MAC addresses and other information may also be matched.

At block the middlebox determines whether the to host is indicated as an endpoint of the connection. In other words the middlebox determines whether migration is being requested back to the original endpoint of the connection. If the to host is indicated as the endpoint of the connection then control flows to block . Otherwise control flows to block .

At block the middlebox configures an address translation rule to translate the from host address to the to host address in protocol data units associated with the connection and flowing to the from host. If the to host is not employing the same port identifier as the from host then the translation rule will also translate the destination port of protocol data units associated with the connection to a different port identifier that will or is used by the to host. In some cases the translation rule will also modify the source port or other information in communications. The middlebox can determine whether a different connection is already established with the to host using the same source port. In that case the address translation rule can be created to change the source port.

At block the middlebox configures an address translation rule to translate the to host address to the from host address in protocol data units associated with the connection and flowing from the to host i.e. address translation rules that reverse the translations of the translation rule set in block . Embodiments can configure the network address translation rules in various manners. The middlebox may invoke a network address translation program and pass the indications of the from host and the to host and relevant port identifiers as parameters to the network address translation program with an indication of the different translations for the different directions of data associated with the connection. The middlebox may write the different network address translation rules into corresponding flow table entries i.e. write the first network address translation rule into the flow table entry that corresponds to flow from a client to the to host and the second network address translation rule into the flow table entry that corresponds to flow from the to host to the client . The network address translation rules may have been sent to the middlebox. In that case the middlebox copies the network address translation rules into the corresponding flow table entries.

At block the middlebox causes the from host to reset the connection i.e. perform operations that implement reset as defined by the corresponding transport layer protocol .

At block the middlebox indicates that the migration has completed. For example the middlebox can set a flag in flow table entries corresponding to the migrated connection endpoint. As another example the middlebox can supply a notification to a controller.

If the to host was an initial endpoint of the connection then control flows to block . At block the middlebox determines whether an address translation rule is being applied to the connection. For instance the middlebox finds a flow table entry that matches the connection and determines whether a network address translation rule is written into the entry or referenced in the entry. If not then control flows to block . If a network address translation rule is being applied to the connection then the middlebox removes the network address translation rule in both directions of the connection at block . Removing the network address translation rules can vary among implementations. The middlebox may delete the rules or mark the rules for deletion from the entries in which they are installed. The middlebox can set a flag associated with the network address translation rules to indicate that the rules are not to be applied. Control flows from block to block .

At block the middlebox sets the acknowledgement number of the constructed ACK message with a random number. The middlebox generates a random number perhaps with a pseudo random number generator module. The middlebox may randomly select a number from the range of possible acknowledgement numbers.

At block the ACK message is communicated to the from host. The middlebox transmits the ACK over the network to the from host.

At block the middlebox listens for an ACK message from the from host for the connection. For instance a TCP stack executing on the middlebox waits for the ACK from the from host. As another example the middlebox can have a process that is not a TCP stack but monitors a receive buffer for the ACK message. The middlebox periodically determines whether an ACK message has been received from the from host at block . If a response is received then the random number selected for the ACK number was out of window and control flows to block . If no response is received before a configurable time period expires at block the random number chosen in block happened to lie inside the receive window of the connection. As mentioned earlier a response may also not be received because either of the ACK message or a response to the ACK message is lost in the network. In case of no response control flows to block where the middlebox creates another ACK message as if from the non migrating host of the connection. This ACK is created with a different random number for the ACK number. For example the middlebox increases the randomly chosen ACK number by the maximum window size e.g. 2 30 1 which means the new ACK number is guaranteed to lie outside the window. Control then returns to block where the new ACK is sent.

At block the middlebox creates a reset message and sets the sequence number of the RST message as the acknowledgement number specified by the from host. The middlebox constructs the RST message with this number to ensure the from host can validate the RST message and will not ignore the RST message. As with the ACK message the middlebox constructs the RST message as if the non migrating connection host is the source of the RST message.

Although presumes that a migration trigger will indicate a connection for migration embodiments can request migration of multiple connections either by specifying multiple connections or indicating criteria for migrating connections. In some cases a load balancing event may lead to a sequence of migration requests for several of the connections on a server to different new servers. The migration requests can indicate an application or port that corresponds to the application to guide selection of connections for migration and a total number of connections to migrate.

Embodiments may proactively initiate the reset and handshake between a client and a to host. As can be seen in the to host does not send a RST until a segment is received from the client. This segment for example may correspond to a new network file system NFS operation request or a pending NFS operation that was previously requested by the client. In some cases the client TCP stack may be silent. The client TCP stack may be waiting for either the TCP receive window or transmit window to be freed up both triggered by an update ACK from the server. Since no updates are coming from the server after a migration the session enters into a deadlock. The deadlock is broken with a timeout mechanism either external to TCP e.g. the NFS retry timeout by default 60 seconds in GNU Linux is triggered or TCP s timeout mechanism. Instead of waiting for a timeout mechanism a middlebox can solicit the segment from the non migrating connection host by sending a spoofed RST to the non migrating connection host as well as to the migrating connection host.

When the application layer process that was using the connection attempts a new operation or retries an operation that was interrupted by the connection reset the client TCP stack will try to establish a new connection with the from host in response to the validated RST ACK 22 SEQ 101 . Thus the client initiates a 3 way handshake with the from host with a SYN. With the configured network address translation rules at the middlebox the 3 way handshake is actually with the to host . All of these connection establishment messages traverse the middlebox which applies the network address translation rules. Thus a connection between the client and the from host is indicated in the middlebox . But the connection actually carrying messages is between the client and the to host .

At block the middlebox creates an ACK message as if from the non migrating endpoint of the connection. With the connection information e.g. IP addresses and ports the middlebox constructs a message that indicates a source IP address and source port with the information about the non migrating endpoint of the connection. The middlebox sets the destination IP address and destination port with the connection information about the migrating endpoint i.e. from host . The middlebox also sets the ACK flag in the message.

At block the middlebox sets the acknowledgement number of the constructed ACK message with a random number. The middlebox may generate a random number perhaps with a pseudo random number generator module. The middlebox may randomly select a number from the range of possible acknowledgement numbers. Regardless of how the number is generated or selected the middlebox attempts to select a number that is not expected by the from host e.g. a number outside of the sliding window of the from host .

At block the ACK message is communicated to the from host. The middlebox transmits the ACK over the network to the from host.

At block the middlebox listens for an ACK message from the from host for the connection. For instance a TCP stack executing on the middlebox waits for the ACK from the from host. As another example the middlebox can have a process that is not a TCP stack but monitors a receive buffer for the ACK message. The middlebox periodically determines whether an ACK message has been received from the from host at block . If a response is received then the random number selected for the ACK number was out of window and control flows to block . If no response is received before a configurable time period expires at block the random number chosen in block happened to lie inside the receive window of the connection. Therefore control flows to block where the middlebox creates another ACK message as if from the non migrating endpoint of the connection. This ACK is created with a different number for the ACK number. Some implementation can select or generate another random number and then manipulate that number to be outside of the receive window. In some implementations the middlebox increases the randomly chosen ACK number by the maximum window size e.g. 2 30 1 which means the new ACK number is guaranteed to lie outside the window. Control then returns to block where the new ACK is sent.

At block the middlebox creates a reset message and sets the SEQ number of the RST message as the acknowledgement number specified by the from host. The middlebox constructs the RST message with this number to ensure the from host can validate the RST message. As with the ACK message the middlebox constructs the RST message as if the non migrating connection host is the source of the RST message.

At block the middlebox creates a second reset message and sets the SEQ number of the second RST message as the SEQ number specified by the from host. The middlebox constructs the second RST message with this number to ensure the non migrating connection endpoint can validate the second RST message. The middlebox constructs this RST message as if the from host is the source of the second RST message.

Although reference is made to an NFS application service other session based applications or services that use TCP as a transport and have idempotent operations with a retry mechanism can utilize the disclosed subject matter. For the NFS service where client modifications are not feasible this middlebox based connection migration supports session continuity and host selection. Furthermore transport layer initiated middlebox based application layer process migration allows seamless capacity expansion with the addition of hosts without the management overheads of configuring additional NFS mounts.

The flowcharts are provided to aid in understanding the illustrations and are not to be used to limit scope of the claims. The flowcharts depict example operations that can vary among embodiments and among implementations of embodiments. Additional operations may be performed fewer operations may be performed the operations may be performed in parallel and the operations may be performed in a different order. For instance a middlebox can employ an interrupt driven technique to determine when a from host sends a response to a spoofed ACK. Thus in and blocks of may not be performed in some embodiments. As another example of variation among implementations embodiments blocks and can be performed in various orders. Embodiments may perform operations corresponding to blocks and before operations corresponding to blocks and . Further as the technique herein relies on networks some operations may need to be repeated to deal with delayed dropped protocol data units for correct operation. For example an embodiment may choose to re send an ACK to ascertain that the RST messages were indeed received and processed correctly at from host. Specifically if from host responds with an RST it can be assumed that the connection was reset. Instead if from host responds with an ACK the connection is still valid and the process of sending the spoofed RST is repeated.

This description refers to terms that should have well defined meanings within the field of networking and or computer technology but can be misinterpreted when the bounds of a reasonable interpretation are stretched. Among many terms the description refers to a host and an application layer process. In this description and for the claims a host refers to any machine that has networking capability. The term application layer process refers to an executing instance of a program or group of programs that are executable by a machine also referred to as a device and that operate in accordance with a communications protocol for communications between processes across a network. The description also refers to a middlebox. A middlebox is a network device with functionality to manipulate traffic traversing the network device other than forwarding and routing functionality.

As will be appreciated by one skilled in the art aspects of the inventive subject matter may be embodied as a system method or computer program product. Accordingly aspects of the inventive subject matter may take the form of a hardware embodiment a software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the inventive subject matter may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to an electro magnetic signal an optical signal an infrared signal or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with a computer. Program code embodied on a computer readable signal medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the inventive subject matter may be written in any combination of one or more programming languages including an object oriented programming language such as the Java programming language C or the like a dynamic programming language such as Python a scripting language such as Perl programming language or PowerShell script language and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on a stand alone computer may execute in a distributed manner across multiple computers and may execute on one computer while providing results and or accepting input on another computer.

Aspects of the inventive subject matter are described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the inventive subject matter. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The term network device and host as used herein comprises any kind of computing system machine or device that has network capability and can be programmed and or configured in accordance with the inventive subject matter. The description also uses the terms endpoint connection endpoint endpoint host and connection endpoint host. All of these terms are used interchangeably to refer to an entity that corresponds to an endpoint of a connection established in accordance with a connection based protocol e.g. TCP . The endpoints are either a source or a destination depending upon the direction that a protocol data unit is traveling. Also the description refers to a connection table. Embodiments are not limited to a table type of data structure that hosts information about transport layer connections that traverse a middlebox. This information can be stored in any of a variety of data structures or even a hardware structure hardware lookup table . Further connections e.g. expressed in terms of addresses and ports of endpoints may be hosted in multiple structures. An initial hardware structure can be accessed with a hash of an IP address for a from host. This entry in the hardware structure can reference one or more entries in another data structure each of which indicate the other endpoint of the connections with the from host. These entries can further reference other structures that indicate various features or services to be applied to traffic corresponding to the entry ies .

While the embodiments are described with reference to various implementations and exploitations it will be understood that these embodiments are illustrative and that the scope of the inventive subject matter is not limited to them. In general techniques for application session endpoint migration as described herein may be implemented with facilities consistent with any hardware system or hardware systems. Many variations modifications additions and improvements are possible.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the inventive subject matter. In general structures and functionality presented as separate components in the example configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the inventive subject matter.

