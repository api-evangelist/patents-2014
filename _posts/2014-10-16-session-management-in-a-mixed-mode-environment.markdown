---

title: Session management in a mixed mode environment
abstract: Systems and methods for managing multiple versions of applications executing on servers in a server pool are provided. A request to generate new session data for a transaction requested by a user is received by a first server executing a first version of an application. A determination is made that the first version of the application is unsuitable to process the request. An identity of a second server executing a second version of the application is requested by the first server in a server pool comprising one or more servers, and an appropriate second server is selected. The first server transmits a hypertext transfer protocol proxy request to the selected second server, which generates the new session data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09519478&OS=09519478&RS=09519478
owner: PayPal, Inc.
number: 09519478
owner_city: San Jose
owner_country: US
publication_date: 20141016
---
The present application is related to U.S. patent application Ser. No. 14 266 463 filed Apr. 30 2014 titled MIXED MODE SESSION MANAGEMENT which is herein incorporated by reference.

The present disclosure generally relates to applications executing on servers and more particularly to a method and system for managing session creation within a server pool having servers executing multiple versions of an application.

More and more consumers are purchasing items and services over electronic networks such as for example the Internet. Consumers routinely purchase products and services from merchants and individuals alike. The transactions may take place directly between a conventional or on line merchant or retailer and the consumer and payment is typically made by entering credit card or other financial information. Transactions may also take place with the aid of an on line or mobile payment service provider such as for example PayPal Inc. of San Jose Calif. Such payment service providers can make transactions easier and safer for the parties involved. Purchasing with the assistance of a payment service provider from the convenience of virtually anywhere using a mobile device is one main reason why on line and mobile purchases are growing very quickly.

Transactions facilitated by a payment service provider may involve multiple steps or stages where each step takes place on a separate web page. Each web page may be provided by a server executing an application corresponding to that transaction. For reliability availability and other considerations many payment service providers use large numbers of servers in a server pool and each web page provided as part of a transaction may be provided by a different server in the server pool executing the application. However some payment service providers frequently upgrade the versions of applications executing on servers that facilitate the services of the payment provider. When a user s transaction with a payment service provider begins on a server executing an older version of an application e.g. a version of an application that is scheduled to be obsolete or upgraded and if the number of other servers in the server pool executing that older version is decreasing users may experience delays in transaction processing for subsequent steps of the transaction.

Thus there is a need for an improved method and system for managing multiple versions of applications in a server pool.

Embodiments of the present disclosure and their advantages are best understood by referring to the detailed description that follows. It should be appreciated that like reference numerals are used to identify like elements illustrated in one or more of the figures wherein showings therein are for purposes of illustrating embodiments of the present disclosure and not for purposes of limiting the same.

The present disclosure provides systems and methods for managing new session data in an environment with two or more versions of an application executing on two or more servers. The servers may be part of a server pool in which all servers in the server pool are executing the same application. Different servers in the server pool may be executing different versions of the application. The application may be provided by a payment service provider to facilitate a particular transaction such as providing payment to purchase a product or transferring funds from a sender to a recipient. A request to generate new session data for a transaction requested by a user may be received at a first server executing a first version of an application. The first server may determine that the first version of the application is unsuitable or otherwise not preferred to process the request to generate new session data for the transaction requested by the user. For example the first server may determine within a server pool having a plurality of servers that include the first server that a number of other servers executing the first version of the application is decreasing and or is below a threshold percentage. Such a situation may arise when the first version of the application is being upgraded to a newer version. In response the first server may request from a metadata store an identity of a second server executing a second version of the application different from the first version. The first server may receive the identity of the second server executing the second version of the application and transmit a proxy request to the second server associated with the identity of the second server. Session data for the user s requested transaction may then be created or generated by the identified second server to begin the user s transaction with the second version of the application as the result of the first server submitting a proxy request to the second server.

Referring now to an embodiment of a networked system is illustrated. The networked system includes one or more client devices that are coupled to a network . A global traffic manager is coupled to the network and to an application router . The application router is coupled to one or more server pools and . Each server pool and may include one or more servers denoted as and that are each coupled through a local network e.g. a local area network LAN and respectively to a local traffic manager and respectively a metadata store and respectively and a session data store and respectively. Session data stores and may store session data for one or more transactions of a payment service provider as will be described further below. Each of the local traffic managers and are coupled to the application router .

In the embodiments discussed below each server pool may be used by a payment service provider to provide one or more payment service provider applications such as a checkout application money sending application and or other payment service provider applications known in the art. As such the server pools and and the application router may be part of a payment service provider system . Payment service provider system may provide multiple applications to consumers and businesses that facilitate a wide variety of transactions. However one of skill in the art in possession of the present disclosure will recognize that the systems and methods of the present disclosure will be beneficial to a wide variety of applications provided by a wide variety of different system providers. As such while specific references are made to a payment service provider providing the systems and methods of the present disclosure any system provider utilizing the teachings of the present disclosure to manage two or more versions of any type of application executing on two or more servers is envisioned as falling within the scope of the present disclosure.

The client devices global traffic manager application router servers local traffic manager and metadata store may each include one or more processors memories and other appropriate components for executing instructions such as program code and or data stored on one or more computer readable mediums to implement the various applications data and steps described herein. For example such instructions may be stored in one or more computer readable mediums such as memories or data storage devices internal and or external to various components of the system and or accessible over the network .

The client devices may be implemented using any appropriate combination of hardware and or software configured for wired and or wireless communication over network . For example in one embodiment the client devices may be implemented as a personal computer of a user in communication with the Internet. In other embodiments the client devices may be a smart phone laptop computer wearable computing device and or other types of computing devices.

The client devices may include one or more browser applications which may be used for example to provide a convenient interface to permit users to browse information available over the network . For example in one embodiment the browser application may be implemented as a web browser configured to view information available over the Internet.

The client devices may also include one or more toolbar applications which may be used for example to provide user side processing for performing desired tasks in response to operations selected by the user. In one embodiment the toolbar application may display a user interface in connection with the browser application.

The client devices may further include other applications as may be desired in particular embodiments to provide desired features to the client devices . In particular the other applications may include a payment application for payments facilitated by a payment service provider through the server pools and . The other applications may also include security applications for implementing user side security features programmatic user applications for interfacing with appropriate application programming interfaces APIs over the network or other types of applications. Email and or text applications may also be included which allow the user to send and receive emails and or text messages through the network . The client device include one or more user and or device identifiers which may be implemented for example as operating system registry entries cookies associated with the browser application identifiers associated with hardware of the client device or other appropriate identifiers such as a phone number. In one embodiment the user identifier may be used by the payment service provider server pools and .

The network may be implemented as a single network or a combination of multiple networks. For example in various embodiments the network may include the Internet and or one or more intranets landline networks local area networks wide area networks wireless networks and or other appropriate types of networks.

The global traffic manager may be provided by a third party service not affiliated with an individual user and may be used by many parties including payment service providers to direct user requests to servers or other computing resources that are located geographically closer to a particular user or computing resources that have capacity to handle user requests.

The application router may be part of a payment provider service system and may receive user requests and facilitate transactions with users by directing requests data for transactions and any other data to an appropriate server pool or individual server executing a particular application. For example application router may direct a request for a checkout application to a server pool having servers executing the checkout application.

As described above server pools and may include a plurality of servers and local traffic managers and and metadata stores and . As illustrated in different servers in the server pools and e.g. servers and may be executing a different version of a particular application e.g. version 1 or version 2 in the illustrated embodiment . Examples of applications include for example a purchasing application for purchasing a good or service from a merchant e.g. a checkout application a money sending application for sending money from one person or entity to another a donation application for donating money from a person or entity to a charity or any other application provided by a payment service provider. Furthermore as discussed above a wide variety of applications other than payment applications will benefit from the teachings of the present disclosure and are envisioned as falling within its scope. For example in servers and are executing version 1 of a money sending application while servers and are executing version 2 of that money sending application. Similarly servers and are executing version 1 of a money sending application while servers and are executing version 2 of the money sending application. Although two versions are illustrated in embodiments described herein may include servers in one or more server pools executed any number of versions of an application. Further the version of an application executing on any particular server may change if a new version of the application is installed on that server. Thus for example server or may be upgraded to version 2 of the application at some point in the future.

Local traffic managers and may receive requests from the application router and may select a server in their respective server pool that will handle the requests. The server selected to handle a request may be chosen by taking into consideration multiple factors such as for example a current workload of the servers in the server pool and or a variety of other request handling criteria known in the art.

The example applications described above may require multiple steps or stages each of which may presented to a user using one or more web pages having input fields and or other data to perform a transaction. In an embodiment each web page that is presented to the user and that corresponds to a step to perform the transaction may be provided by a different server in a server pool. For example a first web page corresponding to a first step of a money sending transaction may be provided by server a second web page corresponding to a second step of the money sending transaction may be provided by server and a third web page corresponding to a third step of the money sending transaction may be provided by server . Data spanning across multiple user requests for a single transaction may be referred to as session data and contains an accumulation of data transmitted between a client device and one or more servers and during multiple HTTP requests pertaining to a single transaction. Session data may be stored in for example a session data store or . Session data may be generated by a server which receives the initial request from the user and may be associated with the version of the application executing on the server which receives the request.

Thus in a typical user transaction the user s session data is initialized generated or created while processing a request submitted at client device which may be routed to the application router by the global traffic manager . As described above the global traffic manager may be used by the payment service provider to direct user requests to server pools that are located geographically closer to a particular user. From global traffic manager the user s request then passes to application router which determines the application suitable for the user s transaction and forwards the user s request to a server pool such as server pool or with servers executing the appropriate application. The local traffic manager or of the server pool then forwards the user s request to one of the servers or based on various criteria such as a current workload of each server. The selected server then facilitates the user s request generating session data and storing information about the transaction into a persistent session store such as session data store or holding the session data across multiple requests within the transaction. Session data is typically a list or a set of key value pairs where each pair stores data used by the transaction.

Payment service providers often use multiple servers executing the same application to provide high availability of the application. For example applications used by payment service providers that facilitate purchases or other transactions are desired to provide near 100 availability in order to allow users to purchase products or perform other transactions at any time of the day or night. The multiple servers which may constitute a server pool may all execute the same application and each server can handle one or more steps or stages of a transaction. Typically only one version of an application is executing on servers in a server pool at a given time. However there are certain times when two or more versions of an application may execute on servers in a server pool at a given time. For example during deployment of a new version of an application two versions of an application may be executing on servers in a server pool at the same time. Upgrading an application executing on a server to a new version may be difficult when applications require such high availability. Further complications may arise during the upgrade process on multiple servers when two different versions of an application are incompatible with each other.

For example version 1 of a particular application may require three steps or stages and version 2 of that application may require four stages. Elements of session data that are used by the application may differ from version 1 to version 2. As one example a money sending application may allow a first user to send money to a second user. Version 1 of the money sending application may include three steps 1 specify the recipient 2 specify the amount and source of funds and 3 confirm the transfer. Thus the session data for version 1 of the money sending application may include key value pairs for at least the recipient amount and source information. Version 2 of the money sending application may include four steps 1 specify the recipient 2 specify the date of transfer 3 specify the amount and source of funds and 4 confirm the transfer. Thus session data for version 2 of the money sending application may include at least the recipient date of transfer amount and source information.

If the user s session begins on a server in a server pool executing version 2 of the money sending application and at some point in the transaction the session is transferred to a server in the server pool executing version 1 of the money sending application an error may occur. The error may occur in the above example because version 2 of the money sending application requires the user to specify the date of transfer and such data may be provided by the customer and included in the session data but version 1 of the application does not or cannot read process or otherwise handle that session data containing the date of transfer information. Such an error may be referred to as a deserialization exception. That is the earlier version of the application cannot or does not know how to process session data it does not expect to see because the new version of the application includes a new variable or may include a new class. Typically when such a deserialization exception occurs the user is presented with an error the user s attempted transaction fails and the user must restart the transaction from the beginning.

In the converse of the above example the user s session may begin on a server executing version 1 of the money sending application and at some point in the transaction the session may be transferred to a server executing version 2 of the money sending application and thus an error may occur in this situation as well. For example the server executing version 2 of the money sending application will expect to see date of transfer information in the session data. However because such data is not required by version 1 of the application that data will not be included in session data provided to the server executing version 2 of the money sending application when the user session is transferred from that server from the server executing version 1 of the money sending application. Thus a deserialization exception may occur in this example as well.

When upgrading multiple servers to execute a new version of an application one option is to deactivate multiple servers at the same time install the new version of the application and reactivate the servers once the upgrade is complete on all servers. For example to upgrade servers every one of those servers may be taken offline or deactivated at the same time have version 2 of an application installed and then be reactivated. Deactivating servers and upgrading the applications on those servers helps ensure that deserialization exceptions and other related errors do not occur. However deactivating multiple servers at once may affect availability of the application executing on the servers and may lead to a diminished user experience.

Instead of deactivating groups or pools of servers at the same time applications may be upgraded on individual servers in a server pool one at a time or in groups smaller than the total number of servers in the server pool. Such an upgrade strategy minimizes the unavailability of the application. Since only a portion of the servers in the server pool are deactivated at a time the other servers in the server pool can handle user requests without a large impact on application availability. Such an upgrade strategy may be known as a mixed mode deployment strategy. A mixed mode deployment strategy may also be used when testing a new version of an application on a limited number of servers in a server pool. However using such an upgrade strategy deserialization exceptions may occur when the different servers in the server pool have different application versions as a user s session can span multiple servers having different versions and lead to the problems discussed above.

Further when utilizing a mixed mode deployment strategy deserialization exceptions may become more frequent as session data may be generated by servers executing unsuitable or obsolete versions of applications. For example as individual servers in a server pool are being upgraded from version 1 of an application to version 2 of the application session data may still be generated for initial requests from users on those servers executing version 1 of the application. As the upgrade process continues the number of servers in the server pool executing version 1 of the application may decrease which may correspondingly increase the number of deserialization exceptions that occur.

For example if a server pool has 12 servers and 3 servers are upgraded at a time at some point in the upgrade process 75 of the servers in the server pool will be executing the newer version of the application. Transactions which begin on servers executing the older version of the application will generate session data associated with the older version of the application. Subsequent steps of that transaction however have a high probability of being routed to servers executing the newer version of the application which will result in deserialization exceptions. As the population of servers in the server pool executing the older version of the application decreases limiting or eliminating the amount of generated session data associated with the older version of the application will reduce the number of deserialization exceptions that occur.

One solution to the issues raised by a mixed mode deployment strategy is to utilize intelligent routing. That is a load balancer or other front end router such as local traffic manager or application router may be configured to direct requests from a user to perform a transaction to an appropriate server executing an application version. Thus in the example above local traffic manager may route requests for transactions from users to only those servers in a server pool executing a newer or upgraded version of an application instead of the servers in the server pool executing an unsuitable or obsolete version which is being upgraded. Thus new session data is only generated by servers executing the newer version of the application. However intelligent routing may slow the performance of the router load balancer and or other front end systems. Further intelligent routing may only be necessary when an application is being upgraded in the mixed mode deployment strategy and such upgrade events or roll outs may be infrequent. Additionally even when an application is being upgraded session deserialization exceptions themselves may occur infrequently. Thus the decrease in performance resulting from intelligent routing may not be commensurate with the benefit afforded by intelligent routing.

Embodiments described herein utilize additional features that may be executed as part of an application itself to minimize or eliminate the amount of new session data created by older versions of an application executed by servers in a server pool. Instead of creating session data on a server executing a version of an application that is being upgraded the user s transaction request may be transmitted via a proxy request from the server which receives the initial request to a server executing the upgraded version of the application such that the server executing the upgraded version of the application generates the user s session data. Accordingly the user s experience is improved. In one embodiment a metadata store such as metadata store or maintains information describing the versions of an application executing on various servers in a server pool. Each server in the server pool may maintain and periodically update statistics relating to the number or proportion of other servers in the server pool executing the same version of the application as the server itself. If a given server determines that a number of application servers executing its own version of the application is decreasing or below a given threshold the server may consult the metadata store to identify another server executing the upgraded version of the application and transmit a proxy request to that server in the server pool executing the upgraded version of the application. Thus the user s session is created with the upgraded version of the application and deserialization exceptions are minimized.

Referring now to an embodiment of a method for managing two or more versions of an application executing on two or more servers is illustrated. In the embodiments and examples discussed below a money sending application is used as an example of a payment application. However other payment applications are also possible including checkout applications donate money to charity applications and or a wide variety of other types of payment applications known in the art. Furthermore as discussed above a wide variety of non payment applications will benefit from the teachings of the present disclosure and are envisioned as falling within its scope. Such applications may be provided by a payment provider service or other system provider and or may include other applications that require high availability e.g. a stock trading or other financial services application .

The method begins at block where a hypertext transmission protocol request from a user is received at a first server executing a first version of an application. In one embodiment the request is for an initial or first step of a transaction that generates new session data for the user s transaction. For example as described above the request may be received at server from a client device through a global traffic manager application router and local traffic manager .

The method then continues to block where the first server determines that the first version of the application is unsuitable to process the request and to generate session data associated with the first version of the application. The first version of the application may be unsuitable to process the request and generate session data associated with the first version of the application because for example the number of other servers within a server pool including the first server that are also executing the first version of the application is decreasing or is below a given threshold. For example in one embodiment the application maintains statistics as to the number or proportion of servers in a server pool executing the same version of the application. If the proportion of servers in the server pool executing the first version of the application was previously 60 and has dropped to 40 a server may determine that it is in a shrinking proportion of servers executing the first version of the application and accordingly the server may determine that the first version of the application is unsuitable to process the request and generate session data for the user s transaction. As discussed above the determination may also be based on a threshold percentage such as 50 although other thresholds are possible. Similarly if the number of servers in the server pool executing the first version of the application was previously 6 and has dropped to 4 a server may determine that it is in a shrinking number of servers executing the first version of the application and accordingly the server may determine that the first version of the application is unsuitable to process the request and generate session data for the user s transaction. Again the determination may also be based on a threshold number of servers such as 5 although other thresholds are possible.

In one embodiment the statistics are based on data periodically retrieved from a metadata store such as metadata store . Metadata stores may store for each server in a server pool a record that identifies a location of the server an application name of an application executing on the server a version number or build number of that application and the last time the record was updated. The data in the metadata store may be updated when an application is started on the server. Similarly when the application is shut down the record for the server may be deleted from the metadata store. On a periodic basis each server in the server pool may update its metadata store record. For example each server may update its corresponding metadata store record every 15 minutes. The update interval may be configurable depending on the payment service provider s or system provider s needs based on the application being executed by the servers in the server pool and or based on a variety of other update factors known in the art. In one embodiment the data for maintaining statistics may be retrieved from the metadata store whenever the metadata store is updated by another server in the server pool.

In one embodiment when the metadata store is queried records for servers having a last update time that exceed a threshold i.e. records older than the update interval of 15 minutes 60 minutes and or other thresholds known in the art may be removed from the metadata store. Such records may be referred to as stale metadata. Thus for example servers that crash or otherwise become unresponsive may have their associated metadata removed from the metadata store. The stale metadata interval may be configurable depending on the payment service provider s or system provider s needs or based on the application being executing by the servers in the server pool and or based on a variety of other stale metadata factors known in the art.

Based on the determination at block the method then continues to block where the first server e.g. server requests the identity of a second server in the server pool that is executing a second version of the application. In one embodiment for example server may consult or query a metadata store such as metadata store to identify one or more servers in the server pool that are executing a second version of the application that is a newer or upgraded version of the application executing on the first server.

The method then continues to block where the first server e.g. server selects one of the one or more servers executing the second version of the application to process the request to generate new session data. For example server may select server executing version 2 of the application. In some embodiments the identity of more than one server executing the second version of the application may be received based on the request of block . Accordingly in one embodiment the first server may select one of the servers at block on a random basis. In one embodiment the selection at block may be based on a last update time of the metadata store record for that server. Thus for example servers that have more recently updated records in the metadata store may be chosen over servers with older records in the metadata store.

As explained above in one embodiment the second version of the application is a newer version or upgraded version of the application. The determination of a newer version may be based on for example a version number build number time value or any other data associated with a record in the metadata store. In one embodiment if more than two versions of the application are executing on servers within the server pool the selected server may be a server executing the version of the application most prevalent in the server pool. For example if a server pool has 12 servers with 3 servers executing version 1 of an application 6 servers executing version 2 of the application and 3 servers executing version 3 of the application a server executing version 2 of the application may be selected. Further in one embodiment if more than two version of the application are executing on servers within the server pool the selected server may be the server executing the version of the application with an increasing population within the server pool.

The method then continues to block . At block the request may be proxied to the server executing the second version of the application identified at block . In one embodiment a hypertext transfer protocol proxy forward request is used to transmit the request from the server that initially received the request at block to the server determined to have the second version of the application at block . The proxy request may submit a new GET or POST HTTP request to the server executing the second version of the application. The server executing the second version of the application may then generate the user s session data which is then associated with the second version of the application. Further processing of the session data on other servers in the server pool executing the second version of the application therefore occurs without deserialization exceptions or other errors.

In certain cases at block the proxy request to the selected server may fail. This can occur for example if the selected server crashed in the time period between when it updated its metadata store record and the time when the metadata store was queried in block . Thus in one embodiment if the proxy request fails the metadata store may be queried to identify another server in the server pool to which the proxy request can be transmitted in substantially the same manner as discussed above with reference to blocks and . In one embodiment the receiving server may query the metadata store following proxy request fails for multiple servers until a threshold number of servers have been attempted or until a specified time period has passed. For example the receiving server may query the metadata store following proxy request fails until up to 5 servers have been returned or may continue querying the metadata store following proxy request fails until 30 seconds or another time period has elapsed. If the threshold number of servers has been attempted or the time period has passed an error may be returned to the user and the transaction may fail.

Referring now to a swim lane diagram which begins at and continues to detailing the interaction between various systems and components described with reference to embodiments discussed above is illustrated. The example of illustrates the interactions between a client device servers and metadata store . In the example of server is executing version 2 denoted as V 2 of an application and server is executing version 1 denoted as V 1 of the application. Further in the example of server is initially executing version 1 of the application but is later updated to version 2 of the application. In a checkout application is illustrated but the illustration is equally applicable to other types of applications.

Beginning on at event server may begin executing version 2 of the checkout application. Accordingly server may update the metadata store with a record identifying the application being executed the version number of the application and the time the metadata store was updated. At event the metadata store may receive and store the record.

At event server may begin executing version 1 of the checkout application. Accordingly server may update the metadata store with a record identifying the application being executed the version number of the application and the time the metadata store was updated. Further at event the metadata store may receive and store the record.

At event server which may have already been executing version 1 of the checkout application is upgraded to version 2 of the checkout application. Thus at event server transmits an updated record to metadata store updating at least the version number of its metadata record and the last update time. At event the metadata store may receive and store the record.

At event a user using client device may commence a checkout application transaction. At event server may receive the user s request for the transaction. At event server may determine that version 1 of the application is unsuitable to process and generate session data for the user s requested transaction. As explained above with reference to block of the method server may make this determination based on statistics reflecting the fact that the number of servers within the server pool executing version 1 of the application is decreasing.

Based on the determination at event server as discussed above with reference to block of the method may submit a lookup request to metadata store for a server executing a newer version of the application. At event metadata store receives the request from server and may determine from the records in the metadata store any servers in the server pool executing a newer version of the application i.e. version 2 of the application such as server and . At event metadata store may transmit the identified servers to server

At event server receives the data indicating that servers and are executing version 2 of the application. Continuing to server may choose server to handle the request and generate new session data for the user s transaction for example on a random basis and thus at event server submits a proxy request to server . At event server may receive the proxy request and can then generate session data for the user s transaction at event . Server may write the session data for the user s transaction to a session data store . Once server generates the user s session data at event server may provide one or more web pages for the transaction to server which originally received the user s request at step . Server may receive the one or more pages at step and provide those pages to the client device at event . The user may then continue the transaction at event .

In the embodiments and examples described above servers which can be candidates for proxy requests are restricted to those servers within the same server pool as a server receiving a request from a user. For example metadata store may only include application version information for servers within server pool . Additionally session data store may only store data for transactions which occur on servers within server pool . Thus only servers within server pool for example servers and may serve as candidate servers for a proxy request from another server in server pool such as server .

In one embodiment data may be replicated between metadata store and metadata store and thus servers in both server pool and may be candidate servers for proxy requests from servers in server pool and . In one embodiment session data may also be replicated between session data store and . In a further embodiment metadata stores and may be combined into a single metadata store accessible to both server pools and . Similarly session data stores and may be combined into a single session data store accessible to both server pools and . In such embodiments proxy requests may still be limited to servers within a same server pool for example using database lookup techniques.

In one embodiment an application upgrade strategy or rollout strategy may minimize the number of deserialization exceptions that occur. Such a rollout strategy may upgrade servers to new application versions in groups. In one embodiment a relatively small set of servers is upgraded followed by one or more relatively larger sets of servers and the rollout strategy may finish by upgrading one or two relatively smaller sets of servers. In one embodiment a waiting period approximately equal to the longest expected reasonable session duration may be allowed between the upgrade of two server groups to allow in progress sessions time to finish. The total time to upgrade a server pool to a new version of an application may be minimized since mixed mode management may increase the workloads of servers in the server pool.

Thus systems and methods for managing multiple versions of an application on multiple servers have been described that provide for high availability of the application while minimizing the occurrence of errors that result from session data being created on servers in a server pool executing older or obsolete versions of applications. The systems and methods of the present disclosure provide substantial benefits over conventional solutions such as the intelligent routing solutions discussed above by for example causing session data to be generated on only servers executing versions of applications that are in an increasing population rather than generating session data on servers executing all versions of an application such that further processing of the session data can occur on a larger number of appropriate servers.

Referring now to an embodiment of a computer system suitable for implementing for example the client device application router servers and local traffic manager and and or metadata store and is illustrated. It should be appreciated that other devices utilized by customers merchants payment service providers and or system providers in the system discussed above may be implemented as the computer system in a manner as follows.

In accordance with various embodiments of the present disclosure computer system such as a computer and or a network server includes a bus or other communication mechanism for communicating information which interconnects subsystems and components such as a processing component e.g. processor micro controller digital signal processor DSP etc. a system memory component e.g. RAM a static storage component e.g. ROM a disk drive component e.g. magnetic or optical a network interface component e.g. modem or Ethernet card a display component e.g. CRT or LCD an input component e.g. keyboard keypad or virtual keyboard a cursor control component e.g. mouse pointer or trackball a location determination component e.g. a Global Positioning System GPS device as illustrated a cell tower triangulation device and or a variety of other location determination devices known in the art and or a camera component . In one implementation the disk drive component may comprise a database having one or more disk drive components.

In accordance with embodiments of the present disclosure the computer system performs specific operations by the processor executing one or more sequences of instructions contained in the memory component such as described herein with respect to the client devices servers and application router local traffic managers and and or metadata stores and . Such instructions may be read into the system memory component from another computer readable medium such as the static storage component or the disk drive component . In other embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the present disclosure.

Logic may be encoded in a computer readable medium which may refer to any medium that participates in providing instructions to the processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. In one embodiment the computer readable medium is non transitory. In various implementations non volatile media includes optical or magnetic disks such as the disk drive component volatile media includes dynamic memory such as the system memory component and transmission media includes coaxial cables copper wire and fiber optics including wires that comprise the bus . In one example transmission media may take the form of acoustic or light waves such as those generated during radio wave and infrared data communications.

Some common forms of computer readable media includes for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge carrier wave or any other medium from which a computer is adapted to read. In one embodiment the computer readable media is non transitory.

In various embodiments of the present disclosure execution of instruction sequences to practice the present disclosure may be performed by the computer system . In various other embodiments of the present disclosure a plurality of the computer systems coupled by a communication link to the network e.g. such as a LAN WLAN PTSN and or various other wired or wireless networks including telecommunications mobile and cellular phone networks may perform instruction sequences to practice the present disclosure in coordination with one another.

The computer system may transmit and receive messages data information and instructions including one or more programs i.e. application code through the communication link and the network interface component . The network interface component may include an antenna either separate or integrated to enable transmission and reception via the communication link . Received program code may be executed by processor as received and or stored in disk drive component or some other non volatile storage component for execution.

Where applicable various embodiments provided by the present disclosure may be implemented using hardware software or combinations of hardware and software. Also where applicable the various hardware components and or software components set forth herein may be combined into composite components comprising software hardware and or both without departing from the scope of the present disclosure. Where applicable the various hardware components and or software components set forth herein may be separated into sub components comprising software hardware or both without departing from the scope of the present disclosure. In addition where applicable it is contemplated that software components may be implemented as hardware components and vice versa.

Software in accordance with the present disclosure such as program code and or data may be stored on one or more computer readable mediums. It is also contemplated that software identified herein may be implemented using one or more general purpose or specific purpose computers and or computer systems networked and or otherwise. Where applicable the ordering of various steps described herein may be changed combined into composite steps and or separated into sub steps to provide features described herein.

The foregoing disclosure is not intended to limit the present disclosure to the precise forms or particular fields of use disclosed. As such it is contemplated that various alternate embodiments and or modifications to the present disclosure whether explicitly described or implied herein are possible in light of the disclosure. For example the above embodiments have focused on merchants and customers however a customer or consumer can pay or otherwise interact with any type of recipient including charities and individuals. The payment does not have to involve a purchase but may be a loan a charitable contribution a gift etc. Thus merchant as used herein can also include charities individuals and any other entity or person receiving a payment from a customer. Having thus described embodiments of the present disclosure persons of ordinary skill in the art will recognize that changes may be made in form and detail without departing from the scope of the present disclosure. Thus the present disclosure is limited only by the claims.

