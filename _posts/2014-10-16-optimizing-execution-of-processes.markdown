---

title: Optimizing execution of processes
abstract: Methods and system for optimizing an execution of a business process are disclosed. In one aspect, a request to execute a business process is received. The business process is executed on multiple threads, which may include multiple computations. The business process is optimized by determining an optimal number of threads for executing the business process by a thread optimization model. From the determined optimal number of threads, the computations in the threads may be distributed or reallocated iteratively by executing an inter-thread computations optimization model. Executing the thread optimization model and the inter-thread computations optimization model optimizes the execution of the business process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09400683&OS=09400683&RS=09400683
owner: SAP SE
number: 09400683
owner_city: Walldorf
owner_country: DE
publication_date: 20141016
---
Advancements in the field of technology have increased the demand for systems and applications that support a diverse set of functions in an organization. Such systems and applications may include execution of complex algorithms and procedures to implement processes in the organization. The execution of algorithms and procedures to implement processes may consume dedicated computing resources and may add to the operational costs. Some of the processes may not be optimized resulting in underutilization of the computing resources. In addition optimizing processes such that the computing resources are effectively utilized may be challenging.

Embodiments of techniques related to optimizing execution of processes are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Business processes may refer to a collection of related activities or tasks. Such activities may be structured and may be associated with a specific service or a product. A business process may include multiple sub processes that may be executed to achieve a desired objective. The sub processes or the business process may be executed concurrently in parallel on multiple threads.

A thread on which a business process is executed may be a component of the business process and may include a sequence of programmed instructions executed by a processor of a general purpose computer. Multiple threads may run or execute in parallel to execute the business process and may share computing resources such as processor memory etc. Determining and allocating an optimal number of threads for executing a business process may contribute to optimizing the execution of the business process. Optimizing the execution of a business process may include modifying an aspect of the process that makes it work more efficiently by using fewer computing resources. By way of example optimizing the execution of a business process may correspond to reducing an overall time required to execute the business process reducing the amount of memory consumed or utilized to execute the business process etc.

In an embodiment process optimization system may optimize the execution of the business process by thread optimization module and inter thread computations optimization module . When process optimization system receives a request to execute a business process e.g. process thread optimization module may determine an optimal number of threads required to execute the business process e.g. process . Thread optimization module may determine attributes structure number of computations etc. associated with the business process e.g. process . The thread optimization module may iteratively calculate a total time required to execute computations associated with the business process e.g. process by incrementing number of threads e.g. a thread count to execute the computations in the business process e.g. process . In each iteration the thread count may be incremented and the total time required to execute the computations in the business process e.g. process is calculated and compared with the corresponding values e.g. total lime required to execute the computations thread count etc. of the previous iterations. Based on the comparison thread optimization module may determine the optimal number of threads for executing the business process e.g. process .

In an embodiment upon determining the optimal number of threads required for executing the business process e.g. process the execution of business process may further be optimized by inter thread computations optimization module . The inter thread computations optimization module may determine a time required to create or generate a thread e.g. a first thread from the optimal number of threads and a total time required to execute the computations in the thread e.g. the first thread . The computations in the optimal number of threads may be partitioned into time slots such that each time slot and or computation is equal to the time required to create the thread e.g. the first thread .

In an embodiment based on a determination of a total time required to execute computations in the business process e.g. process inter thread computations optimization module may iteratively determine available free time slots in the optimal number of threads. The computations of the last thread from the optimal number of threads may be reallocated or distributed between the available free time slots in the optimal number of threads. The reallocation or distribution of the computations may optimize the execution of the business process e.g. process by reducing the memory utilized and the total time required executing the business process.

In an embodiment the execution of the business process may be optimized by executing a thread optimization model and an inter thread computations optimization model. The thread optimization model may be executed to determine an optimal number of threads required for executing the process at . Upon determining the optimal number of threads to execute the process the inter thread computations optimization model may be executed. The execution of inter thread computations optimization model iteratively distributes computations in the determined optimal number of threads at . The distribution or reallocation of the computations may be based on business logic. By way of example the business logic may include iteratively parsing the threads to determine whether the computations in the threads may be reallocated the computations in the threads are awaiting reallocation etc. Based on the determined optimal number of threads and the iterative distribution of the computations in the optimal number of threads the execution of the business process is optimized at .

In an embodiment the execution of the thread optimization model may determine the attributes structures number of computations etc. associated with the business process. The determination of the optimal number of threads required for the execution of the business process may start by a value for number of threads e.g. thread count . Based on the thread count an overall time e.g. total time required to execute the computations in the threads may be determined. The total time required to execute the computations in the threads may be based on parameters such as number of computations in the thread a time required or taken to create or generate the thread time required or taken for executing computations in the thread fixed additional processing time taken for each thread etc. The total time required to execute the computations associated with the business process is calculated at . The value of thread count is iteratively incremented at . Upon incrementing the thread count the total time taken to execute the computations for a corresponding value of the thread count may be calculated. By iteratively incrementing the thread count the total time required to execute the computations may be reduced. For each iteration the thread count is incremented and the total time required to execute the computations in the business process is calculated. The calculated total time and a corresponding value of the thread count are compared for each iteration at e.g. total time required to execute the computations thread count etc. of each iteration is compared with the corresponding values of the previous iterations . Based on the comparison the thread optimization module determines the optimal number of threads for executing the business process at .

In an embodiment consider c representing a time required for each computation in a thread t then an total time required to create a thread may be computed using the equation Equation 1 

In an embodiment n represents the number of threads i represents number of calculations or computations in thread t and f represents fixed additional processing time.

In an embodiment when n corresponds to a master thread e.g. process is executed on a single thread and there are no additional threads e.g. child threads then value of n is 0 zero . Hence Equation 1 may be rewritten as Equation 2 

In an embodiment N corresponds to i which represents the number of computations or calculations in the business process in Equation 2 .

By way of example consider optimizing the execution of business process A . In an embodiment the business process A may be optimized by determining an optimal number of threads required for its execution. The total time required for executing the computations may be optimized or reduced by iteratively increasing the value of thread count and calculating a corresponding total time required for the execution of the computations in the business process. In each iteration the calculated total time required for the execution of the computations may be compared with the corresponding value of total time required for the execution of the computations in the previous iteration. The lowest value of the total time required for the execution of the computations may be determined and the corresponding value of the thread count may be determined. This determined value of the thread count may correspond to the optimal number of threads required to execute the computations thereby optimizing the execution of the business process A. 

In an embodiment consider that business process A may be related to database operations. Consider that business process A executes on a master thread and does not include any additional threads e.g. child threads . Hence the total time required to execute the computations in business process A may be calculated using Equation 2 and this value may represent the maximum total time required to execute the computations in business process A . The execution of the business process A may be optimized by iteratively incrementing the thread count and calculating the corresponding value of the total time required for executing the computations.

By way of example consider the number of computations N as equal to 100 the time required for each computation c as equal to 8 ms milliseconds and the fixed additional processing time required for each thread f as equal to 89 ms. On substituting these values in Equation 2 the maximum total time T required for the execution of business process A may be computed as T 889 ms.

In an embodiment consider that the thread count associated with the execution of the computations in business process A is iteratively incremented and the number of computations in each thread gets divided based on the number of thread count. Table 1 exemplarily illustrates total time required to execute business process A based on an iterative increment in the thread count and number of computations in each thread.

In an embodiment the columns of Table 1 includes attributes such as INDEX THREAD COUNT THREAD CREATION TIME FIXED PROCESSING TIME NUMBER OF COMPUTATIONS IN EACH THREAD COMPUTATION TIME TOTAL TIME etc. The rows of Table 1 includes corresponding attribute values and the values in the column TOTAL TIME corresponds to the total time required for executing the computations in business process A . Based on the attribute value of THREAD COUNT the attribute values of TOTAL TIME may be computed using Equation 1 or Equation 2 . By way of example the attribute value 0 for THREAD COUNT corresponds to execution of the computations of the business process A on the master thread. The attribute value 2 3 4 etc. corresponds to execution of the computations of the business process A on multiple child threads.

By way of illustration Table 1 shows that the attribute values in TOTAL TIME decreases or reduces when the attribute value of THREAD COUNT is iteratively incremented. Based on an iterative increment e.g. increment in value by 1 in the attribute value of THREAD COUNT and the corresponding number of computations the total time required to execute the computations in the business process A may be calculated. In each iteration the attribute value TOTAL TIME may be compared with its corresponding attribute value in the previous iteration. By way of example the attribute value TOTAL TIME for INDEX I2 may be compared with the attribute value TOTAL TIME for INDEX I1 and so on.

In an embodiment by iteratively incrementing the thread count calculating the total time required for executing the computations comparing the attribute values in TOTAL TIME for each iteration and identifying the corresponding thread count the optimal number of threads for execution of the business process A may be determined. By way of example Table 1 shows that the attribute values in TOTAL TIME keeps decreasing with an increment of the thread count that is till the thread count reaches 6 indicated by indices I1 to I6 upon further incrementing the thread count the attribute value TOTAL TIME starts increasing indicated by indices I7 to I10 . The attribute value TOTAL TIME is lowest for the attribute value in THREAD COUNT 6 and starts increasing when the attribute value in THREAD COUNT is incremented. Hence it may be determined that the optimal number of threads for executing business process A is 6. In an embodiment the optimal number of threads may correspond to a minimum total time required to execute the computations in business process A . The minimum total time e.g. lowest total time required to execute the business process A may be further reduced by execution of inter thread optimization model thereby optimizing the execution of business process A .

In an embodiment by iteratively reallocating the computations between the determined optimal number of threads the execution of the business process A may be optimized. As explained previously the optimal number of threads required for executing the computations of business process A may be determined by thread optimization model. Each thread may be created or generated serially. The execution of business process A may be further optimized by iteratively distributing or reallocating the computations between the optimal number of threads. In an embodiment the computations in each thread from the optimal number of threads may be independent and reallocating the computations of one thread may not interrupt its own execution. The time required for executing each computation in each thread may be less than the time required for creating the thread itself. To reallocate the computations between the optimal number of threads a time required to create a thread e.g. a first thread and a total time required to execute computations in the first thread is determined at . Upon such determination the computations in the first thread may be partitioned or divided into time slots. Each time slot may correspond to the time taken to create the thread.

In an embodiment based on the time slots e.g. partitions created in the first thread the computations in the optimal number of threads are partitioned into time slots at . The time slot in each thread may be equal to the time taken to create the thread. In an embodiment upon creating partitions in the optimal number of threads a total time required to execute the computations in the last thread may be determined. The total time required to execute the computations in the first thread a second thread a third thread etc. may be less than the total time required to execute the computations in the last thread e.g. in the optimal number of threads the threads may be referred to as first thread second thread last thread etc. .

In an embodiment the execution of the business process A is completed when the computations in the last thread is completed. In an embodiment the execution of the computations in the first thread second thread etc. may be completed before the creation of the last thread e.g. based on number of computations and time taken for execution of each computation . Since execution of the computations in the last thread completes the execution of the business process A there may be free time slots available between the first thread and a second last thread. An iterative determination of such available free time slots in the optimal number of threads is made based on the total time required to execute the computations in the last thread at . The availability of free time slots may be iteratively determined by parsing the threads and identify or determine the time taken to complete the execution of the computations. Upon such determination the computations from the last thread may be reallocated to the available free time slots in the optimal number of threads to optimize the execution of business process A at . Such reallocation may reduce the total time required to execute the computations associated with the business process A .

In an embodiment when all the computations of the last thread are iteratively reallocated between the first thread and the second last thread the last thread may be released from business process A . The mechanism to determine the available free time slots in the optimal number of threads and reallocate or distribute of the computations between the optimal number of threads may continue iteratively until the all the computations that are waiting to be reallocated are distributed between the optimal number of threads.

In an embodiment when an availability of a free time slot is determined in higher order threads e.g. first thread second thread etc. then the computations in lower order threads e.g. last thread second last thread etc. may be iteratively distributed or reallocated between the higher order threads. Since the time taken for executing computations in the higher order threads may greater than that in the lower order threads reallocation or distribution of the computations reduces the total time required to complete execution thereby optimizing the execution of the business process.

In an embodiment Table 2 exemplarily illustrates the available free time slots in the threads for execution of the business process.

By way of illustration Table 2 shows the AVAILABLE FREE TIME SLOTS corresponding THREAD and INDICATOR information. Table 2 is generated based on available free time slots in each thread. In an embodiment based on the time taken for executing computations in the last thread e.g. thread 6 the availability of free time slots in the optimal number of threads may be iteratively determined. In the example above it may be iteratively determined that there are a total of 15 free time slots available between the first thread e.g. thread 1 and the second last thread e.g. thread 5 . Upon such determination the computations of the last thread e.g. thread 6 may be distributed or reallocated in the available free time slots between the first thread e.g. thread 1 and the second last thread e.g. thread 5 by executing inter thread computations optimization model.

In an embodiment the number of available free time slots is based on the optimal number of threads required for executing the computations in the business process. For instance if k is the number of optimal number of threads required for executing the computations in the business process then the number of available free time slots may be determined by computing summation of free time slots between the first thread and k 1 threads. In general sum of first n natural integers S may be computed using the formula 

In an embodiment if a is the number of available free time slots then substituting n with k 1 in Equation 3 yields 

In an embodiment upon releasing the last thread e.g. thread 6 from participating in the execution of the business process it may be determined that the total number of free time slots that are available is reduced to 10. By way of illustration shows the time slots indicated by K L M N and O are lost e.g. lost time slots as the result of releasing thread 6 thereby reducing the number of available free time slots to 10. In an embodiment any further reallocation of the computations may result in releasing more threads e.g. the second last thread thread 5 from participating in the execution of the business process. In such a scenario the inter thread computations optimization model may determine that reallocations or distribution of the computations in the optimal number of threads may not be possible and the mechanism to reallocate computations stops. Legend in shows the thread creation which corresponds to the time taken or required to create a thread computations which corresponds to the time taken to execute a computation reallocated computations which corresponds to the computations that are reallocated available free time slots which corresponds to the number of available free time slots released thread which corresponds to the thread that is released from participation in the execution of the business process and lost time slots which corresponds to the time slots that are lost as the result of releasing thread.

In an embodiment when the computations in the second last thread e.g. thread 5 are reallocated or distributed among the remaining available free time slots e.g. between thread 2 and thread 4 indicated by G H F I and J and the second last thread e.g. thread 5 is released from participation in the execution of business process it may result in losing 4 more time slots e.g. when thread 5 is released from participating in the business process time slots indicated by G H I and J may be lost . This may result in loss of the computations in the remaining optimal number of threads e.g. between thread 1 and thread 4 . Hence the process of iteratively distributing or reallocating the computations between the optimal number of threads may be stopped.

By way of example consider a scenario that the business process is executed using static or fixed number of threads e.g. thread count of n 1 n 2000 and n 5000 . For instance consider that number of computations in each thread i is 8 fixed additional processing time f is 89 ms and time taken to create the thread t is 21 ms and memory used by each thread is about 500 KB kilobytes then the total time required for the execution of business process may be computed using Equation 1 and Equation 2 as follows 

By way of example consider Table 2 exemplarily illustrating calculating total time required to execute business process using the thread optimization model where the thread count it iteratively incremented.

According to Table 2 the attribute values in TOTAL TIME decreases or reduces when the attribute value of THREAD COUNT is iteratively incremented by 1 and is based on the number of computations. The total time required to execute the computations in the business process may be calculated using Equation 1 and Equation 2 . As explained previously for each iteration the attribute value TOTAL TIME may be compared with its corresponding attribute value in the previous iteration and the optimal number of threads for the execution of business process may be determined.

In an embodiment by the execution of thread optimization model it may be determined that the optimal number of threads for executing the business process may be determined as 617 e.g. corresponding to lowest value of TOTAL TIME indicated by INDEX I8 and the corresponding total time for executing the computations as 26011.96 ms. For this value of thread count the total memory required for executing computations may be computed as 

In an embodiment the execution of the business process may further be optimized by executing the inter thread computations optimization model which iteratively distributes or reallocates the computations in the optimal number of threads. By way of example Table 3 exemplarily illustrates execution of inter thread computations optimization model that may iteratively reduce the thread count by iteratively reallocating or distributing the computations between the optimal number of threads required for executing the business process.

Table 3 shows columns representing attributes such as INDEX NUMBER OF THREADS REDUCED OPTIMAL NUMBER OF THREADS AVAILABLE FREE TIME SLOTS REALLOCATED COMPUTATIONS COMPUTATIONS AWAITED FOR REALLOCATION CONTINUE ITERATION etc. The attribute values of NUMBER OF THREADS REDUCED are iteratively incremented and the corresponding attribute values of AVAILABLE FREE TIME SLOTS REALLOCATED COMPUTATIONS and COMPUTATIONS AWAITED FOR REALLOCATION are determined. It may be noted that the attribute values of COMPUTATIONS AWAITED FOR REALLOCATION iteratively decrease in value with an increment in the value of NUMBER OF THREADS REDUCED e.g. corresponding to indices I1 to I5 . Based on the value of COMPUTATIONS AWAITED FOR REALLOCATION the reduced thread count e.g. NUMBER OF THREADS REDUCED may be determined. The iterations may be stopped when there are no more computations left for reallocation. By way of example Table 3 shows that value of COMPUTATIONS AWAITED FOR REALLOCATION becomes negative and it may be determined that the value of thread count e.g. maximum number of threads that may be reduced is 165 e.g. corresponding to INDEX I5 .

In an embodiment upon determining a value that corresponds to the maximum number of threads that may be reduced the thread count for executing the business process may be determined. For instance the value of maximum number of threads that may be reduced may be subtracted from the optimal number of threads required for the execution of the business process. Therefore the number of threads required for executing the business process may be computed to be equal to a difference between the optimal number of threads required for executing the business process and the number of threads reduced represented by 

In an embodiment using the value of thread count obtained from Equation 5 the total time required and the memory utilized for executing the business process may be computed as follows 

In an embodiment by executing the thread optimization model and inter thread computations optimization model the number of threads required for executing the business process may be reduced. The execution of the above models not only optimizes the execution of the business process but also reduces the computing resources utilized.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components may be implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open Data Base Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the one or more embodiments are described herein for illustrative purposes various equivalent modifications are possible within the scope as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

