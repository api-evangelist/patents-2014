---

title: System and method for authenticating a client to a device
abstract: A system, apparatus, method, and machine readable medium are described for authenticating a client to a device. For example, one embodiment of a method comprises: registering an authenticator of a client with a relying party, the registration allowing a user of the client to remotely authenticate the user to the relying party over a network; generating a first authentication structure using at least a first authentication key associated with the authenticator and a signature generated with a first verification key; caching the first authentication structure on the client; providing a second verification key corresponding to the first verification key to a transaction device; performing an authentication transaction between the client and the transaction device in which the client generates a second authentication structure using a second authentication key associated with the first authentication key, the transaction device uses the second verification key to validate the signature on the first authentication structure and uses the first authentication key to validate the second authentication structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09450760&OS=09450760&RS=09450760
owner: NOK NOK LABS, INC.
number: 09450760
owner_city: Palo Alto
owner_country: US
publication_date: 20140731
---
This invention relates generally to the field of data processing systems. More particularly the invention relates to a system and method for authenticating a client to a device such as an offline device or a device having limited connectivity to a relying party.

Systems have also been designed for providing secure user authentication over a network using biometric sensors. In such systems the score generated by the application and or other authentication data may be sent over a network to authenticate the user with a remote server. For example Patent Application No. 2011 0082801 801 application describes a framework for user registration and authentication on a network which provides strong authentication e.g. protection against identity theft and phishing secure transactions e.g. protection against malware in the browser and man in the middle attacks for transactions and enrollment management of client authentication tokens e.g. fingerprint readers facial recognition devices smartcards trusted platform modules etc .

The assignee of the present application has developed a variety of improvements to the authentication framework described in the 801 application. Some of these improvements are described in the following set of U.S. patent applications Co pending applications all filed Dec. 29 1012 which are assigned to the present assignee Ser. No. 13 730 761 Query System and Method to Determine Authentication Capabilities Ser. No. 13 730 776 System and Method for Efficiently Enrolling Registering and Authenticating With Multiple Authentication Devices Ser. No. 13 730 780 System and Method for Processing Random Challenges Within an Authentication Framework Ser. No. 13 730 791 System and Method for Implementing Privacy Classes Within an Authentication Framework Ser. No. 13 730 795 System and Method for Implementing Transaction Signaling Within an Authentication Framework.

Briefly the Co Pending Applications describe authentication techniques in which a user enrolls with biometric devices of a client to generate biometric template data e.g. by swiping a finger snapping a picture recording a voice etc registers the biometric devices with one or more servers over a network e.g. Websites or other relying parties equipped with secure transaction services as described in the Co Pending Applications and subsequently authenticates with those servers using data exchanged during the registration process e.g. encryption keys provisioned into the biometric devices . Once authenticated the user is permitted to perform one or more online transactions with a Website or other relying party. In the framework described in the Co Pending Applications sensitive information such as fingerprint data and other data which can be used to uniquely identify the user may be retained locally on the user s client device e.g. smartphone notebook computer etc to protect a user s privacy.

Described below are embodiments of an apparatus method and machine readable medium for implementing advanced authentication techniques and associated applications. Throughout the description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known structures and devices are not shown or are shown in a block diagram form to avoid obscuring the underlying principles of the present invention.

The embodiments of the invention discussed below involve client devices with authentication capabilities such as biometric devices or PIN entry. These devices are sometimes referred to herein as tokens authentication devices or authenticators. While certain embodiments focus on facial recognition hardware software e.g. a camera and associated software for recognizing a user s face and tracking a user s eye movement some embodiments may utilize additional biometric devices including for example fingerprint sensors voice recognition hardware software e.g. a microphone and associated software for recognizing a user s voice and optical recognition capabilities e.g. an optical scanner and associated software for scanning the retina of a user . The authentication capabilities may also include non biometric devices such as trusted platform modules TPMs and smartcards.

In a mobile biometric implementation the biometric device may be remote from the relying party. As used herein the term remote means that the biometric sensor is not part of the security boundary of the computer it is communicatively coupled to e.g. it is not embedded into the same physical enclosure as the relying party computer . By way of example the biometric device may be coupled to the relying party via a network e.g. the Internet a wireless network link etc or via a peripheral input such as a USB port. Under these conditions there may be no way for the relying party to know if the device is one which is authorized by the relying party e.g. one which provides an acceptable level of authentication and integrity protection and or whether a hacker has compromised the biometric device. Confidence in the biometric device depends on the particular implementation of the device.

However as discussed below the authentication techniques employed to authenticate the user may involve non location components such as communication over a network with remote servers and or other data processing devices. Moreover while specific embodiments are described herein such as an ATM and retail location it should be noted that the underlying principles of the invention may be implemented within the context of any system in which a transaction is initiated locally or remotely by an end user.

The term relying party is sometimes used herein to refer not merely to the entity with which a user transaction is attempted e.g. a Website or online service performing user transactions but also to the secure transaction servers implemented on behalf of that entity which may performed the underlying authentication techniques described herein. The secure transaction servers which provided remote authentication capabilities may be owned and or under the control of the relying party or may be under the control of a third party offering secure transaction services to the relying party as part of a business arrangement.

The term server is used herein to refer to software executed on a hardware platform or across multiple hardware platforms that receives requests over a network from a client responsively performs one or more operations and transmits a response to the client typically including the results of the operations. The server responds to client requests to provide or help to provide a network service to the clients. Significantly a server is not limited to a single computer e.g. a single hardware device for executing the server software and may in fact be spread across multiple hardware platforms potentially at multiple geographical locations.

The embodiments of the invention described herein include techniques for authenticating a user for a transaction initiated through a secure transaction device. By way of example the transaction may be a withdrawal transfer or other user initiated operation and the transaction device may be an automatic teller machine ATM point of sale PoS transaction device or other device capable of executing transactions on behalf of the user. The transaction may involve for example completing a payment to purchase goods or services at a retail store or other retail location equipped with the device withdrawing funds via the device performing maintenance on the device or any other transaction for which user authentication is required.

One embodiment of the invention provides techniques for authenticating the user locally i.e. verifying the user even in circumstances where the device is offline i.e. not connected to a back end authentication server or semi offline i.e. only periodically connected to a back end authentication server . In one embodiment the user s client device is provided with the ability to cache authentication requests generated by a back end authentication server e.g. operated on behalf of the relying party and the device is provided with data needed to verify the authentication response transmitted from the user s client device to the device.

Prior to discussing the details of these embodiments of the invention an overview of remote user authentication techniques will be provided. These and other remote user authentication techniques are described in the co pending applications which are assigned to the assignee of the present application and incorporated herein by reference.

Turning to the illustrated embodiment includes a client equipped with one or more authentication devices for enrolling and authenticating an end user. As mentioned above the authentication devices may include biometric devices such as fingerprint sensors voice recognition hardware software e.g. a microphone and associated software for recognizing a user s voice facial recognition hardware software e.g. a camera and associated software for recognizing a user s face and optical recognition capabilities e.g. an optical scanner and associated software for scanning the retina of a user and non biometric devices such as a trusted platform modules TPMs and smartcards. A user may enroll the biometric devices by providing biometric data e.g. swiping a finger on the fingerprint device which the secure transaction service may store as biometric template data in secure storage via interface .

While the secure storage is illustrated outside of the secure perimeter of the authentication device s in one embodiment each authentication device may have its own integrated secure storage. Additionally each authentication device may cryptographically protect the biometric reference data records e.g. wrapping them using a symmetric key to make the storage secure .

The authentication devices are communicatively coupled to the client through an interface e.g. an application programming interface or API exposed by a secure transaction service . The secure transaction service is a secure application for communicating with one or more secure transaction servers over a network and for interfacing with a secure transaction plugin executed within the context of a web browser . As illustrated the Interface may also provide secure access to a secure storage device on the client which stores information related to each of the authentication devices such as a device identification code such as an Authenticator Attestation ID AAID user identification code user enrollment data e.g. scanned fingerprint or other biometric data and keys used to perform the secure authentication techniques described herein. For example as discussed in detail below a unique key may be stored into each of the authentication devices and subsequently used when communicating to servers over a network such as the Internet.

As discussed below certain types of network transactions are supported by the secure transaction plugin such as HTTP or HTTPS transactions with websites or other servers. In one embodiment the secure transaction plugin is initiated in response to specific HTML tags inserted into the HTML code of a web page by the web server within the secure enterprise or Web destination sometimes simply referred to below as server . In response to detecting such a tag the secure transaction plugin may forward transactions to the secure transaction service for processing. In addition for certain types of transactions e.g. such as secure key exchange the secure transaction service may open a direct communication channel with the on premises transaction server i.e. co located with the website or with an off premises transaction server .

The secure transaction servers are coupled to a secure transaction database for storing user data authentication device data keys and other secure information needed to support the secure authentication transactions described below. It should be noted however that the underlying principles of the invention do not require the separation of logical components within the secure enterprise or web destination shown in . For example the website and the secure transaction servers may be implemented within a single physical server or separate physical servers. Moreover the website and transaction servers may be implemented within an integrated software module executed on one or more servers for performing the functions described below.

As mentioned above the underlying principles of the invention are not limited to a browser based architecture shown in . illustrates an alternate implementation in which a stand alone application utilizes the functionality provided by the secure transaction service to authenticate a user over a network. In one embodiment the application is designed to establish communication sessions with one or more network services which rely on the secure transaction servers for performing the user client authentication techniques described in detail below.

In either of the embodiments shown in the secure transaction servers may generate the keys which are then securely transmitted to the secure transaction service and stored into the authentication devices within the secure storage . Additionally the secure transaction servers manage the secure transaction database on the server side.

A secure key provisioning protocol such as the Dynamic Symmetric Key Provisioning Protocol DSKPP may be used to share the key with the client over a secure communication channel see e.g. Request for Comments RFC 6063 . However the underlying principles of the invention are not limited to any particular key provisioning protocol.

Turning to the specific details shown in once the user enrollment or user verification is complete the server generates a randomly generated challenge e.g. a cryptographic nonce that must be presented by the client during device registration. The random challenge may be valid for a limited period of time. The secure transaction plugin detects the random challenge and forwards it to the secure transaction service . In response the secure transaction service initiates an out of band session with the server e.g. an out of band transaction and communicates with the server using the key provisioning protocol. The server locates the user with the user name validates the random challenge validates the device s attestation code e.g. AAID if one was sent and creates a new entry in the secure transaction database for the user. It may also generate the key or public private key pair write the key s to the database and send the key s back to the secure transaction service using the key provisioning protocol. Once complete the authentication device and the server share the same key if a symmetric key was used or different keys if asymmetric keys were used.

The secure transaction confirmation is designed to provide stronger security for certain types of transactions e.g. financial transactions . In the illustrated embodiment the user confirms each transaction prior to committing the transaction. Using the illustrated techniques the user confirms exactly what he she wants to commit and commits exactly what he she sees displayed in a window of the graphical user interface GUI . In other words this embodiment ensures that the transaction text cannot be modified by a man in the middle MITM or man in the browser MITB to commit a transaction which the user did not confirm.

In one embodiment the secure transaction plugin displays a window in the browser context to show the transaction details. The secure transaction server periodically e.g. with a random interval verifies that the text that is shown in the window is not being tampered by anyone e.g. by generating a hash signature over the displayed text . In a different embodiment the authentication device has a trusted user interface e.g. providing an API compliant to GlobalPlatform s TrustedUI .

The following example will help to highlight the operation of this embodiment. A user chooses items for purchase from a merchant site and selects check out. The merchant site sends the transaction to a service provide which has a secure transaction server implementing one or more of the embodiments of the invention described herein e.g. PayPal . The merchant site authenticates the user and completes the transaction.

The secure transaction server receives the transaction details TD and puts a Secure Transaction request in an HTML page and sends to client . The Secure Transaction request includes the transaction details and a random challenge. The secure transaction plugin detects the request for transaction confirmation message and forwards all data to the secure transaction service . In an embodiment which does not use a browser or plugin the information may be sent directly from the secure transaction servers to the secure transaction service on the client .

For a browser based implementation the secure transaction plugin displays a window with transaction details to the user e.g. in a browser context and asks the user to provide authentication to confirm the transaction. In an embodiment which does not use a browser or plugin the secure transaction service the application or the authentication device may display the window . The secure transaction service starts a timer and verifies the content of the window being displayed to the user. The period of verification may be randomly chosen. The secure transaction service ensures that user sees the valid transaction details in the window e.g. generating a hash on the details and verifying that the contents are accurate by comparing against a hash of the correct contents . If it detects that the content has been tampered with it prevents the confirmation token signature from being generated.

After the user provides valid verification data e.g. by swiping a finger on the fingerprint sensor the authentication device verifies the user and generates a cryptographic signature sometimes referred to as a token with the transaction details and the random challenge i.e. the signature is calculated over the transaction details and the nonce . This allows the secure transaction server to ensure that the transaction details have not been modified between the server and the client. The secure transaction service sends the generated signature and username to the secure transaction plugin which forwards the signature to the secure transaction server . The secure transaction server identifies the user with the username and verifies the signature. If verification succeeds a confirmation message is sent to the client and the transaction is processed.

One embodiment of the invention implements a query policy in which a secure transaction server transmits a server policy to the client indicating the authentication capabilities accepted by the server. The client then analyzes the server policy to identify a subset of authentication capabilities which it supports and or which the user has indicated a desire to use. The client then registers and or authenticates the user using the subset of authentication tokens matching the provided policy. Consequently there is a lower impact to the client s privacy because the client is not required to transmit exhaustive information about its authentication capabilities e.g. all of its authentication devices or other information which might be used to uniquely identify the client.

By way of example and not limitation the client may include numerous user verification capabilities such as a fingerprint sensor voice recognition capabilities facial recognition capabilities eye optical recognition capabilities PIN verification to name a few. However for privacy reasons the user may not wish to divulge the details for all of its capabilities to a requesting server. Thus using the techniques described herein the secure transaction server may transmit a server policy to the client indicating that it supports for example fingerprint optical or smartcard authentication. The client may then compare the server policy against its own authentication capabilities and choose one or more of the available authentication options.

One embodiment of the invention employs transaction signing on the secure transaction server so that no transaction state needs to be maintained on the server to maintain sessions with clients. In particular transaction details such as transaction text displayed within the window may be sent to the client signed by the server. The server may then verify that the signed transaction responses received by the client are valid by verifying the signature. The server does not need to persistently store the transaction content which would consume a significant amount of storage space for a large number of clients and would open possibility for denial of service type attacks on server.

One embodiment of the invention is illustrated in which shows a website or other network service initiating a transaction with a client . For example the user may have selected items for purchase on the website and may be ready to check out and pay. In the illustrated example the website or service hands off the transaction to a secure transaction server which includes signature processing logic for generating and verifying signatures as described herein and authentication logic for performing client authentication e.g. using the authentication techniques previously described .

In one embodiment the authentication request sent from the secure transaction server to the client includes the random challenge such as a cryptographic nonce as described above the transaction details e.g. the specific text presented to complete the transaction and a signature generated by the signature processing logic over the random challenge and the transaction details using a private key known only by the secure transaction server .

Once the above information is received by the client the user may receive an indication that user verification is required to complete the transaction. In response the user may for example swipe a finger across a fingerprint scanner snap a picture speak into a microphone or perform any other type of authentication permitted for the given transaction. In one embodiment once the user has been successfully verified by the authentication device the client transmits the following back to the server 1 the random challenge and transaction text both previously provided to the client by the server 2 authentication data proving that the user successfully completed authentication and 3 the signature.

The authentication module on the secure transaction server may then confirm that the user has correctly authenticated and the signature processing logic re generates the signature over the random challenge and the transaction text using the private key. If the signature matches the one sent by the client then the server can verify that the transaction text is the same as it was when initially received from the website or service . Storage and processing resources are conserved because the secure transaction server is not required to persistently store the transaction text or other transaction data within the secure transaction database .

As mentioned one embodiment of the invention includes techniques for authenticating the user locally i.e. verifying the user even in circumstances where the user device and device are offline i.e. not connected to a back end authentication server of a relying party or semi offline i.e. where the user device is not connected to the relying party but the device is . illustrates one such arrangement in which a client with authentication devices previously registered with a relying party establishes a secure channel with a transaction device to complete a transaction. By way of example and not limitation the transaction device may be an ATM point of sale PoS transaction device at a retail location Internet of Things IoT device or any other device capable of establishing a channel with the client and allowing the user to perform a transaction. The channel may be implemented using any wireless communication protocol including by way of example and not limitation near field communications NFC and Bluetooth e.g. Bluetooth Low Energy BTLE as set forth in the Bluetooth Core Specification Version 4.0 . Of course the underlying principles of the invention are not limited to any particular communication standard.

As indicated by the dotted arrows the connection between the client and the relying party and or the connection between the transaction device and the relying party may be sporadic or non existent. Real world applications in the area of payments often rely on such off line use cases. For example a user with a client e.g. a Smartphone may not have connectivity to the relying party at the time of the transaction but may want to authorize a transaction e.g. a payment by authenticating to the transaction device . However in some embodiments of the invention the client and or transaction device do exchange some information with the relying party although not necessarily during the authentication or transaction confirmation process described herein .

Traditionally user verification has been implemented using a secret such as a personal identification number PIN to be captured by the device e.g. the PoS transaction device or ATM . The device would then create an online connection to the relying party in order to verify the secret or would ask the user s authenticator e.g. EMV banking card for verifying the PIN. Such implementation has several disadvantages. It might require an online connection which might be available sometimes but not always. It also requires the user to enter a long term valid secret into potentially untrusted devices which are subject to shoulder surfing and other attacks. Additionally it is inherently tied to the specific user verification method e.g. PIN in this case . Finally it requires the user to remember a secret such as a PIN which may be inconvenient to the user.

The authentication techniques described herein provide significantly more flexibility in terms of user verification methods and security as they allow the user to rely on his her own client s authentication capabilities. In particular in one embodiment a mobile application on the user s client caches authentication requests provided by the relying party during a time when the client is connected to the relying party. The authentication requests may include the same or similar information as the authentication requests described above e.g. a nonce and a public key associated with an authenticator as well as additional information including a signature over at least parts of the authentication request generated by a relying party the verification key and potentially timing data indicating the time period within which the authentication request will remain valid or conversely the time after which the authentication request will expire . In one embodiment the mobile application may cache multiple such connection requests e.g. one for each transaction device or transaction device type .

In one embodiment the cached authentication requests may then be used for transactions with the transaction device in circumstances where the client mobile app is incapable of connecting with the relying party. In one embodiment the mobile app triggers the creation of the authentication response based on the cached authentication request containing the serverData and additional data received from the transaction device. The authentication response is then transmitted to the transaction device which then verifies the authentication response using a verification key provided from the relying party e.g. during a time when the transaction device is connected with the relying party . In particular the transaction device may use the key provided by the relying party to verify the signature over the serverData included in the authentication response. In one embodiment the signature is generated by the relying party using a private relying party verification key and the transaction device verifies the signature using a corresponding public relying party verification key provided to the transaction device by the relying party .

Once the transaction device verifies the serverData extracted from the authentication response it may then use the public key extracted from the authentication request e.g. Uauth.pub to verify the authentication response generated by the client mobile app e.g. in the same or a similar manner to the verifications by the relying party described above when the client is authenticating directly to the relying party .

In an alternate embodiment described below the relying party provides the authentication request directly to the transaction device rather than through the mobile app on the client device . In this embodiment the transaction device may ask for the authentication request from the relying party upon receiving a request to complete a transaction from the mobile app on the client. Once it has the authentication request it may validate the request and the authentication response as described above e.g. by generating a signature and comparing it to the existing signature .

At the client requests a cacheable authentication request from the relying party. At the relying party generates the cacheable authentication request at the authentication request is sent to the client and at the client caches the authentication request. In one embodiment the authentication request includes the public key associated with the authenticator to be used for authentication Uauth.pub and a signature generated using the relying party verification key RPVerifyKey over the public key and a random nonce. If asymmetric keys are used then RPVerifyKey used by the relying party to generate the signature is a private key having a corresponding public RPVerifyKey which the relying party has provided to the transaction device potentially far in advance of processing the user authentication request .

In one embodiment the authentication request also includes timing information indicating the length of time for which the authentication request will be valid e.g. MaxCacheTime . In this embodiment the signature for the cacheable authentication request may be generated over the combination of the public authentication key the nonce and the MaxCacheTime e.g. ServerData Uauth.pub MaxCacheTime serverNonce Sign RPVerifyKey Uauth.pub MaxCacheTime serverNonce . In one embodiment the authentication response includes more than one authentication key e.g. one for each authenticator capable of authenticating the user and the signature may be generated over all of these keys e.g. along with the nonce and the MaxCacheTime .

As mentioned the public RPVerifyKey needs to be known the transaction device or any device intended to perform offline verification of the authentication requests responses. This extension is required because the transaction device does not have any knowledge about the authentication keys registered at the relying party i.e. no established relation exists between user device and the transaction device . Consequently the relying party must communicate to the transaction device or other device in a secure manner which key s are to be used for authentication response verification. The transaction device will verify the MaxCacheTime to determine whether the cached authentication request is still valid to comply with the relying party s policy on how long the cached authentication request may be used .

At the client establishes a secure connection to the transaction device and initiates a transaction. For example if the transaction device is a PoS transaction device the transaction may involve a debit or credit transaction. If the transaction device is an ATM the transaction may involve a cash withdrawal or a maintenance task. The underlying principles of the invention are not limited to any particular type of transaction device or secure connection. In addition at the client may transmit the cached authentication request to the transaction device.

In response at the transaction device may transmit device identity information e.g. a transaction device identification code a random challenge nonce and optionally transaction text in a defined syntax to complete the transaction. The random challenge nonce will then be cryptographically bound to the authentication response. This mechanism allows the device to verify that the user verification is fresh and hasn t been cached reused.

In order to support transaction confirmations such as described above see e.g. and associated text the transaction device may be required to create a standardized and human readable representation of the transaction. Standardized as used herein means a format that can be parsed by the relying party e.g. for final verification as indicated in operation below and or the transaction device. It needs to be human readable because transaction confirmations require the authenticator to display it on the secure display of the client . An example of such an encoding could be XML where XSLT is used for visualization.

At to generate the authentication response an authentication user interface is displayed directing the user to perform authentication on the client using a particular authenticator e.g. to swipe a finger on a fingerprint sensor enter a PIN code speak into a microphone etc . Once the user provides authentication the authentication engine on the client verifies the identity of the user e.g. comparing the authentication data collected from the user with the user verification reference data stored in the secure storage of the authenticator and uses the private key associated with the authentication device to encrypt and or generate a signature over the random challenge and also potentially the transaction device ID and or the transaction text . The authentication response is then transmitted to the transaction device at .

At the transaction device uses the public RPVerifyKey to verify the signature on the serverData received at if it has not done so already. Once the serverData is verified it knows the public key associated with the authenticator used to perform the authentication Uauth.pub . It uses this key to verify the authentication response. For example it may use the public authentication key to decrypt or verify the signature generated over the nonce and any other related information e.g. the transaction text the transaction device ID etc . If transaction confirmation is performed by the transaction device then it may verify the transaction text displayed on the client by validating the signature generated over the transaction text and included in the authentication response at . Instead of having a cryptographically secured serverData structure the transaction device could also verify unsigned serverData using an online connection to the relying party if this is available semi offline case .

At a success or failure indication is sent to the client depending on whether authentication was successful or unsuccessful respectively. If successful the transaction device will permit the transaction e.g. debiting crediting an account to complete a purchase dispensing cash performing administrative task etc . If not it will disallow the transaction and or request additional authentication.

If a connection to the relying party is present then at the transaction device may transmit the authentication response to the relying party and or the transaction text assuming that the relying party is the entity responsible for verifying the transaction text . A record of the transaction may be recorded at the relying party and or the relying party may verify the transaction text and confirm the transaction not shown .

At the client initiates a transaction establishing a secure connection with the transaction device e.g. NFC Bluetooth etc . At the transaction device responsively asks for an authentication request from the relying party. At the relying party generates the authentication request and at the authentication request is sent to the transaction device. As in the embodiment shown in the authentication request may include the public key associated with the authenticator on the client to be used for authentication Uauth.pub and a signature generated using the relying party verification key RPVerifyKey over the public key and a random nonce. If asymmetric keys are used then RPVerifyKey used by the relying party to generate the signature is a private key having a corresponding public RPVerifyKey which the relying party provides to the transaction device potentially far in advance of processing the user authentication request . Instead of having a cryptographically secured serverData structure the transaction device may also verify unsigned serverData using an online connection to the relying party if this is available semi offline case .

In one embodiment the serverData also includes timing information indicating the length of time for which the authentication request will be valid e.g. MaxCacheTime . In this embodiment the signature for the serverData may be generated over the combination of the public authentication key the nonce and the MaxCacheTime e.g. ServerData Uauth.pub MaxCacheTime serverNonce Sign RPVerifyKey Uauth.pub MaxCacheTime serverNonce . In one embodiment the authentication response includes more than one authentication key e.g. one for each authenticator and the signature may be generated over all of these keys e.g. along with the nonce and the MaxCacheTime .

In one embodiment the remainder of the transaction diagram in operates substantially as shown in . At the transaction device may transmit identity information e.g. a transaction device identification code a random challenge nonce and optionally transaction text in a defined syntax to complete the transaction. The random challenge nonce will then be cryptographically bound to the authentication response. This mechanism allows the device to verify that the user verification is fresh and hasn t been cached.

In order to support transaction confirmations such as described above see e.g. and associated text the transaction device may be required to create a standardized and human readable representation of the transaction. Standardized as used herein means a format that can be parsed by the relying party e.g. for final verification as indicated in operation below and or the transaction device. It needs to be human readable because transaction confirmations require the authenticator to display it on the secure display of the client . An example of such an encoding could be XML where XSLT is used for visualization.

At to generate the authentication response an authentication user interface is displayed directing the user to perform authentication on the client using a particular authenticator e.g. to swipe a finger on a fingerprint sensor enter a PIN code speak into a microphone etc . Once the user provides authentication the authentication engine on the client verifies the identity of the user e.g. comparing the authentication data collected from the user with the user verification reference data stored in the secure storage of the authenticator and uses the private key associated with the authentication device to encrypt and or generate a signature over the random challenge and also potentially the transaction device ID and or the transaction text . The authentication response is then transmitted to the transaction device at .

At the transaction device uses the public RPVerifyKey to verify the signature on the serverData received at if it has not done so already. Once the serverData is verified it knows the public key associated with the authenticator used to perform the authentication Uauth.pub . It uses this key to verify the authentication response. For example it may use the public authentication key to decrypt or verify the signature generated over the nonce and any other related information e.g. the transaction text the transaction device ID etc . If transaction confirmation is performed by the transaction device then it may verify the transaction text displayed on the client by validating the signature generated over the transaction text and included in the authentication response at . Instead of having a cryptographically secured serverData structure the transaction device could also verify unsigned serverData using an online connection to the relying party if this is available semi offline case .

At a success or failure indication is sent to the client depending on whether authentication was successful or unsuccessful respectively. If successful the transaction device will permit the transaction e.g. debiting crediting an account to complete a purchase dispensing cash performing administrative task etc . If not it will disallow the transaction and or request additional authentication.

At the transaction device may transmit the authentication response to the relying party and or the transaction text assuming that the relying party is the entity responsible for verifying the transaction text . A record of the transaction may be recorded at the relying party and or the relying party may verify the transaction text and confirm the transaction not shown .

As illustrated in in one embodiment a mobile app is executed on the client to perform the operations described herein in combination with an authentication client which may be the secure transaction service and interface shown in . In particular the mobile app may open a secure channel to a web app executed on the transaction device using transport layer security TLS or other secure communication protocol. A web server on the transaction device may also open a secure channel to communicate with the relying party e.g. to retrieve authentication requests and or to provide updates to the relying party as discussed above . The authentication client may communicate directly with the relying party to for example retrieve cacheable authentication requests as discussed in detail above .

In one embodiment the authentication client may identify the relying party and any authorized Mobile Apps with an AppID which is a unique code associated with each application made available by a relying party. In some embodiments where a relying party offers multiple online services a user may have multiple AppIDs with a single relying party one for each service offered by the relying party .

In one embodiment any application identified by an AppID may have multiple facets which identify the allowable mechanisms and or application types for connecting with the relying party. For example a particular relying party may allow access via a Web service and via different platform specific mobile apps e.g. an Android App an iOS App etc . Each of these may be identified using a different FacetID which may be provided by the relying party to the authentication engine as illustrated.

In one embodiment the calling mobile app passes its AppID to the API exposed by the authentication client . On each platform the authentication client identifies the calling app and determines its FacetID. It then resolves the AppID and checks whether the FacetID is included in a TrustedApps list provided by the relying party .

In one embodiment the cacheable authentication requests discussed above may be implemented using bearer tokens such as illustrated in and . In the embodiments of the invention described herein the token recipient the transaction device needs to be able to verify the token the authentication response and the binding of the token to the authentication response without requiring another online connection to the token issuer the relying party .

1. Tokens which can only be verified by the recipient e.g. the transaction device using a different channel to the issuer e.g. the relying party that must exist between the token issuance and the token verification. This class of tokens is referred to herein as unsigned tokens. 

2. Tokens which can be verified by the recipient due to their cryptographic structure e.g. because they contain a digital signature which can be verified using data received from the token issuer potentially way before the specific token was issued. This class of tokens is referred to herein as signed tokens .

The term signed token structure Is used herein to refer to both the signed token including the Uauth.pub key and the signed structure containing the token.

As illustrated in in one embodiment in order to bind signed tokens to the Authentication Key the token issuer e.g. the relying party a adds the Authentication public key Uauth.pub to the to be signed portion of the to be signed token and b includes that signed token in the to be signed portion of the authentication response. By doing this the token recipient e.g. the transaction device can verify the token by validating the signature e.g. the public RPVerifyKey discussed above . If the verification succeeds it can extract the public key Uauth.pub and use it to verify the authentication response as previously discussed.

As illustrated in in order to bind unsigned tokens to the Authentication Key in one embodiment the token issuer e.g. the relying party creates a signed structure covering at least the original token and to be signed data which includes the authentication public key Uauth.pub . The signed structure can be verified by validating the signature using the public key related to the private signing key e.g. the RPVerifyKey pair discussed above . This public signing key needs to be shared with the token recipient e.g. the transaction device . Sharing can be done once after generation of the signing key pair potentially way before the first signed structure was generated.

The techniques described herein support both the full offline implementation i.e. the transaction device has no connection to the relying party at the time of the transaction as well as the semi offline implementation i.e. the transaction device has a connection to the relying party at the time of the transaction but the client does not.

Even in the full offline case the transaction device is still expected to be connected via a host from time to time to the relying party . For example the host may collect all responses stored in the transaction device in order to send them to the relying party and may also update if required the list of revoked Uauth keys e.g. the public authentication keys which have been revoked since the last connection .

Some embodiments also support pure session authentication as well as transaction confirmation. Even in the case of transaction confirmation the relying party can verify the transaction if the transaction device submits the transaction text along with the authentication response to the relying party .

A user has registered his authenticator e.g. a smartphone with a payment service provider PSP . The user wants to authenticate a payment at some merchant using a Point of Sale device PoS authorized by the PSP but the PoS doesn t have a reliable and permanent online connection to the PSP e.g. located in a Bus . In this example the PoS may be implemented as the transaction device and the PSP may be implemented as the relying party described above to allow the transaction notwithstanding the lack of a reliable and permanent connection.

A company has installed several embedded devices e.g. in a factory building etc. . Maintenance of such devices is performed by a technicians employed by a contracted party. For performing the maintenance the technician has to authenticate to the device in order to prove his eligibility for the task. The following assumptions are made based on realistic frame conditions 

a. The technician cannot perform registration with each of such devices as there are too many of them .

b. There are too many technicians and too much fluctuation of such technicians in order to keep the list of eligible technicians up to date on each of the devices.

c. Neither the device nor the technician s computer has a reliable network connection at the time of maintenance.

Using the techniques described above the company can inject a trust anchor e.g. the public RPVerifyKey into all devices once e.g. at installation time . Each technician then registers with the contracted party e.g. the relying party which may be the technician s employer . Using the above techniques the technician will be able to authenticate to each device.

The embodiments of the invention described above may be implemented in any system in which a client with authentication capabilities is registered with a relying party and the authentication operation is performed between this client and a device a acting on behalf of the relying party and b being offline i.e. not having a reliable network connection to the relying party s original server the client has been registered with at the time of transaction. In such a case the client receives a cacheable authentication request from the original server and caches it. Once it is required the client computes the authentication response and sends it to the device.

In another embodiment the client adds channel binding data received in the authentication request to the response in a cryptographically secure way. By doing this the relying party s original server can verify that the request was received by a legitimate client and not some man in the middle .

In one embodiment the relying party adds additional authenticated data to the response such as the Uauth.pub key which allows the device to verify the authentication or transaction confirmation response without having to contact the relying party server for retrieving the approved Uauth.pub key. In another embodiment the relying party requires the user of the client to perform a successful authentication before issuing the cacheable authentication requests in order to prevent denial of service attacks . In one embodiment the relying party requires the client to indicate whether a request needs to be cacheable or not. If cacheable the relying party may require additional authentication data in the response e.g. the MaxCacheTime discussed above .

In one embodiment a device such as the transaction device does not have a direct network connection to the relying party and is synchronized to the relying party using a separate computer sometimes referred to herein as the host . This host retrieves all collected authentication responses from the device and transfers them to the relying party. Additionally the host may also copy a list of revoked Uauth keys to the device to ensure that one of the revoked keys is not used in an authentication response.

In one embodiment a device such as the transaction device sends a random value e.g. nonce to the client and the client cryptographically adds this random value as an extension to the authentication response before signing it. This signed random value serves as a freshness proof to the device.

In one embodiment the client s authenticator adds the current time Ta as an extension to the authentication response before signing it. The device transaction device may compare that time to the current time Td and only accept the response if the difference between Ta and Td is acceptable e.g. if the difference is less than two minutes abs Td Ta 

In one embodiment the relying party adds an authenticated i.e. signed expiration time to the cacheable request. As discussed above the device transaction device will only accept the response as valid if it is received before the expiration time.

In one embodiment the relying party adds an authenticated i.e. signed data block e.g. the signed token structure mentioned above including additional information such as but not limited to public key expiration time maximum transaction value e.g. Security Assertion Markup Language SAML assertions OAuth tokens JSON Web Signature JWS objects etc to the cacheable request. The device transaction device may only accept the response as valid if the signed data block can be positively verified and the contents are acceptable.

In one embodiment the relying party only adds the unsigned token to the cacheable authentication request but the transaction device has an online connection to the relying party at the time of transaction. The transaction device verifies the authenticity of the unsigned token using the online connection to the relying party at the time of transaction.

As illustrated in the computer system which is a form of a data processing system includes the bus es which is coupled with the processing system power supply memory and the nonvolatile memory e.g. a hard drive flash memory Phase Change Memory PCM etc. . The bus es may be connected to each other through various bridges controllers and or adapters as is well known in the art. The processing system may retrieve instruction s from the memory and or the nonvolatile memory and execute the instructions to perform operations as described above. The bus interconnects the above components together and also interconnects those components to the optional dock the display controller display device Input Output devices e.g. NIC Network Interface Card a cursor control e.g. mouse touchscreen touchpad etc. a keyboard etc. and the optional wireless transceiver s e.g. Bluetooth WiFi Infrared etc. .

According to one embodiment of the invention the exemplary architecture of the data processing system may be used for the mobile devices described above. The data processing system includes the processing system which may include one or more microprocessors and or a system on an integrated circuit. The processing system is coupled with a memory a power supply which includes one or more batteries an audio input output a display controller and display device optional input output input device s and wireless transceiver s . It will be appreciated that additional components not shown in may also be a part of the data processing system in certain embodiments of the invention and in certain embodiments of the invention fewer components than shown in may be used. In addition it will be appreciated that one or more buses not shown in may be used to interconnect the various components as is well known in the art.

The memory may store data and or programs for execution by the data processing system . The audio input output may include a microphone and or a speaker to for example play music and or provide telephony functionality through the speaker and microphone. The display controller and display device may include a graphical user interface GUI . The wireless e.g. RF transceivers e.g. a WiFi transceiver an infrared transceiver a Bluetooth transceiver a wireless cellular telephony transceiver etc. may be used to communicate with other data processing systems. The one or more input devices allow a user to provide input to the system. These input devices may be a keypad keyboard touch panel multi touch panel etc. The optional other input output may be a connector for a dock.

Embodiments of the invention may include various steps as set forth above. The steps may be embodied in machine executable instructions which cause a general purpose or special purpose processor to perform certain steps. Alternatively these steps may be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

Elements of the present invention may also be provided as a machine readable medium for storing the machine executable program code. The machine readable medium may include but is not limited to floppy diskettes optical disks CD ROMs and magneto optical disks ROMs RAMs EPROMs EEPROMs magnetic or optical cards or other type of media machine readable medium suitable for storing electronic program code.

Throughout the foregoing description for the purposes of explanation numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without some of these specific details. For example it will be readily apparent to those of skill in the art that the functional modules and methods described herein may be implemented as software hardware or any combination thereof. Moreover although some embodiments of the invention are described herein within the context of a mobile computing environment the underlying principles of the invention are not limited to a mobile computing implementation. Virtually any type of client or peer data processing devices may be used in some embodiments including for example desktop or workstation computers. Accordingly the scope and spirit of the invention should be judged in terms of the claims which follow.

Embodiments of the invention may include various steps as set forth above. The steps may be embodied in machine executable instructions which cause a general purpose or special purpose processor to perform certain steps. Alternatively these steps may be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

