---

title: Dynamic service discovery
abstract: When an application is launched, a framework scanning module scans a plurality of frameworks linked against by the application to generate a list of available services. When the application makes a request of a particular service, a service verification module compares the requested service to the list of available services and if the requested service is found in the list of available services, sends a signal to the application, the signal allowing access to the requested service for the application. Otherwise, access to the requested service is denied.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09189300&OS=09189300&RS=09189300
owner: Apple Inc.
number: 09189300
owner_city: Cupertino
owner_country: US
publication_date: 20140213
---
This application is a continuation of co pending U.S. application Ser. No. 13 007 517 filed on Jan. 14 2011.

This invention relates to the field of inter process communications and in particular to dynamic service discovery using linked frameworks.

In many modern computing systems including desktop laptop notebook netbook tablet and smartphone computing systems concurrent execution of multiple processes has become more and more of a mainstream runtime environment. A process is the execution of a sequence of code to accomplish a particular task. Concurrent execution of multiple processes is the concurrent execution of multiple sequences of code during the same period of time to accomplish multiple tasks corresponding to each process.

In the case of computer application programs application developers may wish to utilize multiple processes for their particular application. However writing application software for a multi process environment presents several challenges. One issue pertains to inter process communication. In certain cases for example applications may be designed to take advantage of services provided by other applications or by an operating system running on a computing device. These services may be a set of computer implemented instructions designed to implement a specific function or perform a designated task. An application may call e.g. make use of one or more of these services to avoid redundant software code for commonly performed operations.

In certain inter process communication environments all available services may be found in a global namespace where each service is identified by a unique name or other identifier. Thus all applications in the computing system have access to all of the available services. Here the calling of a particular service is likely to be a function of a particular state of the application e.g. the values of the application s variables . It is possible that because of the application s state some services have little or no likelihood of being called by the application. Thus it is probable that the some of the services will be unnecessarily instantiated in memory. In addition there are security risks associated with allowing an application indiscriminate access to all services available in a computing system. Furthermore an application that publishes a service does not have the ability to restrict what other applications are allowed to access the service.

Embodiments are described for service discovery using linked frameworks. In one embodiment when an application is launched a framework scanning module may scan a plurality of frameworks linked against by the application to generate a list of available services. When the application makes a request of a particular service a service verification module may compare the requested service to the list of available services and if the requested service is found in the list of available services send a signal to the application the signal allowing access to the requested service for the application.

In one embodiment the service verification module may further determine if the requested service is an application defined service stored with the application. If the requested service is an application defined service the verification module may add the application defined service to the list of available services. If the requested service is not found in the list of available services the services verification module may deny the application access to the requested service. The service verification may identify an instance designation of the requested service. The instance designation may be for example a global instance a per user instance or a per application instance. If the instance designation is a global instance the service verification module may allow access to a global instance of the service. If the instance designation is a per user instance or per application instance the service verification module may instantiate a new instance of the requested service unless a per user or per application instance has already been instantiated.

In the following detailed description of embodiments of the invention reference is made to the accompanying drawings in which like references indicate similar elements and in which is shown by way of illustration specific embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention and it is to be understood that other embodiments may be utilized and that logical mechanical electrical functional and other changes may be made without departing from the scope of the present invention. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

Embodiments are described for service discovery using linked frameworks. In one embodiment a framework scanning module may identify all of the services available in an application itself and in frameworks that the application links against. When an application calls a particular service a service verification module may compare the requested services to a list of available services identified by the framework scanning module. If the requested service is found in the list of available services the service verification module may allow the application to access the requested service. This may lead to a more efficient use of memory resources as the system can load a service into memory only when it is needed or at least when a state of the application is such that there is an increased likelihood that the service might be needed. Moreover further memory efficiencies may be realized if a determination is made that a particular service that has been loaded into memory is apt not to be called upon again. In this case the unused service may be terminated allowing the region memory where the service s corresponding block of code resides to be made available for other system uses.

With dynamic service discovery the list of available services for an application may be computed when the application starts and discarded when the application is exited. There is no explicit registration operation to place services into a namespace as the set of available services is derived from the constituents of the application. The application defined services within the application bundle are found regardless of where the application is located in the system e.g. on local disk network fileserver removable media . This allows the dynamic list of services available to an application to be unique for each application rather than a shared global namespace. The service discovery technique described herein also offer security advantages. Packaging a service within a framework ensures that an application is only allowed access to services in frameworks that the application links against i.e. makes use of . Thus an application can only call known predefined or expected services rather than every service available in the system. These services may be a set of computer implemented instructions designed to implement a specific function or perform a designated task.

In one embodiment the executable code in application bundle may link against one or more frameworks in architecture . Frameworks may include software libraries having reusable abstractions of software code wrapped in a well defined application programming interface API . The frameworks allow software developers to implement the standard structure of an application for a specific development environment e.g. the operating system running on the computing device . The frameworks linked against by an application may be represented by framework bundles . Some examples of commonly used frameworks may include core audio framework and core graphics framework . Framework N may represent any other framework linked against by the application. The frameworks illustrated in are merely exemplary and in other embodiments there may be any number of other frameworks present in the architecture . The executable files in an application may link against the frameworks by storing a framework name or other identifier of framework bundles in a designated location in application bundle and or by calling an API provided by the associated framework.

Similarly to application bundle each of framework bundles may include a number of directories and or subdirectories such as Contents Resources and XPC Services. The XPC Services subdirectory may contain a list of services contained within the framework. For example core audio framework may contain the coreaudio.xpc service and core graphics framework may contain the windowserver.xpc service. In one embodiment the services a identified by the .xpc extension however in other embodiments different extensions may be used. The services illustrated in are merely exemplary and in other embodiments there may be any number of other services present in application bundle and or framework bundles .

The services included in framework bundles may be made available to a number of different applications that are all linking against the same framework. In one embodiment there may be a single global instance of a particular service in a framework that is available to a certain number of different applications. In another embodiment there may be an individual instance of a particular service that is instantiated for each user of the system or an instance of the service for each application that is running in the system. In other embodiments each service may have a different designation as a global instance a per user instance or a per application instance where there may be services of each type present at the same time in the same or different framework s . In addition some other instance may be created at the discretion of the framework. For example one framework may have one instance for each browser tab or window that is opened. Each instance may be identifiable by a universal unique identifier UUID .

At the time an application is built the application designer may specify what services are defined specifically in the application as well as what frameworks the application will link against. The application designer may also have knowledge of what services are contained within those frameworks. Thus between the application defined services and the services in linked frameworks the application designer is able to grant access to all of the services that the application executable file needs or may be likely to access. In addition the application designer is able to specify which services the application executable file is allowed to access. Therefore unnecessary and unauthorized services are not made available to the application.

Inter process communication tool may include framework scanning module . Framework scanning module may receive a list of frameworks that application links against. The list may be provided by initializer module . Framework scanning module scans the frameworks provided by initializer module to identify the services contained within frameworks . The services may be identified during the scan by a known extension e.g. .xpc or an identifier. In addition the services may be found in a designated subdirectory of the framework bundle. Framework scanning module may generated a list of available services which it provides to application launch tool .

When the executable code of application is run it may call a service at some point during its operation. Referring back to application launch tool runs the executable code and when a service is called a service verification module verifies whether the application is authorized to access the requested service. Service verification module compares the requested service to the list of available services e.g. table provided by framework scanning module and application . If the requested service is found in the list of available services e.g. is an application defined service stored directly in application or is found in one of linked frameworks service verification module authorizes the executable code to access the service e.g. by making the appropriate API call and execution of the application code continues. If the requested service is not found in the list of identified services then service verification module denies access to the service by the executable code.

Referring to at block method identifies frameworks that a computer application program links against. An initializer module may examine an application bundle corresponding to application and look for framework names or other identifiers stored in a designated section of the bundle. At block method scans the linked frameworks to identify services provided by each framework. A framework scanning module may examine a framework bundle corresponding to each linked framework and look for service names or other identifiers stored in a designated section of each framework bundle. At block method identifies the application defined services stored directly in the application bundle corresponding to application . Service verification module may receive information about what application defined services are stored in the application bundle when the application is initialized or along with a request to access a particular service. The application defined services may be identified by a particular service extension or other identifier or may be found in a designated subdirectory of the application bundle. At block method generates a list of the available services. Framework scanning module may compile the services identified in the frameworks that are linked against into a list table database other data structure and provide the list to service verification module . The list represents all of the services in the linked frameworks that the application is likely and or authorized to access during execution. This list may be combined with the application defined services identified at block to represent all of the available services for application .

When the executable code of application is run either automatically or in response to a user input the code may be sequentially executed by a processing system such as processing system shown in . Certain instructions in the code may cause the application to call a service at some point during its operation. At block method receives a request for a service from application . Application launch tool runs the executable code from the application and when a service is called service verification module may receive the request for the service. At block method determines if the request service is found in the list of available services. Service verification module may compare a name or identifier of the requested service with the list of available services. In one embodiment service verification module may read available service table to determine if the identifier matches an entry in the table. If the requested service matches one of the services in the list of available services at block method allows the executable code of application to access the requested service. Application launch tool may send a signal to application the signal indicating that access to the requested service has been granted. When access is granted the service may be published to a private namespace of services for the application. The executable code may call an API provided by the requested service in order to initiate the functions provided by the service. Application launch tool may additionally identify the designation of the service as a global instance a per user instance or a per application instance and either start a new instance of the service or provide access to an already existing instance as appropriate. For a global instance launch tool may allow access to the already existing global instance of the service. For a per user or per application instance launch tool may instantiate a new instance of the service unless a per user or per application instance already exists. In that case launch tool may allow access to the already existing per user or per application instance. In one embodiment if the same application were to run more than once than then each instance of the application could have its own instances of per application services. In other embodiments with other instance designations launch tool may check for a UUID of the requested instance and if the UUID already exists launch tool may allow access to the instance.

Under normal conditions it is unlikely that an application may request a service not found in the list of available services. However due to software errors or if the application is maliciously modified e.g. by a virus malware hacker or other application an application may request a service not found in the list of available services. If at block method determines that the requested service is not found in the list of available services method proceeds to block . At block method denies access to the requested service. After either allowing or denying access to the requested service at blocks and respectively the application continues execution and method returns to block to wait to receive a subsequent request to access a service.

Memory may include modules and application . In at least certain implementations of the system the processor may receive data from one or more of the modules and application and may perform the processing of that data in the manner described herein. In at least certain embodiments modules may initializer module framework scanning module and service verification module . Processor may execute instructions stored in memory on image data as described above with reference to these modules. Applications may include a phone application an SMS MMS messaging application a chat application an email application a web browser application a camera application an address book application a calendar application a mapping application a word processing application a photo application or other applications.

Embodiments of the present invention include various operations described herein. These operations may be performed by hardware components software firmware or a combination thereof. Any of the signals provided over various buses described herein may be time multiplexed with other signals and provided over one or more common buses. Additionally the interconnection between circuit components or blocks may be shown as buses or as single signal lines. Each of the buses may alternatively be one or more single signal lines and each of the single signal lines may alternatively be buses.

Certain embodiments may be implemented as a computer program product that may include instructions stored on a machine readable medium. These instructions may be used to program a general purpose or special purpose processor to perform the described operations. A machine readable medium includes any mechanism for storing information in a form e.g. software processing application readable by a machine e.g. a computer . The machine readable medium may include but is not limited to magnetic storage medium e.g. floppy diskette optical storage medium e.g. CD ROM magneto optical storage medium read only memory ROM random access memory RAM erasable programmable memory e.g. EPROM and EEPROM flash memory or another type of medium suitable for storing electronic instructions.

Additionally some embodiments may be practiced in distributed computing environments where the machine readable medium is stored on and or executed by more than one computer system. In addition the information transferred between computer systems may either be pulled or pushed across the communication medium connecting the computer systems.

The digital processing devices described herein may include one or more general purpose processing devices such as a microprocessor or central processing unit a controller or the like. Alternatively the digital processing device may include one or more special purpose processing devices such as a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or the like. In an alternative embodiment for example the digital processing device may be a network process having multiple processors including a core unit and multiple microengines. Additionally the digital processing device may include any combination of general purpose processing devices and special purpose processing devices.

Although the operations of the methods herein are shown and described in a particular order the order of the operations of each method may be altered so that certain operations may be performed in an inverse order or so that certain operation may be performed at least in part concurrently with other operations. In another embodiment instructions or sub operations of distinct operations may be in an intermittent and or alternating manner.

