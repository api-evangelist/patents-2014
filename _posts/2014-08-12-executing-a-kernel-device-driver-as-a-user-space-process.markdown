---

title: Executing a kernel device driver as a user space process
abstract: A method, including receiving, by a user space driver framework (UDF) library executing from a user space of a memory over a monolithic operating system kernel, a kernel application programming interface (API) call from a device driver executing from the user space. The UDF library then performs an operation corresponding to the kernel API call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09092356&OS=09092356&RS=09092356
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09092356
owner_city: Armonk
owner_country: US
publication_date: 20140812
---
The present Application is a Continuation of copending U.S. patent application Ser. No. 12 949 132 filed Nov. 18 2010.

The present invention relates generally to operating systems and specifically to a software framework that enables kernel device drivers to execute as user space processes.

Operating systems are computer programs which manage the way software applications utilize the hardware of computer systems. A fundamental component of operating systems is the operating system kernel also referred to herein as a kernel which provides secure computer system hardware access to software applications executing on the computer system. Since accessing the hardware can be complex kernels may implement a set of hardware abstractions to provide a clean and uniform interface to the underlying hardware. The abstractions provided by the kernel provide software developers easier access to the hardware when writing software applications.

Operating systems typically segregate virtual memory into kernel space and user space. User space is typically the virtual memory region for running user applications while the kernel space is typically reserved for running the kernel and extensions to the kernel.

There is provided in accordance with an embodiment of the present invention a method including receiving by a user space driver framework UDF library executing from a user space of a memory over a monolithic operating system kernel a kernel application programming interface API call from a device driver executing from the user space and performing by the UDF library an operation corresponding to the kernel API call.

There is also provided in accordance with an embodiment of the present invention a computer program product the computer program product including a non transitory computer readable storage medium having computer readable program code embodied therewith the computer readable program code including computer readable program code configured to receive by a user space driver framework UDF library executing from a user space of a memory over a monolithic operating system kernel a kernel application programming interface API call from a device driver executing from the user space and computer readable program code configured to perform by the UDF library an operation corresponding to the kernel API call.

There is further provided in accordance with an embodiment of the present invention a method including identifying two or more ports of a same type in a computer initiating a separate device driver process for each of the identified ports and establishing a one to one correspondence between each of the ports and each of the device driver processes.

There is additionally provided in accordance with an embodiment of the present invention a computer program product the computer program product including a non transitory computer readable storage medium having computer readable program code embodied therewith the computer readable program code including computer readable program code configured to identify two or more ports of a same type in a computer computer readable program code configured to initiate a separate device driver process for each of the identified ports and computer readable program code configured to establish a one to one correspondence between each of the ports and each of the device driver processes.

Some operating systems such as Linux implement a monolithic kernel where the entire operating system executes from kernel space. In addition to the kernel the operating system typically comprises kernel extensions and device drivers. A device driver is a software application that accepts a high level command from a computer program e.g. the kernel or a user application and translates the high level command to a series of low level commands specific to a hardware device e.g. a network interface controller .

During their execution device drivers typically issue application programming interface API calls to the kernel. The API is an interface implemented in the kernel that enables the kernel to interact with other computer programs e.g. device drivers and user applications . Computer programs issue API calls to gain access to and manage system resources.

Embodiments of the present invention provide methods and systems to enable device drivers to execute as user space processes in a monolithic kernel environment. More specifically embodiments of the present invention enable device drivers executing from user space over a monolithic kernel to call kernel API functions. In some embodiments an emulation layer executing over the monolithic kernel receives and processes an API call from a device driver executing from user space. The emulation layer replicates a subset of the kernel s API calls which are applicable to the device drivers. Since the emulation layer receives and processes kernel API calls embodiments of the present invention enable existing device drivers to execute from user space with minimal modification.

If a device driver fails while executing from kernel space over a monolithic kernel the failure of the device driver may cause the kernel to fail thereby causing a system crash. Since embodiments of the present invention enable device drivers to execute from user space kernel stability may be increased since a failure of a device driver executing from user space may only disable access to the device being controlled by the device driver.

In addition to executing device drivers from user space embodiments of the present invention provide additional system stability by executing a separate instance i.e. each instance executing as a separate process of a device driver for each port of a same type in a computer system. For example in a computer system comprising three network interface cards from a single vendor with four ports on each card the kernel may execute twelve separate instances of an identical device driver with each device driver dedicated to one of the twelve ports.

Since operating systems typically load and execute a single device driver for all devices of the same type the device driver typically constitutes a single point of failure i.e. a failure of the device driver disables access to all ports controlled by the device driver. By executing a separate instance of the device driver for each port embodiments of the present invention increase system stability since a failure of one of the device drivers only disables the single port controlled by the failed device driver.

Processor executes device drivers from user space . Device drivers accept high level commands from a monolithic kernel and a user application and translate the high level commands to a series of low level commands for a host bus adapter HBA a hardware device which connects computer to other network and storage devices not shown . HBA comprises hardware ports where each of the ports is controlled by a separate instance of device drivers . A port manager daemon i.e. a background process typically executing from user space manages the relationships between device drivers and ports as described hereinbelow. While the configuration in shows HBA with hardware ports other system configurations can also be employed to implement embodiments of the present invention and are thus considered to be within the spirit and scope of this invention.

An emulation layer in memory is configured to accept kernel API calls from device drivers and perform the requested kernel operation. The emulation layer comprises a user space driver framework UDF library executing from the user space and a UDF kernel module executing from the kernel space. In embodiments of the present invention UDF library is a component of device driver and is configured to implement a subset of application programming interface API calls for kernel that are applicable for managing Peripheral Component Interconnect PCI devices such as HBA .

In the configuration shown in emulation layer comprises UDF kernel module and UDF library of the device driver directly above the UDF kernel module. Since there are four device drivers there are actually four emulation layers . For simplicity only one layer is shown in the figure. The combination of UDF kernel module and the UDF library for each device driver comprises a separate emulation layer .

UDF library is configured to implement API functions that can be run from user space . Examples of API functions that can be performed by UDF library from user space include managing lists timers and a process scheduler PS . Lists typically store information such as message buffers to transfer to hardware devices such as HBA and timers can be used to detect a situation where the HBA or another hardware device does not respond to a command and therefore needs to be reset.

Process scheduler typically schedules threads and interrupt handling code within its associated device driver enabling the implementation of user level threads. In computing a thread is a component of a process in the sense that a single process e.g. an instance of device driver executing from user space may comprise multiple threads where all threads within the single process share the same state share the same memory space and communicate with each other directly.

UDF kernel module is configured to implement API calls that are typically performed from kernel space including mapping input output I O memory addresses allocating direct memory access DMA memory and catching interrupts. Memory comprises a file descriptor FD which is a software mechanism that enables software processes in this case UDF library and UDF kernel module to communicate with one another.

In computing a privilege refers to a permission to perform a specific action. The monolithic kernel tasks performed by processor are usually divided into privileged and non privileged operations. Privileged operations typically have absolute control over critical system resources e.g. memory and ports as opposed to non privileged operations which typically manage less critical system resources e.g. timers and lists . In embodiments of the present invention UDF kernel module is configured to performed privileged operations and UDF library is configured to perform non privileged operations.

When mapping I O memory addresses i.e. implementing memory mapped I O processor assigns addresses in memory to a device such as HBA . Kernel and user application can then access HBA by reading from or writing to the assigned memory addresses. When allocating DMA memory processor assigns addresses in memory that are then used to transfer data directly between memory and a device e.g. HBA without involving processor thereby reducing processor overhead.

An interrupt typically comprises a signal that causes processor to temporarily suspend execution of a program e.g. a process of kernel or user application . After detecting the interrupt processor may either resume executing the suspended program or start executing a different program i.e. an application or a process . In general there are hardware interrupts and software interrupts. A hardware interrupt occurs for example when an I O operation is completed such as transferring data between HBA and memory . A software interrupt occurs for example when user application terminates or requests certain services from kernel .

In monolithic kernel environments interrupts are typically handled from kernel space . In some embodiments of the present invention upon detecting an interrupt UDF kernel library conveys a notification via file descriptor to UDF library that there is an interrupt. Upon receiving the notification scheduler schedules execution of interrupt handling the device driver s interrupt handling code. The interrupt handling code is a component of device driver configured to perform operations such as 

Processor typically comprises a general purpose computer configured to carry out the functions described herein. Software operated by the processor may be downloaded to memory in electronic form over a network for example or it may be provided on non transitory tangible media such as optical magnetic or electronic memory media. Alternatively some or all of the functions of processor may be carried out by dedicated or programmable digital hardware components or by using a combination of hardware and software elements.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system . Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electromagnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

In a receive step UDF library receives a kernel API call from its associated device driver . The device driver typically issues the API call after receiving a high level command from either kernel or user application . In a comparison step if the requested operation associated with the API call is not privileged then in a first perform step UDF library performs the requested operation from user space and the method continues with step . Returning to step if the requested operation is privileged then in a convey step UDF library conveys the API call to UDF kernel module via file descriptor . In a second perform step UDF kernel module performs the requested operation from kernel space conveys any necessary completion information back to UDF library via file descriptor and the method continues with step .

In an execute step processor executes in memory a separate instance of an identical device driver for each of identified ports where each instance is executed as a separate process from a unique address in memory . For example in the computer system shown in processor executes four instances of the same HBA driver for each HBA port and executes each of the HBA drivers as a separate process.

Finally in an establish step processor couples device drivers to ports and establishes a one to one correspondence between each of the device drivers and each of the ports and the method terminates. As discussed supra a failure of one of device drivers only disables the port corresponding to the failed device driver. Typically in the event of a failure of one of the device drivers port manager daemon detects and identifies the port associated with the failed device driver re launches the failed device driver as a new process and couples the re launched device driver to the identified port.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

It will be appreciated that the embodiments described above are cited by way of example and that the present invention is not limited to what has been particularly shown and described hereinabove. Rather the scope of the present invention includes both combinations and subcombinations of the various features described hereinabove as well as variations and modifications thereof which would occur to persons skilled in the art upon reading the foregoing description and which are not disclosed in the prior art.

