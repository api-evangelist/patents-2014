---

title: Access control for data blocks in a distributed filesystem
abstract: A method for access control of data in a filesystem is provided. The method includes storing a map in a server, the map coupled to an agent, the map associating access control rules, filenames in a namespace in a first filesystem, and owners of files. The method includes determining a block filename in a namespace in a second filesystem, based on an I/O request from a data node to the second filesystem regarding a data block. The method includes determining a username of the I/O request and determining a filename in the namespace in the first filesystem, based on the block filename in the namespace in the second filesystem. The method includes applying to the data block and the username an access control rule that the map associates with an owner of a file having the filename in the namespace in the first filesystem.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09628486&OS=09628486&RS=09628486
owner: Vormetric, Inc.
number: 09628486
owner_city: San Jose
owner_country: US
publication_date: 20141023
---
In this era of Big Data large scale processing of large amounts of data can be performed on distributed hardware in a distributed filesystem. In a multitenant environment there is a need for access control of data blocks so that data belonging to each tenant is secure. Yet the distributed nature of such a system poses data security challenges. Some operating systems do not interact well with other operating systems in terms of data security. For example Hadoop can be used as a framework for large scale processing in which Hadoop is used as a first operating system for one or more name nodes and a local operating system is used as a second operating system for one or more data nodes under which data blocks are stored. One problem in such a distributed filesystem is that often the first operating system is not aware of the owner of the data. This renders access control for data blocks difficult in not impossible. One workaround is to define and apply an encryption key in a local filesystem namespace but this imposes a burden on the system and the users and is not transparent to the users. Furthermore such an encryption key cannot be defined and applied selectively on a basis of individual files at the level of the first filesystem e.g. HDFS the Hadoop distributed file system . Administrators in the first filesystem have unrestricted access to unencrypted data since the super user has the same identity as the name node process itself. Therefore there is a need in the art for a solution which overcomes the drawbacks described above.

In some embodiments a method for access control of data in a filesystem is provided. The method includes storing a map in a server the map coupled to an agent executing in the server the map associating access control rules filenames in a namespace in a first filesystem and owners of files. The method includes determining a block filename in a namespace in a second filesystem based on an I O input output request from a data node to the second filesystem regarding a data block. The method includes determining a username of the I O request and determining a filename in the namespace in the first filesystem based on the block filename in the namespace in the second filesystem. The method includes applying to the data block and the username an access control rule that the map associates with an owner of a file having the filename in the namespace in the first filesystem wherein at least one action of the method is performed by a processor in the server.

In some embodiments a tangible non transitory computer readable media having instructions thereupon which when executed by a processor cause the processor to perform a method is provided. The method includes establishing in a data node an I O input output thread associated with a username and regarding a data block responsive to an I O request the data block having a block filename in a namespace in a local filesystem relative to the data node the block filename having a pool ID identifier and a block ID which identify the data block. The method includes mapping the block filename in the namespace in the local filesystem to a filename in a further namespace relative to a name node and having a directory structure in a further filesystem. The method includes associating an encryption key and an access control rule to the filename in the further namespace and passing the username from the data node to an agent. The method includes applying through the agent the access control rule and the encryption key to the data block and the username.

In some embodiments a method for access control of data blocks in a filesystem is provided. The method includes pushing a first map from a data security manager to an agent in a server. The first map having a plurality of access control rules based on users and filenames in a first filesystem. The first map further having one or more encryption keys and associating the one or more encryption keys to the users and the filenames in the first filesystem. The method includes in an I O input output thread in a data node sending a username to the agent through an I O control IOCTL call and in the I O thread calling to a second filesystem regarding one or more blocks the second filesystem having a namespace that references blocks by block filenames. The method includes in the agent intercepting the calling to the second filesystem and obtaining a block filename and determining through the agent a filename of a file in the first filesystem corresponding to the block filename in the second filesystem. The method includes applying through the agent one of the plurality of access control rules corresponding to the filename of the file in the first filesystem against the username from the I O control call.

Other aspects and advantages of the embodiments will become apparent from the following detailed description taken in conjunction with the accompanying drawings which illustrate by way of example the principles of the described embodiments.

A transparent encryption agent disclosed herein operates in a distributed filesystem. The agent can operate in conjunction with one or more name nodes under a first operating system which could be Hadoop or other operating system suitable for a distributed filesystem and one or more data nodes under a second operating system which could be a local filesystem i.e. a filesystem local to each data node . In one embodiment the agent is implemented as the Vormetric Transparent Encryption Agent which is part of a secure filesystem secfs that operates with the Data Security Manager of the assignee of the present application. In various embodiments the agent is installed above alongside or below a filesystem on a server or a virtual machine to enforce security policies. It should be appreciated that secfs is a loadable kernel module and may be embodied as the agent in some embodiments. The secfs module is a file system layer that enforces an access and encryption policy upon selected data on end user systems in some embodiments. The policy specifies a key to be used when writing data to disk and while reading data from disk. Further details on the secure file system secfs of the assignee may be found in application Ser. No. 14 015 954 which is incorporated by reference for all purposes.

The embodiments provide that when an I O input output request is made for a data block identified by a block filename in the second operating system the agent determines the corresponding filename in the first operating system and a username for the I O request. The agent then determines an access control rule applicable to the file having that filename in the first operating system. The agent applies the access control rule to the data block which confirms or denies access to the data block specified in the I O request based on whether the username is allowed access according to the access control rule. If access is allowed encryption or decryption is applied to the data block by the agent. It should be appreciated that these processes are transparent to the user and the I O request in some embodiments.

Examples of terminology for one filesystem in one embodiment are provided below. It should be appreciated that further embodiments are applicable to further filesystems and operating systems as the terminology is not meant to be limiting. An HDFS namespace may refer to a hierarchy of files and directories in HDFS. Files and directories are represented on the name node by inodes in some embodiments. A HDFS Client may refer to the client end of HDFS that interacts with an HDFS name node and data node through class DistributedFileSystem. A HDFS administrator may refer to a super user with the same identity as the name node process itself the super user can do anything in that permissions checks never fail for the super user. By default the super user identity is hdfs. A HDFS block refers to the content of an HDFS file split into large blocks. Typically each block is up to 128 megabytes although other sizes could be used. A HDFS block file refers to the underlying local filesystem file that stores a single HDFS Block. Each HDFS block has an associated name in the local file system. A HDFS pool ID refers to an identifier that uniquely identifies the block pool that belongs to a single HDFS namespace. A HDFS block ID refers to an identifier that uniquely identifies a block that belongs to a block pool.

Examples of Data Security Transparent Encryption Terminology relating to the assignee includes the Transparent Encryption Agent which refers to a kernel mode component installed above the file system to apply encryption key and security rules to filesystem I Os. A user mode component of the transparent encryption refers to a user mode component to handle a request from the Transparent Encryption Agent. The Data Security Manager refers to a repository that centralizes policy control and key management for transparent encryption.

Data blocks are written to and read from data storages which are coupled to the server . It should be appreciated that the data storages need not be physically proximate to the server and could be distributed storage local storage virtual storage cloud storage direct attached storage and so on. When an I O request is received by the server the agent determines the block filename in the second filesystem. The agent then determines the filename in the first filesystem the owner of that file and the applicable access control rule. Meanwhile the username associated with the I O request is obtained by the agent . With this information the agent applies the access control rule. The agent uses the access control engine and confirms or denies access to the data block referenced by the I O request with encryption or decryption using the encryption engine as appropriate. For example if the user that made the I O request is the same as the owner the access control rule would allow access with encryption for a data write or decryption for a data read. Rules and policies for individual ownership and access and or group ownerships and access and combinations thereof are readily devised and applied in accordance with the teachings herein.

Although the flow diagram of provides an example with HDFS and specific function names the method depicted in is applicable to other filesystems and operating systems and is not limited to HDFS. In an action the block filename is input to the mapping module . The mapping module parses a pool ID and a block ID from the block filename in an action . The pool ID is mapped to the hostname of the name node in an action . An API function e.g. libhdfs is called to connect to the name node that has the hostname in an action . A function e.g. hdfsGetFileName pool ID block ID is called to get the filename in the first filesystem from the pool ID and the block ID in an action . This function applies the first map as depicted in . The filename in the first filesystem is output in an action .

Continuing with the block file I O request is sent to the kernel of the second filesystem in an action . For example this could be read and write operations from an I O thread in the data node in some embodiments. In a decision action it is determined whether the encryption key is cached. If the encryption key is cached flow branches to the action . If the encryption key is not cached flow continues to the decision action . In the decision action it is determined whether the filename in the first filesystem is cached. If the filename in the first filesystem is cached flow branches to the action . If the filename in the first filesystem is not cached flow continues to the action . The decision actions could be performed in the reverse order in variations.

In action a user mode component of the transparent encryption agent is requested to get the filename in the first filesystem based on the block filename in the second filesystem. This action can be fulfilled using the second map. In action the agent obtains the encryption key based on the filename in the first filesystem. This action can be fulfilled using the first map. In an action the agent encrypts or decrypts the block file I O with the encryption key i.e. encrypts or decrypts the data block referenced in the block file I O request.

Without modification the I O thread on the data node does not use the credentials of the user requested the services i.e. the data block I O request. For example in Hadoop the HDFS data node process credential is always hdfs. In order to propagate the username code is added to the I O thread that calls into the local filesystem e.g. the second filesystem . This code obtains the username . In one embodiment the code gets the username from the data member userId of the HDFS Java class BlockTokenIdentifier and passes the username to the transparent encryption agent running in the local filesystem kernel i.e. running in the second filesystem . The agent parses the thread context structure and saves the username . This modification is shown in as the I O thread user mode portion in the data node sending the thread context structure containing the username to the I O thread kernel mode portion in the transparent encryption agent .

The block file I O is received in the second filesystem kernel in an action . For example the data node makes read and write calls referencing the data block. In a decision action it is determined whether the filename in the first filesystem is cached. If the filename in the first filesystem is cached flow proceeds to the action . If the filename in the first filesystem is not cached flow proceeds to the action .

In the action the user mode component of the transparent encryption agent is requested to get the filename in the first filesystem based on the block filename in the second filesystem. This can be performed using the second map. In an action the username is obtained from the thread context of the current thread. This can be performed using the mechanism depicted in in which the data node sends the thread context structure to the agent. In the action the access control rule is applied based on the filename in the first filesystem and the username in the current thread. For example the username can be compared to the access control rule and access can be confirmed or denied with encryption as appropriate.

 1 The data security manager pushes the first map to the agent . The first map maps between one or more encryption keys one or more filenames in the first filesystem and one or more access control rules which is illustrated in as two portions of the first map . The first map includes a map portion having at least one access control rule based on the user and the filename in the first filesystem and a further map portion having a map between at least one key and a filename in the first filesystem. In some embodiments the transparent encryption agent runs in a local filesystem kernel i.e. in the second filesystem which is under a data node .

 2 In the data node I O thread user mode portion that will call into the second filesystem i.e. the local filesystem the added specific code obtains the username and sends the username to the agent through an I O control call. In some embodiments the user name is obtained from BlockTokenIdentifier userId.

 3 The data node I O thread calls into the second filesystem i.e. the local filesystem. The agent intercepts the call and obtains the block filename in the second filesystem.

 4 The agent sends the block filename in the second filesystem to the user mode component of the transparent encryption agent . In some embodiments this user mode component of the transparent encryption agent has the mapping module.

 5 The user mode component of the transparent encryption agent parses the pool ID and the block ID from the block filename in the second filesystem. The agent more specifically the user mode component of the encryption engine in some embodiments maps the pool ID to the name node hostname and connects to the name node host. In one embodiment this connection is made through the HDFS C library libhdfs. The agent then sends the pool ID and the block ID to the name node . In some embodiments this is performed through the function getFileName.

 6 The name node serves the request. The name node obtains the filename in the first filesystem based on the pool ID and the block ID. This action is depicted in and can be performed with the assistance of the agent the mapping module and the second map as depicted in .

 7 The user mode component of the transparent encryption agent returns the filename in the first filesystem back to the remainder of the transparent encryption agent operating in the kernel.

 8 The transparent encryption agent applies the access control rule against the username and the filename in the first filesystem. This can be performed by referencing the first map and determining an access control rule associated with the filename in the first filesystem. Then the agent compares the username to the requirements in the access control rule and grants or denies access to the data block accordingly.

 9 The transparent encryption agent gets the encryption key based on the filename in the first filesystem. For example this can be performed with the use of the first map which indicates an appropriate encryption key associated with the filename in the first filesystem. The encryption key is then applied to the data block referenced in the I O request with encryption for a write or decryption for a read. That is if the data block is being written encryption is applied and if the data block is being read decryption is applied.

In an action a block filename in the second filesystem is determined based on the I O request. This is depicted in 3 in in which a data node I O thread calls into a local or second filesystem and the agent intercepts the call and gets the block filename. In an action a first map is generated and stored. The first map associates access control rules owners of files and filenames of files in a first filesystem. For example the first filesystem could be HDFS and relative to a name node and the first map could be pushed from a data security manager to a transparent encryption agent or developed by the transparent encryption agent based on information from the data security manager as depicted in . In an action a second map is generated and stored. The second map associates filenames of files in the first filesystem and filenames of data block files in the second filesystem. For example the second filesystem could be a local filesystem in a data node. The second map could be developed by the agent.

In an action the username of the I O request is determined. This is depicted in 2 in in which the data node uses specific code to get the username and send the username to the agent. In an action the filename in the first filesystem is determined based on the block filename in the second filesystem which may be based on the second map. 5 and 6 depict such an action in which the agent parses the pool ID and the block ID and the name node gets the filename in the first filesystem namespace. The name node sends this to the agent.

In an action an access control rule is determined based on the filename in the first filesystem per the first map. The first map is depicted in and the access control rule is depicted in in the map portion . The first map associates access control rules and filenames in the first filesystem and the agent can consult this first map to determine an appropriate access control rule. In an action the access control rule is applied to the username and the data block of the I O request. For example the agent can determine from the access control rule whether the username is allowed access to the data block. The agent then grants or denies access to the data block accordingly.

In a decision action is determined whether the rule grants access. If access is denied flow branches back to the action for a new I O request. In variations if the first map or the second map does not need updating actions and or could be skipped. If access is granted by the rule flow proceeds to the action . In the action encryption key is determined based on the filename in the first filesystem per the first map. The first map associates encryption keys and filenames in the first filesystem according to the access rules. If access is granted the agent can then determine an appropriate encryption key by consulting the first map. In an action the encryption key is applied to the data block of the I O request. For example if the I O request specifies reading the data block the agent applies the encryption key to decrypt the data block. If the I O request specifies writing reading the data block the agent applies the encryption key to encrypt decrypt the data block. The reading or the writing of the data block proceeds via the data storage depicted in which is coupled to the server e.g. by a network or as direct attached storage. Upon completion of the application of the encryption key flow proceeds back to the action for a new I O request. In variations further actions could be inserted or flow could branch elsewhere.

Embodiments described above develop a hybrid data at rest encryption solution for HDFS and other distributed operating systems. The solution defines encryption key and access control rules for files in a namespace in a first operating system and applies encryption key and access control rules to corresponding data blocks in a second filesystem against the user who issued the I O request. Data at rest is data residing in a storage under encryption and decryption as compared to data in transit. Hybrid as applied herein refers to a solution crosses the user and kernel boundaries and spaces. The hybrid solution described herein can rotate keys with reencryption on existing files in some embodiments and offers security and data control as a result of encryption and access control engines residing in the operating system kernel. This hybrid solution supports encryption selectively on a per file level and can prevent administrators from accessing clear content. One embodiment includes a method to map a block filename in a namespace in a local or second filesystem to the related filename in a namespace in a first filesystem based on a pool ID and a block ID. This is done by enhancing first filesystem client communication and name node components to get the filename in the namespace in the first filesystem from the related block filename in the local or second filesystem namespace based on the pool ID and the block ID in the second filesystem namespace. In another embodiment a method is provided to define an encryption key for a file in a namespace in a first filesystem and apply the encryption key to encrypt and decrypt a related block file in a namespace in a second or local filesystem kernel. This is based on a mapping between the block filename in the second filesystem and the filename in the first filesystem. In another embodiment a method is provided to define an access control rule for a file in a namespace in a first filesystem and apply the access control rule to the related block file in a local or second filesystem kernel based on the mapping between the block filename in the second filesystem and the filename in the first filesystem. In yet another embodiment a method is provided to apply access control against a user who issues an I O request. This is done by enhancing a data node to issue an I O control call from an I O thread to a transparent encryption agent that runs in a local or second filesystem kernel. The I O control call gives the transparent encryption agent the username.

It should be appreciated that the methods described herein may be performed with a digital processing system such as a conventional general purpose computer system. Special purpose computers which are designed or programmed to perform only one function may be used in the alternative. is an illustration showing an exemplary computing device which may implement the embodiments described herein. The computing device of may be used to perform embodiments of the functionality for access control for data blocks in accordance with some embodiments. The computing device includes a central processing unit CPU which is coupled through a bus to a memory and mass storage device . Mass storage device represents a persistent data storage device such as a floppy disc drive or a fixed disc drive which may be local or remote in some embodiments. The mass storage device could implement a backup storage in some embodiments. Memory may include read only memory random access memory etc. Applications resident on the computing device may be stored on or accessed via a computer readable medium such as memory or mass storage device in some embodiments. Applications may also be in the form of modulated electronic signals modulated accessed via a network modem or other network interface of the computing device. It should be appreciated that CPU may be embodied in a general purpose processor a special purpose processor or a specially programmed logic device in some embodiments.

Display is in communication with CPU memory and mass storage device through bus . Display is configured to display any visualization tools or reports associated with the system described herein. Input output device is coupled to bus in order to communicate information in command selections to CPU . It should be appreciated that data to and from external devices may be communicated through the input output device . CPU can be defined to execute the functionality described herein to enable the functionality described with reference to . The code embodying this functionality may be stored within memory or mass storage device for execution by a processor such as CPU in some embodiments. The operating system on the computing device may be MS WINDOWS UNIX LINUX or other known operating systems. It should be appreciated that the embodiments described herein may be integrated with virtualized computing system also.

Detailed illustrative embodiments are disclosed herein. However specific functional details disclosed herein are merely representative for purposes of describing embodiments. Embodiments may however be embodied in many alternate forms and should not be construed as limited to only the embodiments set forth herein.

It should be understood that although the terms first second etc. may be used herein to describe various steps or calculations these steps or calculations should not be limited by these terms. These terms are only used to distinguish one step or calculation from another. For example a first calculation could be termed a second calculation and similarly a second step could be termed a first step without departing from the scope of this disclosure. As used herein the term and or and the symbol includes any and all combinations of one or more of the associated listed items.

As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises comprising includes and or including when used herein specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof. Therefore the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting.

It should also be noted that in some alternative implementations the functions acts noted may occur out of the order noted in the figures. For example two figures shown in succession may in fact be executed substantially concurrently or may sometimes be executed in the reverse order depending upon the functionality acts involved.

With the above embodiments in mind it should be understood that the embodiments might employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. Further the manipulations performed are often referred to in terms such as producing identifying determining or comparing. Any of the operations described herein that form part of the embodiments are useful machine operations. The embodiments also relate to a device or an apparatus for performing these operations. The apparatus can be specially constructed for the required purpose or the apparatus can be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines can be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

A module an application a layer an agent or other method operable entity could be implemented as hardware firmware or a processor executing software or combinations thereof. It should be appreciated that where a software based embodiment is disclosed herein the software can be embodied in a physical machine such as a controller. For example a controller could include a first module and a second module. A controller could be configured to perform various actions e.g. of a method an application a layer or an agent.

The embodiments can also be embodied as computer readable code on a tangible non transitory computer readable medium. The computer readable medium is any data storage device that can store data which can be thereafter read by a computer system. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs magnetic tapes and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion. Embodiments described herein may be practiced with various computer system configurations including hand held devices tablets microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The embodiments can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a wire based or wireless network.

Although the method operations were described in a specific order it should be understood that other operations may be performed in between described operations described operations may be adjusted so that they occur at slightly different times or the described operations may be distributed in a system which allows the occurrence of the processing operations at various intervals associated with the processing.

In various embodiments one or more portions of the methods and mechanisms described herein may form part of a cloud computing environment. In such embodiments resources may be provided over the Internet as services according to one or more various models. Such models may include Infrastructure as a Service IaaS Platform as a Service PaaS and Software as a Service SaaS . In IaaS computer infrastructure is delivered as a service. In such a case the computing equipment is generally owned and operated by the service provider. In the PaaS model software tools and underlying equipment used by developers to develop software solutions may be provided as a service and hosted by the service provider. SaaS typically includes a service provider licensing software as a service on demand. The service provider may host the software or may deploy the software to a customer for a given period of time. Numerous combinations of the above models are possible and are contemplated.

Various units circuits or other components may be described or claimed as configured to perform a task or tasks. In such contexts the phrase configured to is used to connote structure by indicating that the units circuits components include structure e.g. circuitry that performs the task or tasks during operation. As such the unit circuit component can be said to be configured to perform the task even when the specified unit circuit component is not currently operational e.g. is not on . The units circuits components used with the configured to language include hardware for example circuits memory storing program instructions executable to implement the operation etc. Reciting that a unit circuit component is configured to perform one or more tasks is expressly intended not to invoke 35 U.S.C. 112 sixth paragraph for that unit circuit component. Additionally configured to can include generic structure e.g. generic circuitry that is manipulated by software and or firmware e.g. an FPGA or a general purpose processor executing software to operate in manner that is capable of performing the task s at issue. Configured to may also include adapting a manufacturing process e.g. a semiconductor fabrication facility to fabricate devices e.g. integrated circuits that are adapted to implement or perform one or more tasks.

The foregoing description for the purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the embodiments and its practical applications to thereby enable others skilled in the art to best utilize the embodiments and various modifications as may be suited to the particular use contemplated. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

