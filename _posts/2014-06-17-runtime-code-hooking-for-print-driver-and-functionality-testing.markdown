---

title: Runtime code hooking for print driver and functionality testing
abstract: Runtime code hooking techniques are described in which a place holder instruction within a compiled module is used as an entry point to enable code hooking. A hook function to modify a target function is developed. At runtime, the target function to be modified is located. A place holder instruction within the target function is overwritten with instructions to cause execution of the hook function when the target function is called.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274768&OS=09274768&RS=09274768
owner: Microsoft Technology Licensing, LLC
number: 09274768
owner_city: Redmond
owner_country: US
publication_date: 20140617
---
This application is a continuation of and claims priority under 35 U.S.C. 120 to U.S. patent application Ser. No. 12 055 300 filed on Mar. 25 2008 and titled Runtime Code Hooking for Print Driver and Functionality Testing the disclosure of which is incorporated by reference herein in its entirety.

Developers and administrators may wish to hook executable code to an existing module function or other target code for a variety of purposes. Code hooking involves injecting instructions into the target code to cause execution of alternate code e.g. the hooked code. For instance code hooking may be used to test the target code to provide added functionality e.g. extensions to update or patch the target code and so on.

One traditional technique to change an existing function or other target code involves redeveloping the target code to include the new instructions. The software project may then be entirely recompiled and redistributed. This technique relies upon direct changes to the source code and recompilation s of the entire software project. Accordingly the technique is not suited to modifications made at runtime and may involve time consuming and costly redevelopment. Further such a change may not be an option when the source code is not available.

Another technique to change an existing function or other target code involves overwriting an import address table TAT that may dynamically link to external functions. This technique allows code to be hooked by modifications to the TAT that is loaded by an application at runtime. The TAT holds references to imported functions such as those loaded from a dynamic link library DLL . By overwriting the address of a function in the TAT with an alternate function code flow may be redirected to the alternate function. While TAT overwriting is suited for some scenarios TAT overwriting is typically limited to inter module calls because the linkers that use the TAT are limited to making local calls within the same module. Further the TAT overwriting techniques may be defeated by direct calls to a function e.g. static linking Thus TAT overwriting may not be suitable for certain applications such as counters tracking error trapping and so forth because some calls to the target function e.g. direct calls may be missed.

Runtime code hooking techniques are described in which a place holder instruction within a compiled module is used as an entry point to enable code hooking. A hook function to modify a target function is developed. At runtime the target function to be modified is located. A place holder instruction within the target function is overwritten with instructions to cause execution of the hook function when the target function is called.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Developers and administrators hook executable code to an existing module function or target code for a variety of purposes. For instance code hooking may be used for testing the target code to provide added functionality extensions to update or patch the target code and so on. However traditional techniques to hook executable code involved direct changes to source code and recompiling of the code which may be time consuming and costly.

Runtime code hooking techniques are described in which a place holder instruction within a compiled module is used as an entry point to enable code hooking. In implementation a developer may create a hook function to modify a target function that relates to printing functionality of a computing device. For example the hook function may be created to track printer handle leaks related to a target function that assigns printer handles. The hook function may be stored in memory of the computing device or a location accessible to the computing device. At runtime the target function to be modified with the hook function is located. For example a location of the target function in memory or remote storage may be determined through interaction of a verification tool with the operating system of the computing device. Then the verification tool may operate to overwrite a place holder instruction within the target function with instructions that cause the hook function to be executed when the target function is called. In an implementation the verification tool is configured to interact with one or more application programming interfaces APIs of the operating system to locate a target function and overwrite place holder instruction within the target function. The place holder instruction enables code hooking at runtime that may occur without recompiling the code or even rebooting the system. In this manner a developer may modify an existing code project to test the code add new functionality debug the code and so forth.

In the following discussion an exemplary environment is first described that is operable to perform runtime code hooking techniques. Exemplary procedures are then described that may be employed in the exemplary environment as well as in other environments. Although these techniques are described as employed within an exemplary computing environment in the following discussion it should be readily apparent that these techniques may be incorporated within a variety of environments without departing from the spirit and scope thereof.

In the following description a referenced component such as computing device may refer to one or more entities and therefore by convention reference may be made to a single entity e.g. the computing device or multiple entities e.g. the computing devices the plurality of computing devices and so on using the same reference number.

Processors are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example processors may be comprised of semiconductor s and or transistors e.g. electronic integrated circuits ICs . In such a context processor executable instructions may be electronically executable instructions. Additionally although a single memory is shown for the computing device a wide variety of types and combinations of memory may be employed such as random access memory RAM hard disk memory video memory removable medium memory and other types of computer readable media.

The one or more processors are illustrated as executing an operating system which is also storable in the memory . Memory also includes a variety of program applications and related program data . The one or more processors may retrieve and execute computer program instructions from program applications to provide a wide range of functionality to the computing device including but not limited to office productivity email media management printing networking web browsing and so forth. A variety of program data is contemplated examples of which include office documents multimedia files emails data files web pages user profile and or preference data and so forth.

Processor in addition to executing the operating system is further illustrated as executing an analytics module and an injector module each of which may also be stored in the memory . While depicted as stand alone applications in the analytics module and injector module may also be implemented as components of a common program application .

Analytics module and injector module are representative of functionality of the computing device operable to perform runtime code hooking techniques described herein. By way of example a target function and a hook function are illustrated as stored in memory of computing device . The hook function may be developed retrieved and or stored through operation of the analytics module . Then through various interactions of the analytics module and injector module with the operating system the hook function may be hooked to the target function . More particularly analytics module and injector module may be operable at runtime to hook the hook function to the target function .

 Hooking in reference to the described techniques refers to injection of instruction s in a target function to cause execution of the hook function when calls are made to the target function . In an implementation analytics module and injector module perform the hooking at runtime through one or more place holder instructions included in the target function at compile time. The one or more place holder instructions may be intentionally introduced when a code project is compiled e.g. at compile time to enable code hooking in the future e.g. at runtime. Further discussion of using place holder instructions to perform runtime code hooking techniques may be found in relation to the following figures.

Computing device is also depicted a having communication interfaces which may communicatively couple the computing device to a wide range of peripheral devices examples of which include but are not limited to a display a printer a network router a communication network and so forth. In one or more embodiments runtime code hooking techniques may be employed in relation to operation of the peripheral devices . In particular code may be hooked to a target function to facilitate development managing testing debugging and administering of program applications related to operation and performance of various peripheral devices .

Generally the functions described herein can be implemented using software firmware hardware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms module functionality engine and logic as used herein generally represent software firmware hardware or a combination thereof. In the case of a software implementation for instance the module functionality or logic represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices. The features of the techniques to provide runtime code hooking are platform independent meaning that the techniques may be implemented on a variety of commercial computing platforms having a variety of processors.

The computing device in is illustrated as having a processor and memory as discussed in relation to . Further the processor is illustrated as executing the operating system and a print verifier module . In the example of the operating system includes application program interfaces APIs and a print subsystem . APIs provide core tools and functions that may be used to take advantage of the operating system functionality including printing functionality. Generally APIs are interfaces that various program applications may call to take advantage of various tools and services provided by the operating system . While the APIs are illustrated as a single group it is noted that different APIs or groups of the APIs may be arranged as different operating system components. For example certain APIs to provide printing specific functionality may logically be considered part of the print subsystem . A variety of other examples are also contemplated.

Further the computing device may include one or more printer drivers to facilitate communication with one or more printing devices that may be communicatively coupled to the computing device locally or over a network. The operating system may support a variety of printer drivers to enable printing to many different printing devices . The print subsystem may include various printing specific APIs core tools and system drivers. Further the printing specific APIs core tools and system drivers of the print subsystem may interact with a printer driver to enable communication between print functionality of the operating system and a corresponding printing device for which the printer driver is developed. Printer driver may represent a driver developed by a third party e.g. a printer manufacturer for a corresponding printing device .

An application program may generate print data which in is illustrated as stored in memory . For instance in a word processing program a user may create a formatted text document and then select a print command to cause output of the document on the printing device . When a print command of an application program is selected the application program may output print data and interact with the various APIs and the print subsystem to access printing functionality available through the operating system and to create a print job. The operating system and print subsystem may process and format the print job for output to the printing device . A printer driver facilitates communication between the computing device and a corresponding printing device and may operate to format print data related to the print job in a language and or format understandable by the printing device . Printer driver may be configured to use various core tools provided via the print subsystem and to make calls to APIs of the operating system to output the printing data via the printing device .

The print verifier module is representative of functionality to access manage test debug troubleshoot and administer printing functionality of the computing device . Print verifier may be configured to include a set of integrated tools to perform static and or runtime verification and testing of the print subsystem for compatibility stability and security. Print verifier may be implemented as a helper tool that may be employed by developers and administrators to catch and resolve printing related problems.

For example print verifier may be configured to test problems with printing related APIs examples of which include but are not limited to print handle tracking printer handle leak detection and multithreaded usage of printer handles. Print verifier may also provide tools to catch problems between core print functionality of the print subsystem and printer drivers developed by third parties such as non conforming print tickets misuse of device driver interfaces and incompatible communication formats. Further for testing purposes the print verifier may intentionally inject faults and monitor the response and error handling procedures of the print subsystem and printer drivers .

Runtime code hooking techniques may occur in relation to the functions of the print verifier e.g. to enable the print verifier to access manage test debug troubleshoot and administer printing functionality of the computing device . For instance the analytics module and injector module of are depicted as being integrated with the print verifier module . By way of example a target function is illustrated in as a component of a printer driver . Further a hook function which has been developed to test debug update or patch aspects of the printer driver and or print subsystem is illustrated as stored in the memory . Through interactions of the analytics module and injector module with the operating system APIs and or the print subsystem the hook function may be hooked to the target function to test update or patch the printer driver .

While target function to which a hook function is to be hooked is illustrated in as a component of a printer driver the target function may also be a component the operating system an API of the operating system or a component of the print subsystem . In this case the target function rather than being part of the printer driver is a component of the operating system which the printer driver may rely upon to output a print job. Target function may also be a component of a separate program application .

In an embodiment the target function may be included as a function in a dynamic link library DLL provided by the operating system and or available in memory of the computing device which may be called by various program applications . DLLs may be used to avoid having to statically code common procedures into each program application or module that uses one or more procedures. Thus common procedures may be offloaded from a program application itself to a DLL and then imported at runtime from the DLL.

In accordance with the described techniques runtime code hooking may occur via one or more place holder instructions included at compile time in the target function . For instance memory is illustrated as storing a compiler which is representative of functionality to translate source code into executable code. Further at compile time the compiler may be configured to introduce place holder instructions into a code project to facilitate future code hooking. In an embodiment the compiler introduces a place holder instruction as a first instruction of a function such as the illustrated target function . The compiler may introduce place holder instructions into each function of a code project. The place holder instruction may be a non operative instruction whose intended purpose is to be overwritten by other instructions e.g. a jump instruction when code hooking is desired. Thus when code is not hooked to the target function the place holder instruction may be dormant. However a developer or administrator may use the place holder instruction as an entry point to hook code to the target function . Further the place holder instruction is a known quantity that is in a known place within the target function and is accordingly known to be safe to overwrite. Thus a developer or administrator may use the place holder instruction for runtime code hooking without having to search for suitable instructions that can be safely overwritten. Further since the overwritten instruction may not have an operational function the place holder instruction may be overwritten without having to maintain a copy of overwritten instructions to enable a callback to the target function or otherwise perform the function of the overwritten instruction.

In an implementation a relatively small place holder instruction may be included in the target function so that the expense of executing the function e.g. processing time in the absence of code hooking is kept low. In other words the size of the place holder instruction introduced into a target function may be optimized for the situation in which the place holder instruction is not used for code hooking. In this case the place holder instruction may be a few bytes in size e.g. less than 5 bytes which may not be sufficient to write a jump instruction to the hook function .

To provide sufficient space to write a jump instruction to the hook function the compiler may be configured to maintain gaps between functions in a code sequence. Thus the relatively small place holder instruction is sufficient to write a jump to a gap placed in the code sequence between the target function and other functional blocks. The gaps maintained by the compiler may comprise a plurality of non operative instructions which are sufficient to write a longer jump e.g. 5 bytes or more to the hook function . Thus overwriting may include overwriting the place holder instruction with a jump instruction to a plurality of non operative instructions in the code sequence and then overwriting of the plurality of non operative instructions with an instruction to jump to the hook function .

It is noted that the compiler may operate on a separate computing device to compile code that is developed in a separate environment e.g. a development environment and which is then distributed for end use by many computing devices . For example a printer driver may be distributed by a printer manufacturer along with a corresponding printing device . However for simplicity sake the compiler is depicted as a component of the illustrated computing device of . Compiler may represent functionality operable by the computing device or by separate computing devices to introduce place holder instructions for the purpose of code hooking into a target function at compile time. Additional discussion of techniques that use place holder instructions to perform code hooking may be found in relation to the following figures.

In operation analytics module may be configured to specify whether or not code is to be hooked to a target function . For instance a developer or administrator may operate the analytic module to specify various target functions to be modified and to indicate hook functions which are to be hooked to the target functions . The developer or administrator may input information to identify hook functions such as a name address storage location universal record locator URL and so forth. At runtime the analytics module may process various code blocks such as the example code block . Analytics module may determine for code block whether to invoke the injector module or not.

If code hooking is specified for the code block analytics module may determine a location such as a memory address of the target function to be hooked. In an implementation the analytics module may call a function location API of the operating system to obtain the location information. Then the analytics module invokes the injector module to inject one or more instructions into the code block to cause execution of the hook function when calls to the target function are made. For instance analytics module may provide the location of the target function to be hooked to the injector module . Further analytics module may provide information to identify the hook function to the injector module so that the injector module is able to find and or reference the appropriate hook function .

Injector module operates to find one or more place holder instructions within the target function and to overwrite the instructions to cause execution of the hook function . For instance the place holder instruction may be overwritten with a jump instruction specifying a jump to the hook function . In the illustrated example the jump instruction may reference the location of the hook function within the code library . In an implementation the injector module may interact with a code insertion API of the operating system to cause the place holder instruction s to be overwritten with the jump instructions. The result is the example code block which is configured to cause execution of the hook function when calls are made to the target function .

If code hooking is not specified then the original code block may be maintained and calls to the target function will remain unaffected e.g. the original target function is executed. Further discussion of techniques to hook code to a target function may be found in relation to the following procedure.

The following discussion describes techniques related to runtime code hooking that may be implemented utilizing the previously described environment systems and devices. Aspects of each of the procedures may be implemented in hardware firmware or software or a combination thereof. The procedures are shown as a set of blocks that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks. In portions of the following discussion reference may be made to the exemplary environment of and the exemplary computing device of .

In implementation analytics module of may be configured with information sufficient to identify the target function e.g. a function name DLL name URL and so forth and to identify the hook function to be hooked to the target function . At runtime the analytics module may determine a location of the identified target function . For instance the analytics module may call a function location API of the operating system to obtain a memory location or address of the target function in this example the open printer API .

A hook function is identified and that is to execute when the target function is called block . Continuing the preceding example the hook function that is developed to test for printer handle leaks may be stored in memory of the computing device of . Alternatively the hook function may be available from a suitable remote storage location over a network. In either case analytics module may be configured with information to identify the hook function and where the hook function is available such as indicating a DLL in which the hook function is located a name a web address and so forth. To cause hooking of the hook function to the target function analytics module may pass the information identifying the hook function along with the information specifying the location of target function to the injector module which is configured to perform the hooking.

A place holder instruction is overwritten with instructions to cause a jump to the hook function block . In an implementation injector module may call one or more APIs of the operating system to perform the code hooking. For example through interaction with the operating system and various APIs the injector module may retrieve the target function ensure a suitable place holder instruction exists identify the place holder instruction determine a location of the place holder instruction and write the jump instruction s in the determined location to overwrite the place holder instruction. It is noted that injector module is configured to perform the hooking at runtime e.g. when the target function is loaded. The code hooking occurs without having to recompile or reload the code and without having to reboot the system. Further as the jump instruction directly modifies a place holder instruction in the target function both static calls and dynamic calls which use an import address table to the target function will be redirected to the hook function .

Then when the target function is called the jump to the hook function is executed block . In this case the hook function is executed and may perform various print handle tracking functions. The hook function may generate results which are provided back to the analytics module for further processing. For instance hook function may determine which handles are in use how long the handles have been in use and indicate whether handle leaking is suspected. A variety of other examples are also contemplated.

It is noted that a hooked function may be executed in addition to or in lieu of the target function to which the hook function is hooked. Thus the hook function may or may not include a callback to the target function . For example if the hook function provides a fix to a bug in the target function then the target function may be bypassed to avoid the bug. However if the hook function provides a monitoring function such printer handle leak detection in the above example then the instructions in the target function may be executed. In this case the hook function may callback to target function .

In particular a determination is made whether to callback to the target function block . If a callback is determined program flow returns to execute the target function block after the jump instruction. It is noted that since the jump instruction overwrites a place holder instruction the place holder instruction may be overwritten without preserving the place holder instruction. Thus the overwritten place holder instruction need not be copied to the hook function or otherwise stored. To perform the function of the original target function the callback may simply return to the next instruction of the target function e.g. after the place holder .

If a callback is not determined program execution continues without executing target function block e.g. the target function is bypassed. In this manner runtime code hooking may be used to execute a hook function in addition to or in lieu of the target function to which the hook function is hooked.

Although the invention has been described in language specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed invention.

