---

title: Dynamically loaded system-level simulation
abstract: A system-level simulation includes generating netlist information including component library information, which describes instances of the hardware components, and component instance information, which describes component dynamic libraries that include models of hardware components. The simulation is generated at simulation run-time based on the netlist information. Component dynamic libraries corresponding to the component library information are loaded based on the component library information. A simulation dynamic library referenced by the component dynamic libraries is loaded. One or more interlibrary adapters corresponding to the component dynamic libraries are loaded to provide compatibility between the component dynamic libraries and an application binary interface of the simulation dynamic library. Instances of hardware components are instantiated based on the component instance information, and the instantiated instances of the hardware components are connected to form the simulation. The simulation is performed at simulation run-time responsive to the simulation being generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582623&OS=09582623&RS=09582623
owner: Synopsys, Inc.
number: 09582623
owner_city: Mountain View
owner_country: US
publication_date: 20141208
---
This application claims the benefit of U.S. Provisional Patent Application No. 61 939 165 titled Dynamically Loading based SystemC Simulations and filed on Feb. 12 2014 the content of which is incorporated by reference in its entirety. This application claims the benefit of U.S. Provisional Patent Application No. 62 082 880 titled Dynamically Loaded System Level Simulation and filed on Nov. 21 2014 the content of which is incorporated by reference in its entirety.

SystemC is a system level modeling language used for simulating the behavior of a system such as a system on a chip SoC . SystemC allows a system to be described at different levels of abstraction. More specifically SystemC is a language built in standard C by extending the C language with the use of class libraries. SystemC provides a system design and verification language that spans hardware and software. Example uses of SystemC include modeling partitioning of a simulation system evaluating and verifying the assignment of blocks to hardware or software implementations and measuring the interactions between and among simulated components.

Traditionally a host compiler generates SystemC system simulations by statically linking together precompiled object files. Prior to execution of the simulation the host compiler compiles simulation components into a simulation executable file. References by the simulation components to each other are bound to addresses internal to the simulation executable. Statically linked simulations are inconvenient for end users. When a component of the simulation is modified the addresses associated with the bound references are no longer necessarily valid. Accordingly the entire statically linked simulation is recompiled to relink references to the correct address which results in significant time wasted for an end user managing simulations. Additionally statically linked simulations expose the namespace of simulation components to other simulation components. As a result different versions of a component cannot be simulated because these components use the same variable and function names. This limitation of static linking hampers simulation of systems with multiple subsystems.

Reference will now be made in detail to several embodiments examples of which are illustrated in the accompanying figures. It is noted that wherever practicable similar or like reference numbers may be used in the figures and may indicate similar or like functionality. The figures depict embodiments of the disclosed system or method for purposes of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein.

Embodiments of the present disclosure include a system simulation method system and non transitory computer readable storage medium for dynamically loading components of a system simulation at runtime of the system simulation.

In one embodiment netlist information is generated that includes component library information and component instance information. The component library information describes component dynamic libraries that include models of hardware components and the component instance information describes instances of the hardware components. A simulation is generated at simulation run time based on the netlist information. To do so the component library information and the component instance information are accessed and the component dynamic libraries are loaded based on the component library information. A simulation dynamic library providing simulation functionality referenced by the component dynamic libraries is loaded. One or more interlibrary adapters providing compatibility between the component dynamic libraries and a simulation library application binary interface ABI of the simulation dynamic library are also loaded. Instances of hardware components are instantiated based on the loaded component dynamic libraries and the component instance information and the instantiated instances of the hardware components are connected to form the simulation. The simulation may then be performed during the simulation run time responsive to the simulation being generated.

In one embodiment the netlist information includes connectivity information describing connectivity between the instances of the hardware components. The instantiated instances of the hardware components are connected based on the connectivity information to form the simulation.

In one embodiment the component dynamic libraries include component creators adapted to create instances of hardware components from the models of the hardware components. To load the component dynamic libraries the component dynamic libraries are placed into memory and the component creators within the component dynamic libraries are registered into a creator registry. To instantiate the instances of the hardware components one or more of the component creators from the creator registry are identified that correspond to the instances described by the component instance information. Using the identified component creators the instances of the hardware components are instantiated.

In one embodiment an interlibrary adapter includes a component library facing ABI and a mapping between the component library facing ABI and the simulation library ABI of the simulation dynamic library. A compiled component dynamic library includes a component stub library that redirects simulation dynamic library calls by the component dynamic library to the component library facing ABIs of the interlibrary adapter. To generate a component dynamic library one or more source files corresponding to a hardware component modeled by the component dynamic library are obtained. The component stub library is generated and prior to simulation run time the source files are compiled into object files referencing the one or more interlibrary adapters through the component stub libraries. The object files and the component stub libraries are linked into the component dynamic libraries.

In one embodiment a simulation described by the netlist may be performed with a different simulation dynamic library without recompiling the component dynamic libraries for compatibility with the simulation dynamic library even if the different simulation dynamic library has a different simulation library ABI incompatible with the simulation library ABI of the previous simulation dynamic library. The one or more interlibrary adapters are recompiled based on one or more mappings determined between the one or more component library facing ABIs and the different simulation library ABI.

The features and advantages described in the specification and in this summary are not all inclusive and in particular many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings specification and claims. Moreover it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the disclosed subject matter.

The system simulation models the operation of one or more hardware components e.g. processor memory etc. of a target system. The system simulation may imitate the execution of computer program instructions e.g. software firmware on the modeled hardware components e.g. a model of a processor and or memory or the modeled hardware components may deliver specialized functionality e.g. an application specific integrated circuit . In one embodiment the system simulation is implemented using a system level description language e.g. SystemC SpecC SystemVerilog . A hardware component is a physical entity that manipulates physical signals representing information through technologies such as digital and or analog electronics.

The system simulation may represent modeled hardware components hierarchically. For example a system simulation of a computer includes a model of a processor a memory and an input interface e.g. a Universal Serial Bus USB port . The model of the processor includes sub models of a cache a register calculation electronics e.g. an arithmetic logic unit ALU a floating point unit FPU and signal routing electronics e.g. a bus a multiplexer .

The component dynamic library contains instructions for creating and simulating a hardware component. The component dynamic library includes a component model a component creator a component creator registrar and a component stub library .

The system simulation may include one or more instances of a hardware component. To determine how a particular instance of a hardware component functions e.g. in response to an input or an event the system simulation uses a component model which are instructions describing the hardware component s functionality. In one embodiment a component model includes variables which represent the state of a simulated hardware component parameters which describe properties of simulated hardware that are invariant during a simulation and functions which modify or retrieve the state of the simulated hardware component. Different component dynamic libraries may have different component models corresponding to the same hardware component. For example different component dynamic libraries each have different component models describing a hardware component at the transistor level the digital circuit level or at a behavioral level respectively. Different component libraries with different component models provide varying levels of detail accuracy and speed for simulating a hardware component.

The component creator instantiates an instance of a hardware component described by the component model . In one embodiment the component creator of a hardware component initializes parameters and variables representing the state of an instantiated component based on default values or configuration information associated with an instance. In initializing parameters and variables the component creator may allocate memory in a simulating computer for the instance of the hardware component. For example a multiplexer has parameters describing the multiplexer s number of bits in inputs and outputs the multiplexer s number of inputs and the multiplexer s number of outputs. When the component creator instantiates the multiplexer the component creator determines the number of bits the number of inputs and the number of outputs based at least in part on configuration information supplied to the component creator or default parameters.

The component creator registrar includes instructions used to load a component dynamic library into a simulation. The component creator registrar includes instructions to register a component creator of a simulation in a creator registry which is part of the simulation dynamic library . In one embodiment the component creator registrar creates an entry in the creator registry which contains an identifier of the component dynamic library and a pointer to the component creator in the component dynamic library . The identifier uniquely identifies the component dynamic library . For example the identifier is a string indicating the component dynamic library s vendor library name version VLNV which indicates the class name and version number of the component dynamic library .

The component stub library provides an interface between the component dynamic library and the interlibrary adapter . The component stub library is described further in conjunction with the interlibrary adapter .

The netlist provides information indicating configuration of hardware components present in a simulation. The netlist includes a shared library list an instance list and a connectivity list .

The shared library list includes component library information which details the component dynamic libraries used to model the hardware components of a simulation. In one embodiment the shared library list includes a class name for a component dynamic library and reference e.g. a memory pointer to the component dynamic library . In some embodiments the class name for a component dynamic library is a version specific class name e.g. a VLNV which enables use of multiple versions of a component dynamic library in the same simulation. The shared library list may include this information for several component dynamic libraries .

The instance list includes instance information which enumerates component instances of the simulated target system. An instance of a component is a single distinct realization of a hardware component. The instance list may include multiple instances of the same type of hardware component e.g. multiple instances of a processor core all modeled by the same component dynamic library . An entry in the instance list may provide an instance identifier to refer to each instance as well as indicate the component dynamic library that models the instance. An entry in the instance list may also include parameters e.g. the data capacity of a memory hardware component or the number of inputs to a multiplexer to configure an instance.

The connectivity list includes connectivity information describing connections among the instances of hardware components enumerated by the instance list . In one embodiment an entry in the connectivity list describes the one or more instances connected by a connection and particular ports or interfaces of the instances bound to the connection. An entry in the connectivity list may also include the type of the connection e.g. buffer mutex wire semaphore and parameters of the connection e.g. data type number of bits .

The simulation dynamic library provides an infrastructure for executing the system simulation . The simulation dynamic library includes a simulation kernel a creator registry and an instance registry .

The simulation kernel includes instructions that serve as infrastructure for executing the system simulation . The simulation kernel may provide a framework for advancing the simulation through time or events. For an example event based simulation the simulation kernel determines an order for processing simulation events and provides resources to resolve simulation events. The simulation kernel may also provide functionality used by other components of the system simulation such as by the component dynamic libraries . For example the simulation kernel includes functions called by a component dynamic library to detect errors or to notify a user of an error or unusual operating condition.

The creator registry is a list of loaded component dynamic libraries that is created at run time. In one embodiment the component creator registrar creates an entry in the creator registry for a loaded component dynamic library . The entry in the creator registry contains an identifier of the component dynamic library and a pointer to the component creator in the component dynamic library . In one embodiment a component dynamic library may depend on additional embedded files. Such dependency information is embodied in metadata information recorded by the authoring tool . The creator registry may contain pointers to the embedded files.

The instance registry is a list of instantiated components that is created at run time. In one embodiment the component creator of an instantiated component or the simulation loader creates an entry in the instance registry for the instantiated component. The entry in the instance registry contains an identifier of the instance and a pointer to a memory location allocated to the instantiated instance.

The simulation loader takes as an input the netlist and one or more component dynamic libraries generates the simulation at run time and outputs a generated simulation. In one embodiment the simulation loader is an executable file used to perform a simulation. When a user instructs a computer to perform a simulation the simulation loader loads the system simulation into the memory of the computer at simulation run time. Loading a simulation system at simulation run time denotes that the simulation loader generates the simulation immediately after a command to execute a simulation e.g. a user input a scheduled simulation and immediately before performing the simulation. To generate a simulation by dynamic loading at simulation run time the simulation loader loads relevant component dynamic libraries instantiates hardware components of the simulation and connects the instances of the hardware components.

By generating the system simulation at simulation run time the simulation loader avoids building a statically linked simulation file which incurs significant overhead. Dynamically loading a simulation also avoids pitfalls of a dynamically linked simulation. In a dynamically linked simulation the namespaces of various dynamic libraries e.g. the component dynamic library the simulation dynamic library are exposed to each other. If different dynamic libraries use the same name to refer to distinct functions variables or objects then the dynamic libraries are no longer compatible. Dynamically generating and loading the system simulation at run time also avoids implementation difficulties of dynamically linking libraries. If libraries are initially written for use in a statically linked simulation they are not necessarily compatible with a dynamically linked simulation due to unresolvable run time ambiguities in references to functions variables or objects. Remediating a library for compatibility with a dynamically linked simulation is a labor intensive process and is often not be feasible without completely re writing the library s source code. Thus the simulation loader generates dynamically loaded simulations at simulation run time to avoid significant modification of libraries written for use in statically linked simulations.

By dynamically loading a simulation at run time a system simulation may be easily modified. If portions of the simulation are modified after generating the simulation then the simulation loader re loads those portion affected by the modification. For example if the netlist is modified then the simulation loader loads any newly added or modified instances as well as modified connectivity between instances. As another example a component dynamic library modeling a hardware component is swapped for a different version modeling the same hardware component e.g. a slow hardware level version is replaced by a fast software level version . In this example the simulation loader may modify the reference to the component dynamic library associated with the affected instances without re linking the entire system simulation .

The component stub library provides an interface between the component dynamic library and the interlibrary adapter . The interlibrary adapter provides an interface between the component dynamic library and the simulation dynamic library . The interlibrary adapter includes a component library facing interface on which the component stub library depends and the simulation dynamic library includes a simulation library interface on which the interlibrary adapter depends.

A component library name is a symbol e.g. a string in source code an address in memory used to refer to a program construct in the component dynamic library . A program construct is a basic element command or statement used in source code. Example program constructs include functions variables operators objects and classes. A simulation library name is a symbol e.g. a string in source code an address in memory used to refer to a program construct in the simulation dynamic library . In one embodiment the component dynamic library may rely on a simulation library program construct e.g. a function defined in the simulation dynamic library . The component library name of the simulation library program construct may differ however from the simulation library name of the simulation library program construct.

For example if a simulation dynamic library is modified and if the component dynamic library is not modified then the component library name of a function called by a component dynamic library may be different from the function s actual simulation library name defined in the simulation dynamic library . Even if the source code name of a simulation library program construct does not change between versions of a simulation dynamic library the machine code used to refer to the program construct in the simulation dynamic library s application binary interface ABI may change. To ensure compatibility between the component dynamic library and the simulation dynamic library the system simulation uses the component stub library and the interlibrary adapter to bridge gaps in compatibility between the simulation dynamic library and the component dynamic library .

The component stub library takes as input a component library function name used by the component dynamic library maps the component library function name to a corresponding intermediate adapter name and outputs the intermediate adapter name. An intermediate adapter name is a symbol e.g. a string in source code an address in memory used by the interlibrary adapter to refer to a program construct. At a machine code level the component stub library depends on a simulation library facing ABI of the interlibrary adapter .

The interlibrary adapter takes as input the intermediate adapter name maps the intermediate adapter name to the corresponding simulation library name and outputs the simulation library name. Hence the component dynamic library may use the interlibrary adapter to call simulation library program constructs from the simulation dynamic library without exposure to the namespace of the simulation dynamic library . The interlibrary adapter provides for compatibility between a simulation library facing ABI of the interlibrary adapter and a simulation library ABI of the simulation dynamic library .

The adapter generator takes as input the component dynamic library and the simulation dynamic library identifies dependencies by the component dynamic library on the simulation dynamic library and outputs an interlibrary adapter to interface between the component dynamic library and the simulation dynamic library . The adapter generator identifies a component library facing interface corresponding to a version of the simulation dynamic library compatible with the component dynamic library or its source files . The adapter generator identifies the simulation library interface of the present version of the simulation dynamic library . The adapter generator determines a mapping between programming constructs of the component library facing interface and the simulation library interface. Using the mapping the adapter generator generates the interlibrary adapter which includes functions to translate calls to the component library facing interface into calls to the simulation library interface.

For example the interlibrary adapter is generated in conjunction with the component stub library as part of compiling a component dynamic library . Even if the source files of the component dynamic library were written for compatibility with a first version of the simulation dynamic library the interlibrary adapter may provide for compatibility with a second version of the simulation dynamic library .

As another example a first version of the simulation dynamic library is replaced by a second version of the simulation dynamic library after compiling the component dynamic library . The second version of the simulation dynamic library has a simulation library interface different than that of the first version of the simulation dynamic library . The adapter generator generates an updated interlibrary adapter or re generates the interlibrary adapter to maintain compatibility between the component dynamic library and the second version of the simulation dynamic library . The updated interlibrary adapter maintains the same component library facing interface as the initial interlibrary adapter to maintain compatibility with the component stub library of the component dynamic library beneficially obviating compilation of the component dynamic library .

In one embodiment the adapter generator identifies references to program constructs of the simulation dynamic library simulation library program constructs in the source files of the component dynamic library . The adapter generator identifies portions of the component library facing ABI a machine code level component library facing interface that correspond to the identified simulation library program constructs. The adapter generator identifies portions of the simulation library ABI a machine code level simulation library interface . The adapter generator then determines a mapping between the component library facing ABI and the simulation library ABI to provide compatibility. For example the mapping for a function includes pointers to the memory locations of input and output variables or includes instructions to convert variables between data types e.g. between floating point format and double precision floating point format .

The component library generator takes as input the simulation dynamic library and source files describing component models compiles and links the source files to generate a component dynamic library and outputs the component dynamic library . The source files contain source code describing component models e.g. of hardware components as well as source code used to interact with other objects in the system simulation e.g. source code representing the component creator registrar .

In one embodiment the component library generator generates an object file corresponding to each source file. The object file contains machine code representing a hardware component and is compatible with the simulation library interface of the simulation dynamic library through the interlibrary adapter .

In some embodiments the component library generator generates the component stub library in conjunction with the adapter generator generating the interlibrary adapter . In other embodiments the component stub library is generated after the interlibrary adapter . The component library generator identifies the component library facing interface of the interlibrary adapter and generates stub references to the component library facing interface. The component stub library comprises the stub references. The component library generator binds references to simulation library program constructs to the stub references. Thus where the source file refers to a simulation library program construct the object file refers to a corresponding stub reference in the component stub library instead. The component stub library ensures that the resulting component dynamic library depends on the simulation dynamic library indirectly through the interlibrary adapter because references to the simulation dynamic library are routed through the interlibrary adapter by the component stub library .

The component library generator links the object files together to form a component dynamic library having a common namespace. If a component dynamic library includes any dependencies on other embedded files the component library generator may embed metadata describing the dependency in the dynamic component library . In one embodiment the component library generator generates component creator registrars for the component dynamic libraries of the shared library list .

The authoring tool receives user inputs for creating a design of the target system and converts the design into the netlist . The authoring tool may be one or more computer aided design programs that receive user input through a graphical user interface command line prompt or a combination thereof. For example a user may select hardware components configure properties of the hardware components and connect ports of the hardware components through the authoring tool to create a target system design. The authoring tool translates the components into the instance list and translates the connections between the components into the connectivity list . The authoring tool also determines component dynamic libraries associated with the components and collects these component dynamic libraries into the shared library list .

The memory monitor takes as input memory resources available to a computer running the system simulation determines whether to load or unload one or more portions of a component dynamic library and then instructs the operating system of the computer running the simulation to load or unload the corresponding portions of the component dynamic library . For example the portion of the component dynamic library is a component model or a portion of a component model . In one embodiment portions that may be unloaded include portions that do support communication between instances of hardware components e.g. ports port interfaces or portions that do not directly interact with simulation processes. For example in a system level modeling language such as SystemC initialization routines may be unloaded. As another example in SystemC support routines for port interfaces may be unloaded but portions implementing hardware component ports may not be unloaded unless they are unbound to instances of hardware components.

In one embodiment the memory monitor determines whether all of the component dynamic libraries listed in the shared library list may be loaded into memory of the computer running the simulation. If there is sufficient memory then the memory monitor allows loading of all of the component dynamic libraries . If there is not sufficient memory then the memory monitor selects a subset of the component dynamic libraries or portions thereof to dynamically load or unload from the memory of the computer conducting the simulation. Unloading a portion of a simulation component refers to allowing memory allocated to a portion of an unloaded component dynamic library to be allocated to other data.

In one embodiment the memory monitor identifies one or more portions of component dynamic libraries or embedded files referenced by component dynamic libraries that the simulation will not use or is unlikely to use within a threshold time period into the future. For example the memory monitor identifies such a portion of a component dynamic library responsive to a portion of a component model not being used within a threshold period of time or based on a ranking of portions of a component dynamic library by last time used. For example a portion of a component model is identified as not being used where the portion implements a port that is unbounded to any instances of hardware components. The memory monitor instructs the operating system to unload one or more portions of a component dynamic library that the system simulation will not use or will likely not use . As another example the memory monitor identifies a portion of a component dynamic library or another file e.g. a configuration file that is loaded as part of generating a simulation but not used to perform the simulation. In the example the memory monitor unloads the identified portion of the component dynamic library or other file not used after generating the simulation. Unloading portions of dynamic libraries beneficially reduces memory use by the system level simulation and increases memory available to hold other data.

Additionally the memory monitor may identify an unloaded portion of a component dynamic library that is anticipated to be used by the system simulation . For example the memory monitor identifies such a portion using heuristics e.g. a recently used portion of a component dynamic library a portion of a component library related to another portion of the component dynamic library used to resolve a recent simulation event . The memory monitor instructs the operating system to load into memory the identified portion of the component dynamic library that the system simulation is anticipated to use and instructs the operating system to unload from memory one or more portions of one or more component dynamic libraries that the system simulation is not anticipated to use. Pre loading portions of dynamic libraries beneficially reduces simulation time by preventing or decreasing the frequency of the simulation halting to wait for a dynamic library to load.

When compiled and accordingly translated to machine code and linked the component stub library accesses the interlibrary adapter through a component library facing ABI . On the source code level the interlibrary adapter then calls the function in the simulation kernel using the simulation library name. When compiled and linked the interlibrary adapter accesses the simulation kernel using a simulation library ABI of the simulation dynamic library . The component stub library accesses the interlibrary adapter through the component library facing ABI . Because the component stub library references the component library facing ABI changes to the component library facing ABI necessitate recompilation of the component dynamic library . In contrast the simulation library ABI is referenced by the interlibrary adapter so changes in the simulation library ABI may be mitigated by recompiling the interlibrary adapter without recompiling dependent component dynamic libraries .

In one embodiment the component dynamic library and the simulation dynamic library use a domain specific language built on a low level programming language. The component dynamic library and the simulation dynamic library express the component library names and the simulation library names respectively in the high level programming language. The component dynamic library and the simulation dynamic library maintain separate namespaces within the domain specific language. The interlibrary adapter expresses interlibrary adapter names in the low level programming language. Accordingly the component stub library translates the component library name in the high level programming language to the intermediate adapter name in the low level programming language. The interlibrary adapter translates the intermediate adapter name in the low level programming language to the simulation library name in the domain specific language in the namespace of the simulation dynamic library . Thus the component dynamic library may access program constructs in the namespace of the simulation dynamic library by using the low level programming language. The interlibrary adapter has a very simple programmatic structure accordingly the component library facing ABI is relatively stable in contrast to the simulation library ABI which may vary if the simulation dynamic library is updated in significant manner. For example if an update to the simulation dynamic library modifies the number or data format of a function s inputs or outputs then the ABI may change.

For example one function of the simulation dynamic library is sc event notify in the C programming language which is a domain specific language built on the low level programming language C. To resolve this function the component dynamic library uses the component stub library to translate the component library name in the domain specific language C to the intermediate adapter name sc event notify in the low level C programming language. The interlibrary adapter implements the sc event notify function by mapping the intermediate adapter name to sc event defaultNotify which is the corresponding simulation library name in the domain specific language C in the separate namespace of the simulation dynamic library . In the foregoing example an application programming interface API corresponding to the component library facing ABI is expressed in the C programming language and an API corresponding to the simulation library ABI is expressed in the C programming language.

In some embodiments the interlibrary adapter includes a mapping between component library names and simulation library names at a source code level which provides compatibility with an API of the simulation dynamic library . For example when a function s simulation library name changes in an updated version of the simulation dynamic library an older version of the component dynamic library refers to the function using an outdated component library name. To maintain compatibility the interlibrary adapter uses the mapping to determine the function s updated simulation library name. The interlibrary adapter uses the mapping at the API level to determine a mapping to the simulation dynamic library s simulation library ABI .

Prior to simulation run time the component library generator generates one or more component dynamic libraries . Generating a component dynamic library is described further in conjunction with .

Also prior to simulation run time the authoring tool generates netlist information . The netlist information includes component instance information e.g. the instance list and component library information e.g. the shared library list . The component instance information describes instances of the hardware component to be simulated. The component library information describes which component dynamic libraries correspond to the instances described in the instance information and hence which models of the hardware components are used in the system simulation . The component library information may include version specific library names e.g. vendor library name version VLNV . The netlist information may also include connectivity information e.g. the connectivity list describing connectivity between the instances of the hardware components.

Also prior to simulation run time the adapter generator compiles one or more interlibrary adapters based on determined mappings between the component library facing ABI corresponding to the component dynamic library and the simulation library ABI of the simulation dynamic library . For example the adapter generator may generate a mapping based on changes from a current API of the simulation dynamic library and a previous API of the simulation dynamic library when the component dynamic library was compiled. The component stub library reflects the previous API of the simulation dynamic library . Based on the changes between the current and previous APIs the adapter generator determines a mapping between the component library facing ABI which corresponds to the previous API of the simulation dynamic library and the simulation library ABI which corresponds to the current API of the simulation dynamic library . Accordingly the interlibrary adapter emulates a version of the simulation dynamic library on which the component dynamic library depends even though a different version of the simulation dynamic library may be present. In some instances the interlibrary adapter is compiled in conjunction one or more corresponding component dynamic libraries .

At simulation run time the simulation loader generates the simulation using dynamic loading based on the netlist information and the component dynamic libraries . For example the simulation loader coordinates loading of the component dynamic libraries and simulation dynamic library into memory of a computer. Continuing the example the simulation loader may allocate memory of the computer for the instances of the simulated hardware components and the connection between the instances. Generating the simulation is described further in conjunction with .

During simulation run time the system simulation is performed responsive to the simulation loader generating the system simulation . In one embodiment a computer that includes the dynamically loaded system simulation determines by a processor results of the system simulation in response to one or more inputs. For example the system simulation represents a target system having two multicore processors executing computer program code stored on a simulated memory. The computer performing the system simulation determines how efficiently the multicore processors execute instructions in parallel threads of the computer program code stored in the simulated memory. In one embodiment the computer performing the simulation selects dynamic libraries to unload from memory. For example the computer identifies a dynamic library used to generate the simulation at run time e.g. a dynamic library functionality used for configuration but not for performing the simulation . Responsive to determining that the identified dynamic library will not be used to perform the simulation the computer unloads the identified dynamic library to increase memory available to the computer running the simulation.

After the simulation is performed but prior to run time of another simulation the adapter generator may re generate the interlibrary adapter . The interlibrary adapter may be re generated in response to a different version of the simulation dynamic library being used. Re generating the interlibrary adapter is described further in conjunction with .

The component library generator obtains source files corresponding to hardware components modeled by a component dynamic library . The component library generator may also generate a component stub library which routes simulation dynamic library calls by the component dynamic library to the interlibrary adapter . In one embodiment the component stub library includes a mapping between component library names and interlibrary adapter names where the simulation library names refer to simulation library program constructs used by the source file. The component library names refer to component library names of simulation library program constructs used by the source file and hence by the component dynamic library . The component stub library references a component library facing ABI of the interlibrary adapter . Accordingly simulation dynamic library calls in the compiled component dynamic library reference the interlibrary adapter rather than the simulation dynamic library . Generating the component stub library may also include generating an interlibrary adapter as described with respect to .

Prior to generating the simulation at simulation run time the component library generator compiles the source files into component models referencing the interlibrary adapter through the component stub libraries which ensures the compatibility of the component models with an application binary interface of the simulation dynamic library . In one embodiment the component models are compiled object files representing a model of a hardware component in machine code. The component library generator generates the component models based on the obtained component stub library . For example the component library generator compiles the component models so that references to simulation library program constructs are resolved by the component stub library which in turn resolves the reference using the interlibrary adapter .

Also prior to generating the simulation at simulation run time the component library generator generates the component dynamic library by linking the compiled component models into a component dynamic library . The generated component dynamic library includes the linked and compiled component models the component creator registrar and the component stub library .

A first interlibrary adapter providing compatibility between component dynamic libraries and a first version of a simulation dynamic library is obtained. For example the interlibrary adapter is compiled for use in a first simulation involving the first simulation dynamic library . Subsequently a second version of the simulation dynamic library is obtained that has a second different simulation library ABI than the first simulation ABI of the first simulation dynamic library . Accordingly the component dynamic libraries that depend on the simulation dynamic library through the first interlibrary adapter are no longer compatible with the second version of the simulation dynamic library . For example the first version of the simulation dynamic library is designed to perform simulations quickly i.e. with fewer processing operations with a decrease in simulation accuracy and the second version of the simulation dynamic library is designed to perform simulation more accurately with an increase in simulation duration i.e. an increase in processing operations relative to the first version of the simulation dynamic library .

The adapter generator determines a mapping between a component library facing ABI of the interlibrary adapter and the second simulation library ABI . For example the mapping provides how to transform the calling convention used by the component library facing ABI to the calling convention used by the simulation library ABI . For example the calling convention indicates the order of input variables or identifies registers or memory locations storing input variables passed to the simulation library programming construct through a simulation library function call. The determined mapping maintains the same component library facing ABI of the initial interlibrary adapter as modifying the component library facing ABI would render the component dynamic library incompatible with the interlibrary adapter because the component stub library depends on the component library facing ABI of the interlibrary adapter .

The adapter generator recompiles the interlibrary adapter or generates a second version of the interlibrary adapter based on the determined mapping between the component library facing ABI of the interlibrary adapter and the second simulation library ABI . Accordingly the interlibrary adapter provides compatibility between the component dynamic library and the second version of the simulation dynamic library without recompiling the component dynamic library beneficially reducing waiting time for a user configuring a simulation. The interlibrary adapter beneficially enables the user to continue using a component dynamic library dependent on an initial version of a simulation dynamic library even after simulation dynamic library has been updated to a later version which would otherwise be incompatible with the component dynamic library without the interlibrary adapter .

At simulation run time the simulation loader loads the simulation dynamic library . The simulation dynamic library provides simulation functionality referenced by the component dynamic libraries . In other words the simulation dynamic library includes simulation library program constructs referenced by the component dynamic libraries .

At simulation run time the simulation loader begins generating the system simulation by accessing the netlist information which includes component library information e.g. the shared library list component instance information e.g. the instance list and connectivity information e.g. the connectivity list . The simulation loader may access the netlist information to begin generating the simulation in response to a command to perform the simulation. For example the command to perform the simulation is received from a user through a graphical user interface or a command line interface. As another example the command to perform the simulation is received from a test manager program that coordinates running multiple simulations under varied conditions.

The simulation loader loads the component dynamic libraries specified by the component library information. In one embodiment the simulation loader identifies un loaded component dynamic libraries from the shared library list that correspond to one or more instances from the instance list . The simulation loader then loads the identified component dynamic libraries . For example the simulation loader uses a loop that is complete when all component dynamic libraries from the shared library list have been loaded.

In one embodiment the simulation loader loads a component dynamic library by placing the component dynamic library into memory. For example the simulation loader requests that the operating system of the computer performing the system simulation load the component dynamic library into memory allocated to the system simulation . As a consequence of loading the component dynamic library the component creator registrar registers the component dynamic library s component creator with the creator registry . The component creator is adapted to create one or more instances of a hardware component from a component model of that hardware component. Registering the component creator places a reference to the component creator e.g. a memory pointer in a list of pairs in the creator registry . Each pair includes a reference to the component creator and a class name e.g. the Vendor Library Name Version identifier of the associated component dynamic library that includes the component creator . Since different versions of a component dynamic library have different VLNV identifiers the creator registry may contain multiple versions of a component dynamic library . For example a system simulation may include an older version and a newer version of the same hardware component to compare performance. If the component dynamic library is dependent on other embedded files then the component creator registrar embeds pointers to the embedded files in the component dynamic library s entry in the creator registry .

The simulation loader loads one or more interlibrary adapters corresponding to the simulation dynamic library . An interlibrary adapter provides compatibility between one or more component dynamic libraries and a simulation library application binary interface ABI of the simulation dynamic library . In one embodiment the interlibrary adapter includes a component library facing ABI and a mapping between the component library facing ABI and the simulation library application binary interface. The interlibrary adapter takes as input simulation dynamic library calls i.e. dependencies on the simulation dynamic library by a component dynamic library and returns the output of the simulation dynamic library in response to the simulation dynamic library call. For example the interlibrary adapter includes instructions to during simulation run time 1 receive input variables to a simulation function provided by the simulation dynamic library at input registers specified by the component library facing ABI 2 move the input variables from the input registers specified by the component library facing ABI to registers specified by the simulation library ABI 3 pass control to the simulation function provided by the simulation dynamic library 4 retrieve an output variable from the simulation function provided by the simulation dynamic library at an output register specified by the simulation library ABI 5 move the output variable from the output register specified by the simulation library ABI to an output register specified by the component library facing ABI and 6 return control to a function of the component dynamic library that initially called the simulation function provided by the simulation dynamic library .

The simulation loader instantiates instances of hardware components specified by the component instance information e.g. the instance list . In one embodiment the simulation loader identifies un instantiated instances from the instance list . The simulation loader then instantiates the identified instances. The simulation loader may loop over the instances of the instance list until all instances are loaded. The programmatic loop terminates when all instances from the instance list have been loaded.

In one embodiment the simulation loader instantiates an instance of a hardware component by identifying one or more creators from the creator registry that correspond to the instance. In one embodiment to identify the component creator the simulation loader identifies a pair from the creator registry that has a class name matching the class name of the associated component dynamic library that models the instantiated hardware component. From the identified pair the simulation loader retrieves the reference to the component creator e.g. the memory pointer to the component creator which may be used to retrieve the component creator corresponding to the instance. By invoking the component creator the simulation loader invokes instructions to instantiate the instance of the hardware component. For example instantiating an instance of a hardware component allocates memory for the instance. The amount of memory allocated for the instance and the structure of the allocated memory may depend at least in part of properties of the instance retrieved from the netlist .

In one embodiment as part of instantiating a component the component creator of an instance or the simulation loader may register the instance of the hardware component in the instance registry . For example the instance registry is a list of pairs where each pair includes a class name for the instance and a reference to the instance e.g. a memory pointer to the instance .

The simulation loader connects the instantiated instances of the hardware components in accordance with the connectivity information e.g. the connectivity list . In one embodiment the simulation loader identifies un instantiated connections between instances using the connectivity list . For example entries in the connectivity list specify two instances to connect the type of connection and ports of the instances to connect. As another example the simulation loader invokes a bind function between a source port on one instance and a destination port on another instance. Invoking the bind function instructs the simulation kernel to forward function calls from the source port to the destination port. The simulation loader then connects the instances based on the connectivity information. To connect the instantiated instances the simulation loader may loop over the connections of connectivity list . The loop terminates when all connections from the connectivity list have been instantiated. Once the instances have been connected the system simulation is fully generated and is ready for execution.

Dynamically loading the component dynamic libraries advantageously enables modification of a system simulation without completely recompiling all of its components as is the case for a statically linked system simulation. For example suppose an error is discovered in the component model of a component dynamic library . When substituting an updated version of the component dynamic library in place of the erroneous version of the component dynamic library the authoring tool modifies the reference to the affected component dynamic library in the netlist e.g. in the shared library list rather than relinking the entire simulation as in the case for a statically linked system simulation.

Specifically shows a diagrammatic representation of a machine in the example form of a computer system within which instructions e.g. software for causing the machine to perform any one or more of the methodologies discussed herein may be executed. In alternative embodiments the machine operates as a standalone device or may be connected e.g. networked to other machines. In a networked deployment the machine may operate in the capacity of a server machine or a client machine in a server client network environment or as a peer machine in a peer to peer or distributed network environment.

The machine may be a server computer a client computer a personal computer PC a tablet PC a set top box STB a personal digital assistant PDA a cellular telephone a smartphone a web appliance a network router switch or bridge or any machine capable of executing instructions sequential or otherwise that specify actions to be taken by that machine. Further while only a single machine is illustrated the term machine shall also be taken to include any collection of machines that individually or jointly execute instructions to perform any one or more of the methodologies discussed herein.

The example computer system includes one or more processors e.g. a central processing unit CPU a graphics processing unit GPU a digital signal processor DSP one or more application specific integrated circuits ASICs one or more radio frequency integrated circuits RFICs or any combination of these a main memory and a static memory which are configured to communicate with each other via a bus . The computer system may further include graphics display unit e.g. a plasma display panel PDP a liquid crystal display LCD a projector or a cathode ray tube CRT . The computer system may also include alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse a trackball a joystick a motion sensor or other pointing instrument a storage unit a signal generation device e.g. a speaker and a network interface device which also are configured to communicate via the bus .

The storage unit includes a non transitory machine readable medium also referred to herein as a computer readable medium on which is stored instructions e.g. software embodying any one or more of the methodologies or functions described herein. The instructions e.g. software may also reside completely or at least partially within the main memory or within the processor e.g. within a processor s cache memory during execution thereof by the computer system the main memory and the processor also constituting machine readable media. The computer system includes multiple processor cores that can be distributed across one or more of the processors . The instructions e.g. software may be transmitted or received over a network via the network interface device .

While machine readable medium is shown in an example embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database or associated caches and servers able to store instructions e.g. instructions . The term machine readable medium shall also be taken to include any medium that is capable of storing instructions e.g. instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies disclosed herein. The term machine readable medium includes but not be limited to data repositories in the form of solid state memories optical media and magnetic media. The term machine readable medium may also be referred to as a computer readable medium.

The disclosed embodiments beneficially improve the functioning of a computer executing the system simulation by reducing operations needed to modify a system simulation as described throughout the specification. For example the adapter generator modifies the interlibrary adapter in response to changes in the simulation dynamic library in order to avoid rebuilding the component dynamic libraries dependent on the simulation dynamic library . The dynamic loading procedure maintains separate namespaces for different dynamic libraries which enables multiple versions of a component dynamic library to coexist in a system simulation . Additionally the memory monitor beneficially reduces memory usage in the computer by identifying dynamic libraries that are unlikely to be used again in the simulation and unloading those dynamic libraries from the memory.

Throughout this specification plural instances may implement components operations or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations one or more of the individual operations may be performed concurrently and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements fall within the scope of the subject matter herein.

Certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code embodied on a machine readable medium or in a transmission signal or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. a standalone client or server computer system or one or more hardware modules of a computer system e.g. a processor or a group of processors may be configured by software e.g. an application or application portion as a hardware module that operates to perform certain operations as described herein. One or more steps of the processes or methods described herein e.g. that illustrated in are repeated concurrently by multiple threads. Thus one or more of the steps can be performed serially in parallel and or by a distributed system in accordance with various embodiments of the invention.

In various embodiments a hardware module may be implemented mechanically or electronically. For example a hardware module may comprise dedicated circuitry or logic that is permanently configured e.g. as a special purpose processor such as a field programmable gate array FPGA or an application specific integrated circuit ASIC to perform certain operations. A hardware module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

The various operations of example methods described herein may be performed at least partially by one or more processors e.g. processor that are temporarily configured e.g. by software or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments comprise processor implemented modules.

The one or more processors may also operate to support performance of the relevant operations in a cloud computing environment or as a software as a service SaaS . For example at least some of the operations may be performed by a group of computers as examples of machines including processors these operations being accessible via a network e.g. the Internet and via one or more appropriate interfaces e.g. application program interfaces .

The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the one or more processors or processor implemented modules may be located in a single geographic location e.g. within a home environment an office environment or a server farm . In other example embodiments the one or more processors or processor implemented modules may be distributed across a number of geographic locations.

Some portions of this specification are presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory e.g. a computer memory . These algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein an algorithm is a self consistent sequence of operations or similar processing leading to a desired result. In this context algorithms and operations involve physical manipulation of physical quantities. Typically but not necessarily such quantities may take the form of electrical magnetic or optical signals capable of being stored accessed transferred combined compared or otherwise manipulated by a machine. It is convenient at times principally for reasons of common usage to refer to such signals using words such as data content bits values elements symbols characters terms numbers numerals or the like. These words however are merely convenient labels and are to be associated with appropriate physical quantities.

Unless specifically stated otherwise discussions herein using words such as processing computing calculating determining presenting displaying or the like may refer to actions or processes of a machine e.g. a computer that manipulates or transforms data represented as physical e.g. electronic magnetic or optical quantities within one or more memories e.g. volatile memory non volatile memory or a combination thereof registers or other machine components that receive store transmit or display information.

As used herein any reference to one embodiment or an embodiment means that a particular element feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

As used herein the terms comprises comprising includes including has having or any other variation thereof are intended to cover a non exclusive inclusion. For example a process method article or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process method article or apparatus. Further unless expressly stated to the contrary or refers to an inclusive or and not to an exclusive or. For example a condition A or B is satisfied by any one of the following A is true or present and B is false or not present A is false or not present and B is true or present and both A and B are true or present .

In addition use of the a or an are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the invention. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.

Upon reading this disclosure those of skill in the art will appreciate still additional alternative structural and functional designs for dynamically loaded system simulations through the disclosed principles herein. Thus while particular embodiments and applications have been illustrated and described it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications changes and variations which will be apparent to those skilled in the art may be made in the arrangement operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims.

