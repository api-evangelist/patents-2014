---

title: System and method for grammar based test planning
abstract: The present disclosure generally relates to the testing of a system that includes software or hardware components. In some embodiments, a testing framework generates a set of test cases for a system under test using a grammar. Each test case may perform an action, such as provide an input to the system under test, and result in an output from the system under test. The inputs and outputs are then compared to the expected results to determine whether the system under test is performing correctly. Prior to generating the set of test cases from the grammar, the testing framework processes the grammar to identify attributes of the test cases to be derived from the grammar and facilitates the modification of the grammar.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09122671&OS=09122671&RS=09122671
owner: 
number: 09122671
owner_city: 
owner_country: 
publication_date: 20140410
---
This application is a continuation of U.S. patent application Ser. No. 13 941 378 entitled System and Method for Grammar Based Test Planning and filed Jul. 12 2013 which is a continuation of U.S. patent application Ser. No. 13 411 379 entitled System and Method for Grammar Based Test Planning and filed Mar. 2 2012 now U.S. Pat. No. 8 489 926 which is a continuation of U.S. patent application Ser. No. 12 395 235 entitled System and Method for Grammar Based Test Planning and filed Feb. 27 2009 now U.S. Pat. No. 8 132 053 which claims the benefit of U.S. Provisional Application No. 61 032 043 entitled System and Method for Grammar Based Test Planning and filed Feb. 27 2008 the entireties of which is incorporated herein by reference.

Generally described computing devices can be utilized in a variety of contexts such as for exchanging information facilitating communication between users facilitating the operation and control of a wide variety devices and processes and the like. In the context of a manufacturing or production environment a computing network made up of a number of computing devices including personal computing devices server computing devices programmable logic controllers PLCs and or other networked devices can be utilized in conjunction with a communication network such as the Internet to facilitate the operation and control of various devices processes. For example a networked PLC may be utilized to control the operation of physical manufacturing or processing equipment such as controllers for valves power supplies pumps machinery etc. Similarly a software application or suite of software applications may be hosted on a networked computing device such as a server or personal computing device to receive instructions regarding the operation of various equipment and transmit the appropriate respective instructions to the appropriate equipment such as through a PLC .

A fault in one or more networked computing devices such a fault in a computing device can lead to the failure of associated equipment loss of manufacturing production time property damage and the like. Accordingly manufacturing production computing networks including hardware and software aspects can be designed with redundant components to avoid fault conditions during execution in a manufacturing production environment. For example a PLC may include a fail safe mode such that in the event of a fault the outputs from the PLC mitigate potential damage to attached equipment or errant instructions that could cause additional faults damage.

Computing systems can be tested to verify that requirements for safety and redundancy are met and to discover errors in design implementation. For example a testing system can be implemented such as in a laboratory that attempts to emulate various commands instructions or other environmental information and then measure the response generated by the computing device s being tested. The emulated commands instructions or other environment information can be embodied as a test case or testing procedure that can be executed by a testing system.

One approach to the generation of test cases and or testing procedures for computing device testing involves the utilization of testing framework that is in communication solely with the device under test. This approach however can be inefficient in recreating many of the inputs and or operating environments associated with the device under test. For example in a system under test including multiple networked computing devices the testing framework would need to analyze inputs outputs from each computing device in the system under test in order to accurately test the system. For example a computing device in a system under test experiencing an error may still be generating an expected output coinciding with an output generated by the computing device entering a fail safe mode. However in such a fail safe mode the computing device would not be able to properly process inputs from a control computing device. Accordingly current testing approaches can become deficient in properly assessing system under test performance as a function of a testing environment.

The present disclosure generally relates to the automated testing of a system that includes software or hardware components referred to herein as the system under test or device under test . In some embodiments a testing framework generates a set of test cases for a system under test using a grammar. Each test case may perform an action such as provide an input to the system under test and result in an output from the system under test. The inputs and outputs are then compared to the expected results to determine whether the system under test is performing correctly. For example the testing framework can be used to monitor the digital inputs and or outputs of a programmable logic controller PLC and or determine whether the PLC is performing to its specified behavior. Specifically the PLC may be analyzed to determine whether it is capable of properly processing control instructions and input signals and or generating expected output control signals and additional control feedback information. The data can then be interpreted in the grammar system and or used as input to a fault isolation engine to determine anomalies in the system under test.

In an illustrative embodiment the set of test cases can be managed within the testing framework to facilitate more efficient testing of the device under test. In such an embodiment the testing framework can obtain an initial set of test cases that are defined in according to the grammar. The grammar can include one or more attributes or tags that correspond to different aspects of the set of test cases. Prior to deriving the set of test cases for the device under test the testing framework can analyze the grammar corresponding to the initial set of test cases to identify attributes of what would be the resulting set of tests cases. The analysis can include a determination of a number and kind of test cases that would be derived without requiring the actual generation of the initial set of test cases. The resulting analysis can be presented to a user associated with the testing framework such as via a graphical user interface. Based on the analysis the grammar corresponding to the grammar corresponding to the initial set of test cases can be modified such as by modifying one or more tags or attributes of the grammar. The resulting modified grammar can be used to generate a modified set of test cases. Alternatively the testing framework can repeat the analysis process again to facilitate additional modification of the grammar.

This disclosure generally relates to testing and testing frameworks. More specifically it relates to systems and or methods for providing a testing framework for a system under test. In some embodiments the testing framework can be used to assess the robustness of process control devices through the monitoring of outputs from one or more components in a testing environment that are typically considered inputs to a system under test. Additionally the testing framework can assess the robustness of process control devices through monitoring of outputs responsive to a testing sequence e.g. a series of test cases provided by the testing framework. The monitored outputs are generated by the system under test and collected by the testing framework.

In accordance with an illustrative embodiment the system can be tested using a framework that automatically generates test cases using context free grammars. The grammars describe a set of test cases that can be utilized by the testing framework to generate a set of inputs to a system under test or a device under test to verify that such system under test or device under meets requirements or to detect errors in the system under test or device under test. In contrast to testing frameworks in which a set of test cases must be generated and processed the testing framework can analyze an existing grammar to determine attributes or aspects of a set of test cases that would be derived from the grammar. Based on the result of the analysis a new grammar can be generated by controlling grammar attribute tags of the previous grammar. The modification of the attribute tags results in the selection creation of a subset of test cases generated by the previous version of the grammar or previous grammar. In an embodiment the new set of grammars is automatically modified by the testing framework by inserting tags otherwise modifying aspects in an original grammar. In other aspects the testing framework can facilitate a manual modification of the original grammar.

Once the set of test cases has been generated the testing framework can be used to assess specific vulnerabilities and security threats to control system devices and networks. The present disclosure may be particularly beneficial for systems such as process control and supervisory control and data acquisition SCADA systems that have traditionally used closed proprietary architectures. However one skilled in the relevant art will appreciate that the disclosed testing framework operating environment test cases and grammars are illustrative in nature and should not be construed as limiting. Additionally the present disclosure should not be construed to be applicable to any particular system under test or device under and that all disclosed embodiments are also illustrative in nature.

Embodiments of the disclosure will now be described with reference to the accompanying figures wherein like numerals refer to like elements throughout. The terminology used in the description presented herein is not intended to be interpreted in any limited or restrictive manner simply because it is being utilized in conjunction with a detailed description of certain specific embodiments of the invention. Furthermore embodiments of the invention may include several novel features no single one of which is solely responsible for its desirable attributes or which is essential to practicing the inventions herein described.

Client application may be an application running on a computing device that allows a user to select configuration and test procedures to run on system under test . In an embodiment where client application resides on a computer separate from testing framework client application may send data to testing framework that specifies the user selected configuration and test procedures to run. In one aspect client application can obtain results from the testing framework regarding analysis of a grammar prior to generation of a set of test cases derived from the grammar. Additionally after tests have been run on system under test client application can receive results from testing framework and generate reports based on the results. In an alternative embodiment the client application may be hosted as a network provided service.

Testing framework may be an application running on a computer server that generates and executes tests on system under test based on the configuration and test procedures selected by the user with client application . For example testing framework can include a web service component running on a computer server or distributed across one or more computers and operative to exchange information via an application programming interface API . When test results are received from system under test testing framework may refine a testing strategy and create a second set of tests that are broader or narrower than the original tests run on system under test .

System under test may comprise a computer program hardware device and or a combination of one or more hardware device s and computer program s . For example the system under test can include an operating system or software application. In another example the system under test may be a hardware device such as a programmable logic controller or supervisory control and data acquisition system. As previously discussed the system under test may be a combination of hardware or software components such as a computing device executing one or more computer programs. In some embodiments the system under test may be a database user interface computer network and embedded or industrial device. One skilled in the relevant art will appreciate that additional or alternative configurations of the system under test will be considered to be within the scope of the present disclosure. Additionally although the system under test is referred to as a computer system the system under test may correspond to a single computing device or computer program.

Grammar processing engine may receive results from tests run on system under test from test engine . The results may include an actual output from system under test that results from an input being applied to system under test . The actual output may be compared to an expected output to determine whether system under test operates as expected. Grammar processing engine can use the results to create a second new set of one or more grammars by modifying or inserting tags attributes or annotations into one or more grammars of the first original set of grammars according to different strategies. For example grammar processing engine may generate tag combinations that reveal faults. Further grammar processing engine can generate tags that reduce the total number of test cases generated by finding a smaller set of tags that reveal the already existing faults that have been exposed by the original set of grammars. Additionally grammar processing engine can perform a neighborhood search by for example generating grammars that create a new set of test cases near the original set of test cases.

The grammar framework may typically include a grammar with attributes. The grammar with attributes may describe a set of one or more test cases. Of note grammar framework may parse the grammar and generate a set of test cases that can be run on the system under test . Further grammar framework can then execute the test cases on system under test . As shown the results of the test cases can also be gathered by grammar framework from system under test to coordinate execution of the test cases.

As further illustrated monitoring subsystem receives results from executing the test cases on system under test . Monitoring subsystem can then use one or monitors to correlate results from the execution of test cases with for example the health or status of the system under test . This may be advantageous for understanding the effects of test cases on for example available memory processing resources network response time and other specific process functionality of system under test . Further monitoring subsystem allows the results of tests to be interpreted in a reliable repeatable and affordable manner. Monitor may use a variety of techniques to observe the environment or health of system under test during testing for example. As shown there may be one or more types of monitors. Additionally there can be one or more instances of each type of monitor in a test environment. Monitors may also correspond to external software or hardware components for observing the system or system under test .

In an exemplary embodiment monitor may receive output from system under test in real time for example. This may be particularly helpful where the system under test is a device controller. In this situation a device that is operated by system under test may exhibit normal behavior in response to an erroneous input from system under test often the result of the device entering a fail safe mode. As a result it may be improperly assumed that system under test is operating correctly as well. A monitor that examines the output of system under test such as step function would expose this flawed assumption and can therefore be particularly advantageous for ascertaining whether the system under test is actually functioning correctly. To determine whether the system under test is performing as expected for example monitor may compare the actual step function to an expected step function. A discrepancy between the step functions can indicate that a test case resulting from a grammar has exposed a fault of system under test .

Additionally monitor may be useful for determining network connectivity. For example monitor may determine whether system under test is connected to a network or in communication with a device such as a computer server running a component of testing framework . In this embodiment monitor may use internet control message protocol ICMP messages to determine whether the system under test is connected to the network. Alternatively monitor can use an open connectivity interface to ascertain whether system under test is communicating with other devices.

With reference now to the interconnection of inputs and outputs the exemplary components of the systems of will be described. However one skilled in the relevant art will appreciate that the interconnections shown in are illustrative in nature and are not to be construed as limiting. As illustrated in the client application includes a first output corresponding a control signal generated by the client application. In an illustrative embodiment the control signal corresponds to commands or other input generated by the client application for implementing a testing sequence. The commands can be in accordance with the OPC communication standard.

The client application also includes a primary output and secondary output for generating outputs to the system under test . As illustrated in the primary and secondary output signals pass through the testing framework . In this capacity the testing framework serves as a communication bridge and can modify the input signals.

With continued reference to the system under test also includes various outputs and which can be routed to the testing framework . For example output can correspond to a square wave output that can be monitored by the testing framework . Output can correspond to USB interfaces for debugging by the client application or other computing device. Output can also correspond to an RS232 data interface for serially communicating additional information regarding the system under test .

With reference now to a routine implemented by a testing framework for generating a set of test cases will be described. At block the testing framework obtains an identification of an initial set of test cases. In an illustrative embodiment the initial set of test cases is defined in accordance with various attributes or tags of a testing grammar. With tagged grammars a short grammar can describe a very large often infinite set of elements. The grammar tags can be set to selectively reduce the size of the grammar s language. In automated testing the grammars can be written so that each generated element is a test case. This approach has been effective for a variety of testing tasks. In an illustrative embodiment the grammar can comprise a list of rules. Each rule can be made up of terminals quoted strings and or non terminals variable names . A rule can comprise a non terminal followed by the symbol followed by a list of terminals and or non terminals. One non terminal can be designated the start non terminal. 

Even with the tags in place the number of test cases is often too large to generate. The generation tool may run for a long time fail to terminate and or terminate abnormally without a useful error message. There may be no efficient way to determine which grammar rules and or tags are causing the problem. The tester may be forced to perform trial and or error guessing which grammar rule and or tag is causing the problem and or what kind of change will solve it. Often the trials may run for a long time before producing a result making the process too time consuming for practical testing.

At block one or more test case attributes are determined according to the grammar associated with the initial set of test cases. In an embodiment each grammar may represent a set of objects defined by a step by step generation scheme called a derivation. A derivation begins with the start non terminal. In each step a non terminal N can be selected and or a rule R selected with N on the left hand side. N can be replaced with the list of terminals and or non terminals on the right hand side of R. A derivation can be complete when no more non terminals remain. Each list of terminals which can be derived from a grammar is called a string in the language defined by the grammar. Accordingly the one or more test case attributes can include an identification of a number of test cases that would be derived from the current testing grammar. Additionally the one more test case attributes can also include a grouping of test cases that would be derived from the current grammar. The groupings can be selected according to common subject matter values rules or other identifiers that allows the application of organization criteria to the set of test cases that would be derived from the current grammar. By way of example assume the testing framework is analyzing a grammar that can be derived into a set of test cases that generate data packets sent to the system under test . Additionally assume that the data packets can be characterized according to a specific communication protocol e.g. IPv4 vs. IPv6 . In accordance with block in the illustrative example the testing framework can analyze a grammar that would be derived to generate various test packets and organize the test cases according to the communication protocol of the resulting data packets.

In an illustrative embodiment the testing framework can obtain information from the testing grammar about a resulting set of test cases without requiring the generation and processing of the test cases. Illustratively the testing framework can analyze the testing grammar to determine a number of test cases that would be generated from the grammar and to further organize the test cases according to organization criteria. Specifically the testing framework can first search the testing grammar by traversing the language tree of the grammar to identify all terminal strings. Because the terminal strings in the grammar correspond to the test cases the testing framework can identify the number of test cases by identifying terminal strings within the testing grammar. Additionally by further analyzing the terminal strings to identify the same or similar terminal strings within a grammar the testing framework can further group the set of test cases to be generated. Accordingly with reference to the above example the testing framework can identify the number of test cases corresponding to each data packet communication protocol by analyzing and further processing the terminal strings with a grammar to identify for each communication protocol the number of test cases.

At decision block a test is conducted to determine whether the test cases should be modified. With reference to the previous example in an illustrative embodiment a user or system administrator may determine that the set of test cases may have too many test cases relating to a specific communication protocol. Accordingly the underlying grammar may be modified to increase the number of test cases as to other communication protocols or eliminate the number of test case for the specific communication protocol. In an illustrative embodiment the results of the analysis at block may be presented to a user via a graphical user interface. In other embodiments the results of the analysis may be processed automatically by the testing framework according to preconfigured criteria.

With reference now to an illustrate screen display for presenting the results of a grammar analysis will be described. In an illustrative embodiment the screen display can be generated as part of the client application . The screen display is illustratively organized as a hierarchical grouping of test cases corresponding to test cases that result in the generation of data packets to the system under test . Examples of hierarchical groupings include derivation trees and estimator trees. The top node of the hierarchy identifies that the test cases correspond to data packets and includes a total number of data packets resulting from the test cases e.g. 17003936. One skilled in the art will appreciate that the total number represent that the total number of leaf nodes that utilize node as a parent node. The screen display also includes a second level of the hierarchy that includes three nodes and corresponding to subsets of the top node . In this example node further defines data packets corresponding to a first communication protocol e.g. Ethernet IPv4 node further defines data packets corresponding to a second communication protocol e.g. Ethernet IPv6 and node further defines data packets corresponding to a third communication protocol e.g. Ethernet ARP. Nodes also identify the number of data packets in each node. Although only a two level hierarchy is display with regard to screen display one skilled in the relevant art will appreciate that any number of levels may be displayed. Additionally alternative display formats or views may also be incorporated.

In an illustrative embodiment the screen display can also present user controls for eliciting additional action based on the displayed analysis explained below with regard to block . As illustrated in the screen display can include a control for allowing a user initiate the manual modification of the grammar. For example a user can be allowed to select which nodes of the hierarchy are to be included or excluded from the set of test cases. The screen display can also include another control for initiating the set of test cases from the analyzed testing grammar. In alternative embodiments the screen display can incorporate additional functionality for further processing the analyzed testing grammar. For example nodes may be selectable display objects that are interpreted by the testing framework as modifications to the current testing grammar either by inclusion or exclusion.

Returning to if at decision block a determination is made to modify the set of test cases at block the current testing grammar is modified. In an illustrative embodiment grammars can be modified by the inclusion exclusion or modification of tags associated with the testing grammar. For example a tag or attribute may be applied to a grammar to limit the set of test cases that would otherwise be generated in accordance with the grammar. The modification of the current grammar may be accomplished via textual editing of the grammar tags manipulation of display objects corresponding to the grammar tags and the like. As discussed above the testing framework may also modify the current testing grammar automatically based on results of the analyzed grammar.

As illustrated in upon modification of the current testing grammar at block the routine returns to block . In an illustrative embodiment the testing grammar can be iteratively modified a number of times. As discussed above the modification can be achieved without the requirement of the generation and processing of the set of test cases for each iteration. Returning to decision block if a determination is made to not modify the set of test cases the routine terminates at block with the generation of the set of test cases.

While illustrative embodiments have been disclosed and discussed one skilled in the relevant art will appreciate that additional or alternative embodiments may be implemented within the spirit and scope of the present disclosure. Additionally although many embodiments have been indicated as illustrative one skilled in the relevant art will appreciate that the illustrative embodiments do not need to be combined or implemented together. As such some illustrative embodiments do not need to be utilized or implemented in accordance with the scope of variations to the present disclosure.

Conditional language such as among others can could might or may unless specifically stated otherwise or otherwise understood within the context as used is generally intended to convey that certain embodiments include while other embodiments do not include certain features elements and or steps. Thus such conditional language is not generally intended to imply that features elements and or steps are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding with or without user input or prompting whether these features elements and or steps are included or are to be performed in any particular embodiment.

Any process descriptions elements or blocks in the flow diagrams described herein and or depicted in the attached figures should be understood as potentially representing modules segments or portions of code which include one or more executable instructions for implementing specific logical functions or steps in the process. Alternate implementations are included within the scope of the embodiments described herein in which elements or functions may be deleted executed out of order from that shown or discussed including substantially concurrently or in reverse order depending on the functionality involved as would be understood by those skilled in the art. It will further be appreciated that the data and or components described above may be stored on a computer readable medium and loaded into memory of the computing device using a drive mechanism associated with a computer readable medium storing the computer executable components such as a CD ROM DVD ROM or network interface. Further the component and or data can be included in a single device or distributed in any manner. Accordingly general purpose computing devices may be configured to implement the processes algorithms and methodology of the present disclosure with the processing and or execution of the various data and or components described above. Alternatively some or all of the methods described herein may alternatively be embodied in specialized computer hardware. In addition the components referred to herein may be implemented in hardware software firmware or a combination thereof.

It should be emphasized that many variations and modifications may be made to the above described embodiments the elements of which are to be understood as being among other acceptable examples. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

