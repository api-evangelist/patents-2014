---

title: Live rollback for a computing environment
abstract: A first computing device is provided for rolling back a computing environment. The computing device includes processors configured to acquire a stream containing entries including snapshot entries, memory entries, and input/output entries wherein each entry includes information and is associated with a timestamp. The processors are further configured to receive a snapshot entry associated with a first timestamp, revert to a memory state using information provided in at least one memory entry associated with a timestamp after the first timestamp, and re-execute a previously executed process, wherein the re-execution of the process is started using the first timestamp, information from the received snapshot entry, and information for input/output operations corresponding to the input/output entries associated with timestamps after the first timestamp.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09639432&OS=09639432&RS=09639432
owner: Citrix Systems, Inc.
number: 09639432
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20141201
---
Modern computing systems are capable of running a large variety of software applications and platforms. Developers write these software applications in a programming language. For example developers can write an application using C C Objective C or Java. The developer can then compile the application into object code or machine code that the processor can directly execute.

While running the processor can interact with other components of the computer system. For example the processor may store data in system memory. The processor can access the computers system memory graphics memory cache memory or connected storage devices such as hard disks. Further the processor can interact with a variety of input output I O devices. For example a keyboard or mouse can provide user input a graphics monitor can display output from the application and a network interface can allow the application to send and receive data across the network.

An operating system such as Microsoft Windows Linux or Max OS X runs on the base hardware providing a platform for additional applications. A developer can write an application to run on a specific operating system. The application can make use of software libraries and functionality built into an operating system to provide access to the underlying hardware components.

Virtualization technologies have become widely used for sharing limited computer hardware resources. In a hardware virtualization environment sometimes also referred to as a platform virtualization environment one or more virtual machines can simulate a host computer with its own operating system. In particular software executed on these virtual machines can be separated from the underlying hardware resources. As a result multiple virtual machines running on a single host computer can each have its own operating system. For example a computer that is running Microsoft Windows operating system may host multiple virtual machines one virtual machine that simulates a computer running a Linux operating system based on which Linux based software can be executed a second virtual machine simulating a computer running a OS X on which OS X based software can be executed and additional virtual machines each running its own operating system.

Whether a processor is physical or virtual the processor can execute a computer program by following each instruction in the compiled software application. When an application is compiled the program is converted into a sequence of instructions readable by a specific type of processer. The process can execute an instruction cycle for each instruction by loading the instruction into the processor determining what action the instruction requires and taking that action. The processor can repeat this cycle for each instruction in the program until the application finishes running.

The instructions executed by the processor can directly affect other aspects of the computing environment. Instructions can write data to memory. Additionally program instructions can request data from other devices connected to the computer. For example these devices generically referred to as input output devices or I O devices can include a hard disk keyboard mouse or optical drive. The processor can write data to and read data from an I O device. I O devices can notify the processor that they have data for the processor. This notification is called an interrupt request IRQ . When the processor receives an IRQ from an I O device the processor can interrupt its current execution read the data from the device and continue its execution. Additionally a processor may write data to an I O device or initiate interaction with an I O device. Often the processor will request data from the I O device wait until the I O device finishes and then read the data from the I O device. Because interacting with an I O device can sometimes take much longer than other processor tasks modern processers can use direct memory access DMA . Using DMA a processor can initiate interaction with an I O device can continue executing other instructions while waiting for the I O device to respond and can handle the IRQ from the device informing the processor that the request is complete.

The order and result of processor instructions are deterministic. Using the same input data and the same instruction the same result will occur. This determinism can allow for predictable results when executing application instructions. I O data however is non deterministic. Reading from an I O device or the result of an IRQ will not always produce the same result as a previous read or IRQ. Because of their non deterministic nature I O operations are inherently unpredictable. This unpredictability can cause difficulty when trying to determine the processors exact execution history.

There are many practical uses for investigating the past operation and execution of a processor. For example developers often need to re run portions of software applications in order to find and fix bugs and errors in the application. Unfortunately the non deterministic nature of I O renders the ability to precisely replay the execution of an application impossible. Because the I O operations are non deterministic a developer cannot guarantee that running the same instructions with the same input and I O operations will produce the same error or result. Developers cannot guarantee the exact same execution path when rerunning an application even if the deterministic aspects of the execution remain constant. As a result debugging specific application failures or errors can be difficult and imprecise.

Reference will now be made in detail to the exemplary embodiments implemented according to the present disclosure the examples of which are illustrated in the accompanying drawings. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts.

The embodiments described herein provide technologies for replaying the execution of a computing environment from a previous state. These technologies allow for the re execution of a previously executed process in a deterministic and predictable manner. These technologies can operate in both virtual and non virtual computing environments. The techniques described herein can allow for the creation of a stream of memory processor and input output data in various formats and can use a stream of memory data processor state data and I O data to replay a system s execution from a previous point in time. The replay techniques described herein can eliminate the difficulty associated with debugging non deterministic computing environments. Further the techniques described herein can assist with performance analysis.

One or more client devices A F collectively as are devices that can acquire remote services from data center through various means. Client devices A F can communicate with data center either directly e.g. client device E or indirectly through a public network e.g. client devices A D or a private network e.g. client device F . In some embodiments a main office and a branch office can also include one or more client devices that are similar to client devices A F. Main office can be located for example in a principal place of business of a company. Branch office can be located for example remote to main office . In some embodiments the client devices of main office and branch office can also acquire remote services from data center through for example private network .

When client device communicates through public network or private network a communication link can be established. For example a communication link can be established by public network thereby providing a client device e.g. client devices A D access to data center . A communication link can also be established by private network thereby providing client device F main office and or branch office accesses to data center . While client devices A D are portrayed as a computer e.g. client devices A a laptop e.g. client device B a tablet e.g. client device C and a mobile smart phone e.g. client device D it is appreciated that client device could be any type of device e.g. such as a smartwatch that communicates packets to and from data center .

Public network and private network can be any type of network such as a wide area network WAN a local area network LAN or a metropolitan area network MAN . As an example a WAN can be the Internet or the World Wide Web and a LAN can be a corporate Intranet. Public network and private network can be a wired network a wireless network or a combination of both.

Data center can be a central repository either physical or virtual for the storage management and dissemination of data and information pertaining to a particular public or private entity. Data center can be used to house computer systems and associated components such as one or physical servers virtual servers and storage systems. Data center can include among other things one or more servers e.g. server a desktop delivery controller a virtual desktop applications and a backend system .

Server can be an entity represented by an IP address and can exist as a single entity or a member of a server farm. Server can be a physical server or a virtual server. In some embodiments server can include a hardware layer an operating system a communication subsystem and a hypervisor creating or managing one or more virtual machines. Server can provide one or more services to an endpoint. These services can include providing one or more applications to one or more endpoints e.g. client devices A F . For example one or more applications can include Windows or SAP based applications and computing resources. Via the communication subsystem server can communicate with other devices e.g. client devices through various types of networks e.g. private network and public network .

Desktop delivery controller can be a device that enables delivery of services such as virtual desktops to client devices e.g. client devices A F . Desktop delivery controller can provide functionality required to manage maintain and optimize all virtual desktop communications. In some embodiments desktop delivery controller can control manage maintain or optimize the provisioning of applications .

In some embodiments one or more virtual desktops can provide one or more applications . Virtual desktops can include hosted shared desktops allowing multiple users to access a single shared remote desktop services desktop virtual desktop infrastructure desktops allowing each user to have their own virtual machine streaming disk images a local virtual machine individual applications e.g. one or more applications or a combination thereof.

Backend system can be a single or multiple instances of computer networking hardware appliances or servers in a server farm or a bank of servers. Backend system can interface directly or indirectly with server . For example backend system can include Microsoft Active Directory which can provide a number of network services including lightweight directory access protocol LDAP directory services Kerberos based authentication domain name system DNS based naming and other network information and synchronization of directory updates amongst several servers. Backend system can also include among other things an Oracle backend server a SQL Server backend and or a dynamic host configuration protocol DHCP server. Backend system can provide data services or a combination of both to data center which can then provide that information via varying forms to client devices or branch office .

The system memory can include a tangible non transitory computer readable medium such as a flexible disk a hard disk a CD ROM compact disk read only memory MO magneto optical drive a DVD ROM digital versatile disk read only memory a DVD RAM digital versatile disk random access memory processor cache memory register or a semiconductor memory. System memory can be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by CPUs . System memory can be any type of random access memory RAM or any other available memory chip capable of operating as described herein. In the exemplary embodiment shown in CPUs can communicate with system memory via a system interface .

GPUs can be any type of specialized circuitry that can manipulate and alter memory e.g. graphic memory to provide and or accelerate the creation of images stored in a frame buffer e.g. frame buffer shown in for output to a display device e.g. display device . GPUs can have a highly parallel structure making them more effective than general purpose CPUs for algorithms where processing of large blocks of graphical data can be performed in parallel. Furthermore the functionality of GPUs can also be included in a chipset of in some other type of special purpose processing unit or co processor.

CPUs can connect to system memory and system interface . CPUs can execute programming instructions stored in the system memory operates on data stored in system memory and communicates with the GPUs through the system interface which bridges communication between the CPUs and GPUs . In some embodiments CPUs GPUs system interface or any combination thereof can be integrated into a single processing unit. GPUs can be capable of executing particular sets of instructions stored in system memory to manipulate graphical data store in system memory or graphic memory . For example GPUs can receive instructions transmitted by the CPUs and processes the instructions in order to render graphics data stored in the graphic memory . Graphic memory can be any memory space accessible by GPUs including local memory system memory on chip memories and hard disk. GPUs can enable displaying of graphical data stored in graphic memory on display device .

Client device can also include display device and an input output I O device e.g. a keyboard mouse or pointing device connected through an I O controller both of which communicate via system interface . It is appreciated that CPUs can also communicate with system memory and other devices in manners other than through system interface such as through serial communication manners or point to point communication manners. Similarly GPUs can also communicate with graphic memory and other devices in manners other than system interface . Furthermore I O device can also provide storage and or an installation medium for the client device .

As shown in GPUs can also communicate directly with graphic memory and display device . GPUs can communicate with CPUs and other devices through system interface . Graphic memory can also include a frame buffer . Frame buffer can be a graphic output device that drives a display device e.g. display device from a memory buffer of graphic memory containing a complete frame of graphical data. Frame buffer can store the final graphic frames which are to be displayed on display device .

As shown in client device can support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats a USB device a hard drive or any other device suitable for installing software and programs such as any client agent or portion thereof. Client device can further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to client agent . Optionally any of the installation devices could also be used as storage device .

Furthermore client device can include a network interface to interface to a LAN WAN MAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. Network interface can comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing client device to any type of network capable of communication and performing the operations described herein.

Virtualization environment can include a hardware layer that can include one or more physical disks e.g. storage one or more physical devices e.g. I O devices one or more physical processors e.g. CPU a system memory e.g. system memory and a graphic memory e.g. graphic memory . In some embodiments frame buffer can be stored within a memory element in graphic memory and can be executed by one or more of physical processors .

Physical disk can be either an internal or an external hard disk. Virtualization environment in some embodiments can communicate with an external hard disk that is included in the hardware layer as a physical disk . Physical devices in some embodiments can be any combination of devices included in virtualization environment and external devices that communicate with virtualization environment . Physical device can be any device such as a network interface card a video card an I O device such as a keyboard a mouse an input device speakers an optical drive a printer a scanner a display device e.g. a monitor a storage device e.g. storage a universal serial bus connection any device connected to virtualization environment any device communicating with virtualization environment or any other device that is desired. In some embodiments physical processors can be any processor and can include for example CPUs and GPUs .

System memory can include any type of memory that can store data programs firmwares or set of executable instructions. Programs firmwares or executable instructions stored in system memory can be executed by one or more physical processors of virtualization environment . Graphic memory can be any memory space accessible by the physical processors including local memory system memory on chip memories and hard disk. Physical processors can display certain graphics corresponding to graphical data stored in graphic memory on a display device of physical devices .

Virtualization environment can further include an operating system that can be stored in a memory element in system memory and executed by one or more of physical processors . Operating system can also be referred to as kernel. Moreover virtualization environment can include a hypervisor . Hypervisor can be a program executed by physical processors in virtualization environment to manage any number of virtual machines. Hypervisor can be referred to as a virtual machine monitor or platform virtualization software. In some embodiments hypervisor can be any combination of executable instructions and hardware that monitors virtual machines executing on a computing device. Hypervisor can be stored in a memory element in system memory .

Hypervisor in some embodiments can provide virtual resources to one or more virtual machines e.g. virtual machines A C. A virtual machine can be a fully virtualized virtual machine. A fully virtualized virtual machine can have a guest operating system to allow executing of its software. While running on a host computer a fully virtualized virtual machine is unaware that it is a virtual machine. A fully virtualized virtual machine is sometimes also referred as a Domain U or domU virtual machine e.g. virtual machine A . A domU virtual machine can be controlled by a control program of another virtual machine. The control program can also be referred to as a control operating system a control domain a Domain or dom. Thus the virtual machine that runs the control operating system can be referred to as a dom virtual machine e.g. virtual machines B C . In some embodiments a dom virtual machine can have direct access to host computer s hardware resources and thus the control program can be executed by the host computer s operating system. A dom virtual machine can have access to the host computer s hardware resources through a hypervisor that either runs directly on the host computer s hardware i.e. a bare metal hypervisor or runs within the host computer s operating system i.e. a hosted hypervisor . In some embodiments a virtual machine can also be a service domain virtual machine also referred as a Domain S or domS virtual machine not shown .

Hypervisor in some embodiments can provide virtual resources to guest operating systems domU A B and or control operating system dom in any manner such that hypervisor simulates any desirable operating systems e.g. Windows Linux Unix to execute on virtual machines A C. The system resources can include for example hardware layer and any other component included in virtualization environment . In these embodiments hypervisor may be used to emulate virtual hardware partition physical hardware virtualize physical hardware or execute virtual machines that provide access to computing environments. In some embodiments hypervisor can control processor scheduling and memory partitioning for virtual machines A C executing in virtualization environment .

In some embodiments hypervisor can create virtual machines A C in which guest operating systems A B or control operating system execute respectively. As an example hypervisor can load a virtual machine image to create a virtual machine . As another example hypervisor can execute guest operating systems A and B within virtual machines B and C respectively. Guest operating systems A B are further described in details below.

As shown in in some embodiments hypervisor of virtualization environment can be a host hypervisor or a hypervisor that executes within an operating system kernel executing on virtualization environment . As a host hypervisor hypervisor can execute within operating system . And virtual machines A C execute at a level above hypervisor . If hypervisor is a host hypervisor operating system can be referred to as a host operating system while the other operating systems e.g. operating systems A B can be referred to as guest operating systems. Guest operating systems A B can execute on virtual machines B C or domU virtual machines .

In some embodiments hypervisor of virtualization environment can be a bare metal hypervisor or a hypervisor that has direct access to all applications and processes executing in the host computing device e.g. client device all resources on the host computing device and all hardware on the host computing device e.g. the hardware layer shown in or communicating with the host computing device. While a host hypervisor accesses system resources through a host operating system e.g. operating system a bare metal hypervisor can directly access all system resources. For example if hypervisor is a bare metal hypervisor it can execute directly on one or more physical processors and can include program data stored in the system memory and graphic memory .

In a virtualization environment that employs a bare metal hypervisor configuration the host operating system can be executed by one or more virtual machines . Thus a user of the computing device can designate one or more virtual machines as the dom virtual machine e.g. virtual machine A . This dom virtual machine can imitate the host operating system by allowing a user to interact with the computing device in substantially the same manner that the user would interact with the computing device via host operating system .

In some embodiments virtualization environment can host or execute one or more virtual machines A C. As described above a virtual machine executing a control operating system can be referred to as a dom virtual machine and a guest virtual machine can be referred as a domU virtual machine. A virtual machine can be a set of executable instructions that when executed by physical processors imitate the operation of a physical computing device such that programs and processes can be executed on virtual machine in a manner similar to that on a physical computing device. It is appreciated that virtualization environment can host any number of virtual machines . In some embodiments each virtual machine can be provided such as by hypervisor with a unique virtual view of the physical hardware memory processor and other system resources available to that virtual machine . The unique virtual view can be based on for example virtual machine permissions application of a policy engine to one or more virtual machine identifiers the user accessing a virtual machine the applications executing on a virtual machine networks accessed by a virtual machine or any other desired criteria. In some embodiments each virtual machine can be provided with a substantially similar virtual view of the physical hardware memory processor and other system resources available to the virtual machines .

As shown in virtual machines A C can include one or more virtual disks A C collectively as . Virtual disks can correspond to for example one or more physical disks or a portion of a physical disk e.g. physical disks . As an example virtual disk A can be allocated a first portion of physical disks virtual disk B can be allocated a second portion of physical disks and virtual disk C can be allocated a third portion of physical disks . In some embodiments one or more of virtual disks A C can include disk partitions and a file system similar to those of a physical disk. For example virtual disk A can include a system disk which includes disk partitions and system files associated with virtual machine A. In some embodiments the system disk can be shared among virtual machines. For example virtual machines B and C can have the same or similar system disk.

The file systems of virtual disks A C can also include files and folders. For example virtual disk A can also include a user disk which can store user data such as user files and folders. The user data stored on a user disk is also referred to as persistent user data. In some embodiments the system disk and or the user disk of a virtual machine of a client device e.g. client device can be synchronized with the corresponding disks stored in a server e.g. server . The synchronization of system disk and or the user disk between the server and the client device can include for example updating the system disk to a newer version published by the server and providing backup of the user disk. The synchronization is further described in detail below. In some embodiments a virtual disk can also include a local disk. The local disk can store local data associated with a virtual machine e.g. virtual machine B . The local disk can also include persistent user data. In some embodiments the persistent user data stored on a local disk cannot be synchronized with a server.

A virtual disk e.g. virtual disks can be accessed modified updated or provisioned by a client device or a server. As an example as described above when the server publish a new version of the system disk the server can update the system disk by sending the differences between the new version and the current version to the client device. Moreover by using the system disk the server can enable desktop management and patching of the client device. Furthermore the client device can modify its user disk by writing new data to or modifying existing data stored on the user disk. In some embodiments a virtual disk can be stored as a virtual disk file having a format such as a VHD format VHDX format VMDK format qcow format qcow2 format virtual box virtual disk image VDI format and parallels virtual hard disk drive HDD format or a binary format. In some embodiments a virtual disk can include one or more sectors. A sector can include a number of bytes. For example a sector can have a size of bytes. Moreover in some embodiments one sector or a group of sector can form a block of the virtual disk.

In some embodiments virtualization environment can also include virtual apertures not shown in a virtual memory space which can be a virtual view of the virtual memory available to virtual machines . The virtual apertures can correspond to for example caches buffers physical memories such as system memory and graphic memory internal or external physical disks such as hard disk . As an example under the circumstances that applications running on virtual machine A do not require memory more than that is available in system memory the virtual apertures of virtual machine A can correspond to a portion of system memory . As another example under the circumstances that applications executed by virtual machine B requires memory more than that is available in system memory the virtual apertures of virtual machine B can correspond to one or more portions of system memory graphic memory or even one or more portions of physical disks . The virtual apertures can be generated provided and managed by hypervisor .

Virtual processors A C collectively as can be a virtualized view of one or more physical processors of virtualization environment . In some embodiments the virtualized view of the physical processors can be generated provided and managed by hypervisor . In some embodiments virtual processor can have substantially the same characteristics as those of physical processors . In some embodiments virtual processors can provide a modified view of the physical processors such that at least some of the characteristics of virtual processor are different from the characteristics of the corresponding physical processors . In some embodiments virtual processors can provide additional functionality or characteristics that are not available in the corresponding physical processors . For example virtual processors can provide additional registers for use by hypervisor or virtual machines .

In control operating system can execute at least one application for managing and configuring the guest operating systems domUs e.g. domU A and domU B executing on the virtual machines . In some embodiments control operating system can be referred to as control domain domain or dom . While shows that control operating system is included in virtual machine A control operating system can be executed within any control virtual machine or any dom virtual machine can be executed by hypervisor or can be executed by operating system executing hypervisor . Control operating system can execute an administrative application or program that can further display a user interface which administrators can use to access the functionality of each virtual machine and or to manage each virtual machine . In some embodiments the user interface generated by the administrative program can be used to terminate the execution of virtual machines allocate resources to virtual machines assign permissions to virtual machines or manage security credentials associated with virtual machines .

Moreover in some embodiments control operating system can start new virtual machines or terminate execution of virtual machines . Control operating system can also directly access hardware and or resources within the hardware layer . In some embodiments control operating system can interface with programs and applications executing within the context of a virtual machine . Control operating system can also interface with programs and applications executing on the computing device in virtualization environment that are outside of the context of a virtual machine .

Furthermore in some embodiments control operating system can also interact with one or more guest operating systems . Control operating system can communicate with guest operating systems through hypervisor . As an example guest operating systems can communicate with control operating system via a communication channel established by the hypervisor such as via a plurality of shared memory pages made available by the hypervisor . In some embodiments control operating system can also include a network back end driver not shown for communicating directly with networking hardware provided by virtualization environment . The network back end driver can process at least one virtual machine request from at least one guest operating system . Control operating system can also include a block back end driver for communicating with a storage element included in virtualization environment such as system memory and graphic memory . In some embodiments the block back end driver can read and write data from the storage element based upon at least one request received from a guest operating system .

Control operating system can also include a tools stack which can provide functionality for interacting with the hypervisor . Tools stack can include customized applications for providing improved management functionality to an administrator of a virtual machine farm. In some embodiments at least one of tools stack and control operating system can include a management application programming interface API that provides an interface for remotely configuring and controlling virtual machines running in virtualization environment .

As shown in in some embodiments guest operating systems can provide users of virtualization environment with access to resources within a computing environment. Such resources can include programs applications files executable instruction codes desktop environments computing environment or other resources made available to users of virtualization environment . In some embodiments the resource can be delivered to virtualization environment via a plurality of access methods including conventional direct installations in virtualization environment or delivery via a method for application streaming. The resource can also be delivered to virtualization environment via access methods such as delivery of output data generated by an execution of the resource on another computing device and communicated to virtualization environment via a presentation layer protocol delivery of output data generated by execution from a removable storage device connected to virtualization environment and delivery of output data generated by execution via a virtual machine executing in virtualization environment .

In some embodiments the computing environment can determine an omitted timestamp for an entry using other entries in the stream. In these embodiments an entry in stream that does not require an exact execution time but rather only requires that the entry maintain relative order with other entries in the stream can be inserted into the stream without a timestamp. In these embodiments when a computing environment reads an entry without a timestamp from the stream the computing environment can determine the timestamp using the timestamp of either previous or subsequent entries depending on the nature of the recorded entry. For example the exact time of an I O write can be ignored as long as the I O write occurs before the next I O read for the same device. In this example the timestamp for the entry recording the I O write can be omitted. When a computing environment acquires or reads the stream the computing environment can determine a timestamp for the I O write as where the timestamp occurs before the timestamp associated with the subsequent I O read. In this example each entry has a constructive timestamp even though the underlying stream can omit certain timestamps.

Stream can be stored in a memory e.g. system memory . The memory can include a tangible non transitory computer readable medium such as a flexible disk a hard disk a CD ROM compact disk read only memory a CD RW compact disk re writable memory MO magneto optical drive a DVD ROM digital versatile disk read only memory a DVD RAM digital versatile disk random access memory DVD RW digital versatile disk re writable memory a processor cache memory register or a semiconductor memory. Further the memory can be directly attached or can be accessible through a network e.g. a NAS network attached storage a SAN storage area network cloud or internet based storage or a memory attached to a remote computing device . It is appreciated that production of a stream can require that the stream is stored on at least a writeable medium while use of an existing stream requires that the stream is stored on at least a readable medium.

In some embodiments stream can be split into multiple streams stored on the same or different media. In these embodiments the stream can be split based on arbitrarily determined criteria e.g. the type of data the timestamp range the size of the stream . When using multiple streams the computing environment can read from all streams during the rollback and replay process. An example of the multiple streams embodiments is further described below with respect to .

Referring back to stream can contain memory data e.g. memory pages A D . Memory data can be the existing contents of a specific area of memory prior to the processor execution updating that area of memory. In some embodiments the stream includes memory pages to preserve the memory data. In some embodiments the stream includes the first update to a memory location after a snapshot. In these embodiments subsequent updates to the same memory location are not included in the stream until after an additional snapshot.

Stream can contain I O data. I O data can include data related to any I O transactions e.g. I O reads IRQs or DMA operations the processor handles. I O data can contain any information necessary to recreate the recorded I O transaction. For example an I O read entry can contain the device involved and the value returned from the device while a DMA operation can include information related to the initiation of the transfer and the IRQ result.

Stream can contain snapshot data . Snapshot data can record the processor state e.g. execution state . The processor state can include the values of the processor registers the values of the processor counters the execution location memory tables and or any other data that defines the then existing state of the processor. The snapshot can contain all information necessary to return execution state to a specific point during the prior execution of a process.

The elements of stream can be organized in multiple ways. In some embodiments the entries in the stream can be stored chronologically and the rollback process can scan each entry of stream to determine the type of the entry. In some embodiments a snapshot e.g. snapshot C can include a reference to the previous snapshot e.g. snapshot B and or a previous memory entry e.g. memory page C . A memory entry e.g. memory page C can include a reference to a previous memory entry e.g. memory page B and or previous snapshot e.g. snapshot B . For example snapshot C can include a reference to the location in the stream of snapshot B. Further for example snapshot C can reference memory page C memory page C can reference memory page B and memory page B can reference snapshot B to create a linked list of all memory pages between snapshot C and snapshot B providing a mechanism for traversing the snapshots and memory pages in the stream. In some embodiments each entry can contain a reference to the previous entry or the previous entry of the same type. By using these references these embodiments can create linked lists allowing for efficient traversal of the relevant stream entries during a rollback process.

Execution state represents the current execution state of the computing environment. Execution state can contain a last entry reference to the most recent stream entry e.g. snapshot C and a memory state reference to the current memory state . Execution state can include aspects of the processor state necessary to execute instructions for the running process. For example execution state can include the current values of the various CPU registers. When the processor begins executing the results of the executed instructions can update the execution state. The execution state can represent the processor state of both a physical CPU and a virtual CPU. In some embodiments execution state can contain information on a subset of the processer state but that subset of information can be sufficient to execute the running process.

As shown in execution state can contain a last entry reference to the most recent snapshot or memory entry in the stream e.g. snapshot C and a rollback snapshot reference to the chosen snapshot e.g. snapshot B . Beginning with snapshot C the rollback process can follow the backwards references contained in the stream entries. Snapshot C can reference memory page C. When memory page C is reached by the rollback process the memory page can be loaded into current memory state . The rollback process can than follow the backward reference of memory page C to memory page B. The rollback process can load memory page B into the current memory state and continue following the backwards references to B. Because snapshot B is the desired snapshot the rollback process can stop following further references. In some embodiments the rollback process will continue across multiple instances of memory pages and snapshots before reaching the desired snapshot. By loading each recorded memory page between the initial memory state and snapshot B the rollback process can replace the values of memory state with the values stored in the stream. This process results in memory reversion . Memory reversion represents the reversion of memory state into previous memory state . Memory state can then represent the memory state as it existed at the time of snapshot B. It is appreciated that one of ordinary skill would recognize additional embodiments for locating memory entries in the stream. These additional embodiments are consistent with the present disclosure of reverting a current memory state e.g. memory state to a previous memory state e.g. previous memory state based on the memory data stored in a stream e.g. stream .

In some embodiments the execution state can be reverted to the values in snapshot B before the memory is reverted to previous memory state . In some embodiments the memory reversion to previous memory state can precede the reversion of execution state to the values in snapshot B. After the memory and execution state reversion the execution cycle can be restarted. As the running process executes the computing environment can intercept all I O requests made by the executing process and can replace the resulting events with the I O data recorded in stream . The computing environment can monitor the timestamp associated with the running process and the timestamps of the I O events in stream . When a timestamp of an I O event e.g. events B and C in stream is reached by the executing process the computing environment can provide the associated I O event from the stream.

As the running process executes the timestamp of execution state can progress forward from the original timestamp of snapshot B reaching the I O events stored in stream . For example when the timestamp of execution state reaches the timestamp of I O event B the computing environment can read I O event B from the stream and provide it to the executing processor e.g. execution state . The processor can continue to execute instructions and when the timestamp of execution state reaches the timestamp of IRQ the computing environment can provide IRQ from stream to the executing process. This cycle can continue providing all I O events e.g. events B and C stored in stream to the executing process at the exact point the events originally occurred. The process can continue to run until interrupted e.g. by the user or a program error or until all I O events in stream have been provided to the executing process. By providing a deterministic replay of the entire execution history the computing environment can allow for a deterministic replay of past processor execution. This ability can have a variety of applications. For example a user can replay the past process execution to investigate a bug in the process or a user can monitor the past process execution to monitor the performance of various instructions or operations.

Hypervisor can include a repeating timer. When the timer finishes hypervisor can create a snapshot and timestamp A in stream A resulting in snapshots created at regular intervals. When a snapshot is created hypervisor can further mark all memory as copy on write or read only. After the snapshot is created when virtual machine attempts to write to memory a copy on write or read only exception can occur. Hypervisor can capture this exception copy the affected memory data and the current timestamp B into stream B and mark the memory location as read write to prevent further interruption. This process can allow the computing environment to efficiently create a stream that does not contain duplicate memory pages or memory entries between snapshots. In some embodiments hypervisor can record all memory writes to the stream and not mark memory as read only or copy on write.

Any time virtual machine makes an I O request hypervisor can monitor the request create an I O data and timestamp C entry in stream Cd. When an I O device triggers an IRQ hypervisor can intercept the IRQ create an IRQ and timestamp C entry in stream C and forward the IRQ to virtual machine . Through this process hypervisor can create streams categorized by type but still temporally organized according to timestamps . In some embodiments the snapshot data memory data I O data and IRQ data may also contain references to the previous entry in the stream to assist with later traversal of the stream.

In the exemplary embodiments because all memory changes are recorded after each snapshot stream B can contain memory data for the same memory location updated after each snapshot was created. But during a rollback the hypervisor only needs to load a particular memory location s data stored most recently after the desired snapshot. Subsequent entries for that memory location can become superfluous because they can be restored and then overwritten during rollback towards the desired snapshot. In some embodiments snapshot entries can be created at varied temporal periods. For example in these embodiments some snapshots may be taken every second while other snapshots are taken every 100 milliseconds. In these embodiments each set of snapshots can reference the memory pages associated with the first changes to a specific memory location during that specific temporal period. Accordingly in these embodiments the less frequent snapshots can contain fewer memory data entries for the same location over the same amount of time as the more frequent snapshots. Using these separate temporal periods for snapshots hypervisor can create a hierarchy that allows traversing snapshots and memory data more efficiently. When rolling back the memory state in these embodiments hypervisor can use the less frequent snapshot references to traverse larger periods of time resulting in loading fewer memory data entries and can then switch to the more frequent snapshots when nearing the desired snapshot. In these embodiments the hybrid use of snapshot periods can balance the efficiency of the rollback operation with the usefulness of storing snapshots more frequently.

If the computing environment detects a timer expiration step the computing environment gathers step snapshot data. Snapshot data e.g. snapshot data can be any data necessary to allow the computing environment processor virtual processor or other system component to execute the running process. For example snapshot data can include all of the current register values memory pointers and or reference counters. After gathering the snapshot data the computing environment can mark step all memory as copy on write or read only. Marking all memory as either copy on write or read only will allow the computing environment to capture memory changes in other branches of the method. After marking all memory the computing environment can write the snapshot data and the generated timestamp to a stream e.g. stream and or stream A . After writing the data to the stream the computing environment can continue to wait step for additional events.

If instead of a timer expiration the computer environment detects step a memory exception e.g. a read only memory exception or a copy on write memory exception the computing environment can write step the existing memory data and previously generated timestamp to a stream e.g. stream and or stream B . After adding to the stream the computing environment can retrieve step the new memory data from the exception. The computing environment can mark step the affected memory location as read write and can update step the affected memory area with the memory value from the exception. This process allows the computing environment to capture all attempts to update memory record those attempts and ensure future attempts to update that memory area do not generate additional memory exceptions. After updating the affected memory area the computing environment can continue waiting step for additional events.

In some embodiments instead of marking all memory as read only step the computing environment can mark a subset of the memory as read only over the course of multiple snapshots. In these embodiments the computing environment can choose a period of time over which all memory can be marked as read only. In these embodiments during each snapshot within that time a non overlapping subset of the memory can be marked as read only such that after the time period is over all memory locations can be marked as read only at least one time during the time period. Accordingly in these embodiments the resources for processing the memory changes can be amortized over a group of snapshots instead of each snapshot.

If the computing environment detects neither a timer expiration step nor a memory exception step an I O operation has occured. The computing environment can write step the I O operation data and the previously generated timestamp to a stream e.g. stream and or C . After recording the I O event information the computing environment can continue to wait step for additional event data.

The computing environment can follow this process until interrupted. Each event that is handled by the computing environment can add to the stream and can be used during a later rollback process. It is appreciated that each branch path in the method can write to the same stream or different streams depending on the embodiment. It is also appreciated that some of the steps performed in a different order will nevertheless lead to the same result.

After the stream or streams are acquired a desired snapshot is chosen step . The choice of snapshot can be determined arbitrarily or systematically. In some embodiments a user will choose the snapshot to use. In some embodiments an algorithm can analyze the environment and choose a snapshot. For example if a computing environment experiences a catastrophic error the user or system might choose the most recent snapshot.

After choosing a snapshot the computing environment can revert step the current memory state of the computing environment to the state that existed at the time of the snapshot. The system can gather all memory data in the stream having a timestamp after the desired snapshot and revert those areas of memory to the values stored in the stream. In some embodiments the reversion can be accomplished by following backwards references in the stream between each memory page. After replacing the current memory values with those values updated following creation of the snapshot the memory state can reflect the exact memory state at the time of the chosen snapshot.

After the memory state has been reverted the computing environment can restart the processor execution at the time of the snapshot. The computing environment can load the snapshot data from the stream and replace the values in the current processor state with the snapshot values. In some embodiments the values replaced can be the values of all processor registers existing in the snapshot data. By loading the processor state stored in the snapshot the computing environment can effectively put the processer in the exact state that existed at the time of the snapshot. Combined with the memory reversion the processor can then start executing instructions. Because both the memory and processor state can be reverted the processor can begin executing from the snapshot point in exactly the same manner as the processer originally executed from that same moment in time. In some embodiments one of the processor registers will be the retired instruction counter for the guest operating system. This register which measures the number of instructions that have been run by the guest operating system can be stored in the snapshot. In these embodiments when the snapshot is loaded from the stream the value of the retired instruction count register is replaced by the value in the snapshot. In these embodiments as the guest processor finishes executing instructions this value is incremented in exactly the same manner as in the original execution of the running process.

As the processor executes instructions and interacts with memory the computing environment can monitor the processor timestamp and execute step any I O events recorded in the stream when the processor timestamp matches the timestamp recorded in the stream. When the processor timestamp value matches the timestamp of an I O event in the stream that I O event is executed on the processor. The I O event typically the non deterministic aspect of the execution pipeline can be executed in a predictable and deterministic manner.

After all I O data is executed the computing environment can stop step execution. In some embodiments if rerunning the execution of the process results in a system error the process may exit before all entries in the stream are used. It is further appreciated that the method could be interrupted at any step by the user or some other event and restarted using a different snapshot and the same or different stream. Additionally it is appreciated that the process may be fully repeated a plurality of times using different or the same streams and using the same or different snapshots.

In the foregoing specification embodiments have been described with reference to numerous specific details that can vary from implementation to implementation. Certain adaptations and modifications of the described embodiments can be made. Other embodiments can be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only. It is also intended that the sequence of steps shown in figures are only for illustrative purposes and are not intended to be limited to any particular sequence of steps. As such those skilled in the art can appreciate that these steps can be performed in a different order while implementing the same method.

