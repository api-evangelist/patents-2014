---

title: Compression using index bits in MSAA
abstract: A palette compressed representation may be stored in the index bits, when that is possible. The savings are considerable in some embodiments. In uncompressed mode, the data uses 2304 (2048+256) bits, and in compressed mode, the data uses 1280 bits. However, with this technique, the data only uses the index bits, (e.g. 256 bits) with a 5:1 compression improvement over the already compressed representation, and with respect to the uncompressed representation it is a 9:1 compression ratio.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09466124&OS=09466124&RS=09466124
owner: Intel Corporation
number: 09466124
owner_city: Santa Clara
owner_country: US
publication_date: 20141110
---
Multi sampling anti aliasing MSAA improves the visual quality of the images rendered using a graphics processor. In MSAA multiple visibility samples color and depth samples are used per pixel. However during the rendering of a triangle the pixel shader is only executed once per pixel. A common use case is 4 MSAA where there are four times as many samples per pixel compared to the usual case of one sample per pixel. The color buffer bandwidth may increase by a factor of N for N MSAA in a na ve setting. Therefore the MSAA color buffers are compressed.

One way to compress MSAA color buffers is to split the colors into N different planes for N MSAA and always fill plane first and continue with the other planes after that. Each pixel also needs log 2 N bits called index bits to point to a color in the N different planes. For example with 4 MSAA each sample needs 2 index bits to point to a color being located in one of the 4 planes. For a tile of 8 4 pixels with 4 samples per pixel and two bits per sample 256 index bits 2 4 8 4 are needed.

If a pixel is completely inside the triangle being rendered then all samples will get the same color and the index bits will then be all zeroes because they will all point to color plane for all samples and nothing will be stored in the remaining planes. In many cases only plane will be used and the remaining planes will be used more and more depending on the complexity of the geometry being rendered into a tile e.g. 8 4 pixels .

If a color plane is empty for a certain tile then there is no need to write that content to memory on a cache evict and there is no need to read it either when the color content for a tile is requested. Hence this is a type of compression. However one can also apply compression to the color planes when they are evicted from the color cache.

For each tile a small number of bits e.g. 4 are stored to indicate which state the tile is in. These bits can be used to indicate that the tile is cleared or that plane is compressed while plane is not etc. For one render target all these bits are called the control surface.

Assume an 8 4 tile of pixels with 4 samples per pixel and that first a blue triangle is rendered covering the entire tile. Then a green triangle is rendered and it cuts through the tile so that one third of the tile is green and the rest is blue. With the MSAA approach above two color planes would be needed because some pixels will contain at least one green sample and at least one blue sample. For an 8 4 tile with 4 MSAA the number of index bits sum to 256 bits 2 bits per sample times 4 samples per pixel times 8 4 pixels and one plane stores 1024 bits for RGBA8 32 bits per RGBA pixel times 8 4 . Two planes take 2048 bits of storage. With 50 compression the compressed version would use 1024 bits for both planes i.e. the total cost is 1280 1024 256 bits.

Assume a certain compression algorithm such as a delta compression method where the smallest color value is stored per tile and the difference against the smallest color is encoded using as few bits as possible per channel. Such a method may be combined with a palette based method so that for each tile compressing with both these methods is attempted followed by picking the one that compresses to the smallest usable size. This makes it possible to efficiently handle tiles with a few colors e.g. 8 whose values are widely different. However simple cases such as the one above will still use 1280 bits. A palette based compression method stores say M colors called a palette and then each sample stores ceil log M bits that are used to point to one of the colors in the palette. A palette based compression method is better at handling widely different colors than a delta compression method because the colors in the palette can take on any value. A delta based compression method usually stores a base color and then stores differences in relation to the base color. However this means that the differences must be small which in turns indicates that all the colors in the tile must be rather similar. This is the reason why delta based and palette based compression methods are good to combine.

Referring to a depiction of a color buffer according to one embodiment includes a control surface index bits and in this case 4 planes plane plane plane and plane identified as and respectively.

The control surface s bits may be used in a special mode to indicate that none of the planes are used and that a compressed color representation resides inside the index bits of the tile. A compressed color representation for the tile is stored in the tile s index bits and this is marked in the control surface bits for the tile.

Then only the 256 index bits in addition to the control surface bits need to be accessed in the case of 4 MSAA. Assume that 4 bits per tile are used for the control surface and if these bits are 1111 all ones then the tile is in this special mode in one embodiment. In the bits may be used for the special mode.

With 4 MSAA and R8G8B8A8 format two 32 bit colors are stored which sums to 64 bits and there are 128 index bits that is 1 bit per sample for 8 4 pixels each with 4 samples per pixel. This sums to 192 bits. This 2 color palette may be stored in the index bits 256 bits per tile and so 192 fits so that cases such as the green blue tile described above may be handled and a significant amount of memory traffic is saved.

In general there are M colors in the palette and each sample needs to be able to point to any of the M colors. Each sample needs M combinations. If M is a power of 2 then each sample needs log M bits for its combinations.

A palette compressed representation may be stored in the index bits when that is possible. The savings are considerable in some embodiments. In uncompressed mode the data uses 2304 2048 256 bits and in compressed mode the data uses 1280 bits. However with this technique the data only uses the index bits e.g. 256 bits with a 5 1 compression improvement over the already compressed representation and with respect to the uncompressed representation it is a 9 1 compression ratio.

Another variant called method B first uses three bits per pixel to indicate the following situations 

The simple pixels pointing to only one color correspond to combinations 000 001 and 010. The medium pixels pointing to two colors correspond to bit combinations 011 100 and 101 while bit combination 110 is called a complex pixel because it points to three colors.

Then 96 32 3 bits are stored for the three colors for the palette and then three bits per pixel 3 32 96 bits are stored as well. This leaves 64 256 96 2 remaining bits.

The simple pixels do not require any more storage but the medium and complex ones do. The medium pixels require one bit per sample which in this example amounts to 4 bits per medium pixel. If no complex pixels are required then 16 64 4 medium pixels can be stored. Given that there are 32 pixels in the tile this is quite a lot.

A complex pixel needs to be able to point to three different colors. The 64 unused bits may be spent on the medium and complex pixels and if these bits are sufficient for the current tile the compression succeeds and otherwise it fails and then some other compression method is used or the data may be sent uncompressed. So with 4 MSAA a pixel has 4 samples and each sample needs three combinations. Hence one can store 2 bits per sample for the complex pixels. A complex pixel would then need an extra 2 4 8 bits. However since each sample just needs 3 combinations this is actually a bit of waste. A more compact way to store these bits per pixel is described next. The number of combinations needed is 3 3 3 3 81 and hence it suffices with 7 bits instead of 8 bits i.e. each sample needs three combinations to point into the palette.

In one embodiment 64 bits may be used to store medium and complex pixels. If that number of bits is insufficient for the current tile then compression succeeds. If not compression fails and another technique is used or the data may be sent uncompressed.

Alternatively color 2 in the table above can be the clear color and in that case color 2 does not have to be stored which saves 32 bits and these saved bits can be used to store more medium and complex pixels.

In accordance with another embodiment for 8 MSAA for a tile size of 8 4 pixels there are 3 index bits per sample and 8 4 24 768 bits for all index bits for a tile. So for 8 MSAA with 4 bits per pixel to indicate status sums to 4 8 4 128 bits. A 6 color palette costs 6 32 192 bits. The four bits per pixel can be chosen in any way as long as one combination is left for the case where the samples in the pixel can point to all colors in the palette.

So where the palette has 2colors and each sample uses n palette index bits to point into the palette the number of palette index bits for all samples in the tile is less than or equal to the sum of the index bits of the tile.

Another example is to use an 8 color palette for 8 MSAA and still use 4 status bits per pixel with the same table above except that the last complex pixel is changed to 1111 complex pixel where each sample in a complex pixel stores 3 palette index bits. Then the palette has 2 8 colors but each sample uses less than n palette index bits to point into the palette.

In accordance with one embodiment a sequence shown in may be implemented in software firmware and or hardware. In software and firmware embodiments it may be implemented by computer executed instructions stored in one or more non transitory computer readable media such as magnetic optical or semiconductor storage. In one embodiment the storage may be part of a graphics processor.

The sequence begins by selecting a tile for eviction from the color buffer cache as indicated in block . The index bits are investigated to see how many planes are used as indicated in block . Then a check at diamond determines if all the planes are in the cache.

If so the tile is attempted to be compressed using a palette of three colors as one example as indicated in block . Then a check at diamond determines whether the desired bit budget is met by the attempted compression. If so an indication of the successful compression within the budget is stored in the control surface as indicated in block . Then the compressed representation is stored in the index bits as indicated in block . Finally the corresponding cache lines are marked block as evicted. The evicted bits can be used for anything now. However nothing is written back to memory because the compression representation is in the index bits.

If however all planes are already in the cache then another compression method must be used as indicated in block .

If the bit budget is not met as determined in diamond then one can proceed at step 2 in the alternate compression method described next block .

1. A cache line in the color buffer cache is selected for eviction possibly more than one cache lines may be selected for eviction i.e. both the cache line storing the left 4 4 pixels and the right 4 4 pixels in an 8 4 tile.

2. The 8 4 color plane is attempted to be compressed using some algorithm including the palette based compression method s presented above.

3. If a palette based compression method succeeds then this is indicated in the control surface bits of the tile and the compressed representation is stored in the index bits. Else if another compression methods succeeds then the data is sent in compressed form over the bus. This is indicated in the control surface bits of the tile.

4. Otherwise it is sent in uncompressed form. This is also indicated in the control surface bits of the tile.

1. First check the control bits if the tile is marked as using a palette compressed representation in the index bits block . If yes do not read anything from memory simply decompress the data using the index bits and populate the color cache.

The example above was given with respect to 4 MSAA i.e. four samples per pixel. However it is straightforward to extend to other rates as well e.g. 8 MSAA 16 MSAA etc. and even CSAA like schemes.

For example with 8 MSAA each sample stores 3 index bits and each pixel stores 24 3 8 index bits. With 8 4 tiles this amounts to 768 bits. Then 128 32 4 bits are used for 4 colors with 32 bits each. There are 256 8 8 4 samples in one tile. Then 2 bits per sample are stored 256 2 512 and 512 128 640 bits. So in this case one can easily store a 4 color palette. Method B can also be augmented to 8 MSAA in which case a 6 color palette may be possible in the same way that a 3 color palette was possible in method B for 4 MSAA.

Tiles that are relatively simple can be compressed with a very small number of bits and this scheme can trigger a lot in user interfaces for example. Saving memory traffic is extremely important.

The color cache may be between the renderer and the compressor decompressors and in which case the data is decompressed before it gets inserted into the cache for example or the cache indicated in dashed lines between the compressor decompressors and the memory and in this case the data is stored in compressed form in the cache.

An embodiment of the data processing system can include or be incorporated within a server based gaming platform a game console including a game and media console a mobile gaming console a handheld game console or an online game console. In one embodiment the data processing system is a mobile phone smart phone tablet computing device or mobile Internet device. The data processing system can also include couple with or be integrated within a wearable device such as a smart watch wearable device smart eyewear device augmented reality device or virtual reality device. In one embodiment the data processing system is a television or set top box device having one or more processors and a graphical interface generated by one or more graphics processors .

The one or more processors each include one or more processor cores to process instructions which when executed perform operations for system and user software. In one embodiment each of the one or more processor cores is configured to process a specific instruction set . The instruction set may facilitate complex instruction set computing CISC reduced instruction set computing RISC or computing via a very long instruction word VLIW . Multiple processor cores may each process a different instruction set which may include instructions to facilitate the emulation of other instruction sets. A processor core may also include other processing devices such a digital signal processor DSP .

In one embodiment the processor includes cache memory . Depending on the architecture the processor can have a single internal cache or multiple levels of internal cache. In one embodiment the cache memory is shared among various components of the processor . In one embodiment the processor also uses an external cache e.g. a Level 3 L3 cache or last level cache LLC not shown which may be shared among the processor cores using known cache coherency techniques. A register file is additionally included in the processor which may include different types of registers for storing different types of data e.g. integer registers floating point registers status registers and an instruction pointer register . Some registers may be general purpose registers while other registers may be specific to the design of the processor .

The processor is coupled to a processor bus to transmit data signals between the processor and other components in the system . The system uses an exemplary hub system architecture including a memory controller hub and an input output I O controller hub . The memory controller hub facilitates communication between a memory device and other components of the system while the I O controller hub ICH provides connections to I O devices via a local I O bus.

The memory device can be a dynamic random access memory DRAM device a static random access memory SRAM device flash memory device or some other memory device having suitable performance to serve as process memory. The memory can store data and instructions for use when the processor executes a process. The memory controller hub also couples with an optional external graphics processor which may communicate with the one or more graphics processors in the processors to perform graphics and media operations.

The ICH enables peripherals to connect to the memory and processor via a high speed I O bus. The I O peripherals include an audio controller a firmware interface a wireless transceiver e.g. Wi Fi Bluetooth a data storage device e.g. hard disk drive flash memory etc. and a legacy I O controller for coupling legacy e.g. Personal System 2 PS 2 devices to the system. One or more Universal Serial Bus USB controllers connect input devices such as keyboard and mouse combinations. A network controller may also couple to the ICH . In one embodiment a high performance network controller not shown couples to the processor bus .

The internal cache units A N and shared cache units represent a cache memory hierarchy within the processor . The cache memory hierarchy may include at least one level of instruction and data cache within each core and one or more levels of shared mid level cache such as a level 2 L2 level 3 L3 level 4 L4 or other levels of cache where the highest level of cache before external memory is classified as the last level cache LLC . In one embodiment cache coherency logic maintains coherency between the various cache units and A N.

The processor may also include a set of one or more bus controller units and a system agent . The one or more bus controller units manage a set of peripheral buses such as one or more Peripheral Component Interconnect buses e.g. PCI PCI Express . The system agent provides management functionality for the various processor components. In one embodiment the system agent includes one or more integrated memory controllers to manage access to various external memory devices not shown .

In one embodiment one or more of the cores A N include support for simultaneous multi threading. In such embodiment the system agent includes components for coordinating and operating cores A N during multi threaded processing. The system agent may additionally include a power control unit PCU which includes logic and components to regulate the power state of the cores A N and the graphics processor .

The processor additionally includes a graphics processor to execute graphics processing operations. In one embodiment the graphics processor couples with the set of shared cache units and the system agent unit including the one or more integrated memory controllers . In one embodiment a display controller is coupled with the graphics processor to drive graphics processor output to one or more coupled displays. The display controller may be separate module coupled with the graphics processor via at least one interconnect or may be integrated within the graphics processor or system agent .

In one embodiment a ring based interconnect unit is used to couple the internal components of the processor however an alternative interconnect unit may be used such as a point to point interconnect a switched interconnect or other techniques including techniques well known in the art. In one embodiment the graphics processor couples with the ring interconnect via an I O link .

The exemplary I O link represents at least one of multiple varieties of I O interconnects including an on package I O interconnect which facilitates communication between various processor components and a high performance embedded memory module such as an eDRAM module. In one embodiment each of the cores N and the graphics processor use the embedded memory modules as shared last level cache.

In one embodiment cores A N are homogenous cores executing the same instruction set architecture. In another embodiment the cores A N are heterogeneous in terms of instruction set architecture ISA where one or more of the cores A N execute a first instruction set while at least one of the other cores executes a subset of the first instruction set or a different instruction set.

The processor can be a part of or implemented on one or more substrates using any of a number of process technologies for example Complementary metal oxide semiconductor CMOS Bipolar Junction Complementary metal oxide semiconductor BiCMOS or N type metal oxide semiconductor logic NMOS . Additionally the processor can be implemented on one or more chips or as a system on a chip SOC integrated circuit having the illustrated components in addition to other components.

The graphics processor also includes a display controller to drive display output data to a display device . The display controller includes hardware for one or more overlay planes for the display and composition of multiple layers of video or user interface elements. In one embodiment the graphics processor includes a video codec engine to encode decode or transcode media to from or between one or more media encoding formats including but not limited to Moving Picture Experts Group MPEG formats such as MPEG 2 Advanced Video Coding AVC formats such as H.264 MPEG 4 AVC as well as the Society of Motion Picture Television Engineers SMPTE 421M VC 1 and Joint Photographic Experts Group JPEG formats such as JPEG and Motion JPEG MJPEG formats.

In one embodiment the graphics processor includes a block image transfer BLIT engine to perform two dimensional 2D rasterizer operations including for example bit boundary block transfers. However in one embodiment 2D graphics operations are performed using one or more components of the graphics processing engine GPE . The graphics processing engine is a compute engine for performing graphics operations including three dimensional 3D graphics operations and media operations.

The GPE includes a 3D pipeline for performing 3D operations such as rendering three dimensional images and scenes using processing functions that act upon 3D primitive shapes e.g. rectangle triangle etc. . The 3D pipeline includes programmable and fixed function elements that perform various tasks within the element and or spawn execution threads to a 3D Media sub system . While the 3D pipeline can be used to perform media operations an embodiment of the GPE also includes a media pipeline that is specifically used to perform media operations such as video post processing and image enhancement.

In one embodiment the media pipeline includes fixed function or programmable logic units to perform one or more specialized media operations such as video decode acceleration video de interlacing and video encode acceleration in place of or on behalf of the video codec engine . In on embodiment the media pipeline additionally includes a thread spawning unit to spawn threads for execution on the 3D Media sub system . The spawned threads perform computations for the media operations on one or more graphics execution units included in the 3D Media sub system.

The 3D Media subsystem includes logic for executing threads spawned by the 3D pipeline and media pipeline . In one embodiment the pipelines send thread execution requests to the 3D Media subsystem which includes thread dispatch logic for arbitrating and dispatching the various requests to available thread execution resources. The execution resources include an array of graphics execution units to process the 3D and media threads. In one embodiment the 3D Media subsystem includes one or more internal caches for thread instructions and data. In one embodiment the subsystem also includes shared memory including registers and addressable memory to share data between threads and to store output data.

In one embodiment the GPE couples with a command streamer which provides a command stream to the GPE 3D and media pipelines . The command streamer is coupled to memory which can be system memory or one or more of internal cache memory and shared cache memory. The command streamer receives commands from the memory and sends the commands to the 3D pipeline and or media pipeline . The 3D and media pipelines process the commands by performing operations via logic within the respective pipelines or by dispatching one or more execution threads to the execution unit array . In one embodiment the execution unit array is scalable such that the array includes a variable number of execution units based on the target power and performance level of the GPE .

A sampling engine couples with memory e.g. cache memory or system memory and the execution unit array . In one embodiment the sampling engine provides a memory access mechanism for the scalable execution unit array that allows the execution array to read graphics and media data from memory. In one embodiment the sampling engine includes logic to perform specialized image sampling operations for media.

The specialized media sampling logic in the sampling engine includes a de noise de interlace module a motion estimation module and an image scaling and filtering module . The de noise de interlace module includes logic to perform one or more of a de noise or a de interlace algorithm on decoded video data. The de interlace logic combines alternating fields of interlaced video content into a single fame of video. The de noise logic reduces or remove data noise from video and image data. In one embodiment the de noise logic and de interlace logic are motion adaptive and use spatial or temporal filtering based on the amount of motion detected in the video data. In one embodiment the de noise de interlace module includes dedicated motion detection logic e.g. within the motion estimation engine .

The motion estimation engine provides hardware acceleration for video operations by performing video acceleration functions such as motion vector estimation and prediction on video data. The motion estimation engine determines motion vectors that describe the transformation of image data between successive video frames. In one embodiment a graphics processor media codec uses the video motion estimation engine to perform operations on video at the macro block level that may otherwise be computationally intensive to perform using a general purpose processor. In one embodiment the motion estimation engine is generally available to graphics processor components to assist with video decode and processing functions that are sensitive or adaptive to the direction or magnitude of the motion within video data.

The image scaling and filtering module performs image processing operations to enhance the visual quality of generated images and video. In one embodiment the scaling and filtering module processes image and video data during the sampling operation before providing the data to the execution unit array .

In one embodiment the graphics processing engine includes a data port which provides an additional mechanism for graphics subsystems to access memory. The data port facilitates memory access for operations including render target writes constant buffer reads scratch memory space reads writes and media surface accesses. In one embodiment the data port includes cache memory space to cache accesses to memory. The cache memory can be a single data cache or separated into multiple caches for the multiple subsystems that access memory via the data port e.g. a render buffer cache a constant buffer cache etc. . In one embodiment threads executing on an execution unit in the execution unit array communicate with the data port by exchanging messages via a data distribution interconnect that couples each of the sub systems of the graphics processing engine .

The graphics processor receives batches of commands via the ring interconnect . The incoming commands are interpreted by a command streamer in the pipeline front end . The graphics processor includes scalable execution logic to perform 3D geometry processing and media processing via the graphics core s A N. For 3D geometry processing commands the command streamer supplies the commands to the geometry pipeline . For at least some media processing commands the command streamer supplies the commands to a video front end which couples with a media engine . The media engine includes a video quality engine VQE for video and image post processing and a multi format encode decode MFX engine to provide hardware accelerated media data encode and decode. The geometry pipeline and media engine each generate execution threads for the thread execution resources provided by at least one graphics core A.

The graphics processor includes scalable thread execution resources featuring modular cores A N sometime referred to as core slices each having multiple sub cores A N A N sometimes referred to as core sub slices . The graphics processor can have any number of graphics cores A through N. In one embodiment the graphics processor includes a graphics core A having at least a first sub core A and a second core sub core A. In another embodiment the graphics processor is a low power processor with a single sub core e.g. A . In one embodiment the graphics processor includes multiple graphics cores A N each including a set of first sub cores A N and a set of second sub cores A N. Each sub core in the set of first sub cores A N includes at least a first set of execution units A N and media texture samplers A N. Each sub core in the set of second sub cores A N includes at least a second set of execution units A N and samplers A N. In one embodiment each sub core A N A N shares a set of shared resources A N. In one embodiment the shared resources include shared cache memory and pixel operation logic. Other shared resources may also be included in the various embodiments of the graphics processor.

In one embodiment the execution unit array A N is primarily used to execute shader programs. In one embodiment the execution units in the array A N execute an instruction set that includes native support for many standard 3D graphics shader instructions such that shader programs from graphics libraries e.g. Direct 3D and OpenGL are executed with a minimal translation. The execution units support vertex and geometry processing e.g. vertex programs geometry programs vertex shaders pixel processing e.g. pixel shaders fragment shaders and general purpose processing e.g. compute and media shaders .

Each execution unit in the execution unit array A N operates on arrays of data elements. The number of data elements is the execution size or the number of channels for the instruction. An execution channel is a logical unit of execution for data element access masking and flow control within instructions. The number of channels may be independent of the number of physical ALUs or FPUs for a particular graphics processor. The execution units A N support integer and floating point data types.

The execution unit instruction set includes single instruction multiple data SIMD instructions. The various data elements can be stored as a packed data type in a register and the execution unit will process the various elements based on the data size of the elements. For example when operating on a 256 bit wide vector the 256 bits of the vector are stored in a register and the execution unit operates on the vector as four separate 64 bit packed data elements quad word QW size data elements eight separate 32 bit packed data elements double word DW size data elements sixteen separate 16 bit packed data elements word W size data elements or thirty two separate 8 bit data elements byte B size data elements . However different vector widths and register sizes are possible.

One or more internal instruction caches e.g. are included in the thread execution logic to cache thread instructions for the execution units. In one embodiment one or more data caches e.g. are included to cache thread data during thread execution. A sampler is included to provide texture sampling for 3D operations and media sampling for media operations. In one embodiment the sampler includes specialized texture or media sampling functionality to process texture or media data during the sampling process before providing the sampled data to an execution unit.

During execution the graphics and media pipelines send thread initiation requests to the thread execution logic via thread spawning and dispatch logic. The thread execution logic includes a local thread dispatcher that arbitrates thread initiation requests from the graphics and media pipelines and instantiates the requested threads on one or more execution units A N. For example the geometry pipeline e.g. of dispatches vertex processing tessellation or geometry processing threads to the thread execution logic . The thread dispatcher can also process runtime thread spawning requests from the executing shader programs.

Once a group of geometric objects have been processed and rasterized into pixel data the pixel shader is invoked to further compute output information and cause results to be written to output surfaces e.g. color buffers depth buffers stencil buffers etc. . In one embodiment the pixel shader calculates the values of the various vertex attributes that are to be interpolated across the rasterized object. The pixel shader then executes an API supplied pixel shader program. To execute the pixel shader program the pixel shader dispatches threads to an execution unit e.g. A via the thread dispatcher . The pixel shader uses texture sampling logic in the sampler to access texture data in texture maps stored in memory. Arithmetic operations on the texture data and the input geometry data compute pixel color data for each geometric fragment or discards one or more pixels from further processing.

In one embodiment the data port provides a memory access mechanism for the thread execution logic output processed data to memory for processing on a graphics processor output pipeline. In one embodiment the data port includes or couples to one or more cache memories e.g. data cache to cache data for memory access via the data port.

In one embodiment the graphics processor execution units natively support instructions in a 128 bit format . A 64 bit compacted instruction format is available for some instructions based on the selected instruction instruction options and number of operands. The native 128 bit format provides access to all instruction options while some options and operations are restricted in the 64 bit format . The native instructions available in the 64 bit format varies by embodiment. In one embodiment the instruction is compacted in part using a set of index values in an index field . The execution unit hardware references a set of compaction tables based on the index values and uses the compaction table outputs to reconstruct a native instruction in the 128 bit format .

For each format an instruction opcode defines the operation that the execution unit is to perform. The execution units execute each instruction in parallel across the multiple data elements of each operand. For example in response to an add instruction the execution unit performs a simultaneous add operation across each color channel representing a texture element or picture element. By default the execution unit performs each instruction across all data channels of the operands. An instruction control field enables control over certain execution options such as channels selection e.g. predication and data channel order e.g. swizzle . For 128 bit instructions an exec size field limits the number of data channels that will be executed in parallel. The exec size field is not available for use in the 64 bit compact instruction format .

Some execution unit instructions have up to three operands including two source operands src0 src1 and one destination . In one embodiment the execution units support dual destination instructions where one of the destinations is implied. Data manipulation instructions can have a third source operand e.g. SRC2 where the instruction opcode JJ12 determines the number of source operands. An instruction s last source operand can be an immediate e.g. hard coded value passed with the instruction.

In one embodiment instructions are grouped based on opcode bit fields to simplify Opcode decode . For an 8 bit opcode bits and allow the execution unit to determine the type of opcode. The precise opcode grouping shown is exemplary. In one embodiment a move and logic opcode group includes data movement and logic instructions e.g. mov cmp . The move and logic group shares the five most significant bits MSB where move instructions are in the form of 0000xxxxb e.g. 0x0x and logic instructions are in the form of 0001xxxxb e.g. 0x01 . A flow control instruction group e.g. call jmp includes instructions in the form of 0010xxxxb e.g. 0x20 . A miscellaneous instruction group includes a mix of instructions including synchronization instructions e.g. wait send in the form of 0011xxxxb e.g. 0x30 . A parallel math instruction group includes component wise arithmetic instructions e.g. add mul in the form of 0100xxxxb e.g. 0x40 . The parallel math group performs the arithmetic operations in parallel across data channels. The vector math group includes arithmetic instructions e.g. dp4 in the form of 0101xxxxb e.g. 0x50 . The vector math group performs arithmetic such as dot product calculations on vector operands.

The command streamer directs the operation of a vertex fetcher component that reads vertex data from memory and executes vertex processing commands provided by the command streamer . The vertex fetcher provides vertex data to a vertex shader which performs coordinate space transformation and lighting operations to each vertex. The vertex fetcher and vertex shader execute vertex processing instructions by dispatching execution threads to the execution units A B via a thread dispatcher .

In one embodiment the execution units A B are an array of vector processors having an instruction set for performing graphics and media operations. The execution units A B have an attached L1 cache that is specific for each array or shared between the arrays. The cache can be configured as a data cache an instruction cache or a single cache that is partitioned to contain data and instructions in different partitions.

In one embodiment the graphics pipeline includes tessellation components to perform hardware accelerated tessellation of 3D objects. A programmable hull shader configures the tessellation operations. A programmable domain shader provides back end evaluation of tessellation output. A tessellator operates at the direction of the hull shader and contains special purpose logic to generate a set of detailed geometric objects based on a coarse geometric model that is provided as input to the graphics pipeline . If tessellation is not used the tessellation components can be bypassed.

The complete geometric objects can be processed by a geometry shader via one or more threads dispatched to the execution units A B or can proceed directly to the clipper . The geometry shader operates on entire geometric objects rather than vertices or patches of vertices as in previous stages of the graphics pipeline. If the tessellation is disabled the geometry shader receives input from the vertex shader . The geometry shader is programmable by a geometry shader program to perform geometry tessellation if the tessellation units are disabled.

Prior to rasterization vertex data is processed by a clipper which is either a fixed function clipper or a programmable clipper having clipping and geometry shader functions. In one embodiment a rasterizer in the render output pipeline dispatches pixel shaders to convert the geometric objects into their per pixel representations. In one embodiment pixel shader logic is included in the thread execution logic .

The graphics engine has an interconnect bus interconnect fabric or some other interconnect mechanism that allows data and message passing amongst the major components of the graphics engine. In one embodiment the execution units A B and associated cache s texture and media sampler and texture sampler cache interconnect via a data port to perform memory access and communicate with render output pipeline components of the graphics engine. In one embodiment the sampler caches and execution units A B each have separate memory access paths.

In one embodiment the render output pipeline contains a rasterizer and depth test component that converts vertex based objects into their associated pixel based representation. In one embodiment the rasterizer logic includes a windower masker unit to perform fixed function triangle and line rasterization. An associated render and depth buffer caches are also available in one embodiment. A pixel operations component performs pixel based operations on the data though in some instances pixel operations associated with 2D operations e.g. bit block image transfers with blending are performed by the 2D engine or substituted at display time by the display controller using overlay display planes. In one embodiment a shared L3 cache is available to all graphics components allowing the sharing of data without the use of main system memory.

The graphics processor media pipeline includes a media engine and a video front end . In one embodiment the video front end receives pipeline commands from the command streamer . However in one embodiment the media pipeline includes a separate command streamer. The video front end processes media commands before sending the command to the media engine . In one embodiment the media engine includes thread spawning functionality to spawn threads for dispatch to the thread execution logic via the thread dispatcher .

In one embodiment the graphics engine includes a display engine . In one embodiment the display engine is external to the graphics processor and couples with the graphics processor via the ring interconnect or some other interconnect bus or fabric. The display engine includes a 2D engine and a display controller . The display engine contains special purpose logic capable of operating independently of the 3D pipeline. The display controller couples with a display device not shown which may be a system integrated display device as in a laptop computer or an external display device attached via an display device connector.

The graphics pipeline and media pipeline are configurable to perform operations based on multiple graphics and media programming interfaces and are not specific to any one application programming interface API . In one embodiment driver software for the graphics processor translates API calls that are specific to a particular graphics or media library into commands that can be processed by the graphics processor. In various embodiments support is provided for the Open Graphics Library OpenGL and Open Computing Language OpenCL supported by the Khronos Group the Direct3D library from the Microsoft Corporation or in one embodiment both OpenGL and D3D. Support may also be provided for the Open Source Computer Vision Library OpenCV . A future API with a compatible 3D pipeline would also be supported if a mapping can be made from the pipeline of the future API to the pipeline of the graphics processor.

The client specifies the client unit of the graphics device that processes the command data. In one embodiment a graphics processor command parser examines the client field of each command to condition the further processing of the command and route the command data to the appropriate client unit. In one embodiment the graphics processor client units include a memory interface unit a render unit a 2D unit a 3D unit and a media unit. Each client unit has a corresponding processing pipeline that processes the commands. Once the command is received by the client unit the client unit reads the opcode and if present sub opcode to determine the operation to perform. The client unit performs the command using information in the data field of the command. For some commands an explicit command size is expected to specify the size of the command. In one embodiment the command parser automatically determines the size of at least some of the commands based on the command opcode. In one embodiment commands are aligned via multiples of a double word.

The flow chart in shows a sample command sequence . In one embodiment software or firmware of a data processing system that features an embodiment of the graphics processor uses a version of the command sequence shown to set up execute and terminate a set of graphics operations. A sample command sequence is shown and described for exemplary purposes however embodiments are not limited to these commands or to this command sequence. Moreover the commands may be issued as batch of commands in a command sequence such that the graphics processor will process the sequence of commands in an at least partially concurrent manner.

The sample command sequence may begin with a pipeline flush command to cause any active graphics pipeline to complete the currently pending commands for the pipeline. In one embodiment the 3D pipeline and the media pipeline do not operate concurrently. The pipeline flush is performed to cause the active graphics pipeline to complete any pending commands. In response to a pipeline flush the command parser for the graphics processor will pause command processing until the active drawing engines complete pending operations and the relevant read caches are invalidated. Optionally any data in the render cache that is marked dirty can be flushed to memory. A pipeline flush command can be used for pipeline synchronization or before placing the graphics processor into a low power state.

A pipeline select command is used when a command sequence requires the graphics processor to explicitly switch between pipelines. A pipeline select command is required only once within an execution context before issuing pipeline commands unless the context is to issue commands for both pipelines. In one embodiment a pipeline flush command is is required immediately before a pipeline switch via the pipeline select command .

A pipeline control command configures a graphics pipeline for operation and is used to program the 3D pipeline and the media pipeline . The pipeline control command configures the pipeline state for the active pipeline. In one embodiment the pipeline control command is used for pipeline synchronization and to clear data from one or more cache memories within the active pipeline before processing a batch of commands.

Return buffer state commands are used to configure a set of return buffers for the respective pipelines to write data. Some pipeline operations require the allocation selection or configuration of one or more return buffers into which the operations write intermediate data during processing. The graphics processor also uses one or more return buffers to store output data and to perform cross thread communication. The return buffer state includes selecting the size and number of return buffers to use for a set of pipeline operations.

The remaining commands in the command sequence differ based on the active pipeline for operations. Based on a pipeline determination the command sequence is tailored to the 3D pipeline beginning with the 3D pipeline state or the media pipeline beginning at the media pipeline state .

The commands for the 3D pipeline state include 3D state setting commands for vertex buffer state vertex element state constant color state depth buffer state and other state variables that are to be configured before 3D primitive commands are processed. The values of these commands are determined at least in part based the particular 3D API in use. 3D pipeline state commands are also able to selectively disable or bypass certain pipeline elements if those elements will not be used.

The 3D primitive command is used to submit 3D primitives to be processed by the 3D pipeline. Commands and associated parameters that are passed to the graphics processor via the 3D primitive command are forwarded to the vertex fetch function in the graphics pipeline. The vertex fetch function uses the 3D primitive command data to generate vertex data structures. The vertex data structures are stored in one or more return buffers. The 3D primitive command is used to perform vertex operations on 3D primitives via vertex shaders. To process vertex shaders the 3D pipeline dispatches shader execution threads to graphics processor execution units.

The 3D pipeline is triggered via an execute command or event. In one embodiment a register write triggers command execution. In one embodiment execution is triggered via a go or kick command in the command sequence. In one embodiment command execution is triggered using a pipeline synchronization command to flush the command sequence through the graphics pipeline. The 3D pipeline will perform geometry processing for the 3D primitives. Once operations are complete the resulting geometric objects are rasterized and the pixel engine colors the resulting pixels. Additional commands to control pixel shading and pixel back end operations may also be included for those operations.

The sample command sequence follows the media pipeline path when performing media operations. In general the specific use and manner of programming for the media pipeline depends on the media or compute operations to be performed. Specific media decode operations may be offloaded to the media pipeline during media decode. The media pipeline can also be bypassed and media decode can be performed in whole or in part using resources provided by one or more general purpose processing cores. In one embodiment the media pipeline also includes elements for general purpose graphics processor unit GPGPU operations where the graphics processor is used to perform SIMD vector operations using computational shader programs that are not explicitly related to the rendering of graphics primitives.

The media pipeline is configured in a similar manner as the 3D pipeline . A set of media pipeline state commands are dispatched or placed into in a command queue before the media object commands . The media pipeline state commands include data to configure the media pipeline elements that will be used to process the media objects. This includes data to configure the video decode and video encode logic within the media pipeline such as encode or decode format. The media pipeline state commands also support the use one or more pointers to indirect state elements that contain a batch of state settings.

Media object commands supply pointers to media objects for processing by the media pipeline. The media objects include memory buffers containing video data to be processed. In one embodiment all media pipeline state must be valid before issuing a media object command . Once the pipeline state is configured and media object commands are queued the media pipeline is triggered via an execute command or an equivalent execute event e.g. register write . Output from the media pipeline may then be post processed by operations provided by the 3D pipeline or the media pipeline . In one embodiment GPGPU operations are configured and executed in a similar manner as media operations.

In one embodiment the 3D graphics application contains one or more shader programs including shader instructions . The shader language instructions may be in a high level shader language such as the High Level Shader Language HLSL or the OpenGL Shader Language GLSL . The application also includes executable instructions in a machine language suitable for execution by the general purpose processor core . The application also includes graphics objects defined by vertex data.

The operating system may be a Microsoft Windows operating system from the Microsoft Corporation a proprietary UNIX like operating system or an open source UNIX like operating system using a variant of the Linux kernel. When the Direct3D API is in use the operating system uses a front end shader compiler to compile any shader instructions in HLSL into a lower level shader language. The compilation may be a just in time compilation or the application can perform share pre compilation. In one embodiment high level shaders are compiled into low level shaders during the compilation of the 3D graphics application .

The user mode graphics driver may contain a back end shader compiler to convert the shader instructions into a hardware specific representation. When the OpenGL API is in use shader instructions in the GLSL high level language are passed to a user mode graphics driver for compilation. The user mode graphics driver uses operating system kernel mode functions to communicate with a kernel mode graphics driver . The kernel mode graphics driver communicates with the graphics processor to dispatch commands and instructions.

To the extent various operations or functions are described herein they can be described or defined as hardware circuitry software code instructions configuration and or data. The content can be embodied in hardware logic or as directly executable software object or executable form source code high level shader code designed for execution on a graphics engine or low level assembly language code in an instruction set for a specific processor or graphics core. The software content of the embodiments described herein can be provided via an article of manufacture with the content stored thereon or via a method of operating a communication interface to send data via the communication interface.

A non transitory machine readable storage medium can cause a machine to perform the functions or operations described and includes any mechanism that stores information in a form accessible by a machine e.g. computing device electronic system etc. such as recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. . A communication interface includes any mechanism that interfaces to any of a hardwired wireless optical etc. medium to communicate to another device such as a memory bus interface a processor bus interface an Internet connection a disk controller etc. The communication interface is configured by providing configuration parameters or sending signals to prepare the communication interface to provide a data signal describing the software content. The communication interface can be accessed via one or more commands or signals sent to the communication interface.

Various components described can be a means for performing the operations or functions described. Each component described herein includes software hardware or a combination of these. The components can be implemented as software modules hardware modules special purpose hardware e.g. application specific hardware application specific integrated circuits ASICs digital signal processors DSPs etc. embedded controllers hardwired circuitry etc. Besides what is described herein various modifications can be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

One example embodiment may be a method comprising attempting to compress cache lines using a color palette checking whether the palette compression meets a bit budget and if so storing an indicator in a control surface that palette compressor was used storing the compressed representation in index bits in a color buffer and marking the cache lines as evicted. The method may also include where the palette is a set of N colors and each sample uses N combinations to point into the palette where the sum of the storage of the palette and the sum of all samples combinations can be stored in index bits of a tile. The method may also include where the palette is 2colors and each sample uses n palette index bits to point into the palette and where the sum of the storage of the palette and the number of palette index bits for all samples in the tile is less than or equal to the sum of the index bits of the tile. The method may also include wherein the palette is 2colors and each sample uses less than n palette index bits to point into the palette. The method may also include selecting a tile including cache lines for eviction from a color buffer cache and checking index bits in the color cache to determine a number of planes in the color buffer and checking to determine whether all of said planes are in a color buffer cache. The method may also include only attempting to compress if all of the planes are in the color buffer cache. The method may also include using a different compression if all of the planes are not in the cache. The method may also include using a different compression if the bit budget is not met. The method may also include for 4 MSAA storing a 2 color palette and 1 palette index bit per sample. The method may also include for 4 MSAA storing 3 status bits per pixel indicating how the palette indices are encoded. The method may also include for 8 MSAA storing a 4 color palette and 2 palette index bits per sample. The method may also include for 8 MSAA storing 4 status bits per pixel indicating how the palette indices are encoded.

In another example embodiment may be one or more non transitory computer readable media storing instructions to execute a sequence comprising attempting to compress cache lines using a color palette checking whether the palette compression meets a bit budget and if so storing an indicator in a control surface that palette compressor was used storing the compressed representation in index bits in a color buffer and marking the cache lines as evicted. The media may further store instructions to perform a sequence including where the palette is a set of N colors and each sample uses N combinations to point into the palette where the sum of the storage of the palette and the sum of all samples combinations can be stored in index bits of a tile. The media may further store instructions to perform a sequence including selecting a tile including cache lines for eviction from a color buffer cache and checking index bits in the color cache to determine a number of planes in the color buffer. The media may further store instructions to perform a sequence including checking to determine whether all of said planes are in a color buffer cache. The media may further store instructions to perform a sequence including only attempting to compress if all of the planes are in the color buffer cache. The media may further store instructions to perform a sequence including using a different compression if all of the planes are not in the cache. The media may further store instructions to perform a sequence including using a different compression if the bit budget is not met. The media may further store instructions to perform a sequence including using three index bits to indicate which single color all samples point to which pair of colors all samples point to and that the samples point to all three colors. The media may further store instructions to perform a sequence including using 64 bits to store pixels and if these bits are not sufficient then using a different compression method or no compression.

In another example embodiment may be an apparatus comprising a hardware processor to attempt to compress cache lines using a color palette check whether the palette compression meets a bit budget and if so store an indicator in a control surface that palette compressor was used storing the compressed representation in index bits in a color buffer and marking the cache lines as evicted and a storage coupled to said processor. The apparatus may include said processor to where the palette is a set of N colors and each sample uses N combinations to point into the palette where the sum of the storage of the palette and the sum of all samples combinations can be stored in index bits of a tile. The apparatus may include said processor to select a tile including cache lines for eviction from a color buffer cache and check index bits in the color cache to determine a number of planes in the color buffer. The apparatus may include said processor to check to determine whether all of said planes are in a color buffer cache. The apparatus may include said processor to only attempt to compress if all of the planes are in the color buffer cache. The apparatus may include said processor to use a different compression if all of the planes are not in the cache. The apparatus may include said processor to use a different compression if the bit budget is not met. The apparatus may include said processor to use three index bits to indicate which single color all samples point to which pair of colors all samples point to and that the samples point to all three colors. The apparatus may include said processor to use 64 bits to store pixels and if these bits are not sufficient then using a different compression method or no compression. The apparatus may include said processor to use a four color palette.

The graphics processing techniques described herein may be implemented in various hardware architectures. For example graphics functionality may be integrated within a chipset. Alternatively a discrete graphics processor may be used. As still another embodiment the graphics functions may be implemented by a general purpose processor including a multicore processor.

References throughout this specification to one embodiment or an embodiment mean that a particular feature structure or characteristic described in connection with the embodiment is included in at least one implementation encompassed within the present disclosure. Thus appearances of the phrase one embodiment or in an embodiment are not necessarily referring to the same embodiment. Furthermore the particular features structures or characteristics may be instituted in other suitable forms other than the particular embodiment illustrated and all such forms may be encompassed within the claims of the present application.

While a limited number of embodiments have been described those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this disclosure.

