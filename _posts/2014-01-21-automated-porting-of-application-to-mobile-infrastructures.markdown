---

title: Automated porting of application to mobile infrastructures
abstract: Techniques to automatically port applications to a mobile infrastructure using code separation with semantic guarantees are disclosed. Porting enterprise applications from to a target architecture another is effected via separating code into constituent layers of the target architecture. To preserve semantics, code transformations are enforced via an abstract syntax tree structure. The generated code may have various code wrappers and/or infrastructure elements so the ported application will operate in the target architecture. Various techniques are disclosed regarding specific code wrappers and/or infrastructure elements to address operating issues including, but not limited to, architectural issues, network latency, framework changes, regulatory issues.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09459862&OS=09459862&RS=09459862
owner: ArtinSoft Corporation
number: 09459862
owner_city: Bellevue
owner_country: US
publication_date: 20140121
---
This patent application claims priority to provisional patent application 61 758 217 titled Automated Porting of Applications Across Enterprise Infrastructures filed Jan. 29 2013 and non provisional patent application Ser. No. 13 842 519 titled Code Separation With Semantic Guarantees filed Mar. 15 2013 both of which are incorporated by reference in full herein.

Software applications such as accounting finance and customer relations applications may constitute a large ongoing investment by an enterprise or other organization. For example an enterprise information technology EIT organization may invest in the initial requirements gathering and design of an application. Then EIT may invest in the software programming development and testing of the application. Next enterprise data will have to be entered or ported into the application. Finally the application will be deployed often constituting an expense of both hardware and or training.

As the application is used and modified during its lifecycle the application accrues modifications and bug fixes as well as an accretion of business unit information technology BUIT satellite applications. In this way an ecosystem builds around the original software application. Eventually the application may become relied upon by the enterprise as the embodiment of the enterprise s policies. Thus a software application not only represents a financial investment but also an institutionalization of the enterprise s business procedures.

However technology platforms evolve and business needs and policies evolve. An example of the former is where an initial investment in a two tier client server software architecture may give way to three tier enterprise data center based architectures which in turn evolve into web based applications and cloud based applications each time causing applications to be ported to the newer software architectures. Another example of the former is where programming languages and frameworks become deprecated such as where Microsoft Visual Basic.NET and the .NET application framework was not fully backwards compatible with Microsoft Visual Basic 6 and its Component Object Model based infrastructure giving rise to applications being ported. An example of the latter is where the C Standard Library library was later found to be susceptible to buffer overrun security attacks causing applications to be moved to fixed buffer equivalents.

Typically porting an application to a new software architecture or platform causes a full rewrite. Since the rewrite is to a new architecture or platform or represents some other form of code refactoring the port will not behave exactly in the same way as before. For example a personal computer based client application may be ported to a mobile device. Accordingly the functionality of the ported application on mobile device will differ at least according to the form factor change.

The functionality change causes risk that the semantics of the rewrite will not exactly conform to the behavior of the original application. If this were to happen BUIT satellite applications and other software applications interfacing with the original application may break.

This state of affairs leaves EIT organizations on the horns of a dilemma. The extension of the lifecycle of their mission critical software applications may rely on a successful port to a new architecture or platform. But to do so the EIT organization may have to risk a non conforming port. In other words the EIT organization cannot rely on semantics to be preserved during a port.

This patent application discloses automated code transformations of software applications where the transformation includes separating the code into components corresponding to a target architecture while guaranteeing semantic equivalence. Specifically modern software applications are generally organized into separate components. Components may be loosely or tightly coupled and may have high or low degrees of cohesion. Accordingly components are not merely functional blocks of code but also include an invocation interface where the interface guarantees specific semantic behavior. In object oriented programming a component s invocation interface is sometimes referred to as a contract thereby emphasizing the guarantee of specific semantic behavior.

Components are not homogenous. Components typically take on specialized roles in interacting with other components. In this way components may be organized into parts of a larger software machine. For example in object oriented programming design patterns are component interaction patterns where a generic component type may be specialized according to a particular application. For instance one design pattern is the strategy design pattern where an abstract class is replaced with a concrete class depending on the context of a situation. Thus concrete components may take on the type of an abstract class.

Design patterns typically apply only to a part of a software application. However there are patterns called software architectural patterns that cover an entire software application. Example software architectural patterns are model view controller MVC model view MV and model view viewmodel MVVM . Software architecture design is often driven by a platform. Specifically a platform is the set of hardware and or software that hosts and executes the software. A platform generally comprises hardware an operating system standard libraries and or a software application framework. In the case of a virtual execution environment the platform may not necessarily specify physical hardware but virtual hardware and an execution environment or virtual machine. In this way a platform describes the support infrastructure for a software application. As a result a platform may describe the hardware architecture and platform software corresponding for various portions of a software architecture. For example a mobile device may correspond to a client and a cloud based service may correspond to a web service. Thus an architecture software or hardware or both may give rise to a generic classes of components known as component types.

Porting a software application involves porting the software application s source code. Typically source code is written in one or more programming languages each programming language having its own grammar Early applications were written in a single programming language such as FORTRAN or COBOL. Present enterprise applications are often written in multiple programming languages often in the same source code file. For example an application may use a structural language like Microsoft Visual Basic for procedures but structured query language SQL for database access. By way of another example web clients typically use some combination of hypertext markup language HTML cascading style sheets CSS and JavaScript.

As a result in addition to porting to a different architecture porting source code may involve transforming code expressed in multiple input grammars that represent the programming languages of the source code of the application to be ported into code expressed in multiple output grammars representing the programming languages of the source code of the application after being ported. Enterprise applications especially those that have been in operation for a relatively long time are generally complex may be large and may be a hodge podge of different programming languages and approaches as varied as the programmers who maintained the application.

Due to its complexity porting an enterprise application is therefore a candidate program for computer automation. Specifically the goal of a successful port is not only to achieve the architectural change and the translation across grammars but also to preserve the semantics of the application s business logic after the porting process. That is to say any invocation of the business logic post port should have the same behavior as prior to the port.

The emphasis on preserving semantics has the effect of de emphasizing syntax. An automated approach to a port across architectures cannot be a na ve syntactic translation of the original components to the exact same components except in a different programming language. One approach to automating the porting process involves receiving input grammars and output grammars developing a composite grammar representing the application in an abstract syntax tree that supports the composite grammar. The abstract syntax tree may be annotated with transformational rules that impact either a node in the abstract syntax tree all nodes in a sub tree of the abstract syntax tree or the entire abstract syntax tree. In this way porting can be effected by traversing the abstract syntax tree and using the transformational rules in the annotations to determine what output code to generate.

However after a port the architectural changes and grammar changes will change some of the functionality of original application vis vis the ported application. At the very least the ability to run on a new architecture constitutes a functional change. With an architectural change components in the original application may not have a one to one correspondence with components in the ported application. Thus during a port a decision is made as to which semantics are to be preserved.

Code separation is the process of identifying which portions of the source code of the original application map to different portions of a target architecture. Correctly separating code is the basis for a successful port. Consider the case where an application s client application was originally targeted for a personal computer but is being ported to a mobile phone. The user interfaces of the client applications will differ due to the form factor change. However both client applications should be able to expect that interactions with the business logic will be the same as in the original application. Therefore separating code for the client from code for the business logic provides a basis for determining which semantics to preserve during a port.

Code separation will have a varying role in an application port depending on the transformation to be achieved. A transformation is a deterministic alteration of source code to achieve a desired result. Since a transformation is achieved by the application of a deterministic algorithm typically the transformation may be reversed by applying the inverse of the algorithm. However transformations are not necessarily commutative.

Some transformations will not involve code separation. For example a pure language port that does not involve an architectural change is less likely to use code separation. Language based changes such as compilation or insertion of artifacts such as debug information tend to preserve architecture.

However other transformations will rely on code separation. In particular changes in hardware architecture such as porting from a single core computer processing unit CPU to a multi core CPU or to a system on a chip SoC give rise to new hardware capabilities. Therefore the porting process will identify functionality in the original application that may take advantage of the new hardware. Similarly porting software to a new framework such as from COM to .NET or to a new software architecture such as a from two tier client server to a web based services oriented architecture SOA is likely to rely on code separation since the component types in the original application will not have a one to one correspondence to the components types of the targeted architecture. In general the greater the difference in architecture of the original application to the targeted architecture the greater the reliance on code separation.

Differences in component types are not necessarily based on architecture. Some transformations such as performance optimizations and code refactoring are not re architecting transformations. For example components may be combined into a single dynamic link library DLL to improve load times. Similarly during refactoring analysis may identify redundant code and consolidate functionality accordingly. Automated modifications to support a global business policy change in an application may also use code separation as some components likely to embody the policy may be assigned a distinct component type.

Having introduced code separation we turn now to the automation of code separation. is an exemplary context diagram for automated porting of applications with semantic guarantees. Specifically an automated software application transformation may be considered in terms of moving from concrete terms to abstract terms as represented by the horizontal dotted line and in terms of moving from pre transformation i.e. the original application to post transformation i.e. the ported application.

Source code comprises a concrete representation of the original application. Source code is typically in the form of source code files and is generally written in one or more programming languages each programming language represented by a grammar.

The source code may be statically analyzed and represented in an annotated abstract syntax tree which supports the input grammars of the programming languages in the original application as well as the output grammars of the programming languages in the targeted architecture. The annotations in the abstract syntax tree represent transformational rules that impact either a node in the abstract syntax tree all nodes in a sub tree of the abstract syntax tree or the entire abstract syntax tree . Thus code generation may be effected by a traversal of the abstract syntax tree while applying the transformational rules.

However code generation will also include separating code into components. Code separation starts with identifying candidate components by querying the abstract syntax tree . A code separation function analyzes the candidate components in view of an architectural template describing the target architecture i.e. the architecture the original application is being ported to and transformational rules . Note that the transformational rules may be part of the abstract syntax tree or may be stored separately. The code separation process is described in more detail with respect to .

Once the code separation function has identified how code from the original application is to be mapped to components in the target architecture a code generation function may commence. During the code generation in additional to translation to new languages the components of the target architecture may be wrapped with code to facilitate operation in the target architecture and may be connected to additional infrastructure elements such as a runtime to optimize execution.

Client device is any computing device. A client device may have a processor and a memory . Client device s memory is any computer readable media which may store several programs including an application and or an operating system .

Computer readable media includes at least two types of computer readable media namely computer storage media and communications media. Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other non transmission medium that can be used to store information for access by a computing device. In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transmission mechanism. As defined herein computer storage media does not include communication media.

To participate in a communications environment user equipment device may have a network interface . The network interface may be one or more network interfaces including Ethernet Wi Fi or any number of other physical and data link standard interfaces. In the case where the programming language transformations are to be done on a single machine the network interface is optional.

Client may use the network interface to communicate to remote storage . Remote storage may include network aware storage NAS or may be removable storage such as a thumb drive or memory stick.

Client may communicate to a server . Server is any computing device that may participate in a network. Client network interface may ultimate connect to server via server network interface . Server network interface may be one or more network interfaces as described with respect to client network interface .

Server also has a processor and memory . As per the preceding discussion regarding client device memory is any computer readable media including both computer storage media and communication media.

In particular memory stores software which may include an application and or an operating system . Memory may also store applications that may include a database management system. Accordingly server may include data store . Data store may be configured as a relational database an object oriented database and or a columnar database or any configuration to support policy storage.

Server need not be on site or operated by the client enterprise. Server may be hosted in a cloud . Cloud may represent a plurality of disaggregated servers which provide virtual web application server functionality and virtual database functionality. Cloud services may be made accessible via cloud infrastructure . Cloud infrastructure not only provides access to cloud services but also billing services. Cloud infrastructure may provide additional service abstractions such as Platform as a Service PAAS Infrastructure as a Service IAAS and Software as a Service SAAS .

Example Operation of Performing a Software Application Transformation Using Automated Porting of Applications

Software application ports are a form of software application transformation. Where the application architecture is to change or where the application transformation gives rise to changes in component types code separation techniques that preserve semantics are to be brought to bear. illustrates a flowchart of the example operation of performing a software application transformation using automated porting of applications with semantic guarantees.

In block input comprising source code is received. Source code may be in the form of files written in one or more programming languages each programming language represented in a grammar.

A code separation function may access the source code transformed into an abstract syntax tree that supports the input grammars of the source code of the original application as well as the output grammars of the target architecture i.e. the architecture of the ported application. The abstract syntax tree may be annotated with transformational rules.

In block an annotated abstract syntax tree is generated from at least one of the source code files of the original application. In this way a port of a selected portion of the original application or a complete port of the entire original application may be effected.

In block the code separation function receives an architectural template. The architectural template may describe a hardware architecture and or a software architecture. The architectural template may describe solely the target software architecture or may additionally describe a target platform comprising a target hardware architecture and support software such as an operating system support libraries and or frameworks or an execution environment or virtual machine. In the case where the architectural template describes the target platform the architectural template may also describe the advantages and disadvantages of the target platform. For example where the target platform is distributed the architectural template may indicate where performance may be degraded by network connections due to remote communications. By way of another example the architectural template may indicate strong parallel processing capabilities as in a server. In this way the architectural template may provide input that may weigh the selection of components for a corresponding component type.

The architectural template will provide the basis for defining component types. For example a software architecture may prescribe a client tier a business logic tier and a persistence tier. Each of these tier may represent a component type. Other software architectures include examples such as model view controller model view and model view viewmodel. The specific example of model view viewmodel is discussed in more detail with respect to .

Alternatively the architectural template may represent a business architecture instead where each component type enumerates a function corresponding to the organization of the business enterprise such as departments and cost centers.

In the case of hardware architectures the architectural template may describe a cloud infrastructure using a service oriented architecture accessed by mobile devices. The architectural template may include information about additional functionality present in the target cloud architecture such as that exposed by Platform as a Service Infrastructure as a Service and Software as a Service functionality.

In block the existing transformational rules in the annotated abstract syntax tree are augmented with a generated set of transformational rules specific to the received architectural template. Example transformational rules would include the generation of wrapper code corresponding to the component types described in the architectural template. Wrapper code may include simple plumbing code that allows invocation in the new architecture. For example components that were once local to each other may be transformed into remote components invoking each other via remote procedure call RPC . Other transformation rules may include converting components from stateful to stateless components where they are to reside in a middle tier. In some cases instead of wrapper code a component may be transformed by invoking a platform element to optimize execution. Platform elements may include prebuilt platform rearchitecture agents containing code artifacts for the target platform. For example the platform elements for a web page may include prebuilt hypertext markup language HTML cascading style sheet CSS and JavaScript files.

Note that it may be desirable for an architectural template to describe different transformation options for the same component type. For example in a mobile device client scenario a technician may desire to support both Apple iOS and Google Android embodiments of a client. In this case components that have a client component type will have two sets of transformation rules a first set corresponding to transforming the client components into an Apple iOS mobile client and a second set corresponding to transforming the client components into a Google Android mobile client.

Not all transformation rules are driven by the architectural template. For example the transformations translating the source code to the programming languages of the target architecture need not be generated from the architectural template.

Once the transformation rules specific to the architectural template are generated the code separation function determines which components to apply those transformation rules. In block the annotated abstract syntax tree is queried for candidate components. Candidate components are functional blocks with an invocation interface whose semantic behavior is guaranteed. The candidate components are inferred to be of a component type in the architectural template. Inferring candidate components to be of a specific component type is described in more detail with respect to .

Once the candidate components are associated with component types in block at least some candidate components are selected for transformation. In some cases all the candidate components are selected. However in other cases a technician may be reviewing the candidate components via an integrated development environment IDE or some other development tool and may opt to override the inferences made in block . Based on these selections the abstract syntax tree may be further annotated with additional transformation rules where these additional transformation rules are associated with the selected components. If the additional rules are added while a code generation is in progress then the code generation may be reperformed via an IDE or development tool.

In general an IDE or development tool provides the opportunity to monitor the status of a code generation in progress. For example a log of operations against the abstract syntax tree such as annotated component identification component type identification and repositioning may be viewed. Particularly large and complex trees may take a relatively long time thus the log may be viewed substantially in real time. Accordingly an IDE or development tool may receive input from a technician to modify a code generation operation while in progress.

Where the IDE or development tool receives input from a technician the components in the abstract syntax tree directly affected by the input are identified. Since the abstract syntax tree effectively stores information about components affected by other components changing usually in the form as storing components in an affected component s subtree. Thus the IDE or development tool can identify all components dependent on components directly affected by a change. Thus if a code generation is in progress code generation for the directly affected components as well as their dependent components may be reperformed. In this way correct code may be generated despite an input change from a technician without forcing a full code regeneration of the entire abstract syntax tree.

An IDE or development tool may access an arbitrary abstract syntax tree. Therefore an IDE or development tool may manage transformations on different abstract syntax trees. Conversely an abstract syntax tree may store a plurality of transformation rules for the same components in its annotations. For example client components may be annotated with transformation rules to target a tablet or a personal computer at the same time and the IDE or development tool will select which transformation rules to apply. In this way an abstract syntax tree may be shared.

Upon selection the application is ported by generating code in block . Specifically the abstract syntax tree is traversed and pretty printed according to the transformational rules. Code generation may include the generation of wrapper code as described above. Code generation may also include the generation of infrastructural elements to optimize execution. For example it may be appropriate to generate a runtime or a helper library specific to the target architecture.

During code separation the code separation function infers which candidate components belong to a component type of the architectural template. Automated inference may be performed in a number of ways but generally involves determining how similar a component is to a component type. illustrates a flowchart of an exemplary embodiment inferring a component type during automated porting of applications with semantic guarantees.

In block the code separation function receives an architectural template comprising one or more component types as described with respect to above.

Recall that at this point there is an abstract syntax tree that supports input grammars of the programming languages of an original software application and output grammars of the programming languages of the target architecture. The abstract syntax tree also represents a parsing or static analysis of at least some of the source code the original software application. Accordingly the abstract syntax tree contains components comprised of a functional source code block with an invocation interface that guarantees the semantic behavior of the functional source code block.

Thus in block the code separation function marks the components in the abstract syntax tree as at least one of the component types of the architectural template. This results in an abstract syntax tree with a number of candidate components. It also results in a number of candidate components that are not necessarily organized by component type and therefore may need repositioning.

To perform the repositioning in block a distance function for component types is defined in terms of parameters comprising predetermined criteria. A distance function for component types provides a similarity score for component to a component type. The distance function typically supports a metric for example a Euclidean distance. In this way the distance function provides a way to perform deterministic sorting where the components are ordered monotonically based on similarity to a component type. This ordering is performed in block by a graph reaccommodation algorithm that uses the distance function as a metric. Specifically the graph reaccommodation algorithm repositions components based on similarity to a component type.

One consequence of the ability to perform ordered sorting by component type is that the code separation function can identify the outer boundaries of each component type. Therefore the invocation interfaces on the outer boundaries may be configured to guarantee semantics and the interior components that do not face components from other component types may potentially be refactored without changing semantics. For example a middle tier object having a business object component type that faces client objects might not change its invocation interface but a business objects that face other business objects might be merged or otherwise modified.

The distance function may be a function of one or more predetermined criteria which allow the distance to be weighted. Examples include but are not limited to component similarity component affinity and component performance based on component proximity. For component similarity the distance measure may directly calculate how similar a component is to a component type. For component affinity the distance measure may modify the calculation how similar a component is to a component type based on similarity to other components known to belong to that component type. For example a radio button may be classified as a client component type if it is measured as similar to a standard button which was beforehand classified as a client component with high confidence. For component performance the distance measure may be modified in terms of performance metrics. For example a stateless business object that would ordinarily be grouped with other middle tier objects might be placed instead with client objects to limit network round trips. Thus even though the stateless business object is classified as a business object and likely would be placed in a middle tier the distance measure may be weighted to place stateless business objects closer to the client component type.

The predetermined criteria may be have been received with an architectural template. For example an architectural template may have enumerated the advantages and disadvantages of a target platform. Based on those advantages and disadvantages the distance function may be weighed to favor one component type over another based on the characteristics of a component. The advantages and disadvantages may not be specific to component type but may indicate a change in operation such as in a service oriented architecture specifying that some objects should be stateless objects to facilitate scalability. Alternatively the predetermined criteria may be independent of architecture and not necessarily have been received with an architectural template. For example business policies and enterprise standards may be specified as the predetermined criteria for the distance function.

There are several examples of graph reaccommodation algorithms. One example is simulated annealing. Simulated annealing is a well known algorithm where a large graph of objects may be organized. In the present example the components comprise nodes in the graph and the distance function defines the strength of connections between the nodes of the graph. The distance function is used to define a value to be tested for extrema e.g. in this case typically a minima After establishing an initial positioning and the extrema value the simulated annealing function iterates through potential repositionings. Where a repositioning improves the extrema value e.g. a lower value is discovered if testing for minima the repositioning is replaces the prior positioning. When a predetermined threshold is satisfied for example a time limit or a desired extrema threshold the simulated annealing iteration stops. The components in the abstract syntax tree are then repositioned according to the final positioning determined by the simulated annealing algorithm.

Another example of a graph reaccommodation algorithm is to use develop a lattice comprising multiple dimensions each dimension corresponding to a component type. Components are then placed in the lattice according to similarity to the component type. A force function describing affinity between the components is then described. A first repositioning is then effected by first applying the force function to determine the degree of repulsion between the components. A second repositioning is then effect by then applying the force function to determine the degree of attraction between the components. The result is a repositioning of the components where components of similar component type aggregate.

In general the where the overall ordering of a system may be represented based on component distances based on the distance function the system may be deterministically reordered such that the components aggregate to their likely component types. One may consider variations on linear programming where a tableau describing the graph of components may be pivoted to a desired extrema. Accordingly this patent application describes various graph reaccommodation techniques without loss of generality.

Regardless of the graphic reaccommodation algorithm used or the distance function used once the candidate components are repositioned in block the code separation algorithm may infer which candidate components have which component types based on the repositioning. At this point the repositioned abstract syntax tree is ready for code generation as described with respect to above.

The aforementioned code separation techniques may be used for a number of transformations. By way of example a typically application is to port a legacy client server application to a web based service oriented architecture SOA .

In this example the server portion of the client server application is hosted on a web infrastructure such as a cloud infrastructure. The client application may continue to be accessible via a personal computer but as a web application. Furthermore the client application may also be ported to various tablet targets and or mobile phone targets.

A typical software architecture is the model view viewmodel which is used as the target architecture. Therefore component types of model view and viewmodel are derived from the target architecture. Roughly speaking the model may be the client side local data model such as an extensible markup language XML data island. The view may correspond to a client hypertext markup language HTML and cascading style sheet CSS client with embedded JavaScript that accesses the XML data island. Finally the viewmodel may be a server side web service that serves the data island. illustrates a flowchart of an exemplary embodiment of automated porting of applications with semantic guarantees in a port to a model view viewmodel target architecture.

As described with respect to above source code for a software application may be parsed or statically analyzed to generate one or more abstract syntax trees that capture the semantic and syntactic elements of the source code. In the present MVVM example we assume the software application is written using an application framework that includes one or more user interface container classes. For example .NET may include a Windows Form and the Microsoft Foundation Classes include Dialog Box Form and Window and Document View classes. In block one or more abstract syntax trees for the software application are received.

In block an architectural template specifying a front end component type and a back end component type is received. In the present example the model view portion of the target architecture corresponds to the front end component type and the viewmodel portion of the target architecture corresponds to the back end component type. Other mappings may exist. For example a view controller portion of a model view controller architecture may correspond to the front end component type and the model portion may correspond to the back end component type. Thus while the present example is directed to MVVM architectures other architectures with a front end component type and a back end component type are supported without loss of generality.

In block the abstract syntax trees are traversed or otherwise queried for all instances of components that are a user interface container class in the application framework. Those components are then typed as front end component types.

In block the identified user interface container components are iterated. For each user interface container component all components contained by the container class are grouped together. In block a respective back end component set is created. At this point the back end component set starts as an empty set.

In block the components contained by the container class are iterated through. As each component is iterated in block the code separation function seeks back end indicia for the component in block . If back end indicia are detected then in block the component is added to the respective back end component set and the component type is changed to back end component type. Otherwise in block the next component is retrieved. If the iteration is complete then execution proceeds to block .

There are a number of back end indicia. For example the attributes of a component may be reviewed for references. If the references are made solely by business logic or persistence functions then the component may be likely to be a back end component. Framework class type may also assist. Many classes in an application framework are known to be either front end or back end types. Accordingly the application framework type may be indicia of being a back end component type or not being a back end component type . In other situations a component may be compared to another component known to be a back end component type. Where the similarity satisfies a predetermined threshold the component may be determined to be a back end component type.

The foregoing is not intended to be an exhaustive list of back end indicia. Where an IDE or development tool is used in the code separation process a technician may identify new heuristics or back end indicia and may modify the code separation process accordingly.

In block the code separation function determines whether there is another user class component to iterate. If there is then execution returns to block . Otherwise execution continues to a next phase in block . At this point after execution the components are now typed either as front end component types or as back end component types completing the component type inference such as in block of .

One use case of code separation is to port a legacy application to a mobile application. As described above code separation takes source code for a legacy application and identifies candidate components that correspond to architectural classes. In the case of generating a mobile application architectural classes at least include a mobile component to be hosted on a mobile computer and a server component to be hosted on an application server perhaps implemented on a web server in a cloud.

Legacy enterprise applications often assumed relatively homogenous clients specifically personal computers running the same operating system displaying large monitors with 4 3 aspect ratios. In contrast mobile computers range from smart phones and tablets with different operating systems different aspect ratios and different connectivity capabilities. For example it is not unusual for different cellular carriers to sell different smartphones with different operating systems where the operating system is specific to the cellular carrier.

Porting a multi tier enterprise application to the above mobile architecture includes accounting for architecture specific issues. Such issues may include the following classes of porting use cases each typified by a mobile architecture being constrained or less capable than a desktop architecture.

Mobile architecture may be constrained by form factor. Mobile form factors that is the size and hardware user interface of the hardware of the mobile client is generally smaller and more diverse than desktop platforms. A mobile application may have to simultaneously support different smart phones different tablets as well as personal computers. Accordingly the supporting multiple form factors as well as smaller form factors constitutes a constraint.

Mobile applications may also be constrained by the latency of a distributed cellular network. Legacy enterprise applications often could rely on 100 Mbps Ethernet connections. In contrast mobile computers may range from slow 2G connections to fast 4G LTE connections. In some cases mobile computers can perform WiFi offload if close to a WiFi access point. However the reality is that network latency is an issue for a mobile application to manage.

Mobile clients may vary not only by hardware but also by platform. A software platform generally includes an operating system and an application framework. A software platform along with the form factor of the mobile device constitutes a framework specific architecture. A framework specific architecture may be constrained compared to a desktop. Alternatively the variations of a framework specific architecture may constitute a constraint.

Specifically in many cases the operating system may vary by cellular carrier where different cellular carriers modify the operating system. Modifications to the operating system are often a result of self optimizing network SON functionality distributed by cellular carriers as described below. The operating system may support have a software platform such as a run time and a library that constitute an application framework. Examples include the Java Virtual Machine and the .NET application framework. Mobile devices participate on the Internet. Accordingly mobile devices may access third party web services. A common example includes using a social network such as FaceBook for authentication. This example is described in more detail below. These third party web services constitute an extension to the mobile device s platform. Targeting a specific framework an extension to the platform or alternatively a lowest common denominator of frameworks all constitute constraints.

Mobile devices have capabilities and regulations that constitute constraints on architecture. Specifically those capabilities and regulations may be addressed by wrapper code or potentially by added infrastructure elements.

Unlike desktop computers mobile devices roam. Since different geographical regions have different networks mobile applications may have to account for changing networks. Accordingly the architecture may be constrained by geographic region. For example a user roaming from a high coverage urban area to a low coverage rural area may have to account for dropped connectivity and may throttle network use to preserve quality of service.

Mobile devices that participate on a cellular network are constrained by cellular network regulations. Accordingly additional infrastructure elements may have to be added to a ported mobile application. For example Emergency 911 E 911 regulations may block internet protocol calling applications where the user s address has not been set. A ported mobile application may have to have an address check added to the application. E 911 is described in more detail below.

Target hardware of mobile devices and its supporting operating system may also vary. For example some smartphones include a stylus or other alternative hardware input devices. Other smartphone manufacturers add new user interface gestures or software input alternatives to the operating system. These new alternatives constitute an extension to the software framework and the hardware architecture.

For these use cases classes as well as other mobile application specific issues code generation includes the generation of wrapper code and infrastructure elements to mitigate these issues as described in the following paragraphs.

Form factor management includes code transformations specific to a mobile application itself to a mobile application managing multiple form factors and a mobile application managing different platforms from different cellular carriers.

In managing code transformations specific to a mobile application the key issue is in fitting an application that originally targeted a 17 to 24 monitor to a 4 to 5 smart phone screen. Merely scaling the application down results in user interface elements such as buttons and text boxes and other controls being too small to read or activate. Accordingly the user interface typically has to be redesigned to move user interface elements around to fit on the screen of a mobile computer while maintaining accessibility.

Different classes of transformations include rearranging the location of user interface elements eliminating selected user interface elements and substituting user interface elements. An example rearranging transformation includes moving user interface elements closer together without reducing the size of the user interface elements. An example elimination transformation includes removing pictures and logos from the mobile version of an application. An example of substituting user interface elements may be to separate panes in a web page into separate web pages.

Typically some combination of the three classes of transformation may be used. For example a particular web application may subdivide applications into divisions each with their own set of user interface elements. Some divisions may be displayed in side by side columns. One technique to compress the space used by a user interface is to transform the divisions such that they occupy only one column sequentially. Thus two divisions once displayed side by side are transformed to display sequentially in a column. Alternatively separate divisions might be simply moved to different screens within an application. Different screens may be easier to use if one of the divisions is particularly long.

In managing code transformations specific to a mobile application targeting multiple platforms the key issue is that an application user interface may have different versions for a personal computer as opposed to a mobile computer. During code generation either the user interface wrapper code or an infrastructure element could include code to identify whether the computer hosting the application was a personal computer as or a mobile computer. For example a web site might include either a java script or VBScript snippet to identify the hosting computer form factor. If the form factor was a personal computer the personal computer version of the application would run. If the form factor was mobile computer the mobile computer version of the application could run. Scripts can also identify operating system version and the specific mobile computer. Accordingly application versions specific to an operating system or a mobile computer could also be displayed according to a script.

Application versions may proliferate according to mobile computer. In an effort to differentiate platforms mobile computer vendors often expose proprietary functionality. For example Samsung Electronics supports a series of proximity gestures called Air Gestures . In order for an application to take advantage of Air Gestures a script may be written to determine whether the mobile computer was a Samsung device supporting Air Gestures . If so the version of the application supporting proximity gestures would appear or alternatively the corresponding feature in the application would be activated.

Mobile computers are regulated more than desktop personal computers. One set of regulations relates to Emergency 911 E 911 where voice over IP and other WiFi calling is activated only if the calling infrastructure can identify the user s location. In this way in event of a 911 emergency call the dispatcher can automatically identify the location of the emergency. To support this wrapper code and or infrastructure elements may be generated to provide location autopopulation services whenever voice over IP or other WiFi calling infrastructure is invoked.

Mobile application specific code generation is not limited to the client side. Enterprise applications were often written before third party web services proliferated. Many third party web services often in the social space such as FaceBook and Twitter presently expose application programming interfaces APIs that may be leveraged by applications. Accordingly wrapper code and or infrastructure elements may be generated to access those third party web services.

One special example of invoking third party web service APIs relates to security. FaceBook and other social web services may be delegated to for authentication. Instead of entering a proprietary user name and password an application may use FaceBook authentication instead via APIs. While the FaceBook APIs may be secure care must be taken to ensure that any user information used to invoke the API is secure. Accordingly any generated wrapping code and or infrastructure elements may add functionality to ensure parameters are not transmitted in plaintext but are otherwise encrypted.

As described above enterprise applications often were written with the assumption of a relatively fast network connection. Mobile applications contend with many issues including inconsistent coverage different connectivity technologies roaming data plan charges to name a few. A mobile application may be generated in such a way to account for network latency. Network connectivity optimizations may be generated either by adding functionality in the generated mobile application itself or by allowing the generated mobile application to take advantage of network optimizations created by the cellular carrier. In either case the generated mobile application may have a mobile component that contains client side network connectivity functionality and a server component may that contains server side network connectivity functionality.

There are well known application optimizations many of which are carryovers from client server architectures. Such optimizations include content caching where commonly requested content is statically cached. In the case of server side optimization content need not be dynamically generated thereby lowering response time. Furthermore if content such as images and other large binary objects are cached on the client side network latency is reduced since the cached objects need not be re requested.

Another application optimization is connection pooling. A server side network component may preallocate network connections. As a client finishes using a network connection the connection is not deallocated. Rather it is returned to a connection pool so that another client may use it. In this way the time to allocate the network connection is removed from network latency. Thus a mobile application may have a server side network component that implements a connection pool and a client side network component that utilizes network connections from the pool.

Since mobile computers have relatively unreliable network connections it is not unusual for a server to complete an operation send a change request to a client and for the client to no longer be connected. In the case of transactions this can lead to inconsistent state a violation of transactional properties. One solution is to implement so called lazy transactions. Specifically change requests are queued to the client. When the client reconnects it executes the change request completing the transaction. Where a predetermined time threshold passes the transaction may be rolled back. As with the previous features a mobile application may have a server side network component and a client side network component that implement lazy transactions.

The opposite of lazy transactions is to enforce synchronization of layers instead of allowing layers to synchronize when network connectivity is available we may enforce a synchronization event between layers almost immediately. This particularly is apropos for layers that reside in the cloud. For example in a Model View ViewModel architecture the ViewModel may reside in the cloud. Since a View component and a Model component of the ViewModel both are hosted in the cloud where network connectivity is generally available if the View component changes we can instantaneously notify the Model component of the ViewModel to update and vice versa.

Accordingly another application optimization that might be applied as a transformation during application porting is adding infrastructure to enforce timing for synchronization between layers. is an exemplary diagram illustrating enforced timing for synchronization between layers during automated porting of applications. In the layers are a client layer X and a server layer Y . An example client layer X may be a View component of a ViewModel layer and a Model component of a ViewModel layer. When the application is ported it is ported to corresponding client layer X and server layer Y . An additional infrastructure element a change detector is interposed in the ported application. When client layer X performs a state change such as a data change change detector detects the change. This may be done by notifications or events where the change detector subscribes to predetermined change events in client layer X or server layer Y and receives notifications when those change events occur. Change detector will then trigger corresponding changes in server layer Y or client layer X as needed. These corresponding changes may be implemented as event handlers. In order to be interface with change detector client layer X and or server layer Y may have wrapper code and or infrastructure elements added. Client layer X server layer Y and change detector may all reside in the cloud .

Not all scenarios making use of enforced timing are MVVM ViewModels. In some porting scenarios where a legacy enterprise application was implemented as a monolith it may be convenient to implement global state as a singleton. Accordingly the state of the singleton will be propagated to different instances or session of the ported application. In this case a change detector may propagate changes not only to client layer X and or server layer Y but also to application instances . In this way if a state change in a first application instance is to be propagated to a second application instance a change detector in the first application instance may propagate changes to its counterpart change detector in the second application instance via transport through the cloud. With this mechanism an instance with a singleton storing global state may propagate changes.

The largest savings in network latency overhead may be realized by generating a mobile application to take advantage of cellular carrier optimizations. The two most common optimizations are heterogenous network HetNet and self optimizing networks SON .

Heterogenous networks are networks that comprise both a cellular network and a WiFi network. Since smartphones typically support both cellular and WiFi it a smartphone application may be configured to offload high bandwidth data transfers to WiFi called WiFi offload and to prohibit high bandwidth data transfers unless a WiFi connection is present. In this way QoS may be increased. In a mobile environment many users find WiFi offload to be a key strategy in lowering data plan charges. In fact a mobile application may be optimized to minimize data plan charges as opposed to optimizing QoS.

Cellular networks also implement self optimizing networks SON . In a self optimizing network data is collected from the client application the mobile computer the base station access network and the core network. Based on the data routing and data throttling are implemented to optimize QoS. Accordingly in some infrastructures it is desirable for a generated mobile application to provide the data specifically collected by a self optimizing network. This data is generally automatically collected by the mobile operating system. However where documented additional data can be provided to the self optimizing network. In one example an application can request the routing priorities such as PDP priorities to vary in the core network. For example video may be given a lower priority from audio in a video call until a slide presentation is displayed.

In both cases wrapper code and or infrastructure elements may be generated to take advantage of HetNet and or SON. In many cases since the mobile operating system handles HetNet and or SON the application may simply be deployed with a configuration file that enables Het Net and or SON optimizations respectively.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

