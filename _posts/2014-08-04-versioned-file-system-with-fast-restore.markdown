---

title: Versioned file system with fast restore
abstract: A versioned file system comprises a set of structured data representations. Each structured data representation corresponds to a version, and each version comprises a tree of write-once objects. Each version in the versioned file system has associated therewith a borrow window. When it is desired to reconstruct the file system to a point in time, i.e., to perform a “restore,” it is only required to walk a single structured data representation. During a restore, metadata is pulled back from the cloud first, so users can see the existence of needed files immediately. The remainder of the data is pulled back from the cloud when the user goes to open the file. As a result, the entire file system is restored to a previous time nearly instantaneously. A fast restore is performed if an object being restored exists within a borrow window of the version from which the system is restoring.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274896&OS=09274896&RS=09274896
owner: Nasuni Corporation
number: 09274896
owner_city: Natick
owner_country: US
publication_date: 20140804
---
It is known to provide an interface between an existing local file system and a data store e.g. a write once store to provide a versioned file system. The versioned file system comprises a set of structured data representations such as XML. In a representative embodiment at a first time the interface creates and exports to a data store a first structured data representation corresponding to a first version of the local file system. The first structured data representation is an XML tree having a root element a single directory the root directory under the root element zero or more directory elements associated with the root directory and zero or more elements such as files associated with a given directory element. Each directory in turn can contain zero or more directories and zero or more files. Upon a change within the file system e.g. file creation file deletion file modification directory creation directory deletion and directory modification the interface creates and exports a second structured data representation corresponding to a second version of the file system. The second structured data representation differs from the first structured data representation up to and including the root element of the second structured data representation. Thus the second structured data representation differs from the first structured data representation in one or more but not necessarily all parent elements with respect to the structured data element in which the change within the file system occurred. The interface continues to generate and export structured data representations to the data store preferably at given snapshot times when changes within the file system have occurred. The data store comprises any type of back end storage device system or architecture. In one embodiment the data store comprises one or more cloud storage service providers. As necessary a given structured data representation is then used to retrieve an associated version of the file system. In this manner the versioned file system only requires write once behavior from the data store to preserve its complete state at any point in time.

A versioned file system comprises a set of structured data representations such as XML. Each structured data representation corresponds to a version and each version comprises a tree of write once objects rooted at a root directory manifest. Each version in the versioned file system has associated therewith a borrow window. When it is desired to reconstruct the file system or any portion thereof including just a single file to a point in time or more generally a given state i.e. to perform a restore it is only required to jump to and use a particular node in a single structured data representation and the identity of that node is known from the file being restored. During a restore an existing file or more generally a portion of the file system is associated into a new place in the file system which results in two identifiers e.g. filenames within the file system pointing to the same single object. Only the metadata for the existing file or file system portion being associated into a new place in the file system is necessary to do a restore thus a restore operation occurs quickly and without regard to the size of the file or file system portion . In effect the metadata for the file or file system portion being restored is pulled back from the cloud first so users can see the existence of needed files immediately. The remainder of the data is then pulled back from the cloud if when the user goes to open the file. As a result the entire file system or any portion thereof can be restored to a previous time nearly instantaneously. A fast restore is performed if an object being restored exists within a borrow window of the version from which the system is restoring.

The foregoing has outlined some of the more pertinent features of the subject matter. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed subject matter in a different manner or by modifying the subject matter as will be described.

The interface may be implemented as a machine. A representative implementation is the Nasuni Filer available from Nasuni Corporation of Massachusetts. Thus for example typically the interface is a rack mounted server appliance comprising hardware and software. The hardware typically includes one or more processors that execute software in the form of program instructions that are otherwise stored in computer memory to comprise a special purpose machine for carrying out the functionality described herein. Alternatively the interface is implemented as a virtual machine or appliance e.g. via VMware or the like as software executing in a server or as software executing on the native hardware resources of the local file system. The interface serves to transform the data representing the local file system a physical construct into another form namely a versioned file system comprising a series of structured data representations that are useful to reconstruct the local file system to any point in time. A representative VFS is the Nasuni Unity File System UniFS . Although not meant to be limiting preferably each structured data representation is an XML document or document fragment . As is well known extensible markup language XML facilitates the exchange of information in a tree structure. An XML document typically contains a single root element or a root element that points to one or more other root elements . Each element has a name a set of attributes and a value consisting of character data and a set of child elements. The interpretation of the information conveyed in an element is derived by evaluating its name attributes value and position in the document.

The interface generates and exports to the write once data store a series of structured data representations e.g. XML documents that together comprise the versioned file system. The data representations are stored in the data store. Preferably the XML representations are encrypted before export to the data store. The transport may be performed using known techniques. In particular REST Representational State Transfer is a lightweight XML based protocol commonly used for exchanging structured data and type information on the Web. Another such protocol is Simple Object Access Protocol SOAP . Using REST SOAP or some combination thereof XML based messages are exchanged over a computer network normally using HTTP Hypertext Transfer Protocol or the like. Transport layer security mechanisms such as HTTP over TLS Transport Layer Security may be used to secure messages between two adjacent nodes. An XML document and or a given element or object therein is addressable via a Uniform Resource Identifier URI . Familiarity with these technologies and standards is presumed.

The interface shown in may be implemented as a standalone system or as a managed service. In the latter case the system executes in an end user local file system environment. A managed service provider provides the system and the versioned file system service preferably on a fee or subscription basis and the data store the cloud typically is provided by one or more third party service providers. The versioned file system may have its own associated object based data store but this is not a requirement as its main operation is to generate and manage the structured data representations that comprise the versioned file system. The cloud preferably is used just to store the structured data representations preferably in a write once manner although the versioned file system as described herein may be used with any back end data store.

As described above the file system agent is capable of completely recovering from the cloud or other store the state of the native file system and providing immediate file system access once FSA metadata is recovered . The FSA can also recover to any point in time for the whole file system a directory and all its contents a single file or a piece of a file. These and other advantages are provided by the versioned file system of this disclosure as it now described in more detail below.

The second structured data representation may borrow unchanged parts of the first structured data representation. Thus the second structured data representation does not need to construct or even consider parts of the tree that were not changed it just points to the same c nodes that the first structured data representation does.

Moreover as noted it is possible but not required that a new version be created at the time of the actual change in the local file system typically the new version is created after a snapshot of the local file system is taken and a number of change events may occur during a given snapshot period. illustrates this approach. As seen in this drawing an FSA instance preferably aggregates all of the changes to the local file system in two ways delta frames and reference frames . The delta frames control the number and size of the objects that need to be stored in cloud storage. As noted above preferably every local file system event is recorded by the FSA instance as a change event . As noted new inodes directories and files trigger corresponding new entities created by FSA in the cloud however preferably modifications to existing structures create change events that are aggregated by FSA into a single new entity the delta frame . A delta frame starts with a new root that represents the current state of the file system. Preferably the FSA instance compiles the delta frame information such that each of the new entry points i.e. any modifications to the previous version to c nodes directories and files are represented as new versions of the data structures plus pointers to the old structures. To reconstruct the current state of a local file system an FSA client only has to walk a tree for any version to see all the correct items in the tree. Reference frames are also compiled by FSA and contain an aggregation of the previous reference frame plus all the intervening delta frames.

A given reference frame may be thought of as an entire copy with no references to previous versions while a delta frame may be thought of as including pointers to older versions. In other words a delta frame logically is a combination of a current version and one or more prior versions. Each frame reference or delta may be considered a complete file system from a tree walk perspective. This means that a walk of the tree by itself is all that is required to restore the file system or any portion thereof including a single file to its associated state or point in time as represented by the tree .

Preferably by pointing to the same c node that a previous version did each version is complete in and of itself. There is no need to regenerate a full copy of a given version as preferably each version is always full.

When it is desired to reconstruct the file system to a point in time or more generally a given state i.e. to perform a restore it is only required to walk use a single structured data representation a tree . In other words one and only one VFS tree may be used to identify a prior state of the local file system. It is not required to jump across multiple trees for this purpose.

Frames preferably are stored in an event pipe . As will be seen the event pipe is implemented in a structured data representation as a table of contents TOC although this is not a limitation. Preferably this data structure is held both at the FSA instance and at CCS as illustrated in . The event pipe with its entry points into cloud storage is then the primary means to access all files stored remotely. In particular one of ordinary skill in the art will appreciate that this is a lightweight data structure that preferably contains only versions of root for the given volume. Although it is desired that CCS be highly available preferably the writes occur periodically in a transaction safe way as controlled by FSAs. The reads are only necessary when an FSA copy has failed therefore CCS can be run using an ordinary high availability database or file based back end. Preferably the mix of delta and reference frames in the event pipe is chosen to balance storage and bandwidth utilization against a practical recovery time for FSA to create a new local file system instance. The composition of the event pipe can also be set according to a configurable policy. For instance users may choose to keep only so many versions or versions dating back to a specific date.

In a versioned cloud file system according to embodiment described in Ser. No. 12 483 030 filed Jul. 11 2009 the disclosure of which is incorporated herein by reference a versioned file system VFS comprises a set of structured data representations such as XML documents and document fragments. Names are object references that typically are not parsed by the system. The handle names typically have no relation to the actual file names or content. The handle names in the XML preferably are prefixed with a length component.

Also for items other than the table of contents TOC the path and version elements in the XML are informative and need not be used by the system. The path typically represents the originating path in the local file system when the item was last updated. The version typically represents the version of root at the time the item was last updated. The table of contents TOC is a table at the head of every version preferably the TOC contains references to all versions.

During a restore preferably metadata is pulled back from the cloud first so users can see the existence of needed files immediately. The remainder of the data is then pulled back from the cloud if when the user goes to open the file. As a result the entire file system or any portion thereof including a single file can be restored to a previous time nearly instantaneously. The metadata appears first and is stitched into the file system where it remains available for immediate use and then the cache gradually fills with the associated files as they are requested and as they are streamed back from the cloud . From the user s perspective however it will appear as if the data is actually present restored once merely the metadata is returned.

As used herein a fast restore is said to be performed if an object being restored exists within a borrow window of the version from which the system is restoring. During a fast restore the file or more generally file system portion being restored is associated into a new place in the file system which results in two identifiers e.g. filenames within the file system pointing to the same single object. As noted above the metadata for the file or file system portion being restored is pulled back from the cloud first so users can see the existence of needed files immediately. The remainder of the data is then pulled back from the cloud if when the user goes to open the file. This enables the file system portion to be restored to a previous time nearly instantaneously.

Typically a restore is triggered by a user choosing to restore his her its data. In a representative embodiment a user opens an interface e.g. a web based UI and selects a file data time snapshot etc. and selects a restore button. The system determines whether the restore will proceed on a fast basis based on a borrow window. By way of brief background each version in the versioned file system is identified as a particular version typically by a version number and has associated therewith a borrow window which preferably is an integer value. A most recently created version is a current version. In the context of a fast restore operation the borrow window of interest is the borrow window of the older version from which an object is being restored. As used herein this construct is sometimes referred to as the restore borrow window. Each individual version has its own associated borrow window and for a set of versions each borrow window may be different. A borrow window is sometimes referred to as a borrowing window or window. 

If a user initiated restore requires objects from a version outside the restore borrow window the system performs a slow restore with respect to versions outside the restore borrow window to copy from an old version to the latest version as necessary. The word slow in the phrase slow restore does not necessarily have temporal implications by definition a slow restore is a state or status associated with a new file that just happens to have the same name and content as an older file. The metadata for a new file like all new files is available when the file is written.

The following describes additional details of the preferred fast restore functionality. As noted above generally this function works by borrowing dependencies from one or more prior versions. Suppose it is desired to restore file A B C from version X to the current version Y at A B C. As noted above a version has a borrow window value typically an integer which value preferably is advertised. The borrow window for a version may differ from the borrowing window from another version. The fast restore process begins by determining the version created of all chunks of A B C in version X. For each chunk i in the manifest the fast restore operation sets the version created of i be V. Then a fast restore is permitted if and only if for all i Y V is less than or equal to the borrowing window advertised by version V. If this condition is met at an individual object level the fast restore function proceeds as follows.

The manifest for A B C in version X is already present in the cloud. Its handle is obtained. Then a new directory entry C in created in A B. This directory entry includes the same attributes as A B C from X this is the borrowing as well as the handle of the original file manifest that was just obtained. A next push then commits the modified directory A B to the cloud. As a result the chunk objects and manifest of A B C are now referenced from different versions X and Y.

In the versioned cloud file system each file is represented by a manifest object and a series of chunk objects. The manifest object comprises a listing of the chunk objects that make up the file and each entry in the manifest preferably comprises a handle an offset and chunk length. The entry also preferably identifies a number of the version in which the chunk was created. A directory in the versioned cloud file system is represented in a similar manner as is a file with the contents of the directory being a series of directory entries. A directory entry also comprises a name as well as other attributes for the file directory as well as the handle for the manifest that represents the contents of the file directory. As described a version is defined as the tree of objects rooted at a particular root directory manifest. A file system table of contents TOC contains the handle of a latest root directory manifest as well as a list of all previously root directory manifests. For each table of contents entry there is also preferably stored a timestamp version number and a borrow window as noted above preferably an unsigned integer . In the versioned cloud file system each of the objects is a write once object and versions often share objects file directory manifests file directory chunks .

Pruning a version as used herein means an operation starting from the root directory manifest for the version and deleting all objects in the tree that are not referenced in another version. A difficulty in pruning is dealing with the situation where items from that version have been borrowed by other versions. Thus for example assume that a first version V1 is created upon a write of file A and a write of file B. Now assume that a second version V2 is created upon a write file C and a delete of file B. If it is then desired to prune V1 it is not possible to do so by merely deleting all the objects that V1 references because File A is still being used i.e. borrowed by version V2. As noted above such sharing of objects is a characteristic of the versioned file system. As a consequence any pruning algorithm must take into consideration two 2 types of objects i objects in the pruned version that have been referenced from previous versions and thus should not be purged sometimes referred to as borrowed objects and ii objects created in the pruned version that are referenced restored in later versions sometimes referred to as lent objects . During pruning any objects that are borrowed or lent are not purged.

As will be seen during pruning preferably the search for lent objects is constrained by the borrow window of the version to be pruned and preferably the search for borrowed objects is constrained by the size of the borrow window of the version in which the borrowed object was created. Constraining the searches in this manner provides computational and storage efficiencies as the approach obviates scanning all versions backwards and forwards and limits the searching just to the versions within the above described windows.

Thus according to the teachings of this disclosure a borrow window is associated to each of a set of versions in the versioned file system. A version is then pruned by deleting all objects in the tree associated with the version that at the time of pruning i are not being lent to any other version within the borrow window of the version being pruned and ii are not referenced in any other version whose borrow window is sufficiently large enough such that an object in the version could have been restored from that other version. Another way of thinking about constraint ii with respect to a particular object in the tree associated with the version being pruned is that the object is deleted if it does not reside within the lending window of the version in which the object was created. If it is assumed that the borrow window of the version being pruned does not include the current version of the versioned file system then the temporal limitation at the time of pruning is not necessary as all of the objects associated with the version being pruned either are borrowed or not and this fact cannot change during the time the pruning is taking place . Thus pruning of versions that are still available for borrowing into the current version is not recommended and in one embodiment it not permitted at all.

The following describes in detail how a preferred pruning algorithm determines which objects in a tree are not referenced in another version.

Consider pruning a version X with a borrowing window Y. In one embodiment for each manifest in X the following characteristics are true i the manifest could be referenced from a previous version only if the directory or file did not change since the immediately previous version X 1 and ii the manifest could be referenced from a later version only if the directory or file did not change between X and an immediate next version X 1 . Thus to determine whether a manifest is referenced in a version besides X a check of all manifests in versions X 1 and X 1 suffices. If version X 1 is already pruned only the most recent version X needs to be used. In an alternative embodiment manifests can be borrowed.

Likewise with respect to chunks the following characteristics are true i for chunks created in X the chunk may be referenced in any version V where X

A pruning algorithm then proceeds as follows. Reference is made to the process flow shown in . At step all chunks and manifests in version X are first enumerated by walking the entire tree of X starting from the root directory manifest for X. All manifests in version X 1 or in a most recent version X if version X 1 has already been pruned are enumerated at step . Steps and may be carried out in reverse order or concurrently. At step the prune algorithm calculates bounds for each chunk search as follows define a minimum min X and define a maximum max X Y. For each chunk in the list of X if version created for chunk is max max version created borrowing window for that version. Note that if the borrowing window is not allowed to change then then max value will always be X Y although this is not a limitation. Then at step the routine searches for chunk references in the calculated search space defined by these bounds . Step enumerates chunks referenced in each version from min to max. Any chunk found in version not X is then removed from the list of objects for X if present . All objects remaining in the list for X are only referenced in X and may all be deleted. This completes the prune.

Thus preferably the pruning algorithm takes into account not only a version back and a version forward but also preferably all versions within a fast restore range i.e. a configurable borrow window . This ensures that the pruning operation can be carried out efficiently and in a scalable reliable manner. If the pruning operation were not constrained in this manner the operation would be difficult to scale efficiently once the number of versions becomes large due in part to the sharing of objects across versions .

In a typical prune operation the system may need to account for several borrow windows including some of differing values. For example assume that are ten 10 versions V1 . . . V10 that the first five versions V1 V5 each have a borrowing window of 10 and the next first versions V6 10 each having a borrowing window of 2. Now consider what happens when it is desired to prune version V9. Because of the first five versions V1 V5 have borrowing windows of 10 objects from V1 could be restored to any version as high as V11 objects from V2 could be restored to any version as high as V12 and so forth. Thus the prune algorithm must search for references in these early versions as well as more recent versions that may borrow the object. More generally the prune algorithm deletes a version from the versioned filed system by deleting all objects in the tree associated with the version that are not referenced in any other version whose borrow window is sufficiently large such that an object in the version could be restored from that other version.

One of ordinary skill in the art will appreciate that the interface described herein provides a primary local but preferably non resident application layer to interface the local file system to the data store. As has been described the interface caches user data and file system metadata organized in a unique manner to the data store e.g. one or more SSPs preferably as a service. The metadata provides a level of indirection from the data and the VFS enables it to be stored separately from the data that it represents.

While the above describes a particular order of operations performed by certain embodiments of the disclosed subject matter it should be understood that such order is exemplary as alternative embodiments may perform the operations in a different order combine certain operations overlap certain operations or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic.

While the disclosed subject matter has been described in the context of a method or process the subject matter also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including an optical disk a CD ROM and a magnetic optical disk a read only memory ROM a random access memory RAM a magnetic or optical card or any type of media suitable for storing electronic instructions and each coupled to a computer system bus. A computer readable medium having instructions stored thereon to perform the interface functions is tangible.

A given implementation of the disclosed subject matter is software written in a given programming language that runs on a server on an Intel based hardware platform running an operating system such as Linux. As noted above the interface may be implemented as well as a virtual machine or appliance or in any other tangible manner.

While given components of the system have been described separately one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions program sequences code portions and the like.

