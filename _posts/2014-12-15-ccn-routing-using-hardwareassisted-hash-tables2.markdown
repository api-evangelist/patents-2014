---

title: CCN routing using hardware-assisted hash tables
abstract: One embodiment provides a system that facilitates forwarding of packets with variable length names. During operation, the system receives a packet with a hierarchically structured variable length identifier (HSVLI) which comprises contiguous name components ordered from a most general level to a most specific level. The system performs a longest prefix match lookup by selecting an entry from a first data structure of entries. The entries indicate a name component, forwarding information for the name component, and a plurality of entry identifiers that chain an entry to another entry. If a size of the name component is less than or equal to a predetermined threshold, the system selects an entry based on the name component. If the size is greater, the system selects an entry based on a compressed key which can be a hash of the name component. The system also resolves collisions associated with the selected entry.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09590948&OS=09590948&RS=09590948
owner: CISCO SYSTEMS, INC.
number: 09590948
owner_city: San Jose
owner_country: US
publication_date: 20141215
---
The subject matter of this application is related to the subject matter in the following applications 

This disclosure is generally related to distribution of digital content. More specifically this disclosure is related to forwarding packets in a content centric network CCN by using hardware assisted hash tables in a CCN router.

The proliferation of the Internet and e commerce continues to create a vast amount of digital content. Content centric network CCN architectures have been designed to facilitate accessing and processing such digital content. A CCN includes entities or nodes such as network clients forwarders e.g. routers and content producers which communicate with each other by sending interest packets for various content items and receiving content object packets in return. CCN interests and content objects are identified by their unique names which are typically hierarchically structured variable length identifiers HSVLI . An HSVLI can include contiguous name components ordered from a most general level to a most specific level and can contain an arbitrary number of path segments e.g. name components of unbounded and variable length.

In general a CCN router maintains a forwarding table to determine how to forward a packet. The forwarding table can be a hash table where the key is based on a name component and the result contains the forwarding information for the name component. Network processors in a CCN router can increase the efficiency and speed of forwarding by providing hardware assisted hash tables. These hardware assisted hash tables typically restrict the key length and the result length to a fixed size. This restriction imposes limits on using these hardware assisted hash tables for forwarding packets in a CCN where forwarding is performed based on name components of unbounded and variable length which may be greater than the fixed length supported by the hardware assisted hash tables.

One embodiment provides a system that facilitates forwarding of packets with variable length names. During operation the system receives a packet with a hierarchically structured variable length identifier HSVLI which comprises contiguous name components ordered from a most general level to a most specific level. The system performs a longest prefix match lookup by selecting an entry from a first data structure of entries. The entries indicate a name component forwarding information for the name component and a plurality of entry identifiers that chain an entry to another entry. Each name component has a size. If the size of a name component is less than or equal to a predetermined threshold the system selects an entry based on the name component. If the size is greater the system compresses the name component to obtain a compressed key and selects an entry based on the compressed key. In response to determining a lookup collision associated with the selected entry the system resolves the lookup collision thereby facilitating forwarding of packets with variable length names.

In some embodiments in response to determining that the size of the name component is less than or equal to the predetermined threshold the system creates an entry in the first data structure based on the name component. In response to determining that the size of the name component is greater than the predetermined threshold the system performs a first compression function on the name component to obtain a compressed key and creates an entry in the first data structure based on the compressed key. In response to determining an insertion collision based on the created entry the system resolves the insertion collision.

In some embodiments the system creates an entry in a second data structure based on the name component wherein the second data structure indicates the name component and a corresponding index. The system sets a string identifier field in the entry for the name component in the first data structure to the index from the second data structure.

In some embodiments the system resolves the insertion collision by including a collision indicator in the created entry in the first data structure. The system performs a second compression function on the name component to obtain a new lookup key. The system also creates an entry in a third data structure based on the new lookup key wherein the third data structure indicates the new lookup key and forwarding information for the name component.

In some embodiments the system resolves the lookup collision by determining that the selected entry includes the collision indicator. The system performs the second compression function on the name component to obtain the new lookup key and selects an entry in the third data structure based on the new lookup key.

In some embodiments in response to selecting the entry in the first data structure based on the compressed key the system determines the index of the string identifier field for the selected entry and retrieves from the second data structure the name component based on the determined index. The system compares the name component of the HSVLI with the retrieved name component from the second data structure.

In some embodiments the plurality of entry identifiers includes a parent identifier and an entry identifier wherein the entry identifier is unique for each entry in the first data structure. For each name component beginning with a component at the most general level the system selects the entry based on the parent identifier wherein for the most general level name component the parent identifier of the entry corresponds to a predetermined initial value and for each subsequent name component the parent identifier of the entry corresponds to the entry identifier of an entry corresponding to the name component of a previous most general level.

In some embodiments the first data structure is a hash table of entries comprised of a key and a result wherein if the size is less than or equal to the predetermined threshold the key is based on the name component directly and if the size is greater than the predetermined threshold the key is based on the compressed key.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present disclosure. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

Embodiments of the present invention provide a system that solves the problem of using hardware assisted hash tables which are typically restricted to fixed length keys to forward CCN packets by mapping name components to a forwarding hash table and performing chained hash lookups in the forwarding hash table. Forwarding a CCN packet is typically based on a name associated with the packet which can be a hierarchically structured variable length identifier HSVLI that includes contiguous name components ordered from a most general level to a most specific level. The present system can map the name components of an HSVLI for insertion and lookup in the forwarding hash table of a CCN router based on the size of each name component. When the size of the name component is small e.g. less than or equal to 41 bytes the system creates a hash table entry using a standard hash table function where the key is the name component. When the size is big e.g. greater than 41 bytes the system creates the entry by first applying a compression function on the name component and using the compressed value as the key for the hash table. The system can also insert the uncompressed name component into a separate string table at a specific index and indicate that index in the result of the entry. If a collision occurs during insertion the system can set a flag in the result to indicate a collision generate a new lookup key and create an entry in a separate table using the new lookup key.

Furthermore the system uses the forwarding hash table to perform chained hash lookups which determines the forwarding information for a packet. During the insertion process the system assigns a unique index key e.g. an entry identifier EID to each result in the forwarding hash table. Each entry includes its own unique index key and also includes a pointer to the unique index key of the previous name component e.g. a parent entry identifier PEID . Another method of using the forwarding hash table in a CCN router is cumulative name component hashing described in U.S. Pat. No. 8 243 735 herein incorporated by reference.

To forward the packet the system parses through each name component of an HSVLI from the most general level to the most specific level using the unique index keys of each entry result to chain the lookups in the forwarding hash table for each name component. Similar to the insertion process the system looks up a name component by using the name directly if the size is less than or equal to a certain size and by using the compressed key if the size is greater. If a collision occurs during lookup the system can use the index included in the result of the entry to obtain the original uncompressed key from the separate string table and compare the uncompressed key with the name component of the HSVLI from the packet. Furthermore the system can detect that the result flag in the entry indicates a collision generate a new lookup key and perform a lookup in a separate table using the new lookup key. The result returned from the chained hash lookups referred to as the longest prefix match lookup is used to forward the packet. In this disclosure longest prefix match lookup refers to performing a lookup that returns a result matching the largest number of components from the most general level to the most specific level in an HSVLI. Thus by mapping the name components in a size based manner to the forwarding hash table e.g. the hardware assisted hash table maintained by a CCN router and by chaining the hash lookups with unique index keys the system can use hardware assisted hash tables in a CCN router to increase the efficiency of forwarding packets.

In examples described in this disclosure each piece of content is individually named and each piece of data is bound to a unique name that distinguishes the data from any other piece of data such as other versions of the same data or data from other sources. This unique name allows a network device to request the data by disseminating a request or an Interest that indicates the unique name and can obtain the data independent from the data s storage location network location application and means of transportation. The following terms are used to describe the CCN architecture 

Content Object A single piece of named data which is bound to a unique name. Content Objects are persistent which means that a Content Object can move around within a computing device or across different computing devices but does not change. If any component of the Content Object changes the entity that made the change creates a new Content Object that includes the updated content and binds the new Content Object to a new unique name.

Unique Names A name in a CCN is typically location independent and uniquely identifies a Content Object. A data forwarding device can use the name or name prefix to forward a packet toward a network node that generates or stores the Content Object regardless of a network address or physical location for the Content Object. In some embodiments the name may be a hierarchically structured variable length identifier HSVLI . The HSVLI can be divided into several hierarchical components which can be structured in various ways. For example the individual name components parc home ccn and test.txt can be structured in a left oriented prefix major fashion to form the name parc home ccn test.txt. Thus the name parc home ccn can be a parent or prefix of parc home ccn test.txt. Additional components can be used to distinguish between different versions of the content item such as a collaborative document. In some embodiments the name can include a non hierarchical identifier such as a hash value that is derived from the Content Object s data e.g. a checksum value and or from elements of the Content Object s name. A description of a hash based name is described in U.S. patent application Ser. No. 13 847 814. A name can also be a flat label. Hereinafter name is used to refer to any name for a piece of data in a name data network such as a hierarchical name or name prefix a flat name a fixed length name an arbitrary length name or a label e.g. a Multiprotocol Label Switching MPLS label .

Interest A packet that indicates a request for a piece of data and includes a name or a name prefix for the piece of data. A data consumer can disseminate a request or Interest across an information centric network which CCN routers can propagate toward a storage device e.g. a cache server or a data producer that can provide the requested data to satisfy the request or Interest.

The methods disclosed herein are not limited to CCN networks and are applicable to other architectures as well. An example of a CCN architecture is described in U.S. patent application Ser. No. 12 338 175.

Forwarding hash table can include forwarding information for HSVLI of shortname longname shortname by listing entries with a hash key and a result . Forwarding hash table can contain entries and . For short name components e.g. less than or equal to 41 bytes CCN router can use the name component directly in the hash key as in entry with a value of shortname and in entry with a value of shortname . For long name components e.g. greater than 41 bytes CCN router can first compress the name component by performing a compression function on the name component to obtain a compressed key K and use that compressed key Kin the hash key as in entry with a value of hash longname . The compression function can be based on a hash function a dictionary method or any other known method. Entry can also include a string identifier SID field that indicates the index to an entry in separate string table that stores the original uncompressed longname string. CCN router detects and handles insertion and lookup collisions as described in relation to . In some embodiments forwarding hash table includes one table for short name components e.g. entries and that does not include an SID and another table for long name components e.g. entry that does include an SID. Compressed and uncompressed keys can be stored in different tables e.g. corresponding to the data structures shown in for uncompressed keys and for compressed keys. Entries in forwarding hash table can also include a bit in the key to indicate whether the key is compressed or uncompressed.

Furthermore CCN router forwards packet by performing chained hash lookups in forwarding hash table to determine the longest prefix match for HSVLI . CCN router computes the key for the first name component shortname . Because the first name component is no longer than a threshold it uses an uncompressed key Kequal to a PEID concatenated with the literal name component e.g. hash key of entry . The system looks up Kin the uncompressed key hash table. The hardware assisted hash table will then produce the corresponding result. If a match is found based on K the results will contain an EID and corresponding forwarding information for the name e.g. result of entry . The system then proceeds to look up the next name component longname . Because this name component is longer than a threshold it computes a compressed key Kequal to a PEID concatenated with a hash of the name component e.g. hash key of entry . In this case the PEID is the EID returned from K. The system looks up Kin the compressed key hash table. The hardware assisted hash table will then produce the corresponding result. If a match is found based on K the results will contain an EID and corresponding forwarding information for the name e.g. result of entry . The EID can be a small number efficiently and uniquely compressing the previous key. The system continues these chained hash lookups for each subsequent name component and the result returned from the most specific level name component shortname is the longest prefix match e.g. forwarding information of result for entry .

If the length is less than or equal to a predetermined size e.g. 41 bytes decision the system compresses the name component by e.g. hashing the name component to obtain a compressed key K operation . The system creates an entry in the hash table using the compressed key K operation . If the system does not detect a collision upon inserting the entry based on the compressed key decision the system inserts the original uncompressed string into a string table at a specific index and includes a string identifier SID in the result of the entry in the forwarding table with a value set to the specific index value operation . The SID is a pointer to a table storing the uncompressed key value. If the system does detect a collision upon inserting the entry based on the compressed key decision the system sets a result flag in the entry to indicate a collision operation . The system then generates a new lookup key and creates an entry in a collision table using the new lookup key operation . The system performs operation as described above. Subsequently the system determines whether any name components remain to be processed decision and if any name components do remain to be processed moves to the next name component operation to begin the insertion process for the next name component operation .

If the length is greater than a predetermined size e.g. 41 bytes decision the system compresses the name component by e.g. hashing the name component to obtain a compressed key K operation . The system looks up the value in the forwarding table using a key based on the PEID and the compressed key K operation . If a match is not found the system returns the match that is currently stored in temporary storage R operation . If a match is found the system determines a string identifier e.g. index value for the result and retrieves the entry from the string table corresponding to the index value of the string identifier SID operation . As described above the SID is a pointer to a table storing the uncompressed key value. The system stores the matched result in temporary storage R operation . The matched result contains the unique EID that is used to chain the hash table lookups as described above. The system determines if a collision is detected in the lookup based on the compressed key decision . If a collision is detected in the lookup based on the compressed key the operation continues as described in . If no collision is detected the system determines if any name components remain to be processed decision . If there are no name components left the system returns the match that is currently stored in temporary storage R operation . If more name components remain to be processed the system goes to the next name component and sets the PEID of the next name component to the EID of the current result operation . Subsequently the system returns to operation to begin the lookup process for the next name component.

The system can also determine that the entry in Rindicates a collision based on a flag in the result indicating a collision operation . The system generates a new lookup key operation by applying a hash function that is both different from the hash function applied to obtain the compressed key of operation in and the same as the hash function applied to generate the new lookup key upon insertion as in operation of . The system looks up the result in the collision table using the new lookup key operation and stores the collision table results in temporary storage R operation . Subsequently the system passes R back to operation of to continue processing the HSVLI operation .

In some embodiments e.g. the NP4 entries in a hardware assisted hash table are limited to 36 bytes per entry where the key and result together are less than or equal to 32 bytes and 68 bytes per entry where the key and result together are less than or equal to 64 bytes. Data structures and meet these limits. Data structure represents an entry in the forwarding hash table where the value of the key e.g. name component is 9 bytes and data structures and represent entries with values for larger strings 21 and 41 bytes respectively . Data structure represents an entry with a key of a length longer than 41 bytes where the network processor uses a compressor or hash function to obtain a compressed key hash of 16 bytes in length. Thus data structures and 26 and 32 bytes respectively will both fit in 32 bytes while data structures and 38 and 58 bytes respectively will result in 64 byte entries. Note that because data structure results in the same amount of memory and the same number of cycles as the larger entry of data structure in some embodiments the system may not use data structure . In addition the data structures for uncompressed keys e.g. data structures and can include length encoded name components. For example data structure has a TLV that includes type field length field and value field . Hence when a literal name component is used as part of the key e.g. PEID name component in an uncompressed key the system can accurately determine the value because the remainder of the 41 bytes will be zero padded.

The following use case for HSVLI is based on the exemplary tables presented and described in relation to and and the methods disclosed herein. During operation a CCN forwarder or router can receive an interest with an HSVLI of apple pie longname good. The system finds the longest prefix match by looking up a first forwarding entry based on a hash key with a PEID of 0 concatenated with the short e.g. less than or equal to 41 bytes string apple of the most general level name component. The forwarding hash table returns a result with an EID of 2 entry which the system then uses as the PEID to lookup the next forwarding entry. The system looks up the next forwarding entry based on a hash key with a PEID of 2 concatenated with the short string pie of the next most general level name component which returns a result with an EID of 4 entry . Next the system looks up the next forwarding entry based on a hash key with a PEID of 4 concatenated with the hash value of the long e.g. greater than 41 bytes string longname which returns a result with a collision flag set to 1 that indicates a collision as well as an SID with a value of 2 entry . The system can determine that the collision is due to two hash keys resulting in the same forwarding entry e.g. hashing to the same bucket . The system can perform a new hash function on the uncompressed key to obtain a new hash key use that new hash key to obtain the forwarding entry result in a separate collision table and return that value to as the result for entry . In another example a lookup on an HSVLI of cherry pie longname z would result in a chained hash lookup based on PEIDs chained to previous EIDs resulting in entry entry and entry . Upon determining that a collision flag in entry is set to 1 indicating that the hash of the name component longname z from HSVLI is the same as the hash of the name component longname from HSVLI the system performs the new hash function as described above to obtain a new hash key and uses the new hash key to obtain the appropriate forwarding entry result from the separate collision table.

Additionally the system can determine that the collision occurs because a name component of the HSVLI does not exist in the forwarding hash table but its hash collides with an existing entry. The system can use the SID of entry to obtain the uncompressed key stored in a separate string table compare the obtained string with the name component of the HSVLI in the packet memory and proceed accordingly. As discussed above this comparison can yield a Boolean result which indicates whether or not the string from the packet memory exists in the string table and hence is the correct entry in the forwarding hash table . For example a lookup on an HSVLI of apple pie longname tasty yields a chained hash lookup resulting in entry and entry . If the hash of the long string longname tasty of HSVLI results in the same value as the hash of the name component longname of HSVLI but the forwarding hash table does not contain an entry for longname tasty this collision cannot be detected during the insertion process. In this case the next lookup yields entry and the system determines correctness by retrieving the string indicated by SID 2 in result and performing a string comparison between the retrieved string e.g. longname and the string of the name component from HSVLI from the packet memory e.g. longname tasty . The system determines that the two strings are not equal indicating that even if entry is returned as a match it is an incorrect match. Subsequently the system can return the previous match forwarding entry as the longest prefix match for HSVLI e.g. entry .

Returning to HSVLI the system determines after the collision resolution and correctness checks that entry contains the result for the correct forwarding entry based on a hash key of 4 concatenated with the hash value of the string longname . Entry contains an EID of 5 which the system uses as the PEID for the next lookup which has a hash key with a PEID of 5 concatenated with the short string good. This lookup yields a result with an EID of 6 a slot bitmap and an RID. Because there are no further name components to be processed in HSVLI the forwarding entry for entry contains the longest prefix match and is used by the CCN router to forward the packet.

Content processing system can include instructions which when executed by computer and communication system can cause computer and communication system to perform methods and or processes described in this disclosure. Specifically content processing system may include instructions for sending or receiving a packet with an HSVLI over a computer network communication mechanism . Content processing system can also include instructions for performing a longest prefix match lookup in a forwarding hash table lookup mechanism . Content processing system can include instructions for inserting entries into a forwarding hash table insertion mechanism . Content processing system can include instructions for in response to determining a collision upon an insertion or a lookup in the forwarding hash table resolving the lookup collision collision resolution mechanism .

Content processing system can additionally include instructions for comparing an entry in a string table to a name component in packet memory string comparison mechanism . Content processing system can include instructions for assigning unique entry identifiers to chain one entry to another entry chaining mechanism .

Data can include any data that is required as input or that is generated as output by the methods and or processes described in this disclosure. Specifically data can store at least a packet with an HSVLI a forwarding hash table a string table and a separate collision table as described in this disclosure and a parent identifier PEID and a unique entry identifier EID for each entry in the forwarding hash table.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore the methods and processes described above can be included in hardware modules or apparatus. The hardware modules or apparatus can include but are not limited to application specific integrated circuit ASIC chips field programmable gate arrays FPGAs dedicated or shared processors that execute a particular software module or a piece of code at a particular time and other programmable logic devices now known or later developed. When the hardware modules or apparatus are activated they perform the methods and processes included within them.

The foregoing descriptions of embodiments of the present invention have been presented for purposes of illustration and description only. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims.

