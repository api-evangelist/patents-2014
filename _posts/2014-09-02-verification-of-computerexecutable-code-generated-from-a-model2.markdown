---

title: Verification of computer-executable code generated from a model
abstract: In an embodiment, a model is sliced into a plurality of slices. A slice in the plurality of slices is selected. A portion of code, that corresponds to the selected slice, is identified from code generated from the model. The identified code is verified to be equivalent to the selected slice. Equivalence may include equivalent functionality, equivalent data types, equivalent performance, and or other forms of equivalence between the selected slice and the identified generated code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09612806&OS=09612806&RS=09612806
owner: The MathWorks, Inc.
number: 09612806
owner_city: Natick
owner_country: US
publication_date: 20140902
---
Sep. 30 2011 which claims priority to and the benefit of U.S. Provisional Patent Application No. 61 494 274 titled VERIFICATION OF COMPUTER EXECUTABLE CODE GENERATED FROM A MODEL which was filed on Jun. 7 2011 and U.S. Provisional Patent Application No. 61 509 371 titled VERIFICATION OF COMPUTER EXECUTABLE CODE GENERATED FROM A MODEL which was filed on Jul. 19 2011. Also this Application is a continuation in part of U.S. patent application Ser. No. 12 559 233 titled VERIFICATION OF COMPUTER EXECUTABLE CODE GENERATED FROM A MODEL which was filed on Sep. 14 2009 and which claims the benefit of U.S. Provisional Patent Application No. 61 103 167 titled MODEL STYLE GUIDELINE VERIFICATION AND ANNOTATION which was filed on Oct. 6 2008 and U.S. Provisional Patent Application No. 61 103 161 titled VERIFICATION OF COMPUTER READABLE CODE GENERATED FROM A MODEL which was also filed on Oct. 6 2008. All of the above identified applications are hereby incorporated by reference in their entirety as though fully set forth herein.

The accompanying drawings which are incorporated in and constitute a part of this specification illustrate one or more embodiments described herein and together with the description explain these embodiments. In the drawings 

The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar features illustrated in the drawings. Also the following detailed description does not limit the invention.

Code generated from a model may need to be verified to ensure for example that the code properly represents the model and does not introduce unintended side effects. The code may be generated by a code generator and verified by a code verifier. Different verification objectives may be of interest depending on a specific verification task at hand. Code verification may be important to safety critical software systems. Moreover code verification may be required by various government industry or company wide standards and or may be useful for testing or implementing a system using the generated code.

Code verification may focus for example on analyzing data dependencies without verifying aspects related to execution times. Moreover code verification may emphasize verifying algorithmic parts e.g. operands operators of the code instead of verifying data types of operands used by the code. Here for example the algorithmic parts of a fixed point algorithm may be verified even if chosen fixed point scalings may not be verified.

Verifying generated code by hand may be a costly and time consuming process. As the complexity of models grow complexity of verifying code generated for the models may grow. In addition to an automation of the verification it may be desirable to do an additional limited manual review. In some instances automating a full verification of code may not be possible. Here the code may be partially verified automatically and partially verified manually. Regardless providing at least a partial verification of the code automatically may still be useful and may involve less effort than if the code were to be completely verified manually.

A code verifier may be used to automatically verify that code generated from a model represents functionality of the model. The code verifier may receive a model which may be in an intermediate representation IR form and the generated code which may also be in an IR form. The code verifier may create further IRs of the model and or the generated code to compare functionality and or other verification objectives presented in the received model and generated code.

The code verifier may create an element connectivity list ECL for the model. An ECL may be an example of an IR that may be created by the verifier. The ECL may represent elements of the model model elements such as for example blocks and connections between the elements. The model from which the ECL may be created may be for example a graphical model a textual representation of a graphical model and or a textual model.

The model may comprise graphical aspects e.g. graphical blocks and textual aspects e.g. blocks defined textually . The model may be for example a time based model an event based model or another type of model. A time based model may be a model where state transitions in the model depend on time. A time based model may include model elements that are represented by entities in an ECL for the model. An event based model may be a model whose execution is event driven. An example of an event based model may be a state chart e.g. a Simulink statechart . States may constitute model elements in an event based model and may be represented by entities in an ECL for the model.

The code verifier may also receive or create an internal representation of the generated code. Such internal representation may be for example an abstract syntax tree AST . The AST may be an IR that may represent statements data data flow and control flow within the generated code.

To verify the generated code the code verifier may locate code components in an AST that correspond to entities in an ECL and note the correspondence or lack thereof. The code verifier may also generate a report of verification details and verification failures if any. A verification failure may be signified for example by one or more AST components that are not identified as corresponding to one or more ECL elements and or by one or more ECL elements for which certain corresponding AST components have not been found.

The code verifier may create or receive one or more program dependency graphs PDGs including a PDG for the model PDG M . PDGs are also examples of IRs. The PDG M may represent model elements and data and control relationships associated with the model. The PDG M may be created from for example the model a graphical representation of the model e.g. a block diagram and or a textual representation of the model. The model may include both graphical and textual features. The model may be a time based model an event based model or other type of model. The model may contain blocks which may be considered model elements of the model. The blocks may be represented by entities in a PDG M. Moreover a model may be event driven and contain states which may be considered model elements of the model. The states may be represented by entities in a PDG M.

Code may be generated from the model. The code verifier may create or receive a graph that may be generated from the code. The graph may be a PDG for the code PDG C . The PDG C may represent elements of the code such as statements and data and data and control relationships in the code.

To verify the generated code the code verifier may 1 locate code components in a PDG M for the model that correspond to entities in a PDG C for the generated code and 2 identify a correspondence or lack thereof between the code components and the entities. The verification tool may also transform the PDG M the PDG C or both into a normal form before attempting to identify the correspondence. The code verifier may also generate a report of verification details and verification failures if any. To support partial verification the report may also identify model or code elements that were outside of the scope of the actual verification.

The code verifier may slice an IR to identify parts of an IR that may be for example verified independently of each other. The code verifier may attempt to verify the different slices sequentially or in parallel. A report which may be generated by the code verifier may include information about the slices. To support partial verification the report may also include verification results for different slices separately. As an example the code verifier may create one or more slices for a model output that contain those model elements contributing to the output.

The code verifier may provide information to a user that indicates changes may be made to the model to improve slicing.

Elements of an IR generated from a model or generated code may also be tagged with type information to identify elements of the model or generated code that may be relevant with respect to a given verification objective.

In a code generation stage of the code optimization of the generated code may be desirable. Optimization may remove some elements of the model. In addition a single statement of the generated code may represent functionality from multiple model elements. To provide meaningful verification of the generated code the code verifier may use information regarding kinds of optimizations or transformations that may take place during code generation.

The code verifier may support a restricted subset of possible model elements and or a restricted subset of connections. The restricted subset may be determined based on model elements that may generate allowable patterns in the generated code and or based on various code verification considerations.

A received model may be checked for compliance with the restricted subset of possible model elements before during or after generating the ECL or PDG M. The code verifier may report violations within the model when for example one or more elements in the model are not supported by the code verifier or are outside a particular restricted subset within which the code verifier may operate. Verification may be aborted or not started until some or all of the violations are removed. For example verification may proceed on the subset of the code generated from the portions of the model supported by the code verifier and the remaining sections of the generated code may remain unverified or left for manual verification. The generated code the model or one or more of the IRs may be marked up in accordance with determinations made by the code verifier.

If the code verifier encounters for example an unsupported model element the code verifier may treat the model element as a black box and may focus verification on interfaces to the unsupported model element. Other features associated with the model element e.g. the model element itself output interfaces associated with the element may be left for manual verification. Model elements that are partially verified by the code verifier may be marked up in results provided by the code verifier. For example the model elements may be noted as conditionally verified model elements in the results. A report containing the results may include information about remaining model elements or objectives left for manual verification and information about tracking a success of steps taken during manual verification.

The code verifier may wrap unsupported model elements into containers e.g. blocks with well defined interfaces to simplify interface verification. The code verifier may attempt to group multiple unsupported model elements into a single container.

Annotations may be provided for unsupported model elements. The annotations may include tokenized information of what code is expected for a particular model element. The verification tool may use this information when verifying the model element in its specific context for the actual model and code pair or in future verifications that include the same model element. In addition annotations may be added to a library to extend a supported subset.

Depending on a corresponding code pattern found for an unsupported model element the code verifier may suggest a corresponding code pattern for this model element. Instead of annotating the tokenized information from scratch a user may check the tokenized information suggested by the code verifier for correctness. A compliance checker may interactively or automatically modify the model to replace unsupported model elements or user settings with equivalent model elements or settings that are within a supported subset.

Marking of the generated code model and or IRs may be performed in many different ways. For example markups may include color visualization that may be used to differentiate sections of code corresponding to different sections of the model. Here a first color may be used to mark portions of the generated code that correspond to portions of the model that have been verified by the code verifier and are not found to contain errors a second color may be used to mark errors located by the code verifier a third color may be used to mark portions of the generated code for which the presence or absence of errors could not be verified and a fourth color may be used to mark portions of the generated code that correspond to portions of the model that are not supported by the code verifier. Moreover mark ups may be shown through text and or visual clues. In addition a user may be presented with a user interface for browsing the generated code according to what portions of the model it comes from and or according to mark ups. Portions of a model or code that are upstream or downstream of an unsupported or unverifiable portion of the model or code may be marked with yet another color.

A user may be able to manually review sections of the generated code that are not supported by the code verifier. The user may want to manually verify the sections of the generated code that correspond to sections of the model that fall outside of that predetermined set. Provisions may be provided to assist the user in locating and verifying the sections of the code that have not been verified by the code verifier.

Generated code may refer to code generated from a model or a portion of a model. Moreover generated code may include code generated from an IR. The generated code may be generated as source code or executable code. The generated code may include statements instructions written in such languages as FORTRAN ADA Python C C Java Java bytecodes Assembly MATLAB programming language Structured Text hypertext markup language HTML extensible markup language XML hardware description language HDL or unified modeling language UML . Models need not be solely graphical models and may be textual models and or a combination of graphical and textual models.

An element of an IR received or created by the code verifier may be linked to its corresponding counterpart in the model the generated code and or an IR. This linking may be provided for traceability purposes. The links may be called traceability links. Traceability links may be preserved when the IRs are transformed or modified by the verification tool. Traceability tags may be used to produce code to model or model to code traceability reports.

The code verifier may provide a mapping between elements of the model and portions of the generated code that have been verified to correspond to those elements. The code verifier may also indicate sections where verification is inconclusive or sections containing verification failures. Mapping between the model and the generated code may be bi directional. For example a graphical model may be mapped to generated code and vice versa. Bi directional mapping may facilitate graphical identification of portions of the graphical model that correspond to selected segments of the generated code. Bi directional mapping may also facilitate graphical identification of segments of generated code that correspond to selected portions of a graphical model.

Models may be developed based on a set of requirements that may be contained in one or more machine readable structures such as a text file a spreadsheet a word processing file a presentation application file database or repository. Such machine readable structures may be generally referred to as requirement documents for the model. The requirement documents may be subject to version control by a version control system to enable tracking of versions when requirements change. In some instances the tracing to requirements may be included in the model such that the traces to the requirements for the model and the design i.e. the model are in the same location. The requirements may be traced to the graphical model and or generated code to facilitate identification of requirements that trace to graphical affordances in a model and or segments in generated code.

Generated code may be generated in a programming language such as Sequential Function Chart Structured Text or another IEC 61131 language C C SystemC Java Javascript Python FORTRAN ADA an assembly language a hardware description language HDL such as Verilog VHDL very high speed integrated circuit hardware description language a register transfer language RTL or some other type of language. Implementations may further generate information about a graphical model using a programming language alone or in combination with the generated code discussed above. In an example an XML representation such as part of for example the Autosar standard may be used to include information and meta information about the model such as which functions should be called and in what order which task should be called and at what rate what types input arguments have or other information.

During the code generation process one or more IRs may be generated. An IR may be in the form of a data structure that is stored in memory a file a database or any other acceptable storage medium. The IR may be constructed from input data contained within a source language e.g. a language used by a graphical model and from which part or all of the target language information e.g. generated code is constructed. One example of an IR that may be used with is a control flow graph CFG . An IR may have meta tags to identify where content of the IR is derived from. A meta tag may associate the content of the IR with content that is used to generate the IR. The content of an IR may be derived from for example elements in a model optimization rules and or model configuration options.

One or more embodiments of the invention may be implemented on one or more computing devices. The one or more computing devices may be a system or part of a system. The one or more computing devices may include for example a desktop computer laptop computer client computer server computer mainframe computer personal digital assistant PDA netbook computer tablet computer web enabled cellular telephone smart phone or some other computing device.

The I O bus may be an interconnect bus that may enable communication between various components in the computing device such as processing logic secondary storage input devices output devices and communication interfaces . The communication may include among other things transferring information e.g. data control information executable instructions between the components.

The memory bus may be an interconnect bus that may enable information to be transferred between the processing logic and the primary storage . The information may include instructions and or data that may be executed manipulated and or otherwise processed by processing logic . The instructions and or data may include instructions and or data that may implement one or more embodiments of the invention.

Processing logic may include logic that may interpret execute and or otherwise process information contained in for example the primary storage and or secondary storage . The information may include computer executable instructions and or data that may implement one or more embodiments of the invention. Processing logic may comprise a variety of hardware. The hardware may include for example some combination of one or more processors microprocessors field programmable gate arrays FPGAs application specific instruction set processors ASIPs application specific integrated circuits ASICs complex programmable logic devices CPLDs graphics processing units GPUs or other types of processing logic that may interpret execute manipulate and or otherwise process the information. Processing logic may comprise a single core or multiple cores. Moreover processing logic may comprise a system on chip SoC or system in package SiP . An example of a processor that may be used to implement processing logic is the Intel Xeon processor available from Intel Corporation Santa Clara Calif.

The secondary storage may provide a storage e.g. a persistent storage that is accessible to the processing logic via I O bus . The secondary storage may store information for the processing logic . The information may be executed interpreted manipulated and or otherwise processed by the processing logic . The secondary storage may comprise for example a storage device such as a magnetic disk optical disk e.g. CD ROM DVD player random access memory RAM disk tape unit and or flash drive. The information may be stored on one or more non transient tangible computer readable media contained in the storage device. This media may include for example magnetic discs optical discs magnetic tape and or memory devices e.g. flash memory devices static RAM SRAM devices dynamic RAM DRAM devices or other memory devices . The information may include data and or computer executable instructions that may implement one or more embodiments of the invention. The information may be stored in various storage entities contained in the secondary storage . These storage entities may include for example files databases records tables e.g. contained in one or more databases or other storage entities.

Input devices may include one or more devices that may be used to input information into computing device . Examples of devices that may be used to input information into computing device may include a keyboard e.g. hardware keyboard software keyboard computer mouse microphone camera trackball gyroscopic device e.g. gyroscope mini mouse touch pad stylus graphics tablet touch screen joystick isotonic or isometric pointing stick accelerometer palm mouse foot mouse eyeball controlled device finger mouse light pen light gun neural device eye tracking device gesture tracking device steering wheel yoke jog dial space ball directional pad dance pad soap mouse haptic device tactile device neural device multipoint input device discrete pointing device or some other input device. The information may include spatial e.g. continuous multi dimensional data that may be input into computing device for example using a device such as a computer mouse. The information may also include other forms of data such as for example text that may be input using a keyboard.

Output devices may include one or more devices that may output information from the computing device . Examples of devices that may output information from the computing device may include a cathode ray tube CRT plasma display device light emitting diode LED display device liquid crystal display LCD device vacuum florescent display VFD device surface conduction electron emitter display SED device field emission display FED device haptic device tactile device neural stimulation device printer e.g. a three dimensional 3D printer laser printer speaker video projector volumetric display device plotter actuator e.g. electrical motor or some other output device.

Output devices may be directed by for example the processing logic to output the information from the computing device . The information may be presented e.g. displayed printed by output devices . The information may include for example graphical user interface GUI elements e.g. windows widgets dialog boxes or other GUI elements graphical representations pictures text or other information that may be presented by output devices . Note that the information may be presented on output devices in a stereoscopic view to enable for example a perception of depth.

Communication interfaces may include one or more devices that contain logic that may 1 interface the computing device with for example one or more communication networks and 2 enable the computing device to communicate with one or more devices connected to the communication networks. An example of a communication network that may be used with computing device will be described further below with respect to .

Communication interfaces may include one or more transceiver like mechanisms that enable the computing device to communicate with devices connected to the communication networks. Communication interfaces may include a built in network adapter network interface card NIC Personal Computer Memory Card International Association PCMCIA network card card bus network adapter wireless network adapter Universal Serial Bus USB network adapter modem or other device suitable for interfacing the computing device to the communication networks.

The primary storage may provide a storage that is accessible to the processing logic via bus . The primary storage may be a non transient tangible computer readable media that may store information for processing logic .

The information may include computer executable instructions and or data that may implement operating system OS windows manager WM an application APP and a technical computing environment TCE . The instructions may be executed interpreted and or otherwise processed by processing logic . The information may be stored in various storage entities contained in the primary storage . These entities may include for example files databases tables e.g. contained in databases or other storage entities.

The primary storage may comprise a RAM that may include RAM devices that may store the information. The RAM devices may be volatile or non volatile and may include for example one or more DRAM devices flash memory devices SRAM devices zero capacitor RAM ZRAM devices twin transistor RAM TTRAM devices read only memory ROM devices ferroelectric RAM FeRAM devices magneto resistive RAM MRAM devices phase change memory RAM PRAM devices or other types of RAM devices.

OS may be a conventional operating system that may implement various conventional operating system functions. These functions may include for example scheduling one or more portions of APP and or TCE to run on the processing logic managing the primary storage controlling access to various components associated with the computing device e.g. secondary storage input devices output devices communication interfaces and controlling access to data received and or transmitted by these components.

Examples of operating systems that may be used to implement OS include but are not limited to the Linux operating system Microsoft Windows operating system the Symbian operating system Mac OS Chrome OS and the Android operating system. A version of the Linux operating system that may be used is Red Hat Linux available from Red Hat Corporation Raleigh N.C. Versions of the Microsoft Windows operating system that may be used include Microsoft Windows 7 Microsoft Windows Vista Microsoft Windows Phone and Microsoft Windows XP operating systems available from Microsoft Inc. Redmond Wash. The Chrome OS and Android operating systems are available from Google Inc. Mountain View Calif. The Mac OS operating system is available from Apple Inc. Cupertino Calif. The Symbian operating system is available from the Symbian Foundation London United Kingdom.

WM may be a conventional window manager that may manage GUI elements such as widgets dialog boxes and windows that may be part of the OS TCE and APP . The GUI elements may be displayed on an output device . The WM may also be configured to 1 capture one or more positions of interactions with an input device and or other data associated with the input device and 2 provide the positions and or data to for example OS APP and or TCE . The positions and or data may be provided in messages that are sent to the OS APP and or TCE . Examples of window managers that may be used to implement WM may include but are not limited to X windows GNOME Unity Compiz and KDE which are often used with the Linux operating system and window managers used with the Microsoft Windows XP Microsoft Windows Vista Microsoft Windows Phone and Microsoft Windows 7 operating systems. It should be noted that other window managers or components that implement various functions associated with window managers may be used to implement WM .

APP may be designed to perform a particular task or tasks. APP may be an executable and or interpretable version of a software application that may be written in a programming language such as for example C C Java the MATLAB language or some other programming language. Some or all of APP may be written by a user of computing device supplied by a vendor or generated by TCE . Some or all of APP may operate under the control of OS . APP may include computer executable instructions and or data that may implement one or more embodiments of the invention.

TCE may be a modeling environment such as a graphical modeling environment or textual modeling environment. Some or all of TCE may operate under the control of OS . TCE may include computer executable instructions and or data that may implement one or more embodiments of the invention.

The TCE may include hardware logic software or some combination of hardware logic and software that may provide a computing environment that allows for example a user to perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business biology and or finance. The TCE may include a dynamically typed programming language e.g. the MATLAB language that can be used to express problems and or solutions in mathematical notations.

For example the TCE may use an array as a basic element where the array may not require dimensioning. The array may be used to support array based programming where an operation can apply to an entire set of values included in the array. Array based programming may allow array based operations to be treated as a high level programming technique that may allow for example operations to be performed on whole aggregations of data without having to resort to explicit loops of individual non array operations.

The TCE may include a dynamically typed programming language e.g. the MATLAB language where a data type of data may be determined at runtime. The dynamically typed programming language may use an array as a basic data element where the array may not require dimensioning. The array may be used to support array based programming where an operation may apply to a set of values included in the array. Array based programming may allow array based operations to be treated as a high level programming technique that may allow for example operations to be performed on aggregations of data without having to resort to explicit loops of individual non array operations.

In addition the TCE may perform matrix and or vector formulations that may be used for data analysis data visualization application development simulation modeling and or algorithm development. These matrix and or vector formulations may be used in many areas such as statistics image processing signal processing control design life sciences modeling discrete event analysis and or design state based analysis and or design and so on.

The TCE may further provide mathematical functions and or graphical tools or blocks e.g. for creating plots surfaces images volumetric representations or other representations . The TCE may provide these functions and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting and or parallel processing . In addition the TCE may provide these functions as block sets. The TCE may also provide these functions in other ways such as via a library local or remote database and so on.

The TCE may include provisions for creating compiling executing and or interpreting models such as model . A model may be graphical and may be executable e.g. an executable block diagram model . TCE may contain computer executable instructions and data that perform various tasks. The tasks may include for example 1 constructing model through an interface such as a GUI 2 allowing an augmentation of a pre defined set of blocks with custom user specified blocks that may be associated with model 3 using model to compute and trace an evolution such as a temporal evolution of outputs associated with a dynamic system represented by the model and 4 automatically producing for example deployable software systems and descriptions of hardware systems that mimic a behavior of either the entire model or portions of the model . The blocks may be represented in a graphical representation e.g. a block diagram of the model . The graphical representation may be presented by the TCE to for example a user via an interface such as a GUI.

Examples of TCEs that may be adapted to incorporate one or more embodiments of the invention may include but are not limited to MATLAB Simulink Stateflow and SimEvents which are available from The MathWorks Inc. Unified Modeling Language UML profiles associated with UML e.g. Modeling Analysis and Real Time Embedded Systems MARTE Systems Modeling Language SysML Avionics Architecture Description Language AADL GNU Octave from the GNU Project MATRIXx and LabView from National Instruments Mathematica from Wolfram Research Inc. Mathcad from Mathsoft Engineering Education Inc. Maple from Maplesoft Extend from Imagine That Inc. Scilab and Scicos from The French Institution for Research in Computer Science and Control INRIA Modelica or Dymola from Dynasim AB VisSim from Visual Solutions SoftWIRE from Measurement Computing Corporation WiT from DALSA Coreco Advanced Design System VEE Pro and SystemVue from Agilent Technologies Inc. Vision Program Manager from PPT Vision Inc. Khoros from Khoral Research Inc. VisiQuest from Pegasus Imaging Corporation Gedae from Gedae Inc. Virtuoso from Cadence Design Systems Inc. Rational Rose Rhapsody and Tau from International Business Machines IBM Inc. SCADE from Esterel Technologies and Ptolemy from the University of California at Berkeley.

Editor may be a block diagram editor that may allow for example a user to construct model . Constructing model may include for example specifying editing annotating saving publishing and printing a block diagram of model . The editor may contain provisions for editing code e.g. source code requirements and or tests that may be associated with model .

The execution engine may enable a computation and or tracing of a dynamic system s outputs from the model . The execution engine may carry out the task of compiling and linking the model to produce an in memory executable version of model that may be used for simulating verifying generating code trimming or linearizing the model .

The execution engine may receive and execute the model . The execution engine may generate data from the execution of the model . The data may be presented e.g. displayed to a user in a textual or graphical form. The TCE may use a centralized data viewer to view the data generated by the execution engine .

The execution engine may use numerical integration methods to compute behavior for differential equation as well as difference equation models. These numerical integration methods may be explicit and or implicit as well as fixed step or variable step. The execution engine may use a zero crossing detection and location mechanism to identify and locate times at which events occur such as a modeled collision between two rigid bodies. The execution engine may handle difference equations by pre computing a static schedule of times for when various values may change. This static schedule may employ a base rate that may be a greatest common denominator of all sample times that are scheduled for execution by the execution engine . The execution engine may handle discrete event systems based on a base rate or by using a dynamical scheduling mechanism such as an event calendar. The execution engine may employ a combination and or permutation of these features.

Model may be for example a time based graphical block diagram model a state transition diagram a discrete event model an activity diagram a UML diagram a sequence diagram a data flow model a structural model e.g. a software architecture model an electronics hardware model a network architecture model a mechanical structure model or some other type of model or diagram. Model may represent a system. Model may be graphical textual or some combination of graphical and textual. The system represented by model may be dynamic linear non linear or some other type of system.

A dynamic system either natural or man made may be a system whose response at any given time may be a function of its input stimuli its current state and a current time. Such systems may range from simple to highly complex systems. Natural dynamic systems may include for example a falling body the rotation of the earth bio mechanical systems muscles joints etc. bio chemical systems gene expression protein pathways weather and climate pattern systems. Examples of man made or engineered dynamic systems may include for example a bouncing ball a spring with a mass tied on an end automobiles airplanes control systems in major appliances communication networks audio signal processing nuclear reactors and a stock market.

The system represented by model may have various execution semantics that may be represented in model as a collection of modeling elements such as blocks. A modeling element may generally refer to a portion of functionality that may be used in the model . The modeling element may be graphically represented however it can be appreciated that the modeling element does not necessarily need to be represented graphically. For example a modeling element may be represented textually or stored in some form of internal representation. Also a particular visual depiction used to represent the modeling element for example in a graphical block diagram may generally be an arbitrary design choice.

A modeling element may be hierarchical in that the block itself may comprise one or more modeling elements that make up the modeling element. A modeling element comprising one or more modeling elements e.g. sub blocks may be referred to as a subsystem block. A subsystem block may be configured to represent a subsystem of the overall system represented by the model.

A modeling element may represent for example continuous and or discrete dynamic aspects of a system such as for example integration unit delay algorithms e.g. sum product or lookup tables and or structural aspects e.g. multiplexers switches signal or bus selectors . A modeling element may also represent one or more states and the block may include a state diagram model.

The code generator may generate code such as for example source code object code a compiled executable or a library for forming an executable representation of the model . The code generator may also be used to generate a hardware description language HDL or a register transfer language RTL representation of the model . The generated code may be stored in multiple files. For example part of the generated code may be stored in a header file while another part of generated code may be stored in a source file. To generate code the code generator may convert a source model language representation of the model to a target language representation.

During the code generation process the code generator may generate one or more IRs prior to generating code from the model . The IR may be a CFG that may capture one or more semantics of model . An IR represented by a CFG may include nodes that may represent algorithmic aspects of the model and edges that may indicate a flow e.g. data flow control flow of algorithmic aspects represented by the nodes.

The code generator may generate code for an execution of the model . The code generator may also compile generated code into object code and build an executable program library or other forms of executable instructions. The generated code may be designed to be executed by for example a processor microprocessor dual core processor multi core processor cluster of processors digital signal processor DSP programmable logic device PLD system on chip SOC System in Package SiP reconfigurable signal conditioning hardware operating system computational hardware device component of a computational hardware device or other processing logic.

Code generated by code generator may be deployed on various target hardware. This target hardware may include for example field programmable gate arrays FPGAs programmable logic arrays PLAs application specific integrated circuits ASICs and application specific integrated processors ASIPs .

The generated code may include embedded code targeted to run on an embedded system. For example generated code may be implemented as firmware in an electronic system that uses a microprocessor or a microcontroller. Additionally the code generator may be configured to customize the generated code based on target hardware that may execute the generated code. For example generated code may include fixed point code to run a fixed point processor or generated code may emulate fixed point behavior on a floating point processor.

Optimizations such as for example expression folding function inlining function outlining constant propagation strength reduction loop unrolling or other optimization may be applied to code generated by code generator . Expression folding may include reducing multiple expressions to a single expression in generated code. Function inlining may involve replacing replaces a function e.g. a function procedure method call site with the body of the function. Function outlining may include outlining an inlined function such that when the function is executed the function may go to a call site that is not part of the body of generated code. Constant propagation may include replacing variables that reference a constant with the constant. Strength reduction may include replacing a computation with an equivalent but less expensive computation in terms of processor cost such as speed power usage . Loop unrolling may include making iterations of a loop explicit so a looping construct may be removed.

Code generated by code generator may be verified by code verifier . Code verifier may verify for example that the code reproduces functionality of model and does not introduce functionality that is not associated with model . Code verifier may generate a report. The generated report may be for example a document structured with sections corresponding to different blocks of model and indications of whether any verification failures have been detected in sections of model that may contain those blocks a report detailing use of the temporary variables a report detailing compliance of the code with the functionality of the model or other report.

The generated report may use navigable links. For example the generated report may be in the form of a document in a markup language such as for example the hypertext markup language HTML . The navigable links may contain information relating to model settings of code generator or other information.

When generating an IR code a report or other entity TCE may use transformation rules. Transformation rules for example may determine how an element in model is represented in the IR or generated code. For example there may be a transformation rule relating to the element for transforming the element into a section of the IR. Moreover there may be another transformation rule for transforming the section of the IR into generated code. The transformation rules may exist on a non transitory computer readable medium and may be contained in a file database repository or some other structure.

TCE may incorporate a graph rewriting system that may be used to implement a transformation rule. The graph rewriting system may use a graph grammar. The graph grammar may use pattern matching for replacing one graph structure with another. Various ways may be used to implement pattern matching. The graph grammar may employ heuristics which may be used to manage computational complexity. The graph grammar may employ one or more rewriting rules transformation rules that may be extended by textual transformation information. The graph rewriting system may implement triple graph grammar or a higher order of graph grammar when generating an IR code a report or other entity. Transformation rules such as those implemented using triple graph grammar may allow for example mapping between a first entity e.g. an IR generated code a generated report a second entity that may be generated from the first entity and information e.g. transformation rules used to generate the second entity.

API may provide a programming interface to various functions performed by the TCE . The programming interface provided by the API may be used by programs such as for example application programs that may be run outside of TCE or application programs that operate under control of TCE to access these various functions.

As can be observed in there is no statement corresponding to the absolute value block . This lack of correspondence may be explained by an optimization operation that may have occurred when the code segment was generated. In embodiment the output of the adder block is an unsigned integer which is guaranteed to be positive so no additional operations may be needed to find its absolute value. Code verifier may respond to such optimizations by not treating the lack of the corresponding statement as an error. It should be noted that code shown in is not the only possible code that could be generated from embodiment . There may be many different code variations that still properly reflect the functionality of embodiment . As such code verifier may account for those variations to properly verify code generated from embodiment .

Table may include an input data type column an output data type column a rounding method column and a saturation on integer overflow column . A column may contain various values. For example the input data types column may contain values representing double float 32 bit signed integer int 16 bit signed integer int 8 bit signed integer int 32 bit unsigned integer unsigned 16 bit unsigned integer unsigned 8 bit unsigned integer unsigned Boolean or other data types. It should be noted that the values need not be arranged in the order illustrated in . Similarly the table may contain values other than the values illustrated in .

The rounding method column may include values indicating ceiling simplest floor zero or nearest rounding methods. The saturation on integer overflow column may include values indicating whether the saturation is required or not. Note that table may include additional columns and or values based on which functionality is looked up.

Table may be used as a lookup table that may provide information associated with various variables that may be contained in code that is generated from a model. For example a variable contained in code generated for model may be a 32 bit integer type int . Using table a rounding method for the variable i.e. floor may be identified knowing the data type of the variable which in this example is int .

Steering table may provide a key into steering table that may list control values specifying which transformations if any may be needed to make sure that a particular operation in the generated code inputs an appropriate input and outputs an appropriate output. Additional steering tables may be used to determine other details about the generated code that may need to be taken into account when matching portions of a model with portions of the generated code. Note that steering tables similar to the steering tables and may be used to match portions of expected code that may be associated with corresponding portions of the model.

At block an ECL is generated from the acquired representation. The ECL may be an internal representation of information of the model that may be contained in the acquired representation. Such information may include for example information about one or more elements in the model information about connectivity of elements in the model information internal to elements in the model or other information about the model. Information internal to the elements in the model may include for example element names element types parameters that may be required by the elements parameter types size data types vector sizes types of inputs and or outputs or other information about the elements. If the acquired representation includes a block diagram of the model for example the ECL may include a list of blocks contained within the model that may provide arithmetic and or logical actions and or may have functionality beyond providing for example connectivity grouping containers or information for model elements contained within containers.

Some of the information for the ECL may be derived from a compiled version of the model. A compiled model may be a model for which its attributes have been determined so that an executable representation may be derived. Determining model attributes may involve for example inferring sample times data types or signal dimensions from the model. The ECL may be generated as described above.

At block code generated from the model is acquired. The code may be generated by the TCE or may be generated outside of the TCE. Code generation may be initiated by a user in a sequence with code verification and the generated code may be provided to the TCE upon completion of the code generation or it may be made available incrementally. The generated code may contain artifacts or markers inserted in portions of the generated code. The artifacts or markers may include for example links back to the model an indication of where different code statements are derived from within the model or other information.

At block an AST may be created from the generated code. The AST may be a tree representation of the syntax of the generated code which relates to its functionality. A component of the AST may denote a construct that may occur in the generated code. Note that some constructs that appear in the generated code may not be explicitly represented in the AST. For instance the AST may exclude some grouping parenthesis of the source code and in the AST the grouping of the operands may be implicit in the tree structure. The AST may be built by a parser part of a verifier such as code verifier an external parser tool or otherwise built. Semantic analysis information may be included in the AST. For example the AST may include a file location for the generated code and a list of temporary variables declared within the generated code source file.

At block elements represented in the ECL are linked to code components represented in the AST. Here the TCE may find correspondences between entities in the ECL with nodes in the AST. There may be a one to many correspondence between an entity in the ECL and components in the AST although the correspondence may also be one to one. Components in the AST that correspond to an entity in the ECL may be found as described above.

An entity in the ECL may have for example a corresponding component in the AST or information about transformations that may have resulted in the corresponding model element being removed by an optimization during the code generation. If a model element is found that does not have a corresponding component in the AST or that matches the transformation for example for which there is no reason to expect it being removed by an optimization this situation may be considered a verification failure. At block a report may be generated e.g. by a TCE such as TCE . The report may contain information about one or more verification failures.

The AST may be traversed to find one or more components that may not have been associated with a corresponding entity in the ECL. The traversal may be a top down traversal or may employ tree search or traversal techniques. The components in the AST that do not have corresponding entities in the ECL or that are not traced to a particular model or model element setting may be considered to represent functionality that is not present in the model and may thus also represent verification failures. These verification failures may also be included in the report generated at block .

Different types of verification failures may be tracked e.g. by the TCE and may be included in the report. Moreover the report may include an indication of the failures and locations where they occur. For example the failures may be marked on the generated code and or on the model. Links may be provided between elements of the model and corresponding elements in the marked code and or model. The report may include a pass fail indication that represents whether the code overall has passed the verification.

Users may also be apprised of results of the code verification in various ways. For example code verifier may keep statistics about the code examined and about the particular patterns found therein. The report may include information about temporary variables used in the generated code and where they are used. The report may be in a format prepared according to user s settings or specifications. API may provide routines and or an interface for specifying what information to include in the generated report.

The ECL may be ordered based in part on the connectivity of the model and in part based on the arrangement of the generated code. For example portions of the model that are independent from each other from the standpoint of control and or data flow of execution may be arranged in multiple different ways in the generated code while still preserving the functionality of the model. As such there may be multiple different orderings of the entities in the ECL that also correctly represent the model functionality.

Referring to at block an unordered list or vector of entities may be created. Creating the unordered list will be described in further detail with respect to below. An unordered list of entities may be represented using various data structures such as for example a linked list a vector an array a dictionary a set a collection of objects or a heap.

At block the generated code may be scanned to locate one or more markers that may identify locations of code components corresponding to model elements in the generated code. Such markers may be contained for example in one or more comment sections of the code to avoid being processed by for example certain compiler or execution environments e.g. during generation or execution of the code . The markers may be presented in various formats. The markers may mark a beginning and or end of a section of code that corresponds to one or more elements of the model.

The code need not contain statements appropriately corresponding to the model element indicated code verifier may identify this case. Therefore the markers in the code may be consulted to aid the verification process and not as a means of verifying that the code within the marked section contains what the marker specifies it does. The AST may include information related to the markers and the code components may be located by searching the AST.

There may be some sections of the generated code that are not marked by any markers. Furthermore in some cases the markers may be incorrect in that they incorrectly identify a section of code as corresponding to a particular model element. Even in these cases the verification may still proceed because code verifier may check that the code reproduces the model functionality not that it is marked correctly. Code verifier may identify correspondences between model elements and code components. Code verifier may generate a report indicating these correspondences with more precision than the code markers inserted by code generator . At block the unordered list of entities may be ordered using the connectivity of the elements in the model and markers in the generated code. Ordering the unordered list of entities will be described in further detail below with respect to .

At block the file may be scanned to locate a group of model elements to examine. At block for each model element in a group an object may be instantiated to hold information about that model element block . An object may be of a class specifically designed to hold information about a model element. Such information may include information about the functionality of the model element its settings its input and output parameters default options or other information about the model element. An object may also be any other data structure employed to store information about one or more model elements. An object stored in an ECL or a list that is to become an element connectivity list may be referred to as an entity of the ECL.

At block default model element parameters are applied and recorded for the model element. The actual model element parameter values may then be extracted and stored in the corresponding entity block . Applying default model element parameters may be useful in case the actual model element parameters do not specify all of the possible parameters leaving the other ones to be set to defaults.

At block if there are model elements left to examine in the group at block objects may be created for those model elements otherwise connections between model elements are examined one by one. Each identified connection may be recorded in the appropriate entities. A single connection may need to be recorded in more than one object. In particular it may be noted in the source object which is then indicated as the source for the destination object as well as in the destination object which is then indicated as a destination for the source object. Other information about the connection such as the number and parameters may be recorded as well.

A connection may have properties such as an interface e.g. service interface specified. These properties may cause additional entities in the ECL to be created to capture the functionality. At block while there are connections left to examine they are processed one by one block after which the processing moves on to the next group if any block . In such a way the entire model file is processed to extract information about model elements and to create an unordered list of entities.

It should be noted that the textual representation of the model need not be as described above. In particular the model elements need not be grouped into distinct groups. Provided the model representation contains information about the model elements and connections between them it may be appropriately processed into a list of entities.

In other models it may be necessary to scan for additional markers block to locate additional model elements and to order those model elements upstream from them. Thus if there are two or more sections of the model that are not dependent on each other in terms of an execution pattern e.g. an order of execution they may be ordered in the ECL based on the ordering in the generated code. However if the model imposes an ordering based on the execution patterns such order may be preserved in the resulting ECL.

In an alternative embodiment a structure different from the ECL may be used to hold an internal representation of the model for code verification so long as it is capable of being traversed to match model elements with their corresponding code components.

Model element functionality may be generally viewed as something requiring code functionality. Code functionality may be represented by one or more statements. Such statement may be an operator or a control. For example an adder model element may have among other functionalities the functionality of adding two or more inputs. However even though on the face of the model that may be all that the adder does its functionality may not be limited only to the addition. In some cases it may be necessary for example to modify parameters of input and or output to ensure that the parameters are of the correct type as specified. Modifying model parameters may be performed by casting them and or setting appropriate overflows and other information relating to the parameter type.

Thus the extent of the entity functionality may be determined not only by what model element it corresponds to but also by what inputs and outputs are for that model element. It may also be affected by other model and code generation parameters. Whether any casting or any additional operations are required in the code to represent the functionality of the model element may be determined using parsers and or objects designed for each type of a model element. In addition one or more steering tables such as the steering tables described above may be used to determine what additional operations if any are needed in the code to represent the model element functionality.

For a functionality of a model element an operator or a control statement is determined block . An operator may act upon operands. A control may be a statement directing control flow of the code such as for example loop commands case commands IF ELSE commands etc.

Depending on the operator or control there may be one or more operands that are needed for that operator block . Those operands are determined based in part on the operator and based on what has already been determined for other entities. For example an operand for a plus operator may be an expression or a variable. Values of that expression and or variable may have been predetermined in conjunction with a previously verified model element. Therefore they can be retrieved from storage associated with an entity corresponding to that model element. As such the ordering of the entities in the ECL may be employed for traversal to match model elements with corresponding components in the code.

After the operator operand combinations have been determined they are located in the generated code block . As discussed above the generated code may be represented using an AST. However alternative representations may be possible so long as they permit searching and allow for locating of operator operand combinations. If the AST representation is used in an embodiment there may be search functions employed to locate the operator operand combinations as implemented by one of skill in the art.

The results of searching the AST are recorded block to note whether the corresponding code has been found and where. Additional information from the code components may be recorded in the corresponding entities. Such information may be for example expressions and or values of the output of the operands temporary variables involved etc. The information may be recorded in the entities and or directly in a report or other memory structures holding information for the report.

At block after the match information has been recorded if there is more model element functionality remaining to be examined the matching process proceeds to the additional functionality. Otherwise the matching process moves on to the next model element to examine block until all model elements have been examined and matches with the code components have been attempted to be found.

Referring to a report may include a section reporting whether code patterns have been identified for each model element block as well as an indication of whether all code components have been matched with an element block . Any model elements and or code components that have not been matched may be reported specifically so that the user may be apprised of specifics of the verification failures block .

The report may also include a description and or accounting of temporary variables usage in the generated code block . The temporary variables may be listed with indication as to where they are used in the code.

The report may also go into additional details as determined by one of skill in the art. For example the code verification process may check whether the generated code provides an expected interface to the model and the results of this check may be reported to the user. Verifying the correct interface may also involve verifying that a reusable code interface is correctly contained in the generated code and the corresponding AST. If the model indicates it contains non reusable code then the verification tool may verify that the non reusable code interface is contained in the generated code. In addition the verification tool may check that structures storing values during time steps e.g. DWORK structures are properly contained in the interface as well as that the model element I O structures are properly contained in the interface to the generated code. All of these interface details may be included in the report.

There may be also additional verifications that are performed by the code verifier and the results of which are included in the report. For example code verifier may determine that all of the expected entry points into the generated code have been correctly generated by the code generation. A model may be processed in stages such as evaluating its output updating its state computing its derivatives etc. These stages may constitute entry points. Some models may also have a single step stage.

The model options settings such as for example code reuse exported functions combining model output and model update calls etc. may partially determine what code entry points are expected. In addition some model elements such as for example a rate transition element may require specific entry points into the generated code for example to evaluate functionality at different rates that may be in different paths. In addition the code verifier may determine whether there are unexpected entry points in the generated code. Such entry points may be determined based on scanning the AST for the entry points and determining whether they correspond to the expected entry points. Furthermore the report generation tool may determine whether all model element names have been generated correctly. In some embodiments these names may be mangled in some cases if the length of the name is restricted and there are unintentional matches and part of the verification activities may be determining that the mangled names have been generated correctly. The report may list these mangled names and or indicate whether they have been generated correctly.

Furthermore as part of the verification and or reporting activities code verifier may inspect the generated code to verify that in line and non in line model subsystems have been generated correctly. For in line model subsystems the corresponding code may need to be contained within the same file as the code for the rest of the model. For the non in line model subsystems the generated code may need to be contained in a separate file. In addition for the non in line model subsystems the generated code may need to have its own interface accessible from outside the model subsystem and it may be verified that this interface is called from within the generated code for the rest of the model. It may also be verified that the interface is external to the model.

The results of these and other verification activities may be reported to the user. The report may be provided as a document or a set of documents. There may be a user interface for viewing the code verification report and browsing corresponding code and or model sections where appropriate. The results of code verification activities may be reported visually in conjunction with the model. For example the model elements for which no corresponding code components have been found may be visually indicated as such to the user. The report may be incrementally generated and displayed to the user as it is being created.

A code verifier such as code verifier may for example support all of the features and elements allowed in a model in a particular modeling environment or a restricted subset of the model elements. illustrates a flow diagram of example acts that may be used to inspect a model for compliance with a restricted subset of elements and configurations of elements supported by a code verifier such as code verifier . After the model source file is received by the code verifier block an IR is generated block and is examined for compliance with a restricted subset of elements block . The compliance may be verified based on all elements belonging to the restricted subset of elements and or based on additional factors block . If there are elements of the model that fall outside of the supported set a code generator such as code generator may report non compliance to the user block .

The verification results may be visually marked up for the user on the model and or code. In addition the user may be able to mark up the model and or code after receiving the verification report. illustrates a flow diagram of example acts that may be used to provide an interface for browsing and or marking sections of generated code and corresponding sections of a model. After the code is verified block a report may be presented to the user block or the user may be shown marked up code. The user may then choose to manually verify portions of the code whether those that have been verified by the code verifier or not and to mark up the code in accordance with the manual verification. User generated mark ups may be received stored and or reported block . Reporting may include reflecting the mark ups on the model and or the code.

The example embodiment may be sliced by TCE . The model may be sliced into two slices . Slices of example embodiment may be based on various criteria such as outputs of the model verifiable portions of the example embodiment or other criteria. In this example the slices are based on verifiable portions of example embodiment . Specifically slice includes a portion of example embodiment that is considered verifiable. Slice on the other hand includes a portion of model that is considered unverifiable.

A slice may be considered verifiable if code generated for that portion of the model represented by the slice is verifiable. illustrates examples of expected code and actual generated code for slices . Referring to the expected code may be identified by TCE . Identifying the code may involve for example generating code e.g. using code generator receiving code from a user via an interface receiving code over a communications network reading code from a file or database or otherwise identifying code .

Likewise the actual code may identified by TCE . Identifying the code may likewise involve for example generating code e.g. using code generator receiving code over a communications network reading the code from a file or database or otherwise identifying code .

The code at lines and may be expected code for slice and the code at lines and may be expected code for slice . Likewise the code at lines and may be generated code for slice and the code at lines and may be generated code for slice . Note that TCE may consider slices and verifiable because the TCE may be able to identify the expected code for these portions of model .

The identified expected code and the actual code may be analyzed to determine whether the expected code and the actual code meet certain criteria. The criteria may include for example whether the expected code is equivalent to the actual code . Note that equivalence does not necessarily mean the expected code is identical to the actual code . Rather equivalence may refer to other forms of equivalence. For example equivalence may refer to equivalent functionality equivalent data types equivalent performance semantic equivalence structural equivalence numerical equivalence and or other forms of equivalence between the expected code and the actual code .

Semantic equivalence may be determined in accordance with a definition of languages e.g. C C Java used to implement the expected and or actual code. Semantic equivalence may be found if semantics of the expected code is equivalent to semantics of the actual code regardless of for example syntactic grammatical details of languages used to implement the expected and actual code.

Structural equivalence may be based on a control and or data flow analysis of the expected and or actual code. Structural equivalence may be found if a control and or data flow analysis shows that the expected code is structurally equivalent to the actual code.

Numerical equivalence may be based on an equivalence between a first numerical value associated with the expected and or actual code and a second numerical value associated with the expected and or actual code. A value at a point of interest in the actual code may be considered numerically equivalent to a value in the expected code if the value in the actual code falls within a certain tolerance or range of the values with respect to the expected code. For example if a value produced at a point of interest in the expected code is 10 and a tolerance factor is 20 a value produced at a corresponding point of interest in the actual code that fall between 8 and 12 may cause the expected code to be considered equivalent to the actual code.

It should be noted that equivalence may be defined using for example a rule. Here a user may specify a rule that is used to define equivalence. Moreover the user may specify a parameter that may be associated with the rule. For example the user may define a rule that defines a numerical equivalence. The rule may contain a parameter that may specify a tolerance value used by the rule to determine equivalence such as described above. A user may have control over specifying the tolerance value.

Also note that criteria may be based on metrics other than equivalence. For example criteria may be based on various performance considerations code efficiency utilization of special hardware software storage occupied by the code readability of the code traceability of the code to the model or other considerations. Moreover criteria may be defined using a rule that may be for example evaluated to identify the criteria.

IR represents generated code that was generated from slice . IR may be generated from code at lines and . Likewise IR represents generated code that was generated from slice . IR may be generated from code at lines and .

TCE may determine whether the expected code for slice is equivalent to the generated code for slice by for example determining whether IR is equivalent to IR . Likewise TCE may determine whether the expected code for slice is equivalent to the actual code for slice by for example determining whether IR is equivalent to IR . For slice as can be seen in IRs and the IRs are equivalent except for the name of temporary variables used in an intermediate result. Thus TCE may find as a result of examining the IRs that the expected code for slice and the actual code for slice are equivalent. Likewise for slice as can be seen in IRs and the IRs are equivalent except for the name of temporary variables used in an intermediate result. Thus TCE may find as a result of examining the IRs that the expected code for slice and the actual code for slice are equivalent.

It should be noted that slicing may be viewed as a projection on a model. The projection may not necessarily lead to mutual exclusivity of contents contained in slices of the model. Rather in some situations two or more slices may contain the same element of the model. For example an element contained in a model may be contained in a first slice of the model and a second slice of the model.

The verification process may begin by comparing the nodes labeled d . If these nodes are found to be equivalent verification may proceed to the next nodes labeled to determine if they are equivalent the nodes associated with dashed line to determine if they are equivalent and the nodes associated with dashed line to determine if they are equivalent. If for example all of the nodes in an IR generated from the expected code are found to be equivalent to their corresponding nodes in the IR generated from the actual code the expected code may be considered equivalent to the actual code . Otherwise the expected code and the actual code may be considered not equivalent.

The code at block is another example of code that may be generated from example embodiment . At line the values of variables a and b are added. The result of the addition is stored in a variable named tmp . At line the value in variable tmp is stored in variable y . At line the values of variables c and d are added and the result of the addition is stored in the variable named tmp . At line the value stored in variable tmp is stored in variable y. Note that the code in block utilizes storage for only one temporary variables i.e. tmp .

TCE may evaluate the code in and to determine if they are equivalent. Equivalence may depend on a point of interest which may be predetermined predefined . For example if the point of interest is to ensure that the resultant values stored in y and y by the code in block is the same as the resultant values stored in these variables by the code in block both blocks of code may be considered equivalent because both store the same resultant values in these variables. However if the point of interest is efficiency especially from a standpoint of memory usage the code in block may not be considered equivalent to the code in block because the code in block uses two temporary variables whereas the code in block uses only one temporary variable.

The IRs in block may be generated from code in block . As can be seen only one temporary variable is used to store intermediate results of operations performed in the code in block .

An analysis of the IRs in blocks and may show that the code in blocks in and may or may not be equivalent based on a point of interest as described above.

Suppose that TCE may consider code generated for block verifiable because TCE may find an expected pattern for the generated code. Further suppose that TCE may be capable of finding an expected pattern for code that may be generated for a gain block and thus code generated for a gain block may be considered verifiable by TCE . TCE may suggest for example to a user a change to example embodiment or for example automatically make a modification to example embodiment that may make slice verifiable. The change may involve changing block to a block similar to block and adding a gain block. The combination of the changed block and gain block may be functionally equivalent to block .

Referring now to TCE may replace block with blocks and to make slice verifiable. Block may be functionally equivalent to block . Block may be a gain block. A parameter associated with the gain block may be set to 1 to cause the gain block to be functionally equivalent to a negation function that may be performed by block . The combination of gain block and block may duplicate the functionality of block . Since TCE may find an expected pattern for generated code for gain block and block TCE may consider slice to be verifiable after the change is made.

Note that the change may be suggested via a GUI to for example a user. The user may they provide authorization to make the change. The change may be automatically performed by the TCE with or without user authorization . The change may be performed temporarily. Here the change may be made temporarily e.g. by TCE for purposes of verification. After verification the model may be reverted back to its original design e.g. by TCE .

Also note that after a change has been made to the model the model may be re sliced. For example in example embodiment may be sliced in the same arrangement or a different arrangement after block is replaced with gain block and block .

Lines contain code associated with the gain block . TCE may consider this code verifiable e.g. TCE may be able to find an expected pattern for the code that may be used to verify the code thus in this example the code is not tagged.

Operationally the in memory representation component may generate an in memory representation of model . The model IR construction component may construct an IR of the in memory representation of the model which may be called a model IR. The model IR may be generated from information that describes the model. This information may be contained for example in a file database block diagram of the model or some other source. The model IR may include expected code that represents functionality of the model such as the described above. The model IR may be normalized by the model IR normalization component to produce a normalized model IR. The normalized model IR may be considered the expected pattern.

For example suppose that a block diagram of embodiment is provided. The model IRs generated from the provided block diagram may include the expected code and or IRs and . IRs and may be a normalized as illustrated in . The normalized IRs and or the expected code may be considered the expected pattern.

Code generated from the model may be input to the target language parser component . An output from the target language parser component may be input into the code IR construction component which may generate a code IR. The code IR may be considered the to be verified pattern.

For example given the above example the code generated for the embodiment may be code . IRs produced from the code may include IRs and . These IRs may be normalized as illustrated in . The normalized IRs and or the actual code may be considered the to be verified pattern for embodiment .

The expected pattern and the to be verified the pattern may be fed to the verifier which may determine whether the to be verified pattern is equivalent to the expected pattern.

It should be noted that equivalence should not be limited to mean that the expected pattern and the to be verified pattern are identical. Equivalence may refer to for example equivalent functionality equivalent performance and or other forms of equivalence between the expected pattern and the to be verified pattern. Also note that criteria e.g. various performance considerations code efficiency utilization of special hardware software storage occupied by the code readability of the code traceability of the code to the model other than equivalence between the expected pattern and the to be verified pattern may be checked for by the verifier .

A model such as model may contain a series of blocks and connectivity among the blocks. Here a block may define certain functionality of the model and the connectivity may define a data flow relationship among functionalities defined by multiple blocks. The model may be described by the following equations.

In general functionality of a block may be described by equation y f u p d 1 where f may represent functionality of the block umay represent inputs of the block pmay represent parameters of the block and dmay represent states that may be used by the block. Together f u p and dmay determine an output yof the block. A block parameter p may generally be set manually using for example a user interface and equation p P 2 may be used to describe the parameter. Similarly the equation d D 3 may be used to describe d. It should be noted here that state may be internal to the block and may be unknown.

A model may include various types of blocks that may not necessarily be described by the above equations. For example a model may include source blocks and sink blocks that may be defined by equations that are different than equations described above. Source blocks may include blocks that produce and output sources of signals. An example of a source block may include a signal generator block which may produce and output a sine wave signal. Sink blocks may include blocks that provide sinks for signals that are inputted into the source blocks. An example of a sink block may include a scope block which may display a signal that is input into the block.

An output yof a source block may be defined with by a known state U that may be input into the source block. Thus an equation that may be used to describe a source block may be y U 4 . Similarly a sink block s state Y may be defined by the sink block s input u. An equation that may be used to describe a sink block may be Y u 5 .

Connectivity may determine a direction of data flow among blocks. An output of a block ymay be a source of connectivity between blocks. An input of a block umay be a destination of connectivity between blocks. Equation u y 6 may be used to describe connectivity among blocks in the model where the superscripts dest and src are used to denote source and destination respectively. Note that yand ymay be used herein interchangeably depending on context. Likewise uand umay be used herein interchangeably depending on context.

A model may contain a list of blocks and connectivity among these blocks. A portion of a model may be formulated using the following equation Y Y . . . Y F U P D where 0

TCE may generate code generated code . The code may be generated in various languages such as for example C C C Python Java machine language and assembly language. Given a piece of generated code equation Y Y . . . Y F U where 0

One way to determine whether equations 7 and 8 are equivalent may involve treating F and F as a black box serve the same test vector to both equations and observe the outputs of the equations. If the same output is observed it could be said that equation 7 and 8 are equivalent.

Another way to determine whether equation 7 and 8 are equivalent may involve assuming that F and F are equivalent. Then the outputs of equations 7 and 8 should be the same. The TCE may use the above assumption to establish equivalence between equations 7 and 8 .

Slicing may be used to show equivalence between various outputs that may be associated with a model and or code generated from the model. Slicing may involve converting equations 7 and 8 to the equations Y F U P D where 0

For code slicing may involve determining for example which statements in the code may affect a value x at a point P in the code. TCE may define x as Y where 0

Suppose the tuple is used to represent x and P. Slicing may involve identifying which statements in the code affect . Or stated differently slicing may involve finding those statements in the code that are coupled with . An approach to slicing may include for example examining dependencies in the code. Here dependencies may include data dependencies and or control dependencies in the code.

A statement may be said to include a true data dependency if a value of a data associated with the statement depends on a value of data associated with a previous statement. Consider for example the following code 

In the above example the code at line defines a value of the variable temp and the code at line uses the value of variable temp . It may be said that the value produced by the code at line is consumed by the code at line and a value produced by line is data dependent on a value produced by line . Therefore it may be further said that a data dependency exists between the code at line and the code at line . Moreover given the above code there may be no way to reorder the code at line and line and preserve the semantics of the original program.

An output dependency may be where an ordering of instructions may affect an output value of a variable. For example consider the following code 

In the above example the code at line and line define values for the variable temp . If the order of code at line and line is changed then the value held by temp may change as well. It may be said that the code at line and line are coupled. Rewriting the above code as follows may decouple the above code since the order of the following code does not impact the values held by variables temp and temp .

An anti dependency may involve a variable that is used by a statement in code whose value may be updated by a later statement in the code. For example consider the following code 

In the above example line uses the value held by the variable temp and line updates the value held by the variable temp . If the order of line and line were to change the value held by the variable y may be incorrect. An anti dependency may be similar to the output dependency described above in that certain statements may be coupled. In the above example the statements at line and line are coupled. Rewriting the above example as follows may decouple the statements at line and line . Note that the order of the statements becomes less critical in the rewritten code with regards to impacting the value of the output variable y .

Output dependencies and anti dependencies may be said to be name dependent . As can be seen from the above rewritten examples output dependencies and anti dependencies may be avoided by carefully choosing the names of variables.

A control dependency may also affect a value of a statement. For example a control dependency may also affect a value of a statement if the execution of the statement is dependent on another e.g. preceeding statement. This concept is illustrated in the following example code 

In above example code the value of variable y depends on the condition specified by C . If the condition specified by C is satisfied e.g. true then the value of variable y is set to the value held by the variable temp . Otherwise if the condition specified by C is unsatisfied e.g. false then the value of variable y is set to 5 . Note that since the value of y depends on the condition specified by C it may be said that y has a control dependency on or y is control dependent on the condition specified by C .

A PDG may include a graph G e v where e represents a set of edges among a set of vertices v . A vertex v may represent a statement of a program. An edge e may represent a dependency relationship between two distinct vertices v and v may be said to exist. If v is data dependent on v a data dependent edge e which may represent the data dependency v between and v may be added to graph G e v . If v is control dependent on v an edge e which may represent a control dependency between v and v may be added to graph G e v .

For example illustrates example code that may be generated from a model such as model by an environment such as TCE . The listing including a column of line numbers where a particular line number is associated with a line of code. Referring to at line a test is performed to determine whether a value of a variable named X is a Boolean TRUE. If so the code at lines and are performed otherwise the code at a line is performed. At line the values of variables named A and B are added together and the result of the addition is stored in a variable named TEMP . At line a value of a variable named TEMP is assigned the value of the variable named TEMP . At line the values of variables named C and D are added together and the result of the addition is stored in a variable named TEMP . At line the value of a variable named Y is set to the value of the variable named TEMP . At line the value of the variable named Y is set to the value of the variable named TEMP .

Control dependency graph likewise includes a series of nodes and a series of edges . Nodes represent statements in code . The number inside a node indicates a line number of the statement represented by the node . Thus for example node contains the number 1 which indicates that node represents the statement at line i.e. IF X in code . Edges represent control dependencies between statements in code . For example edge represents a control dependency between the statement at line and the statement at line in code .

A PDG may be sliced as follows. Given a vertex v of the PDG graph G e v the slice of G e v with respect to v is a graph G e v containing all vertices of which v has a transitive flow or control dependency. All vertices can reach v via data flow or control edges.

For example illustrates an example of how PDG may be sliced. Referring to PDG may be sliced into two slices. A first slice may include nodes edge and edge . A second slice may include nodes edges and edges . Nodes include numbers that represent line numbers of statements in code that are associated with the nodes . For example node contains the number 1 which is associated with the statement at line number i.e. IF X in code . Edge indicates a control dependency between the statement at line number represented by node and the statement at line number represented by node in code . Edge indicates a data dependency between the statement at line number and the statement at line number in code .

Likewise in slice nodes includes numbers that represent line numbers of statements in code that are associated with the nodes . For example node contains the number 1 which is associated with the statement at line number i.e. IF X in code . Edge is indicate control dependencies between statements in code that are represented by nodes . For example edge indicates a control dependency exists between the statement at line number represented by node and the statement at line number represented by node in code . Edges indicate data dependencies between statements in code that are represented by nodes . For example edge indicates a data dependency exists between the statement at line represented by node and the statement at line number represented by node in code .

Slicing code such as described above may be used to identify pieces of generated code that may be separately verified. For example based on the above slices and the statements in code represented by nodes may be verified separately from the statements in code represented by nodes . Moreover after a piece of code is identified a corresponding portion of the model which corresponds to the identified piece of code may be identified. After identifying the piece of code and its corresponding portion of the model equations 10 and 11 may be identified.

After equations 10 and 11 have been identified a determination may be made as to whether the following equations holds F U P D F U 12 . The following determinations may be derived from equation 12 U P D U 13 and F F 14 .

For equation 13 The meaning of an argument may be highly predictable by examining a limited number of use cases. A framework may be provided e.g. in the form of an API which may support describing a behavior of generated code. The TCE may leverage this framework to determine whether equation 13 holds e.g. is true .

Equation 14 may be further decomposed into pattern normalization and verifier. Pattern may refer to an expected pattern and an actual pattern. In equation 14 Fmay represent the expected pattern and F may represent the actual pattern. The expected pattern may be derived from an IR of the model and the actual pattern may be derived from the code generated from the model.

Normalization may involve performing a semantic equivalent transform on both Fand F which may convert Fand F into Fand F respectively. Assuming Fis equivalent to Fand F is equivalent to F then it may be said that equation 14 may hold if F F 15 . Linker may involve performing a structural equivalence check of Fand F to determine whether equation 15 holds.

F may be a collection of f of one or more blocks contained in a model. A semantic of a block may be deterministically determined by the block s type and configuration. An initial state f of a block semantic may be constructed prior to verification. The initial state f of a block may serve as an expected pattern.

A to verify pattern may be derived from code that is generated from blocks in the model that are associated with F. The TCE may use a parser e.g. ELSA to parse the generated code to generate an AST associated with the to verify pattern. The TCE may further convert the AST to an IR that may be used by the TCE compare the to verify pattern with the expected pattern to determine whether they are equivalent.

Due to various functions performed during code generation such as optimization and lowering of code high level semantics of a model such as model the code generated for the model may follow various patterns. For example a functionality of a gain block may be defined as y k u where y represents a value of a signal that may be output from the gain block u represents a value of a signal that is input into the gain block and k represents a gain of the gain block. Code generated from the block may follow the following semantically equivalent patterns 

Pattern 1 may be a default form that is used as a default for code generated from the gain block. Pattern 2 may be a form that may be used due to a commutative operation being allowed in a target language of the generated code. Pattern 3 may be used due to a performance oriented transform. The transform may be premised on a left shift operation being faster that a multiplication operation. Patterns 4 and 5 may relate to the concept of lowering . Lowering may be related for example to a semantic intensity of a language. For example if a first target language for the generated code is an array based language such as the MATLAB language the array operation in patterns 4 and 5 may be performed in a single statement. On the other hand if a second target language for the generated code is a non array based language such as C the array operation may be performed using several statements rather than a single statement. The first target language may be said to be more semantically intense than the second target language with respect to the array operation because the first target language may perform the array operation in a single statement whereas the second target language may require more than one statement to perform the same array operation. In addition moving from a language that may handle the operation in a single statement to a language that may handle the same operation using several statements may be considered a form of lowering.

A way to perform verification of the code generated from the gain block may include constructing various forms and then try to match them. This approach may require that conditions related to different patterns be known in advance.

In some environments a b and e above may be readily determined whereas c and d may not e.g. they may be somewhat black box . Here predicting what optimization may happen and how it works may generally be impractical. However suppose the optimization involves for example performing a verification oriented transform e.g. semantic equivalence transform instead of a performance or other optimization transform. The verification transform may transform patterns in code that have the same semantics to a particular formal pattern. Then it may be expected that the generated code is verifiable.

In equation 1 code generated by TCE may include different identifiers for yand yif temporary variables are used. This situation may be related to the following cases 1 Optimizations to eliminate temporary variable usage and 2 Semantics of the target language may require that temporary variables be used to implement functionality.

Case 1 may be related to an optimization that may involve eliminating superfluous local variables sometimes referred to as expression folding . This optimization in general may control whether generated code should use temporary variables or not. Verification may perform global expression folding to mask the effect of this optimization.

Case 2 may be related to the target language itself. The language may not provide an option to control this case or alternatives may be difficult to implement. A typical scenario may be the presence of switch logic. Global expression folding may not get rid of the usage of temporary variables in this scenario. However during verification of generated code the generated code verification process may introduce an IR i.e. a phi node to handle temporary variables in this scenario. A phi node may be used to represent various code in generated code.

Code includes an example of a phi node that may be used to perform an assignment of the variable named temp . In code if the condition c is true a variable named temp is set to 10. Otherwise if the condition c is false the value of a variable named temp is set to 8. The phi node indicates that if c is a true then the value held by the variable named temp is assigned to the variable named temp otherwise if c is false then the value held by the variable named temp is assigned to temp .

Code includes an example of a phi node that collapses the switch structure into a single line. In addition the phi node eliminates the use of the temporary variables i.e. temp temp and temp . In phi node y represents the variable y c represents the condition c T represents the condition c being true and F represents the condition c being false. Thus phi node represents the following the variable named y is set to the value of 10 if the condition c is true otherwise if the condition c is false the variable named y is set to the value of 8.

Suppose the block is a slice of expected code. Referring to blocks and may be different forms of code that may be generated. Block shows a phi node that may be generated from the code in block . Block shows a phi node that may be generated from the code in block . Block shows a phi node that may be generated from the code in block . Block shows a phi node that may be generated from the phi node in block after the phi node in block is normalized. Normalization may involve removing P which represents a previously assigned value and replacing it with the actual previously assigned value. Blocks and show this process for block . Verification of the generated code and the expected code may be performed by comparing the resultant phi nodes in block and to determine whether they are equivalent.

A constant value which may be contained in code generated from a model may be categorized as non tunable or tunable. A non tunable constant value may be represented in the code as the following representations a a literal value e.g. 888 or b a variable with const qualifier e.g. const int Param Gain 888 .

A constant may use most any valid data type. In some situations a constant may be an array data type or a struct data type. Examples of data types for constants may include 1 a built in data type e.g. int int 2 an array data type e.g. int and 3 a struct data type e.g. bus where bus has two fields int a int b . If the constant is a built in data type then representations a and b above could be used to represent the constant in the generated code. If the constant is an array data type then only representation b may be used to represent the constant in the generated code.

If the constant is a struct data type then representations a or b may be used to represent the constant in the generated code. For representation a the struct data type may be unrolled so that a literal may be assigned to each field. A tunable constant value may use a variable without a const qualifier in the target code. For a non tunable constant a literal value may be directly used. Here further normalization may not be necessary.

If a variable with a const qualifier is used then normalization of const may convert the initialization of that const variable to an assignment and insert that into the proper scope IR. illustrates an example normalization that may be applied to code generated for a model.

Referring to the code in box defines a data type named ConstParam t which is a structure that contains a field named Gain Gain . The field Gain Gain is defined in the code in box as a three element array of unsigned integers. The code in box declares a constant named ConstP whose data type is ConstParam t . Further in the code in box ConstP.Gain Gain is defined as the array U U U . The code in box includes a statement which uses ConstP.Gain Gain in a calculation the result of which is assigned to a variable named tmp . A normalized IR of the code in boxes and is shown in box . Specifically normalization may include inserting statement into the IR as shown in block .

Various optimizations may be performed by on a constant during code generation. These optimizations may include folding. In some environments disabling this optimization may not be an option. Moreover predicting how this optimization may work may be difficult.

To address these issues an environment such as TCE may perform a maximum constant folding on both an expected pattern and a to verify pattern to minimize uncertainty that may be caused by folding. This may dramatically enhance the robustness of the environment.

Suppose for example that an expected pattern for code generated from a model is 3 5 and a to verify pattern of the code is 10 5 . TCE may consider the expected pattern and to verify pattern equivalent since the code in both patterns may be folded to the value 15. Note that TCE may employ for example tagging and traceability to reveal an evolution that led to the formation of the value 15 and thus help flag this situation.

Types e.g. data types used in generated code may be limited by target hardware that may execute the code. In choosing a type the TCE may generally consider accuracy and efficiency. An alias term for type is container. A first container that is bigger than a second container may mean that the first container may have more bits than the second container and thus the first container may represent a value that is to a true value.

In some programming languages e.g. C language a variable may be associated with a type specifier. The type specifier may act as a container for the variable. Conversion rules may be used to derive intermediate container information. An explicit cast expression may be used to store a value held by a variable of a certain type into a new container provided the cast expression satisfies certain conversion rules. Converting a value due to a cast expression may fall into the following cases 1 Convert a smaller container to a bigger container 2 Convert a container to a same size container 3 Convert a bigger container to a smaller container.

A minimum container may be defined as follows. Given an expression and all its possible containers C a minimum container i.e. C is the one that is either equal to or smaller than any c where c C. It should be noted that a minimum container may determine an accuracy of a value that may be associated with an expression.

Regarding the above mentioned three cases Cfor cases 1 and 3 may be the smaller container. For case 2 since conversion is between the same sized container Cis the container itself.

In case 1 and case 2 a cast expression may be normalized with the expression itself without losing semantics. For case 3 a cast may not be normalized. Thus for case 3 TCE may a keep the cast or b remove the cast and use an expression to carry the container information.

Referring back to the linker may establish whether structurally Fand F are equivalent. For example Fand F may be represented in a graph e.g. tree form. Linker may first determine whether Root which is the root of the graph representing F is equivalent to e.g. is the same as Root which is the root of the graph representing F. If so linker may follow the same kind of edges in both graphs to check whether vertices vand v which depend on the roots are equivalent. This process may continue for other edges and vertices in the graph to ensure the graphs are structurally equivalent.

A target language may support commutative expressions. Thus when checking for structural equivalence between an IR for an expected pattern and an IR for a to verify pattern for code written in such a language edges in the IRs for nodes associated with commutative expressions may be un ordered and may need to be exhausted. Also when checking type equivalence in during a structural equivalence check the following heuristic may be used if the generated code uses an equivalent or bigger container than an expected minimum container then type is verified.

At block the model may be sliced into a plurality of slices. The slices may be identified using various criteria such as outputs produced by the slices types of blocks verifiable unverifiable portions of the model or other criteria. For example as noted above with respect to model may be sliced based on verifiable portions in the model .

At block a slice in the plurality of slices may be selected. The slice may be selected based on various criteria such as complexity of the slice outputs produced by the slice or other criteria. The slice may be selected manually for example by a user via an interface or automatically for example by a verification tool such as code verifier .

At block a portion of code associated with the selected slice is identified. The portion of code may be contained in code generated from the model. The portion of code may correspond to the selected slice.

At block verification is performed to determine if the identified code is equivalent to the selected slice. Here verification may involve generating an IR of the selected slice generating an IR of the identified code normalizing the IRs and determining whether the normalized IR of the selected slice is equivalent to the normalized IR of the identified code.

At block a slice in the plurality of slices is selected. The slice may be selected such as described above. At block a portion of code in code generated for the model that corresponds to the selected slice is identified. The portion of code may be identified such as described above.

At block a portion of code generated from the model that corresponds to the selected slice is identified. The portion of code may be identified based on various criteria such as functionality of the code and the corresponding selected slice information e.g. tags comments contained in the portion of code or other criteria.

At block an IR of the selected slice is generated. The IR may include a graph. The IR may contain vertices that may represent functionality associated with the selected slice and edges that indicate a relationship e.g. data flows control flows between functionality represented by the vertices.

At block an IR of the identified portion of code may be generated. The IR may include a graph. A vertex in the IR may represent a statement of portion of code and an edge may represent a dependency e.g. data dependency control dependency relationship between two distinct vertices in the IR.

At block a verification may be performed to determine whether the IR of the selected slice is equivalent to the IR of the identified portion of code. The verification may involve analyzing the IR of the selected slice and the IR of the identified portion of code to determine whether they are equivalent.

At block a portion of code generated from the model that corresponds to the verifiable portion of the model contained in the selected slice is identified. The portion of code may be identified as described above.

At block an IR of the verifiable portion of the model contained in the selected slice is generated. The IR may be generated as described above.

At block an IR of the portion of the code identified at block is generated. The IR may be generated as described above.

At block a verification is performed to determine whether the identified code is equivalent to the verifiable portion of the model contained in the selected slice. The verification may include verifying that the IR generated at block is equivalent to the IR generated at block .

At block a first slice in the plurality of slices of the model is verified. The first slice may be associated with a portion of the model that is verifiable.

At block a first indication that indicates one or more elements in the first slice are verified is provided. The indication may be provided in a block diagram of the model. The indication may include presenting the one or more elements differently than elements that have not been verified. For example the one or more verified elements may be displayed in a color that is different than the unverified elements.

At block a second indication is provided in the block diagram of the model. The second indication may indicate that a second slice containing a portion of the model that is verifiable has not been verified. For example the second slice may contain one or more blocks of the model that are verifiable but have not been verified. At block the fact that the blocks are verifiable but have not been verified may be indicated in the block diagram e.g. using a color that may indicate this distinction .

At block a portion of the model that is not part of any slice in the plurality of slices is identified. Identifying the portion may involve comparing the elements in the model with elements of the model contained in the slices and identifying those components that are in the model that are not contained any of the slices.

At block a third indication is provided in a block diagram of the model. The third indication may indicate the portion of the model that was identified at block that is not part of any slice in the plurality of slices.

At block the expected code is identified using the information. For example suppose the first element is a gain block in the model the acquired information is a tag that indicates the first element is a gain block the expected code is contained in a file and that the location in the file that contains the expected code is tagged with a tag that matches the acquired annotation. The expected code may be identified by searching the file for the matching tag and reading the code associated with the matching tag from the file.

At block code that is generated for the first element is acquired. The generated code may be acquired by reading the code from a file or database receiving the code via an interface e.g. a GUI command line interface receiving the code via a network or otherwise acquiring the code.

At block a check is performed to determine whether the generated code and the expected code are equivalent. The code may be checked for equivalence as described above.

If the generated code and the expected code are not equivalent at block this lack of equivalence is handled. The lack of equivalence may be handled for example by providing a visual indication e.g. in a block diagram of the model generating an exception condition e.g. throwing an exception generating an interrupt return an error code reporting the situation in a report e.g. an error message or otherwise handling the condition.

If at block it is determined that the generated code is equivalent to the expected code at block a pattern for the expected code may be learned. Learning may involve associating the identified expected code and or the acquired information with element types that are equivalent to the element type of the first element.

At block an indication is acquired. The indication may indicate that the learned pattern is acceptable for use in verifying elements that are equivalent to the element type of the first element. For example the learned pattern may be presented to a user via a GUI. The user may review the pattern and provide the indication that the pattern is acceptable for use in verifying elements that are equivalent to the element type of the first element.

At block the learned pattern is integrated into a verification procedure that may be used to verify code generated from one or more elements whose element types are equivalent to the element type of the first element. For example the pattern may be used to modify an algorithm or a behavior of an algorithm that may be used to verify elements of an equivalent type as the first element.

At block code generated for a second element in the model is acquired. The generated code may be acquired as described above. The second element may be of an element type that is equivalent to the element type of the first element.

At block generated code for the second element is verified using the learned pattern. Verification may involve generating expected code for the second element based on the learned pattern and determining whether the expected code is equivalent to the generated code for the second element such as described above.

At block a slice of expected code is identified. The slice may be identified as described above. The expected code may be specified for example by a user read from a file or from some other source.

At block a verification is performed to determine whether the identified slice of generated code is equivalent to the identified expected code. The verification may be performed using various intermediate representations e.g. graphs phi nodes such as described above.

One or more embodiments of the invention may be implemented in a distributed environment. illustrates an example of a distributed environment that may implement one or more embodiments of the invention. Referring to environment may contain various components including computing device target environment service provider cluster and communications network . Note that the distributed environment is just one example of a distributed environment that may be used with one or more embodiments of the invention. Other distributed environments that may be used with one or more embodiments of the invention may contain more components or fewer components than illustrated in . Moreover the components in the distributed environments may be arranged differently than the arrangement shown in . In addition the distributed environments may implement various cloud computing frameworks.

Details of computing device were described above with respect to . In distributed environment computing device may among other things exchange information e.g. data with other components in the communications network e.g. target environment service provider and cluster . Computing device may interface with the communications network via a communication interface .

Target environment may be configured to interpret and or execute for example one or more embodiments of the invention which may be generated in or otherwise made available to the distributed environment . The communications network may include digital and or analog aspects. Information exchanged in communications network may include machine readable information having a format that may be adapted for use for example in the communications network and or with one or more components in the communications network .

For example the information may be encapsulated in one or more packets that may be used to transfer the information through the communications network . Information may be exchanged between components in the communications network using various communication protocols such as but not limited to the Internet Protocol IP Asynchronous Transfer Mode ATM Synchronous Optical Network SONET the User Datagram Protocol UDP Transmission Control Protocol TCP Institute of Electrical and Electronics Engineers IEEE 802.11 or other communication protocol.

The communications network may comprise various network devices such as gateways routers switches firewalls servers repeaters address translators etc. Some or all of the communications network may be wired e.g. using wired conductors optical fibers and or wireless e.g. using free space optical FSO radio frequency RF acoustic transmission paths . Portions of the communications network may include a substantially open public network such as the Internet. Portions of the communications network may include a more restricted network such as a private corporate network or virtual private network VPN . It should be noted that implementations of communications networks and or devices operating on communications networks described herein are not limited with regards to for example information carried by the communications networks protocols used in the communications networks and or the architecture configuration of the communications networks.

Cluster may include a number of units of execution UEs that may execute or interpret one or more embodiments of the invention or portions thereof on behalf of computing device and or another component such as service provider . The UEs may reside on a single device or chip or on multiple devices or chips. For example the UEs may be implemented in a single ASIC or in multiple ASICs. Likewise the UEs may be implemented in a single computer system or multiple computer systems. Other examples of UEs may include for example some combination of FPGAs CPLDs ASIPs processors multiprocessor systems on chip MPSoCs graphic processing units and or microprocessors. The UEs may be configured to perform operations on behalf of another component in the distributed environment . For example in an embodiment the UEs are configured to execute portions of code associated with the TCE . Here the TCE may dispatch certain activities pertaining to one or more embodiments of the invention to the UEs for execution. The service provider may configure cluster to provide for example the above described services to computing device on a subscription basis e.g. via a web service .

The foregoing description of embodiments is intended to provide illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from a practice of the invention. For example while a series of acts has been described above with respect to the order of the acts may be modified in other implementations. Further non dependent acts may be performed in parallel. Also the term user as used herein is intended to be broadly interpreted to include for example a computing device e.g. a workstation or a user of a computing device unless otherwise stated.

It will be apparent that one or more embodiments described herein may be implemented in many different forms of software and hardware. Software code and or specialized hardware used to implement embodiments described herein is not limiting of the invention. Thus the operation and behavior of embodiments were described without reference to the specific software code and or specialized hardware it being understood that one would be able to design software and or hardware to implement the embodiments based on the description herein.

One or more embodiments of the invention may be stored on one or more tangible non transitory computer readable storage media and may include computer executable instructions that may be executed by processing logic such as processing logic . The computer executable instructions may include instructions that implement one or more embodiments of the invention. The tangible computer readable storage media may be volatile or non volatile and may include for example flash memories dynamic memories removable disks and non removable disks.

No element act or instruction used herein should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

It is intended that the invention not be limited to the particular embodiments disclosed above but that the invention will include any and all particular embodiments and equivalents falling within the scope of the following appended claims.

