---

title: Restoring an application from a system dump file
abstract: An application is identified that was running at a time of a system crash. A system dump file is received that was created responsive to the system crash. A restoration dataset stored in the system dump file is determined. The application is restored based, at least in part, on the restoration dataset.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09652329&OS=09652329&RS=09652329
owner: International Business Machines Corporation
number: 09652329
owner_city: Armonk
owner_country: US
publication_date: 20140613
---
The present invention relates generally to the field of application and system recovery and more particularly to restoring an application after a system crash.

Due to the nature and growing complexity of software there are increasing opportunities for a possibility of an error or fault in the software. Such errors or faults are generally handled by exception handles but not all errors or faults can be handled by exception handles and these can lead to system crashes. Most of the time upon system crash a dump file is generated to allow for debugging to look for a solution to the problem. This dump file often called a kernel dump file contains the entire memory image of the program including the central processing unit CPU state.

If an error happens in the kernel of the computer system the entire system crashes and all applications running on the computer system crash as well. Most of these crashes occur due to bugs in the kernel. If such crashes occur the kernel dump file is saved the computer system is rebooted and an application can be restarted. Restarting an application from the beginning can lead to loss of data and computation time. Current backup techniques employ checkpoint restore for fault tolerance.

In a checkpoint restore technique the application is check pointed at regular intervals of time. If the kernel crashes the computer system is rebooted and an application can be restored from the last check point. The checkpoint restore technique has a few drawbacks. First the computations performed by the application from the last checkpoint until the time of the system crash are lost. Second check pointing itself may take a long time if the application has a large memory buffer. Third check pointing may freeze the application while generating a consistent snapshot of the application and this is performed at regular intervals affecting application performance.

Embodiments of the present invention include a method computer program product and system for restoring an application from a system dump file. In one embodiment an application is identified that was running at a time of a system crash. A system dump file is received that was created responsive to the system crash. A restoration dataset stored in the system dump file is determined. The application is restored based at least in part on the restoration dataset.

As software complexity increases system crashes seem to occur more frequently. As stated previously the conventional checkpoint restore technique that backs up a computer system has a number of drawbacks. Some embodiments of the present invention provide a restore program that solves the aforementioned problem by restoring the crashed application from the kernel dump file. In other words the application is restored to the state it was in at the time of system crash. This avoids the need to deploy the checkpoint restore technique and the drawbacks that come along with that technique.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

An embodiment of a possible hardware and software environment for software and or methods according to the present invention will now be described in detail with reference to the Figures. is a functional block diagram illustrating various portions of networked computers system including computer sub system clients communication network computer communication unit processor set input output I O interface set memory device persistent storage device display device external device set random access memory RAM devices cache memory device kernel restore program application and kernel dump file .

Computer sub system is in many respects representative of the various computer sub system s in the present invention including client and . Accordingly several portions of sub system will now be discussed in the following paragraphs.

Sub system may be a laptop computer tablet computer netbook computer personal computer PC enterprise servers a desktop computer a personal digital assistant PDA a smart phone or any programmable electronic device capable of communicating with the client sub systems via network . Restore program is a collection of machine readable instructions and or data that is used to create manage and control certain software functions that will be discussed in detail below.

Sub system is capable of communicating with other computer sub systems via network . Network can be for example a local area network LAN a wide area network WAN such as the Internet or a combination of the two and can include wired wireless or fiber optic connections. In general network can be any combination of connections and protocols that will support communications between server and client sub systems.

Sub system is shown as a block diagram with many double arrows. These double arrows no separate reference numerals represent a communications fabric which provides communications between various components of sub system . This communications fabric can be implemented with any architecture designed for passing data and or control information between processors such as microprocessors communications and network processors etc. system memory peripheral devices and any other hardware components within a system. For example the communications fabric can be implemented at least in part with one or more buses.

Memory and persistent storage are computer readable storage media. In general memory can include any suitable volatile or non volatile computer readable storage media. It is further noted that now and or in the near future i external device s may be able to supply some or all memory for sub system and or ii devices external to sub system may be able to provide memory for sub system .

Restore program application and kernel dump file are stored in persistent storage for access and or execution by one or more of the respective computer processors usually through one or more memories of memory . Persistent storage i is at least more persistent than a signal in transit ii stores the program including its soft logic and or data on a tangible medium such as magnetic or optical domains and iii is substantially less persistent than permanent storage. Alternatively data storage may be more persistent and or permanent than the type of storage provided by persistent storage .

Restore program may include both machine readable and performable instructions and or substantive data that is the type of data stored in a database . In this particular embodiment persistent storage includes a magnetic hard disk drive. To name some possible variations persistent storage may include a solid state hard drive a semiconductor storage device read only memory ROM erasable programmable read only memory EPROM flash memory or any other computer readable storage media that is capable of storing program instructions or digital information.

The media used by persistent storage may also be removable. For example a removable hard drive may be used for persistent storage . Other examples include optical and magnetic disks thumb drives and smart cards that are inserted into a drive for transfer onto another computer readable storage medium that is also part of persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices external to sub system . In these examples communications unit includes one or more network interface cards. Communications unit may provide communications through the use of either or both physical and wireless communications links. Any software modules discussed herein may be downloaded to a persistent storage device such as persistent storage device through a communications unit such as communications unit .

I O interface set allows for input and output of data with other devices that may be connected locally in data communication with server computer . For example I O interface set provides a connection to external device set . External device set will typically include devices such as a keyboard keypad a touch screen and or some other suitable input device. External device set can also include portable computer readable storage media such as for example thumb drives portable optical or magnetic disks and memory cards. Software and data used to practice embodiments of the present invention for example restore program can be stored on such portable computer readable storage media. In these embodiments the relevant software may or may not be loaded in whole or in part onto persistent storage device via I O interface set . I O interface set also connects in data communication with display device .

Display device provides a mechanism to display data to a user and may be for example a computer monitor or a smart phone display screen.

The programs described herein are identified based upon the application for which they are implemented in a specific embodiment of the present invention. However it should be appreciated that any particular program nomenclature herein is used merely for convenience and thus the present invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

Resident on computer kernel is a computer program that manages input output requests from software and translates these requests into data processing instructions for the central processing unit and other electronic components of a computer such as memory and devices. Kernel is the core of a modern computer s operating system and common uses include the Linux kernel used on many Linux based operating systems Windows 9x kernel used in Windows 95 98 and ME Windows NT kernel used in all Windows NT systems including Windows 2000 XP Vista and 7 and XNU used in Mac OS X operating systems. Note the term s Linux Windows Vista XNU and or Mac OS may be subject to trademark rights in various jurisdictions throughout the world and are used here only in reference to the products or services properly denominated by the marks to the extent that such trademark rights may exist. Kernel described herein can be any one of the above referenced kernels any other kernel found in any operating system or any other function or program that performs tasks similar to the kernel as known in the art.

Upon boot of the operating system on computer sub system kernel is stored not shown in persistent storage but then deployed in memory as shown in . Upon deployment kernel controls the operations discussed in the above paragraph. Throughout the course of the computer sub system performing the actions of applications or functions these applications or programs make requests of the kernel via a system call. As the kernel performs its primary function of managing the computer s hardware and resources and enabling other programs to run access and use these resources errors may occur. If an error is a fatal error an error from which the operating system or kernel cannot safely recover from computer sub system may crash and reboot.

Upon a system crash and before a reboot process occurs kernel dump file will be created in persistent storage . Kernel dump file may also be known as a system dump file a crash dump file a system crash dump file or any other term known in the art suitable for the foregoing intended use. A kernel dump file often consists of the recorded state of the working memory of a computer program at a specific time usually when the program has terminated abnormally. In practice other key pieces of program state are usually dumped at the same time. This can include at least one of the following i the contents of processor registers ii a program counter iii a stack pointer iv memory management information v heap vi state of architected registers vii state of processor s viii operating system flags and ix information that existed near a time of a fault. Generally a kernel dump file is used to assist in diagnosing and debugging computer programs or the kernel.

The method of creating a kernel dump file is well known in the art and will be discussed in brief but it should be known that a kernel dump file can be created and written to persistent storage in any other way suitable for the foregoing intended use. One method involves the first crashed kernel. Kernel may create and write the kernel dump file to persistent storage . Alternatively it is preferable to use an entity outside of the first kernel to create and write the kernel dump file . Here software tools are used to create a kernel to kernel bootloader and the kernel that crashed can load and run a second instance of a kernel. The second kernel may now create and write kernel dump file to persistent storage . In another alternative with the growing use of virtualization a hypervisor may create and write kernel dump file to persistent storage .

Restore program operates to restore an application to the state it was in at the time of a system crash that causes computer to reboot. When an error occurs in a kernel the entire system crashes and all applications running on the kernel s computer are abruptly terminated. However often the cause of the system crash is due to a bug in kernel and not directly related to a failure in application . As discussed previously upon system crash kernel dump file is generated for debugging to determine the source of the problem. Kernel dump file is stored in persistent storage . Restore program extracts information from kernel dump file and uses this information to restore application to the state it was in at the time of kernel crash.

Processing begins at step S where deployment module deploys restore program . Deployment module detects an input from a user indicating that the user would like to execute restore program . Alternatively this step may occur by an automated process after a system reboot. In one embodiment this step may occur directly after a system boot due to a system crash. Alternatively this step may occur at any time after a system boot due to a system crash or after any event that results in the creation of kernel dump file .

Processing proceeds to step S where receiving module receives an indication of an application to restore. In this embodiment step S is performed from a user input. Alternatively this step is performed from an automated input from another application or function not shown . Receiving module receives an indication of an application to restore. Application may or may not be currently running. Application may be chosen from a list of applications that were running at the time of system crash as determined by module . Alternatively application may be chosen and module must determine if application was running at the time of system crash. For example a user is operating on computer that just had a fatal error there was a system crash kernel dump file was created and computer was rebooted. After computer proceeds through the standard boot and startup process as known in the art and user has executed restore program computer using display displays a drop down menu of application s that were running at the time of system crash. For example a user may be prompted to select from Applications A B and C. Alternatively there may have been any number of applications running at the time of system crash and they would all be displayed to the user. The user then chooses Application A to restore by clicking on Application A on the drop down menu and then choosing a submit option to proceed to the next step.

Processing proceeds to step S where extraction module extracts information from kernel dump file . Restore program after determining application to restore determines the information from kernel dump file that will be needed to restore application . Restore program then extracts or removes that information from kernel dump file . The information that is extracted from kernel dump file may include i stack ii heap iii cpu state iv state of the architected registers v application state vi resources assigned or used including shared memory shared libraries open file descriptors and sockets and or vii thread specific information all of which being relevant to application to . Additionally if application was processing larger amounts of data at the time of system crash the actual data generated by application could have been paged out to swap space. Is such a case extraction module may determine from at least one of the stack heap cpu state and state of the architected registers if swap space has been utilized and responsive to determining that swap space has been utilized extraction module extracts relevant information from swap space provided the computer sub system has a mechanism to retain data in swap space upon system crash and reboot. For example extraction module extracts information from kernel dump file for restoring application . Additionally extraction module determines if application was using swap space and if so the extraction module extracts relevant information from the swap space. Heap referred to herein is the dynamically allocated memory region of the application address space.

In computer science a stack is a collection of entities with the principal operations on the collection being the addition of an entity to the collection a push and removal of an entity a pop. A stack has a bounded capacity. If the stack is full and does not contain enough space to accept an entity to be pushed the stack is then in an overflow state. The stack is a restricted data structure that is not directly accessible by a program. Only a few operations are performed on it. The nature of the pop and push operations also mean that stack elements have a natural order. Elements are removed from the stack in the reverse order to the order of their addition. Therefore the lower elements are those that have been on the stack the longest.

In computer science the architectural state consists in part of a state of the central processing unit CPU which holds part of the state of a process and this includes control registers and general purpose registers. The control registers can include at least one of the following instruction flag registers interrupt mask registers memory management unit registers or status registers. General purpose registers can include at least one of the following general purpose registers address registers floating point registers counter registers index registers stack registers and string registers.

Processing proceeds to step S where rebuild module rebuilds the application state. The rebuild module determines the state of application at the time of the system crash. In this embodiment rebuild module determines what hardware application was interacting with at the time of system crash. Additionally rebuild module may determine any other software that application was interacting with at the time of crash. For example application may have been interacting with a camera system not shown along with interacting with the corresponding software that is used with the camera system. Rebuild module restores any connections at the time of the system crash and restores application to the state that it was at the time of system crash.

Processing proceeds to step S where restore module restores application from the information extracted from kernel dump file . In other words the restore module using the information extracted from the kernel dump file puts application in the state it was in when the system crashed. Here application is restored as if it had already processed the data that had been processed prior to the system crash. Further application is restored such that it is ready to handle and process the next data in the data set that application was handling at the time of the system crash. For example application was processing a data set that included information for each day of a month. Application had processed information up to and including the fifteenth of the month when the system crashed. Restore module restores application so that it has processed information from the first to the fifteenth and also sets up restore application so that the next piece of information application will process will be information associated with the sixteenth of the month.

Processing proceeds to step S where resume module resumes application execution. In other words application begins to run as it did immediately before system crash having completed a certain data set or process and starting to work on the next available data set or process. For example application begins to function as it was just before system crash. Application has processed all information the same that it had before system crash and can now take that information and continue to move through that information processing the data set or completing the tasks that are next in line for application . Alternatively application begins to run as it did at any time before system crash.

Processing proceeds to step S where determine module determines if there are any other application s to restore. In this embodiment restore program determines if there are any additional application s to restore once application is restored. Alternatively restore program receives a list of applications to restore in step S so when application is restored the restore program initiates the restoration process for a next application not shown . Alternatively only application is restored and processing proceeds to step S. For example application is now running independently of restore program and may be continuing to process data. If restore program determines there is another application not shown to restore decision block S yes branch then restore program proceeds to S where a new application not shown is indicated for restoration. Alternatively if restore program determines there are no other applications to restore decision block S no branch the restore program proceeds to end restore program S .

Processing ends at step S where end module ends restore program . In other words the restore program has finished restoring all applications for example as specified by a user and can now end execution. For example application and any other applications that needed to be restored have been restored and restore program ends. All work has been completed by restore program .

In an alternative embodiment the above discussed method can be applied to recover guest instances of virtual machines on a host computer system in the event of a hypervisor crash. All instances of the guest virtual machines can be restored from the hypervisor dump without using the check pointing method. Here the hypervisor dump is similar to the previously discussed kernel dump file . This mechanism enhances the fault tolerance mechanism in the cloud environment and is much less resource exhaustive as compared to check pointing each and every guest instance of virtual machines running in the cloud to restore the guest instance in the case of hypervisor crash.

An exemplary embodiment of the present invention is provided for a Linux operating system. Those persons skilled in the art will recognize that the illustrated embodiment can be extended to any operating system. In this embodiment the task struct associated with the application is fetched from kernel dump file . The task mm mmap provides all virtual memory areas VMA associated with the task. An elf phdr structure is built for VMA of the task which includes information such as type size permission and page alignment. The associated page for the VMA is extracted from the kernel dump file by converting the corresponding virtual address to a physical address and then converting the physical address to file offset in the dump file.

Further information such as stack instruction pointer saved context and information related to multiple threads is fetched from task struct. Once all of this information is extracted from kernel dump file application is ready to be restored to the state it was in at the time of the system crash. The process of restoring application requires help from kernel and therefore requires suitable changes by kernel . The restoring procedure forks a process and creates threads for each thread in application to be restored. The address space is re mapped in these threads and the stack instruction pointer and all other thread or process specific data extracted from kernel dump file is restored with the help of kernel . Some of the application programming interfaces used to restore thread stack and to remap address space is already available with the Linux kernel as a part of check point restore technique. Once all the required data for application is restored inside a newly created process with the help of kernel the process is ready to run. The process is put in the run queue and starts executing when scheduled. In that way application runs after restoration according to any next operations that would have occurred if there were no system crash. This is possible because the stack address mappings cpu state and or instruction pointer are in the same state as when the system crashed.

In the above example a possible implementation technique is provided without low level implementation details. However implementation also requires taking care of additional details such as i handling the case when the application is in the middle of a system call and ii handling the open file descriptors.

Some embodiments of the present invention may include one or more of the following features characteristics and or advantages i the ability to restore an application in the case of system crash without the need for check pointing ii the application is restored to the state it was in at the time of system crash iii there is no need to perform regular check pointing and therefore the system saves resources cpu cycles to perform checkpoint operations and disk space to store the checkpoint image and or iv applications are not interrupted or frozen at regular intervals to take the snapshot during the checkpoint restore method.

