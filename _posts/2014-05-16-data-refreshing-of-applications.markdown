---

title: Data refreshing of applications
abstract: According to examples of the present disclosure, a method is provided to perform data refreshing of an application. The method may comprise registering a first view and a second view of the application to a group to which both the first view and the second view belong. The first view may be associated with a first data refresh function that is invocable to refresh data shown on the first view, and the second view with a second data refresh function that is invocable to refresh data shown on the second view. The method may further comprise, in response to determination that data refreshing is required for the first view in the group, performing data refreshing of the first view and the second view in the group by invoking the first function associated with the first view. Further, the method may comprise, in response to determination that data refreshing is also required for the second view in the group, performing data refreshing of the second view by invoking the second function associated with the second view.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09407714&OS=09407714&RS=09407714
owner: VMware, Inc.
number: 09407714
owner_city: Palo Alto
owner_country: US
publication_date: 20140516
---
The present application claims the benefit of U.S. Provisional Application No. 61 823 914 filed May 16 2013 and is related in subject matter to U.S. patent application Ser. Nos. 14 275 904 and 14 279 951 all three of which are incorporated herein by reference.

Unless otherwise indicated herein the approaches described in this section are not admitted to be prior art by inclusion in this section.

When data shown on an application changes data refreshing of the application is required. For example the changes may be due to a user s interaction with the application such as generating a create retrieve update and delete CRUD operation to create new data retrieve data from a database update or delete existing data shown on the application respectively. The changes may also be due to a user navigating through the user interface of the application. Data refreshing may require a lot of processing and bandwidth resources to for example retrieve the data and render a user interface of the application.

In the following detailed description reference is made to the accompanying drawings which form a part hereof. In the drawings similar symbols typically identify similar components unless context dictates otherwise. The illustrative embodiments described in the detailed description drawings and claims are not meant to be limiting. Other embodiments may be utilized and other changes may be made without departing from the spirit or scope of the subject matter presented here. It will be readily understood that the aspects of the present disclosure as generally described herein and illustrated in the drawings can be arranged substituted combined and designed in a wide variety of different configurations all of which are explicitly contemplated herein.

According to examples in the present disclosure data refreshing may be performed for multiple views of an application. The views which may generally refer screens or interfaces that form the application may be grouped based on their refresh requirements. When it is determined when data refreshing is required for one view in the group data refreshing may be performed for at least one other view in the group. As such data refreshing for multiple views may be controlled and performed simultaneously. Data refreshing of multiple views according to examples of the present disclosure also improves data consistency across related views in a group. For example if one view displays a list of active virtual machines in a system another view should display the relevant action item that is available for the active virtual machines.

In more detail is a flowchart of example process for data refreshing of an application. Example process may include one or more operations functions or actions illustrated by one or more blocks such as blocks to . The various blocks may be combined into fewer blocks divided into additional blocks and or eliminated based upon the desired implementation.

At block in a first view and a second view of the application are registered for data refreshing. Both the first view and the second view may belong to a group see block the first view may be associated with a first function that is invocable to refresh data shown on the first view see block and the second view may be associated with a second function that is invocable to refresh data shown on the second view see block .

At block in it is determined whether data refreshing is required for the first view. At block in in response to the determination that data refreshing is required for the first view data refreshing is performed for the first view by invoking the first function associated with the first view.

At block in since the second view belongs to the same group as the first view it is determined whether data refreshing is also required for the second view. At block in response to determination that data refreshing is also required for the second view data refreshing is performed for the second view by invoking the second function associated with the second view.

Data refreshing may be determined as required at block if the first view becomes visible such as when a visibility status of the first view that changes from invisible to visible. Similarly at block data refreshing may be required for the second view if it also visible. In another example a data stability status of data shown on the first view may be monitored and data refreshing is determined as required if the status indicates instability and the first view is visible. In these examples unnecessary processing costs for invisible views may be reduced by only refreshing visible views. For example data refreshing at blocks and may involve retrieving data from a database and re rendering the first view and second view to display the retrieved data. Data refreshing may also involve creating updating or deleting data shown on the first view and second view.

Example process may be implemented by any suitable device generally a client device executing the application e.g. using client side code in thick client architecture . Alternatively example process may be implemented by a server supporting the application e.g. using server side code in thin client architecture or a combination of both client and server implementations.

Throughout the present disclosure the terms first function and second function refer generally to computer methods procedures subroutines or any other set of computer readable instructions that may be invoked to perform data refreshing. The terms invoke or invoking refer generally to calling a function which may include providing suitable parameters to call the function. The term invocable indicates capability of being invoked.

The term application refers generally to any program instructions or functional components that execute on a device e.g. client device such as a web application mobile application executed on a mobile device such as smartphone tablet personal digital assistant etc. and desktop application executed on a desktop computer etc. The application includes multiple views which a user may interact with and navigate using any suitable input devices e.g. touchscreen keyboard stylus mouse etc. . The application may provide any suitable services to the client device such as database provisioning and management etc.

The application may be a web application which refers generally to an application that is provided by a server and accessible by a client device via a network. Web applications such as Rich Internet Applications RIAs provide more features than basic web applications and may be delivered by way of a site specific browser a browser plug in an independent sandbox JavaScript or a virtual machine etc. From an application developer s perspective web applications are generally less expensive and less complicated to develop and deploy. User s experience also improves since web applications are generally easier to use without having to fully install them locally at the client device or manually update them when new versions are available.

According to examples in the present disclosure example process facilitates centralized and automatic data refreshing for multiple views in a group such as based on the view s visibility and stability. This improves over conventional approaches that merely add an auto refresh feature to individual views. In more detail unlike example process the individual auto refresh function generally does not determine under which condition or when data refreshing should be performed. Further since data refreshing is implemented independently for each view in the conventional approaches it is more time consuming to maintain the code required. When it is necessary to update the code to update the auto refresh feature or when conditions for data refreshing change the code must be updated for each view to avoid the views behaving inconsistently.

Similarly example process also improves over conventional approaches that define an auto refresh feature in one class which is called by each view when data refreshing is required. In this case it is necessary for each view to maintain an auto refresh class increasing the consumption of memory for the maintenance. Again each view still has to determine when to call the auto refresh feature and without knowledge of the data refreshing requirement of other related views it is generally difficult to maintain data consistency across multiple views.

Further using the conventional approaches discussed above it may be more complicated and time consuming to implement data refreshing for multiple views having similar data at the same time. For example the first view of the application is for creating a new book object and the second view is to show information of the newly created object. Using example process the first view and second view are grouped together and when data refreshing is performed for the first view data refreshing is also performed for the second view if necessary e.g. when the second view is also visible .

Computing environment includes server e.g. web server application server etc. that communicates with client device over network e.g. Internet Intranet etc. . Client device executes application such as a web application mobile application and desktop application etc. In the case of a web application client device may access a service provided by server via application using any suitable client side program such as web browser etc.

Application may be implemented based on application framework which refers generally to a set of classes that provides application functionality and services. The set of classes represents a library of software code that may be used and reused by application developers to reduce development time and complexity. This saves an application developer from the task of rewriting a large amount of standard software code when building a new application.

Any suitable application framework may be used such as Apache Flex JavaFX and Microsoft Silverlight etc. for rich Internet applications RIAs . For example Apache Flex supports a component oriented programming model that allows developers to assemble applications from components and extend base components to create custom interactions. A web browser may load the relevant application framework package e.g. Apache Flex package from server and execute it on client device . Apache Flex source code may be compiled into Flash bytecode e.g. a SWF file that is executed by client device to render user interface of application on a client side program e.g. web browser . Other example web application frameworks include Google Web Toolkit GWT Vaadin and Ext JS etc.

User interface of application may include multiple views such as to which will be collectively referred to as views or individually as a general view . For example in a server client architecture such as example in server generally connects to databases to access data for delivery to computing device and display on views . In a database management application views may include View 1 e.g. left navigation view to display a list of databases. The user can navigate through different tabs or screens represented by View 2 e.g. databases view to display database properties e.g. name status database type cluster role base database template etc. and View 3 e.g. backup and recovery view to display information relating to backup and recovery e.g. backup type recovery point etc. . Remaining views and may be relating to tasks and events i.e. View 4 reports i.e. View 5 as well as logs and permissions both not shown for simplicity etc.

Depending on application framework views may be implemented using any suitable approach. For example using Apache Flex view may be implemented using a container class e.g. view and viewNavigator classes in Apache Flex etc. and the transition from one view to another may be managed by defining a state for each view e.g. view states in Apache Flex etc. . To a user interacting with web browser using client device application is presented as a series of views .

To facilitate data refreshing of views of application application framework includes a refresh framework to facilitate registration of views according to block and data refreshing according to blocks to in . As used herein the term refresh framework refers generally to a set of interrelated programs methods applications components or classes that facilitate data refreshing according to example process .

In the example in refresh framework includes registration manager to register and deregister views information manager to maintain information of registered views and refresh controller to control and perform data refreshing of views . Registration manager includes various modules for view registration see to and deregistration see . The modules see to may be used by view instances such as when they are added to user interface . Views generally have an initialization function and their registration may occur when the initialization function is called to add view .

 Register group module see of registration manager is to register views to a group. For example views are assigned to one or more groups such as View 1 and View 2 to Group 1 and View 2 to Group 1 and Group 2 etc. As such the relationship between views and groups is many to many i.e. each group may have multiple views and a view may belong to multiple groups. Grouping of views may be performed during the development of application e.g. based on business logic and updated as application evolves into newer versions.

Views of application are grouped based on their data refreshing requirements. The grouping may be based on any suitable requirements such as if they display similar or related data for the same entity e.g. database object or they have requirements to synchronize a state of the entity etc. Views in the same group may or may not be visible on user interface at the same time. The group assignment process allows multiple views belonging to the same group to be updated at the same time. That is if data refreshing is performed for View 1 other views in the same group e.g. View 2 in Group 1 that require data refreshing may also be similarly refreshed. In another example if two views e.g. View 1 and View 2 display the same data item e.g. database name etc. both views may be refreshed as the data item changes. If similar or related data items e.g. number of databases in View 1 and list of databases in View 2 are displayed they may also be refreshed at the same time.

Registration manager further includes various modules for registering view level data refresh functions see Register view data refresh function and group level data refresh functions see Register group data refresh function . In general views in a group may have similar or related data items that need to be fetched for data refreshing. For example application may wish to retrieve a virtual machine s unique model e.g. includes attributes such as name description storage memory etc. for multiple views e.g. View 1 View 2 and View 3 . View 1 may display only the name View 2 displays the name and description and View 3 displays all attributes.

The group data refresh function allows all attributes of the virtual machine to be fetched at the same time. Although possibly reducing redundant retrieval it might take longer and consume more resources to fetch all the required attributes at the same time. This might adversely affect the user s experience. As such if all the data cannot be fetched within a predetermined time the data refresh function of each view may be registered with Register view data refresh function module see . For example a first data refresh function for View 1 retrieves the name only a second data refresh function for View 2 retrieves the name and description while a third data refresh function for View 3 retrieves all attributes.

However if the data may be fetched within a predetermined time a group data refresh function for View 1 to View 3 is registered using Register group data refresh function module see . In this case a data callback function of each view is registered with Register view data callback function module see .

For example when a group data refresh function is invoked to fetch data the fetched data for the group may be one or more parameters of view s data callback function. From the perspective of view when its data callback function is invoked view is notified of the need to refresh data and uses the fetched data to perform data refreshing accordingly. As used herein the term data callback function may refer generally to a function subroutine or the like that is invocable to perform data refreshing for view using the data fetched by its associated group data refresh function. The data callback functions may be implemented using any suitable approach such as a listener function etc. For example a data callback function may be defined in refresh framework as a Function object in Apache Flex or an implementation of the listener interface in Java etc.

Similarly to determine whether data shown on view is stable registration manager further includes various modules for registering view level data stability functions see Register view data stability function and group level data refresh functions see Register group data stability function . For example a first data stability function may be registered for View 1 and a second data stability function for View 2 etc. If the group level function is used a group data stability function may be registered for both View 1 and View 2 to determine whether data shown are stable or otherwise. Similar to the group level data refresh function the group level data stability function may be implemented if it is efficient to do so.

Registration manager also includes Deregister view module see to deregister views such as when views are removed from user interface . This may be monitored using a display object or monitored view list that is updated as views are registered and deregistered.

Refresh framework further includes information manager to store and allow retrieval of information provided during the registration process using any suitable modules. For example Group information module is to manage view and group information including the name key group level functions e.g. group data refresh function and group data stability function where applicable . View data refresh function module is to manage each view s data refresh function e.g. first data refresh function of View 1 and second data refresh function of View 2 . View data callback function module is to manage each view s data callback function e.g. first data callback function of View 1 and second data callback function of View 2 . View data stability function module to manage each view s data stability function e.g. first data stability function of View 1 and second data stability function of View 2 .

Refresh framework further includes refresh controller which includes View visibility monitor and View refresh monitor for data refreshing using view level functions and Group data stability and refresh monitor for data refreshing using group level functions.

In more detail in example in data refreshing and data stability monitoring are both performed at a view level. View registration e.g. View 1 and View 2 includes registering each view s data refresh function e.g. first data refresh function of View 1 and second data refresh function of View 2 and data stability function e.g. first data stability function of View 1 and second data stability function of View 2 . See also flow leading to block in registration and data refreshing .

In example in data refreshing is performed at a view level and data stability monitoring at a group level. View registration e.g. View 1 and View 2 includes registering each view s data refresh function e.g. first data refresh function of View 1 and second data refresh function of View 2 and a group data stability function for both View 1 and View 2. See also flow leading to block in registration and data refreshing .

In example in data refreshing is performed at a group level and data stability monitoring at a view level. View registration e.g. View 1 and View 2 includes registering a group data refresh function for both View 1 and View 2 and each view s data stability function e.g. first data stability function of View 1 and second data stability function of View 2 . See also flow leading to block in registration and data refreshing .

In example in data refreshing and data stability monitoring are both performed at a group level. View registration e.g. View 1 and View 2 includes registering a group data refresh function and a group data stability function for both View 1 and View 2. See also flow leading to block in registration and data refreshing .

Examples to will now be explained with reference to to . Although a group of two views e.g. View 1 and View 2 are used in the examples for simplicity it will be appreciated that the group may include more than two views and example processes to apply accordingly.

At block in a group of views e.g. View 1 and View 2 are registered using Register group module of registration manager . Registering the group includes storing information relating to the group and views in the group.

Blocks and in relate to example in . For each view e.g. View 1 in the group Register view data refresh function module adds the view to user interface and its data refresh function e.g. first data refresh function . Register view data stability function module also registers each view s data stability function e.g. first data stability function of View 1 .

Blocks and in relate to example in . Example is the same as example except that block is performed instead of to register a group data stability function using Register group data stability function module .

Blocks and in relate to example in . Example is the same as example except that a group level data refresh function is registered instead of view level functions. Register group data refresh function module is used to register the group data refresh function. Register view data callback function module adds each view e.g. View 1 to user interface and registers each view s callback function e.g. first data callback function of View 1 . Register view data stability function module also registers each view s data stability function e.g. first data stability function of View 1 .

Blocks and in relate to example in . Example is the same as example except that block is performed instead of to register a group data stability function using Register group data stability function module .

In the example in blocks to relating to data refreshing may be performed by refresh controller using information obtained from information manager . Blocks to relating to view deregistration may be performed by registration manager . Using example process data refreshing may be determined as required based on a visibility status of views see blocks to and or data stability status of data shown on views see blocks to in a group.

At block in refresh controller monitors a visibility status of each view e.g. View 1 and View 2 belonging to a group registered for data refreshing. Any suitable implementation may be used to monitor the visibility status. For example using Apache Flex an event listener may be added to a Stage class instance associated with view to listen to view visibility change events such as stage.addEventlistener event.visibleChanged callback . The events may be monitored in this way because views are added as children of the Stage class which is the top level view container for all views that can monitor all views visibility change event. The callback in stage.addEventlistener is a function used to determine whether view triggering the visibility change event is related to a registered view. Here related may mean the view is a parent of a registered view e.g. View 1 or a registered view e.g. View 1 itself.

In another example also using Apache Flex the visibility change event may also be monitored by adding to every view in user interface an event listener for view visibility changed events to such as view.addEventlistener event.visibleChanged callback . The callback in view.addEventlistener is a function used to determine whether view triggering the visibility change event is related to a registered view. Here related may mean the view is a parent of a registered view e.g View 1 or a registered view e.g. View 1 itself. If related the visibility status of that view within refresh framework may be updated such that data refreshing can be performed. As such implementation using Apache Flex may include the monitoring of all views instead of just registered ones. Using other application frameworks it may not be necessary to monitor all views.

At block if the visibility status of one of the monitored views e.g. View 1 changes from invisible to visible it is determined that data refreshing is required. In this case at block data refreshing is performed for view e.g. View 1 by invoking its view level data refresh function e.g. first data refresh function of View 1 . Otherwise data refreshing is not required example process proceeds to block .

At block in refresh controller determines whether data refreshing is required for at least one other view e.g. View 2 in the group such as based on its visibility status. If yes e.g. View 2 is visible at block data refreshing is performed by invoking its data refresh function e.g. second data refresh function of View 2 . Otherwise data refreshing is not required example process proceeds to block .

At block in refresh controller monitors the data stability status of each view e.g. View 1 in the group using view level data stability functions e.g. by invoking first data stability function of View 1 . For example the data may become unstable after a new object e.g. database object is created. Since the creation takes time the data relating to the new object remains unstable until the creation completes. The data shown on View 1 may also be unstable while the data is updated or deleted.

At blocks and in data refreshing is determined as required if the data stability status of one of the monitored views e.g. View 1 indicates that data instability and that view e.g. View 1 is visible. In this case at block data refreshing is performed for view e.g. View 1 by invoking its data refresh function e.g. first data refresh function of View 1 . Otherwise data refreshing is not required example process proceeds to block .

At block in refresh controller determines whether data refreshing is required for at least one other view e.g. View 2 in the group such as based on its visibility status. If yes e.g. View 2 is visible at block data refreshing is also performed for that view e.g. View 2 by invoking its data refresh function e.g. second data refresh function of View 2 . Otherwise data refreshing is not required example process proceeds to block .

Although not shown refresh controller may continue monitoring the data stability status of view e.g. View 1 at blocks to and repeat the process until the data becomes stable again or data refreshing is not required e.g. View 1 is no longer visible . The repetition may occur at suitable time interval e.g. a few seconds or minutes to reduce unnecessary processing costs.

At blocks to in views may be deregistered from refresh framework when data refreshing is no longer required. For example information manager may maintain a list of monitored views . For example using Apache Flex the list may be implemented using the DisplayObject class which is the base class for all objects that can be placed on the display list. The display list manages all objects displayed on user interface .

At block when view e.g. View 1 is removed from user interface it is deregistered. This means that view e.g. View 1 is removed from the monitored view list in which case function information relating to view e.g. including any data refresh and data stability functions will be removed by information manager . At block example process ends if no view needs to be monitored i.e. list is empty but otherwise the above are repeated.

Since views in a group are deregistered as they are removed from user interface a group may be empty at one stage if all of its views are deregistered. In one example depending on application the group may be maintained until application is closed. This generally simplifies implementation since a group to which views may be added and removed is kept alive until application is closed. In another example a group may be deregistered once all its views are deregistered. In this case registration manager may include a Deregister group module to deregister a group not shown for simplicity .

Further depending on application views e.g. View 1 to View 5 in may be children of a parent view e.g. View 6 not shown for simplicity . In this case during the registration process children views e.g. View 1 to View 5 may be registered with a group associated with its parent view e.g. View 6 at block in . When it is necessary to deregister view e.g. View 1 it is deregistered from the group associated with its parent view e.g. View 6 . Depending on whether view level or group level monitoring is used blocks to may then be used to register other information and example processes in to for data refreshing and data stability monitoring.

Blocks to in are the same as corresponding blocks to in except that a group level data stability function is invoked at block . In particular since data stability monitoring is performed at a group level refresh controller invokes a group data stability function to monitor a data stability status of each view .

Using example process it is not necessary for each view to maintain a view level data stability function. Since views in a group may have related data items the stability of the data items may be monitored by invoking the group level function. This may further improve data refreshing efficiency and reduce implementation costs.

Deregistration of views according to blocks to are the same as corresponding blocks to in . Similar examples apply.

Blocks and in are the same as corresponding blocks and in . Since a group level data refresh function is used at blocks and refresh controller invokes the group data refresh function associated with view e.g. View 1 whose visibility status changes to visible to fetch data. At block based on the fetched data data refreshing is performed for view e.g. View 1 by invoking its data callback function e.g. first data callback function of View 1 .

At blocks and in refresh controller determines whether data refreshing is required for at least one other view e.g. View 2 in the group. If yes e.g. View 2 is also visible at block refresh controller performs data refreshing for that view e.g. View 2 by invoking its data callback function e.g. second data callback function of View 2 . Depending on the type of data shown on view e.g. View 2 all or part of the data fetched using the group data refresh function may be used. Otherwise data refreshing is not required for View 2 example process proceeds to block .

Blocks to are the same as corresponding blocks and in . At block if any view has an unstable data status refresh controller determines whether the view is visible and requires data refreshing. At block however once it is determined that data refreshing is required for view e.g. View 1 because its data is unstable and it is visible refresh controller invokes the group data refresh function to fetch data. At block data refreshing is then performed by invoking the view s data callback function. Although not shown in for simplicity refresh controller may repeat blocks to for at least one other view e.g. View 2 in the group that is also determined to be visible at block . Blocks to may also be repeated e.g. at fixed intervals until the data is stable again.

Deregistration of views according to blocks to are the same as corresponding blocks to in . Similar examples apply.

Blocks to in are the same as corresponding blocks to in except that a group level data stability function is invoked at block . In particular since data stability monitoring is performed for the entire group of views e.g. View 1 and View 2 refresh controller invokes a group data stability function to monitor a data stability status of the views .

Since views in a group may have related data items the stability of the data items may be monitored by invoking the group level function. Similar to example process it is not necessary in example process for each view to maintain a view level data stability function. This may further improve data refreshing efficiency and reduce implementation costs.

Deregistration of views according to blocks to are the same as corresponding blocks to in . Similar examples apply.

In this case application is a web application supported by server . Similar to the example in server is accessible by client devices to access web application implemented based on web application framework . Refresh framework facilitates data refreshing of web application according to the examples in to . Data may be retrieved from and or provided to databases during data refreshing.

Server is connected to physical servers also known as hosts that each execute virtualization software e.g. hypervisor and include suitable hardware to support multiple virtual machines . Virtualization software also maintains a mapping between virtual resources and physical resources such as CPU resources e.g. processors memory resources e.g. random access memory network resources e.g. access networks and storage resources e.g. storage using databases . Each virtual machine may support guest operating system and at least one application e.g. database instance .

Services supported by server and accessible e.g. via an application programming interface may include the provisioning management and maintenance of storage resources e.g. databases CPU resources memory resources network resources virtual machines etc. The services may also be related to the provisioning management and maintenance of objects stored in storage resources and or memory resources etc.

The above examples can be implemented by hardware software or firmware or a combination thereof. is an example system configured to perform data refreshing of application in accordance to at least some examples in the present disclosure. Example system may include processor memory network interface device and bus that facilitate communication among these illustrated components and other components.

Processor is to perform processes described herein with reference to to . Memory may store relevant data or information to perform data refreshing of application such as information relating to views groups data refresh functions data stability functions etc. Memory may further store machine readable instructions executable by processor to cause processor to perform processes described herein with reference to to .

The methods processes and components described herein may be implemented by hardware including hardware logic circuitry software or firmware or a combination thereof. The term processor is to be interpreted broadly to include a processing unit ASIC logic unit or programmable gate array etc. The techniques introduced above may be implemented in special purpose hardwired circuitry in software and or firmware in conjunction with programmable circuitry or in a combination thereof. Special purpose hardwired circuitry may be in the form of for example one or more application specific integrated circuits ASICs programmable logic devices PLDs field programmable gate arrays FPGAs and others.

Software and or firmware to implement the techniques introduced here may be stored on a non transitory machine readable storage medium and may be executed by one or more general purpose or special purpose programmable microprocessors. A machine readable storage medium as the term is used herein includes any mechanism that provides i.e. stores and or transmits information in a form accessible by a machine e.g. a computer network device personal digital assistant PDA mobile device manufacturing tool any device with a set of one or more processors etc. . For example a machine accessible storage medium includes recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. 

The figures are only illustrations of an example wherein the units components or processes shown in the figures are not necessarily essential for implementing the present disclosure. Those skilled in the art will understand that the units in the device in the example can be arranged in the device in the examples as described or can be alternatively located in one or more devices different from that in the examples. The units in the examples described can be combined into one module or further divided into a plurality of sub units.

It will be appreciated by persons skilled in the art that numerous variations and or modifications may be made to the above described embodiments without departing from the broad general scope of the present disclosure. The present embodiments are therefore to be considered in all respects as illustrative and not restrictive.

