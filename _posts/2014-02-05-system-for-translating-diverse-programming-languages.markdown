---

title: System for translating diverse programming languages
abstract: A computer language translator that translates all or any portion thereof of source code in an original computer language to source code in a target computer language, which may then be translated back to the original language while still maintaining concept, syntax, form of expression, and formatting of the original source code. The translator may take the form of a tool that resides on a server such that the user may select file of source code corresponding to desired functionality and the user may indicate which computer language the file should provided in. The tool will then translate the selected file to the desired computer language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09086931&OS=09086931&RS=09086931
owner: PureNative Software Corporation
number: 09086931
owner_city: Brooklyn
owner_country: US
publication_date: 20140205
---
The present invention relates to a system and method for translating source code between different computer languages and different operating environments. More specifically the present invention relates to a bi directional computer language translator where source code written in an original language may be translated to a target language and then may be translated back to the original language while still maintaining concept syntax form of expression and formatting of the original source code.

Computer systems and applications have reached almost every market on a global scale. As a result vast sums of money are spent in researching and developing new applications and programs. Typically these applications are written in a computer language selected by a software developer or by a group of software developers.

A trend among software developers has been toward use of object oriented programming OOP languages. Three major categories of OOP languages are 1 systems programming languages which are generally unmanaged and natively compiled and in turn executed natively 2 productivity oriented business application programming languages which are generally managed and compiled to non native bytecodes or a non native intermediate language IL and in turn executed non natively by a managed runtime environment or virtual machine and 3 scripting languages which are generally managed and expressed in plain text source code instead of a binary form like compiled languages and in turn plain text source code is executed non natively by a scripting runtime environment or virtual machine.

Scripting languages are relatively easy to program computer languages that use simpler and more permissive forms of expression than compiled languages such as Java and C . Scripting language programs are usually expressed in plain text as source code instead of a binary form like compiled programs which makes them very readable and easy to modify. They are generally interpreted instead of being explicitly compiled by the programmer. This means that programmers see immediate results from their programming statements and makes for a very interactive development experience. These features make scripting languages well suited for beginners experimentation and research system administrative tasks and high productivity fast turn around development projects. Scripting languages are becoming dominant in Web programming both for Web server and Web client programming. Scripting languages are also used in for example Adobe Flash integrated runtime environments from Adobe Microsoft and Sun desktop operating environments like Mac OS X as well as mobile devices such as for example but not limited to the iPhone that runs iOS and the various Android devices that run Android OS. The mobile devices would also include tablet devices such as for example but not limited to the iPad that runs iOS or the Google Nexus and Samsung Galaxy that run Google s Android OS. For these reasons scripting languages are very popular with programmers and the range of devices that supports them continues to grow.

Systems programming languages are typically used for developing performance critical applications operating systems operating environments operating system specific applications managed runtime environments and virtual machines embedded systems and hardware specific software such as for instance device drivers. Systems programming languages are generally lower level languages which offer finer control over the run time execution of applications. Systems programming languages include for instance but are not limited to C and C .

Productivity oriented business application languages are typically used for developing applications for electronic commerce wireless devices multimedia devices and platforms accessing databases web applications and other business related needs. Productivity oriented business application languages are generally higher level languages which offer greater programmer productivity and increased reliability during the run time execution of applications. Business application languages include for instance but are not limited to Java and C pronounced C Sharp . These however are just a few of the many OOP languages that may be utilized in generating applications.

Traditionally software developers choose one computer language for systems programming and another for business applications programming. In doing so however they must make sacrifices and accept the tradeoffs of the selected language. The application design methodology and business model may all factor into the choice of programming language used for a particular application.

For instance C is typically viewed as an advantageous language for creating large scale applications whereas Java is typically viewed as optimized for the distribution of program objects in a network such as the Internet. Java is generally considered a higher level language than C that is closer to the actual business application. As a result many programmers prefer to write programs in Java because it is generally considered an easier language to use than C .

Another advantage Java provides is that Java objects cannot contain references to data external to themselves or other known objects. This ensures that an instruction input by a programmer cannot contain an address of data storage in another application or in the operating system itself either of which could cause the program and possibly even the operating system to terminate or crash. In addition Java utilizes a virtual machine that makes a number of checks on each object to ensure integrity. This results in a finished application that is not prone to low level memory errors and requires considerably less debugging. C on the other hand does not have these safety functions such that a programmer may inadvertently or maliciously cause problems with the operating system. In addition many of the computer viruses seen today exploit this characteristic of C to cause widespread computer problems. Many of these problems could be avoided by utilizing Java because of the built in safety checks and balances inherent to the language.

Alternatively there are some distinct advantages associated with C as opposed to Java. For instance C is generally considered a higher performance language than Java. Once an application is written in C it may be compiled to native code or machine code as opposed to Java which is typically compiled into bytecode. As a result unlike Java a program compiled into native code does not need to operate with a virtual machine which results in increased application performance. Another advantage to compiling a program to native code is that it is very difficult to derive the C source code from the native code whereas it is a fairly simple matter to derive the Java source code from the compiled bytecode. Therefore C can provide greater protection for a company s intellectual property.

In view of the forgoing there is an inherent tension between using Java and using C . Many programmers would prefer to write programs in Java however many companies want their end product to be completed in C so that it may be compiled into native code. However companies also recognize the benefits of using Java realizing that it may be a faster and less expensive way to get new products and services to market. This is because Java is generally considered an easier language to use and also because of the greatly reduced debugging time associated with new applications.

Historically it has been very difficult or nearly impossible to convert a program written in C to Java and or vice versa. To do so requires manual porting which is generally labor intensive error prone and requires extensive re testing.

To address these issues and minimize the differences between computer languages a number of existing systems have tried a number of approaches. These include for instance 1 cross language interoperability layers and object mapping mechanisms 2 native compilers for traditionally non natively compiled languages 3 programs which convert or migrate computer programs from one language to another language and 4 programs which translate computer programs between different computer languages. None of these approaches however have provided an acceptable solution.

For instance one approach taken is cross language interoperability layers and object mapping mechanisms including the Sun Microsystems Java Native Interface JNI the Microsoft Common Object Model COM and the Object Management Group OMG Common Object Request Broker Architecture CORBA . Such solutions are generally suited for integrating two or more different computer languages and operating environments. However they do not eliminate the need for middleware such as virtual machines managed runtime environments and object request brokers ORBs but instead increase dependence on these. This dependence make these solutions unsuitable for demanding low level systems programming for developing for instance operating systems virtual machines and embedded systems.

A second approach taken includes native compilers for traditionally non natively compiled languages including for instance the GNU Compiler for Java GCJ and the Excelsior JET. The GNU Compiler for Java GCJ is a free open source software project and is disclosed in U.S. Pat. No. 6 110 226. These products compile Java source code or Java bytecode a platform independent intermediate language to native binary executables. The GCJ compiler may generate native binary executables which do not require a virtual machine to execute program so long as the compiled Java program does not make use of Java classes or objects which are externally referenced or otherwise not natively compiled. In the latter case the compiled native binary executable requires an internal statically linked or external dynamically linked virtual machine which suffers from the same drawbacks as cross language interoperability layers and object mapping mechanisms. Alternatively Excelsior JET for instance generates native binary executables that generally depend on the presence of a virtual machine on the client system in order to run. However these requirements carry the same drawbacks as common cross language interoperability layers and therefore negate most of the benefits of native compilers.

While the GCJ compiler does support interoperability with C through CNI Cygnus Native Interface this means of interoperability however is effectively limited to the GNU C compiler. GCJ does not support interoperability with leading platform specific C compilers such as Microsoft Visual C for Microsoft Windows operating system nor does it support the industry standard JNI to interoperate with leading Java virtual machines. Additionally native compilers do not translate source code to another computer language so they do not inherently benefit from wealth of available software development tools such as compilers linkers optimizers and debuggers or features of other popular computer languages such as C .

A third approach has been to convert or migrate source code in one computer language to another computer language. This approach is disclosed in U.S. Pat. No. 6 453 464 the 464 patent . This approach is directed toward migrating source code from an aging computer language such as for instance COBOL to an OOP language such as Java. However the resulting translated source code does not fully preserve the style and spirit of the original source code is not easily human readable and does not support translation back to the original language. Therefore the system disclosed in the 464 patent cannot be used for bi directional translation between OOP languages to combine the best features of both languages.

A fourth approach taken has included computer language to computer language translation. Existing translators include Toba C2J and J2C among others. These solutions however have severe limitations of their respective design and implementation. For instance they fail to manage objects exactly like the original language manage arrays exactly like the original language maintain the same high level of thread safety characteristic in the original language and support the full breadth of features of the original language. Additionally none of these approaches support nor addresses bi directional translation. Still further these one way translation approaches generally require translation of the entire application at one time rather than providing for translation of only a file or a portion of a file.

Most modern scripting languages support Object Oriented Programming OOP features. Such object oriented scripting languages include but are not limited to JavaScript Ruby Python Perl and PHP. Object oriented programming features make such scripting languages easier to understand and their programs more maintainable. Further to assist programmers modern object oriented programming languages have their own language specific API class library.

However not all the world s programmers are proficient in scripting languages and not all the world s devices support or efficiently support scripting languages. For example a developer proficient in C or Java may prefer to run an existing C or Java program in a scripting environment. To do so the developer would need to become proficient in the target scripting language and its associated API class library and would need to manually rewrite the existing C or Java program in the target scripting language. As another example a developer proficient in a certain scripting language such as JavaScript Python Ruby Perl or PHP would need to rewrite the program in C in order to run on an embedded or mobile device that did not support scripting languages.

Further not all scripting languages are supported on all devices that support scripting. For example Web browsers generally only support JavaScript and not Ruby Python Perl or PHP. Still further a developer may need to produce a program that runs at peak efficiency on a device. Even though the device supports scripting languages in order to perform at maximum speed and efficiency the program must instead use a compiled programming language such as C . In this example the developer would need to be proficient in C and either create or rewrite the program in C in order to meet the project requirements.

Further there is a vast amount of source code especially open source programs readily or freely available on the Internet and through various other forms of distribution such as CD ROM and DVD ROM. However usually an individual program is only available for one particular computer language or perhaps a few computer languages. It is common for software developers to come across source code especially by searching the Internet or by examining public source code repositories which meet their needs except that the source code they have found is in a different computer language than their project requires. Such developers are faced with either manually porting the source code to their target computer language or limit their search results to only source code in their target computer language neither option being desirable.

Further for various business and technical reasons certain devices will lack support for a particular scripting language and scripting runtime environment. The ability to add support for a particular scripting language and scripting runtime environment would be a desirable feature for consumers and vendors alike especially if the feature could be provided entirely in software without requiring any hardware modifications. For example the lack of support for Adobe Flash and its associated scripting language ActionScript on the iPhone has been a cause for complaint on the part of present and prospective iPhone user alike. At present the wide range of Adobe Flash and ActionScript language programs are not available to iPhone users.

Further the inherent nature of scripting language programs being expressed in plain text source code is highly undesirable for certain applications and certain organizations. In order to safeguard intellectual property preserve trade secrets and prevent tampering especially related to computer security online crime and circumventing protection schemes for digital media it would be essential that certain applications only be distributed in compiled binary form. This would either preclude scripting languages for such applications or it would necessitate manually porting existing scripting language programs to a compiled language before being externally distributed.

For these reasons it is desirable for an invention to automatically translate source code from an object oriented scripting language to a compiled object oriented programming language.

In line with this it is further desirable to seamlessly and automatically translate a program at runtime such as during the process of downloading and starting the program from a foreign or unsupported object oriented scripting language to a scripting language for which the host device includes built in support.

Further it is desirable for an invention to automatically translate source code from a compiled object oriented programming language to an object oriented scripting language.

Still further is desirable for an invention to automatically translate source code from an object oriented scripting language to another object oriented scripting language.

It is further desired to provide a computer language translation system that may be coupled with associated software libraries and accurately and reliably translate source codes between higher level productivity oriented business application programming languages and systems programming languages.

It is still further desired to provide a bi directional computer language translation system that may accurately and reliably translate source code from a higher level productivity oriented business application programming language to a systems programming language and back again.

It is yet further desired to provide a computer language translation system that is usable with multiple computing platforms operating systems and operating environments.

It is also desired to provide a computer language translation system that provides deterministic automated object management without a garbage collector in order to be suitable for embedded systems.

It is still further desired to provide a computer language translation system that may utilize industry standard compiler tools such as for instance ANSI C compilers.

It is yet further desired to provide a computer language translation system that will be virtual machine agnostic specifically that will be able to operate without a virtual machine or conversely if desired able to interoperate with an industry standard virtual machine.

It is still further desired to provide a computer language translation system that adheres to industry standards for cross language interoperability such as JNI for interoperability between Java environments and C environments.

It is also desired to provide a computer language translation system that can be utilized by an Internet or Intranet search engine in order to automatically translate search results comprising source code from the original computer language of the found source code to the preferred computer language of the user requesting the search.

It is also desired to provide a computer language translation system that can be utilized by the search indexing engine of an Internet or Intranet search engine. As the search indexing engine comes across source code the search indexing engine can use the invention to automatically translate source code from the original computer language of the source code to a multiplicity of computer languages and then index the source code in its original computer language as well as a multiplicity of computer languages. This would allow the search engine to find more code sample in diverse computer languages regardless of the computer language of the search query itself.

It is yet further desired to provide a computer language translation system that may be utilized to translate only a portion of the source code to be translated.

Accordingly a bi directional translator has been provided that translates source code from one computer language to another divergent computer language. The translated source code closely resembles the original program source code in concept syntax form of expression and formatting. The system may be utilized as either an automatic translator that automatically translates source code from one computer language to another or may be utilized in connection with a software development library that enables programs to be manually ported from one computer language to another.

When the system is utilized to automatically translate a software tool is provided that automatically translates programs written in for instance the Java language to the C language the Objective C language the Smalltalk language or from or to a scripting language such as JavaScript Python Ruby or Perl. The tool makes use of tables and specific language knowledge of Java and C or the scripting language. This tool does not require clean up or hand editing after translation. The final translated programs may be built and run as is.

Alternatively if the system is used by a programmer who is manually porting the source code a software development library that implements the Java language and core APIs in ANSI standard C syntax is provided. Manually ported C programs which make use of the library closely resemble the original programs in the Java language.

Because of the nature of divergent OOP languages such as Java and C or scripting languages the divergent languages are incompatible meaning that one word does not simply translate straight to another word. For instance the way variables are identified in Java is different than in C . To achieve bi directional translation the system in resolving incompatibilities performs a name adjustment that is consistently utilized throughout. Because the name adjustments are always consistent the system may re translate either the entire document or only small sections as desired.

The system also utilizes tagged elements or tags which are inserted by the system to control how for instance a specific section of source code is translated. The tagged element may include a Java instruction inserted into the C translation. In this manner if the Java source code instruction is incompatible with any C source code instruction the original is not lost but instead is maintained in a tagged element within the C source code. This feature facilitates bi directional translation because the original language may be exactly re created from the translation even with incompatibility problems.

It is understood that the software that executes the translation of OOP language s may reside on a computer operated by a user a programmer . However it should be understood that the translation software may reside on a web server in the cloud. A user may visit a location on the Internet to obtain open source code e.g. sites such as GitHub.com and the like . However the source code may be provided in a first programming language that the user does not want to utilize. In this case it is contemplated that a translation tool may be provided in the cloud allowing the user to translate the software from the first programming language to a desired second programming language.

In one embodiment the translation tool could be positioned on a server accessible by a web page such that the user can upload the source code in the first programming language to the web page then select the desired second programming language the user desires the source code to be translated to. When completed the translation tool could alert the user that the translation process is completed. The source code in the desired second programming language could be pushed out to the user e.g. emailed to an email address provided by the user as an archive file such as a .zip file or the like or could notify the user that the source code is ready to be downloaded e.g. the user can click on a link provided in a notification that takes the user to a web page to download the source code in the second programming language .

Alternatively it should be understood that the translation tool could be provided as a tool on the web page the user is obtaining the source code from. For example the user could visit a web page browse for source code providing a particular functionality and when code providing the desired functionality is identified the user could be presented with an option to select the OOP language the user would like to receive the source code in e.g. Java C C etc. . In this manner the user would not have to upload the source code to a different website as the translation tool is executing on the web page the user obtained the source code from. Again the source code would be provided in the desired OOP language as a file s pushed out to the user or provide a notification allowing the user to pull the file s as desired.

It is further understood that in another embodiment the user may be provided with a preview of the individual translated files. For example the user may select source code and then have the translation tool translate the selected source code to a desired OOP language. Once translated the user could be presented with a preview of individual files that have been translated by the tool. In still another embodiment the translation tool could allow the user to execute the translated program over the Internet to view and or evaluate the functionality of the translated source code.

It is further understood that in another embodiment the user may choose to compile and build the translated source code into an executable binary application package or a binary library. Once built the executable binary application package or binary library could be pushed to one or more app stores software component stores or beta testing sites such as TestFlight testflightapp.com . In addition the user may choose to build the application or library for a multiplicity of OS platforms device platforms app stores and beta testing sites. In addition the user may choose to package source code along with the binary application or library which may be necessary to satisfy open source licensing requirements or other deployment requirements.

It is further understood that the user may subscribe to automatic updates to translated source code as well as to binary executable applications and libraries built from such translated source code. The translation process and updates could be triggered by commits to the source code of user specified projects in an online source code repository such as GitHub. Alternatively the automatic updates could be scheduled at a user specified time interval such as hourly or daily. In either case the latest source code would be obtained from user specified source code repository before translation and building. In addition the translation tool and build process could be run by a continuous integration server such as Jenkins.

The term data as used herein means any indicia signals marks domains symbols symbol sets representations and any other physical form or forms representing information whether permanent or temporary whether visible audible acoustic electric magnetic electromagnetic or otherwise manifested. The term data as used to represent particular information in one physical form shall be deemed to encompass any and all representations of the same particular information in a different physical form or forms.

The term storage as used herein means data storage devices apparatus programs circuits systems subsystems or other elements whether implemented in hardware software or both and whether used to process data in analog or digital form into which data may be entered and from which data may be obtained as desired. Storage can be primary and or secondary and can store data in electromagnetic magnetic optical magneto optical chemical and or holographic forms.

The term processor as used herein means data processing devices apparatus programs circuits systems and subsystems whether implemented in hardware software or both and whether used to process data in analog or digital form. The processor can operate on data in electromagnetic magnetic optical magneto optical chemical and or holographic forms.

The terms communicate communicating and communications as used herein include both conveying data from a source to a destination as well as delivering data to a communications medium system or link to be conveyed to a destination. The term communication as used herein means the act of communicating or the data communicated as appropriate.

The terms coupling coupled coupled to and coupled with as used herein each mean a relationship between or among two or more devices apparatus files programs media components networks systems subsystems and or means constituting any one or more of a a connection whether direct or through one or more other devices apparatus files programs media components networks systems subsystems or means b a communications relationship whether direct or through one or more other devices apparatus files programs media components networks systems subsystems or means or c a functional relationship in which the operation of any one or more of the relevant devices apparatus files programs media components networks systems subsystems or means depends in whole or in part on the operation of any one or more others thereof.

The term network as used herein means the communications linkage used to join two or more units such as systems networks links nodes equipment circuits buses and devices and includes without limitation networks of all kinds including coupling amongst components of a system both intra networks and inter networks and including but not limited to the Internet and is not limited to any particular such network.

The terms computer language and computer programming language as used herein mean a computer programming language for accomplishing software development and or expressing the source code of a computer program. Furthermore a computer programming language may or may not be classified as object oriented. Computer programming languages include but are not limited to Java C and C .

The terms virtual machine VM virtual machine environment managed runtime and managed runtime environment MRE as used herein refer to an apparatus either software or hardware which executes bytecode. Virtual machines may also include a platform application programming interface API or platform classes that bytecode programs may call or otherwise make use of. Virtual machines are designed to isolate software programs from the underlying native hardware and software platform which facilitates the creation deployment and execution of distributed secure platform independent software programs and components. Java and C are designed for virtual machine environments whereas C is not.

The term bytecode as used herein refers to a non native binary representation of an executable program or software component. Bytecode is designed to be executed by a virtual machine. Bytecode may also be referred to as an intermediate language IL . 

The term garbage collector as used herein refers to an apparatus for automated object management where allocated memory is automatically reclaimed when it is unneeded which is accomplished through a housekeeping process. The housekeeping process may further include memory compaction. The housekeeping process is generally performed nondeterministically at the primary discretion of the garbage collector. Virtual machine environments such as those for Java and C include a garbage collector. Legacy and ANSI C programming environments do not include a garbage collector.

The term SourceUnit is the smallest unit of autonomous source code which may be compiled interpreted or executed depending on the capabilities of the source language. This generally refers to an individual source code file such as in Java C or C . In C and some other languages a SourceUnit may be referred to as a compilation unit. 

The term Document Object Model DOM is an object oriented programming interface for representing the different conceptual elements of a document. Furthermore the individual elements in a DOM may be stored in a hierarchy.

The term SourceUnit DOM is a specialized DOM for representing the different conceptual elements of a source code file or document. The SourceUnit DOM is only intended for representing source code files. The conceptual elements making up a SourceUnit DOM include single line comment multiple line comment package statement import statement class definition field definition implementation block implementation statement method definition static constructor definition exception statement control flow statement and text. There is only one SourceUnit DOM per SourceUnit. The SourceUnit DOM is a complete representation of the original SourceUnit including its formatting. Alternatively the term SourceUnit DOM may also apply to an Abstract Syntax Tree AST that serves the same purpose of representing the different conceptual elements of a source code file or document.

The term tagged element is a note inserted by the translator that contains extra information to be preserved through the translation process. A tagged element is embedded inside specially denoted single line comment or multiple line comment elements. This extra information captures logic and other content from the original source files that typically cannot be preserved in translation but through such tagged elements allows such logic and content to be preserved in translated results.

The term keyword means a word that always has the same meaning and cannot be used for any other purpose i.e. as identifiers.

The term class is a type in an object oriented programming language. A class may have methods data fields and inner classes classes within classes which may all be generically referred to as class members. The term class also can refer to an interface. 

The term method is a function or procedure that a particular class may do. A method may or may not be provided with variable parameters and it may or may not return a value. A method is always associated with a particular class and it may be referred to as a class member. The term method also applies to constructors and destructors.

The term constructor is a function or procedure that will be used to initialize an object which an instance of a particular class. A constructor may or may not be provided with variable parameters and it may not return a value. A constructor is always associated with a particular class and it may be referred to as a class member. A class must have at least one explicit or implicit constructor in order to instantiate instances of itself.

The term destructor is a function or procedure that will be used to destruct an object which an instance of a particular class. A destructor may not be provided with variable parameters and it may not return a value. A destructor is always associated with a particular class and it may be referred to as a class member. A class may have only one destructor which itself is optional. In Java a destructor is called a finalizer. 

The term data field is a variable that a particular class contains. A data field may be a numeric value a Boolean value an object reference or an interface reference or an array reference. A data field is always associated with a particular class and it may be referred to as a class member. 

The term interface is a class that declares one or more methods but it does not define implement any of these methods. Instead other classes which implement a particular interface must themselves define implement all of the interface s methods.

The term class declaration is the declaration of a new class or interface type. A class declaration is sometimes referred to as a class interface. It describes the constructors destructor finalizer methods data fields and inner classes a class within a class that make up a particular class. Constructors destructor methods data fields and inner classes of a particular class may be referred to generically as class members. A class declaration defines the access control for each of its class members be they constructors destructor methods data fields or inner classes. A class declaration also details which class this class inherits from which includes its superclass and any interfaces it implements. Certain computer languages like C allow separating class declarations from class implementations whereas other languages like Java and C combine both the class declaration and class implementation into the class definition. A public class declaration makes a particular class accessible so that other external classes can create or interact with instances of the class. In turn other external classes come to depend on the class declaration which necessitates that the class declaration remains consistent.

The term class implementation is the implementation of a newly declared class type. It implements its constructors destructor methods static data fields and inner classes. Certain computer languages like C allow separating class declarations from class implementations whereas other language like Java and C combine both the class declaration and class implementation into the class definition. The class implementation is not directly accessible to other external classes but only the class declaration is. This means that the internal class implementation may potentially be changed without adversely affecting other classes which depend on its class declaration.

The term class definition is the definition implementation of a new class type. The exact meaning of this term differs from computer language to computer language. For Java and C this refers to the combined class declaration and class implementation. In C this refers only to the class implementation.

The terms first and second are used to distinguish one element set data object or thing from another and are not used to designate relative position or arrangement in time.

The term object oriented programming language is programming that represents concepts as objects that include data fields and associated procedures. Object oriented programming languages include for example but are not limited to C Java Objective C C Smalltalk Perl PHP Ruby and Python.

In one advantageous embodiment a computer language translator is provided that includes translating software executing on a computer having a storage. The translating software is provided for translating a first OOP computer language source code to a second OOP computer language source code. The translating software comprises an emulated Application Programming Interface library including a table accessible by said translating software on the computer. The API library has data indicative of types of data manipulations between the first computer language source code and the second computer language source code. The table includes second computer language equivalent functions callable by the second computer language. The translator is provided such that the translating software identifies the type of data manipulation the first computer language source code performs and accesses the table of the API library and correlates the type of data manipulation the first computer language source code performs to second computer language source code. The translator is further provided such that the translating software generates second computer language source code based in part upon identified equivalent functions in the second computer language.

In another advantageous embodiment a method is provided for translating a first OOP computer language source code to a second OOP computer language source code comprising the steps of providing a computer with a storage the computer having translation software executing thereon. The method further comprises the steps of providing an emulated Application Programming Interface library having data indicative of types of data manipulations between the first computer language source code and the second computer language source code. The method further comprises the steps of providing a table associated with the API library including second computer language equivalent functions callable by said second computer language. The method still further comprises the steps of identifying the type of data manipulation the first computer language source code performs and accessing the table and correlating the type of data manipulation the first computer language source code performs to second computer language source code. The method also comprises the steps of generating second computer language source code based in part upon identified equivalent functions in the second computer language.

In still another advantageous embodiment a computer language translation tool for translating a first OOP computer language source code to a second OOP computer language source code is provided comprising a computer having software executing thereon. The software comprises a translation module and an emulated Application Programming Interface library module. The API library includes data indicative of types of data manipulations of the first OOP computer language source code and second computer language API equivalent functions callable by said second computer language. The translation module accesses the table of the API library and correlates the type of data manipulation the first OOP computer language source code performs to second OOP computer language source code. The software also comprises a generation module generating second OOP computer language source code based in part upon identified equivalent functions in the second computer language.

In yet another embodiment a method for providing source code in a desired Object Oriented Programming OOP computer language is provided the method comprising the steps of providing a server having a network connection and an interface allowing a user computer to access the sever via the network connection presenting the user with a plurality of source code functionality corresponding to a plurality of files and receiving a selection of from the user of a selection of at least one of the plurality of files. The method further comprises the steps of receiving a desired OOP computer language selection from the user and providing a translation tool executing on the server. The translation tool includes an emulated Application Programming Interface API library including a table. The API library has data indicative of types of data manipulations of the first OOP computer language source code and second computer language API equivalent functions callable by said second computer language. The method further comprises the steps of accessing the table of the API library and correlating the type of data manipulation the first OOP computer language source code performs to second OOP computer language source code and generating second OOP computer language source code based in part upon identified equivalent functions in the second computer language

The invention and its particular features and advantages will become more apparent from the following detailed description considered with reference to the accompanying drawings.

First computer language source code may comprise any computer language however in one advantageous embodiment comprise an OOP language such as for instance Java C C or scripting language such as JavaScript Python Ruby Perl and or PHP. Computer may also comprise any computer capable of receiving first computer language source code . Translator in an advantageous embodiment comprises software executing on computer to received and process first computer language source code . While translator executes on computer it is not necessary that translator reside on computer . For instance translator may comprise software residing on another computer not shown to which computer is connected over for instance a network. The network connection may comprise for instance a hard wired and or wireless network e.g. employing bus connections parallel cable serial cable coaxial cable fiber optic twisted wire pair USB cable infrared link radio frequency link microwave link satellite link and or the like.

Also provided in is library which is coupled to and accessible by computer . In one advantageous embodiment library comprises data indicative of relationships between the first computer language source code and the second computer language source code . In another advantageous embodiment library may comprise data for correlating particular functions of the first computer language source code to the second computer language source code . In still another advantageous embodiment library may comprise for instance a database.

Once translator has analyzed first computer language source code translator then generates second computer language source code . Again second computer language source code may comprise any computer language such as for instance an OOP language including Java C C or a scripting language such as JavaScript Python Ruby Perl and or PHP. Translation system may be operated in various modes of operation including fully automated manual and or combinations thereof.

As illustrated in translator generates second computer language source code . For instance when first computer language source code comprises Java and second computer language source code comprises C there is a C implementation of the Java language. There is true translation from in this example Java to C . This means that there is no requirement for interoperability between Java and C and therefore no need to utilize a virtual machine after translation.

It should further be noted that the arrows indicated from first computer language source code to computer and from second computer language source code to computer are shown bi directional. This illustrates the bi directionality of translator . For instance first computer language source code may be input to computer and be translated to second computer language source code . Subsequently second computer language source code may then be input to computer and be re translated back to first computer language source code . Notably as illustrated in the re translated first computer language source code is depicted as the same as the first computer language source code . This is possible because translator translates first computer language source code independent of the context of in which it is used. In this manner the translation of various elements of the source code is always consistent and therefore reversible because of the direct correlation between various elements of the first computer language source code to the second computer language source code .

First computer language source code is input to translator which has as a first block analyzer . Analyzer is also coupled to library which as previously discussed comprises data indicative of relationships between the first computer language source code and the second computer language source code . Analyzer will analyze the function of the first computer language source code and then correlate the function to second computer language source code . In one advantageous embodiment analyzer will logically traverse or cycle through first computer language source code in order to build class declarations and or class definitions.

Analysis encompasses traversing all the elements of a particular SourceUnit DOM in order to produce high level programming entities. For converting Java to C for instance such high level programming entities include the main public class and any supporting classes. These classes may in turn be made up of methods fields static constructors and inner classes. In another advantageous embodiment analysis may also entail some language specific pre generation work such as organizing high level programming entities differently for certain target languages such as C .

Once analyzer has built the class declarations and or class definitions these are sent to generator for generation of second computer language source code . Generation is the process of producing source code in the target language from the high level programming entities such as public classes produced from the analysis step. Generation may further re organize high level programming entities for correctness in the target language. Generation may still further entail adding embedded tagged elements where necessary so as to preserve the full semantic meaning of the original language and to facilitate bidirectional translation if desired.

One problem that the generator may encounter during generation is a conflict between keywords between the first computer language source code and the second computer language source code . For instance identifier names in the source language may conflict with keywords in destination language. Such conflicts must be resolved in a consistent manner and preserve the syntactical correctness and readability of the translated result. Name resolution may require name adjustment which is a mild form of name mangling. Identifier names which conflict with keywords or other features of the destination language must be adjusted. In such a case the name is mildly mangled with the best effort being made to preserve the name as readable as possible. More common standard conforming identifier names are usually mangled less than uncommon nonstandard identifiers. This strategy is weighted toward preserving the readability of content which is already deemed readable due to its standards conformance.

In an alternative embodiment illustrates another expanded view of translator that includes parser analyzer and generator . The translation process according to may be divided into three steps 1 parsing 2 analysis 3 generation.

First computer language source code is input to parser . Parser is provided to parse first computer language source code into parsed elements prior to transmission to analyzer for building of class declarations and or class definitions. The parser is essentially provided to turn the document into a hierarchy of elements including for instance but not limited to comments such as inserting a tagged element class definitions variable declarations and or method calls. Parsing entails breaking each original language source code file down into corresponding elements in a SourceUnit DOM.

The remaining elements are similar to those discussed in connection with and will not be repeated here.

The next step is translation of source code file in original computer language to source code file in target computer language . This process would include for instance the processes variously described in connection with . Once the translation process is completed the resulting source code file in the target computer language may be 1 compiled into a binary executable program 2 run 3 debugged and 4 profiled . To accomplish this step any number of commercial compilers may be utilized for instance Java and C may be compiled to bytecode while C may be compiled to native code. The steps of running the program debugging and profiling will be minimized due to the translation step. Finally the resulting source code file in the target language is modified as necessary and stored .

The result is a highly accurate translation of the original source code file to the target source code file that will function as seamlessly as the original source code file preserving the syntax and function of the original source code file. The process of converting original source files to a target language is reversible as illustrated in . The process is reversed by the translation of the source code file in the target computer language back to the original computer language . It should be noted however the any modifications made to the source code file will be reflected in the re translated source code. Once the target language source code file is re translated to the original source code language the resulting source code file in the original computer language may be 1 compiled into a binary executable program 2 run 3 debugged and 4 profiled . As previously stated any number of commercial compilers may be utilized to accomplish this step. As can be seen from the process has returned to the step of storing the source code file in the original computer language .

This bi directional translation process is possible in part because the translation from the original source code to the target source code is accomplished without regard to the context. The translation of elements is always consistent and thereby reversible. For instance keywords and identifiers are always resolved in a consistent manner and preserve the syntactical correctness and readability of the translated result.

Further details the various hierarchical array types and hierarchical array references types and their relationship to one another and other objects in the system. The array types support storing both one dimensional and multi dimensional storage of array elements. In addition the hierarchical array reference types fully support inheritance for themselves and the elements they contain. In one advantageous embodiment element count is read only and is fixed when the array is created.

One problem associated with reference types is that external classes for instance in C are stored in their own files called header files . If one class makes use of another class it must include the other class header file before it declares its own class. A problem arises when the classes refer to each other creating a circular dependency. However translation system obviates this problem by declaring reference types in their own files. A reference type file then only needs to include the header file of its superclass and implemented interfaces. A superclass is a parent of the class that extends from it and subclasses or child classes can never be their own parent thereby preventing the circular dependency problem.

Another advantage to this embodiment of the present invention is that the second computer language source code is utilized to implement types of data manipulations of the first computer language source code. When translating from Java or C to C this provides the benefit of eliminating the need for a virtual machine because there is implementation of the original language s i.e. Java or C platform classes in the target language i.e. C .

In another advantageous embodiment of the present invention no garbage collector is required to automatically manage objects. Rather translation system automatically provides for object management making translation system suitable for use with embedded systems.

As an initial step the user or the script file of a batch process specifies the following directory path of source code file s directory path of pre translated source code files if any and file types to generate in target language . Of course this initial step assumes that the source code files in the original language i.e. Java or C have already been generated. In addition pre translated software class library i.e. native implementation of Java platform classes or C and .NET platform classes in target language and pre translated class declaration file s in target language have been provided.

The next step is that the user or the batch process starts the translation process followed by generation of the list of packages from the specified directory path of source code files . As used herein source code projects are made up of one or more packages which in turn variously comprise classes fields methods inner classes blocks statements and or combinations thereof. A source code project includes all the source code files related to a particular software application program. Translation system then iterates through the packages so as to generate a package importation file s in the target language which in turn results in a generated package importation file in the target language . The next step is to generate a list of source file s from the specified directory path s of source code files .

Translation system then iterates through each source code file . At this point translation system resolves whether the source code file exists . If the source code file does not exist translation system will notify the user that the source code file does not exist and will return to allowing the user to specify the directory path .

If however the source code file does exist translation system proceeds to parse source file into tree of source code elements including formatting using an event driven parser such as for instance Simple API for XML SAX . This high level parsing of the source code file results in the generation of source code document SourceUnit DOM . The parsing step is essentially provided to turn the source code file into a hierarchy of elements and is discussed in more detail in connection with .

Next translation system performs an analysis of the source code by analyzing the source code element tree in the source code document into class definitions . The next step is to analyze imported pre translated class declaration file s into class declarations . At this point translation system has logically traversed or gone through all of the parsed elements to build class definitions and class declarations to be used for generation of the target source code. In the building of the class definitions and class declarations some preliminary broad pre translation to the target language may also take place. This analysis has also been previously discussed in connection with .

We next move to the actual generation of the target source code. As an initial step translation system generates a class importation file in the target language which results in a generated class importation file in the target language . The next step is to generate a class reference type definition file in the target language which also results in a generated class reference type file in the target language . Following this step is to generate a class declaration file in the target language which too results in a generated class declaration file in the target language . The process of generating the class declaration file is described in more detail in connection with . Finally translation system generates a class implementation file in the target language which results in a generated class implementation file in the target language . This step is also described in greater detail in connection with . This generation step has also been discussed in connection with .

This completes the translation process of the specified source file such that translation system proceeds to the next source file and or the next package and returns to iterating through the packages . The process will be repeated until all packages have been translated.

The system starts with a statement in the original language . Initially the system parses the statement into sub statements and then iterates through the sub statements . The system then determines if the sub statement requires a reference type or a referenced type . This step is described further in connection with . If it is determined that a reference type is required the system proceeds to parse the reference type name identifier and replace the reference type name identifier with an adjusted name for the target language . This step is described further in connection with . Once this step is completed the system proceeds to parse the sub statement into expressions . Alternatively in connection with determining if the sub statement requires a reference type or a referenced type if the system determines that a referenced type is required the system will also proceed to parse the sub statement into expressions . Once the sub statements have been parsed into expressions the system iterates through the expressions and parses any type name identifier in the expression . At this point the system determines if the identifier name is compatible with the target language . If it is not the system proceeds to replace the identifier with an adjusted name . This step is described further in connection with . Once the identifier is replaced with an adjusted name or it is determined that the identifier name is compatible with the target language the system proceeds to determine if the expression corresponds to a simulated keyword . If it is determined that the expression does correspond to a keyword the expression is replaced with a simulated keyword . Once the expression is replaced with a simulated keyword or it is determined that the expression does not correspond to a simulated keyword the system proceeds to determine if the translation is fully expressible in the target language . If the translation is not fully expressible in the target language the system will proceed to embed tagged elements or a tag in the translated language. Once the tagged element is embedded or it is determined that the translation is fully expressible in the target language the system proceeds to the next expression and or the next sub statement to repeat the above described process until all expressions and sub statements are translated. If it is determined that there are no more expressions or sub statements the system proceeds back to the next step of determining if there are additional statements in the method definition that contains the statement. If it is determined that there are no more statements the system proceeds back to the next step of determining if there are additional method definitions as illustrated in .

The following is a table in extended BNF notation illustrating an example of a potential format of embedded content which cannot be expressed in the target language and is therefore embedded as tagged elements within the comment sections 

The following is a table illustrating an example of simulated keywords used to provide corresponding features and forms of expression of the original language in the target language. Simulated keywords fully preserve all details of the expression of the original language so that the translated results in the target language can be accurately translated back to the original language producing identical or substantially identical results to the original expressions in the original language.

The system starts with a statement or expression . A determination is then made as to whether the target language requires separate types for references . If not the referenced type is used . If however the target language does require separate types for references the system proceeds to determine if the statement or expression is a variable declaration statement . If not the reference type is used . If however it is determined that the statement or expression is a variable declaration statement the system proceeds to determine if it is cast or an instance of expression . If not the referenced type is used . If however it is determined that it is cast or an instance of expression the system proceeds to determine if the parameter type is an array . If not the referenced type is used . If so the reference type is used . The system then proceeds according to as previous discussed.

In this step the system begins with a reference type name identifier in the source language . It is then determined if the type name is a fundamental type in the source language . If not then the class name identifier is adjusted for the target language which is described in more detail in connection with . Once this is completed it is determined if the name is an array reference . If not then the system will proceed to append a character to the resultant identifier . This character may be for instance any alphanumeric character depending on the computer language. For example an uppercase R may be effectively utilized in connection with the Java language because it is uncommon for Java variable type names to end with an uppercase R and it further indicates Reference to the user. Other suffixes however may be effectively utilized in connection with other computer languages. Once the character is appended the system completes this step.

If on the other hand it is determined that the type name is a fundamental type in the source language according to step then a primitive type name is translated to the target language . The system may in one advantageous embodiment reference a table of primitive type names in the original language and target language to facilitate this step. Once this is completed it is determined if the name is an array reference . If not then the system completes this step.

If however it is determined that the name is an array reference and or the system will then proceed to determine the array dimensions . If it is determined that there is one dimension two characters are appended to the resultant identifier . Again in one advantageous embodiment uppercase AR may be effectively used because it is uncommon for Java variable types to end with uppercase AR and it may indicate for instance Array Reference to the user. Alternatively if it is determined that there are two dimensions three characters are appended to the resultant identifier . For instance uppercase AAR may be utilized and indicate for instance Array of Array References to the user. It is however contemplated that other suffixes may be effectively utilized in connection with other computer languages. Once these characters are appended the system completes this step.

This step starts with a referenced type name identifier in the source language and proceeds to determine if the type name is a fundamental type in the source language . If not the class name identifier is adjusted for the target language . This step is described in greater detail in connection with . If however the type name is a fundamental type in the source language the system proceeds to translate the primitive type name to the target language . Again in one advantageous embodiment a reference table of primitive type names in the original language and target language may be used to facilitate this step.

An identifier in the original language is analyzed to determine if the identifier name is qualified . For clarity a qualified name contains one or more identifier name separator tokens for instance Java and C use the period . character i.e. java.lang.Object or System.object is qualified but Object or object is not . If it is determined that the identifier name is qualified the system proceeds to determine if the identifier name is an imported class and in one advantageous embodiment may utilize a list of imported classes to facilitate this determination. If the identifier name is an imported class the system proceeds to adjust the class name identifier for the target language which is discussed in greater detail in connection with . Alternatively if the identifier name is not an imported class the system proceeds to determining if the identifier is a method or a data field identifier . If it is determined to be a method identifier the method name identifier is adjusted for the target language which is again discussed in greater detail in connection with . However if the identifier name is determined to be a data field the data field name identifier is adjusted for the target language which is discussed in greater detail in connection with .

Returning now to the step of determining if the identifier name is qualified if it is determined to be qualified the system proceeds to determine if the identifier is a fully qualified imported class . If so the package namespace of the identifier is parsed and then the package or namespace of the identifier for the target language is adjusted which is again described in greater detail in connection with . Once this step is completed or in the event the identifier is not a fully qualified imported class the system proceeds to parse the class name identifier and method or data field identifier . It should also be noted that the class name identifier here may also comprise an inner class. The class name identifier for the target language is then adjusted as further described in connection with . Next it is determined whether an identifier is supplied after the class name . If not this step is completed. If it is determined that an identifier is supplied after the class name then the system proceeds to determine if the identifier is a method or a data field identifier as previously discussed.

An identifier name in the original computer language is parsed into name segments . The system then iterates through the name segments and further parses the identifier name segment in the original computer language . It is then determined if the name segment is a keyword in the target language . If the name segment is determined to be a keyword in the target language the system will proceed to append an underscore   to the name segment and proceeds to the next name segment . If however the name segment is determined to not be a keyword in the target language the system proceeds to determine if the name segment terminates or ends with an underscore   . If so the system proceeds to append an underscore   to the name segment and proceeds to the next name segment . If however it is determined that the name segment does not terminate with an underscore   the system proceeds to determine whether the name segment ends with a selected character such as for instance with an uppercase R . If not the system proceeds to the next name segment . If however it is determined that the name segment ends with a selected character an underscore   is inserted before the last character in the identifier name after which the system proceeds to the next name segment .

This process begins with a class data field identifier name in the original computer language . It is then determined whether the source language supports both a method named X and a data field named X in the same class declaration . If so the system proceeds to determine if the target language supports both a method named X and a data field named X in the same class declaration . If so this process is completed. If not however the field name identifier for the target language is adjusted which is discussed in greater detail in connection with after which the process is completed. Returning now to determining whether the source language supports both a method named X and a data field named X in the same class declaration if not then the system determines if the target language supports both a method named X and a data field named X in the same class declaration . If not the process is completed. If however it does support both a method named X and a data field named X in the same class declaration then the system translates the adjusted field name to the original name in the target language after which the process is completed.

It is contemplated that the source code may reside on a storage and be saved as a first OOP language e.g. C however the user would like to receive the source code in a second OOP language e.g. Java . In this case the translation tool would retrieve the source code in the first OOP language and generated source code in the desired second OOP language .

While the translation tool is illustrated as residing on the server it is contemplated that the translation tool may reside on a second server not shown hosted as a different web site from interface . In this instance the user could via interface select the desired source code in the first OOP language download the selected source code to the user computer navigate to the web page hosting the translation tool and then upload the first OOP language for translation to a second desired OOP language. Alternatively instead of the user having to download and then upload the first OOP language it is contemplated that the interface could push the first OOP language to the web site hosting the translation tool for translation via a user account.

Still further the user once translation tool generates the source code in the second OOP language could be presented with a preview of the individual translated files via interface . The user could also execute the source code in the second OOP language via interface allowing the user to view and or evaluate the functionality of the translated source code prior to downloading or receiving the second OOP language source code.

Although the invention has been described with reference to a particular arrangement of parts features and the like these are not intended to exhaust all possible arrangements or features and indeed many other modifications and variations will be ascertainable to those of skill in the art.

