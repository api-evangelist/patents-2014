---

title: Live data as a service and corresponding programming infrastructure
abstract: Techniques for live data management are described. Some embodiments provide a Live Data Management System (“LDMS”) that provides a facility for managing live data objects and for efficiently developing client-server applications that utilize such live data objects. Live data objects are modules of computation that exist on both a client side and server side portion of a client-server application. Live data objects are configured to monitor changes to data hosted on or accessible via the server side, and to automatically update the client side without the need for polling or other requests made by the client side. The described techniques facilitate efficient software development of Web-based client server applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134985&OS=09134985&RS=09134985
owner: 
number: 09134985
owner_city: 
owner_country: 
publication_date: 20140813
---
The present disclosure relates to methods techniques systems and frameworks for live data management and corresponding techniques for facilitating efficient software development of Web based client server applications.

Embodiments described herein provide enhanced computer and network based methods techniques and systems for live data management. The described techniques provide a framework for efficient software application development of client server applications that use live data objects. Live data objects are objects that exist on both a client side and server side portion of a client server application. Live data objects are configured to monitor changes to data hosted on or accessible via the server side and to automatically update the client side without the need for polling or other requests made by the client side. More specifically the server side live data object continuously monitors information and generates events which can be handled by the client side by way of callbacks or similar mechanisms. The client side receives events that it desires to handle and incorporates newly received data as desired. The server side can work with dynamically changing data that is stored in one or more databases relational or otherwise and or other sources or types of data including files sensor data or the like.

The described techniques also support or provide an application development framework. In this framework the software developer can code both the client and server side portions of the client server application together in a single source code module using libraries or other shared code provided by a live data management system or other source. In some embodiments the shared code supports the ability to instantiate a live object on the server based on code and or data received from the client portion. More particularly the client portion initially loads a Web page or other data that includes code defining the client server application. Then the client portion transmits to the server code and or data that defines the server portion of the application. In response and based on the received server code the server instantiates the server portion of the application including by instantiating data bases tables and or related data sources instantiating server application code instantiating live data objects and initiating any bookkeeping operations such as application tracking message dispatching and the like.

The described techniques facilitate the efficient implementation of the model view controller MVC design pattern in the client server context. In particular a developer defines the operation of all three elements of the model view controller pattern within a single source file or other module. For example the single source file may define the model by defining database schemas and corresponding operations for managing the application state. The single source file may further define the controller by defining the operations performed on the server side to operate upon the model. Finally the single source file may further define the view by defining database views for accessing the data on the server side and or the user interface controls that are to be displayed on the client side for presentation of the application and its corresponding data.

The described techniques for client server application development are at least in part facilitated by the live data object. In particular live data objects free the software developer from needing to craft code to manage monitor and effectuate the transmission of data updates between the client and server portions of the application. Instead the developer needs only to specify the types of changes or updates of interest in order to receive automatic notifications of changes and or other updates that occur with respect to data hosted on or managed by the server portion of the application.

In the illustrated example the first client initially performs a page load to receive a Web page or other data from the LDMS . The loaded page need not necessarily be hosted by the LDMS and can instead be provided by some third party system. The loaded page includes contents e.g. code instructions specifications and or data that define the client server application. Upon loading the page the client transmits an application definition also called an application context to the LDMS . The client also generates based on the contents of the page the user interface and the proxy object

Upon receipt of the application definition by the LDMS the session manager creates a new session . In particular the session manager executes or interprets the received application definition and in response generates a new session and generates any necessary tables and views in the session data . In the language of the MVC paradigm the session data thus operates as the model. The new session includes a proxy application and a proxy object . In the language of the MVC paradigm the proxy application functions as the controller. The proxy object is responsible for monitoring changes to the session data and or its schema and transmitting updates to the proxy object

Next the second client performs a page load to receive the same Web page or other data provided to the client . As described with respect to client client similarly creates the user interface and proxy object . In one embodiment the client also transmits the application definition to the LDMS which creates a corresponding session for the client . The session for client also includes a proxy application and a proxy object not shown that are dedicated to serving the client

Since clients and are in this example sharing the session data the initialization performed by the LDMS with respect to the client differs slightly as compared to client . In particular since the structure of the session data e.g. its tables and database views has already been defined by the earlier initialization performed with respect to client the session manager need not perform those operations again on behalf of client

In other embodiments the clients and or need not necessarily transmit the application context to the LDMS . In such embodiments the application context may be loaded from a database of the LDMS or other source e.g. file system based on the request e.g. as defined by a URL and associated parameters made by a client.

Some embodiments may support the caching of application contexts. For example when client initially transmits the application definition to the LDMS the LDMS may cache the application context in a database or other storage. Then when client initializes the application e.g. on page load the LDMS may determine whether the application has been modified e.g. by comparing modification dates or code signatures digests . If the application has not been modified the LDMS utilizes the cached application context if so the LDMS obtains the modified application from the client performs the necessary initializations and stores the application context in the cache for future access. Such an embodiment would provide benefits during application development and prototyping in that any modification to the application would be reloaded while providing efficiency by not needlessly reloading unmodified applications.

Next a user of client operates the user interface to interact with the client portion of the client server application. For example the user may add modify or delete data presented by the user interface . In response the user interface causes the proxy object to transmit the update e.g. new data to the LDMS . The proxy application receives the data update which is then reflected in the session data .

In response to data updates made to the session data the proxy object of each of the sessions transmits the data update to its corresponding client or . The data update is then received by proxy object and and in turn reflected by the corresponding user interface and . In this manner any update to the session data is automatically forwarded to every client interacting with the client server application. For example if the client deletes a data item via the user interface the client will be notified of the deletion so that it can be presented via the user interface

The illustrated LDMS includes a security filter a session manager multiple local sessions managed processes application libraries and a storage layer . The storage layer includes user and security data a session directory and session data .

The security filter is responsible for restricting access to authorized users. Information about authorized users and the types of operations they are permitted to perform is stored as user and security data .

The session manager is responsible for managing the creation and destruction of sessions . The session manager also dispatches incoming and outgoing messages or other transmissions e.g. updated data between the clients and the corresponding local sessions . The session manager records information e.g. identifiers of new sessions in the session directory .

The local sessions each manage resources associated with one of the clients . Each local session includes a stateless module a proxy application a proxy object and a real time database instance . The stateless module includes any objects code that do not need any state to be maintained between requests. Such stateless objects may be used to answer questions such as application version numbers or to access resources such as images and other static data. Other such stateless objects may provide authentication functions math functions or the like.

The proxy application is a component of the overall application that is responsible for performing the core server side operations of the client server application. Proxy applications exist and execute for the entire life span of the overall application.

The proxy object is a live data object that is responsible for forwarding data updates between the session data and a corresponding client . The elements of the local session are defined by code and or data received from the client as described with respect to above.

The application libraries include shared code that is used to implement functions within the LDMS and or the clients . For example the shared libraries may include infrastructure code for defining and implementing client server applications that use proxy objects.

The managed processes include server side processes that correspond to local sessions . The managed processes typically connect to third party applications or directly to external systems. In an example deployment that provides live data services for an electronic power simulation engine the managed processes provide glue between an application a variety of third party tools utilities and services.

Note that although the LDMS is here shown as a stand alone system it may also or instead be deployed in other ways. For example the LDMS may be deployed within or behind a Web server or other type of application server that provides a front end for interacting with the LDMS . In this way the LDMS may be deployed in the context of a larger system such as an e commerce system a customer relationship management system or the like.

The chat room application of is defined by computer program Listing 1 below. Listing 1 is a listing of a Java Server Page that includes JavaScript code for defining the illustrated chat room application. The Java Server Page shown in Listing 1 is loaded by a client Web browser. The code in lines 15 62 is substantially directed to defining the operation of the server portion of the client server chat application. In particular lines 17 36 define the tables and entities that represent the MVC model and are stored in a database hosted by the server as session data. Lines 43 51 define a handler for adding new values e.g. chat messages to the database. Line 53 requests that all data events be forwarded by the live data object proxy object on the server side. Lines 56 61 define an event handler for entering new chat messages into the database. Lines 83 89 define the client side user interface shown in including user interface elements and .

The chat room application of is defined by computer program Listing 2 below. Listing 2 is a listing of a Java Server Page that includes JavaScript code for defining the illustrated chat room application. The Java Server Page show in Listing 2 adds functionality to the code of Listing 1. For example lines 35 38 add a clear function that operates to remove messages associated with a specified user. This function is invoked on the server side in response to user activation of the clear button .

The chat room application of is defined by computer program Listing 3 below. Listing 3 is a listing of a Java Server Page that includes JavaScript code for defining the illustrated chat room application. The Java Server Page shown in Listing 3 adds functionality to the code of Listing 2. For example lines 42 59 define the log as a live data object having corresponding methods functions including init shutdown refresh and eventcb an event call back .

The screen also includes a start button and a stop button . The start button is configured to start the log by sending the appropriate message to the server portion of the client server application. The stop button is configured to stop the log by sending the appropriate message to the server portion of the client server application.

The chat room application of is defined by computer program Listing 4 below. Listing 4 is a listing of a Java Server Page that includes JavaScript code for defining the illustrated chat room application. The Java Server Page shown in Listing 4 adds functionality to the code of Listing 3. For example lines 28 33 add a chat room table. Lines 61 77 define corresponding functions for tracking and managing chat rooms.

Note that only a small amount of code was added to each successive version of the chat room application described above. The source code demonstrates an iterative software development process in which the developer codes both the client and server side portions in a single source module. When this module is executed by the client e.g. a Web browser the server code portion is transmitted to the server where it is executed.

The described techniques also facilitate a dynamic development cycle by automatically re instantiating the server portion in response to code modifications. In particular when the developer makes changes e.g. adds a new feature he need only modify the source module because when the module is again executed by the client the modified server code portion will be transmitted to the server where it will automatically replace any previously instantiated server code portion. As noted above modified server code portion may be retransmitted on every instantiation or alternatively a caching scheme may be deployed so that code is only retransmitted when it is modified. During development the developer is thus freed from manually accessing the server in order to stop replace and restart the server code portion or otherwise perform any management tasks on the server. This dynamic iterative mode of software development facilitated by the described techniques yields great efficiencies in the rate flexibility responsiveness and expressiveness of the software development process.

Note that although JavaScript is used herein for illustrative purposes the techniques are not limited to JavaScript or to any particular programming language or architecture. Nor do the techniques require the use of Java Server Pages or related technology. In other embodiments other types of dynamic Web programming servlet containers application servers or the like may be employed.

Block includes at a first computing system instantiating a client server application by performing operation s of block s and described below. The client server application is typically instantiated by a server computing system that hosts an example LDMS and that interacts with one or more clients. The LDMS is configured to instantiate and manage server portions of client server applications along with associated live data objects that automatically reflect data updates to one or more clients interacting with the server system.

Block includes receiving a string from a client portion of the client server application the client portion executing on a second computing system the string encoded with data used to mirror facilities of the client portion of the client server application. The received string is typically encoded with instructions that define or otherwise specify the data structures and operations of the server portion of the client server application. The received string is in some embodiments transmitted by a Web browser or other Web capable client application executing on the second computing system. The string is transmitted by the second computing system in response to loading a page that includes code e.g. JavaScript that defines the client server application. The string may be encoded in various ways such as via Base64 encoding or similar. In other embodiments arbitrary binary data may be received instead of or in addition to the string.

Block includes instantiating a server portion of the client server application based on the received string the server portion executing on the first computing system and containing functions that are proxies for functions available in the client portion of the client server application. Instantiating the server portion may include generating a session along with corresponding proxy applications objects and database tables and views as specified by the received string. If the server portion already exists e.g. because it has been previously created by another client then a session with a proxy application and related objects will be created but new database structures will not.

Block includes monitoring data from a data source in accordance with the server portion functions and to receive updates to data from the data source. Monitoring the data from the data source may include creating a live data object proxy object that is configured to track changes to an underlying database file sensor or other source of data. The types of data events captured by the live data object are typically also specified via the received string.

Block includes automatically forwarding the updates to the client portion without receiving polling requests from the client portion. Forwarding the updates typically involves transmitting to the second computing device notifications or other messages that reflect changes to the monitored data. Some embodiments use AJAX Asynchronous JavaScript and XML to push such notifications to the client portion without requiring any polling or other request from the client portion.

Block includes instantiating a database for execution on the first computing system the database defined by the received string. The database represents the model in the MVC paradigm. Instantiating the database may include creating tables and associated database views for interacting with those tables as specified by the received string. The received string may specify tables relationships integrity rules and the like. The instantiated database may be shared by multiple users who are operating the client server application executing on distinct computing systems. Other types of data sources or data management systems may of course be employed such as file systems device sensor abstractions or the like. The database may be hosted by the first computing system or in other cases be resident on a remote system.

Block includes instantiating a proxy application for execution on the first computing system the proxy application configured to perform functions defined by the received string. The proxy application is the controller in the MVC paradigm. The proxy application includes functions specified by the received string for interacting with the database and or performing stateless functions or operations.

Block includes instantiating a server side live data object for execution on the first computing system wherein the live data object is configured to transmit the updates to a corresponding client side live data object executing on the second computing system. As shown in the server first computing system hosts a live data object proxy object that interacts with a corresponding live data object executing on the client second computing system . The server side live data object is configured to forward data update notifications to the client side live data object which in turn may reflect the update on a corresponding client user interface.

Block includes determining that code corresponding to the server portion has been modified. In some embodiments determining that the server portion code has been modified includes receiving a second string that represents the modified server portion. The second string is typically received in or during a software development process in which a developer has modified the code module e.g. Web page to change the functionality of the client server application. The process can then determine whether the code has been modified by comparing the string to a previously received string. In other embodiments the client instead transmits a modification date version number and or a digest e.g. MD5 digest to the server which can be compared by the server to determine whether the client is in possession of modified code.

Block includes in response to determining that the code has been modified automatically replacing the server portion with the modified server portion such that a developer of the modified server portion need not manually access the server in order to stop replace and or restart the server portion. In embodiments where the client always retransmits a string that defines the server portion the process automatically re initializes and restarts the server portion of the application based on the newly received string including any corresponding database operations structures. In embodiments where the client first transmits a modification date version number or code digest the server may request that the client transmit the corresponding code such as by transmitting a second string that defines the server code portion.

Block includes receiving the string a second time. The string may be received a second time from the second computing system or from some other computing system that is also executing the client server application.

Block includes determining that the string is unchanged and in response not replacing or restarting the server portion. The process determines that the string is unchanged such as by comparing it to the previously received string by comparing hash values or the like. Because the string is not changed the process need not replace the server portion with a modified server portion and in particular it need not modify the data structures e.g. database tables and views .

Block includes receiving the string from a Web client that executes on the second computing system and that loads a single page that defines both the client portion and the server portion by defining a database a proxy application and a server side live data object corresponding to the server portion. Examples of single pages are provided in program Listings 1 4 below. By packaging both the client and sever portions within a single page software development efficiencies may be obtained. In particular the developer can rapidly prototype the client server application because the functionality data structures and interfaces between the client and server portions are all contained within a single manageable and comprehensible file.

Block includes at a first computing system instantiating a client server application by performing operation s of block s and described below. This process implements an example of the application development model described herein wherein a developer can efficiently code a client server application in a single module e.g. a Web page . As also discussed above the client server application is typically instantiated by a server computing system that hosts an example LDMS and that interacts with one or more clients.

Block includes providing a page that defines both a client portion and a server portion of the client server application. The page may be provided by the first computing system or some other system such as a separate Web server.

Block includes receiving a string from the client portion of the client server application the client portion executing on a second computing system the string encoded with data used to mirror facilities of the client portion of the client server application. The received string is typically encoded with instructions that define or otherwise specify the data structures and operations of the server portion of the client server application. The received string is in some embodiments transmitted by a Web browser or other Web capable client application executing on the second computing system. The string is transmitted by the second computing system in response to loading a page that includes code e.g. JavaScript that defines the client server application.

Block includes instantiating a server portion of the client server application based on the received string the server portion executing on the first computing system and containing functions that are proxies for functions available in the client portion of the client server application. Instantiating the server portion may include generating a session along with corresponding proxy applications objects and database tables and views as specified by the received string. If the server portion already exists e.g. because it has been previously created by another client then a session with a proxy application and related objects will be created but new database structures will not.

Block includes receiving the string from a Web client executing on the second computing system wherein the Web client loads the page and transmits the string to the first computing system wherein the page includes code that defines the database and corresponding views code that defines functions performed by the proxy application and code that defines functions performed by the server side live data object to transmit updates to the database to a client side live data object that executes within the Web client. Examples of pages are provided in program Listings 1 4 below. As discussed above application development efficiencies may be obtained by this approach.

Block includes determining that code corresponding to the server portion has been modified. As noted above determining that the code has been modified may be performed in various ways such as by receiving a second string that represents the server portion and comparing it to the previously received string comparing version numbers comparing hash values comparing modification dates times or the like.

Block includes in response to determining that the code has been modified automatically replacing the server portion with the modified server portion such that a developer of the modified server portion need not manually access the server in order to stop replace and or restart the server portion. The server portion may be automatically re initialized based on a second string received by the client portion

Block includes receiving from the second computing system a second string that represents the modified server portion. As noted above in some embodiments the client second computing system will on every page load or other condition retransmit the string modified or not. In other embodiments the second string will be transmitted by the client computing system in response to a request from the first computing system such as may be sent when the first computing system determines that the code has been modified based on a comparison of version numbers modification dates code digests or the like.

Block includes in response to receiving the second string automatically replacing the server portion.

Block includes receiving an indication that the client server application is in developer mode. Developer mode may be specified by a server side configuration file or other mechanism such as by providing a developer key as part the request transmitted by the second computing system

Block includes in response to the received indication automatically replacing the server portion every time the code corresponding to the server portion is modified. Techniques for conditionally replacing the server portion upon code modification are discussed above.

In the embodiment shown computing system comprises a computer memory memory a display one or more Central Processing Units CPU Input Output devices e.g. keyboard mouse CRT or LCD display and the like other computer readable media and network connections . The LDMS is shown residing in memory . In other embodiments some portion of the contents some or all of the components of the LDMS may be stored on and or transmitted over the other computer readable media . The components of the LDMS preferably execute on one or more CPUs and perform the techniques described herein. Other code or programs e.g. an administrative interface a Web server and the like and potentially other data repositories such as data repository also reside in the memory and preferably execute on one or more CPUs . Of note one or more of the components in may not be present in any specific implementation. For example some embodiments may not provide other computer readable media or a display .

The LDMS is shown executing in the memory of the computing system . Also included in the memory are a user interface manager and an application program interface API . The user interface manager and the API are drawn in dashed lines to indicate that in other embodiments functions performed by one or more of these components may be performed externally to the LDMS .

The LDMS interacts via the network with client devices information sources and third party systems applications . The network may be any combination of media e.g. twisted pair coaxial fiber optic radio frequency hardware e.g. routers switches repeaters transceivers and protocols e.g. TCP IP UDP Ethernet Wi Fi WiMAX that facilitate communication between remotely situated humans and or devices. The third party systems applications may include any systems that provide data to or utilize data from the LDMS including Web browsers e commerce sites calendar applications email systems social networking services and the like. The information sources may include remote data repositories that are managed monitored or tracked by or via the LDMS . For example the LDMS may include live data objects proxy objects that reflect updates to data that is housed in one of the information sources .

The UI manager provides a view and a controller that facilitate user interaction with the LDMS and its various components. For example the UI manager may provide interactive access to the LDMS such that users can interact with the LDMS such as by configuring user accounts and or permissions monitoring the status of various data repositories managed by the LDMS controlling processes and the like. In some embodiments access to the functionality of the UI manager may be provided via a Web server possibly executing as one of the other programs . In such embodiments a user operating a Web browser executing on one of the client devices can interact with the LDMS via the UI manager .

The API provides programmatic access to one or more functions of the LDMS . For example the API may provide a programmatic interface to one or more functions of the LDMS that may be invoked by one of the other programs or some other module. In this manner the API facilitates the development of third party software such as user interfaces plug ins adapters e.g. for integrating functions of the LDMS into Web applications and the like. In some embodiments the API is a REST Representational State Transfer API that is accessed via HTTP.

In addition the API may be in at least some embodiments invoked or otherwise accessed via remote entities such as code executing on one of the client devices information sources and or one of the third party systems applications to access various functions of the LDMS . In typical embodiments all interaction between a client and the LDMS is performed via the API . As another example one of the third party systems may utilize via the API the functions of the LDMS to provide client server applications to its own clients.

In an example embodiment components modules of the LDMS are implemented using standard programming techniques. For example the LDMS may be implemented as a native executable running on the CPU along with one or more static or dynamic libraries. In other embodiments the LDMS may be implemented as instructions processed by a virtual machine that executes as one of the other programs . In general a range of programming languages known in the art may be employed for implementing such example embodiments including representative implementations of various programming language paradigms including but not limited to object oriented e.g. JAVA C C Visual Basic.NET Smalltalk and the like functional e.g. ML Lisp Scheme and the like procedural e.g. C Pascal Ada Modula and the like scripting e.g. PERL RUBY PYTHON JAVASCRIPT VBScript and the like and declarative e.g. SQL PROLOG and the like .

The embodiments described above may also use either well known or proprietary synchronous or asynchronous client server computing techniques. Also the various components may be implemented using more monolithic programming techniques for example as an executable running on a single CPU computer system or alternatively decomposed using a variety of structuring techniques known in the art including but not limited to multiprogramming multithreading client server or peer to peer running on one or more computer systems each having one or more CPUs. Some embodiments may execute concurrently and asynchronously and communicate using message passing techniques. Equivalent synchronous embodiments are also supported. Also other functions could be implemented and or performed by each component module and in different orders and by different components modules yet still achieve the described functions.

In addition programming interfaces to the data stored as part of the LDMS such as data in the storage layer user and security data session directory and session data and or data repository can be available by standard mechanisms such as through C C C and JAVA APIs libraries for accessing files databases or other data repositories through scripting languages such as XML or through Web servers FTP servers or other types of servers providing access to stored data. The illustrated data stores may be implemented as one or more database systems file systems or any other technique for storing such information or any combination of the above including implementations using distributed computing techniques.

Different configurations and locations of programs and data are contemplated for use with techniques described herein. A variety of distributed computing techniques are appropriate for implementing the components of the illustrated embodiments in a distributed manner including but not limited to TCP IP sockets RPC RMI HTTP Web Services XML RPC JAX RPC SOAP and the like . Other variations are possible. Also other functionality could be provided by each component module or existing functionality could be distributed amongst the components modules in different ways yet still achieve the functions described herein.

Furthermore in some embodiments some or all of the components of the LDMS may be implemented or provided in other manners such as at least partially in firmware and or hardware including but not limited to one or more application specific integrated circuits ASICs standard integrated circuits controllers executing appropriate instructions and including microcontrollers and or embedded controllers field programmable gate arrays FPGAs complex programmable logic devices CPLDs and the like. Some or all of the system components and or data structures may also be stored as contents e.g. as executable or other machine readable software instructions or structured data on a computer readable medium e.g. as a hard disk a memory a computer network or cellular wireless network or other data transmission medium or a portable media article to be read by an appropriate drive or via an appropriate connection such as a DVD or flash memory device so as to enable or configure the computer readable medium and or one or more associated computing systems or devices to execute or otherwise use or provide the contents to perform at least some of the described techniques. Some or all of the components and or data structures may be stored on tangible non transitory storage mediums. Some or all of the system components and data structures may also be stored as data signals e.g. by being encoded as part of a carrier wave or included as part of an analog or digital propagated signal on a variety of computer readable transmission mediums which are then transmitted including across wireless based and wired cable based mediums and may take a variety of forms e.g. as part of a single or multiplexed analog signal or as multiple discrete digital packets or frames . Such computer program products may also take other forms in other embodiments. Accordingly embodiments of this disclosure may be practiced with other computer system configurations.

All of the above U.S. patents U.S. patent application publications U.S. patent applications foreign patents foreign patent applications non patent publications and appendixes referred to in this specification and or listed in the Application Data Sheet including but not limited to U.S. Provisional Patent Application No. 61 865 519 filed on Aug. 13 2013 and entitled LIVE DATA AS A SERVICE AND CORRESPONDING PROGRAMMING INFRASTRUCTURE is incorporated herein by reference in its entirety.

From the foregoing it will be appreciated that although specific embodiments have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of this disclosure. For example the methods techniques and systems for live data management are applicable to other architectures or in other settings. For example the live data management techniques may be used generally for client server applications for monitoring or interacting with any kind of dynamic data including power systems data online games personal information systems calendar applications or the like. Also the methods techniques and systems discussed herein are applicable to differing protocols communication media optical wireless cable etc. and devices e.g. desktop computers wireless handsets electronic organizers personal digital assistants tablet computers portable email machines game machines pagers navigation devices etc. .

The following program Listings 1 4 include code that respectively corresponds to the examples presented with respect to above.

