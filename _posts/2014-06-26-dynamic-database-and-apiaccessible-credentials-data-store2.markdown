---

title: Dynamic database and API-accessible credentials data store
abstract: A system for managing credentials for authenticating and securely communicating with trusted hosts, for example, in a cloud computing environment. The system dynamically updates credentials stored in a database and injects the updated credentials back into a runtime environment without restarting the runtime environment or applications running on the runtime environment. Embodiments of the present invention further enable credentials to be tracked and managed on a per-tenant basis, allowing each tenant that is running an application on a runtime environment to customize which hosts should be trusted.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09639691&OS=09639691&RS=09639691
owner: VMware, Inc.
number: 09639691
owner_city: Palo Alto
owner_country: US
publication_date: 20140626
---
Cryptographic protocols are commonly used by computing devices to securely transmit information over the Internet. Such protocols may implement various types of cryptographic keys to encrypt and or decrypt communications as well as certificates to enable a computing device to verify the identities of hosts with whom the computing device is communicating. These keys and certificates are generally stored in a credentials data store such as a key store or a trust store and are accessed by the computing device to generate one or more credentials managers such as one or more key managers and or trust managers. The credentials managers are then used to verify the identities of host devices and to transmit encrypted communications to as well as receive encrypted communications from the host devices.

In cloud computing applications cryptographic protocols may be implemented by an application running on a virtual machine VM to enable the application to securely communicate with multiple hosts and determine whether communications received from a particular host should be trusted. For example in multi tiered cloud computing applications a management application may use one or more trust managers to authenticate different hosts associated with one or more cloud computing platform providers.

During deployment of a multi tiered application various virtual machines VMs in hosts and or cloud computing platform providers may be added to or removed from a listing of trusted hosts. As such keys and or certificates associated with the VMs in the hosts and cloud computing platform providers may be added to or removed from the credentials data store. In some cases the management application may be executing in a runtime environment such as a Java Virtual Machine JVM in which credentials managers are generated only when the runtime environment is launched and cannot be modified to add or remove keys and or certificates while the runtime environment is running. Consequently if new keys and or certificates are received during execution of the management application the runtime environment and consequently the application must be restarted in order to generate new credentials managers. As a result adding or removing trusted hosts generally requires increased downtime and administrative costs.

Further current runtime environment implementations typically allow only one set of credentials managers to be implemented for applications running on a particular runtime environment. Consequently when multiple users are running an application or applications on a virtual machine the users must share a single set of global credentials managers preventing trusted hosts from being selected on a per user basis. Accordingly there are challenges faced by system administrators when attempting to update and manage keys and certificates to be used by a runtime environment.

One or more embodiments of the present disclosure provide a system for managing credentials for authenticating and securely communicating with trusted hosts for example in a cloud computing environment. This system enables an administrator to dynamically update credentials stored in a database and inject the updated credentials back into a runtime environment without restarting the runtime environment or applications running on the runtime environment. Embodiments of the present disclosure further enable credentials to be tracked and managed on a per tenant basis allowing each tenant that is running an application on a runtime environment to customize which hosts should be trusted.

A method of managing credentials using a runtime environment according to an embodiment includes adding one or more keys to a first credentials data store included in a database using a first application programming interface API command and retrieving the one or more keys from the first credentials data store using a second API command. The method further includes generating a first credentials object based on the one or more keys retrieved from the first credentials data store and verifying first host credentials received from a first remote host by an application running on the runtime environment using the first credentials object.

A non transitory computer readable storage medium comprising instructions that when executed in a computing device manage credentials using a runtime environment by performing the steps of in an embodiment adding one or more keys to a first credentials data store included in a database using a first application programming interface API command and retrieving the one or more keys from the first credentials data store using a second API command. The non transitory computer readable storage medium further includes instructions for generating a first credentials object based on the one or more keys retrieved from the first credentials data store and verifying first host credentials received from a first remote host by an application running on the runtime environment using the first credentials object.

A computer system for managing credentials using a runtime environment the computer system comprising a system memory and a processor programmed to carry out the steps of in an embodiment adding one or more keys to a first credentials data store included in a database using a first application programming interface API command and retrieving the one or more keys from the first credentials data store using a second API command. The system memory and processor are further programmed to carry out the steps of generating a first credentials object based on the one or more keys retrieved from the first credentials data store and verifying first host credentials received from a first remote host by an application running on the runtime environment using the first credentials object.

A developer of enterprise uses an application director which may be running in one or more VMs to orchestrate deployment of a multi tier application onto one of the deployment environments provided by a cloud computing platform provider . Application director may include one or more software modules for generating a logical topology of an application to be deployed generating a deployment plan based on a blueprint that includes deployment settings e.g. virtual computing resources cluster size CPU memory networks and executing the deployment plan by communicating with cloud computing platform providers to provision and configure VMs in the deployment environments . Application data includes one or more catalogs that are populated and customized by an administrator e.g. IT or system administrator who enters in specifications configurations properties and other details for items in the catalog s .

In order to facilitate secure communication during deployment of the application the application director may be provided with one or more credentials managers such as key managers and or trust managers that implement the necessary keys and or certificates to authenticate and communicate with VMs in one or more of the cloud computing platform providers . It is understood that from the perspective of application director the VMs may be viewed as hosts and as such may be herein referred to interchangeably with hosts. After the application has been deployed application director may be further utilized to monitor and modify e.g. scale the deployment. For example the application director may modify the deployment by provisioning or removing one or more additional VMs deployment environments and or cloud computing platform providers . Consequently even after an application has been deployed keys and or certificates may be added to or removed from the credentials data store when VMs associated with the application are modified requiring the credentials managers implemented by application director to be updated. Various techniques for updating credentials managers to add delete and modify keys and certificates are described below in conjunction with .

As in conventional computer systems computer system includes both system hardware and system software. System hardware generally includes a processor some form of memory management unit MMU which may be integrated with processor a disk interface a network interface and memory sometimes referred to as machine memory . Machine memory stores data and software such as an operating system and currently running application programs. Generally MMU is responsible for managing a virtual memory for processes running in computer system by mapping virtual memory pages to machine memory pages. Processor may be a single processor or two or more cooperating processors in a known multiprocessor arrangement. Examples of disk interface are a host bus adapter and a network file system interface. An example of network interface is a network adapter also referred to as a network interface controller NIC . In some embodiments a plurality of NICs is included as network interface . It should further be recognized that system hardware also includes or is connected to conventional registers interrupt handling circuitry a clock etc. which for the sake of simplicity are not shown in the figures.

One or more virtual machines VMs represented by VM to VM VM omitted for clarity are configured within computer system and share the hardware resources of computer system . Each virtual machine typically includes a guest operating system OS and virtualized system hardware not shown which includes one or more virtual CPUs virtual system memory one or more virtual disks one or more virtual devices etc. all of which are implemented in software to emulate the corresponding components of an actual computer. Guest OS included in each virtual machine includes a file system which stores various files and libraries associated with applications that are run on guest OS .

The virtual machines run on top of a hypervisor which is a software interface layer that abstracts system hardware into virtualized hardware thereby enabling sharing of system hardware of computer system amongst the virtual machines. Hypervisor acts as an interface between VM and system hardware for executing VM related instructions and for transferring data to and from machine memory processor s disk interface etc. Hypervisor may run on top of an operating system of computer system or directly on hardware components of computer system .

VM is configured to support a runtime environment and a database running on top of guest OS . To simplify the description description of other VMs not shown are omitted but it should be understood that other VMs may be configured similarly to VM . In the embodiments illustrated herein runtime environment is a Java Virtual Machine JVM and database is a structured query language SQL database such as MySQL although it should be recognized that other runtime environments databases and or applications running on top of the guest OS such as web servers etc. may be used without departing from the scope of the teachings herein. The embodiments presented should therefore not be interpreted to be exclusive or limiting but rather exemplary or illustrative. Runtime environment may include an interpreter a heap and a garbage collector to support execution of one or more applications e.g. application director within runtime environment . Interpreter is configured to translate and execute software code i.e. byte code of one or more applications. Garbage collector is a memory manager for runtime environment that attempts to reclaim heap memory occupied by objects in heap no longer used by runtime environment or applications running therein. Heap comprises a region of memory referred to herein as heap memory reserved for storing one or more objects e.g. Java objects and other data structures utilized during execution of an application.

Runtime environment is configured to run one or more applications to provide for example web services database services and other information technology services that may involve retrieval processing and serving of data to one or more users. Additionally as shown runtime environment is configured to run application director to orchestrate deployment of an application onto one or more deployment environments . To enable application director to authenticate and communicate with various hosts included in deployment environment s application director may be provided with one or more credentials managers such as trust manager s which implement authentication certificates and or cryptographic keys received from hosts and or certificate authorities CAs . Accordingly credentials managers enable application director to verify the identities of hosts within deployment environment s and engage in trusted communication with the hosts.

Runtime environment of VM is configured to generate a credentials object that includes references and or otherwise implements various types of credentials such as authentication certificates public keys private keys secret keys etc. that are used by application director to identify and communicate with different hosts. In the embodiments illustrated herein the credentials object is an SSLContext object also referred to as SSLContext that includes one or more trust managers although it should be recognized that other types of credentials objects that include or are associated with other types of cryptographic keys authentication certificates credentials trust managers key managers etc. may be used without departing from the scope of the teachings herein. When generating SSLContext one or more trust managers and or key managers not shown may be created and provided to application director . Trust manager s are used by application director to determine whether authentication credentials received from a remote host should be trusted. Each trust manager may support one or more authentication protocols such as secure sockets layer SSL transport layer security TLS and the like. Although not shown in SSLContext may further include or be associated with one or more key managers that may be used to determine which credentials should be sent to a remote host during authentication.

In conventional virtual machine implementations SSLContext is generated when a runtime environment is launched on a guest OS. More specifically upon launch of a runtime environment conventional implementations access keys and certificates stored in the file system of the guest OS and use the keys and certificates to generate SSLContext and trust managers and or key managers associated with SSLContext. However in order for an administrator to add a host to a list of trusted hosts the administrator must manually add the key s and certificate s associated with the new host to the file system for example via a command line interface. Further in conventional virtual machine implementations applications running within the runtime environment are isolated from the credentials store which is typically stored on the file system of the guest OS. Consequently in order to generate a new SSLContext object using the key s and certificate s associated with the new host the runtime environment as well as any applications running on the runtime environment must be restarted requiring the virtual machine to be temporarily taken offline.

In contrast to the conventional virtual machine implementations described above various embodiments of the disclosure enable application director to modify a listing of trusted hosts as well as credentials associated with the trusted hosts without restarting runtime environment by storing host credentials in a database that can be accessed by application director . More specifically as shown in application director may access credentials stored in a trust store via a truststore API which may implement a REST API library such as Apache HttpClient. By storing credentials in database instead of in file system of guest OS administrator is able to update trust store included in database through the user interface of application director using simple commands such as GET POST PUT and DELETE. Consequently trust store may be dynamically updated to modify credentials using applications running on runtime environment without requiring runtime environment to be taken offline and restarted.

In the embodiments illustrated herein database includes trust store which stores one or more credentials such as public keys private keys secret keys certificates etc. However it should be recognized that credentials associated with different hosts may be stored in other types of databases and data stores such as a key store and that the terms trust store key store credentials store and credentials data store may be used interchangeably without departing from the scope of the teachings herein.

In some embodiments application director may monitor API commands issued to truststore API to determine when SSLContext should be reconstructed. For example application director may determine that SSLContext should be reconstructed when credentials have been added to or removed from trust store . Further because database can communicate with application director via truststore API upon detecting changes to trust store SSLContext may be reconstructed and injected back into application director without restarting runtime environment or application director . Accordingly application director can dynamically add or remove hosts to and from a multi tiered application without requiring administrator to manually modify the contents of file system and take runtime environment offline in order to generate an updated SSLContext object.

In embodiments that implement a REST API when credentials stored in trust store are modified SSLContext may be reconstructed using a library method configured to return an SSLContext object that includes the updated credentials e.g. SSLContext.getInstance SSLContext.getDefault . The updated SSLContext may then be injected back into runtime environment as the default SSLContext . In some embodiments SSLContext may be reconstructed each time application director attempts to connect to a host. In the same or other embodiments application director may monitor truststore API and cause SSLContext to be reconstructed each time credentials in trust store are modified.

As described above in conventional implementations SSLContext is generated using credentials stored in the file system of the guest OS. As such one or more custom libraries e.g. Java Runtime Engine JRE libraries may be included in runtime environment in order to enable SSLContext to be generated using credentials stored in database instead of accessing the credentials from file system . Additionally trust manager s may be customized to read credentials included in tuples stored in database instead of reading the tuples from file system .

By storing host credentials on database the credentials may be backed up moved and restored in a manner that is similar to backing up and restoring application data when an application running on runtime environment is moved to a new host. For example when an administrator wishes to move application director to a different VM or runtime environment the contents of database including application data and trust store may be backed up without the need for accessing file system of guest OS .

In some embodiments trust store includes a relational database that is organized according to a relational model. In such embodiments each data item included in the relational database may be associated with a row of attributes that may include for example a host name tenant identifier public key private key secret key certificate etc. associated with one or more hosts. Trust store may then be queried by a database management system such as MySQL e.g. via trust store API to access one or more data items e.g. tuples included in the relational database in order to facilitate communication with and or authentication of a particular host. In some embodiments trust store includes a tenant column to enable credentials to be stored and accessed by multiple tenants that are running an application on runtime environment . In other embodiments trust store includes a separate table and or relational database to manage the credentials associated with each tenant.

Conventional runtime environments are capable of generating and implementing only a single SSLContext object. Consequently conventional runtime environments are ill suited for multiple tenant environments in which each tenant wishes to select their own trusted hosts. Accordingly in various embodiments of the disclosure multiple SSLContext objects e.g. SSLContext to SSLContext each of which is associated with one or more tenants may be generated and referenced using proxies. That is when a particular tenant attempts to access SSLContext and or trust manager s the runtime environment and or other software running on guest OS may act as a proxy by retrieving the specific SSLContext included in SSLContext to SSLContext associated with that tenant and transmitting that specific SSLContext and or the associated trust manager s to application director . Thus as shown in application director may receive multiple sets of trust managers each of which are associated with a different tenant or set of tenants. In some embodiments SSLContext and or trust manager s may be proxied using an aspect oriented programming AOP framework such as Spring .

In step runtime environment generates SSLContext and trust manager s associated with SSLContext using credentials stored in database . Trust manager s are then injected into one or more applications e.g. application director running on runtime environment . In step application director determines whether one or more credentials stored in database are to be modified. For example credentials stored in database may be modified when for example input is received from an administrator via trust store API to add remove modify etc. one or more keys certificates etc. stored in database . If credentials are to be modified the method proceeds to step where application director interacts with database via an API such as via trust store API to modify credentials stored in database . The method then proceeds to step . If no credentials are modified the method proceeds to step .

In step application director determines whether a host connection is being requested. A host connection may be requested when for example an outgoing connection request is transmitted to a remote VM to configure the VM as part of a deployment of a multi tiered application in a deployment environment . If a connection to a host is not being requested then the method returns to step . If a connection to a host is being requested then in step runtime environment determines whether credentials stored in database have been modified. In some embodiments in step runtime environment determines whether credentials stored in database have been modified since a host connection was last requested by the application director and or by a remote host attempting to connect to the application director .

If runtime environment determines that credentials stored in database have been modified then in step runtime environment retrieves the modified credentials from database e.g. using trust store API reconstructs SSLContext using the modified credentials and injects modified trust manager s associated with the reconstructed SSLContext into application director . The method then proceeds to step . If runtime environment determines that credentials stored in database have not been modified then in step application director verifies that the host is a trusted host using trust manager s . If application director determines that the host is a trusted host then in step a connection is established between application director and the host. If application director determines that the host is not a trusted host then in step application director disconnects from the host.

The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present invention have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. For example while embodiments herein have referred to certain methods for establishing communication between application director and a remote host it should be recognized that any type of application running on runtime environment may be utilized in alternative embodiments. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claims s .

