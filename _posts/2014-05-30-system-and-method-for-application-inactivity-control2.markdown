---

title: System and method for application inactivity control
abstract: A system includes multiple applications executing on a device. One or more user-interfaces connect with the device. The one or more user-interfaces interact with the applications as user-interface activities. A processor sends or receives an indication of the user-interface activities for the multiple applications. The multiple applications are closed or locked, or the device logged out, based on the indication of the user-interface activities for the multiple applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09632824&OS=09632824&RS=09632824
owner: GENESYS TELECOMMUNICATIONS LABORATORIES, INC.
number: 09632824
owner_city: Daly City
owner_country: US
publication_date: 20140530
---
A client is computer hardware and software that accesses a service made available by a server. The server can be located on another computer system in which case the client can access the service by way of a network. A server host runs one or more applications which share their resources with clients and the clients can also execute applications on the client. A client can request a server s content or service functions.

Systems and methods can control the logging out of users and or the closing of applications executing on a device or across devices if no user interface activity is detected in the applications for a specified interval of time. Additionally or alternatively systems and methods can provide timing out applications during cross device utilization. Additionally or alternatively systems and methods can provide single logout functionality to multiple applications that were logged in using a single login implementation. Additionally or alternatively systems and methods can provide third parties e.g. administrators to log out users and or close the applications.

In one implementation the applications are used to process sensitive customer information credit card numbers social security numbers etc. inputted into and or received by the client devices . The applications can be used in the home and for business including agents at contact centers employees at banks attorneys at law offices accountants at accounting firms etc. As described in more detail below the applications can be locked closed and or logged out etc. after a period of user interface inactivity with the applications e.g. to prevent unauthorized access to the information displayed by the applications . The lack of interaction with the application can include a lack activities other than user interface interactions with the application. Additionally or alternatively the applications can be locked then closed after a further time period of no user interface interaction activity and then the client device logged out after a further time period of no user interface interaction activity etc. or any combination of stepwise closing locking and logging out.

For example a contact center agent or bank employee may step away from the computer for a period of time. In one example the applications can be closed or logged out or the computer locked to maintain a confidentiality of the information. Such closing logging out or locking of the applications can comply with business or industry regulations e.g. the payment card industry PCI security regulations and can help ensure that customer payment card data is kept safe and protected against data breaches. Other reasons to close or lock the applications and or logout a client after a period of no user interface activity include resource management e.g. limiting of number of users application license management maximizing performance of other active sessions by closing unused sessions conserving battery power of mobile devices etc. The time that an application is inactive can also be reported e.g. to help with resource management. The closed logged out or locked applications can include thin application provided by the servers and or thick applications installed on the client devices and or dynamically loaded on the client devices e.g. using JavaScript.

In one implementation a browser application e.g. Internet Explorer Chrome Firefox etc. of the client device can maintain a counter value or timestamp . The timestamp can indicate a time of a user interface activity per participating application and the counter value can represent a number of units of time since a user interface activity of the application e.g. counts of inactive intervals. Other applications can be used to keep track of time periods of activity of the applications executing on the client device e.g. an activity tracker that monitors user interface activities with applications accessed by the client device and can report periods of no user interface activity to the activity monitor described below. For example a time period since a mouse click or a data entered into the application etc. can be monitored. Additional and or alternative user interactions can be monitored for example a user interface being used to move a window of the application on the display screen can be detected and considered an activity even though the application is otherwise inactive e.g. showing a report which is unchanged because there is no new data traffic.

The counter value timestamp can be incremented or decremented by the client device e.g. in JavaScript and or based on an internal clock of the client device . Periodic messages that include the counter value timestamp can be sent from the client devices to the applications application servers and or activity monitor described below depending on an implementation for processing to determine whether or not a period of interaction activity with the applications has been exceeded. The counter value timestamp can be maintained separately for each application . For example the client device may execute multiple applications at the same time and each executing application including suites of applications can receive its own counter value timestamp message. The counter value timestamp can be sent to all applications at the same time or sent at different times. The counter value for a particular application can be reset when the client device interacts with the application e.g. mouse movement or click keypad strike etc. Additionally or alternatively if a timestamp is used instead of a counter the timestamp need not be reset when the interaction occurs.

When there are no activities or interactions with the applications the applications can remain open for the determined time period. The time period of no user interface activity or since the activity can be determined for the applications . Multiple applications can remain open as long as one application is active e.g. for a suite of applications or multiple application sessions by the same user being used on the same device or multiple devices located near each other as described below. For example a WORD document can remain open during an inactive period while the client device is working on the EXCEL application and vice versa. Additionally or alternatively applications can be independently closed after the determined time period has been exceeded for the application . When the counter value timestamp received by the application indicates that a time period of no user interface activity for the WORD application has exceeded a determined amount the WORD document is closed the screen is locked and or or the client is logged out of the WORD document etc. even though the EXCEL document remains open.

The counter value timestamp messages used to determine the no user interface activity time period can be sent using a messaging protocol or other message transport protocol implemented by hardware software or firmware or a combination thereof of the client device . The messages can be set using hypertext transfer protocol http user datagram protocol UDP transmission control protocol TCP Websphere MQ simple mail transfer protocol SMTP remote procedure calls rpc JavaScript object notification JSON messaging session initiation protocol for instant messaging SIMPLE or any other message transport mechanism. The message protocol signal can be sent from the client devices to the servers at regular intervals in the order of seconds or other determined intervals. The counter messages need not be sent at regular intervals and can be sent at irregular intervals. In accordance with the received counter value timestamp the server side applications determines if a time period of application user interface inactivity has been exceeded . An exemplary time period is about fifteen minutes but other time periods can be used based on an implementation. The time period can be configurable e.g. by an administrator of the client devices or application servers for any determined activity duration.

If the time period of user interface inactivity has been exceeded the application can be closed locked and or the client device logged out etc. or the application otherwise secured against an unauthorized viewing of the information. The client devices can receive coordinated status messages related to the applications . For example the activity manager or other central server can cause the applications to show a session expiration warning clean the warning if the user interface reactivates and conceal data when the timeout occurs.

The client devices and or the application servers can monitor user interactions with the applications e.g. by monitoring user interface interactions including mouse movements or clicks keypad strokes display screen touches and swipes display viewings etc. to determine if an interaction with the applications has occurred . If no interaction has occurred the counter value continues to increase or decrease depending on the implementation . If an interaction has occurred the client devices can reset the counter e.g. to zero. This is one way that detected inactivity timeouts can be coordinated across applications on a client device or across client devices . Other ways are described below. Therefore closing or logout of applications and or logout on a client device or across client devices can be coordinated as triggered by user interface inactivity user choice and or other triggers e.g. administrator choice.

Additionally or alternatively the applications can monitor a time period between server side actions e.g. inputted text saves to memory and other client initiated server actions etc. to determine no user interface activity. For example the application servers can store an array or map of user activity of applications by device of the client devices during a session. A maximum allowed period of no user interface activity for the applications executing on the device is compared to a timeout value and the applications are closed or the user logged out or locked out when the no user interface activity value exceeds the timeout value. The no user interface activity value can vary depending on the application. For example an application that can contain sensitive customer data can be configured to time out faster than applications that contain no customer sensitive data. When a device has been inactive for determined amount of time the application servers can log out the client device .

If the client device is unable to send the message protocol signal or other message containing the counter value timestamp to the application servers the severs can time out the session after a configured timeout period has passed without being able to send any message protocol signal. Additionally or alternatively the applications can close or lock and or the client be logged out if the applications do not receive the message protocol signal within a determined amount of time since the activity. In one implementation the above described timeouts can be used for the mobile applications since chatty session management can consume battery.

When proximity changes and devices are moved near to one other their sessions can merged into one session. For example a knowledge worker can take a call on the smart phone then walk to the desktop computer and have an interaction workspace IWS with relevant customer information and call details pop up the display because the smart phone is now proximal to the desktop computer . When the smart phone and desktop computer are located near each other e.g. within short range wireless connectivity such as a dedicated short range communication the application remains open as long as activity occurs on either the smart phone or the desktop computer . Information about the single session can be stored with the applications . Additionally sessions can be transferred from one device to another device . Moreover a single session can be separated into multiple sessions when devices are moved away from each other.

In one example an customer service agent is working with a contact center application e.g. by GENESYS TELECOMMUNICATIONS LABORATORIES INC. on the desktop computer and a customer relationship management CRM application on another desktop computer or the laptop computer etc. for a single session. Additionally or alternatively the contact center application and the CRM application can both be executing on the desktop computer and the laptop computer or any combination of devices and applications thereof. The applications can include separate timeout time periods for each application or a shared timeout time period for the shared contact center application and CRM application session. If the desktop computer and the laptop computer are located near each other the applications on both the desktop computer and the laptop computer can be considered a single session and remain open while either the desktop computer or laptop computer applications are being interacted with within the determined timeout time period. Likewise the applications can be closed locked or logged out together upon no user interface activity. When the laptop computer moves away from the desktop computer e.g. as determined by the short range communication protocol no longer able to communicate between devices the desktop session can be separated from the laptop session so that the applications executing on the desktop computer and the laptop computer are provided their own timeout time periods. Additionally or alternatively other mechanisms for determining a nearness of the devices can be used including a proximity sensor used to detect that the devices are no longer near each other.

In one implementation the client credentials are sent to the identity provider using HTTP requests. The identity provider determines whether there is an existing session for the client device . If there is no existing session the identity provider queries the client device for a user name and password. If the user name and password are valid or if the user is already logged in the identity provider redirects the client device to the service provider along with an assertion that the client device has been validated. Upon receipt of this assertion the service provider determines it is dealing with an authenticated client device and sets up a session with the client device . In a browser sessions can be tracked by cookies but other implementations are possible. Once the name and password are entered with the identity provider a user is not aware of subsequent redirections to the identity provider . From the user s point of view he can use all the service provider applications .

To log out of the applications without having to log out of each application separately the communication network includes an activity manager . The activity manager can be implemented with software firmware or hardware or a combination thereof. The activity manager can be implemented on a server that the client device application server and or identity provider can access remotely e.g. over the communication network . The activity manager can process activity information across multiple applications on a client device and or across multiple client devices for numerous applications accessed by the client devices and or executing on the client devices . The client devices can have sessions with the identity provider and one or more service provider applications . The sessions can be independent of each other and for single log out are terminated in what appears to be a single operation to the user. Coordinated user interface activity timeouts can also be applied to thick applications stored on and or loaded on to the client device .

The communication system can also include an activity tracker implemented on a device of the client device to track activities of applications stored or loaded on to the client device . Single sign in through different profiles supports thick client applications and the single logout mechanism can work with the activity tracker notifying the thick application to end its session. The activity tracker can be utilized as an intelligent agent of the central activity manager . The activity tracker can monitor and determine application in activity information on the client devices they are deployed on e.g. not limited to applications within the monitored session. The activity tracker can also report proximity information to other devices. If the threshold of no user interface activity is reached or proximity status changes a message is sent to the activity manager which can makes decisions based on information received from the activity trackers e.g. including closing logging out or locking out applications.

The client device can open the applications e.g. using a single sign in procedure e.g. SAML . When the client device logs into the communication system the client device is also logged into the activity manager . Thereafter for every application that the client device logs into an application server of a service provider can send a communication message to the activity manager when the client device logs in and when the client device closes the application e.g. by closing a tab in the browser. The message can include the user name and an identifier for the session that has been created. The activity manager maintains a record of the applications open on the client device and or maintains a record of application servers providing the applications . The registered applications and connected servers can be stored in a database for access by the activity manager e.g. a Casandra database. The activity manager tracks what sessions the client device has open at any time. In one implementation the activity manager can track a subset of applications and not track others. For example identified general purpose web browsing applications can be excluded from the tracked subset as well as concurrently opened private social media sessions.

To logout the client of the applications when the browser is closed or the logout button clicked etc. the client device sends a request to the activity manager to close the open applications. The activity manager sends commands to the identity provider to clear the session and notifies the open service provider applications to terminate the sessions . In a web context the application server can close or clear the session by removing the cookie set for the client device and by clearing any internal records related to the session. Other methods for closing the session are possible. For example sessions can be closed with a single sign in logout request since the activity manager behaves as a service provider. Requests to the application servers can be achieved by the activity manager acting as the client device by using the stored session ID of the target application.

Therefore the client device can log out of all sessions with a single command. By clearing the sessions with the identity provider and applications the client device is not later automatically logged in by the identity provider without knowledge of the client device . Additionally or alternatively instead of the activity manager sending a request to the identity provider to clear the session the application server sends the request to the identity provider to clear the session before clearing its own session. In either case the client device session with the identity provider can be cleared before the application server clears their own sessions. When the logout commands have been executed the client device no longer has a session with the identity provider or any of the application servers . The next time the client device attempts to access any service provider resource the client device is requested to log in e.g. by the identity provider .

Additionally or alternatively a third party with appropriate privileges e.g. an administrator can send the logout command to the activity manager and cause the client device to be logged out with the applications and the user session cleared with the identity provider . Additionally or alternatively the applications can send notifications of user interface interaction activity or user interface interaction inactivity to the activity manager to identify which open applications are active. The activity manager can track activity across all applications and close an application or logout the client device is there is no activity in any of the applications for a determined interval of time e.g. giving the counter value timestamp of the recent activity in that interval. The time interval can be configurable based on an implementation e.g. whether the client device is displaying sensitive data or not and or to manage application resources. If there is no application related activity within the interval the service provider may either omit sending the activity message or send one identifying that there has been no activity. In accordance with the activity messages the activity manager can determine the user interface activities in any of the applications that the client device has open. If a configurable interval passes without activity the activity manager can initiate log out on and or close the sessions with the identity provider and the service provider applications . Additionally or alternatively active applications can remain open. User interface inactivity can also be determined by monitoring interactions with the applications as discussed above.

In a user initiated log out case an icon in one or more of the applications can provide an option to request the logout. When the logout is requested e.g. by clicking on the icon providing a voice command etc. the application can send the request to log out to the activity manager . The activity manager can check that the command was sent by a valid client device and that the client device is currently logged in. The activity manager can execute the logout in the manner described above and returns a notification to the applications once the logout operations are complete. The execution of the logout can include multiple commands to be sent and completed but the logout appears as a single operation to the client device and is triggered with a single operation e.g. clicking on the icon. In the case that a system administrator requests the logout client of the administrator sends a command to the activity manager specifying the name of the client device to be logged out and or multiple client devices to be logged out in one command. The activity manager can check that the system administrator is authorized to execute the command and then executes it returning a notification to the administrator once the actions have completed. Therefore the system administrator is also able to log out one or more users in a single operation.

The activity manager registers client logins logout events and in some implementations can provide an interface for administrative logout requests. The login information is also sent to the application server . The application server can include a login filter a security protection filter e.g. SAML filter and logout filter . The application server can include a middleware software executing on a hardware server. Service provider applications or other web applications can include software executing on the application server . When integrated with single sign in logic the service provider applications can have a role of single sign in service providers. Therefore a logic of the security protection filter can be included as part of the service provider applications . Multiple service provider applications can be included on a single server and or on multiple servers. Each servicer provider application can behave as a service provider. The post login filter registers client login requests on the activity manager including information to terminate the session later. The server s login filter is responsible for registering requests from the client device on the activity manager including information to terminate the session . The logout filter is responsible to redirect the client device to the activity manager clear login logout custom data on the application server and set a success failure parameter on the logout response.

The post login filter login filter security protection filter and logout filter can be implemented using HTTP filters which intercept single sign in message flows and register client device sessions on the activity manager . When the client device is authenticated by the identity provider the post login filter intercepts post login flow information and redirects the login notification to the activity manager e.g. using an auto submit HTML form with user session information. The activity manager establishes a session with the client device e.g. sends a cookie to the client device . The activity manager can create and preserve user context and redirect the client device to identity provider to complete the single sign in authentication flow. When the client device logs in to each application the login filter intercepts single sign in flow and redirects the login notification to the activity manager e.g. using an auto submit HTML form with user session information. The activity manager loads the user session e.g. by sending the client device a cookie and updates a user login context with the service provider information.

When the client device sends a logout request to log out service provider applications e.g. either via the activity manager and or directly to the server the activity manager sends logout requests to the identity provider and application server and . If the logout request is sent directly to the logout filter alternative the logout filter redirects the client device to make the logout request to the activity manager and . The activity manager can act as e.g. pretend to be the client device using relevant session identifications of the client device from the stored user login context. The login context can be stored in a database e.g. a distributed database for storing and managing large amounts of data e.g. Cassandra or other database. The activity manager sends logout requests to the application server and identity provider to clear the application sessions and single login credentials e.g. clear the respective cookies including the server session ID and identity provider session ID with the application server and identity provider and . The single logout procedure allows single sign in sessions to be closed locked or logged out for multiple applications over multiple servers without the need for the client device to separately close lock or log out each one. The single logout procedure can also ensure that the identity provider does not maintain login credentials to erroneously log the client device back into the applications e.g. service provider applications without a client user s knowledge. The security protection filter can send a logout response to the activity monitor when the applications are logged out with the client device . A correlation between identity provider and application server sessions is done by the provided username. Therefore the logout process has an ability to terminate all user sessions at once. A specific user context is not terminated from the browser .

The identity provider sends single sign in authentication responses to the application server e.g. of a service provider. The identity provider completes single sign in authentication and sends the client device login information to the application server . The application server logs in. The login filter is activated on mapped requests and checks if registration is required or if credentials already exist for the client device . On subsequent redirected requests the login filter identifies that a principal session exists and triggers the session registration on the activity manager . The login filter registers the client on the activity manager . The login filter fetches the registration data from the user session and redirects the user to the activity manager e.g. using HTTP POST redirection. The registration data is entered in the auto submit form. The login filter can also mark the session as registered by a flag. The activity manager processes the registration by validating the client device session e.g. that the client device has a prior established session e.g. a cookie that was set during registration request from the identity provider . The activity manager also updates stored user login context with application server session information and redirects the client device to the application server e.g. using a return URL encoded in auto submit form.

When the client device requests logout e.g. via browser the activity manager can check client device session validity. If the session is valid the activity manager retrieves relevant identity provider session information and list of involved servers e.g. from database . To support administration requests a dedicated application programming interface API of the activity manager can be used. The activity manager requests logout on the session on the identity provider . The activity manager can generate and send HTTP request to an identity provider local logout URL e.g. custom URL exposed by a Shibboleth identity provider. The activity manager can act as the client device in this request e.g. by using the session identification of the client device so that the activity manager is transparent to the application server . The application manager can act as the client device by using client s cookie e.g. session ID s. The activity manager can access identity provider metadata from a single sign in metadata repository e.g. SAML metadata repository and access session data from the database to generate the logout request. The activity manager also requests logout on the application servers . The activity manager generates and sends HTTP request to each application server e.g. to their logout URL . The requests can be sent in parallel with clearing the identity provider of the session. An exemplary application server logout flow is described in . The security protection filter can return a logout response to the activity manager . After receiving responses and clearing the context the activity manager can return a combined response to the client device of a successful failed or partial successful closing of the application and request to close the browser .

The integrated circuit can be electrically coupled with the system bus and include any circuit or combination of circuits according to an implementation. In on example the integrated circuit includes a processor that can be of any type. The processor may mean any type of circuit such as but not limited to a microprocessor a microcontroller a graphics processor a digital signal processor or another processor. Other types of circuits that can be included in the integrated circuit are a custom circuit or an application specific integrated circuit ASIC . The processor may also be implemented with discrete logic or components or a combination of other types of analog or digital circuitry combined on a single integrated circuit or distributed among multiple integrated circuits. The system and method may include a communications circuit for use in wireless devices such as Bluetooth near field communication NFC cellular pagers portable computers two way radios and other information and communication technology systems. In an example the processor includes on die memory such as SRAM and or eDRAM.

All or part of the logic described above may be implemented as instructions for execution by the processor controller or other processing device and may be stored in a tangible or non transitory machine readable or computer readable medium such as flash memory random access memory RAM or read only memory ROM erasable programmable read only memory EPROM or other machine readable medium such as a compact disc read only memory CDROM or magnetic or optical disk. A product such as a computer program product may include a storage medium and computer readable instructions stored on the medium which when executed in an endpoint computer system or other device cause the device to perform operations according to any of the description above.

In an example the information and communication technology system also includes an external memory that in turn may include one or more memory elements suitable to the particular application such as a main memory in the form of RAM one or more hard drives and or one or more drives that handle removable media such as diskettes compact disks CDs digital video disks DVDs flash memory keys and other removable media.

In an example the information and communication technology system also includes a display device an audio output . In an embodiment the information and communication technology system includes a controller such as a keyboard mouse trackball game controller microphone voice recognition device or any other device that inputs information into the information and communication technology system .

The processing capability of the system may be distributed among multiple system components such as among multiple processors and memories optionally including multiple distributed processing systems. Parameters databases and other data structures may be separately stored and managed may be incorporated into a single memory or database may be logically and physically organized in many different ways and may implemented in many ways including data structures such as linked lists hash tables or implicit storage mechanisms. Programs may be parts e.g. subroutines of a single program separate programs distributed across several memories and processors or implemented in many different ways such as in a library such as a shared library e.g. a dynamic link library DLL . The DLL for example may store code that performs any of the system processing described above.

For example a system includes a processor and a memory where the memory stores instructions which when executed by the processor causes the processor to monitor interactions across applications executing on a device determine a time period since an interaction with the applications and close or lock the applications or log out the device based on the time period of an interaction with the applications being greater than a determined time period.

While various embodiments have been described it can be apparent that many more embodiments and implementations are possible. Accordingly the embodiments are not to be restricted.

