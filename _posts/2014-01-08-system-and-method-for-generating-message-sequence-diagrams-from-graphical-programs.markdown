---

title: System and method for generating message sequence diagrams from graphical programs
abstract: A system and method automatically generating one or more message sequence diagrams based on an analysis of the execution behavior of a model, such as a computer-generated, executable graphical model. A model analyzer examines execution instructions generated for the model. A filtering unit identifies execution instructions that concern designated elements of the model. An auto diagram builder generates one or more message sequence diagrams. The diagrams may include display features that represent activities involving the designated model elements. The diagrams may show the relative execution time order of the activities.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256485&OS=09256485&RS=09256485
owner: The MathWorks, Inc.
number: 09256485
owner_city: Natick
owner_country: US
publication_date: 20140108
---
This application claims the benefit of U.S. Provisional Application Ser. No. 61 830 839 filed Jun. 4 2013 which application is hereby incorporated by reference in its entirety. This application is a continuation in part of commonly assigned copending U.S. patent application Ser. No. 13 117 859 which was filed on May 27 2011 by Alan J. Moore and E. Mehran Mestchian for Message Based Model Verification which claims the benefit of U.S. Provisional Application Ser. No. 61 349 401 filed May 28 2010 which applications are hereby incorporated by reference in their entireties.

The Unified Modeling Language UML is a standard visual modeling language used to specify and or document new or existing business processes or software systems. The UML standard defines many different types of diagrams including Class Diagrams Object Diagrams State Machine Diagrams and Interaction Diagrams. Examples of Interaction Diagrams include Sequence Diagrams Communication Diagrams and Timing Diagrams which provide different views of the interaction among objects or entities of a process or system. A Sequence Diagram typically illustrates message interchange between objects or entities of a business process or software system. A Timing Diagram typically illustrates the timing or duration of messages or conditions in the system or process. A developer or other user may create UML diagrams using a variety of existing software tools such as the Systems Modeling Language SysML from the Object Management Group OMG and IBM Rational Rose from IBM among others.

Tools such as modeling environments also exist for creating computer generated models such as graphical behavioral models that represent dynamic systems. A model may include a plurality of graphical objects such as blocks or icons. A model may be executed to simulate the operation or behavior of the system being modeled. For example the model may be executed by evaluating the model at a plurality of simulation or execution time steps beginning at a start time and ending at a stop time. In a single rate model all of the objects execute during each time step except for objects configured for conditional execution where the condition is not met. In a multi rate model objects execute at different rates relative to each other and thus in a given time step only a portion of the blocks may execute. Some of the graphical objects of the model may generate and or process signals. A signal may refer to a time varying quantity having one or more values typically at all points in time during model execution. Other objects of the model may generate and or process messages that may have payloads that include one or more values. Payloads may be fixed and may persist for a determined time interval during a simulation time. A message may be generated at a particular point in time during model execution e.g. by a source message based block and may only exist for a limited time interval during which the message may be read by another message based block such as an intermediary block or a sink block.

To execute a model a scheduling order may be created that specifies an order of execution of at least some of the objects or components that make up a model. In addition one or more execution tasks may be implemented or defined and the objects of the model may be assigned to the one or more tasks for execution. Priorities may be assigned to the tasks and a higher priority task may preempt and or block execution of a lower priority task.

The present invention relates to systems and methods for automatically generating one or more message sequence diagrams based on an analysis of the execution instructions generated for a model such as a computer generated executable graphical model. In an embodiment a system may include a modeling environment having a human machine interface HMI engine a model editor and a simulation engine. The simulation engine may include one or more schedulers such as a static scheduler which may apply a scheduling algorithm such as the Rate Monotonic Scheduling RMS algorithm and a dynamic scheduler that may use an event calendar to establish a schedule. The simulation engine also may include one or more solvers. The modeling environment may support the creation of a model having dynamic i.e. time based objects and message based objects among other objects. The modeling environment also may include or be in communication with a diagramming tool. The diagramming tool may include a plurality of components. Specifically the diagramming tool may include a model analyzer a filtering unit an auto diagram builder and a user interface UI engine.

The model analyzer may be configured to examine execution instructions generated for a model created in the modeling environment and determine when particular execution activities such as the occurrence of events the execution of blocks the generation and consumption of messages the changes in signal values occur during execution of the model. The auto diagram builder may be configured to receive information concerning the model s execution behavior and to automatically generate one or more message sequence diagrams for the model. The filtering unit may receive inputs such as user inputs specifying selected model elements such as objects signals messages queues communication elements etc. to be included in the message sequence diagrams. For example a user may designate one or more signals message based blocks and messages to be included in the message sequence diagram generated by the auto diagram builder. The diagramming tool may be configured to provide the message sequence diagram to an output device such as a display or a printer. A user may review the message sequence diagram to observe and thus better understand the execution behavior of the model.

The message sequence diagram may be dynamically generated and updated during execution of the model. Alternatively information needed to generate the message sequence diagram may be logged or otherwise saved during model execution and the message sequence diagram may be generated following model execution for example in a post mortem analysis.

A first message sequence diagram created by the auto diagram builder may include a plurality of visual elements including lifelines and message arrows. The lifelines which may be vertically oriented on the first message sequence diagram may represent selected message based objects of the model such as message source and or message sink objects. The arrows which may extend between the lifelines may represent selected messages such as synchronous and asynchronous messages that are sent and received by the objects illustrated by the lifelines. As the model executes the first message sequence diagram may scroll e.g. upward and the temporal relationship among events or other interactions or activities may be shown on a dynamic e.g. scrolling diagram.

The auto diagram builder may include execution timing information on the message sequence diagram. For example the auto diagram builder may include a plurality of epoch elements in the diagram where each epoch element represents an execution time increment or instant defined during execution of the model. For example a model may execute over a simulation time that starts at a simulation start time and ends at a simulation end time. States and outputs defined by model objects and other values may be computed at successive points in time between the start and end times. These points in time may be referred to as simulation steps or time steps and their size may be fixed or variable as determined by a particular solver used by the simulation engine. In an embodiment the epochs may correspond to the simulation steps determined by the simulation engine. In another embodiment epochs may correspond to time periods specified by a user and may be hierarchically organized e.g. into major and minor epochs and the periods and organization of epochs may be changed during execution of visualization. In a state based modeling environment such as the Stateflow system when a state diagram executes it may respond to an event that may occur in its context. An event may be a sample time hit. In response to this event one or more transitions may be possible. In a normal step which may also be referred to as a micro step only one such transition may be executed. In a superstep which may also be referred to as a macro step multiple such transitions may be executed. A superstep may complete when the state diagram which may be referred to as a state chart reaches a new stable configuration e.g. no more transitions from active states exist. Also during execution of a state chart new events may be generated locally instead of in the state chart context. The corresponding chart activity may take place in a local step. In an embodiment epochs may correspond to one or more of these various steps e.g. micro step superstep and local step. The type of step to which an epoch corresponds may be user specified. Additionally or alternatively the multiple types of epochs may be indicated e.g. explicitly in a message sequence diagram. The epoch elements may be illustrated by horizontally arranged bands or regions overlaid on the first message sequence diagram. The first message sequence diagram may thus illustrate the particular time instants in which selected messages are sent and received by selected message based objects of the model.

A second message sequence diagram created by the auto diagram builder may include one or more of the visual elements of the first message sequence diagram. In addition the second message sequence diagram may include one or more signal trace elements. A signal trace element may include a trace representing the value of a selected signal of the model. The trace may illustrate how the signal s value changes during execution of the model. The signal trace element like the lifelines may be vertically oriented within the second message sequence diagram and may extend across the horizontally arranged bands representing the epoch elements. In another embodiment a signal trace canvas may be provided alongside a message canvas and the signal trace canvas may be configured to show data events of several signals in one lifeline . The second message sequence diagram may thus provide the user with a visual indication of the value of the selected signal at the time particular messages are exchanged by the message based blocks.

Several different modes may be used to display the value of the signal in the signal trace element. In a first mode to the extent an object represented in the message sequence diagram observes the value of the signal the value of the signal as presented in the signal trace element may be discretized at each epoch element. That is the actual change in value of the signal may be represented in the diagram in temporal relationship with other events e.g. the change in value may be ordered relative to other events such as message send and receive activities. For each epoch element the value presented for the signal may be the observed value. In a second mode the signal value may not be discretized at each epoch element and the signal s actual value may be presented by the signal trace element. In an embodiment separate signal trace elements for both modes may be included in the message sequence diagram. The mode may be determined by a user settable option.

A third message sequence diagram created by the auto diagram builder may include one or more of the visual elements of the first or second message sequence diagrams. In addition the third message sequence diagram may include one or more repeating pattern elements. In particular the model analyzer may be configured to identify a series of sequential epochs during which the message based objects represented by the lifelines exchange similar messages. Rather than include multiple epoch elements illustrating similar message exchanges repeatedly the diagramming engine may replace these epoch elements with a repeating pattern element. The repeating pattern element may illustrate in just a single element the message exchange that repeatedly occurs during a series of epochs. The repeating pattern element also may include an indication of the particular epochs covered by the repeating pattern element. By reviewing the third message sequence diagram a user may identify unexpected behavior in the model. For example the third message sequence diagram may show one or more messages outside of a repeating pattern when the designer expected all of the messages to fall within a repeating pattern.

The simulation engine may implement or define a single task or multiple tasks or processes for executing various portions of the model. A task may be scheduled and a task may have an execution list that includes a set of blocks. The model compiler may assign priorities to the tasks and may assign graphical objects or other model elements such as blocks to a particular task for execution. For example an object associated with a higher sample rate than another object or task may be assigned to a task having a higher priority than another task to which objects having a lower sample rate are assigned. A higher priority task may preempt execution of a lower priority task. In addition the simulation engine may implement a blocking or non blocking execution paradigm. Blocking refers to the process of placing a task on hold because the task is waiting for something e.g. input data a resource a reply to a function call etc. The assignment of priorities and the use of blocking or non blocking schemes may depend on the scheduling algorithm being used by the simulation engine. Other scheduling algorithms besides RMS include Earliest Deadline First Static Cyclic Scheduling and Deadline Monotonic Scheduling.

The simulation engine may be configured to simulate a multitask environment. In addition the simulation engine may be configured to simulate the contention for access to shared resources such a processor resource a memory resource etc. by objects of the model or by tasks.

A fourth message sequence diagram may include visual elements of the first second or third message sequence diagram. In addition the fourth message sequence diagram may include a task execution element for one or more message based objects represented by the lifelines. The task execution element may provide an indication of the particular task executing the respective object. For example the task execution element may include a graphical affordance such as a vertically extending bar portion that is color coded or otherwise marked to indicate the task executing the respective object. For example a first color or fill pattern may represent a first task a second color or fill pattern may represent a second task and so on. The bar elements associated with different objects may be arranged on the diagram to provide a visual indication of when a given task is executing a first object as opposed to a second object. The task execution element also may include a header or other graphical affordance containing the name of the event whose occurrence triggered the current execution of the task. The task execution elements may thus illustrate which task is executing at a given execution time instant and which object or other element a given task is executing.

To execute message based blocks the simulation engine may allocate queues such as input and or output queues for the message based blocks and the queues may be used to temporarily store the values of messages received and or to be sent by the message based blocks.

The model analyzer may detect the allocation of such queues and the auto diagram builder may include queue elements in a fifth message sequence diagram. A queue element may include a vertically arranged queue lifeline that is disposed adjacent to the lifeline for the respective message based block. To the extent messages are sent from an output queue of a source block and received in an input queue of a sink block message arrows of the message sequence diagram may extend between the respective queue lifelines. In an embodiment a graphical affordance such as a queue depth bar may be provided on at least some of the queue lifelines that indicates the number of messages in the queue represented by the respective queue lifeline. For example a queue depth bar may have a width that indicates the number of messages in the respective queue. The queue depth bar may be widened when an additional message is added to the queue and narrowed when a message is removed from the queue.

The queue depth bar also may be configured to indicate if the depth of the queue has been exceeded. For example a queue may have a depth of five if a sixth message is sent to in the queue the color of the queue depth bar may be changed by the auto diagram builder e.g. from green to red or some other indication may be provided.

In an embodiment a user may modify a message sequence diagram. For example the user may change the execution of a selected task from a first epoch to a second epoch e.g. by dragging and dropping the task execution bar from a first epoch element to a second epoch element. The user also may change when a selected message is sent and or received by editing the corresponding arrow again using drag and drop techniques. Other changes may be made to a message sequence diagram. The user initiated changes may be captured by the UI engine of the diagramming tool. The diagramming tool may notify the simulation engine of the changes detected in the message sequence diagram. The simulation engine including the model compiler and the schedulers may generate new execution instructions for the model that conform to the user modified message sequence diagram. For example the schedulers may reschedule the execution order of one or more objects of the model in order to comply with the changes made to the message sequence diagram.

The modeling environment may further include a diagramming tool . The diagramming tool may include a model execution analyzer a filtering unit an automatic auto diagram builder and a user interface UI engine . As described herein the model execution analyzer may be configured to examine the execution instructions generated by the simulation engine for a specified model. The filtering unit may be configured to search the execution instructions for particular elements of the model. The auto diagram builder may be configured to generate one or more message sequence diagrams utilizing the information obtained by the model execution analyzer as filtered by the filtering unit . The UI engine may be configured to generate one or more user interfaces that include the one or more message sequence diagrams and to receive edits thereto.

The modeling environment may include other components such as a code generator a target language compiler and a differencing engine . The code generator may be configured to generate computer programming code such as source and or object code from a model. The target language compiler may be configured to compile source code such as source code generated by the code generator into an executable form such as one or more object code files or binaries for execution by target platform or target hardware such as a central processing unit CPU an embedded processor a microprocessor a microcontroller a Field Programmable Gate Array FPGA an Application Specific Integrated Circuit ASIC a Graphics Processing Unit GPU etc. of a data processing device. The differencing engine may be configured to analyze two models identify the differences between them and generate a report that sets forth the identified differences.

Suitable code generators for use with the present invention include but are not limited to the Simulink Coder the Embedded Coder and the Simulink HDL Coder products from The MathWorks Inc. of Natick Mass. and the TargetLink product from dSpace GmbH of Paderborn Germany. Suitable target language compilers include C and C language compilers. Nonetheless other code generation systems and other compilers may be used. Suitable differencing engines include the version compare utility in the Simulink Report Generator tool and the SimDiff tool from Ensoft Corp. of Ames Iowa.

In an embodiment the diagramming tool may be implemented through one or more software modules or libraries containing program instructions pertaining to the methods described herein. The software modules may be stored in one or more memories such as a main memory a persistent memory and or on computer readable media of a workstation or other data processing machine or device and executed by one or more processing elements. Other computer readable media may also be used to store and execute these program instructions such as non transitory computer readable media such as optical magnetic or magneto optical media. In another embodiment the diagramming tool may comprise registers and combinational logic implemented in hardware and configured and arranged to produce sequential logic circuits. In alternative embodiments various combinations of software and hardware including firmware may be utilized to implement the described methods.

In other embodiments the diagramming tool or one or more components thereof may be separate from the modeling environment . In such cases the diagramming tool may be in communication with the modeling environment e.g. through local procedure calls LPCs remote procedure calls RPCs or one or more Application Programming Interfaces APIs .

In an embodiment the modeling environment is a high level modeling environment. Suitable high level modeling environments include the MATLAB and Simulink technical computing environments from The MathWorks Inc. as well as the Simscape physical modeling system and the Stateflow charting tool also from The MathWorks Inc. the MapleSim physical modeling and simulation tool from Waterloo Maple Inc. of Waterloo Ontario Canada the LabVIEW programming system and the NI MatrixX model based design product both from National Instruments Corp. of Austin Tex. the Visual Engineering Environment VEE product from Agilent Technologies Inc. of Santa Clara Calif. the System Studio model based signal processing algorithm design and analysis tool from Synopsys Inc. of Mountain View Calif. the SPW signal processing algorithm tool from Synopsis a Unified Modeling Language UML system a Systems Modeling Language SysML system the System Generator system from Xilinx Inc. of San Jose Calif. and the graphical modeling systems described in U.S. Pat. No. 7 324 931 for Conversion of Model Components Into References and U.S. Pat. No. 7 991 598 for Method and System for Modeling a Mechanical System which are hereby incorporated by reference in their entireties among others. Models created in the high level modeling environment may contain less implementation detail and thus operate at a higher level than certain programming languages such as the C C C and SystemC programming languages.

Those skilled in the art will understand that the MATLAB technical computing environment is a math oriented textual programming environment for digital signal processing DSP design among other uses. The Simulink technical computing environment is a model based design environment for modeling and simulating dynamic and other systems among other uses. The MATLAB and Simulink tools provide a number of high level features that facilitate algorithm development and exploration and support model based design. Exemplary high level features include dynamic typing array based operations data type inferencing sample time inferencing and execution order inferencing among others.

In another embodiment a lower level programming language such as the C C and C programming languages among others may be used to create one or more models.

Models constructed by the modeling environment may include textual models graphical models and combinations of graphical and textual models. A given model may simulate e.g. approximate the operation of a system. Exemplary systems include physical systems such as weather systems financial markets plants controllers etc. A model may be executed in order to simulate the system being modeled and the execution of a model may be referred to as simulating the model.

The diagramming tool may receive an indication such as a command to generate one or more message sequence diagrams for a model as indicated at block . The diagramming tool also may receive an indication of one or more model elements to be included in the one or more message sequence diagrams to be generated as indicated at block . In an embodiment the HMI engine may be configured to present one or more model editor windows on a display. The model editor windows may include a plurality of graphical elements such as menu bars tool bars and a canvas for displaying a graphical model. A user may select one or more elements of a model presented on the model canvas. Alternatively or additionally a parameter or property may be defined for at least some of the graphical objects used in models. The setting of the parameter may determine whether the respective object is to be included in a message sequence diagram. To set the parameter the user may select the respective object and the UI engine may present a dialog or pane through which the value of the parameter may be set by the user.

The simulation engine may generate execution instructions for the model as indicated at block . The generation of execution instructions and the simulation of a model may involve several phases such as a compilation phase a link phase and a simulation phase. Model execution typically involves processing input data and generating output data. In an embodiment execution of the model may be carried out over a time span e.g. a simulation time which may be user specified or machine specified. The simulation time is a logical execution time and may begin at a simulation start time and end at a simulation end time. At successive points in time between the simulation start and end times which points in time may be called simulation time steps states inputs and outputs of objects of the model may be computed. The size of the time steps may be fixed or may vary and are determined by the particular solver used in the execution of the model. Execution instructions may be generated for the entire simulation time.

A compile stage may mark the start of execution of the model and may involve preparing data structures and evaluating parameters configuring and propagating block characteristics determining block connectivity and performing block reduction and block insertion. The preparation of data structures and the evaluation of parameters may result in the creation and initialization of one or more data structures for use in the compile stage. For the blocks of the model a method may force the block to evaluate all of its parameters. This method may be called for the blocks in the model. If there are any unresolved parameters execution and or compilation errors may be thrown. During the configuration and propagation of block and port signal characteristics the compiled attributes such as data dimensions data types complexity sample modes and sample time of each block and or port signal may be setup on the basis of the corresponding behaviors and the attributes of blocks and or port signal that are connected to the given block which connections may be graphically represented on the model through lines arrows or other connectors. The attribute setup may be performed through a process during which block behaviors ripple through the model from one block to the next following signal state physical message or other connectivity.

This process is referred to as inferencing an implementation of which is propagation. In the case of a block that has explicitly specified its block or port behaviors propagation helps ensure that the attributes of the block are compatible with the attributes of the blocks connected to it. If not an error may be issued. Secondly in many cases blocks are implemented to be compatible with a wide range of attributes. Such blocks may adapt their behavior in accordance with the attributes of the blocks connected to them. This is similar to the concept of polymorphism in object oriented programming languages. The exact implementation of the block may be chosen on the basis of the model in which the block finds itself. Included within this step may be other aspects such as validating that all rate transitions yield deterministic results and that the appropriate rate transition blocks and or delay blocks are being used. The compilation step also may determine actual block connectivity. For example virtual blocks may play no semantic role in the execution of a model. In this step the virtual blocks may be optimized away e.g. removed and the remaining non virtual blocks may be reconnected to each other appropriately. This compiled version of the design model with actual block connections may be used from this point forward in the execution process. The way in which blocks are interconnected in the model does not necessarily define the order in which the equations methods corresponding to the individual blocks will be solved executed . These equations may include outputs equations derivatives equations and update equations.

Block sample times may also be determined during the compilation stage. A block s sample time may be set explicitly e.g. by setting a SampleTime parameter of the block or it may be determined in an implicit manner based on the block s type or its context within the model. The SampleTime parameter may be a vector T T where Tis the sampling period and Tis the initial time offset.

The selected solver may determine the size of the simulation time steps for the simulation of the model and these simulation time steps are selected to correspond with the sample times of the blocks of the model. When a simulation time step matches the sample time for a block a sample time hit occurs and the block is scheduled for execution during that simulation step.

The schedulers may generate execution lists for the blocks of the model. In particular the schedulers may generate a block sorted order list and a method execution list. The schedulers may utilize one or more algorithms for generating the block sorted order and method execution lists. For example the static scheduler may use the Rate Monotonic Scheduling RMS Earliest Deadline First Scheduling Static Cyclic Scheduling or Deadline Monotonic Scheduling. The dynamic scheduler may use an event calendar to schedule future events such as timeouts and alarms.

In the link stage memory may be allocated and initialized for storing run time information for blocks of the model.

Following the model compilation and link stages code may or may not be generated for the model. If code is generated the model may be executed through an accelerated execution mode in which the model or portions of it is translated into either software modules or hardware descriptions which is broadly referred to herein as code. If this stage is performed then the stages that follow use the generated code during the execution of the design model. If code is not generated the model may execute in an interpretive mode in which the compiled and linked version of the model may be directly utilized to execute the model over the simulation time. The model may not be executed when code is generated for the model. Instead of executing the model within the modeling environment the generated code may be compiled and deployed on a target device such as a controller test hardware etc.

Generated code may be stored in memory e.g. persistent memory such as a hard drive or flash memory. The HMI engine may provide or support a Code Generation button in a GUI that may be selected by the user or the HMI engine may receive a code generation command entered by the user e.g. in the GUI or the CLI. The code generation command also may be invoked programmatically for example when a particular event occurs. In response to the code generation command being activated the code generator may generate code for the model.

In an embodiment the generated code may be textual code such as textual source code that may be compiled and executed on a target machine or device. The generated code may conform to one or more programming languages such as Ada Basic C C C SystemC FORTRAN VHDL Verilog embedded MATLAB a vendor or target specific HDL code such as Xilinx FPGA libraries assembly code etc. For example one or more code generation files such as header main make and other source files may be generated for the design model. The target language compiler may compile the generated code for execution by target hardware such as a microprocessor a Digital Signal Processor DSP a Field Programmable Gate Array FPGA etc.

The model execution analyzer may analyze the execution instructions generated for identified model as indicated at block . For example the model execution analyzer may access the execution instructions generated by the simulation engine to determine the execution order of one or more objects of the model the identity of tasks executing particular objects of the model the priority of particular tasks and or objects of the model the existence of queues e.g. for buffering messages and the logical execution times at which messages are generated added to queues removed from queues and consumed. The model execution analyzer may obtain further information regarding the execution of the model.

The auto diagram builder may generate one or more message sequence diagrams as indicated at block and the one or more message sequence diagrams may be presented e.g. on a display as indicated at block . In an embodiment the one or more message sequence diagrams may be presented as the model is executed. In another embodiment the one or more message sequence diagrams may be generated for viewing after model execution.

Furthermore the sender block may be configured such that when event e2 occurs the sender block places the current value of the counter block on its output queue qOut generates a message having the current value of the counter block as its payload and increments the counter block . Messages generated by the sender block are received at the input queue qIn of the receiver block as indicated by a first arrow . The receiver block may be configured such that when event e1 occurs the receiver block determines whether there is a message on its input queue qIn . If so the receiver block retrieves the message places the value of the message at its output queue qOut and generates a message with the value. If there is no message on the receiver block s input queue qIn the receiver block generates a message with a payload of 1 . Messages generated by the receiver block are received at the input queue sIn of the sink block as indicated by a second arrow . The sink block may be configured such that when event e3 occurs the sink block retrieves the messages on its input queue sIn and displays the message values e.g. on a console.

A user may be interested in observing the execution of the model . The user may enter a command to generate one or more message sequence diagrams for the model . The user may designate that information concerning the sender receiver and sink blocks is to be included in the one or more message sequence diagrams.

The model execution analyzer may examine the execution instructions including the execution schedules generated for the model by the simulation engine . If the model has not yet been executed the diagramming tool may direct the simulation engine to execute the model thereby generating execution instructions. The filtering unit may direct the model execution analyzer to search the execution instructions for the occurrence of elements of the model such as blocks queues connections etc. that were identified as being of interest to the user e.g. the sender receiver and sink blocks . The filtering unit also may direct the model execution analyzer to examine one or more logical execution time periods that are of interest to the user.

The model compiler may establish a single task e.g. the PollingSystemPeriodic task to execute the functions defined by all three blocks and . In addition the static scheduler may be used and may schedule the order of the events e1 e2 and e3 such that event e2 is processed before event e1 which is processed before event e3.

The auto diagram builder may be configured to utilize a plurality of different graphical affordances in the first diagram to illustrate the interactions among the selected entities of the model . For example the auto diagram builder may include a first type of graphical affordance to represent the selected entities i.e. the sender receiver and sink blocks . The first type of graphical affordance may be a lifeline. In particular the auto diagram builder may include a first lifeline for the sender block a second lifeline for the receiver block and a third lifeline for the sink block . The lifelines may be dashed lines that are parallel to each other and may extend vertically in the diagram . The lifelines may include headers such as headers that contain information identifying the respective entities such as their names e.g. sender receiver and sink .

The auto diagram builder may use a second type of graphical affordance to represent interactions between the entities. For example the auto diagram builder may represent the occurrence of message send and receive interactions among the entities during execution of the model using one or more symbols or other graphical images such as connectors and more particularly solid line arrows where the arrows extend between the lifelines thereby visually linking the lifelines. An arrow may identify the lifelines of the sending and receiving blocks. For example the tail of an arrow may be located on the lifeline of the entity sending the message while the head of the arrow may be located on the lifeline of the entity receiving the message. As mentioned the auto diagram builder may arrange the arrows on the diagram in an order that illustrates the execution order of the interactions as determined by the simulation engine . For example the auto diagram builder may place the arrow for a first interaction above a second arrow for a second interaction where the first interaction occurs before the second interaction.

As mentioned the schedulers of the model compiler generate an execution schedule for the model over the simulation time. The message based blocks are configured to execute at particular sample times. Accordingly the blocks may be message based blocks that may be scheduled for execution at each simulation time step that corresponds to a sample time hit for a respective one of the blocks .

All three blocks may be scheduled for execution in a first simulation time step which may correspond to sample time 0. The sender block reads the value of the counter block e.g. 0 and generates a first message with this value as its payload. The message is received at the receiver block which generates a second message with this value as its payload. The second message is received at the sink block which displays the value from the message e.g. 0 on the console.

On the first diagram a first arrow extending from the sender s lifeline to the receiver s lifeline represents the first message. A second arrow extending from the receiver s lifeline to the sinks lifeline represents the second message. In an embodiment the auto diagram builder may provide information concerning the payload of messages illustrated in the first diagram . For example the auto diagram builder may include a payload data box adjacent to e.g. above the arrow and may present the value of the message s payload in the data box. A first data box may be associated with the first arrow indicating that the payload of the first message is 0. A second data box may be associated with the second arrow indicating that the payload of the second message is also 0. Execution of the sink block does not involve the generation or sending of any messages. Accordingly no arrows are shown from the sink s lifeline .

As mentioned the receiver block executes at each sample time e.g. sample times 0 1 2 3 etc. the sender block executes at every other sample time e.g. sample times 0 2 4 6 etc. and the sink block executes every fourth sample time e.g. sample times 0 4 8 12 etc. Accordingly at the simulation time step for sample time 1 only the receiver block is scheduled for execution. The receiver block again generates a message. However because there is no new data on the receivers input queue qIn the receiver block transmits a message whose payload is 1. This message is represented on the diagram as a third arrow having third data box

In an embodiment the auto diagram builder positions the arrows representing messages to indicate when during execution of the model the message is both sent and received. The first and second messages are both sent and received during the first simulation step which corresponds to sample time 0 because all three blocks execute at this sample time. Accordingly the auto diagram builder may draw the first and second arrows horizontally on the diagram .

However while the third message as represented by the third arrow is sent by the receiver block during the simulation time corresponding to sample time 1 this third message is not received by the sink block until the simulation time corresponding to sample time 4 which is the next time after sample time 0 that the sink block is scheduled to execute. Accordingly while the tail of the third arrow is placed on the receiver s lifeline at a location indicating that it is the next message to be sent after the second message the head of the third arrow is placed on the sink s lifeline at a much lower point e.g. a point representing the simulation time step for sample time 4. The slope of an arrow in the first diagram may thus represent a delay between a logical execution time at which a message is sent and a logical execution time at which the message is received.

At the simulation time for sample time 2 both the sender block and the receiver block are scheduled for execution. The sender block again reads the value of the counter block which is now 1 and generates a message with that value as its payload. This message is illustrated in the diagram by a fourth arrow with a data box illustrating that the payload of this message is 1. The receiver block receives the message and generates its own message with the value from the received message e.g. 1. The message generated by the receiver block is illustrated in the diagram by a fifth arrow with a data box . Because the message represented by the fifth arrow is not received by the sink block until the sink block next executes the fifth arrow like the third arrow is also sloped indicating the time delay.

At the simulation time for sample time 3 only the receiver block is scheduled for execution. The receiver block generates a message but because no new data was received by the receiver block the receiver block uses the value of 1 for the payload of this message. This message is illustrated in the diagram by a sixth arrow with a data box . The sixth arrow is also displayed in a sloping manner indicating that it is not received by the sink block until a later logical execution time.

At the simulation time for sample time 4 all three blocks are once again scheduled for execution. The sender block reads the value of the counter block i.e. 2 and generates a message with this value as its payload. This message is represented in the diagram by a seventh arrow with a data box . The receiver block receives the message from the sender block and generates its own message using the value from the received message i.e. 2. The message generated by the receiver block is illustrated by an eighth arrow with a data box

Even though the eighth arrow represents a message that is sent and received during the same simulation time step e.g. sample time 4 the eighth arrow is sloped indicating that the sink block receives the message at a logical time that is after it was sent by the receiver block . This is due to the fact that after the receiver block sends this message it is not processed by the sink block until after the sink block has processed the other messages represented by arrows and .

The auto diagram builder may also be configured to utilize one or more graphical affordances to represent logical execution time of the program on a message sequence diagram. For example the auto diagram builder may be configured to include a plurality of horizontal regions on a message sequence diagram where each region corresponds to a particular logical execution time instant. The horizontal regions may be referred to as epochs. In an embodiment an epoch may correspond to a simulation time step during which an activity involving at least one of the selected entities occurs. The auto diagram builder may include boundaries such as lines separating adjacent epochs and may include information regarding the logical execution time instant of the epochs.

Included in the second diagram is a first epoch for the simulation time step corresponding to sample time 0. The first epoch may include a data box that contains information regarding the particular logical execution time instant of the first epoch e.g. the simulation time step that corresponds to sample time 0. A boundary line may mark the end of the first epoch and the start of a second epoch . The second epoch may include a data box that contains information regarding its logical execution time instant e.g. the simulation time step that corresponds to sample time 1 and a boundary that separates the second epoch from a third epoch . The third epoch includes a data box that contains information regarding its logical execution time instant e.g. the simulation time step that corresponds to sample time 2 and a boundary line that separates the third epoch from a fourth epoch . The fourth epoch includes a data box that contains information regarding its logical execution time instant e.g. the simulation time step that corresponds to sample time 3 and a boundary line that separates the fourth epoch from a fifth epoch . The fifth epoch includes a data box that contains information regarding its logical execution time instant e.g. the simulation time step that corresponds to sample time 4.

In addition to illustrating epochs on a message sequence diagram the auto diagram builder may also be configured to include one or more graphical affordances that represent the task used to execute the blocks . For example the auto diagram builder may overlay a task activation bar onto a lifeline to indicate when a task is executing the block represented by that lifeline.

As mentioned the model compiler may be directed to implement or define a single task to execute the sender receiver and sink blocks . The model compiler may define a task called PollingSystemPeriodic .

During the first epoch a first task activation bar may indicate that the task i.e. the PollingSystemPeriodic task first executes the sender block . The length of the task activation bar may provide an indication of the length of the physical execution time that the task spends executing the sender block . Upon completion of the sender block the task switches to executing the receiver block as indicated by a second task activation bar . Upon completion of execution of the receiver block the task executes the sink block as indicated by a third task activation bar . A task activation bar may include a header portion and information identifying the event that triggered execution of a block by the task such as the event s name may be included in the header portion. For example the event that triggers execution of the sender block is called e2 the event that triggers execution of the receiver block is e1 and the event that triggers execution of the sink block is e3.

As the PollingSystemPeriodic task can only execute one of the blocks at any given point in time there is no overlap among the task activation bars .

During the second epoch which corresponds to the simulation time step for sample time 1 the task only executes the receiver block as indicated by fourth task activation bar . During the third epoch which corresponds to the simulation time step for sample time 2 the task executes the sender block and the receiver block as indicated by fifth and sixth task activation bars . During the fourth epoch which corresponds to the simulation time step for sample time 3 the task only executes the receiver block as indicated by seventh task activation bar . During the fifth epoch which corresponds to the simulation time step for sample time 4 the task executes all three blocks as indicated by eighth ninth and tenth task activation bars .

The message sequence diagram provides the user with an indication of which activities occur in a given logical execution time instant i.e. an epoch and the relative order of those activities in that time instant. For example with reference to the first epoch it can be observed that the task executes the sender block before executing the receiver block and that the task executes the receiver block before executing the sink block . The diagram also provides the user with an indication of the length of logical execution time taken by a task to execute a given entity. For example with reference to the fifth epoch it can be observed that the task requires more logical execution time to execute the sink block than to execute the sender or receiver blocks . The diagram also provides an indication of the event that triggers the execution of a block of interest.

With reference to the receiver block has an input queue qIn and the sink block has an input queue sIn . Suppose the user is interested in seeing the interaction among the sender receiver and sink blocks including the input queues qIn and sIn . In this case the user may designate the input queues qIn and sIn as additional entities to be included in a message sequence diagram and the model execution analyzer may examine the execution instructions to determine what interactions occur with these queues as well as the blocks and when those interactions occur.

During the first epoch which corresponds to sample time 0 the sender block reads the value of the counter and sends a message to the receiver block with the counter value 0. While this message is received by the receiver block more specifically it is received by the receiver block s input queue qIn . Since the receiver block s input queue qIn is now represented in the third diagram this message is represented by a first arrow having a data box that extends from the sender s lifeline to the lifeline for the receiver s input queue qIn . As noted the tail of an arrow may be located at the lifeline of the message sender and the head of the arrow may be located at the receiver s lifeline. The auto diagram builder may be configured to provide a graphical affordance that illustrates how long a message sits in a queue. For example the auto diagram builder may provide a queue depth bar on the lifeline of a queue that indicates how long a message sits in the queue. A first queue depth bar indicates how long the first message from the sender block sits in the receiver s input queue qIn . The auto diagram builder also may include a graphical affordance that indicates when a message is removed from a queue e.g. when the message is consumed. The graphical affordance may be a solid line arrow. The act of retrieving the message by the receiver block from its input queue qIn is illustrated by a second arrow which may include a data box that indicates the value e.g. 0 of the message retrieved from the queue.

A third arrow with a data box indicates the message sent by the receiver block and received by the input queue sIn of the sink block . A second queue depth bar indicates how long this message sits in the sink block s input queue sIn and a fourth arrow with a data box indicates when the message is retrieved by the queue sIn by the sink block .

During the second epoch which corresponds to sample time 1 a fifth arrow with a data box indicates the message sent from the receiver block to the input queue sIn of the sink block . A second queue depth bar may indicate the depth of the sink block s input queue sIn .

During the third epoch which corresponds to sample time 2 a sixth arrow with a data box indicates the message sent from the sender block to the receiver block s input queue qIn . A third queue depth bar indicates how long this message sits in the receiver block s input queue qIn . A seventh arrow with a data box indicates that the receiver block retrieves the message from its input queue qIn and an eighth arrow with a data box indicates the message sent from the receiver block to the sink block s input queue sIn .

The auto diagram builder may be configured to use one or more graphical affordances to indicate how many messages are sitting in a queue. For example the auto diagram builder may alter the width of a queue depth bar to indicate how many messages are waiting in a queue. That is a first width may indicate a single message is in the queue a second width may indicate two messages are in the queue a third width may indicate three messages are in the queue etc. When the third message is received at the sink s input queue sIn as indicated by the eighth arrow it now represents the second message in the sink s input queue sIn . Accordingly the auto diagram builder may increase the width of the queue depth bar . For example a first portion of the queue depth bar may be used to indicate a single message in the queue e.g. during the third epoch and a second portion that is wider than the first portion may be used to indicate two messages are in the queue at the start of the fourth epoch .

During the fourth epoch which corresponds to sample time 3 another message is sent from the receiver block to the sink s input queue sIn as indicated by a ninth arrow with a data box . The auto diagram builder may also create a third portion of the queue depth bar that is even wider than the second portion to indicate there are now three messages are in the sink s input queue sIn .

During the fifth epoch which corresponds to sample time 4 the sender block sends a message to the receiver s input queue qIn as indicated by a tenth arrow with a data box . The message sits in the receiver s input queue qIn as indicated by the queue depth bar . The message is retrieved by the receiver block as indicated by an eleventh arrow with a data box . The receiver block sends a message to the sink s input queue sIn as indicated by a twelfth arrow with a data box . However with this example the sink s queue size is only three and the sink s queue already has three messages. The auto diagram builder may be configured to use one or more graphical affordances to indicate the occurrence of a lost message or a message that cannot be delivered. For example the auto diagram builder may illustrate a lost or undeliverable message by shortening the twelfth arrow so that it does not reach the intended lifeline . In addition the auto diagram builder may connect the head of the arrow to a dot such as dot providing an additional visual cue that the message could not be delivered e.g. because the sink s input queue sIn is full.

The retrieving of messages by the sink block from its input queue sIn may be illustrated by thirteenth fourteenth and fifteenth arrows with data boxes . When a message is retrieved from the sink s input queue sIn the auto diagram builder may indicate this on the diagram by decreasing the width of the queue depth bar as illustrated at fourth and fifth portions 

It should be understood that the model execution analyzer may determine that the message represented by the twelfth arrow is not delivered by examining the execution instructions generated for the model by the model compiler .

As described above with reference to the sender block is configured to read the current value of the counter block generate a message with that value as it payload and cause the counter block to increment its value. Suppose a user is interested in observing the counter value generated by the counter block during model execution. In this case the user may designate the counter signal generated by the counter block as well as the sender receiver and sink blocks for presentation in a message sequence diagram. The counter block may be a signal based block. That is the counter block may generate a counter signal that in an embodiment may have a value at all times during execution of the model .

With reference to the first epoch the sender block reads the value of the counter signal 0 and generates a message with this value. The message is represented by the first arrow . After generating the message the sender block causes the counter block to increment the counter signal e.g. from 0 to 1. As illustrated in the fourth message sequence diagram at the completion of the task executing the sender block as indicated by the task activation bar the value of the counter signal as represented by the trace moves from 0 to 1 as shown by trace portions and . Because the task executing the sender and receiver blocks does not commence execution of the receiver block until after the sender block causes the counter signal to increment from 0 to 1 the first arrow leading to the receiver block s lifeline is sloped.

As shown the value of the counter signal remains at until the third epoch which is the next simulation step at which the sender block is executed. Again the sender block reads the current value of the counter signal which is now 1 generates a message with this value as indicated by the fourth arrow and causes the counter block to increment the counter signal. The change in value of the counter signal e.g. from 1 to 2 is represented by trace portions and

The value of the counter signal remains unchanged until the fifth epoch which is the next simulation step at which the sender block is executed. Once again the sender block reads the current value of the counter signal which is now 2 generates a message with this value as indicated by the seventh arrow and causes the counter block to increment the counter signal. The change in value of the counter signal e.g. from 2 to 3 is represented by trace portions and

By reviewing the fourth message sequence diagram the user can observe the value of the counter signal in relation to the interactions among the sender receiver and sink blocks .

As with the third message sequence diagram the final message generated by the receiver block is not delivered to the sink s the input queue sIn because the queue is full as represented by the eighth arrow which terminates in the dot element .

In an embodiment the model compiler may be configured to implement a plurality of tasks for executing the sender receiver and sink blocks rather than just a single task as previously described. In addition the model compiler may map the execution of the sender block to a first task which may be called Task e2 the receiver block to a second task which may be called Task e1 and the sink block to a third task which may be called Task e3 .

The auto diagram builder moreover may be further configured to provide information on a message sequence diagram that shows which task is executing a selected block or other selected element of the model .

The fifth message sequence diagram may include a legend block that indicates the fill pattern or color used to illustrate the different tasks. The legend block may include a first entry that indicates that the Task e3 task is represented with a forward hash pattern a second entry that indicates that the Task e2 task is represented with a vertical hash pattern and a third entry that indicates that the Task e1 task is represented with a backward hash pattern.

The various tasks may use the same computing resources such as processing and or memory resources and the model compiler may assign different priorities among the tasks to control their execution order. For example the task Task e1 may be assigned a higher priority than the task Task2 which in turn may be assigned a higher priority than the task Task e3 . In addition the user interface engine may be configured to include one or more graphical affordances e.g. in the legend block to indicate the priorities of the tasks. For example the user interface engine may indicate the priorities of the tasks with numbers included in parentheses following the task names. Specifically the task Task e3 may have priority 1 the task Task e2 may have priority 2 and task Task e1 may have priority 3.

Alternatively there may be concurrent resources available to the various tasks which may not require preemption to support multitasking.

The auto diagram builder may be configured to illustrate the execution of the sender receiver and sink blocks with task activation bars having the color or fill pattern of the respective task. More specifically a first task activation bar may represent execution of the receiver block during the first epoch . Execution of the receiver block includes the generation of a message that is received by the sink block as indicated by a first arrow have a data box . Following the completion of the execution of the receiver block by the Task e1 task the Task e2 task executes the sender block as indicated by a second task activation bar . Execution of the sender block includes the generation of a message received by the receiver block as indicated by a second arrow with a data box . Following the completion of the execution of the sender block by the Task e2 task the Task e3 task executes the sink block as indicated by a third task activation bar .

In the second epoch only the receiver block executes as indicated by a fourth task activation bar which bears the fill pattern for the Task e1 task. During execution of the receiver block in the second epoch the message generated by the sender block in the first epoch is received as indicated by the head of the second arrow terminating at the receiver s lifeline in the second epoch . Execution of the receiver block during the second epoch includes the generation of a message as indicated by a third arrow with a data box

In the third epoch the receiver and sender blocks execute as indicated by fifth and sixth task activation bars which carry the fill patterns for the respective tasks. Execution of the receiver block includes generation of a message as indicated by a fourth arrow with a data box . Execution of the sender block includes the generation of a message as indicated by a fifth arrow with a data box

In the fourth epoch only the receiver block executes as indicated by a seventh task activation bar . During execution of the receiver block the message represented by the fifth arrow is received and a new message is generated as indicated by a sixth arrow with a data box

In the fifth epoch the sender receiver and sink blocks all execute as indicated by eighth ninth and tenth task activation bars . Execution of the receiver block which occurs first because of the priority assignments includes the generation of a message as indicated by a seventh arrow with a data box . Execution of the sender block includes the generation of a message as indicated by an eighth arrow with a data box

As noted one or more of the message sequence diagrams generated by the auto diagram builder may be dynamic. That is the diagrams may change as the interactions among selected elements are displayed. For example one or more of the diagrams may scroll to show new interactions while previous interactions may disappear from view within the diagrams.

The auto diagram builder may use one or more graphical affordances to indicate a message that has been successfully queued at the receiver but not yet consumed. For example an arrow that represents a message may be provided with a first graphical affordance when the message is generated and a second graphical affordance when the message is received. Reference is made to the eighth arrow of the fifth message sequence diagram . When the message represented by the eighth arrow is generated by the sender block and successfully received at the receiver block but not yet consumed by the receiver block the auto diagram builder may be configured to provide the arrow with a first graphical affordance such as a dashed line. When the message represented by the arrow is finally consumed by the receiver block the auto diagram builder may change its appearance e.g. from a dashed line to a solid line. In this way the auto diagram builder may represent messages that are received and sitting in a queue such as the receiver block s input queue qIn but have yet to be consumed.

Message sequence diagrams illustrate the interaction among entities or elements of the model including graphical objects such as blocks and other entities such as queues. Instead of viewing the interaction among model entities or elements a user may be interested in observing the interaction among tasks implemented by the model compiler to execute the model .

In an embodiment the diagramming tool may receive a command to create one or more message sequence diagrams that illustrate the interaction among a plurality tasks selected e.g. by the user. For example the UI in which the message sequence diagrams are displayed may include a mode command field not shown . The user may switch the mode command field from block to task and this command may be received by the diagramming tool . The auto diagram builder may be configured to generate one or more message sequence diagrams presenting a task centric view as opposed to a model entity or element centric view as shown in the message sequence diagrams of .

The auto diagram builder may provide a lifeline for each of the tasks such as a first lifeline for the Task e2 task a second lifeline for the Task e1 task and a third lifeline for the Task e3 task. Headers may be provided with the lifelines for presenting information about the respective tasks such as their names. Specifically the first lifeline may include a first lifeline header the second lifeline may include a second lifeline header and the third lifeline may include a third lifeline header . In addition an overall domain header such as overall task domain header may be included in the diagram that provides information such as the name e.g. PollingSystemPollingDomain of the domain of the tasks represented by the lifelines . In an embodiment a fourth lifeline with a fourth lifeline header may be included to represent an idle task. The fourth lifeline may be configured to indicate when a resource shared by the tasks such as a processor or a core is not being used during an epoch.

The auto diagram builder may be configured to provide a graphical affordance that indicates the execution of a particular task. For example the auto diagram builder may include a task execution bar at the lifelines to represent the execution of the respective task. More specifically during the first epoch the Task e1 task executes as indicated by a first task execution bar . A task execution bar header portion may be provided that includes additional information regarding the respective task such as the blocks or other model elements executed by the respective task. The first task execution bar may include a first header portion that specifies the one or more blocks or other model elements executed by that task i.e. the receiver block . During execution of the Task e1 task a message is generated as indicated by a first arrow with a data box . The message moreover is received by the Task e3 task. The auto diagram builder may place the tail of the arrow at the lifeline of the task that generates the message e.g. the second lifeline for the Task e1 task and the head of the arrow at the lifeline of the task receiving the message e.g. the third lifeline for the Task e3 task.

Following execution of the Task e1 task the Task e2 task executes as indicated by a second task execution bar which also includes a header portion specifying the model elements executed by that task i.e. the sender block . In an embodiment the auto diagram builder may be configured to use one or more graphical affordances to indicate when a task is ready to execute and when that task is executing. For example a portion of a task execution bar located below the header may represent the execution of the task while a portion of the task execution bar above the header may represent a logical execution time when the task is ready to but not yet executing. The second task execution bar may include a ready to execute portion

One or more graphical affordances may be used to distinguish the ready to execute portion of a task execution bar from the rest of the task execution bar. Exemplary graphical affordances include fill pattern shading coloring etc. In an embodiment the graphical affordance may be a variation of the fill pattern used for the task execution bar. In particular when the fill pattern is vertical lines as with the second task execution bar the ready to execute portion may have dashed vertical lines. Nonetheless those skilled in the art will understand that other graphical affordances may be used.

As indicated by the ready to execute portion of the second execution bar the Task e2 task was ready to execute at the same time as the Task e1 task. However because the Task e1 task has a higher priority than the Task e2 task the Task e2 task had to wait until the Task e1 task completed before it could begin executing. In other words the ready to execute portion provides a visual indication of the execution of the Task e2 task being preempted by the Task e1 task which has a higher priority. During execution of the Task e2 task a message is generated as indicated by a second arrow with a data box

Following execution of the Task e2 task the Task e3 task executes as indicated by a third task execution bar of the diagram . The third task execution bar also includes a header portion that indicates the model elements executed by the task i.e. the sink block and a ready to execute portion indicating the logical execution time during which this task was ready to execute but was not yet executing. As indicated by the ready to execute portion the Task e3 task was also ready to execute at the same time as the Task e1 and Task e2 tasks. However the Task e3 task has a lower priority than these other two tasks and thus the Task e3 task had to wait unit the other two tasks completed before it could begin executing. At the completion of the Task e3 task the shared resource e.g. the processor falls idle before the end of the first epoch and before the start of the second epoch as indicated by a first idle bar on the idle lifeline .

At the second epoch only the Task e1 task executes as indicated by a fourth task execution bar . During execution of the Task e1 task in the second epoch the message represented by the second arrow is received and a new message is generated as indicated by a third arrow having a data box . At the completion of the Task e1 task the shared resource again falls idle before the end of the second epoch as indicated by a second idle bar .

At the third epoch the Task e1 task executes as indicated by a fifth task execution bar having a header . Execution of the Task e1 task involves the generation of a message as indicated by a fourth arrow with data box . Next the Task e2 task executes as indicated by a sixth task execution bar having a header and a ready to execute portion . Execution of the Task e2 task includes the generation of a message as indicated by a fifth arrow having a data box

At the fourth epoch only the Task e1 task executes as indicated by a seventh task execution bar with a header . During execution of the Task e1 task the message represented by the fifth arrow is received and a new message is generated as indicted by a sixth arrow having a data box . The shared resource e.g. the processor is in use during the entire third and fourth epochs and . Accordingly there are no idle bars on the idle lifeline in the third or fourth epochs and .

At the fifth epoch the Task e1 task executes as indicated by an eighth task execution bar having a header . A message is generated during execution of the Task e1 task as indicated by a seventh arrow having a data box . Following the execution of the Task e1 task the Task e2 task executes as indicated by a ninth task execution bar having a header portion and a ready to execute portion

Because the fifth epoch represents the last simulation step of the simulation time there is no message generated by the sender block during the fifth epoch and thus no message arrow appears in the diagram .

Following the execution of the Task e2 task the Task e3 task executes as indicated by a tenth task execution bar having a header portion and a ready to execute portion . During execution of the Task e3 task during the fifth epoch the message represented by the arrows and are received and consumed. At the completion of the Task e3 task the shared resource again becomes idle before the end of the epoch as indicated by a third idle bar on the idle lifeline .

Referring to as described above the receiver block was configured to execute at each simulation step where the sample time was a whole number e.g. 0 1 2 3 etc.

Suppose the receiver block of the model is modified so that it now executes when there is a message available on its input queue qIn . That is suppose the receiver block is re configured as a message triggered block. The model compiler may generate execution instructions for the model and the dynamic scheduler may schedule the execution of the re configured receiver block . Suppose the model compiler implements two tasks for executing the sender receiver and sink blocks . Specifically the model compiler may implement an aperiodic task called Task qIn that executes the receiver block and a periodic task called Task e2 that executes the sender and sink blocks . Suppose further that the model compiler assigns a higher priority to the periodic Task e2 task than to the aperiodic Task qIn task. The user may be interested in observing the interaction among the sender receiver and sink blocks .

In the first epoch the Task e2 task first executes the sender block as indicated by a first task activation bar . During execution of the sender block a message is generated as indicated by a first arrow with a data box . The Task e2 task next executes the sink block as indicated by a second task activation bar . The Task qIn task executes the receiver block as indicated by a third task activation bar . During execution of the receiver block a message is generated as indicated by a second arrow with a data box

In this example none of the sender receiver or sink blocks execute during the second epoch when the simulation time corresponds to a sample time of 1 because the receiver block is no longer configured to execute on simulation steps corresponding to whole number sample times. In an embodiment the auto diagram builder may be configured to omit from a message sequence diagram one or more epochs for a span of logical execution time during which no interaction among the selected model elements occurs. Thus the second epoch is not included in the sixth message sequence diagram .

During the third epoch the Task e2 task executes the sender block as indicated by a fourth task activation bar . Execution of the sender block includes the generation of a message as indicated by a third arrow with a data box . The message represented by the third arrow is received at the input queue qIn of the receiver block which triggers the execution of the receiver block . Accordingly the Task qIn task executes the receiver block during the third epoch as indicated by a fifth task activation bar . Execution of the receiver block includes the generation of a message as indicated by a fourth arrow with a data box

Once again because no interactions and no execution of the sender receiver or sink blocks occur during the fourth epoch it is omitted from the sixth message sequence diagram by the auto diagram builder .

In the fifth epoch the Task e2 task first executes the sender block as indicated by a sixth task activation bar and sends a message to the receiver block as indicated by a fifth arrow with a data box . The Task e2 task next executes the sink block as indicated by a seventh task activation bar . During execution of the sink block the messages represented by arrows and are received and consumed by the sink block .

Because a message is available at the receiver block s input queue qIn as indicated by the fifth arrow the Task qIn task executes the receiver block during the fifth epoch as indicated by an eighth task activation bar . Execution of the receiver block includes the generation of a message as indicated by a sixth arrow having a data box . Because the message represented by the sixth arrow has been sent and received but not yet consumed the auto diagram builder gives the sixth arrow an appearance that represents the message s status e.g. a dashed as opposed to a solid line.

Suppose the priorities of the aperiodic Task qIn task and the periodic Task e2 task are switched so that the aperiodic Task qIn task has the higher priority. Suppose also that the user requests a task centric message sequence diagram rather than a model element centric diagram.

The model execution analyzer may examine the execution instructions generated for the model and the auto diagram builder may create a task centric message sequence diagram.

Here the auto diagram builder provides two lifelines for the periodic Task e2 task. A first lifeline represents the periodic task s execution of the sender block while a second lifeline represents the periodic task s execution of the sink block . A third lifeline represents the aperiodic Task qIn task. The first and second lifelines may share a header and the third lifeline may include a header . In addition an overall domain header may be included in the diagram that provides the name e.g. PollingSystemTriggerDomain of the domain of the tasks represented by the lifelines and .

During the first epoch the periodic Task e2 task first executes the sender block as indicated by a first task execution bar . Even though the aperiodic task Task qIn has a higher priority it does not execute because the trigger i.e. the availability of a message on the receiver block s input queue qIn is not satisfied. Execution of the sender block includes the generation of a message as indicated by a first arrow having a data box . The message is received at the receiver block s input queue qIn which triggers the execution of the receiver block by the Task qIn task as indicated by a second task execution bar . The execution of the receiver block includes the generation of a message as indicated by a second arrow with a data box . The Task e2 task then executes the sink block as indicated by a third task execution bar .

In an embodiment the auto diagram builder may be configured to use one or more graphical affordances to illustrate when a given task is blocked e.g. by the execution of another task. Exemplary graphical affordances include color shading a fill pattern etc. In an embodiment the auto diagram builder uses a cross hatch fill pattern on the task execution bar to indicate a task that is currently blocked. The first task execution bar for example may include a blocked portion . Similarly the third execution bar may include a blocked portion . The blocked portions illustrate that the Task e2 task is blocked from executing by the execution of the higher priority task the Task qIn task. The blocked portions end at the completion of the Task qIn task at which logical execution time the execution of the Task e2 task resumes with the execution of the sink block . It should be understood that the diagram may include just a single blocked portion i.e. or . A task may be blocked because data is not available or because another task has a lock on the location from where data is to be read or written. A task of lower priority may hold the lock but because it may be preempted by another higher priority task that does not hold the lock the lower priority task can never complete and relinquish the lock.

In an embodiment the auto diagram builder may be further configured to use one or more graphical affordances to indicate which task has a lock on a shared resource such as a memory location a queue etc. For example a color coding scheme where red represents a highest priority blue represents a lowest priority and other colors are used to represent other priorities may be used. In this way a message sequence diagram may indicate whether a task having a high priority fails to perform some operation such as a write because a low priority task with a lock on the target of the write is preempted from completing its operation by the high priority task.

At the third epoch again the second epoch is omitted the Task e2 task executes the sender block as indicated by a fourth task execution bar . A message is generated by the Task e2 task executing the sender block as indicated by a third arrow with a data box . Receipt of the message triggers execution of the receiver block by the Task qIn task as represented by the fifth task execution bar . Execution of the receiver block includes the generation of a message as indicated by a fourth arrow with a data box . As shown no blocking occurs during the third epoch .

During the fifth epoch the Task e2 task executes the sender block as indicated by a sixth execution bar . Execution of the sender block includes the generation of a message that is received at the receiver block s input queue qIn as indicated by a fourth arrow with a data box . The availability of the message at the receiver block triggers its execution by the Task qIn task as indicated by a seventh task execution bar . Execution of the receiver block includes the generation of a message as indicated by a fifth arrow with a data box

When the Task qIn task completes the execution of the receiver block the Task e2 task may resume with execution of the sink block as indicated by an eighth task execution bar . During execution of the sink block the messages represented by the fourth and sixth arrows are received and processed. The sixth task execution bar which represents execution of the sender block and the eighth task execution bar each include a blocking portion respectively. The blocking portions indicate that execution of the Task e2 task is blocked by the execution of the higher priority Task qIn task.

With reference to the model of suppose the receiver block is configured to issue a function call to the sender block where the function call includes one or more input arguments. The sender block performs the function and returns one or more output arguments to the receiver block . The receiver block then generates a message with the one or more output arguments returned by the sender block . The message is received at the sink block which displays the received value on a console. Suppose the receiver block is configured to execute periodically e.g. at each simulation step where the sample time is a whole number e.g. 0 2 4 etc. Suppose further that the sink block is also configured to execute periodically e.g. at each simulation step where the sample time is a multiple of four e.g. 0 4 8 etc.

The model compiler may implement two periodic tasks for executing the receiver and sink blocks and a separate event driven task for executing the sender block .

The user may be interested in observing a visual of the interaction among the sender receiver and sink blocks .

During the third epoch which corresponds to a simulation step where the sample time is 2 the Task e2 task executes the receiver block as indicated by a first task activation bar . In this example execution of the receiver block involves issuing a function call to the sender block . The auto diagram builder may use one or more graphical affordances to represent the function call. In an embodiment the auto diagram builder may represent a function call with a solid line arrow where the tail of the arrow is located at the lifeline of the block issuing the function call and the head of the arrow is located at the lifeline of the block being called.

A first arrow represents the function call by the receiver block to the sender block . The first arrow may include a data box that includes information about the function such as the function s name e.g. Fn1 and the one or more input arguments with which the function is being called e.g. 1 .

Receipt of the function call by the sender block triggers execution of the sender block as indicated by a second task activation bar . In this example the sender block is executed by the callIn task which is different from the e2 task that executes the receiver block . The callIn task executes the sender block which involves executing the called function i.e. Fn1 with the input argument s i.e. 1. The auto diagram builder may use one or more graphical affordances to illustrate the function reply from the called function to the caller function. In an embodiment the auto diagram builder may use a dashed line arrow whose tail is located at the lifeline of the called function and whose head is located at the caller function. A second arrow represents the function reply from the sender block to the receiver block . The second arrow may include a data box that includes information about the called function such as the function s name e.g. Fn1 and the return or output argument e.g. 2. By way of example the notation of the MATLAB programming language is used e.g. 2 Fn1 1 .

The Task e2 task then resumes execution of the receiver block as indicated by a resumed portion of the first task activation bar . The gap appearing between the initial portion of the first task activation bar and the resumed portion indicates that the Task e2 task was blocked by execution of the Task callIn task illustrated by the second task activation bar . That is the function call to the sender block is a blocking function call. With the resumption of the execution of the receiver block a message is generated as indicated by a third arrow having a data box . The head of the third arrow joins the lifeline for the sink s input queue sIn and a first queue depth element at the lifeline includes a first portion which indicates that the sink s input queue sIn now contains one message.

During the fifth epoch the Task e2 task commences execution of the receiver block as indicated by a third task activation element . A fourth arrow indicates a function call by the receiver block to the sender block . The fourth arrow includes a data box that includes the name of the function and the input argument i.e. Fn1 2 . The receipt of the function call triggers the execution of the sender block . In particular the Task callIn task executes the sender block as indicated by a fourth task activation element which includes execution of the called function. This includes sending a function reply to the receiver block as indicated by a fourth arrow with a data box that includes the output arguments e.g. 3 Fn1 . Execution of the receiver block is then resumed by the Task e2 task as indicated by the resumed portion of the third task activation bar . Again the gap appearing between the initial portion of the third task activation bar and the resumed portion indicates that the Task e2 task was blocked during execution of the sender block by the Task callIn task which has a higher priority than the Task e2 task. Resumed execution of the receiver block includes the generation of a message as indicated by sixth arrow with a data box . The head of the sixth arrow is located at the lifeline for the sink s input queue sIn and a second portion of the queue depth bar which is wider than the first portion indicates that the queue now contains two messages.

The Task e1 task executes the sink block during the fifth epoch as indicated by a fifth task activation element . The sink block consumes the messages in its input queue sIn as indicated by seventh and eighth arrows and with data boxes and . After the first message is consumed a third portion of the queue depth bar which is narrower than the second portion indicates that the queue only contains a single message. After the last message in the input queue sIn is consumed as indicated by the eighth arrow the queue depth bar terminates.

Suppose that the sender block in addition to being called by the receiver block to perform the Fn1 function is configured to delay responding to the receiver block e.g. by one second. The model compiler may be configured to define two tasks for executing the sender receiver and sink blocks . The sender block may be executed by an aperiodic task while the receiver and sink blocks may be executed by a periodic task. Again the user may want to observe the interactions among the sender receiver and sink blocks in this scenario.

During the third epoch which corresponds to a simulation step where the sample time is 2 the PollingSystem Periodic Task task executes the receiver block as indicated by a first task activation bar . A first arrow with a data box indicates a function call by the receiver block to the sender block . Receipt of the function call by the sender block triggers execution of the sender block by the PollingSystem Aperiodic Task task as indicated by a second task activation bar which represents execution of the function call. In this example however the function reply is not sent during the third epoch . Instead the PollingSystem Aperiodic Task task executes the delay portion of the sender block during the fourth epoch as indicated by a third task activation bar . At the end of the delay the function reply is issued as indicated by a second arrow with a data box . The PollingSystem Periodic Task task continues execution of the receiver block during the fourth epoch as indicated by a resumed portion of the first task activation bar . The gap appearing between the initial portion of the first task activation bar and the resumed portion indicates that the PollingSystem Periodic Task task was blocked due to the PollingSystem Aperiodic Task task s execution of the sender block as illustrated by the second and third activation bars . That is the function call to the sender block is a synchronous function call. With the resumption of the execution of the receiver block a message is generated as indicated by a third arrow having a data box . The head of the third arrow joins the lifeline for the sink s input queue sIn and a queue depth element at the lifeline includes a first portion which indicates that the sink s input queue sIn now contains one message.

During the fifth epoch the PollingSystem Periodic Task task commences execution of the receiver block as indicated by a fifth task activation bar . A fourth arrow having a data box represents a second function call by the receiver block to the sender block . Once again receipt of the function call triggers the execution of the sender block by the PollingSystem Aperiodic Task task during the fifth epoch as indicated by a fifth task activation bar . Nonetheless the function reply is not sent during the fifth epoch . Instead the reply is sent during a sixth epoch which corresponds to a simulation step where the sample time is 5. In particular the PollingSystem Aperiodic Task task performs the delay portion of the sender block as indicated by a sixth task activation bar which occurs during the sixth epoch .

The function reply is sent to the receiver block during the sixth epoch as indicated by a fifth arrow with a data box . Execution of the receiver block is then resumed by the PollingSystem Periodic Task task as indicated by the resumed portion of the third task activation bar . Again the gap appearing between the initial portion of the third task activation bar and the resumed portion indicates that the PollingSystem Periodic Task task was blocked during execution of the sender block by the PollingSystem Aperiodic Task task which has a higher priority. Resumed execution of the receiver block includes the generation of a message during the sixth epoch as indicated by a sixth arrow with a data box . The head of the sixth arrow is located at the lifeline for the sink s input queue sIn and a second portion of the queue depth bar which is wider than the first portion indicates that the queue now contains two messages.

The PollingSystem Periodic Task task executes the sink block during the sixth epoch as indicated by a seventh task activation bar . The sink block consumes the messages in its input queue sIn as indicated by seventh and eighth arrows and with data boxes and . After the first message is consumed a third portion of the queue depth element which is narrower than the second portion indicates that the queue only contains a single message. After the last message in the input queue sIn is consumed as indicated by the eighth arrow the queue depth element terminates thereby indicating there are no more messages in the sink block s input queue sIn .

As noted the sink block is configured so as to execute on a periodic basis. Specifically it should execute during the simulation steps when the sample time is a multiple of four e.g. 0 4 8 12 etc. Thus the sink block should have executed during the fifth epoch which corresponds to a sample time of 4. However as shown in the eighth message sequence diagram the sink block did not execute until the sixth epoch which corresponds to a sample time of 5. The execution of the sink block was thus late. The auto diagram builder may be configured to represent the late execution of a selected model element using one or more graphical affordances. For example the auto diagram builder may use a striped block arrow that points to where the model element should have executed. Accordingly the auto diagram builder may include a late execution arrow in the eighth message sequence diagram . The late execution arrow may be disposed on or adjacent to the lifeline of the model element whose execution was delayed. In this case the late execution arrow may be disposed on the sink s lifeline . In addition the late execution arrow may have a tail that is positioned at the task activation bar whose execution ran late and a head that points to the location at which the task should have occurred e.g. during the fifth epoch .

The model execution analyzer may be configured to identify repeating patterns of interactions or executions of the selected elements during the execution of a model. In addition the auto diagram builder may be configured to represent these repeating patterns in a message sequence diagram.

For example suppose the model is configured to execute over a logical execution time of 1 to 40 seconds. Suppose further that the model execution analyzer identifies one or more repeating patterns of interaction among the selected elements e.g. the sender receiver and sink blocks . The auto diagram builder may present the one or more repeating patterns in a message sequence diagram.

During each of the logical execution times represented by the first section the receiver block sends a message to the sink block with a payload and the message is received in the same logical execution time as represented by a second arrow with a data box in the first section . Because the value of the message payload changes the auto diagram builder may be configured to represent the payload of the message with a variable such as s2 . Also during each of the logical execution times represented by the first section the sender block sends a message to the receiver block with a payload and the message is received in the next logical execution time as indicated by a third arrow with a data box where the payload of the message is represented by a variable s1 . During each of the logical execution times represented by the second section the receiver block receives the message generated by the sender block in the previous logical execution time. The receiver block also generates a message with a payload that is received by the sink block as indicated by a fourth arrow with a data box where the payload of the message is represented by a variable s3 .

The diagram may include a second epoch that corresponds to a logical execution time of 20 seconds as indicated by a label . During the second epoch the sender block generates a message with a payload of 1 and the message is received by the receiver block as indicated by a fifth arrow with a data box

The auto diagram builder may include a second repeating pattern window . The second window includes a first section and a second section . The second repeating pattern window corresponds to the logical execution times from 21 to 40 seconds. The first section corresponds to the logical execution times 21 23 25 27 etc. up to 39 as indicated by a label element and the second section corresponds to the logical execution times 22 24 26 etc. up to 40 as indicated by a label element .

During each of the logical execution times represented by the first section of the second repeating pattern window the receiver block sends a message to the sink block with a payload and the message is received in the same logical execution time as represented by a sixth arrow with a data box in the first section . Also during each of the logical execution times represented by the first section the sender block sends a message to the receiver block with a payload and the message is received in the next logical execution time as indicated by a seventh arrow with a data box . During each of the logical execution times represented by the second section the receiver block receives the message generated by the sender block in the previous logical execution time. The receiver block also generates a message with a payload that is received by the sink block as indicated by an eighth arrow with a data box

The auto diagram builder may be configured to provide one or more graphical affordances that indicate the values of the variables used in the message sequence diagram . For example the auto diagram builder may include a variable element in the diagram . The variable element may include a header that contains information about the variable such as its name i.e. s1 a trace that indicates the value of the variable over the execution time and a scale for the trace . The trace may be vertically arranged and may be aligned with the epochs and the repeating pattern windows of the diagram to provide an indication of the value of the variable at the logical execution times represented by the epochs and the repeating pattern windows . For example the variable element indicates that the value of the s1 variable during the first epoch is zero. During the first repeating pattern window when the logical execution times goes from 2 to 19 the value of s1 increases from zero to 18. During the second epoch s1 has no value because the set s1 does not exist in the second epoch . During the second repeating pattern window the value of s1 increases from 21 to 39. In an embodiment the values of the variable s1 as presented in the trace may not be discretized across the repeating pattern windows and . Instead the trace may indicate a change in value of the variable s1 from a beginning value e.g. 0 to an ending value e.g. 19 as illustrated with reference to the first repeating pattern window . The user interface engine may be configured to illustrate the change in value of the variable s1 in the trace in a linear manner or alternatively in other ways e.g. as one or more steps.

The auto diagram builder also may include a signal trace element that represents the value of the counter signal of the counter block in the diagram . The signal trace element may include a header with information about the counter signal such as its name i.e. counter a trace of the value of the counter signal and a scale .

In an embodiment repeating patterns may be identified by a user to the diagramming tool using a language that contains constructs for defining sequence choice iteration etc. For example the patterns of may be described as 

In natural language this code snippet may mean match any number of a sequence of messages containing first a message from receiver to sink then a message from sender to receiver and finally a message from receiver to sink . The respective payloads are returned in collections s1 s2 and s3. These patterns may be entered by the user before any given simulation of the model. The diagramming tool may also have a default set of patterns that it matches. The extent of the semantics of the language and particularly the extent to which it can be parameterized may govern the patterns that can be described by the user.

By examining the diagram a user may identify anomalies in the execution of the program . For example the user may expect to see a single repeating patter window for the entire logical execution time. Accordingly when the user observes the presence of two repeating pattern windows and two individual epochs the user may realize that the program is not executing as intended and may make edits or changes to the program.

In an embodiment the model execution analyzer may be configured to determine from a model s execution schedule when particular methods or functions execute during one or more epochs. In addition the diagramming tool may be configured to use one or more graphical affordances in a message sequence diagram to indicate when the methods execute during the one or more epochs. Suppose for example that a model includes a sender block that is connected to a receiver block which in turn is connected to a sink block. Suppose further that the receiver block executes at a higher rate than the sender and the sink blocks. In this case rate transition blocks may be added between the sender and receiver blocks and between the receiver and sink blocks to manage these different execute rates of the blocks. Suppose further that at least some blocks of a model have a plurality of methods that are executed during execution of the model. In the Simulink modeling environment from The MathWorks Inc. there are block output methods and block update methods that are evaluated e.g. executed during the execution of the model. The output method for a given block computes the block s outputs based upon the block s inputs at the current time step and the block s states as determined at the previous time step. The update method for a given block computes the values of the block s states e.g. discrete states at the current time step based on the block s inputs and current time step and the block s states e.g. discrete states at the previous time step. It should be understood that additional and or other methods may be defined such as a derivatives method which computes the derivatives of the block s continuous states at the current time step based on the block s inputs and the values of the block s states at the previous time step.

In some embodiments a block or other graphical object of a model may have multiple outputs. For example there may be one output method per output port of a block one output method per output port that has a direct relation with an input port etc. The different output methods may be determined based on the block s context within the model in which the block is used e.g. how the block s input and output ports are connected to other blocks ports of the model.

During the second epoch the first rate transition block executes its output method as indicated by bar element on the second lifeline . Execution of the first rate transition block s output method involves sending a message from the first rate transition block to the receiver block as indicated by the arrow . The output and update methods of the receiver block then execute as indicted by the bar elements and . Execution of the receiver block s output method involves sending a message to the second rate transition block as indicated by the arrow . Execution of the receiver block s output and update methods is followed by the execution of the second rate transition block s output method as indicated by the bar element on the fourth lifeline . Execution of the second rate transition block s output method involves sending a message to the sink block as indicated by the arrow .

In an embodiment the message sequence diagram may be user editable and or support user interaction. Suppose for example that upon reviewing the message sequence diagram the user would like to change the order of occurrence of one or more of the methods within a given epoch or even from one epoch to another. The user may select the one or more methods and move it along its lifeline to a desired location such as with a drag and drop or other GUI based operation. The desired location may be in relation to the occurrence of other methods by the same or by different blocks e.g. before or after a particular method executes. For example suppose that the user decides that the update method of the first rate transition block during the first epoch as indicated by the bar element should occur immediately after the first rate transition block s output method as indicated by the bar element . The user may manipulate the message sequence diagram to move the bar element along the second lifeline to the desired location as indicated by dashed arrow and dashed bar element . A user may similarly move a bar element representing the execution of a particular method from one epoch to another epoch.

The user interface engine may be configured to detect such edits to the message sequence diagram . The diagramming tool may be configured to instruct the simulation engine to modify the model s execution schedule to reflect the new schedule as presented on the revised version of the message sequence diagram . The model execution analyzer may be configured to determine whether such a change to the model s execution schedule may affect the results computed by the model during execution. For example the model execution analyzer may be configured to permit a user to move update methods anywhere within a message sequence diagram but before the output method of the same block. The user interface engine may be configured to disallow such actions by for example snapping back the bar element to a permitted location or position in the message sequence diagram. The model execution analyzer may further be configured to disallow moving a method before an arrow that indicates a write to the method. For example arrow may communicate data to update method represented by bar element and so moving the bar element before the arrow on the life line may be disallowed by the model execution analyzer . If the user tries to perform such a move the user interface engine may be configured to present a warning or an indication that such a move may change the execution results of the model. Similarly moving output methods may be permitted provided that the output methods are not moved to a new location that is before an arrow that writes data that the output method uses as input. For example while it may be permitted to move bar element after execution of bar element but still before execution of bar element if the execution of bar element is moved to a position or location before the execution of bar element the model execution analyzer may determine that such a change may cause the model to compute a different result and the change may be disallowed and or a warning presented.

In an embodiment the model execution analyzer may be configured to evaluate a dependency graph which may be created by the IR builder from the model. The dependency graph may represent a partial execution order of the blocks and thus of the blocks methods. If an attempt is made to move the execution of an output method such that the resulting overall list of methods remains consistent with the partial execution order the results computed by the model may not change and such an interaction may be permitted by the model execution analyzer .

It should be understood that the message sequence diagram of is meant for illustrative purposes and the invention may be used in other environments. For example one or more blocks may have multiple output and or update methods in a given epoch.

Suppose that the model illustrated in the message sequence diagram of is executed on one or more multi core processing units and the block methods are assigned for execution on the different cores e.g. by the simulation engine . The model execution analyzer may be configured to determine from a model s execution schedule the particular processing cores on which the methods or functions associated with the blocks execute during one or more epochs. In addition the diagramming tool may be configured to use one or more graphical affordances in a message sequence diagram to indicate which core executes the methods or functions during the one or more epochs.

During the second epoch the first rate transition block executes its output method as indicated by bar element which involves sending a message as indicated by arrow from the first rate transition block to the receiver block. The output and update methods of the receiver block then execute as indicted by the bar elements and and execution of the receiver block s output method involves sending a message as indicated by arrow to the second rate transition block. Execution of the receiver block s output method occurs during the execution of the second rate transition block s output method as indicated by the bar element and execution of the second rate transition block s output method involves sending a message as indicated by the arrow to the sink block.

The user interface may be configured to use one or more graphical affordances in the message sequence diagram to indicate which processing core executes the respective method. In an embodiment the graphical affordance may be a fill effect on the bar elements. For example a first fill effect such as a shaded fill may represent a first processing core while a second fill effect such as be dashed lines may represent a second processing core.

In the first epoch the output method of the sender block and the output and update methods of the receiver block are executed on a first processing core as indicated by the dashed fill pattern in bar elements and . The output and update methods of the first rate transition block the output method of the second rate transition block and the output method of the sink block are executed on a second processing core as indicated by the solid fill pattern in bar elements and . In the second epoch the output methods of the first and second rate transition blocks are executed on the first processing core as indicated by the dashed fill pattern of bar elements and . The output and update methods of the receiver block are executed on the second processing core as indicated by the solid fill pattern of bar elements and .

In an embodiment the message sequence diagram may be user editable. Suppose for example that upon reviewing the message sequence diagram the user would like to change the processing core one which one or more of the methods executes. The user may select the one or more methods and change its graphical affordance e.g. the fill pattern of its respective bar element to the graphical affordance corresponding to the desired processing core. One or more edit or other GUI based operations may be used to change the graphical affordance. For example suppose that the user decides that the output method of the sink block during the first epoch as indicated by the bar element should be executed on the first processing core rather than on the second processing core as determined by the simulation engine and as reflected in the message sequence diagram . The user may manipulate the message sequence diagram to alter the graphical affordance associated with the bar element . For example the user may change the fill pattern for the bar element from a solid fill pattern to a dashed fill pattern as indicated by dashed arrow and dashed bar element .

In an embodiment the model execution analyzer may be configured to perform a check to determine whether all methods that are assigned to a given core are mutually exclusive in that the user is not attempting to assign two methods that execute at the same time to the same core. If the model execution analyzer detects such a condition it may be reported to the user e.g. by the user interface engine and an error may occur. Alternatively the user assignment may be changed to an assignment in which all methods executing on one core are mutually exclusive in their execution time. In an embodiment the model execution analyzer may be configured to use the dependency graph created by the IR builder to search for and find an order of execution that would be mutually exclusive based on the user assignment but where the order of the methods executing may change from the original message sequence diagram. The user interface engine may be configured to detect such edits to the message sequence diagram . The diagramming tool may be configured to instruct the simulation engine to modify the model s execution schedule to reflect the new assignment of block methods to processing cores as presented on the revised version of the message sequence diagram .

In an embodiment one or more task centric message sequence diagrams may be edited e.g. by a user to alter the execution schedule of the model. Referring to the message sequence diagram the sender and receiver and blocks execute during the third epoch as indicated by the fifth and sixth task activation bars . Execution of the receiver block includes generation of a message as indicated by a fourth arrow with a data box indicating that the message carries a value of 1 because the receiver block has not received a new value from the sender block since the second epoch . Suppose the user would like to have the receiver block issue an updated value during the third epoch . In this case the user may select the sixth task activation bar for the sender block and drag it into the second epoch and the message represented by the arrow with the new value 1 would be received by the receiver block in the third epoch . As a result the receiver block would send a message with a value of 1 during the third epoch instead of a value of 1 . The diagramming tool may notify the simulation engine of the change made to the message sequence diagram and the simulation engine may modify the model s execution schedule to conform to the revised message sequence diagram. For example the simulation engine may change the rate of execution of the task executing the sender block Task e2 . Alternatively the simulation engine may change the event offset e.g. the offset for event e2 which triggers task Task e2 or task priority to achieve the desired effect of the revised message sequence diagram.

The message sequence diagram may extend across a plurality e.g. six epochs and . During each of the first to third epochs the receiver and sink blocks execute as indicated by respective bar elements . Execution of the receiver block includes the generation of a message that is received by the sink block as indicated by arrows having respective data boxes. As indicated by the values in the data boxes the receiver block sends a value of 1.

During the fourth epoch the sender block and its transmit function execute as indicated by bar elements and . Execution of the sender block includes the generation of a message received by the sender s transmit block during the fifth epoch as indicated by arrow with a data value of 0 as indicated by data box . The receiver and sink blocks also execute as indicated by bar elements and and the receiver block transmits a message with a value of 1 to the sink block as indicated by arrow with data box . During the fifth epoch the transmit function of the sender block and the receive function of the receive block execute as indicated by bar elements and . The transmit functions sends a message that is received by the receive function of the receiver block as indicated by arrow with data box . The message is received by the receive function during the six epoch . The receiver and sink blocks also execute as indicated by bar elements and and arrow with data box . As the message from the sender block is not received by the receiver block until the sixth epoch however as indicated by arrow during the fifth epoch the receiver block sends a value of 1 to the sink block as indicated by arrow and data box

During the sixth epoch the receiver s block receive function executes as indicated by bar element . The receiver and sink blocks also execute as indicated by bar elements and . Execution of the receiver block includes sending a message to the sink block with a value of 0 as indicated by arrow and data box

A user upon evaluating the automatically generated dynamic message sequence diagram may realize that the message sent by sender block including its transmit function although begun during the fourth epoch does not reach the receiver block until the sixth epoch as indicated by arrows and . Accordingly during the fourth epoch the receiver block sends a value of 1 to the sink block as indicated by the arrow . The user may have intended that the value of 0 be sent to the sink block during the fourth epoch .

In an embodiment the user may interact with the message sequence diagram to alter the execution of the model and achieve the desired operation i.e. the transmission of the value 0 from the receiver block to the sink block during the fourth epoch . The user may interact with the message sequence diagram to advance the execution of the sender block and its transmit function to an earlier epoch to achieve the desired operation.

As a result of this user initiated change to the message sequence diagram the simulation engine may determine a new execution schedule for the model. The diagramming tool may present this new execution schedule in the message sequence diagram . Specifically with the task2 that executes the sender block modified to begin execution during the second epoch the sender block s transmit function begins execution during the second epoch and the receiver block s receive function begins its execution during the third epoch . As a result the receiver block receives a message with a value of 0 during the fourth epoch rather than during the sixth epoch as indicated in . Additionally the receiver block sends a message with a value of 0 to the sink block during the fourth epoch as indicated by arrow and data box . As noted this is the behavior that the user desired for the model.

In an embodiment the diagramming tool may be configured to include one or more graphical affordances on a message sequence diagram to indicate logical and or physical execution time.

During the second epoch the first rate transition block executes its output method as indicated by bar element which involves sending a message as indicated by arrow from the first rate transition block to the receiver block. The output and update methods of the receiver block then execute as indicted by the bar elements and and execution of the receiver block s output method involves sending a message as indicated by arrow to the second rate transition block. Execution of the receiver block s output and update methods is followed by the execution of the second rate transition block s output method as indicated by the bar element and execution of the second rate transition block s output method involves sending a message as indicated by the arrow to the sink block.

During the third epoch the first rate transition block executes its output method as indicated by bar element which involves sending a message as indicated by arrow . The output methods of the sender and receiver blocks then execute as indicated by bar elements and which involve sending messages as indicated by arrows and . The update of the receiver block then executes as indicated by bar element . Next the output method of the second rate transition block executes as indicated by bar element which involves sending a message as indicated by arrow . Then the update and output methods of the first rate transition block and the sink block execute as indicated by bar elements and .

The diagramming tool may be configured to determine when epochs occur in terms of logical execution time and to present this information in a message sequence diagram. In an embodiment the diagramming tool may include a logical execution time element for each epoch for example at the end of each epoch and or at the boundary between adjacent epochs. The logical execution time elements may be configured with the logical execution time e.g. in milliseconds ms for the respective epoch. The logical execution time elements may be located at the graphical affordances that separate adjacent epochs e.g. the horizontally arranged dashed lines. With reference to a first logical execution time element indicates that the first epoch ends after 10 ms logical execution time. A second logical execution time element indicates that the second epoch ends after 20 ms logical execution time and a third logical execution time element indicates that the third epoch ends after 30 ms logical execution time. That is each epoch and takes 10 ms to complete.

By examining the bar elements within the epochs and a user may better understand how often or frequent different blocks execute. In particular the receiver s output and update methods run every epoch and while the sender s and sink s methods run every other epoch e.g. the first and third epochs and . Accordingly the message sequence diagram shows that the sender and receiver blocks execute every 20 ms while the receive block executes every 10 ms.

In addition or alternatively to providing an indication of logical execution time the diagramming tool may be configured to determine when blocks and or methods execute in terms of physical time and present this information in a message sequence diagram. For example the modeling environment may include a hardware simulation tool that may simulate execution of a model on target hardware. The hardware simulation tool may as part of the simulation process determine the time it takes to execute the model on the target hardware. The diagramming tool may obtain this information and include it on a message sequence diagram.

With reference to the user interface engine may add one or more graphical affordances to the message sequence diagram that represent the passage of physical execution time for the model. Specifically the user interface engine may include one or more physical time markers such as first and second markers and placed on the message sequence diagram in locations that correspond to the respective physical execution times. Each marker and may include a timestamp box and and a line element and . Presented in the timestamp boxes and may be a numeric value of the respective physical execution time e.g. 7 ms and 12 ms. The line elements and may extend horizontally across the message sequence diagram to help the user visually align the occurrence of block and or method executions with respect to physical execution time. As illustrated after 7 ms of physical execution time about half of the methods of the first epoch are run. After 12 ms of physical execution time the second epoch is nearly complete. In an embodiment the markers and may be interactive such that a user may slide the markers and up and down along the diagram and the corresponding physical execution time may be shown.

The main memory which may be a Random Access Memory RAM may store a plurality of program libraries or modules such as an operating system and one or more application programs that interface to the operating system such as the modeling environment .

The removable medium drive may accept and read a computer readable medium such as a CD DVD floppy disk solid state drive tape flash memory or other non transitory medium. The removable medium drive may also write to the computer readable medium .

Suitable computer systems include personal computers PCs workstations servers laptops tablets palm computers smart phones electronic readers and other portable computing devices etc. Nonetheless those skilled in the art will understand that the computer system of is intended for illustrative purposes only and that the present invention may be used with other computer systems data processing systems or computational devices. The present invention may also be used in a networked e.g. client server computer architecture or a public and or private cloud computing arrangement. For example the modeling environment application may be hosted on a server and accessed by a remote client through an application hosting system such as the Remote Desktop Connection tool from Microsoft Corp.

Suitable operating systems include the Windows series of operating systems from Microsoft Corp. of Redmond Wash. the Android and Chrome OS operating systems from Google Inc. of Mountain View Calif. the Linux operating system the MAC OS series of operating systems from Apple Inc. of Cupertino Calif. and the UNIX series of operating systems among others. The operating system may provide services or functions for other modules such as allocating memory organizing data according to a file system prioritizing requests etc. The operating system may run on a virtual machine which may be provided by the data processing system .

As indicated above a user or developer such as an engineer scientist programmer etc. may utilize one or more input devices such as the keyboard the mouse and the display to operate the modeling environment and construct one or more graphical skeleton components and or one or more models that include one or more graphical skeleton components. As discussed the graphical models may be computational and may have executable semantics. In particular the models may be executable. In particular the model may provide one or more of time based event based state based frequency based control flow based and dataflow based execution semantics. The execution of a model may simulate operation of the system that is being designed or evaluated. The term graphical model moreover is intended to include graphical program.

The foregoing description of embodiments is intended to provide illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example while a series of acts has been described above with respect to the order of the acts may be modified in other implementations. Further non dependent acts may be performed in parallel.

In addition while particular examples of graphical affordances have been described and shown it should be understood that other graphical affordances may be used. For example other connectors such as lines boxes bars etc. may be used instead of or in addition to the arrows. Similarly other icons or widgets may be used. In addition various combinations of features may be combined in one or more of the message sequence diagrams of the invention.

Also the term user as used herein is intended to be broadly interpreted to include for example a computing device e.g. a workstation or a user of a computing device unless otherwise stated.

It will be apparent that one or more embodiments described herein may be implemented in many different forms of software and hardware. Software code and or specialized hardware used to implement embodiments described herein is not limiting of the invention. Thus the operation and behavior of embodiments were described without reference to the specific software code and or specialized hardware it being understood that one would be able to design software and or hardware to implement the embodiments based on the description herein.

Further certain embodiments of the invention may be implemented as logic that performs one or more functions. This logic may be hardware based software based or a combination of hardware based and software based. The logic may be stored in one or more tangible computer readable storage media and may include computer executable instructions that may be executed by processing logic such as processing logic . The computer executable instructions may include instructions that implement one or more embodiments of the invention. The tangible computer readable storage media may be volatile or non volatile and may include for example flash memories dynamic memories removable disks and non removable disks.

No element act or instruction used herein should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

