---

title: Metadata cache supporting multiple heterogeneous systems
abstract: A request for a metadata object is received where the request includes an identifier. It is determined whether the metadata object is stored in a metadata cache, including by: selecting a sub-cache in the metadata cache based at least in part on the identifier and determining whether the metadata object is stored in that sub-cache. If it is determined the metadata object is not in the metadata cache, a request (in a format associated with the source) to obtain the metadata object is sent to a source with which the metadata object is associated. If the metadata object provided by the source is in a native format which is not the same as the common format, the metadata object is transformed from the native format into the common format. Access to the metadata object in the common format is provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477695&OS=09477695&RS=09477695
owner: EMC Corporation
number: 09477695
owner_city: Hopkinton
owner_country: US
publication_date: 20140206
---
This application is a continuation of co pending U.S. patent application Ser. No. 13 334 853 entitled METADATA CACHE SUPPORTING MULTIPLE HETEROGENEOUS SYSTEMS filed Dec. 22 2011 which is incorporated herein by reference for all purposes.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

A metadata cache which stores metadata associated with one or more data management systems is described. The associated data management systems may be of the same type e.g. a homogenous environment or may include a variety of system types e.g. a heterogeneous environment . In various embodiments metadata may be transformed or mapped from how it is stored and represented natively e.g. on a source data management system or in a source file into a format or framework that is common to multiple forms used to represent and describe metadata. For example some systems are relational databases whereas others are not some have a framework for or the concept of user defined schemes data structures and or functions whereas others do not. Metadata in various frameworks and formats such as those are transformed or mapped to the common format. In some embodiments the common format is one employed by one of the data management systems. In some other embodiments the common format is not used by any of the data management systems. If some requested metadata is not stored in the cache then that metadata is retrieved transformed as needed e.g. by an associated metadata provider configured to communicate with that particular type of data management system to the common format. One benefit of such a system is a performance improvement. For those pieces of metadata in the cache i.e. a hit metadata is more readily accessible than for example having to retrieve it from a remote device via a network. Another benefit is that functions which use the metadata stored in the cache can be decoupled from the specific implementations of the various data management systems. For example if the metadata stored in the cache is used by a planner to optimize a query then the planner can be implemented using the common metadata format and not be tightly coupled to one specific implementation.

Metadata in general is information about data. Some examples of metadata associated with a data management system include characteristics structures or properties of the data stored in and or managed by a data management system. Metadata may be about the sources of data in a data management system e.g. tables in a database files in a file system etc. . Metadata may describe types of data e.g. a string versus an integer or how data is organized or otherwise structured e.g. as arrays tables trees etc. . Metadata may be related to operations such as specifying an operand or result type. Metadata may describe relationships for example between two or more related or linked data objects e.g. a hierarchical relationship between two objects in a file system tree a dependent relationship such as between a backup copy and its corresponding original or a relationship resulting from an association applied to the data objects by an application such as various electronic medical records relating to the same patient .

In one example of data management systems the first and second data management systems and are electronic medical records systems associated with two clinic sites of a medical practice. The medical practice implemented medical records at the two sites at the same time so the same software company implemented both systems and therefore the structure and implementation of the databases and the associated metadata are the same at the two clinic sites. The third data management system may be that of an off site and or third party laboratory. Test orders and test results e.g. an order for a blood test for patient John Doe and the corresponding lab results are stored in data management system but the medical records for patient John Doe e.g. a doctor s summary of an office visit and prescribed medication resulting from the office visit are stored in the first or second data management system or .

Also connected to network are file parser and executor . Parser is configured to assemble raw queries targeting one or more of data management systems and . Planner receives a raw query from parser and optimizes the query using metadata stored in metadata cache . The optimized query is then returned to executor which executes the query against the target data management system s i.e. one or more of data management systems or . In some embodiments multiple queries are processed simultaneously. Although this example describes planner as a client of the metadata cache in various embodiments other clients may be a parser executor language binder etc.

Although the example system shown herein shows two data management systems of a first type and a single data management system of a second type any number of total systems and or number of system types may be used in combination with the techniques described herein. Some example types of data management systems e.g. and include EMC Greenplum databases Oracle databases MySQL Hadoop MapReduce file systems etc.

As an example of a query that targets a single data management system parser generates a raw query to retrieve all unbilled lab tests performed in the previous month from the laboratory e.g. data management system . Planner in that example uses metadata from metadata cache associated with data management system to optimize the query.

In an example where a query targets multiple data management systems a query is generated to flag a latex allergy for patient John Doe. To make the staff at the laboratory and the patient s home clinic aware of this allergy at least two of the data management systems are targeted by the query. As such metadata associated with those data management systems is retrieved from metadata cache and is used by planner to optimize the raw query.

In some cases two queries are simultaneously optimized by planner and the targets overlap. For example at the same time planner is optimizing the query to flag the latex allergy for patient John Doe another query is being optimized to place an order for a skin prick allergy test.

In addition to live data management systems metadata cache is configured to work with metadata stored in a file such as file . As with metadata from a data management system metadata from file is transformed as needed into the common format and stored in metadata cache .

The ability to operate on metadata stored in a file has a number of benefits. In one example scenario a data management system is configured to write state information including metadata to a file in the event of a system failure or crash. Using the resulting file debugging can be performed by accessing the metadata stored in the file via metadata cache. Debugging can also be performed without having access to the actual system. In some cases a data management system can be instructed e.g. by a system administrator to do a file write independent of a system failure for example so that a vendor can recreate a customer s system environment for system analysis and or optimization. Although the system shown in the figure describes using metadata cache to optimize queries e.g. at planner in this example the metadata accessible via metadata cache may be used for any purpose not just optimization. Another benefit to a metadata cache being able to import metadata from a file is that during development new products can be tested using a simulated environment. For example rather than using a data management system and possibly risking client information file can be used to test the performance of a new product.

Metadata providers not shown in metadata cache are responsible for retrieving metadata from a data management system and performing the transforming to a common format. The following figure describes metadata providers in further detail.

In some embodiments metadata stored in a metadata cache is read only and the metadata cache is not responsible for updating a corresponding metadata object in a source file or source data management system. For example if sub cache includes a metadata object that is being used by an executor not shown to execute an optimized query the executor is not permitted to manipulate the metadata object in sub cache and or with the expectation that any such change will be propagated to first data management system on behalf of the executor. In such embodiments any changes to a metadata object are made directly at the source e.g. at data management system or using application programming interfaces APIs or other interfaces .

Using a plug in architecture where each type of data management system has a corresponding metadata provider is attractive because the system is easily extensible. If support for a new type of data management system is desired a new metadata provider configured to communicate with the new data management system and convert the metadata objects from their native format to the common format can be built and installed. Similarly if an already supported data management system performs an update e.g. by adding new metadata objects then the corresponding metadata provider can be updated as well.

At a raw query is received including identification of one or more metadata objects associated with the raw query. For example planner in may receive a raw query to be optimized from parser . In various embodiments various forms of identification are included at . In general included identification uniquely identifies the metadata objects on a global basis so that for example if needed a metadata cache knows which source to go to e.g. which file or data management system and what metadata objects to retrieve from that source.

The identified metadata objects are requested from the metadata cache at . To uniquely identify the metadata objects to the metadata cache a request at may include the metadata object identifiers received at . Alternatively some mapping between the identification received at and that used at may be performed.

At the identified metadata objects are received from the metadata cache in common format. With respect to cache hits and cache misses there is no behavioral difference between a cache hit or a cache miss from the point of view of a planner or any other process which accesses metadata from a metadata cache when data is received at . If the identified metadata is not stored in the metadata cache then the corresponding metadata provider is used to access those metadata objects and transform them as needed in a manner that is transparent to the planner.

The raw query is optimized using the metadata objects in the common format received from the metadata cache at . The metadata objects received at and used at are in the common format which permits the planner to operate in a manner that is not necessarily coupled to a specific database implementation.

At the optimized query is output. For example in an optimized query may be sent from planner to executor for execution against the appropriate target. For debugging e.g. when metadata from file in is used the optimized query may be sent to a debugger for presentation to and or manipulation by a system administrator.

In some embodiments when a process such as a planner accesses a metadata object from a metadata cache the metadata objects being accessed are locked or pinned to prevent those metadata objects from being removed from the cache before the planner or other process is finished with those metadata objects. Unlocking may occur when the process is done with the metadata object e.g. upon completion of the process or if there is some other exit or conclusion to the process such as an error event . In some embodiments such locking or pinning is accomplished using metadata accessors. In such embodiment all accesses to metadata objects in the metadata cache are performed using a metadata accessor which has the scope of the process e.g. a planner and releases the metadata accessors at the end of the process if not sooner. In some embodiments there is a many to one mapping of metadata accessors to metadata objects. For example if two queries are associated with the same metadata object then each query will have its own metadata accessor for that metadata object.

At a request is received at a metadata cache for a metadata object. For example in planner may be optimizing a query associated with one or more metadata objects and planner sends a request to metadata cache for those metadata objects.

At it is determined whether the metadata object is cached. In some embodiments this includes determining which sub cache a particular metadata object would be stored in and checking that sub cache for example using an identifier included in a request at which is associated with the requested metadata object. For example in it may be determined which of sub caches the requested metadata object is associated with and checking that sub cache for the requested metadata object. As described above in some embodiments there is a single cache for example where all information is stored together and the example process is modified accordingly.

If it is determined at that a metadata object is cached then access is provided to the metadata object in a common format at . For example the common format may be a generic or standardized format and in some cases does not exactly match any of the formats or representations as they are organized or represented at the source e.g. in file or data management systems and in . In various embodiments the access is read only. That is the metadata cache does not support e.g. via the metadata object provided at updates to a metadata object as it is stored in a source file or a source data management system. In some embodiments a metadata accessor or some other technique is used to ensure the metadata object in the common format provided at is not removed or deleted before an application or other entity to which access is provided e.g. planner in is done using the metadata object from the metadata cache.

If it is determined at that a metadata object is not cached then a metadata provider is used to obtain a metadata object from a source and transform the metadata object in a native format into a common format at . In for example if the requested metadata objects associated with sub cache are available in sub cache but some other requested metadata objects associated with sub cache are not available in that sub cache then Type X metadata provider is used to communicate with first data management system in order to obtain the desired metadata objects from first data management system transform it to the common format and store it in sub cache . Access to the metadata object in a common format is then provided at .

At a source which manages a metadata object is communicated with to obtain the metadata object in a native format. For example third data management system may have an API or service for accessing metadata objects and Type Y metadata provider may obtain the desired metadata objects using such an interface. In some embodiments a metadata provider is responsible for updating multiple sub caches and step may include determining which source to communicate with. For example Type X metadata provider is responsible for updating both sub cache and sub cache and step may include determining whether to communicate with first data management system or second data management system .

At a metadata object in its native format is transformed as needed to a common format. For example a generic or standard format which does not e.g. perfectly match any of the native formats may be used. Alternatively one of the native formats may be used as the common format. The metadata object in the common format is stored in a metadata cache at . For example the metadata after any transformation is stored in the appropriate one of sub caches in .

In diagram metadata object from a first source of metadata corresponds to metadata objects and in the common format. In this example what was previously represented in a single metadata object is now represented using two metadata objects. Metadata object from the first source does not correspond to anything in the common format. In various embodiments it may have been determined to be redundant e.g. and the same information can be obtained from another metadata object or the information is not relevant or needed in the common format. The third metadata object is transformed into metadata object in the common format.

For the second source of metadata metadata object in native format is transformed into metadata object . Metadata object is transformed into metadata object metadata object is transformed into similar to metadata object . As is shown in this example in some cases there is a many to one correspondence during transformation. For example in the native format one metadata object may define e.g. all data types and another metadata object may define e.g. all permitted operations on those data types. In the common format there may be a metadata object for each data type which also includes functions permitted to be performed on that data type and thus there is a many to one correspondence. As was shown for the first source of metadata in diagram there may also be a one to many relationship in some cases.

In diagram the common format is one of the native formats employed by the second source of metadata. As such transformation of metadata objects associated with the second source of metadata is not necessary. Metadata objects associated with the first source of metadata are transformed respectively into metadata objects .

In some embodiments metadata at a source e.g. file or data management systems or changes. To accommodate this in some embodiments a metadata cache tracks and or includes as input output one or more version numbers. The following figure describes an embodiment of a process performed by a metadata cache where version numbers are used.

At a request for a metadata object is received at a metadata cache where the request includes a version number. A variety of version numbering techniques may used in combination with this technique. In one scheme for example a version number changes any time anything changes. Put another way there is a single version number for all of the metadata. On the other end of the spectrum another scheme may have a version number for each metadata object. Another scheme is a compromise between the previous two schemes with multiple version numbers where each version number tracks a corresponding set of metadata objects. Depending upon the particular versioning scheme the appropriate version numbers are included in a request at . For example planner in may include in a request sent to metadata cache version numbers for desired metadata objects stored in metadata cache .

At it is determined whether the requested version of the metadata object is cached. This may include determining which sub caches to check and checking those sub caches for the specified version number of the metadata object.

If it is cached at then access is provided to the metadata object in the common format with a version number. For example metadata cache may return the requested metadata object to planner in with the version number. In the event the requested version of the metadata object is not found by the metadata cache metadata provider at it is left up to the clients e.g. planner to determine the appropriate course of action. The requesting entity e.g. planner may decide to request the metadata objects again with the same version number or may decide that a different version of the metadata objects is sufficient. In either case it is left up to the requesting entity or another higher level entity such as an application which initiated a query being optimized to determine the appropriate course of action. Metadata cache does not at least in this embodiment determine whether the returned version is the most current version and if not what is the appropriate course of action in such cases.

If it is not cached at then a metadata provider is used to obtain the specified version of the metadata object from the source and transform the metadata object in native format into a common format at . For example Type Y metadata provider may provide an identifier for a desired metadata object along with a version number for that metadata object to third data management system in . After using the appropriate metadata provider at to obtain the specified version of the metadata object at access is provided at .

At a source which manages a metadata object is communicated with to obtain a specified version of a metadata object in a native format. For example if a specific version of a metadata object is not stored in sub cache then file metadata provider communicates with file in . At the specified version of the metadata object in the native format is transformed as needed into a format common to a plurality of forms for describing metadata. For example sub caches may use a common framework or format for describing metadata even though sources and may not necessarily have a common metadata framework or format. At the metadata object in the common format is stored in a metadata cache with the version number. For example a metadata object obtained from file in may be stored after any transformation into the common format in sub cache with a version number. Storing a version number enables the metadata cache to know whether or not a specific version of a metadata object is located in the metadata cache e.g. the next time a request comes in .

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

