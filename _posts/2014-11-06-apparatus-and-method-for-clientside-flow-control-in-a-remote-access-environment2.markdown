---

title: Apparatus and method for client-side flow control in a remote access environment
abstract: A client-side flow control mechanism for controlling the flow of messages communicated from a service to a client in a remote access system. The service, which may be a managed or unmanaged service, may communicate messages to the client where the messages include a service sequence ID (SSI). As the client processes the messages from the service, the client responds with a client sequence ID (CSI). The SSI and CSI values determine the number of messages that are in transmission queues. The service compares a difference between the current SSI and CSI to a stop window value. If the difference is greater than the stop window value, transmission of messages from the service to the client is turned OFF. The client continues to send CSI acknowledgments as it processes messages. Once the difference falls below a start window value, the transmission of messages to the client is turned ON.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09584447&OS=09584447&RS=09584447
owner: Calgary Scientific Inc.
number: 09584447
owner_city: Calgary, AB
owner_country: CA
publication_date: 20141106
---
This application claims priority to U.S. Provisional Patent Application Nos. 61 900 940 filed Nov. 6 2013 entitled METHOD FOR CLIENT SIDE FLOW CONTROL IN A REMOTE ACCESS ENVIRONMENT and 61 910 189 filed Nov. 29 2013 entitled METHOD FOR SERVER SERVICE SEPARATION WITH END TO END FLOW CONTROL IN A CLIENT SERVER REMOTE ACCESS ENVIRONMENT the disclosures of which are incorporated herein by reference in their entities.

Ubiquitous remote access to services has become commonplace as a result of the growth and availability of broadband and wireless network access. As such users are accessing services using an ever growing variety of client devices e.g. mobile devices tablet computing devices laptop notebook desktop computers etc. . A remote server may communicate messages that contain data or other information between services and client devices over a variety of networks including 3G and 4G mobile data networks wireless networks such as WiFi and WiMax wired networks etc.

A problem arises when there is enough network bandwidth to send messages from the service to a connected client but the client cannot process the messages quickly enough. For example with some APIs networking is push based. As such during periods when the client is idle or performing background tasks additional messages may be sent and queued at the client. If too many are sent and the client cannot process them in a timely fashion errors may occur.

Disclosed herein are systems and methods for providing flow control in a remote access system. In accordance with aspects of the disclosure the method may include communicating messages from a service to a client the service being remotely accessed by the client and the messages including a service sequence ID SSI receiving at the service a client sequence ID CSI from the client in response to the client completing processing of a message having a specific SSI associated with the message determining at the service a difference between a current SSI communicated to the client and the current CSI received from the client and if the difference is greater than a predetermined stop window value turning communication from the service to the client OFF.

In accordance with other aspects of the disclosure a method of providing client side flow control is described that may include communicating a message from a service to a client the message including a first sequence number that is incremented by the service to represent a relative position of the message within a plurality of messages that are communicated from the service to the client receiving at the service a response from the client indicating a completion of processing of a message having a second sequence number less than first sequence number determining at the service from the response if the processing of messages at the client is lagging beyond a first predetermined value and turning communication from the service to the client OFF if the client is lagging beyond the predetermined value.

In accordance with yet other aspects of the disclosure an apparatus for providing client side flow control of communication of messages from a service to a client is described. The apparatus may include a remote access server having a server layer as a communications proxy for messages sent between the client and the service the server layer containing an outbound client queue of messages destined for the client and a second server executing a service layer associated with the service the service layer having a service receive queue for messages received from the client and a service send queue of messages destined for the client. The messages destined for the client may include a service sequence ID SSI and the messages received from the client include a client sequence ID CSI indicative of the client completing processing of a message having a specific SSI associated with the message. The service may determines if a difference between a current SSI and the CSI received from the client is greater than a predetermined stop window value to turn communication from the service to the client OFF.

In accordance with an aspect of the disclosure a method of providing client side flow control in a remote access system is described. The method may include communicating messages from a service to a client the service being remotely accessed by the client and the messages including a service sequence ID SSI receiving a client sequence ID CSI from the client in response to the client completing processing of a message having an SSI associated with the CSI determining at the service a difference between a current SSI communicated to the client and the CSI received from the client and if the difference is greater than a predetermined stop window value turning communication from the service to the client OFF.

Other systems methods features and or advantages will be or may become apparent to one with skill in the art upon examination of the following drawings and detailed description. It is intended that all such additional systems methods features and or advantages be included within this description and be protected by the accompanying claims.

Unless defined otherwise all technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art. Methods and materials similar or equivalent to those described herein can be used in the practice or testing of the present disclosure. While implementations will be described for remotely accessing services it will become evident to those skilled in the art that the implementations are not limited thereto but are applicable for remotely accessing any type of service including applications and data via a remote device.

With the above overview as an introduction reference is now made to which illustrates a layered architecture in accordance with the present disclosure. The layered architecture implements a client flow control mechanism which allows a client to control the flow of information from a service executing on an application server through a remote access server . As illustrated in there are three layers in the system a client layer a server layer and a service layer . In accordance with the present disclosure the layered architecture includes messaging queues that account for the particularities of client ability to process messages containing data or other information from the application server . The client layer resides in the client and is used to connect to the server layer . Typically the client layer includes a client application e.g. a web browser dedicated application etc. used to provide a user interface at the client . The client may be wireless handheld devices such as for example an IPHONE an ANDROID based device a tablet device or a desktop notebook personal computer that are connected by a communication network to the remote access server .

The remote access server may include a server remote access program that is used to connect the client to the application server which may be e.g. a medical application. An example of the server remote access program is PUREWEB available from Calgary Scientific Inc. of Calgary Alberta Canada. The server remote access program may optionally provide for connection marshalling and application process management across the architecture of . The remote access server may be connected to the application server over a communication connection . If the application server is executing on a computing device other that the remote access server the communication connection may be a communication network. For example the communication connection may be a TCP IP communications network a VPN connection a dedicated connection etc. If the application server is executing on the same node or computer as the remote access server the communication connection may be a TCP IP socket connection shared memory space shared file location etc.

The server layer serves to proxy communications from the client to the service layer as described below. The client layer contains a client receive queue of messages received from the remote access server which are sent on behalf of the application server to which the client is logically connected. The client layer also contains a client send queue of messages it sends to a receive queue in server layer of the remote access server . The messages may be ultimately destined to the application server for example.

An instance of the service layer e.g. associated with the service connects to the server layer which proxies communications from the application server to the client logically associated with that service. The service layer contains a service receive queue of messages it receives from the server on behalf of the client . Each message may be labeled with the unique identifier of the client . The service layer also contains a service send queue of messages it sends to a client queue in the server layer of the remote access server . Each message in the service send queue may also be labeled with the unique identifier of the client . Additionally details regarding types of services is provided with reference to .

The client flow control mechanism of the present disclosure may be included as part of a service Software Development Kit SDK implemented in the service layer that causes the service to stop sending messages when the network connection between server and client is saturated as determined by message tracking system. As will be described below with reference to a sequence counter may be added to track the current service sequence ID SSI sent to a client and current client sequence ID CSI received from the client for each connected session. The client layer listens for messages from the service execution on the application server that have the service sequence ID SSI . Whenever the client receives and processes a message having an SSI it sends the client sequence ID CSI as an acknowledgement to the service. Transmission to the client may be turned OFF when difference between the service sequence ID SSI and the client sequence ID CSI is larger than a predetermined OffWindowSize value. In other words the combination of the SSI and CSI indicate the number of messages in queues and is greater than the OffWindowSize value. Transmission to the client may be turned ON when the difference between the service sequence ID SSI the client sequence ID CSI is below an OnWindowSize value. As such the service will be able to determine how far behind the client is in its message processing. The OnWindowSize value allows the client to catch up before the service sends more data.

At the service determines the difference between the current SSI and the current CSI. The application server maintains the current SSI and CSI values. A difference between these values may be used by the application server to determine if the client is overwhelmed or otherwise lagging behind the application server . At if the difference between the SSI the CSI is larger than a stop window size e.g. the OffWindowSize value and the current state transmission state is ON then the session is set to an OFF transmission state at . This change of transmission state will stop the application server from sending additional messages to the client . The application server will continue to track the SSI and CSI values because the client may send messages updating the CSI as it continues to process messages. While the transmission state is OFF messages are queued in the service send queue in the service layer . Processing then continues at where the client continues process queued messages in the client receive queue .

If at the difference between the SSI and the CSI is not greater than the stop window size then processing returns at where the service sends a next message to the client with an incremented SSI. The application server will send the next message in the service send queue to the client . Processing continues as described above.

If at if the current transmission state is OFF then at it is determined if the difference between the SSI and the CSI is less than a start window size e.g. the OnWindowSize value . If not then processing returns to where the client processes the next message in the client receive queue . If at the difference between the SSI and the CSI is less than the start window size then the client is ready to process messages from service and the transmission state is set to ON at .

In the above operational flow example stop window OffWindowSize value is 5. It is noted that this value may be adjusted based on weights assigned to the communication session between client and application server . An example start window OnWindowSize value is 2. In accordance with some implementations the stop window value and the start window value are different in order to prevent a situation where transmission rapidly toggles back and forth between ON and OFF.

In accordance with yet other implementations the start and stop window values can be dynamically adjusted based on e.g. historical performance of the client a type of network being used e.g. Ethernet vs. cellular data etc. The difference between the start window value and stop window value may be made bigger as transmissions between the application server and client are successful and made smaller where there is trouble in the transmissions.

Thus as described above the application server makes all flow control decisions based on information received from the client . Further the process prevents delays in informing in the application server that there is a delay at the client . This allows the message flow to adapt to quality performance of the client . For example even if the client slows down and cannot process messages quickly enough the flow control mechanism of will stop the transmission of messages even though the network is fully capable of sending messages.

In accordance with the above the operational flow of may also be used to account for transmission characteristics of the communication connection . For example the communication connection may not provide the high bandwidth of an internal system bus of a computing device. Therefore the operational flow address latency that may occur during communication between the application server and the remote access server .

Accordance with the other implementations the operational flow may provide for interoperability among services and or clients that do not recognize or send an SSI and or CSI. For example if the application server does not send SSI the client may be adapted such that it does not does not send a CSI. Also if the service sends an SSI but client does not respond with CSI then the service will assume that the client is not enabled.

In some implementations two or more client devices may collaboratively interact in a collaborative session with the service using the remote access server . The remote access server may utilize a state model to present a synchronized view of display data associated with the application server . Flow control may be implemented on a per client basis. Where transmission is OFF to a particular client that client may skip messages to re synchronize its view with other clients in the collaborative session when transmission returns to an ON state.

Reference is now made to which illustrate examples of alternative models for client remote access to services in a layered architecture such as that shown in in which the client side flow mechanism described above may be implemented. illustrates a managed service in which the services are deployed on the same system node or computing device as the remote access and application server to which client devices communicate. In this case the service is managed in that the server controls the application process life cycle by starting and stopping the service as client connect and disconnect. illustrates an unmanaged service in which services are deployed on servers at a different system node from the integrated remote access and application server the application process life cycle is no longer managed by the remote access server.

In both the server remote access program may provide for connection marshalling and application process management. Further both the managed service and unmanaged service may implement the client side flow control of and or reliable messaging of . For example in the environment of is implemented if the communication connection experiences conditions that cause communication problems between the unmanaged service and the remote access server the tracking of the SSI and CSI values by the flow control mechanism of may be used by the unmanaged service turn off communications until the conditions are more favorable.

As shown in the client has the client layer that may communicate to a remote access and application server that includes the server layer and the service layer . The client may be connected by a communication network to the remote access and application server . The remote access and application server may include a server remote access program that executes in the server layer . The server remote access program is used to connect the client to a managed service e.g. an application executing in the service layer . Within the remote access and application server the server remote access program in the server layer may be connected to the service in the service layer using a TCP socket connection and by e.g. a system bus of the remote access and application server . Thus bandwidth between the server remote access program and the service is extremely high. An example of the client and the remote access and application server is shown in .

Referring now to there is illustrated an example of an unmanaged service deployment. In such environments a remote access server includes the server layer in which the server remote access program executes. An application server includes the service layer in which the service or application executes. In the environment of the service shown as unmanaged service is provided on a computing device other than a computing device on which the server remote access program executes and communicates over the communication connection to the remote access server . Thus the service is on a node separate from the server. An example of the remote access server and the application server is shown in .

In the client connects to the remote access server over communication connection . The application server may connect to the remote access server at a predetermined Internet Protocol IP address and or socket or using a Uniform Resource Locator URL associated with the remote access server to register the service or application with the server remote access program executing on the remote access server . An external entity the end user or another process or application launches the unmanaged service outside of the remote access server . The unmanaged service on startup connects to the remote access server using a server service socket connection and establishes the session as a queued and unmanaged application to which a client may connect.

Numerous other general purpose or special purpose computing system environments or configurations may be used. Examples of well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers servers handheld or laptop devices multiprocessor systems microprocessor based systems network personal computers PCs minicomputers mainframe computers embedded systems distributed computing environments that include any of the above systems or devices and the like.

Computer executable instructions such as program modules being executed by a computer may be used. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Distributed computing environments may be used where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules and other data may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing aspects described herein includes a computing device such as computing device . In its most basic configuration computing device typically includes at least one processing unit and memory . Depending on the exact configuration and type of computing device memory may be volatile such as random access memory RAM non volatile such as read only memory ROM flash memory etc. or some combination of the two. This most basic configuration is illustrated in by dashed line .

Computing device may have additional features functionality. For example computing device may include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage .

Computing device typically includes a variety of tangible computer readable media. Computer readable media can be any available tangible media that can be accessed by device and includes both volatile and non volatile media removable and non removable media.

Tangible computer storage media include volatile and non volatile and removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Tangible computer storage media include but are not limited to RAM ROM electrically erasable program read only memory EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of computing device .

Computing device may contain communications connection s that allow the device to communicate with other devices. Computing device may also have input device s such as a keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. All these devices are well known in the art and need not be discussed at length here.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the presently disclosed subject matter or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the presently disclosed subject matter. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs may implement or utilize the processes described in connection with the presently disclosed subject matter e.g. through the use of an application programming interface API reusable controls or the like. Such programs may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and it may be combined with hardware implementations.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

