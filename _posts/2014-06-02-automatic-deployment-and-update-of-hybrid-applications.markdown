---

title: Automatic deployment and update of hybrid applications
abstract: Described herein is a framework for deploying and updating applications (Apps). In accordance with one aspect, a source code of a hybrid application may be provided by a development environment running on a cloud server, in response to a user event. A deployment generator running on the cloud server may be automatically invoked to receive the source code of the hybrid application. The source code of the hybrid application may be further packaged to form a hybrid application package for deployment by the deployment generator. The hybrid application package may be deployed to a deployment service on the cloud server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274784&OS=09274784&RS=09274784
owner: SAP SE
number: 09274784
owner_city: Walldorf
owner_country: DE
publication_date: 20140602
---
The present disclosure relates generally to a framework for deploying and updating applications Apps .

Apps are developed for a wide variety of purposes. There are different types of Apps. For example native Apps are downloaded installed and run on devices. A native App is written for a specific kind of device or platform. Native Apps take advantage of the various functions available on a device. On the other hand Web Apps reside on a server. A device accesses a Web App through its browser. By being browser based any device with a browser can access Web Apps. In other words Web Apps are not platform or device type specific. However Web Apps cannot cross the boundaries of web browsers thus restricting access to some system specific resources.

A hybrid App is another type of App. Hybrid Apps combine elements of both native and Web Apps. Hybrid apps provide benefits of both native and Web Apps. For example hybrid Apps can be accessed through a browser while having access to various functions and features of a device. However deployment of hybrid Apps requires significant efforts and time. For example properly setting up the native development environment and preparing the required web contents is very complex and prone to errors. Updating of a hybrid App also requires significant effort. For example when a hybrid App is updated the corresponding native development environment is also required to be upgraded and updated accordingly.

From the foregoing discussion it is desirable to provide an approach to automatically deploy and update hybrid Apps without complicated environment setting.

A framework for deploying and updating applications Apps is described herein. In accordance with one aspect a source code of a hybrid application may be provided by a development environment running on a cloud server in response to a user event. A deployment generator running on the cloud server may be automatically invoked to receive the source code of the hybrid application. The source code of the hybrid application may be further packaged to form a hybrid application package for deployment by the deployment generator. The hybrid application package may be deployed to a deployment service on the cloud server.

In accordance with another aspect a source code of a hybrid application may be provided by a development environment running on a cloud server in response to a user event. A deployment generator running on the cloud server may be automatically invoked to receive the source code of the hybrid application. The deployment generator may scan the source code of the hybrid application to identify and remove design time files resulting in a scanned application file. The scanned application file may be analyzed to resolve runtime dependencies of the hybrid application as well as retrieving dependent libraries resulting in a resolved application file. The resolved application file may be further converted to files and folders compatible for deployment to the deployment service on the cloud resulting in a converted application file which may be compressed to form a compressed application file. The deployment generator may further generate a deployment metadata file and package the compressed application file and deployment metadata file to produce an application package. The application package may then be deployed to a deployment service on the cloud server.

In accordance with yet another aspect an application development system is described. The application development system includes an application developer running on a cloud server. The application developer further includes a development environment and a deployment generator. The development environment enables a developer to create a new hybrid application or update an existing hybrid application to produce an update hybrid application while the deployment generator packages the new hybrid application or packages the update hybrid application and deploys the new hybrid application or the update hybrid application to a deployment service on the cloud.

With these and other advantages and features that will become hereinafter apparent further information may be obtained by reference to the following detailed description and appended claims and to the figures attached hereto.

In the following description for purposes of explanation specific numbers materials and configurations are set forth in order to provide a thorough understanding of the present frameworks and methods and in order to meet statutory written description enablement and best mode requirements. However it will be apparent to one skilled in the art that the present frameworks and methods may be practiced without the specific exemplary details. In other instances well known features are omitted or simplified to clarify the description of the exemplary implementations of present frameworks and methods and to thereby better explain the present frameworks and methods. Furthermore for ease of understanding certain method steps are delineated as separate steps however these separately delineated steps should not be construed as necessarily order dependent or being separate in their performance.

In the case of a plurality of computers they are collectively considered as the cloud. The computers of the server are connected through a communication network. The communication network may be an internet an intranet a local area network LAN a wide area network WAN or a combination thereof.

The cloud is configured to host and process applications including storing data associated with the environment. Such hosting and processing may be considered as cloud services provided by the cloud. Various types of cloud services may be provided. The cloud services may be provided in a public private or hybrid network. The cloud services may be provided by a cloud service provider. For example the cloud services may be provided by SAP AG. Other types of clouds and cloud providers may also be useful.

End users may connect to the cloud using end user devices. An end user device may be a local computing device with for example a local memory and a processor. The memory may be volatile or non volatile types of non transitory computer readable media such as magnetic media optical media random access memory RAM read only memory ROM removable media or any other suitable local or remote memory component. Various types of processing devices may serve as an end user device. For example the end user device may be a PC a tablet PC a workstation a network computer a kiosk or a mobile computing device such as a laptop a tab or a smart phone. Other types of processing devices may also be used. End user and end user device may be used interchangeably. For example when referring to an end user it is understood that the end user connects to the cloud using an end user device.

Connection to the cloud may be through the internet. The interconnect connection may be using a mobile telecommunication network such as a 4G network. Other types of connections to the cloud may also be useful. An end user may access the cloud by having a cloud account. For example an end user may access cloud services by logging onto a user account.

In one implementation the environment includes a hybrid application development system . The hybrid application development system in one implementation is a software tool for efficiently and effectively developing updating packaging and deploying Apps. The development system includes an enhanced app developer running on the cloud . The enhanced app developer includes a development environment . The development environment facilitates in creating and updating Apps. In one implementation the development environment is an integrated development environment IDE . The enhanced app developer also includes an automatic deployment generator DG . The DG facilitates in packaging and deploying new and updated Apps. In one implementation the DG is an integrated DG IDG . The system also includes a multi purpose hybrid container . The hybrid container runs on an end user device . The end user device as shown is a mobile device such as a smart phone. The end user device may alternatively be a desktop device. It is understood that numerous end user devices may be communicating with the cloud. The hybrid container sets up the native environment of the end user device for the App in which to run.

A developer end user may log on to the cloud accessing the app developer . It is understood there may be numerous developer end users communicating with the cloud . Using the IDE running on the cloud the developer develops an App. In one implementation the IDE is a web based IDE. The web based IDE runs on a web browser. The web based IDE may be a wizard based IDE. For example the IDE includes wizards to guide the developer end user in developing Apps. The IDE for example may be a SAP River RDE from SAP AG Other types of IDEs may also be useful. The App may be a mobile or desktop App. Once the App is finished the IDG in one implementation is automatically invoked. When invoked the IDG packages the App e.g. source code of the App and deploys the App package to the cloud. For example the IDG deploys the App package to an App store or market on the cloud. For example the IDG packages the App s web content together with all required runtime libraries Javascript framework style sheets images as well as other resources and automatically deploys to the App store on the cloud.

In one implementation the environment includes a deployment service hosted on the cloud. The App package is forwarded by the IDG to the deployment service which deploys it to the App store.

As discussed the development system also includes a multi purpose hybrid container . The multi purpose hybrid container is prebuilt for different native environments. For example the hybrid container may be built to run on various native platforms. Native platforms may include mobile platforms such as iOS Android and windows mobile and desktop platforms such as Windows and MacOSX. Other types of platforms may also be useful. The hybrid container for example runs on an end user device. The hybrid container may serve as an App manager managing the lifecycle of an App. The hybrid container for example may include a set of plugins to manage the application credentials life cycle as well as other functions. In one implementation the hybrid container may be a SAP Kapsel Hybrid Container from SAP AG. Other types of hybrid containers may also be useful.

In one implementation the App is packaged in the multi purpose hybrid container . For example a new App version 1 at the App store is contained in the multi purpose hybrid container. When an end user downloads the App the hybrid container is installed to set up the App in the native environment. The hybrid container may be continuously updated to newer version via the Application store or market. For example whenever the hybrid container is updated it is pushed to the end user. The web application content is updated in the hybrid container of the end user. By continuously updating the hybrid container developers do not need to setup maintain and update their own native development environment. This avoids the complicated and error prone process for native application development.

Once deployed an end user may log onto the cloud and download the App contained in the hybrid container from the App store. When the App is downloaded the setup hybrid container is installed and runs on the end user s device setting up the native environment for the App. For example the App is configured to run in the hybrid container.

The IDE may also be used to update Apps. For example when changes are committed by the developer the IDG automatically deploys the update to the cloud. From the cloud the App s web content will be automatically pushed to the hybrid containers running on native platforms of end users who have already downloaded the App. In one implementation an application update plugin is provided in the hybrid container. The application update plugin communicates with the deployment service on the cloud to get the updated App automatically pushed to it. A logon manager plugin is also provided in the hybrid container. The logon manager plugin manages who is subscribed for updates. For example when the App is activated the logon manager passes current information of the App such as version and end user. The cloud service compares the information and determines if there are any updates. Updates are pushed to the App by the deployment service on the cloud.

As discussed the IDE facilitates in developing new Apps and updating existing Apps while the IDG automatically deploys new Apps and updates to the cloud. Updates are then automatically pushed to end user devices already having the App which needs to be updated.

An App developer end user may access the enhanced App developer by logging into the cloud. In one implementation a deployment configuration is performed. For example the App developer end user may access the configuration module in the IDE. The deployment configuration includes the developer end user providing information related to cloud deployment configuration. Such information for example may include cloud server name account name password as well as other deployment configuration information. For example other information may include the target platform and whether automatic update is enabled or not. In one implementation the App configuration module employs a configuration dialog to facilitate deployment configuration of Apps. The configuration dialog may be activated by selecting it on a menu bar in the IDE. Other techniques to effect deployment configuration may also be useful.

When a developer end user creates an App e.g. version 1 the build module in the IDE is accessed. The build module in one implementation provides a project wizard for creating an App. The wizard requests various information from the developer end user regarding the project or App. For example the wizard requests project name information regarding application domain etc. The wizard provides available templates for the developer end user to use. The templates for example provide format for viewing selected data. Also the wizard enables the developer to define the type of App such as mobile or desktop. Other techniques for developing Apps may also be useful. Command buttons may be provided by the wizard. For example a finished command button may be provided. When selected the App is finished. The App created using the wizard is translated to source code by the IDE such as for example HTML5 JS and CSS3. Other types of source codes may also be useful.

In the basic project information section project name and application domain fields and are included. The name of the project is provided in the project name field. For example as shown the project name is proj1 . As for the Application domain field it may pertain to the domain for different lines of business such as CRM ERM as well as others. As shown all domains are selected. The available template section includes a list . The list is a list of different project templates which are available for selection. A template may be selected by for example clicking on the project box . In such case the template is selected for a mobile based application. A project box may be provided for desktop based application. The template customization section includes a view name field . The view name field indicates which view is the initial view of the application. In the confirm section a finish command button is provided. Selecting the finish button for example by clicking on it indicates that the project is completed. Including other fields or configurations of the various sections may also be useful.

After the App has been created the user selects the finish command button on the wizard. This triggers the IDG to run to effect deployment. The deployment process is transparent to the user and runs automatically in the servers on the cloud.

In the case of updating an existing App the update module in the IDE is accessed. The update module includes a source control SC system. The SC system for example may be a Git system unit. Other types of SC systems may also be useful. The SC system includes an interface enabling the user to make updates to the App.

When updates are finished the user commits the updates by selecting the commit command button in the SC interface. For example the user commits the updated code. This triggers the IDG to run to effect deployment.

In the case of a new App e.g. version 1 or an updated App e.g. greater than version 1 the App scanner module of the IDG scans the App. The term App in this instance may refer to either a new App or an updated App. For example the scanner module identifies design time files and removes them resulting in a scanned App. Design time files may include files such as project setting and user preference files. Other types of design time files may also be included for removal.

The App dependencies module analyzes the scanned file to resolve application runtime dependencies as well as retrieving dependent libraries. For example redundant libraries are removed from the dependency list while conflicts in dependencies are resolved. This produces a resolved dependency RD App.

The file system conversion module analyzes the RD App. The conversion module converts the App s file system which is managed by the IDE on the cloud to files and folders suitable for packaging and network transfer. For example the App s file system is converted to be compatible to the deployment service on the cloud. This produces a converted App.

The packaging module packages the converted App. In one embodiment the packaging module includes a compression unit metadata generator unit packaging unit and deployment unit.

The compression unit compresses the converted App. Compressing the converted App in one implementation includes compressing the files of the converted App into compressed App. File compression for example may include minifying JS and CSS codes compressing large text files into small binary files as well as other actions. File compression including code minification is described in for example U.S. patent application Ser. No. 14 032 184 titled Packaging and Deploying Hybrid Applications filed on Sep. 19 2013 and which is herein incorporated by reference for all purposes.

The metadata generator unit generates a deployment metadata file corresponding to the compressed App. For example the metadata generator unit analyzes the compressed App s dependencies to generate the metadata file. The metadata file defines the backend services used by the App.

The packaging unit packages the compressed App and metadata file to form an App package for deployment. In the case of a new App for example version 1 of an App the compressed App and metadata file is packaged in a hybrid container forming the App package. For example the App package includes the compressed App file containing the source code of the new App and the metadata file in the hybrid container. The hybrid container for example may be a Kapsel Hybrid Container from SAP AG. For an updated App for example greater than version 1 no hybrid container is used. For example the App package includes the compressed App file and metadata file.

As discussed the cloud includes a deployment service. The deployment unit of the IDG for example deploys the App package to the deployment service on the cloud. The deployment service receives the App package from the IDG. The deployment service exposes its service. For example the IDG sends a post request to the deployment service. In one implementation the deployment service exposes its service as a standard REST service. For example the IDG sends a REST post request to the deployment service.

Communication between IDG and deployment service on cloud in one implementation is purely metadata driven. As such no script or programming language is required between the IDG and deployment service. This advantageously results in a simple and secure interface between the deployment service and IDG.

In the case of a new App the deployment service deploys the packaged App which includes the hybrid container to a persistent repository on the cloud. For example the App package is deployed to an App store. In the case of an updated App the deployment service deploys or pushes the App package to hybrid containers of end users who already have the App.

After the App is completed the IDG is automatically invoked to process the App at step . The IDG in one implementation processes the App by scanning it to remove design time files. This for example produces a scanned App file. The scanned App file is scanned to resolve runtime dependencies as well as retrieving dependent libraries. This produces a resolved dependency RD App file. The RD App s file system is converted to files and folders suitable for packaging and network transfer. A metadata file is also generated defining the backend services used by the App. After that the IDG packages the App and metadata file in a hybrid container for deployment. The packaged App in this case includes the App metadata file and hybrid container.

The IDG at step deploys the packaged App to the deployment service on the cloud. The deployment service deploys the packaged App to the App store at step . An end user may download the App to the hybrid container in the device.

After updating is completed the IDG is automatically invoked to process the updated App at step . The IDG in one implementation processes the App by scanning it to remove design time files. This for example produces a scanned App file. The scanned App file is scanned to resolve runtime dependencies as well as retrieving dependent libraries. This produces a resolved dependency RD App file. The RD App s file system is converted to files and folders suitable for packaging and network transfer. A metadata file is also generated defining the backend services used by the App. After that the IDG packages the App and metadata file for deployment. For example the packaged App includes the App and metadata file.

The IDG at step deploys the packaged App to the deployment service on the cloud. At step the deployment service pushes the packaged App of the updated App to hybrid containers of user devices which have non updated version of the App.

The enhanced App developer running on the cloud as described simplifies the App deployment workflow. For example a new App is created in the IDE of the App builder using for example a project wizard. Once the source code is committed the IDG packages the App and metadata file in a hybrid container and automatically deploys the packaged App to for example an App store via a deployment service on the cloud. An end user can easily download the App package and install and setup a hybrid container in the App package to run on the end user device. The App is installed and runs in the hybrid container on the end user device. In the case of an update once the source code is committed it is automatically deployed to the deployment service on the cloud which then pushes the update to the hybrid container on the end user device.

Since the App developer with the IDE and IDG and deployment service are all on the cloud a developer end user just need a browser to access the App developer for deployment while an end user needs a hybrid container running on an end user device. For example an end user just needs a hybrid container to receive the deployment and updates.

As described the application development system may be embodied as an application. For example the application development system may be embodied as a software application. The different components of the system may be separate software applications configured to operate or interact with each other whether on the cloud or on the end user devices. The source code of the applications may be compiled to create an executable code. The codes for example may be stored in a storage medium such as one or more storage disks or in memory of a server and or end user devices. Other types of storage media may also be useful.

Although the one or more above described implementations have been described in language specific to structural features and or methodological steps it is to be understood that other implementations may be practiced without the specific features or steps described. Rather the specific features and steps are disclosed as preferred forms of one or more implementations.

