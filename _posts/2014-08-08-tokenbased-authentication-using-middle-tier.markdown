---

title: Token-based authentication using middle tier
abstract: An intermediary system facilitates a connection request from a client to a server. The intermediary system may participate in either or both of a token creation phase and a server connection phase. If participating in the token creation phase, the intermediary system generates a token that may later be used by the client during a server connection phase. The token includes a session identifier and is returned to the client. If participating in the server connection phase, the intermediary receives the token, which is sent from the client in conjunction with a connection request, extracts the session identifier from the token, and compares against the session identifier for the session in which the token was created. If the session identifiers match, then the intermediary connects to the server to complete the connection request for the client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09003191&OS=09003191&RS=09003191
owner: Microsoft Technology Licensing, LLC
number: 09003191
owner_city: Redmond
owner_country: US
publication_date: 20140808
---
This application is a continuation of prior application Ser. No. 12 895 595 filed Sep. 30 2010 titled Token Based Authentication Using Middle Tier which is incorporated herein by reference in its entirety.

Computer services are now often offered over a network such as the Internet. In order to securely provide such services it is often necessary to accurately authenticate those computing systems or users who are requesting accesses to the computing service. In other words the service requestor s identity is confirmed. Authentication has been important for millennia and thus various authentication mechanisms have been developed. Authentication is now quite prolific in Internet based transactions. Authentication precedes authorization in which the permissions associated with the authenticated identity are verified.

There have also been attempts to circumvent the security provided by authentication. One such circumvention is referred to in the art as cross site request forgery in which a third party site tries to take advantage of secure information provided between an authenticated party and an authenticating party in order to impersonate the authenticated party. Authentication methods that reduce the opportunity for cross site request forgery would be highly valuable.

At least one embodiment described herein relates to an environment in which a client requests a service from a server. An intermediary system intervenes between the client and server and is configured to facilitate the server request from the client.

In some embodiments the intermediary system performs a token creation phase in which intermediary generates a token for the client that may later be used by the client during a server connection phase. In the token creation phase the intermediary receives a connection request from a client the request including one or more connection credentials. The intermediary uses at least one of the credentials to attempt a connection to the server. The intermediary creates a session identifier and formulates a connection ticket that includes the session identifier and the credential s used in the successful server connection attempt. The connection ticket is then encrypted and included in a token which is then returned to the client.

In some embodiments the intermediary system performs a server connection phase. In the server connection phase the intermediary receives the token decrypts the token using a secret key to thereby extract a connection ticket. Then a session identifier is extracted from the connection ticket. This extracted session identifier is then compared against a session identifier in which the connection ticket was formulated. If the session identifiers match the extracted credentials are then used to complete a connection with the server.

This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

In accordance with embodiments described herein an intermediary system facilitates a connection request from a client to a server. The intermediary system may participate in either or both of a token creation phase and a server connection phase. If participating in the token creation phase the intermediary system generates a token that may later be used by the client during a server connection phase. The token includes a session identifier and is returned to the client. If participating in the server connection phase the intermediary receives the token extracts the session identifier from the token and compares against the session identifier for the session in which the token was created. If the session identifiers match then the intermediary connects to the server to complete the connection request. First some introductory discussion regarding computing systems will be described with respect to . Then the embodiments of the intermediation of server requests will be described with respect to .

First introductory discussion regarding computing systems is described with respect to . Computing systems are now increasingly taking a wide variety of forms. Computing systems may for example be handheld devices appliances laptop computers desktop computers mainframes distributed computing systems or even devices that have not conventionally considered a computing system. In this description and in the claims the term computing system is defined broadly as including any device or system or combination thereof that includes at least one processor and a memory capable of having thereon computer executable instructions that may be executed by the processor. The memory may take any form and may depend on the nature and form of the computing system. A computing system may be distributed over a network environment and may include multiple constituent computing systems.

As illustrated in in its most basic configuration a computing system typically includes at least one processing unit and memory . The memory may be physical system memory which may be volatile non volatile or some combination of the two. The term memory may also be used herein to refer to non volatile mass storage such as physical storage media. If the computing system is distributed the processing memory and or storage capability may be distributed as well. As used herein the term module or component can refer to software objects or routines that execute on the computing system. The different components modules engines and services described herein may be implemented as objects or processes that execute on the computing system e.g. as separate threads .

In the description that follows embodiments are described with reference to acts that are performed by one or more computing systems. If such acts are implemented in software one or more processors of the associated computing system that performs the act direct the operation of the computing system in response to having executed computer executable instructions. An example of such an operation involves the manipulation of data. The computer executable instructions and the manipulated data may be stored in the memory of the computing system . Computing system may also contain communication channels that allow the computing system to communicate with other message processors over for example network .

Embodiments of the present invention may comprise or utilize a special purpose or general purpose computer including computer hardware such as for example one or more processors and system memory as discussed in greater detail below. Embodiments within the scope of the present invention also include physical and other computer readable media for carrying or storing computer executable instructions and or data structures. Such computer readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer readable media that store computer executable instructions are physical storage media. Computer readable media that carry computer executable instructions are transmission media. Thus by way of example and not limitation embodiments of the invention can comprise at least two distinctly different kinds of computer readable media computer storage media and transmission media.

Computer storage media includes RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to store desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer.

A network is defined as one or more data links that enable the transport of electronic data between computer systems and or modules and or other electronic devices. When information is transferred or provided over a network or another communications connection either hardwired wireless or a combination of hardwired or wireless to a computer the computer properly views the connection as a transmission medium. Transmissions media can include a network and or data links which can be used to carry or desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above should also be included within the scope of computer readable media.

Further upon reaching various computer system components program code means in the form of computer executable instructions or data structures can be transferred automatically from transmission media to computer storage media or vice versa . For example computer executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module e.g. a NIC and then eventually transferred to computer system RAM and or to less volatile computer storage media at a computer system. Thus it should be understood that computer storage media can be included in computer system components that also or even primarily utilize transmission media.

Computer executable instructions comprise for example instructions and data which when executed at a processor cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be for example binaries intermediate format instructions such as assembly language or even source code. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather the described features and acts are disclosed as example forms of implementing the claims.

Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations including personal computers desktop computers laptop computers message processors hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers mobile telephones PDAs pagers routers switches and the like. The invention may also be practiced in distributed system environments where local and remote computer systems which are linked either by hardwired data links wireless data links or by a combination of hardwired and wireless data links through a network both perform tasks. In a distributed system environment program modules may be located in both local and remote memory storage devices.

The client computing system is modified with the term client and the server computing system is modified with the term server since as described below the client computing system makes a service request to the server computing system . In other contexts the client computing system may provide services and the server computing system may consume services. The client computing system the server computing system and the intermediary may also be referred to herein as client server and intermediary for short.

The intermediary facilitates a service request from the client to the server . The service request may be made in two phases a token creation phase and a subsequent server connection phase . The intermediary may participate in just one or perhaps both of these phases. The benefits of splitting the request into two phases will be outlined after the description of .

Referring to the method of in the token creation phase the intermediary receives a connection request for a client act . Referring to the specific example of the client communicates a connection request to the intermediary . In the example the client and the intermediary communicate using the Secure Sockets Layer in the HyperText Transport protocol. The connection request includes one or more credentials. For instance in a username and password are provided in the authorization header. In addition a server name and instance identifier may be provided as a Uniform Resource Locator URL parameter. In particular the URL specifies the address of the server that is to be connected to. The server name that is included as a URL parameter defines the server name that the client is to connect to. In the case that the server is a database server the instance identifier that is included as a URL parameter defines a database name that the client is to connect to. Separate communications may be used to perform the connection request and to provide one or more credentials in which case the multiple communications may be considered as a request that includes the credentials consistent with the principles described herein.

Referring to the intermediary uses at least one of the one or more connection credentials to attempt a connection to a server act . In for example the intermediary formulates a connection string that includes the provided credentials including the user name and password. The intermediary then uses a connection method with the connection string as a parameter. This would be an appropriate for a SQL server but other methods of connection attempts may be used for other types of servers. The connection attempt is performed in order to verify that the credentials are part of a valid connection with the server. In the connection attempt is represented by arrow . The result of the connection attempt is represented by arrow . If the connection fails the method terminates after perhaps notifying the user of the failure represented by arrow . If the connection succeeds the method continues.

Referring again to the intermediary optionally formulates key salt act and formulates ticket salt act . Salt is short for a pseudo random sequence. In the formulation of the key salt is represented by arrow and the formulation of the ticket salt is represented by arrow .

The key salt is to randomize the secret key used to later encrypt and decrypt. This makes a brute force attack to discover the secret key much more difficult. The ticket salt is used to randomize the connection ticket to be encrypted. The use of the key salt and the ticket salt provide security to the method . Furthermore the salt makes it more certain that a unique token will be generated whenever a token is created. The generation of the salt is optional. If the salt is used a reasonable time for the salt to be generated would be upon receipt of the token creation request. However the timing of generation is not key to the broadest aspects described herein so long as the salt is generated prior to it being used.

In the intermediary formulates a session identifier associated with the connection request act . This session identifier will be included within the connection ticket as described below. However the timing of the creation of the session identifier is not critical so long as the session identifier is available when the connection ticket is being formed. Nevertheless in many protocols the session identifier is generated upon a client connecting with any server. Accordingly in implementations in which the intermediary uses those protocols to communicate with the client the session identifier may automatically be generated as part of the protocol. In the session identifier is obtained by calling a specific method to create the session identifier as represented by arrow .

The connection ticket is then formed act . The connection ticket includes the session identifier. In this description and in the claims a first data item includes a second data item if the second data item may be obtained from information within the first data item. For instance the second data item may be encrypted compressed hashed or otherwise be in a form that is not directly readable without a converse transformation being performed on the second data item. Furthermore the first data item may just contain a pointer or reference that may be used to access the second data item.

The connection ticket includes the session identifier and at least one of the connection credentials. In for example the formulation of the connection ticket is represented by arrow . In this specific example the connection ticket includes a concatenation of a hash of the session identifier the connection string used to successfully attempt the connection to the server a timeout the ticket salt a SKU i.e. a server identifier and a version. Such a connection ticket allows the token to be provided to different intermediaries that perform the same function as described for the intermediary since no state is required for the intermediary in the transition from the token creation phase to the server connection phase. Thus intermediary may be but one of a potentially large number of intermediaries assisting in the token creation phase and or server connection phase between a large number of clients and or a larger number of servers. So long as those different intermediaries share the same secret key they will be able to facilitate the server connection phase described below. This allows the system to scale since communication is not required between intermediaries to maintain state from one intermediary to another.

Examining the contents of the connection ticket to include the session identifier the session identifier is first hashed before being included in the connection ticket. The timeout is used to determine if the token is still valid when the token is later provided in the subsequent server connection phase. The ticket salt is used to randomize the connection ticket so as to significantly inhibit the chance that identical tokens will be generated. The connection ticket also may include server specific information such as the SKU i.e. the server identifier and the version of the server.

The connection ticket is then encrypted act . This is performed using a secret key that is unknown to the client. In this encryption is represented by arrow . In the specific example of the connection ticket is encrypted using a combination of the secret key and the key salt. Specifically the combination used for encryption is obtained by logically XOR ing the secret key and the key salt.

The token is then generated act that includes the connection ticket. In the connection ticket is represented by arrow and includes a concatenation of the key salt and the encrypted connection ticket. The token is then provided to the client act . In the token is returned in a cookie along with a session identifier as cookies may include a session identifier that identifies a session in which the cookie was generated. However different mechanisms may be used to return the token depending on the connection. The return of the cookie that includes the token and session identifier is represented in using the arrow .

As previously mentioned the server request is facilitated by first performing a token creation phase and then performing a server connection phase. illustrates a flowchart of a method for performing the server connection phase. In some embodiments the intermediary of may participate in the server connection phase as symbolically represented by the token creation element being included within the intermediary . shows a more specific sequence diagram in a specific example in which a client is making a request to a database server and in which various optional actions are also illustrated. Accordingly will be frequently referred to as a very specific example of the method of .

The method is initiated upon receiving a token from the client act . For instance this token may be the token that was created using the method of . The token is attached with a service request from the client to be performed on the server. In for example the intermediary receives a web operation request as represented by arrow along with a cookie that is returned to the intermediary. Recall that in the sequence diagram of this may be the same cookie that was sent to the client along with the token. In the communication between the client and intermediary may be over a non secure network because the connection ticket is already encrypted allowing its distribution without exposing its sensitive encrypted contents. This can improve performance because the setting up of security over a secure network e.g. creating a secure socket layer is expensive in terms of processing time latency and memory usage.

The intermediary then decrypts the token using the secret key to extract the connection ticket act . In for example the token includes a concatenation of the key salt and the encrypted connection token. The encrypted connection token was encrypted using a combination of the secret key and the key salt the combination being generated by logically XOR ing the secret key and the key salt. The combination may be regenerated by reading the key salt from the token logically XOR ing the key salt with the secret key and decrypting the connection ticket. This is represented in by arrow resulting in the connection ticket.

The session identifier and the at least one connection ticket are then extracted from the connection ticket act . In this is represented by arrow in which the hashed session identifier is obtained along with the connection string that contains the credential s used in the previous successful connection attempt from the token creation phase. Furthermore a timeout the SKU i.e. the server identifier and the version are then extracted.

A few checks are then performed to provide security. If the connection ticket includes a timeout the timeout is reviewed to verify whether the timeout has expired. If the timeout has expired then the token is determined to be invalid.

If it is verified that the timeout has not expired act then it is evaluated whether the session identifier extracted from the connection ticket matches a session identifier for a session in which the connection ticket was formulated act . For instance in the verification of the timeout and the session identifier are represented by arrow . To verify the session identifier the session identifier extracted from the token is compared against the session identifier included in the cookie. Rather than being included in the cookie the session identifier can come from the network stack that can associated session data with a specific channel.

By checking that the session identifiers match act at least two protections are achieved. First malicious sites that are loaded in the same session cannot access the intermediary because they have no access to the token. Second even if someone gets hold of the token the individual will not be able to access the token because he needs to be in the same session. Based on these protections there is protection against Cross Site Request Forgery XSRF attacks. Furthermore there is protection against over the shoulder attacks in which someone can see the links in the client s address bar but cannot steal the session.

If the timeout has not expired act and the session identifiers match act then the server request is sent to the server along with credentials act . In for example the service request is forwarded with the connection string as represented by the arrow . The results of the service request are then returned by the server to the intermediary as represented by the arrow whereupon the results are returned from the intermediary to the client as represented by the arrow .

Depending on the embodiments the embodiment described herein may have any one or more of the following benefits. The client may connect to any server through the intermediary without the need to have a membership provider for each server. The web service interface may have a RESTful web service interface and efficiently mitigate XSRF attacks. REST is a representational state transfer is a well known architectural pattern for web communication.

Furthermore there is scalability in that the principles enable the interface to be used against a web farm that has a collection of intermediaries across different data centers so the server request may be routed to any of them based on load balancing or random assignment. The method may be used even when cookies are disabled by setting the token to be present in the web service URL. The server connection phase allows communication over secure and non secure transport protocols since the connection credentials are encrypted inside the token and do not appear in plain text. The method may be performed in a server farm without the need of a session server since the method does not require anything stored on the intermediary.

Thus a useful flexible and secure mechanism for intermediating service requests is described. The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

