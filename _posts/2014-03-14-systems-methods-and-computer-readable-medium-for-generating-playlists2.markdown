---

title: Systems, methods, and computer readable medium for generating playlists
abstract: Methods, systems and computer program products are provided for generating a playlist. An application programming interface (API) receives a request to generate a playlist, where the request includes a set of rule-primitives. A playlist engine evaluator evaluates a rule corresponding to each rule-primitive in the set of rule-primitives across a catalog of media content, calculates a cost associated with each item in the catalog of media content, and generates a playlist based on the items of the catalog having the lowest costs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626436&OS=09626436&RS=09626436
owner: SPOTIFY AB
number: 09626436
owner_city: Stockholm
owner_country: SE
publication_date: 20140314
---
This application claims priority to U.S. Provisional Application No. 61 798 745 filed Mar. 15 2013 the contents of which are incorporated herein by reference.

Example aspects described herein relate generally to media content programming and more particularly to generating playlists.

Since the advent of radio disc jockeys DJs have been generating lists of songs referred to as a playlists to be played from broadcast stations. Typically which songs from a catalog of available songs are included in a playlist is driven by a DJ through the careful curation of songs and libraries as well as the custom definition of metadata. Oftentimes a DJ will manually order the results to achieve a pleasing result. This also gives a DJ control over the pace and scheduling of the played songs.

Nowadays playlists can be generated by a computer automatically. A conventional playlist generator applies a set of user preferences to a collection of songs to identify selections in the collection that satisfy the set of preferences. User selected preferences may define songs that are to be included in or excluded from the playlist particular genres or styles and so on. They can also define a song to be used as a seed to find similar songs. To create a different playlist a user modifies the preferences and submits them to the playlist generator. As can be understood this methodology is still limited in functionality. The embodiments described herein solve technical challenges to provide other unique and useful functions related to playlist generation that are significant.

The example embodiments described herein provide methods systems and computer program products for generating a playlist.

An application programming interface API receives a request to generate a playlist where the request includes a set of rule primitives. A playlist engine evaluator evaluates a rule corresponding to each rule primitive in the set of rule primitives across a catalog of media content calculates a cost associated with each item in the catalog of media content and generates a playlist based on the items of the catalog having the lowest costs.

The example embodiments of the invention presented herein are directed to methods systems and computer program products for generating media content playlists which are described herein in terms of an example playlist generator for generating song playlists. This description is not intended to limit the application of the example embodiments presented herein. In fact after reading the following description it will be apparent to one skilled in the relevant art s how to implement the following example embodiments in alternative embodiments to generate playlists for different types of media content items such as video movies and the like.

Generally a playlist generation device creates a playlist from a catalog of songs based on an arbitrary set of rules. The playlist generation device can generate distinct playlists by responding to implicit and explicit tunings under the control of a content programmer e.g. a DJ while allowing personalization for individual users to drive a unique playlist experience for each user.

API receives a request from a requestor interface referred to herein simply as requestor which includes elements that identify one or more rule primitives as well as corresponding values of parameters of the rule primitive which are necessary to generate a playlist for a given collection of corresponding rules and constrained to a catalog of songs stored in catalog database . The corresponding rules are stored in a rules database . Upon API receiving a request from a requestor system e.g. a processor of system issues the request a session identifier which can be used by requestor to make additional API calls for additional playlists. Specific rules from rules database catalog elements from catalog database and a playlist session history from playlist session history database are retrieved based on the request. Playlist engine evaluator in turn operates on this information to identify a song to be played next. System then returns the playlist response to requestor .

Generally a rule is based on a combination of at least one rule primitive and values of parameters that the rule primitive acts on. Particularly a rule is instantiated using the rule primitive with the parameter values it needs to run a computation.

Rule primitives and the corresponding parameter values are customizable by requestor . Requestor may also receive input from another user e.g. an end user through another interface not shown . The rule parameters and values relate to for example a particular minimum maximum or value of an attribute of a parameter a weight given to the rule metadata related to the media content e.g. songs video movies etc. and the like. Table 1 below lists example rule primitives.

As will be explained below in connection with a rule may also be associated with a selector that describes the conditions under which the rule should run.

Each instantiated rule an instantiated rule referred to sometimes as simply rule is assigned a separate ID rule identifier and plural rules are gathered into a rule set which is assigned another identifier a rule set identifier . The rule set and its corresponding rule set identifier are passed into API and used in one embodiment to identify the next song to be played. In another embodiment the rule set and its corresponding rule set identifier are passed into API to generate a new playlist. In yet another embodiment the playlist session can be steered by enabling or disabling one or more rule sets.

Referring again to rules are stored in a rules database . The rules can be customized for example by requestor through the API or optionally through another independent API referred to as a rule API not shown .

In this example rule parameters include an attribute on which to operate and a set of values to make use of a weight and a selector all of which in combination govern the constraints and effects of the time quota rule.

Particularly in this example implementation no less than one 1 song min quota and no more than four 4 songs max quota that have a custom.liveness attribute value of L Live should be included in a playlist in a time span of one 1 hour. In this example custom.liveness refers to recordings that are live. As will be understood other attributes and related parameters and parameter values can be used.

Time quota rule primitive also includes an optional selector that is used to describe the conditions under which the rule should run Selector Rule . As explained in more detail below with respect to a selector can have an optional set of parameters that are used to govern the selector and a set of parameters.

Referring to the beam search is particularly used to build a search tree of possible playlist candidates P. At each level of the tree e.g. P P P P P P all possible successor states are generated by applying each active rule in the rule set to each possible candidate song and summing the individual rule costs to get a total cost for each candidate song. This candidate cost is combined with the costs for predecessor songs in the tree to give a total cost for the candidate playlist at that level. The resulting successor states are sorted in order of increasing costs. In turn the N lowest costs states where N is an integer are retained. Only these states are expanded in the next iteration. The process of expanding and pruning states continues until the desired playlist length is achieved Thus only the path with lowest total cost is selected as the playlist.

Each rule can be expressed as a numeric cost when evaluated with a song. In some cases the rule is governed by the song by itself. If the cost is zero 0 it means the rule is met. The cost may also be a number that is greater than zero to indicate the extent to which the rule was not precisely met. All the rules that are part of a rule set are applied to each song and a combined score is generated for each song. The closer to zero the better a candidate is as a song to be inserted e.g. played at a particular point in a playlist. A cost is computed over every song in the pool and then songs that have the lowest cost that are equally valid to be played next.

One of the components of cost can be an attribute on the song. Another component of cost can be the playlist history. For example a rule can be do not play a song of a particular category immediately after another song of the particular category has been played. The cost in that case thus takes into account the playlist history. Particularly the cost of a particular content item in the catalog is adjusted based on the playlist history and thus the overall score of an item takes into account whether other items in the same category were previously played. The playlist history and the other weightings associated with the media content items and rules thus drive the selection of songs.

Cost is the sum of all the rules each of which includes a mathematical formula. For example the time quota rule has a specific mathematical formulation the frequency map rule has another specific mathematical formulation. The cost of a song is the aggregate of each of the costs of each of the rule parameter values that are applied to these formulas. The particular mathematical formula that is used thus defines the relationship of the various values attributes and weights of a given rule primitive and a respective target.

In an example implementation a beam search is performed across X number of songs where X is an integer the tree is generated several times to calculate the cost several steps down the line. Particularly given all of the cost functions across the e.g. 10 songs the songs that have high costs are pruned such that the songs with the lower costs are candidates to be played.

The beam can be run for every song and every rule set once as well as for the subsequent songs to ensure the best overall path. Thus it is the cost of multiple steps through the playlist engine evaluator of executing the beam to prevent running out of songs or getting to a point where the cost is too high for example two or three songs into the playlist.

Aspects of the embodiments discussed above can take into account rules that are contradictory. For example a song that is very popular but not fast may be desirable. However many songs that are popular are fast as well. Because there is a tension between such rules e.g. popularity vs. tempo the beam is applied across several rules and eventually the content having the best match is approximated.

Another example rule primitive is referred to as the closer rule primitive. The closer rule primitive is used to locate media content e.g. songs videos movies whose attributes have values that are relatively close to a certain target value. For example a target value of the tempo of a song may be selected e.g. 120 beats per minute . The costs of songs that have that selected tempo e.g. a tempo of 120 beats per minute have a cost of zero 0 and songs whose tempo is faster or slower will have a higher cost. A tempo of 200 beats per minute for example will have a higher cost e.g. 200 120 80 . It will be understood that the particular unit and range of a rule primitive will correspond to the particular rule primitive. For example tempo is in beats per minute and may range between 40 200 to include for example Grave through Prestissimo .

Other rule primitives may have binary values representing a yes or no . Alternatively a rule primitive can have a range may vary and be for example from 0 to infinity or other value defined as representing infinity in a computer such as a maximum floating point value.

As explained above a rule primitive can be associated with a weight e.g. of of . If a weight is associated with the rule primitive the combination of the weight and the calculated cost s are evaluated to determine how important the instantiation of the rule primitive is. The weight is a multiplier which when multiplied to the cost determines whether a song should be included in the playlist. Thus a total cost that is high e.g. high cost low weight will have less of a chance to being added to the playlist than a song with a lower total cost e.g. high cost low weight having a high cost multiplied by a low weight will be included in the playlist.

Another example rule primitive is the every rule primitive. The every rule primitive requires that every Nsong has a particular attribute where N is an integer. For example a rule primitive may require that every Nsong has the attribute popular. The playlist engine evaluator takes into account the song attribute and the playlist history session history obtained from the playlist history database which knows where a song is within the playlist so that the Nsong in the playlist can be one that has the particular attribute in this example the attribute popular .

Rule primitives may be independent of the music domain and act on among other things attributes for the purpose generating a value. Rule primitives allow for targeting of content items that have a particular attribute value that is close to a desired fixed value. The specific combination of rule primitives and values is selected and defined by for example a user through a graphical user interface to cause the playlist engine evaluator to build a playlist that provides a desired experience. Multiple rule primitives can thus be evaluated for any given playlist.

As explained above rules have rule primitives specific parameters a weight and a selector. A selector is a pre condition that gets evaluated to decide whether the rule should be used in the cost computation. The selector is another computation function that will evaluate to either true or false. If the selector is true then the rule is used in the song cost computation. If the selector is false then the rule is ignored.

In this example a particular rule can be applied during predetermined periods of a playlist session. This allows a user e.g. DJ or content programmer to generate a particular experience.

As shown in the interface includes selectors and associated with two rules that have been defined as RULE 1 and RULE 2 respectively. In this example implementation the selectors are using the rule primitive parameter referred to as enabled window . These example selectors in particular define a criterion to be evaluated in order to determine the associated rule should be applied. In the example of the RULE 2 is applied for the first N e.g. N 10 songs. That is the selector of RULE 2 returns true if N or fewer songs within the playlist have been played and false if greater than N songs have been played. After RULE 2 is applied for the first N songs the playlist reverts back to a different rule set in this case RULE 1. Thus the selector can be seen as a wrapper around a rule. If the selector evaluates to true then the rule operates. It should be understood that other rule primitives and rule primitive parameters and parameter values can be implemented and still be within the scope of the invention.

Optionally additional rules which do not have selectors can be applied in conjunction with rules that do. For example RULE 3 of is a rule that seeks songs having a tempo of 120 beats per minute. RULE 3 applies to the entire playlist because it does not have a selector. Thus the rule selector operator operates at the rule level and the song score is the sum of all rules that are selected. This allows rules to be generated that take into account for example the history of the playlist and user interface desires. The rule sets are not one set of static rule sets. They can be changed or boosted during the playlist session by using the above described enabled windows feature which allows a rule to be active for only a certain set of songs.

In terms of cost in the example shown in for instance the selector enable window rule primitive is set to determine whether less than 10 songs in the history have been played. If true playlist engine evaluator returns a cost of zero or otherwise returns a cost of one 1 . In an example implementation shown in a user e.g. content programmer or DJ can use the interface to decide what selector to assign to each rule if any. For each song i.e. candidate that exists in the catalog database each rule is run against the song to compute its cost the computation of which takes into account the selector parameter value.

As explained above in the example implementation of two rules are created. RULE 1 is a frequency map rule having a distributions Category 1 has a distribution of 50 and category 2 has a distribution of 50 . Category 1 can be for example genre disco and category 2 can be for example genre rock . The frequency map also has selector enabled window set to greater than 10. RULE 2 is also a frequency map rule having two categories but the distribution of category 1 is 100 and the distribution of category 2 is 0 respectively. RULE 2 also has a selector enable window set at less than or equal to 10 songs. RULE 2 represents the behavior that someone is listening first 10 songs and then RULE 1 falls back to a different behavior e.g. after 10 songs . RULE 3 is based on the Closer rule primitive which seeks songs having approximately 120 beats per minute. RULE 3 does not have a selector and thus operates on all songs in the playlist regardless of position.

The example embodiments described above such as for example the systems and procedures depicted in or discussed in connection with or any part or function thereof may be implemented by using hardware software or a combination of the two. The implementation may be in one or more computers or other processing systems. While manipulations performed by these example embodiments may have been referred to in terms commonly associated with mental operations performed by a human operator no human operator is needed to perform any of the operations described herein. In other words the operations may be completely implemented with machine operations. Useful machines for performing the operation of the example embodiments presented herein include general purpose digital computers or similar devices.

The computer may include without limitation a processor device a main memory and an interconnect bus . The processor device may include without limitation a single microprocessor or may include a plurality of microprocessors for configuring the computer as a multi processor system. The main memory stores among other things instructions and or data for execution by the processor device . The main memory may include banks of dynamic random access memory DRAM as well as cache memory.

The computer may further include a mass storage device peripheral device s portable storage medium device s input control device s a graphics subsystem and or an output display . For explanatory purposes all components in the computer are shown in as being coupled via the bus . However the computer is not so limited. Devices of the computer may be coupled via one or more data transport means. For example the processor device and or the main memory may be coupled via a local microprocessor bus. The mass storage device peripheral device s portable storage medium device s and or graphics subsystem may be coupled via one or more input output I O buses. The mass storage device may be a nonvolatile storage device for storing data and or instructions for use by the processor device . The mass storage device may be implemented for example with a magnetic disk drive or an optical disk drive. In a software embodiment the mass storage device is configured for loading contents of the mass storage device into the main memory .

The portable storage medium device operates in conjunction with a nonvolatile portable storage medium such as for example a compact disc read only memory CD ROM to input and output data and code to and from the computer . In some embodiments the software for storing an internal identifier in metadata may be stored on a portable storage medium and may be inputted into the computer via the portable storage medium device . The peripheral device s may include any type of computer support device such as for example an input output I O interface configured to add additional functionality to the computer . For example the peripheral device s may include a network interface card for interfacing the computer with a network .

The input control device s provide a portion of the user interface for a user of the computer . The input control device s may include a keypad and or a cursor control device. The keypad may be configured for inputting alphanumeric characters and or other key information. The cursor control device may include for example a mouse a trackball a stylus and or cursor direction keys. In order to display textual and graphical information the computer may include the graphics subsystem and the output display . The output display may include a cathode ray tube CRT display and or a liquid crystal display LCD . The graphics subsystem receives textual and graphical information and processes the information for output to the output display .

Each component of the computer may represent a broad category of a computer component of a general and or special purpose computer. Components of the computer are not limited to the specific implementations provided here.

Portions of the example embodiments of the invention may be conveniently implemented by using a conventional general purpose computer a specialized digital computer and or a microprocessor programmed according to the teachings of the present disclosure as is apparent to those skilled in the computer art. Appropriate software coding may readily be prepared by skilled programmers based on the teachings of the present disclosure.

Some embodiments may also be implemented by the preparation of application specific integrated circuits field programmable gate arrays or by interconnecting an appropriate network of conventional component circuits.

Some embodiments include a computer program product. The computer program product may be a storage medium or media having instructions stored thereon or therein which can be used to control or cause a computer to perform any of the procedures of the example embodiments of the invention. The storage medium may include without limitation a floppy disk a mini disk an optical disc a Blu Ray Disc a DVD a CD ROM a micro drive a magneto optical disk a ROM a RAM an EPROM an EEPROM a DRAM a VRAM a flash memory a flash card a magnetic card an optical card nanosystems a molecular memory integrated circuit a RAID remote data storage archive warehousing and or any other type of device suitable for storing instructions and or data.

Stored on any one of the non transitory computer readable medium or media some implementations include software for controlling both the hardware of the general and or special computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the example embodiments of the invention. Such software may include without limitation device drivers operating systems and user applications. Ultimately such computer readable media further includes software for performing example aspects of the invention as described above.

Included in the programming and or software of the general and or special purpose computer or microprocessor are software modules for implementing the procedures described above.

While various example embodiments of the invention have been described above it should be understood that they have been presented by way of example and not limitation. It is apparent to persons skilled in the relevant art s that various changes in form and detail can be made therein. Thus the invention should not be limited by any of the above described example embodiments but should be defined only in accordance with the following claims and their equivalents.

In addition it should be understood that the figures are presented for example purposes only. The architecture of the example embodiments presented herein is sufficiently flexible and configurable such that it may be utilized and navigated in ways other than that shown in the accompanying figures.

Further the purpose of the Abstract is to enable the U.S. Patent and Trademark Office and the public generally and especially the scientists engineers and practitioners in the art who are not familiar with patent or legal terms or phraseology to determine quickly from a cursory inspection the nature and essence of the technical disclosure of the application. The Abstract is not intended to be limiting as to the scope of the example embodiments presented herein in any way. It is also to be understood that the procedures recited in the claims need not be performed in the order presented.

