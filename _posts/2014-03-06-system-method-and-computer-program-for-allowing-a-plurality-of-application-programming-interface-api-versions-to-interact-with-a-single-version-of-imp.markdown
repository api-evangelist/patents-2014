---

title: System, method, and computer program for allowing a plurality of application programming interface (API) versions to interact with a single version of implementation code
abstract: A system, method, and computer program product are provided for allowing a plurality of application programming interface (API) versions to interact with a single version of implementation code. A system, method, and computer program product are provided for allowing a single version of core code to interact with a plurality of customization versions. In use, at least one first data object is received. Additionally, it is determined whether the at least one first data object is associated with a first data object version corresponding to a first data structure associated with a first API version. Additionally, it is determined whether the first data object version associated with the first data structure is compatible with an implementation code, the implementation code being compatible with a second data object version corresponding to a second data structure associated with a second API version. Moreover, the at least one first data object associated with the first data object version is automatically converted to the second data object version corresponding to the second data structure, such that the at least one first data object is compatible with the implementation code and the second API version. Computer generated code is used to convert data objects to compatible versions. The versions of data objects and data structures are determined dynamically at runtime. The data objects are converted to compatible versions dynamically at runtime.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09063748&OS=09063748&RS=09063748
owner: Amdocs Software Systems Limited
number: 09063748
owner_city: Dublin
owner_country: IE
publication_date: 20140306
---
This application claims the benefit of U.S. Provisional Application No 61 803 117 filed Mar. 19 2013 the entire contents of which are incorporated herein by reference.

The present invention relates to communication between devices and more particularly to allowing multiple versions of an API to interact with a single version of a software program.

Introduction of new functionalities to a software program may be accompanied with changes in data structures. Changes in data structures may break backwards compatibility with existing clients and or customizations in existing installations. Such data structure changes typically force clients and customizations to align their code which may result in costly development and testing cycles often spanning multiple software vendors and system integrators.

One way to mitigate this problem is to expose multiple versions of APIs to be used by clients and customizations. Once a new version of an API is available clients and customizations can be gradually upgraded to use the new API and until they do so they may use the old API. However versioning of the APIs may incur replication of all or most of the product code implementing those APIs.

However such code replication is costly and difficult to maintain. Enhancements and bug fixes need to be developed and tested in all versions. Resources that are shared by all code versions such as database schema need to support compatibility with all code versions. The cost and complexity further increases with the increase in complexity of the product and introduction of more versions.

A system method and computer program product are provided for allowing a plurality of application programming interface API versions to interact with a single version of implementation code. In use at least one first data object is received. Additionally it is determined whether the at least one first data object is associated with a first data object version corresponding to a first data structure associated with a first API version. Additionally it is determined whether the first data object version associated with the first data structure is compatible with an implementation code the implementation code being compatible with a second data object version corresponding to a second data structure associated with a second API version. Moreover the at least one first data object associated with the first data object version is automatically converted to the second data object version corresponding to the second data structure such that the at least one first data object is compatible with the implementation code and the second API version.

Coupled to the network is a plurality of devices. For example a server computer and an end user computer may be coupled to the network for communication purposes. Such end user computer may include a desktop computer lap top computer and or any other type of logic. Still yet various other devices may be coupled to the network including a personal digital assistant PDA device a mobile phone device a television etc.

As shown a system is provided including at least one central processor which is connected to a communication bus . The system also includes main memory e.g. random access memory RAM etc. . The system also includes a graphics processor and a display .

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive etc. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory the secondary storage and or any other memory for that matter. Such computer programs when executed enable the system to perform various functions to be set forth below for example . Memory storage and or any other storage are possible examples of tangible computer readable media.

In use at least one first data object is received. See operation . As shown further the method includes determining whether the at least one first data object is associated with a first data object version corresponding to a first data structure associated with a first API version. See operation .

In the context of the present description a data object refers to any runtime instance of at least one data structure. For example computer servers typically define and implement APIs. Client devices use the APIs to interact with the server. Data is passed between client and the server in the form of data objects. Data objects are runtimes instances of data structures. Each API may be associated with zero or more specific data structures.

In the context of the present description a data structure refers to any structure of data associated with one or more APIs. For example the data structure may include a structure and or format of data compatible with an API. Further in the context of the present description an API generally refers to an interface that specifies how some software components should interact with each other.

As shown further in the method further includes determining whether the first data object version associated with the first data structure is compatible with an implementation code the implementation code being compatible with a second data object version corresponding to a second data structure associated with a second API version. See operation . The implementation code may include any type of code software and or computer program.

Additionally the at least one first data object associated with the first data object version is automatically converted to the second data object version corresponding to the second data structure such that the at least one first data object is compatible with the implementation code and the second API version. See operation . Utilizing this technique a single version of implementation code may interact with multiple API versions.

For example the first API and second API may be different versions because the second API evolved to provide new functionality etc. e.g. the first API version may include an older version than the second API version etc. . In some cases changing the API may include changing the data structures used by the API. However changing the data structures of an existing API may break backwards compatibility with existing clients.

Accordingly the method may function to allow the use of data structures associated with only one version of core implementation code. For example if the version of the data structures used by a particular version of the API is different than the version of the data structures used by the implementation code the data objects may be converted from one version to another. In this way one version of implementation code may accommodate multiple versions of the API.

With further reference to in one embodiment the at least one first data object may be received from a client device associated with the first API version. Additionally the at least one first data object may be received by a server device including the implementation code the server device being associated with the first API version and the second API version.

In one embodiment the implementation code may include core product business code. Of course in various embodiments the implementation code may include any type of code and or software program. In one embodiment the implementation code may be located on a host and or server. In either case in one embodiment automatically converting the at least one first data object associated with the first data object version to the second data object version corresponding to the second data structure may function to allow a single version of the core product business code to interact with a plurality of API versions.

Further in one embodiment the implementation code may be associated with one or more customization routines. In this case determining whether the first data object version associated with the first data structure is compatible with the implementation code may include determining a version of one or more data structures used by at least one of core routines or customization routines associated with the implementation code. In one embodiment automatically converting the at least one first data object associated with the first data object version to the second data object version corresponding to the second data structure may include converting the at least one first data object associated with the first data object version to a version capable of being utilized by the customization routine.

For example a software program may allow users and system integrators to customize its behavior. This program may include core routines with functionality that is constant and customization routines with functionality that may be different for different users or different installations. The core routines may provide hooks in which customization routines may be plugged in and or accessed.

Data may be passed between core and customization routines in the form of data objects which are instances of data structures etc. . The core routine may define an API that is implemented by customization. Without utilizing the techniques described herein if the data structures used by the API changes it may break backward compatibility with customization s implementations. Further all customization routines may not be changed to use a different version of data structures at once.

Thus the method may be utilized to ensure backwards compatibility with the customization routines is not broken even if the data structures used by the core routine changes. For example in one embodiment the data objects may automatically be converted from one version to another when they are passed between the core and customization routines.

In one embodiment the method may further include mapping first data associated with the first data object version corresponding to the first data structure to second data associated with the second data object version corresponding to the second data structure. In this case automatically converting the at least one first data object associated with the first data object version to the second data object version corresponding to the second data structure may include utilizing the mapping.

Further in one embodiment the method may include automatically generating code for mapping the first data associated with the first data object version corresponding to the first data structure to the second data associated with the second data object version corresponding to the second data structure. In this case the automatically generated code for mapping the first data associated with the first data object version corresponding to the first data structure to the second data associated with the second data object version corresponding to the second data structure may include at least one automatically generated data object convertor.

For example a system may have multiple versions of the data structures. Data objects might have to be converted from one version to another. However a large system can typically have a large number of data structures. The logic of mapping data of one version to another version may be labor intensive because manually coding this logic for every data structure is repetitive voluminous and error prone. This task becomes more voluminous as the number of data structures and the number of versions increase.

Accordingly in one embodiment logic for mapping data of one version to another may be coded in a computer program which then automatically generates the code e.g. source or binary etc. implementing the logic of data conversion for each data structure. In one embodiment the generated code may be utilized to convert data objects from one version to another.

Still yet in one embodiment the method may further include receiving at least one third data object from a client device and determining the at least one third data object is associated with a third data object version corresponding to a third data structure associated with a third API version where the third API version is different from the first API version and the second API version. In this case the at least one third data object associated with the third data object version may be automatically converted to the second data object version corresponding to the second data structure such that the at least one third data object is compatible with the implementation code.

Converting the first data object associated with the first data object version to the second data object version may include any number of conversion operations with varying complexities. For example automatically converting the at least one first data object associated with the first data object version to the second data object version corresponding to the second data structure may include copying at least one string field associated with the first data object from a first string field type corresponding to the first data object version to a second string field type associated with the second data object version. As another example automatically converting the at least one first data object associated with the first data object version to the second data object version corresponding to the second data structure may include a validation operation a data manipulation operation a lookup operation to an external data source to obtain mapping logic and or any other type of operation etc.

More illustrative information will now be set forth regarding various optional architectures and uses in which the foregoing method may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

As shown the system includes a server . The server is in communication with a plurality of client devices and e.g. via an API etc. . As an example the client device may include a remote SOAP Simple Object Access Protocol client. As another example the client device may include a remote RIM Remote Method Invocation client. As yet another example the client device may include a local POJO Plain Old Java Object client. Of course these are only examples and in various embodiments any number of clients of various types may be present.

The client devices and are in communication with the API associated with the server . The API may function as an interface to core business logic which is in communication with customization business logic .

In one embodiment the server may define and implement APIs utilized in the system . Further the clients and may use the API s to interact with the server . In operation data may be passed between the clients and and the server in the form of data objects. Data objects are runtime instances of data structures.

Further in operation the system may function such that product business code e.g. the core business logic and or the customization business logic etc. is able interact with multiple API versions. For example the server may include and implement computer generated data object convertors and just in time adaptation e.g. as part of the API in one embodiment etc. . These techniques help to reduce the cost complexity and time to release new features as well as simplify defect fixing and enhancements.

Moreover in various embodiments the server may function to implement multiple versions of API signatures with a single version of underlying business code enable support for a single version of core product code interacting with different versions of product customizations utilize computer generated code to convert data objects from one version to another and or utilize just in time adaptation for data objects passed between core and customization code etc.

For example in one embodiment the server may include logic for mapping data of one version to another where such logic is coded in a computer program which then generates the code source or binary implementing the logic of data conversion for each data structure. In this case the generated code may include computer code to convert data objects from one version to another. In various embodiments this may be implemented to reduce development and testing effort to introduce new data structures thus significantly reducing overall project cost and eliminate human errors. Furthermore bug fixes and enhancements would be simple to deploy and the time to release newer versions would be reduced.

As shown the system includes a server . The server is in communication with a plurality of client devices and via an API and or an API etc. . In one embodiment the client device may be associated with a first data structure associated with a first version. Furthermore the client device may be associated with the first data structure associated with a first version and a second data structure associated with a second version. Additionally in one embodiment the client device may be associated with the second data structure associated with the second version and or a third data structure associated with a third version.

The client devices and are further in communication with one or more APIs associated with the server . The API may function as an interface to implementation code . In operation the first API associated with the first version may receive at least one first data object from the first client device or the second client device . At least one computer generated data object converter may work in conjunction with at least one computer generated adaptation layer to determine the first data object is associated with a first data object version corresponding to a first data structure associated with a first API version.

The computer generated adaptation layer may further determine whether the first data object version is compatible with the implementation code the implementation code being compatible with a second data object version corresponding to a second data structure associated with a second API version . The computer generated adaptation layer may further work with the computer generated data object converter to automatically convert the first data object associated with the first data object version to the second data object version corresponding to the second data structure such that the first data object is compatible with the implementation code .

As shown further in one embodiment the second client device and the third client device may send a data object associated with the second version to the second API version which may then communicate with the implementation code without conversion. Of course if the third client device was compatible with a third version of an API the computer generated data object converter or another convertor could be used to convert a third data object associated with a third data structure version to be compatible with the implementation code . In various embodiments any number of client devices representing a variety of versions may be accommodated.

As an example of the different API and data structure versions a first API may represent createCustomer v1.Name name v1.SocialSecurityNumber id where v1.Name type contains 3 String fields firstName middleName lastName and v1.SocialSecurityNumber type contains a field of type integer . On the other hand a second new version of the createCustomer API may be createCustomer v2.Name name v2.SocialSecurityNumber id where v2.Name type is identical to v1.Name type but v2.SocialSecurityNumber contains a field of type long integer . Thus in one embodiment the data object converter may be utilized to convert data objects associated with the first version to be compatible with the second version of the code.

As shown the system includes a server . The server includes core routines e.g. associated with a second version etc. . Further the server includes a computer generated data object convertor a just in time adaptation layer and a version calculator which may function to determine data object versions and convert the data objects to compatible versions. Further the server includes at least one customization routine e.g. associated with a first version etc. and at least one customization routine e.g. associated with a second version etc. .

In operation the core routines of a single version may interact with customization routines and of different versions by using the services of the just in time adaptation layer .

For example in a particular runtime environment some customization routines may use new version of data structures and some customization routines may continue to use older version of data structures. Before a call is dispatched to the customization routine the just in time adaptation layer may use the version calculator to determine the version of data objects supplied by the core routines and the version of the data structures used by the customization routines and . Further the just in time adaptation layer may compare the version of data objects used by the core routines with the version of data structures used by the customization routines and . If the versions do not match the data objects may be converted to the version used by customization routines by using computer generated data object convertor . Similar data conversion logic may be applied to convert data objects returned by customization routines before these objects are presented to the core routines as illustrated in .

The system may implement just in time adaptation. The decision whether to convert data objects from one version to another may be taken dynamically at runtime by determining the version of data structures used by core and customization routines. As an example when using Java programming language the version of the data structures can be determined by using Java Reflection API.

In one embodiment in order to reduce the cost of maintenance a system may deprecate older versions of the data structures when newer versions are introduced. Deprecated data structures may be subsequently deleted in later releases. In such cases customization routines could start using newer versions of data structures at some point of time. However in some cases it may not be feasible to change all customization routines at once. The system may function to allow a gradual change of customization routines to use newer versions of data structures.

As shown the system illustrates the function of computer generated data object convertors in accordance with one embodiment. As one example of operation the conversion from v1.Name type to v2.Name type may involve a copying of String fields from one type to another. As another example the conversion of v1.SocialSecurityNumber type to v2.SocialSecurityNumber type may involve validation data manipulation or possibly a lookup in an external data source to obtain the mapping logic etc.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

