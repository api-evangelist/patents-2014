---

title: Computing system and method for representing volumetric data for a scene
abstract: A computing system and method for representing volumetric data for a scene. One embodiment of the computing system includes: (1) a memory configured to store a three-dimensional (3D) clipmap data structure having at least one clip level and at least one mip level, and (2) a processor configured to generate voxelized data for a scene and cause the voxelized data to be stored in the 3D clipmap data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09367946&OS=09367946&RS=09367946
owner: NVIDIA CORPORATION
number: 09367946
owner_city: Santa Clara
owner_country: US
publication_date: 20140124
---
This application claims the benefit of U.S. Provisional Application Ser. No. 61 892 288 filed by Bolotov et al. on Oct. 17 2013 entitled A Method for Optimizing Regions for Voxelization Updates and U.S. Provisional Application Ser. No. 61 892 316 filed by Bolotov et al. on Oct. 17 2013 entitled Using Clipmaps to Represent Volumetric Data for GI and AO Algorithms commonly assigned with this application and incorporated herein by reference.

This application is directed in general to representing volumetric data for a three dimensional 3D scene and more specifically to using a 3D clipmap to represent the volumetric data.

Many computer graphic images are created by mathematically modeling the interaction of light with a 3D scene from a given viewpoint. This process called rendering generates a two dimensional 2D image of the scene from the given viewpoint and is analogous to taking a photograph of a real world scene.

As the demand for computer graphics and in particular for real time computer graphics has increased computer systems with graphics processing subsystems adapted to accelerate the rendering process have become widespread. In these computer systems the rendering process is divided between a computer s general purpose central processing unit CPU and the graphics processing subsystem architecturally centered about a graphics processing unit GPU . Typically the CPU performs high level operations such as determining the position motion and collision of objects in a given scene. From these high level operations the CPU generates a set of rendering commands and data defining the desired rendered image or images. For example rendering commands and data can define scene geometry lighting shading texturing motion and or camera parameters for a scene. The graphics processing subsystem creates one or more rendered images from the set of rendering commands and data.

Scene geometry is typically represented by geometric primitives such as points lines polygons for example triangles and quadrilaterals and curved surfaces defined by one or more two or three dimensional vertices. Each vertex may have additional scalar or vector attributes used to determine qualities such as the color transparency lighting shading and animation of the vertex and its associated geometric primitives.

Many graphics processing subsystems are highly programmable through an application programming interface API enabling complicated lighting and shading algorithms among other things to be implemented. To exploit this programmability applications can include one or more graphics processing subsystem programs which are executed by the graphics processing subsystem in parallel with a main program executed by the CPU. Although not confined merely to implementing shading and lighting algorithms these graphics processing subsystem programs are often referred to as shading programs programmable shaders or simply shaders. 

A variety of shading programs are directed at modeling illumination in a scene. The physical plausibility of rendered illumination often depends on the application more specifically whether or not the rendering is done in real time. Physically plausible illumination at real time frame rates is often achieved using approximations. For example ambient occlusion is a popular approximation because of its high speed and simple implementation. Another example is directional occlusion. Many algorithms can only approximate direct illumination which is light coming directly from a light source.

Global illumination or GI is a concept that accounts for both direct illumination and indirect illumination which is light that reflects off other surfaces in rendering the scene. In doing so a significantly more realistic image is achievable. However real time global illumination remains problematic for large and dynamic scenes. Efforts to mitigate the latency introduced by these comprehensive illumination algorithms are ongoing. For example some algorithms partially pre compute illumination. Another example is instant radiosity which models indirect lighting as a set of point lights the contributions of which are accumulated over multiple rendering passes. Yet another approach is to limit indirect lighting to a single bounce under the assumption that one bounce indirect illumination is sufficiently realistic. Still real time frame rates are typically only achievable through approximations.

Ambient occlusion or AO is an example of a shading algorithm commonly used to add a global illumination look to rendered images. AO is not a natural lighting or shading phenomenon. In an ideal system each light source would be modeled to determine precisely the surfaces it illuminates and the intensity at which it illuminates them taking into account reflections refractions scattering dispersion and occlusions. In computer graphics this analysis is accomplished by ray tracing or ray casting. The paths of individual rays of light are traced throughout the scene colliding and reflecting off various surfaces.

In non real time applications each surface in the scene can be tested for intersection with each ray of light producing a high degree of visual realism. This presents a practical problem for real time graphics processing rendered scenes are often very complex incorporating many light sources and many surfaces such that modeling each light source becomes computationally overwhelming and introduces large amounts of latency into the rendering process. AO algorithms address the problem by modeling light sources with respect to an occluded surface in a scene as white hemispherical lights of a specified radius centered on the surface and oriented with a normal vector at the occluded surface. Surfaces inside the hemisphere cast shadows on other surfaces. AO algorithms approximate the degree of occlusion caused by the surfaces resulting in concave areas such as creases or holes appearing darker than exposed areas. AO gives a sense of shape and depth in an otherwise flat looking scene.

The most realistic AO techniques are global the illumination at each point is a function of other geometry in the scene. Screen space AO SSAO can render only local effects and therefore fails to recognize the more subtle illuminations that lend realism. For this reason SSAO will not be further described herein.

Several methods are available to compute global AO but its sheer computational intensity makes it an unjustifiable luxury for most real time graphics processing systems. To appreciate the magnitude of the effort AO entails consider a given point on a surface in the scene and a corresponding hemispherical normal oriented light source surrounding it. The illumination of the point is approximated by integrating the light reaching the point over the hemispherical area. The fraction of light reaching the point is a function of the degree to which other surfaces obstruct each ray of light extending from the surface of the sphere to the point.

One aspect provides a computing system. In one embodiment the system includes 1 a memory configured to store a three dimensional 3D clipmap data structure having at least one clip level and at least one mip level and 2 a processor configured to generate voxelized data for a scene and cause the voxelized data to be stored in the 3D clipmap data structure.

Another aspect provides a method of representing volumetric data for a scene. In one embodiment the method includes 1 voxelizing the scene into a 3D clipmap centered about a viewpoint and 2 employing the 3D clipmap in computing an effect for the viewpoint.

Yet another aspect provides a graphics processing subsystem. In one embodiment the subsystem includes 1 a memory configured to store a three dimensional 3D clipmap having a plurality of levels of detail LODs and 2 a graphics processing unit GPU coupled to the memory and configured to 2a voxelize a scene thereby generating the 3D clipmap including at least one clip level and at least one mip level and 2b cause the at least one clip level and the at least one mip level to be respectively written to the memory.

A mipmap is a collection of correlated images of increasingly reduced resolution. Mip is actually an acronym representing the Latin phrase multum in parvo meaning much in little. Mipmaps are often described as resolution pyramids starting with level zero the largest and finest level. Each lower level represents the image using half as many texels in each dimension. Consequently for a two dimensional 2D image each lower level consumes one quarter of the memory required for the level above. For a 3D volume each lower level consumes one eighth the memory required for the level above. Rendering processes can gain access to the various levels of detail LODs to use the texels contained therein to render an image. Mipmaps are intended to increase rendering speed and reduce aliasing.

A clipmap is a representation of a partial mipmap in which the finest levels are clipped to a specified maximum size. Rather than the pyramidal shape seen in mipmaps the clipmap more resembles an obelisk. Clipped levels are referred to as clip levels and unclipped levels are referred to as mip levels. A clipmap has at least one mip level and at least one clip level. The mip levels of a clipmap represent the same spatial region of a scene with increasing resolution beginning with the coarsest level. Each of the clip levels has the same resolution that is equal to the resolution of the finest mip level. While the clip levels maintain a constant resolution across the corresponding LODs the respective spatial regions represented shrink as the LODs become finer. This representation reduces the amount of memory required to represent parts of the scene with high spatial resolution and cover a large region of the scene at the same time.

Clipmaps resulted from the realization that the majority of a mipmap is not used to render a single frame of a scene. In fact the viewpoint and display resolution determine the part of the mipmap that is used to render a frame. The clipmap is intended to be the minimal subset of the mipmap needed to render each frame. Thus clipmaps should be updated as frames change over time. For this reason practical clipmaps are updatable.

It is realized herein the clipmap data structure should be expanded to represent volumetric data for a 3D scene. Volumetric data is packaged in a volumetric pixel or voxel. Clipmaps were originally implemented as 2D mipmaps with the finest levels clipped such that they have the same number of texels but cover different size spatial regions. It is realized herein a 3D clipmap has advantages over alternative representations such as a sparse voxel octree in that it can be updated more quickly and more quickly sampled than an octree.

Generally graphics processing hardware e.g. GPUs does not support use of 3D clipmaps. It is realized herein that 3D clipmaps can be efficiently implemented on GPUs that provide direct control over virtual memory. In certain embodiments it is realized herein 3D clipmaps can be implemented on GPUs lacking support for 2D clipmaps. It is realized herein that a 3D mipmap texture can be created to store the 3D clipmap. Each level of the 3D mipmap data structure contains memory pages in which voxels are stored. Most of the memory pages the 3D mipmap refers to are unmapped when storing a 3D clipmap. Only the regions of the 3D mipmap that correspond to regions in the 3D clipmap are mapped.

Clipmaps can be used in many graphics rendering processes including ambient occlusion and global illumination. To evaluate a viewpoint in a particular scene the scene is voxelized to form a clipmap that is centered on or in some embodiments slightly offset from the viewpoint. Generally when computing an effect on the viewpoint geometry that is further from the viewpoint has less impact on the computation than nearer geometry. When processing the viewpoint samples are taken from the various LODs of the clipmap. Nearer samples are taken from the finer LODs and distant samples are taken from the coarser LODs.

Before describing various embodiments of the graphics processing subsystem and method of representing volumetric data for a scene introduced herein a computing system within which the graphics processing subsystem or method maybe embodied or carried out will be described.

As shown the system data bus connects the CPU the input devices the system memory and the graphics processing subsystem . In alternate embodiments the system memory may connect directly to the CPU . The CPU receives user input from the input devices executes programming instructions stored in the system memory operates on data stored in the system memory and configures the graphics processing subsystem to perform specific tasks in the graphics pipeline. The system memory typically includes dynamic random access memory DRAM employed to store programming instructions and data for processing by the CPU and the graphics processing subsystem . The graphics processing subsystem receives instructions transmitted by the CPU and processes the instructions in order to render and display graphics images on the display devices .

As also shown the system memory includes an application program an application programming interface API and a graphics processing unit GPU driver . The application program generates calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images. The application program also transmits zero or more high level shading programs to the API for processing within the GPU driver . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on one or more shading engines within the graphics processing subsystem . The API functionality is typically implemented within the GPU driver . The GPU driver is configured to translate the high level shading programs into machine code shading programs that are typically optimized for a specific type of shading engine e.g. vertex geometry or fragment .

The graphics processing subsystem includes a graphics processing unit GPU an on chip GPU memory an on chip GPU data bus a GPU local memory and a GPU data bus . The GPU is configured to communicate with the on chip GPU memory via the on chip GPU data bus and with the GPU local memory via the GPU data bus . The GPU may receive instructions transmitted by the CPU process the instructions in order to render graphics data and images and store these images in the GPU local memory . Subsequently the GPU may display certain graphics images stored in the GPU local memory on the display devices .

The GPU includes one or more streaming multiprocessors . Each of the streaming multiprocessors is capable of executing a relatively large number of threads concurrently. Advantageously each of the streaming multiprocessors can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying of physics to determine position velocity and other attributes of objects and so on. Furthermore each of the streaming multiprocessors may be configured as a shading engine that includes one or more programmable shaders each executing a machine code shading program i.e. a thread to perform image rendering operations. The GPU may be provided with any amount of on chip GPU memory and GPU local memory including none and may employ on chip GPU memory GPU local memory and system memory in any combination for memory operations.

The on chip GPU memory is configured to include GPU programming code and on chip buffers . The GPU programming may be transmitted from the GPU driver to the on chip GPU memory via the system data bus . The GPU programming may include a machine code vertex shading program a machine code geometry shading program a machine code fragment shading program or any number of variations of each. The on chip buffers are typically employed to store shading data that requires fast access in order to reduce the latency of the shading engines in the graphics pipeline. Since the on chip GPU memory takes up valuable die area it is relatively expensive.

The GPU local memory typically includes less expensive off chip dynamic random access memory DRAM and is also employed to store data and programming employed by the GPU . As shown the GPU local memory includes a frame buffer . The frame buffer stores data for at least one two dimensional surface that may be employed to drive the display devices . Furthermore the frame buffer may include more than one two dimensional surface so that the GPU can render to one two dimensional surface while a second two dimensional surface is employed to drive the display devices .

The display devices are one or more output devices capable of emitting a visual image corresponding to an input data signal. For example a display device may be built using a cathode ray tube CRT monitor a liquid crystal display or any other suitable display system. The input data signals to the display devices are typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .

Having described a computing system within which the graphics processing subsystem and method of computing an effect for a viewpoint in a scene may be embodied or carried out various embodiments of the graphics processing subsystem and method will be described.

Mip level is the coarsest LOD in 3D clipmap and includes a single voxel that represents the full spatial extent spanned by 3D clipmap volume . Consequently mip level requires the least memory to store. Mip level doubles the resolution in each dimension with respect to mip level making the resolution eight voxels. Mip level again doubles the resolution in each dimension with respect to mip level making the resolution 64 voxels. As resolution increases from mip level to mip level to mip level the memory necessary to store those LODs also increases. The spatial regions or volumes spanned by mip level mip level and mip level are the same.

Clip level maintains the 64 voxel resolution of mip level increases the detail represented and decreases the spatial region represented by the LOD. In a 3D mipmap representation the resolution would again double in each dimension. However 3D clipmap clips voxels outside the maximum size for each dimension thereby leaving a portion of the full spatial extent volume unrepresented in clip level . Clip level is centered about a viewpoint which is located where the octants of clip level meet.

Clip level is the finest LOD in 3D clipmap and also maintains the 64 voxel resolution of mip level and clip level . Clip level increases the detail represented relative to clip level and decreases the spatial region represented by the LOD. Clip level leaves a larger portion of the full spatial extent volume unrepresented than clip level and is centered about the same viewpoint.

The mip levels of 3D clipmap would span the same volume spanned by resolution cube . Each successive mip level reduces the resolution by one half in each dimension relative to resolution cube resolution cube and resolution cube .

Continuing the embodiment of as the scene changes or as the viewpoint moves the 3D clipmap can be updated by re voxelizing the updated scene. The 3D clipmap generated by voxelizing the scene is then employed in a computation step . At computation step the 3D clipmap is used to compute an effect for the viewpoint about which voxelization was centered in voxelization step . In certain embodiments the 3D clipmap is employed in computing an AO value for the viewpoint. In other embodiments the 3D clipmap is employed in computing a GI value for the viewpoint. Access to the 3D clipmap is based on the position of the viewpoint and the resolution of the frames to be displayed. Geometry nearest the viewpoint typically contributes most to the effect to be computed. As such the 3D clipmap provides the finest LOD nearest the viewpoint. As geometry is sampled that is further from the viewpoint access is had to other LODs that provide less detail. The 3D clipmap is re voxelized as the viewpoint moves such that the finest LOD is centered at the viewpoint. In alternate embodiments the 3D clipmap is re voxelized such that the finest LOD is slightly offset from the viewpoint. The method then ends in an end step .

Those skilled in the art to which this application relates will appreciate that other and further additions deletions substitutions and modifications may be made to the described embodiments.

