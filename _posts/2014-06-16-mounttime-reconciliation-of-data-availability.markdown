---

title: Mount-time reconciliation of data availability
abstract: Systems and methods are disclosed for mount-time reconciliation of data availability. During system boot-up, a non-volatile memory (“NVM”) driver can be enumerated, and an NVM driver mapping can be obtained. The NVM driver mapping can include the actual availability of LBAs in the NVM. A file system can then be mounted, and a file system allocation state can be generated. The file system allocation state can indicate the file system's view of the availability of LBAs. Subsequently, data availability reconciliation can be performed. That is, the file system allocation state and the NVM driver mapping can be overlaid and compared with one another in order to expose any discrepancies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104329&OS=09104329&RS=09104329
owner: APPLE INC.
number: 09104329
owner_city: Cupertino
owner_country: US
publication_date: 20140616
---
This application is a continuation of U.S. patent application Ser. No. 13 323 347 filed on Dec. 12 2011 now U.S. Pat. No. 8 756 458 which is hereby incorporated by reference herein in its entirety.

NAND flash memory as well as other types of non volatile memories NVMs are commonly used for mass storage. For example consumer electronics such as portable media players often include flash memory to store music videos and other media.

A system can store different types of files in an NVM. When the system experiences an error discrepancies can occur between a file system s view of the files stored in the NVM and the actual files that are stored in the NVM. Eventually when the file system needs to access a particular file the system may discover that the file is either corrupt or does not exist in the NVM. This then triggers the file system to attempt to recover the file from an external source. The discovery of discrepancies and subsequent recovery during system operation can be disruptive to the user experience.

Systems and methods are disclosed for mount time reconciliation of data availability. During system boot up a non volatile memory NVM driver can be enumerated and an NVM driver mapping can be obtained. The NVM driver mapping can include the actual availability of LBAs in the NVM. A file system can then be mounted and a file system allocation state can be generated. The file system allocation state can indicate the file system s view of the availability of LBAs. Subsequently data availability reconciliation can be performed. That is the file system allocation state and the NVM driver mapping can be overlaid and compared with one another in order to expose any discrepancies.

Systems and methods for mount time reconciliation of data availability are provided. During system boot up a non volatile memory NVM driver can be enumerated and an NVM driver mapping can be obtained. The NVM driver mapping can include the actual availability of LBAs in the NVM.

A file system can then be mounted. During the mounting process a file system allocation state can be generated which can indicate the file system s view of the availability of LBAs. Subsequently data availability reconciliation can be performed. That is the file system allocation state and the NVM driver mapping can be overlaid and compared with one another in order to expose any discrepancies.

In particular for each available LBA range in the file system allocation state the file system can transmit a command to an NVM interface of the system. Upon receiving the command the NVM interface can determine whether the NVM driver mapping has a consistent state.

If the NVM interface determines that the NVM driver mapping is inconsistent e.g. at least one portion of the LBA range is unavailable the NVM interface can transmit information to the file system indicating this inconsistency. As used herein a LBA range is unavailable if the LBA range is known uncorrectable or unmapped. Upon receiving this information the file system can invoke a policy to restore data associated with the at least one portion of the LBA range.

Electronic device can include system on a chip SoC and non volatile memory NVM . Non volatile memory can include a NAND flash memory based on floating gate or charge trapping technology NOR flash memory erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM Ferroelectric RAM FRAM magnetoresistive RAM MRAM or any combination thereof.

NVM can be organized into blocks which can the smallest erasable unit and further organized into pages which can be the smallest unit that can be programmed or read. In some embodiments NVM can include multiple integrated circuits where each integrated circuit may have multiple blocks. Memory locations e.g. blocks or pages of blocks from corresponding integrated circuits may form super blocks . Each memory location e.g. page or block of NVM can be referenced using a physical address e.g. a physical page address or physical block address .

In some embodiments one or more designated blocks of NVM can store context information. As used herein context information can refer to information associated with the state of the entire NVM at a particular point in time. For example context information can include logical to physical mappings for the blocks of NVM at a particular time. As used herein logical to physical mappings can be mappings between one or more logical addresses e.g. logical sectors and physical page addresses of data pages.

In some embodiments one or more blocks of NVM can include block table of contents TOCs . Each block TOC can include information that maps pages of the block to corresponding logical addresses. In some embodiments the block TOC may include only the logical address e.g. the logical block address LBA or the logical page number for each page that is programmed in the block. In other embodiments the block TOC may also include the relative age of updates made to a page e.g. when a page has been updated relative to other pages . In such embodiments the block TOC can include a logical address age pair for each page that is programmed.

System on a chip can include SoC control circuitry memory and NVM interface . SoC control circuitry can control the general operations and functions of SoC and the other components of SoC or device . For example responsive to user inputs and or the instructions of an application or operating system SoC control circuitry can issue read or write commands to NVM interface to obtain data from or store data in NVM . For clarity data that SoC control circuitry may request for storage or retrieval may be referred to as user data even though the data may not be directly associated with a user or user application. Rather the user data can be any suitable sequence of digital information generated or obtained by SoC control circuitry e.g. via an application or operating system .

SoC control circuitry can include any combination of hardware software and firmware and any components circuitry or logic operative to drive the functionality of electronic device . For example SoC control circuitry can include one or more processors that operate under the control of software firmware stored in NVM or memory .

Memory can include any suitable type of volatile memory such as random access memory RAM e.g. static RAM SRAM dynamic random access memory DRAM synchronous dynamic random access memory SDRAM double data rate DDR RAM cache memory read only memory ROM or any combination thereof. Memory can include a data source that can temporarily store user data for programming into or reading from non volatile memory . In some embodiments memory may act as the main memory for any processors implemented as part of SoC control circuitry .

Memory can include one or more data structures for storing logical to physical mappings. For example memory can include a tree which can provide a mapping between LBA ranges and corresponding physical addresses of NVM . Trees will be described in more detail in connection with .

NVM interface may include any suitable combination of hardware software and or firmware configured to act as an interface or driver between SoC control circuitry and NVM . For any software modules included in NVM interface corresponding program code may be stored in NVM or memory .

NVM interface can perform a variety of functions that allow SoC control circuitry to access NVM and to manage the memory locations e.g. pages blocks super blocks integrated circuits of NVM and the data stored therein e.g. user data . For example NVM interface can interpret the read or write requests from SoC control circuitry perform wear leveling and generate read and program instructions compatible with the bus protocol of NVM .

While NVM interface and SoC control circuitry are shown as separate modules this is intended only to simplify the description of the embodiments of the invention. It should be understood that these modules may share hardware components software components or both. For example SoC control circuitry may execute a software based memory driver for NVM interface .

In some embodiments electronic device can include a target device such as a flash memory drive or Secure Digital SD card that includes NVM and some or all portions of NVM interface e.g. a translation layer discussed below . In these embodiments SoC or SoC control circuitry may act as the host controller for the target device. For example as the host controller SoC can issue read and write requests to the target device.

Electronic device can include file system NVM driver NVM bus controller and NVM . In some embodiments file system and NVM driver may be software or firmware modules and NVM bus controller and NVM may be hardware modules. Accordingly in these embodiments NVM driver may represent the software or firmware aspect of NVM interface and NVM bus controller may represent the hardware aspect of NVM interface .

File system can include any suitable type of file system such as a File Allocation Table FAT file system or a Hierarchical File System Plus HFS and may be part of the operating system of electronic device e.g. part of SoC control circuitry of . In some embodiments file system may include a flash file system which provides a logical to physical mapping of pages. In these embodiments file system may perform some or all of the functionalities of NVM driver discussed below and therefore file system and NVM driver may or may not be separate modules.

File system may manage file and folder structures for the application and operating system. File system may operate under the control of an application or operating system running on electronic device and may provide write and read commands to NVM driver when the application or operating system requests that information be read from or stored in NVM . Along with each read or write command file system can provide a logical address to indicate where the user data should be read from or written to such as a logical page address or a LBA with a page offset.

File system may provide read and write requests to NVM driver that are not directly compatible with NVM . For example the logical addresses may use conventions or protocols typical of hard drive based systems. A hard drive based system unlike flash memory can overwrite a memory location without first performing a block erase. Moreover hard drives may not need wear leveling to increase the lifespan of the device. Therefore NVM interface can perform any functions that are memory specific vendor specific or both to handle file system requests and perform other management functions in a manner suitable for NVM .

NVM driver can include translation layer . In some embodiments translation layer may be or include a flash translation layer FTL . On a write command translation layer can map the provided logical address to a free erased physical location on NVM . On a read command translation layer can use the provided logical address to determine the physical address at which the requested data is stored. Because each NVM may have a different layout depending on the size or vendor of the NVM this mapping operation may be memory and or vendor specific. Translation layer can perform any other suitable functions in addition to logical to physical address mapping. For example translation layer can perform any of the other functions that may be typical of flash translation layers such as garbage collection GC and wear leveling.

For example translation layer can perform garbage collection to free up a programmed block of NVM for erasing. Once freed and erased the memory locations can be used to store new user data received from file system for example. In some cases the GC process may involve copying the valid data from the programmed block to another block having erased memory locations thereby invalidating the valid data in the programmed block. Once all of the memory locations in the programmed block have been invalidated translation layer may direct bus controller to perform an erase operation on the programmed block. As used herein valid data may refer to user data that has been programmed in response to the most recent write request corresponding to one or more logical addresses e.g. LBAs and may therefore be the valid version of user data for the one or more logical addresses.

NVM driver may interface with NVM bus controller to complete NVM access commands e.g. program read and erase commands . Bus controller may act as the hardware interface to NVM and can communicate with NVM using the bus protocol data rate and other specifications of NVM .

NVM interface may manage NVM based on memory management data sometimes referred to herein as metadata . The metadata may be generated by NVM driver or may be generated by a module operating under the control of NVM driver . For example metadata can include any information used for managing the mapping between logical and physical addresses bad block management wear leveling error correcting code ECC data used for detecting or correcting data errors or any combination thereof. The metadata may include data provided by file system along with the user data such as a logical address. Thus in general metadata may refer to any information about or relating to user data or used generally to manage the operation and memory locations of a non volatile memory.

NVM interface may be configured to store metadata in NVM . In some embodiments NVM interface may store metadata associated with user data at the same memory location e.g. page in which the user data is stored. For example NVM interface may store user data the associated logical address and ECC data for the user data at one or more memory locations of NVM . NVM interface may also store other types of metadata about the user data in the same memory location.

NVM interface may store the logical address so that on power up of NVM or during operation of NVM electronic device can determine what data resides at that location. In particular because file system may reference the user data according to its logical address and not its physical address NVM interface may store the user data and logical address together to maintain their association. This way even if an index table in NVM maintaining the physical to logical mapping becomes outdated NVM interface may still determine the proper mapping at power up or reboot of electronic device for example.

Conventionally when a system experiences an error during system operation e.g. an unrecoverable NVM error a file system error or a general system error discrepancies can occur between a file system s view of the files stored in the NVM and the actual files that are stored in the NVM. For example during an unclean reboot the file system may have already allocated LBAs for a file e.g. metadata has been updated to reflect that a file has been downloaded but the file has not yet been programmed to the NVM.

In such situations the file system may assume that one or more LBAs are available e.g. the one or more LBAs are associated with correctable user data stored in the NVM but the one or more LBAs may actually be unavailable. As used herein unavailable LBAs can refer to LBAs that are unallocated unmapped e.g. LBAs that are not associated with user data stored in the NVM or known uncorrectable e.g. the error correction codes of the user data associated with the LBAs are not functioning . At a later time when the file system needs to access the one or more LBAs the system may discover that associated user data are missing or corrupt. The file system may then attempt to recover user data associated with the one or more LBAs. This process however may negatively impact user experience.

In some embodiments rather than waiting for a user to intercept discrepancies the system can initiate a full NVM scan during system operation. By comparing the file system s view of the availability of LBAs with the results of the NVM scan the system can detect discrepancies. This can be a time consuming process and can cause problems while the system is operating because the system needs to be fully responsive to application requests.

Accordingly in order to avoid these performance issues the system can initiate a reconciliation process at an earlier time in particular during system boot up. This can allow the reconciliation to be performed with minimal impact on system performance. In particular because the file system does not yet have to respond to read and write requests from applications during boot up the system has sufficient time to perform the reconciliation process. Therefore a baseline of available LBAs can be established before the system becomes fully operational and system accesses can be held off until the system reaches a known good state. In addition because the reconciliation process deals with only small data structures stored in volatile memory the reconciliation process can be performed much faster in comparison to a process that conducts a full read pass of the NVM.

Referring now to process is shown for data availability reconciliation during system boot up. Process may begin at step and at step an NVM driver e.g. NVM driver of can be enumerated. In particular an NVM driver mapping which can be stored in volatile memory e.g. memory of can be obtained during the enumeration. The NVM driver mapping can include the actual availability of LBAs in the NVM.

The enumeration of the NVM driver can be performed by scanning an NVM e.g. NVM of or NVM of . For example an NVM interface e.g. NVM interface of or NVM interface of can read context information stored in the NVM where the context information includes logical to physical mappings. The NVM interface can then load the logical to physical mappings into volatile memory. In some cases the NVM interface can identify one or more blocks with logical to physical mappings that have not been captured by the context information e.g. blocks that have been updated more recently . As a result the NVM interface can scan the block TOCs of the one or more blocks in order to update the logical to physical mappings in the volatile memory.

In some embodiments the updated logical to physical mappings can be stored in a suitable data structure such as for example a tree or a mapping table. Based on the results of the NVM driver enumeration e.g. the updated logical to physical mappings the NVM interface can obtain an NVM driver mapping which can indicate the availability of LBAs in the NVM. Trees and NVM driver mappings will be discussed in more detail in connection with .

In other embodiments the NVM interface can obtain an NVM driver mapping by directly scanning the NVM e.g. by examining the state of one or more flags stored in the NVM . This process will be discussed in more detail in connection with .

An NVM driver mapping can take any suitable form. For example referring now to illustrative mappings of availability states are shown from the perspectives of a file system and an NVM driver. In particular NVM driver mapping can indicate the availability of LBA ranges as determined by an NVM interface e.g. NVM interface of or NVM interface of . As shown LBAs that are available e.g. LBAs that are associated with correctable user data stored in an NVM are indicated by horizontal lines whereas LBAs that are unavailable e.g. LBAs that are unmapped or uncorrectable are indicated by blank space. Persons skilled in the art will appreciate that NVM driver mapping can provide the availability of any suitable number of LBAs e.g. all of the LBAs of the system . For the sake of simplicity only a subset of the NVM driver mapping is shown in .

NVM driver mapping can be stored as any suitable data structure in volatile memory e.g. memory of such as for example a bitmap a mapping table or a range list. In some embodiments each entry of NVM driver mapping can correspond to a single bit. That is each entry of the bitmap can store a binary value e.g. 0 or 1 where each binary value can correspond to an availability state of the associated LBA e.g. available or unavailable . Alternatively each entry of the bitmap can correspond to multiple bits and can thus store additional information regarding an availability state of the associated LBA e.g. whether a LBA is available unavailable unmapped or unavailable uncorrectable . Because NVM driver mapping only needs to store the availability of LBAs and not the actual physical locations of LBAS NVM driver mapping can occupy a relatively small space in the volatile memory.

Referring back to at step a file system e.g. file system of can be mounted. During the mounting process a file system allocation state can be generated from a file system journal. The file system allocation state can indicate the file system s view of the availability of LBAs. For example referring again to file system allocation state can represent the file system s view of the availability of LBA ranges . Similar to NVM driver mapping file system allocation state can be stored as any suitable data structure such as for example a bitmap a mapping table or a range list. In addition each entry of file system allocation state can correspond to one or more bits.

Continuing to step of a boot time unmap can be performed. In particular the file system can provide a list of currently unmapped LBAs to the NVM driver. Process may then move to step .

At step data availability reconciliation can be performed. In particular a new communication path can be established between the file system and the NVM interface and the file system allocation state and the NVM driver mapping can be overlaid and compared with one another in order to expose any discrepancies. Because the file system allocation state and the NVM driver mapping are relatively small data structures stored in volatile memory the comparison process can be relatively fast.

In an ideal scenario the file system allocation state and the NVM driver mapping should be identical. However any discrepancies between the file system allocation state and the NVM driver mapping can indicate situations in which the file system assumes that one or more LBAs are available but the LBAs are actually unavailable in the NVM. Based on these discrepancies the file system can initiate a recovery process to restore data associated with the one or more unavailable LBAs.

Referring now to an illustrative process for restoring data is shown. Process may begin at step and at step a file system e.g. file system of can determine a file system allocation state e.g. file system allocation state of during system boot up.

Then at step for each available LBA range in the file system allocation state the file system can transmit a command to an NVM interface e.g. NVM interface of or NVM interface of to determine whether an NVM driver mapping e.g. NVM driver mapping of has a consistent state. In some cases the command can be in the form of an application programming interface API command. An API can be any suitable interface that allows a software program or module to interact with other software.

Thus for each LBA range that the file system assumes is allocated in the file system allocation state e.g. LBA ranges 1 5 of the file system can transmit an API command. In some embodiments the API command that is transmitted can have the following format IsAllValid LBA LBA end callback 1 where LBA can correspond to the start LBA of the LBA range LBA end can correspond to the end LBA of the LBA range and callback can correspond to a callback function. The callback function can be a function that enables the NVM interface to communicate with the file system.

In other embodiments the API command that is transmitted can have the following format IsAllValid LBA LBA end list 2 where LBA can correspond to the start LBA of the LBA range LBA end can correspond to the end LBA of the LBA range and list can correspond to a list in which items can be added. Persons skilled in the art will appreciate that the commands transmitted from the file system can have any suitable format. Persons skilled in the art will also appreciate that instead of passing a single LBA range in a command the file system can pass a list of LBA ranges in a single command.

Continuing to step the file system can receive information from the NVM interface indicating that one or more LBA ranges has inconsistent states. That is based on a comparison with the NVM driver mapping the NVM interface may have determined that at least one portion of the one or more LBA ranges is unavailable e.g. unmapped or uncorrectable .

Then at step the file system can invoke a policy to restore data e.g. user data associated with the one or more LBA ranges. The policy that is invoked for a particular LBA range can be based on a file path associated with the LBA range. For instance if data associated with the LBA range is temporary data e.g. the data is deleted and then recreated each time a device is booted up the file system can stop restoring the data. On the other hand if data associated with the LBA range is internal data associated with the file system the file system can use the internal data to recover the data. As yet another example if data associated with the LBA range is application generated data the file system can invoke a policy associated with the corresponding application to recover the data from an external or back up source e.g. issue a restore command to the external source request an application back up or request for a user to plug the device into a computer . Upon restoring the data the file system can re mount the data. Process may then end at step .

Referring now to process is shown for determining data availability. Process may begin at step and at step an NVM interface e.g. NVM interface of or NVM interface of can detect that an electronic device is booting up.

Continuing to step the NVM interface can obtain availability states of LBAs from a data structure e.g. a tree stored in volatile memory e.g. memory of .

For example referring now to tree can be used by the NVM interface to obtain availability states of LBAs. Tree can include multiple nodes where each node may be consistently sized for memory allocation purposes e.g. each node may have a fixed size of 64 bytes . For the sake of simplicity tree is shown to include a small number of nodes. Thus the dashed boxes in tree can indicate other nodes of tree which are not shown in any detail.

In addition each node of tree can include one or more entries. For example as shown in node can include two entries e.g. entries and . Each entry of a node can be associated with a number of fields. For example each entry of tree can be associated with LBA range e.g. a run length encoding compressed rle compressed range and page address . In addition each entry of tree can include a pointer field with a particular token value. Persons skilled in the art will appreciate that each of entries of tree can include additional fields not shown in . For the sake of simplicity however only three fields are shown for each entry in tree .

In some embodiments each pointer field of an entry can have a value corresponding to a node pointer an NVM pointer an NVM unmapped pointer or an NVM uncorrectable pointer. For example entry of tree is shown to include node pointer e.g. a pointer to another node . As another example entry is shown to include NVM pointer which can correspond to a physical address of the NVM.

As yet another example entry can include NVM unmapped pointer which can be a pointer to the NVM. However NVM unmapped pointer can also indicate that associated entry corresponds to unmapped space. As a further example entry is shown to include NVM uncorrectable pointer which can also be a pointer to the NVM. NVM uncorrectable pointer can indicate that associated entry corresponds to uncorrectable space.

In some embodiments pointers can be updated in tree during a garbage collection GC process. For example while a translation layer e.g. translation layer of is performing GC on a programmed block of the NVM the translation layer may discover upon reading valid data in the block that the data is uncorrectable. The translation layer can subsequently discard the data and update the associated pointer in tree to an NVM uncorrectable pointer.

By maintaining different token values for pointers in tree tree can retain information regarding the allocation states e.g. mapped unmapped and the uncorrectable states of LBAs. As a result by detecting different token values for the pointers of tree the NVM interface can obtain an NVM driver mapping e.g. NVM driver mapping of . In particular LBAs that are associated with NVM pointers can be considered available LBAs whereas LBAs that are associated with NVM unmapped pointers and NVM uncorrectable pointers can be considered unavailable LBAs.

Referring back to at step the NVM interface can receive a request from a file system e.g. file system of regarding data availability of a LBA range. As discussed previously in connection with process the request may take the form of an API command.

Then at step the NVM interface can determine whether at least one portion of the LBA range is unavailable e.g. unmapped or uncorrectable based on the availability states of the LBAs e.g. based on a comparison with an NVM driver mapping such as NVM driver mapping of . If at step the NVM interface determines that the at least one portion of the LBA range is available process may end at step .

If at step the NVM interface instead determines that the at least one portion of the LBA range is unavailable process may move to step . For example responsive to a request from the file system regarding the data availability of LBA range of the NVM interface may determine that a portion of LBA range in NVM driver mapping is unavailable e.g. the portion between LBA range and LBA range .

Then at step the NVM interface can transmit information to the file system indicating that the at least one portion of the LBA range is unavailable. The NVM interface can notify the file system of this unavailability in any suitable manner. In some embodiments the NVM interface can call a callback function e.g. the callback function may be provided by the original API command issued by the file system . In some cases the callback function can be called each time an unavailable portion of a LBA range is detected. Alternatively the callback function can be called only once regardless of the number of unavailable portions detected in a LBA range.

In other embodiments the NVM interface can append the at least one LBA range to a list associated with an API command e.g. the list may be associated with the original API command issued by the file system . The NVM interface can subsequently transmit the list to the file system. In some cases the NVM interface can transmit the list after all unavailable LBAs have been discovered and appended to the list. Alternatively the NVM interface can transmit the list as soon as a LBA range has been added to the list.

The NVM interface may transmit general or specific information to the file system regarding LBA unavailability. For example the NVM interface can provide general information regarding the unavailability of a LBA range. Alternatively the NVM interface can provide specific information regarding which portion of the LBA range is unavailable. After transmitting the information process may end at step .

Accordingly by reconciling a file system s view of data availabilities of LBAs with availability states of LBAs obtained from a data structure during system boot up the NVM interface is able to communicate any inconsistencies to the file system at an earlier time. This enables the file system to handle the inconsistencies during system boot up rather than waiting until the system becomes fully operational.

In some embodiments instead of using a tree to obtain information regarding the availability of LBAs e.g. whether a particular LBA is uncorrectable the NVM interface can obtain an NVM driver mapping by directly scanning the NVM e.g. by examining the state of one or more flags stored in the NVM . For example the uncorrectable state of a LBA can be directly maintained in the NVM.

Turning now to process is shown for handling uncorrectable data. Process may begin at step and at step an NVM interface e.g. NVM interface of or NVM interface of can determine that a first block of an NVM e.g. NVM of or NVM of needs to be garbage collected.

Then at step the NVM interface can detect that at least one portion of valid data stored in the first block is uncorrectable. Process may then move to step .

At step the NVM interface can tokenize or move the valid data to a second block of the NVM. For example in some embodiments the NVM interface can move the valid data to the second block. In other embodiments the NVM interface can tokenize the uncorrectable data. That is the NVM interface can assign the uncorrectable state of the at least one portion of the valid data as a token value in a logical to physical mapping system.

Continuing to step the NVM interface can store the token value on the NVM or set one or more flags in one or more pages and or a block TOC of the second block to indicate that the at least one portion of the valid data is uncorrectable. Process may then end at step .

Thus by directly maintaining the uncorrectable states of one or more LBAs in the NVM the NVM interface may not have to update a data structure in volatile memory e.g. a tree with this information. When the NVM interface needs to obtain an NVM driver mapping the NVM interface can scan a block TOC for each block of the NVM. By scanning the block TOCs the NVM interface can determine the states of the one or more flags which can indicate whether corresponding data e.g. user data stored in the blocks are correctable. This information can be used by the NVM interface to update the NVM driver mapping.

In other embodiments instead of performing the reconciliation process during system boot up the reconciliation process can be performed during run time and the reconciliation process can be interspersed with system input output requests e.g. read and write commands . That is after the file system has mounted and boot time unmap has completed the system can proceed to run time without performing data availability reconciliation. In some cases during run time the system can hold off read commands to certain LBA ranges that have not yet been reconciled. Then upon the occurrence of a particular event e.g. when the NVM driver first becomes idle when the NVM driver discovers uncorrectable data and or during garbage collection data availability reconciliation can be performed.

It should be understood that processes and of and may be executed by one or more components in a system e.g. electronic device of or electronic device of . For example at least some of the steps in the processes may be performed by a control circuitry e.g. SoC control circuitry of .

It should also be understood that processes and of and are merely illustrative. Any of the steps may be removed modified or combined and any additional steps may be added without departing from the scope of the invention.

The described embodiments of the invention are presented for the purpose of illustration and not of limitation.

