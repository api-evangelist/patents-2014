---

title: Systems and methods for facilitating video fingerprinting using local descriptors
abstract: Systems and methods for facilitating video fingerprinting are provided. In one embodiment, a system can include: a memory, a microprocessor, a communication component that receives a video, and a video fingerprinting component that fingerprints the video with a subfingerprint (SFP). The video fingerprinting component can employ an SFP component stored in the memory and that comprises: a feature extraction component that determines local descriptors for at least one frame of a video; and a quantization component that quantizes the local descriptors to generate first frame information including a set of values for the at least one frame. The SFP component can also include: an accumulation component that accumulates first frame information over a snippet of the video; and an SFP generation component that computes the SFP associated with the snippet. The SFP can be computed based on a hash based on the accumulated first frame information over the snippet.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09177350&OS=09177350&RS=09177350
owner: Google Inc.
number: 09177350
owner_city: Mountain View
owner_country: US
publication_date: 20140114
---
This application claims priority to and the benefit of U.S. non provisional patent application Ser. No. 13 347 680 filed Jan. 10 2012 and titled SYSTEMS AND METHODS FOR FACILITATING VIDEO FINGERPRINTING USING LOCAL DESCRIPTORS the entirety of which is incorporated herein by reference.

Conventional video processing methods employ video fingerprinting to identify near duplicate videos and or portions thereof. Video fingerprinting can be also employed in identifying copyrighted material in a video. Unfortunately methods for generating fingerprints are typically complex. Further the fingerprints generated can be sensitive to crops scaling and or flipped versions of the video rendering the generated fingerprint of limited utility. As such systems and methods that provide new approaches for generating video fingerprints are desired.

The following presents a simplified summary of one or more embodiments in order to provide a basic understanding of such embodiments. This summary is not an extensive overview of all contemplated embodiments and is intended to neither identify key or critical elements of all embodiments nor delineate the scope of any or all embodiments. Its purpose is to present some concepts of one or more embodiments in a simplified form as a prelude to the more detailed description that is presented later.

In one or more embodiments the disclosed subject matter relates to a system that performs video fingerprinting comprising a memory that stores computer executable components and a microprocessor that executes computer executable components stored in the memory. The computer executable components can include a video fingerprinting component that generates a subfingerprint of a video. The video fingerprinting component can include a feature extraction component that determines one or more local descriptors for one or more selected frames of the video and a quantization component that quantizes the one or more local descriptors to generate first frame information. The first frame information can include a set of values for the one or more selected frames of the video. The video fingerprinting component can also include an accumulation component that accumulates the first frame information over a snippet of the video. The snippet can include selected consecutive ones of the frames of the video. The video fingerprinting component can also include a subfingerprint generation component that computes the subfingerprint associated with the snippet. Computing the subfingerprint can include computing a first hash based on an accumulated first frame information over the snippet.

In one or more embodiments the disclosed subject matter relates to a method facilitating video fingerprinting. The method can include generating a first set of one or more local descriptors for at least one frame of a video generating a second set of one or more local descriptors for a flipped version of the at least one frame of the video and quantizing the local descriptors of the first set and the second set to generate quantized local descriptors. The method can also include appending to each quantized local descriptor an identifier of a part of the snippet of the video in which the quantized local descriptor is located to generate a set of augmented quantized local descriptors generating a histogram representing the set of augmented quantized local descriptors and computing a subfingerprint for the video based at least on computing one or more hash values for the histogram.

In one or more embodiments the disclosed subject matter relates to another method for generating a subfingerprint of a snippet of a video wherein the snippet includes sets of frames. The method can include generating one or more local descriptors for each set of frames quantizing each local descriptor to yield quantized local descriptors appending to each quantized local descriptor an identifier of a part of the snippet in which the quantized local descriptor is located to yield a set of augmented quantized local descriptors computing a count of augmented quantized local descriptors to yield a weighted set of augmented quantized local descriptors and computing a hash for the weighted set of augmented quantized local descriptors.

In one or more embodiments the disclosed subject matter relates to another method facilitating video fingerprinting. The method can include determining one or more local descriptors for at least one frame of a video and quantizing the one or more local descriptors to generate first frame information. The first frame information can include a set of values for the at least one frame. The method can also include accumulating additional first frame information over a snippet of the video. The snippet can include the at least one frame and one or more additional frames of the video within a fixed duration of time. The method can also include computing an SFP associated with the snippet. The computing the SFP can include computing a first hash based on an accumulated first frame information over the snippet.

Toward the accomplishment of the foregoing and related ends the one or more embodiments include the features hereinafter fully described and particularly pointed out in the claims. The following description and the annexed drawings set forth herein detail certain illustrative aspects of the one or more embodiments. These aspects are indicative however of but a few of the various ways in which the principles of various embodiments can be employed and the described embodiments are intended to include all such aspects and their equivalents.

Various embodiments are now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a more thorough understanding of one or more embodiments. It is be evident however that such embodiments can be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing one or more embodiments.

Systems and methods disclosed herein relate to video fingerprinting using local descriptors. In particular a system can include a subfingerprint SFP component that can generate an SFP for a video received and or processed by the system. In various embodiments the SFP can be an identifier or signature e.g. a string of bits that describes content of video or snippets thereof . The SFP component can include a feature extraction component that can determine one or more local descriptors for one or more frames of the video and a quantization component that can quantize the local descriptors. In some embodiments the local descriptors can be determined for one or more frames in lieu of determining the local descriptors for averages of the frames . The system can also include an accumulation component that can accumulate frame information over consecutive frames e.g. a snippet of the video. An identifier can be appended to the portion of the snippet in which the quantized local descriptors is located and a count of the local descriptors over the snippet can be computed. A histogram can then be generated of a weighted set of local descriptors. An SFP generation component can then compute the SFP based on a hash.

The systems and methods can advantageously facilitate the use of video fingerprinting in cases in which the video is cropped scaled and or flipped horizontally or vertically. In various embodiments the systems and methods can be utilized in a video deduping pipeline and or can be utilized to identify duplicate videos during video searching or matching. Further the systems and methods herein can be utilized for horizontal flipped versions or vertical flipped versions of the video rendering the systems and methods robust to such flips.

The communication component can receive a video or component thereof. The communication component can also output a fingerprinted video as shown in . The fingerprinted video can include a subfingerprint SFP . In some embodiments the communication component can also output an SFP for the received video . In various embodiments the communication component can access a video stored at the memory of the VF system and or stored at a location remote from the VF system . For example the communication component can access the video over a network not shown including but not limited to the internet.

The VF component can fingerprint the video with an SFP. In various embodiments for example the VF component can employ the SFP component stored in the memory to generate the SFP with which the video or a portion thereof is fingerprinted.

Microprocessor can perform one or more of the functions described in this disclosure with reference to any of the systems and or methods disclosed.

The memory can be a computer readable storage medium storing computer executable instructions and or information for performing the functions described in this disclosure with reference to any of the systems and or methods disclosed. For example as shown memory can store computer executable instructions in some embodiments for performing the functions of the SFP component .

As shown in the SFP component can include a feature extraction component a quantization component an accumulation component a snippet component and or an SFP generation component . In some embodiments the SFP generation component can include an identifier appending component a counting component a histogram weighted representation generation component a hash generation component a transcoding component and or a re sizing component . SFP component can also include a video flipping component in various embodiments. In various embodiments one or more of the feature extraction component quantization component accumulation component snippet component video flipping component SFP generation component identifier appending component counting component histogram weighted representation generation component hash generation component transcoding component and or re sizing component can be electrically and or communicatively coupled to perform one or more functions of the SFP component or SFP component .

The feature extraction component can determine one or more local descriptors for one or more frames of a video. In various embodiments the local descriptors can be determined for an average of two or more frames. The frames can be selected or averages of the frames can be determined prior to generating the local descriptors. As such the frames or averages thereof can be separated by one or more other frames or be of various durations of time in some embodiments.

The local descriptors for one or more frames or averages of two or more frames can be based on the content of one or more frames. The local descriptors can include but are not limited to information indicative of a type position scale or aspect ratio of the frame or average of two or more frames . In various embodiments the local descriptor can include information indicative of a descriptor of a portion of the frame or average of two or more frames . In some embodiments the local descriptor can include a scale invariant feature transform SIFT descriptor a Speeded Up Robust Feature SURF descriptor a CONGAS descriptor or another variant of descriptor. SIFT is an algorithm in computer vision to detect and describe local features in images. SURF is an image detector and descriptor that can be used for computer vision tasks like object recognition. CONGAS is a local descriptor based on Gabor wavelets of varying scale and orientation drawn from a space variant grid around an interest point.

The quantization component can quantize the one or more local descriptors and generate frame information that is based on the quantized local descriptors. In some embodiments the frame information can include a weighted set of values for the selected frames or for the average of the selected frames . The values can be weighted based on the number of occurrences of the local descriptors for example.

The accumulation component can accumulate over a snippet of the video the frame information based on the quantized local descriptors. The snippet can include selected consecutive frames of the video within a fixed duration of time.

The SFP generation component can compute the SFP associated with the snippet. In various embodiments the SFP generation component can compute the SFP by computing a hash that is based on the accumulated frame information over the snippet.

In some embodiments the SFP can be computed as follows. The identifier appending component of the SFP generation component can append an identifier to the quantized local descriptors to describe a part of a snippet in which the local descriptors occur. Augmented quantized local descriptors can be generated as a result.

The counting component can then compute a count of the augmented quantized local descriptors over the snippet. The histogram weighted representation generation component can generate a histogram including a weighted set of the augmented quantized local descriptors. The hash generation component can compute one or more hash values for the histogram. The SFP generation component can compute the SFP based on the one or more hash values. In various embodiments an SFP can be an identifier or signature e.g. a string of bits that describes content of video or snippets thereof .

Accordingly SFPs can be computed for snippets of videos. As such near duplicates of cropped and or scaled versions of videos can be identified in various embodiments.

The transcoding component can perform encoding and or decoding of media. In some embodiments the transcoding component can transcode media by converting encoded information in a first format to encoded information in a second format. In various embodiments the transcoding component can be or can be included in the transcoder described with reference to .

The re sizing component can re size the frames to a selected number of pixels. For example in various embodiments the re sizing component can re size the frame while preserving the aspect ratio.

In various embodiments the SFP component can include a video flipping component that can flip a received video. One or more of the functions of the VF system SFP component or SFP component can be performed for the flipped version of the video. For example the local descriptors and quantized versions thereof can be determined not only for the original video but also for the above described flipped versions. For example the quantized local descriptors can be computed for a frame or for an average of two or more frames for the original video and quantized local descriptors can be similarly determined for the corresponding frame or average of corresponding two or more frames for the flipped version of the video.

The quantized local descriptors for the flipped version of the video and for the original e.g. non flipped version of the video can be combined to create a new set of quantized local descriptors. Weights can be generated for the entire set of quantized local descriptors. As described above with reference to frame information can be accumulated based on the new set of quantized local descriptors over a snippet of the video. Finally an SFP can be computed employing on a hash computed based on the accumulated frame information over the snippet as described with reference to . As such because the frame information incorporates information for the non flipped and flipped versions of a video the SFP can be invariant to such flips. Accordingly the systems and methods herein can be robust notwithstanding a video being processed may be a flipped version of the original video or flipped version of a portion of the video . Accordingly near duplicates of flipped versions of videos can be identified in various embodiments.

In some embodiments the local descriptors can include information associated with a type position scale aspect ratio and or a descriptor of a portion of the frame or for an average of two or more frames . In some embodiments the local descriptors include a SIFT descriptor a SURF descriptor and or a CONGAS descriptor.

While not shown in some embodiments method can include removing selected content from the frames or averages thereof prior to determining the local descriptors. The selected content can include but is not limited to a border in the video frame or a logo e.g. station logo in the one or more video frames or in the frames averaged . Four example the border can be a black or other color border of a video frame.

At method can include quantizing the local descriptors to generate frame information e.g. using the quantization component . The frame information can include a set of values for the at least one frame.

In some embodiments the quantization can be tree based quantization of the local descriptors. By way of example but not limitation the tree based quantization can be a hierarchical k means quantization. In some embodiments quantizing can include mapping the local descriptors to one or more closest neighbors from a selected set of neighbors.

At method can include accumulating additional frame information over a snippet of the video e.g. using the accumulation component . The snippet can include the at least one frame of the video and one or more additional frames of the video within a fixed duration. While not shown the method can include identifying a snippet of video e.g. using the snippet component .

At method can include computing an SFP associated with the snippet e.g. using the SFP generation component . Computing the SFP can include computing a hash. The hash can be based on the accumulated frame information over the snippet.

In some embodiments while not shown method can also include computing SPFs for one or more snippets of the video e.g. using the SFP generation component . The snippets can be separated a predefined amount of time apart from one another in some embodiments. In some embodiments the SFPs can be generated for snippets spaced apart from one another.

In various embodiments while not shown a method for generating a fingerprint that is invariant to a flipped version of the video can be as follows. A flipped version of the video can be generated or obtained e.g. using the video flipping component . By way of example but not limitation the method can include determining a first set and a second set of local descriptors e.g. using the feature extraction component . The first set can be associated with one or more selected frames of the video and the second set can be associated with one or more selected frames of the flipped version of the video. The one or more selected frames of the flipped version of the video can correspond to the one or more selected frames of the video. The method can also include quantizing the first set and the second set of the local descriptors to generate frame information e.g. using the quantizing component . The first frame information can include a weighted set of values for the one or more selected frames of the video and for the one or more selected frames of the flipped version of the video. The method can also include accumulating the frame information over a snippet of the video e.g. using the accumulation component . The snippet can include selected consecutive ones of the frames of the video. The method can also include computing the SFP associated with the snippet e.g. using the subfingerprint generation component . Computing the subfingerprint can include computing a first hash based on accumulated frame information over the snippet e.g. using the hash generation component .

Turning now to method can be a method for computing an SFP. At method can include generating augmented quantized local descriptors by appending to quantized local descriptors an identifier of a part of the snippet in which the quantized local descriptors occurred e.g. using the identifier appending component .

At method can include computing counts of the augmented quantized local descriptors over the snippet e.g. using the counting component .

At method can include generating a histogram utilizing the weighted set of augmented quantized local descriptors e.g. using the histogram weighted representation generation component .

At method can include computing the SFP based at least on computing one or more hash values for the histogram e.g. using the SFP generation component . The hash values can be computed by the hash generation component in some embodiments.

Turning now to method can be a method for computing an SFP that is robust to flipped versions of video. As shown in at method can include generating a first set of one or more local descriptors for at least one frame of a video e.g. using the feature extraction component . At method can include generating a second set of one or more local descriptors for a flipped version of the at least one frame of the video e.g. using the feature extraction component .

At method can include quantizing the local descriptors of the first set and the second set to generate quantized local descriptors e.g. using the quantization component .

At method can include appending to each quantized local descriptor an identifier of a part of a snippet in which the quantized local descriptor is located to generate a set of augmented quantized local descriptors e.g. using the identifier appending component .

At method can include generating a histogram representing the set of augmented quantized local descriptors e.g. using the histogram weighted representation generation component .

Turning now to method can include computing an SFP for the video based at least on computing one or more hash values for the histogram e.g. using the SFP generation component .

Turning now to method is an illustration of an exemplary method for comparing fingerprinted videos. Method can include the actions of method for generating one or more SFPs for a video. At method can include comparing the SFP generated for the video to an SFP for a previously fingerprinted video e.g. using the VF component . At method can include determining whether the video matches the previously fingerprinted video based on the comparison e.g. using the VF component . In various embodiments cropped scaled and or flipped versions of videos can be compared.

In some embodiments a method of performing video fingerprinting can be as follows. For one or more frames of a video a set of local descriptors can be computed. In some embodiments the local descriptors are computed for each of the frames of the video e.g. using the feature extraction component . The local descriptors can be SURF SIFT and or CONGAS local descriptors and or any of a number of other variants of video descriptors.

The local descriptors for the frames can then be quantized e.g. using the quantization component yielding a representation of each frame. The representation can be a set of information e.g. words that describes the frame. In some embodiments the sets of information can be accumulated over a sliding temporal window of frames e.g. using the accumulation component yielding a larger set of descriptors for a video snippet of a fixed duration. This larger set of descriptors can be weighted e.g. using the histogram weighted representation generation component .

A hash can then be computed from this larger set of descriptors e.g. using the hash generation component . In one embodiment the SFP for the snippet is the hash. In other embodiments the hash is employed to generate the SFP for the snippet. SFPs can be generated for one or more of video snippets of a selected length and separated a selected amount of time apart.

At method can include detecting and removing information in the video stream e.g. using the feature extraction component . In various embodiments borders e.g. black borders and or logo information e.g. station logo information can be detected and removed.

At method can include re sizing the video frames to a selected number of pixels e.g. using the re sizing component . The re sizing can preserve the aspect ratio in some embodiments.

At method can include detecting local descriptors e.g. CONGAS of one or more of the averaged frames e.g. using the feature extraction component . In one implementation the number of features detected per frame is capped at . One or more of the features can include information such as a type position scale aspect ratio and or a descriptor of a local part of the frame as for example responses to Gabor filters .

Turning now to at method can include quantizing the local descriptors e.g. using the quantization component . In some embodiments the position descriptor can be quantized using one or more grids. In some embodiments the scale descriptor or in some embodiments the log scale descriptor and or the aspect ratio descriptor can be quantized using separate grids. In one implementation each descriptor is quantized using for example a tree based quantization e.g. hierarchical k means quantization . In one embodiment each descriptor is mapped to a set of six approximate closest neighbors out of a set of 100 000 neighbors.

At method can include accumulating the quantized descriptors to produce a set of quantized descriptors e.g. using the accumulation component . For example in a set each quantized descriptor can be a tuple including but not limited to type quantized position quantized scale and or quantized descriptor . In one implementation two separate grids are utilized to quantize the position descriptor and the six closest neighbors are determined in order to quantize the descriptor. As such in this embodiment 12 quantized descriptors can be generated for each original descriptor.

At method can include determining a temporal window e.g. using the snippet component . For example in some embodiments windows having a length of three seconds can be divided into one or more portions. The one or more portions can be overlapping or non overlapping in various embodiments. For example if two of the portions are non overlapping the portions can be two disjoint portions.

At method can include appending an identifier to each quantized descriptor e.g. using the identifier appending component . In an exemplary embodiment the identifier identifies a part of the temporal window in which the feature identified by the descriptor is located.

At method can include computing the counts of the quantized descriptors that are augmented with the identifier e.g. using the counting component . The count can be computed over the temporal window.

Turning to at method can include generating a weighted set of augmented quantized descriptors in which the weights are the counts computed at . In some embodiments the counts can be adjusted by multiplying one or more of the counts by a function of a scale descriptor to weigh the descriptors with larger spatial support heavier than descriptors with less spatial support. The weighted set can be represented as a histogram. For example the histogram weighted representation generation component may generate an unnormalized histogram to represent the weighted set. The weighted set may also be represented as a sparse vector. For example the histogram weighted representation generation component may generate a sparse vector where the index is the augmented descriptor to represent the weighted set.

At in embodiments wherein the histogram is computed the method can include computing one or more hash values for the histogram e.g. using the hash generation component . By way of example but not limitation a weighted minhash can be employed since the probability of collision can approximately equal the Jaccard similarity of histogram. Minhash min wise independent permutations locality sensitive hashing is a technique for quickly estimating the similarity between two sets. One weighted minhash that can be employed Weighted Minhash generalizes the min wise permutation hashes of Broder see e.g. Broder et al. Min wise independent permutations J. Comput. Syst. Sci. vol. 60 no. 3 pp. 630 659 2000 from binary to real weights. See Sergey Ioffe Improved Consistent Sampling Weighted Minhash and L1 Sketching IEEE ICDM 2010. 

At method can include computing the SFP based on the one or more hash values e.g. using the SFP generation component . In various embodiments the methods and systems described in this disclosure can utilize wavelets for generation of the SFPs.

At method can include generating one or more local descriptors for each set of frames e.g. using the feature extraction component . In some embodiments generating the one or more local descriptors can include averaging two or more frames to yield an average of the two or more frames and generating one or more local descriptors for the average.

At method can include quantizing each local descriptor to yield quantized local descriptors e.g. using the quantization component . In various embodiments quantizing the local descriptor can include quantizing a local descriptor using tree based quantization.

In some embodiments quantizing the local descriptor can include quantizing a position of a local descriptor using two or more grids to generate a quantized position value. A tuple of quantization values can be created for the local descriptor. In some embodiments the tuple can include the quantized position value. The tuple may also be a type quantized scale and or quantized descriptor.

At method can include appending to each quantized local descriptor an identifier of a part of a snippet in which the quantized local descriptor is located to yield a set of augmented quantized local descriptors e.g. using the identifier appending component . For example if each SFP is calculated for three seconds of video an identifier can be appended specifying whether the quantized local descriptor occurred in the first half of the three seconds or the second half of the three seconds.

In various embodiments each frame or frame average can be associated with one or more snippets e.g. if the SFPs are computed every 0.25 seconds for example . As such the same local descriptor can be augmented differently for different snippets. In various embodiments of method is optional and is not included in method .

At method can include computing a count of augmented quantized local descriptors to yield a weighted set of augmented quantized local descriptors e.g. using the counting component .

At method can include computing a hash for the weighted set of augmented quantized local descriptors e.g. using the hash generation component . In some embodiments the hash can be computed using a weighted minhash.

Although not shown in some embodiments the method can include convolving the video with a temporal filter prior to generating the one or more local descriptors. In various embodiments although also not shown method can also include removing data e.g. a border or logo from the video prior to generating the one or more local descriptors.

One of ordinary skill in the art can appreciate that the various embodiments described in this disclosure can be implemented in connection with any computer or other client or server device which can be deployed as part of a computer network or in a distributed computing environment and can be connected to any kind of data store where media may be found. In this regard the various embodiments described in this disclosure can be implemented in any computer system or environment having any number of memory or storage units and any number of applications and processes occurring across any number of storage units. This includes but is not limited to an environment with server computers and client computers deployed in a network environment or a distributed computing environment having remote or local storage.

Distributed computing provides sharing of computer resources and services by communicative exchange among computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for objects such as files. These resources and services can also include the sharing of processing power across multiple processing units for load balancing expansion of resources specialization of processing and the like. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may participate in the various embodiments of this disclosure.

Each computing object etc. and computing objects or devices etc. can communicate with one or more other computing objects etc. and computing objects or devices etc. by way of the communications network either directly or indirectly. Even though illustrated as a single element in network can include other computing objects and computing devices that provide services to the system of and or can represent multiple interconnected networks which are not shown. Each computing object etc. or computing objects or devices etc. can also contain an application such as applications that might make use of an application programming interface API or other object software firmware and or hardware suitable for communication with or implementation of the various embodiments of the subject disclosure.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems can be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks though any network infrastructure can be used for exemplary communications made incident to the systems as described in various embodiments.

Thus a host of network topologies and network infrastructures such as client server peer to peer or hybrid architectures can be utilized. The client can be a member of a class or group that uses the services of another class or group. A client can be a computer process e.g. roughly a set of instructions or tasks that requests a service provided by another program or process. A client can utilize the requested service without having to know all working details about the other program or the service itself.

As used in this application the terms component module system and the like are intended to refer to a computer related entity either hardware software firmware a combination of hardware and software software and or software in execution. For example a component can be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computing device and or the computing device can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers. In addition these components can execute from various computer readable storage media having various data structures stored thereon. The components can communicate by way of local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems by way of the signal .

Moreover the term or is intended to mean an inclusive or rather than an exclusive or. That is unless specified otherwise or clear from the context the phrase X employs A or B is intended to mean any of the natural inclusive permutations. That is the phrase X employs A or B is satisfied by any of the following instances X employs A X employs B or X employs both A and B. In addition the articles a and an as used in this application and the appended claims should generally be construed to mean one or more unless specified otherwise or clear from the context to be directed to a singular form.

In a client server architecture particularly a networked system a client can be a computer that accesses shared network resources provided by another computer e.g. a server. In the illustration of as a non limiting example computing objects or devices etc. can be thought of as clients and computing objects etc. can be thought of as servers where computing objects etc. provide data services such as receiving data from client computing objects or devices etc. storing of data processing of data transmitting data to client computing objects or devices etc. although any computer can be considered a client a server or both depending on the circumstances. Any of these computing devices can process data or request transaction services or tasks that can implicate the techniques for systems as described in this disclosure for one or more embodiments.

A server can be typically a remote computer system accessible over a remote or local network such as the Internet or wireless network infrastructures. The client process can be active in a first computer system and the server process can be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects utilized pursuant to the techniques described in this disclosure can be provided standalone or distributed across multiple computing devices or objects.

In a network environment in which the communications network bus can be the Internet for example the computing objects etc. can be Web servers file servers media servers etc. with which the client computing objects or devices etc. communicate via any of a number of known protocols such as the hypertext transfer protocol HTTP . Objects etc. can also serve as client computing objects or devices etc. as can be characteristic of a distributed computing environment.

As mentioned advantageously the techniques described in this disclosure can be applied to any suitable device. It is to be understood therefore that handheld portable and other computing devices and computing objects of all kinds are contemplated for use in connection with the various embodiments i.e. anywhere that a device may wish to read or write transactions from or to a data store. Accordingly the below remote computer described below in is but one example of a computing device. Additionally a suitable server can include one or more aspects of the below computer such as a media server or other media management server components.

Although not required embodiments can be partly implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates to perform one or more functional aspects of the various embodiments described in this disclosure. Software can be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Those skilled in the art will appreciate that computer systems have a variety of configurations and protocols that can be used to communicate data and thus no particular configuration or protocol is to be considered limiting.

With reference to an exemplary computing environment for implementing one or more embodiments includes a computing device in the form of a computer is provided. Components of computer can include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit .

Computer typically includes a variety of computer readable media and can be any available media that can be accessed by computer . The system memory can include computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and or random access memory RAM . By way of example and not limitation memory can also include an operating system application programs other program modules and program data.

Computer can also include a transcoder . Transcoder can perform encoding. In some embodiments the transcoder can convert data encoded in a first format to data encoded in a second format. In various embodiments transcoder can also perform decoding.

A user can enter commands and information into the computer through input devices non limiting examples of which can include a keyboard keypad a pointing device a mouse stylus touchpad touch screen trackball motion detector camera microphone joystick game pad scanner video camera or any other device that allows the user to interact with the computer . A monitor or other type of display device can be also connected to the system bus via an interface such as output interface . In addition to a monitor computers can also include other peripheral output devices such as speakers and a printer which can be connected through output interface .

The computer can operate in a networked or distributed environment using logical connections to one or more other remote computers such as remote computer . The remote computer can be a personal computer a server a router a network PC a peer device or other common network node or any other remote media consumption or transmission device and can include any or all of the elements described above relative to the computer . The logical connections depicted in include a network such local area network LAN or a wide area network WAN but can also include other networks buses e.g. cellular networks.

As mentioned above while exemplary embodiments have been described in connection with various computing devices and network architectures the underlying concepts can be applied to any network system and any computing device or system in which it is desirable to publish or consume media in a flexible way.

Also there are multiple ways to implement the same or similar functionality e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to take advantage of the techniques detailed herein. Thus embodiments herein are contemplated from the standpoint of an API or other software object as well as from a software or hardware object that implements one or more aspects described in this disclosure. Thus various embodiments described in this disclosure can have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

Computing devices typically include a variety of media which can include computer readable storage media and or communications media in which these two terms are used herein differently from one another as follows. Computer readable storage media can be any available storage media that can be accessed by the computer can be typically of a non transitory nature and can include both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable storage media can be implemented in connection with any method or technology for storage of information such as computer readable instructions program modules structured data or unstructured data. Computer readable storage media can include but are not limited to RAM ROM electrically erasable programmable read only memory EEPROM flash memory or other memory technology compact disc read only memory CD ROM digital versatile disk DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or other tangible and or non transitory media which can be used to store desired information. Computer readable storage media can be accessed by one or more local or remote computing devices e.g. via access requests queries or other data retrieval protocols for a variety of operations with respect to the information stored by the medium.

On the other hand communications media typically embody computer readable instructions data structures program modules or other structured or unstructured data in a data signal such as a modulated data signal e.g. a carrier wave or other transport mechanism and includes any information delivery or transport media. The term modulated data signal or signals refers to a signal that has one or more of its characteristics set or changed in such a manner as to encode information in one or more signals. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media.

It is to be understood that the embodiments described in this disclosure can be implemented in hardware software firmware middleware microcode or any combination thereof. For a hardware implementation the processing units can be implemented within one or more application specific integrated circuits ASICs digital signal processors DSPs digital signal processing devices DSPDs programmable logic devices PLDs field programmable gate arrays FPGAs processors controllers micro controllers microprocessors and or other electronic units designed to perform the functions described in this disclosure or a combination thereof.

When the embodiments are implemented in software firmware middleware or microcode program code or code segments they can be stored in a machine readable medium or a computer readable storage medium such as a storage component. A code segment can represent a procedure a function a subprogram a program a routine a subroutine a module a software package a class or any combination of instructions data structures or program statements. A code segment can be coupled to another code segment or a hardware circuit by passing and or receiving information data arguments parameters or memory contents. Information arguments parameters data etc. can be passed forwarded or transmitted using any suitable means including memory sharing message passing token passing network transmission etc.

For a software implementation the techniques described in this disclosure can be implemented with modules or components e.g. procedures functions and so on that perform the functions described in this disclosure. The software codes can be stored in memory units and executed by processors. A memory unit can be implemented within the processor or external to the processor in which case it can be communicatively coupled to the processor via various structures.

The word exemplary is used herein to mean serving as an example instance or illustration. For the avoidance of doubt the subject matter disclosed herein is not limited by such examples. In addition any aspect or design described in this disclosure as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs nor is it meant to preclude equivalent exemplary structures and techniques known to those of ordinary skill in the art. Furthermore to the extent that the terms includes has contains and other similar words are used in either the detailed description or the claims for the avoidance of doubt such terms are intended to be inclusive in a manner similar to the term comprising as an open transition word without precluding any additional or other elements.

What has been described above includes examples of one or more embodiments. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the aforementioned embodiments but one of ordinary skill in the art can recognize that many further combinations and permutations of various embodiments are possible. Accordingly the described embodiments are intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Moreover use of the term an embodiment or one embodiment throughout is not intended to mean the same embodiment unless specifically described as such. Further use of the term plurality can mean two or more.

The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub components some of the specified components or sub components and or additional components and according to various permutations and combinations of the foregoing. Sub components can also be implemented as components communicatively coupled to other components rather than included within parent components hierarchical . Additionally it is to be noted that one or more components can be combined into a single component providing aggregate functionality or divided into several separate sub components and that any one or more middle layers such as a management layer can be provided to communicatively couple to such sub components in order to provide integrated functionality. Any components described in this disclosure can also interact with one or more other components not specifically described in this disclosure but generally known by those of skill in the art.

In view of the exemplary systems described above methodologies that can be implemented in accordance with the described subject matter will be better appreciated with reference to the flowcharts of the various figures. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks can occur in different orders and or concurrently with other blocks from what is depicted and described in this disclosure. Where non sequential or branched flow is illustrated via flowchart it can be appreciated that various other branches flow paths and orders of the blocks can be implemented which achieve the same or a similar result. Moreover not all illustrated blocks can be required to implement the methodologies described in this disclosure after.

In addition to the various embodiments described in this disclosure it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiment s for performing the same or equivalent function of the corresponding embodiment s without deviating there from. Still further multiple processing chips or multiple devices can share the performance of one or more functions described in this disclosure and similarly storage can be provided across a plurality of devices. The invention is not to be limited to any single embodiment but rather can be construed in breadth spirit and scope in accordance with the appended claims.

