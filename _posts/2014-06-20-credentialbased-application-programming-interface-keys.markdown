---

title: Credential-based application programming interface keys
abstract: A processing device comprises a processor coupled to a memory and is configured to obtain a credential associated with a particular access control interval, to determine an application programming interface (API) key based at least in part on the credential, and to utilize the API key in an API key enrollment protocol. The obtaining, determining and utilizing are repeated for one or more additional instances of the API key enrollment protocol corresponding to respective ones of one or more additional access control intervals. The processing device illustratively comprises a service requester device configured to carry out at least a portion of a given instance of the API key enrollment protocol with a service provider device. The API key may comprise, for example, the credential itself, or a function of the credential and other information. The credential may comprise, again by way of example, an intermediate value of a hash chain.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09503442&OS=09503442&RS=09503442
owner: EMC IP Holding Company LLC
number: 09503442
owner_city: Hopkinton
owner_country: US
publication_date: 20140620
---
The field relates generally to information security and more particularly to techniques for controlling access to protected resources.

Applications running on computers mobile telephones and other types of processing devices are often configured to utilize application programming interface API keys in order to access protected resources over a network. By way of example an API key may be submitted in conjunction with a service request directed to a server over the Internet in order to uniquely identify the source of the request. The corresponding API on the server can grant or deny access to services based on the identity of the request source as reflected by the API key. Accordingly the API key may be viewed as supporting a type of user authentication that serves to control access to protected resources.

A more particular example of an application that utilizes API keys is a content aggregator application. Such an application is generally configured to gather information for a given user from multiple designated services including news feeds and social media sites such as Facebook and Twitter. The content aggregator application then presents all of the gathered information to the user in a unified view.

The requests generated by the application may be encoded as hypertext transfer protocol HTTP requests. A given such request includes an API key that identifies the user in a manner that can be understood by the corresponding service.

Unfortunately conventional API keys can present significant problems in terms of security. For example API keys in many cases are implemented as static passwords and are therefore highly vulnerable to interception and replay by attackers. Such attackers could use the API key to disrupt the server or to accrue unauthorized charges on a user account. These and numerous other potential issues associated with use of static passwords can undermine the effectiveness and utility of API keys in a wide variety of applications.

Illustrative embodiments of the present invention provide API keys that are determined based at least in part on credentials associated with respective access control intervals. The generation of API keys from credentials associated with respective access control intervals avoids the above noted problems associated with use of static passwords.

In one embodiment a processing device comprises a processor coupled to a memory and is configured to obtain a credential associated with a particular access control interval to determine an API key based at least in part on the credential and to utilize the API key in an API key enrollment protocol. The obtaining determining and utilizing are repeated for one or more additional instances of the API key enrollment protocol corresponding to respective ones of one or more additional access control intervals.

The processing device in this embodiment may comprise for example a service requester device configured to carry out at least a portion of a given instance of the API key enrollment protocol with a service provider device.

In another embodiment a processing device comprises a processor coupled to a memory and is configured to receive a request for an API key to obtain a credential to generate the API key based at least in part on the credential and to provide the API key to at least one of a service requester and a service provider.

The processing device in this embodiment may comprise for example a trusted API key service device configured for communication with a service requester device and a service provider device.

Other embodiments include but are not limited to methods apparatus systems and articles of manufacture comprising processor readable storage media.

The API key in one or more of the above noted embodiments may comprise for example the credential itself or a function of the credential and other information. The credential may comprise again by way of example an intermediate value of a hash chain. Numerous other types of credentials based on intermediate values of a hash chain or other cryptographic constructs may be used.

Illustrative embodiments of the present invention will be described herein with reference to exemplary information processing systems and associated computers servers storage devices and other types of processing devices. It is to be appreciated however that the invention is not restricted to use with the particular illustrative system and device configurations shown. Accordingly the term information processing system as used herein is intended to be broadly construed so as to encompass for example any processing system comprising at least one processing platform including systems comprising virtual machines and other cloud infrastructure.

Certain embodiments of the invention are configured to utilize techniques disclosed in U.S. patent application Ser. No. 13 629 771 filed Sep. 28 2012 and entitled Protected Resource Access Control Utilizing Intermediate Values of a Hash Chain and U.S. patent application Ser. No. 13 931 083 filed Jun. 28 2013 and entitled Protected Resource Access Control Utilizing Credentials based on Message Authentication Codes and Hash Chain Values both of which are commonly assigned herewith and incorporated by reference herein. However it is to be appreciated that use of such techniques is not a requirement of embodiments of the present invention.

The central manager in the present embodiment is assumed to incorporate credential generation functionality such as a credential generation module and possibly related functionality for key provisioning user account creation and user authentication. Exemplary implementations of such functionality are disclosed in the above referenced U.S. patent application Ser. Nos. 13 629 771 and 13 931 083.

In other embodiments the central manager can be eliminated and the credentials can be generated in the first processing device . For example the credentials in some embodiments can comprise respective one time passcodes or other types of tokencodes generated by a hardware or software authentication token implemented in or otherwise associated with the first processing device .

The first and second processing devices and in this example are more particularly designated in the embodiment as a client and a server respectively with the client being configured to generate an API key for use in an API key enrollment protocol carried out between the client and the server.

Although the first and second processing devices and are configured in the present embodiment as respective client and server devices this is by way of example only. In other embodiments a single device can operate as a client relative to one device and as a server relative to another device. Thus it is possible for a single device to include both client and server functionality.

Also numerous other arrangements of first and second processing devices are possible. For example in another embodiment to be described below in conjunction with the first and second processing devices illustratively comprise respective service requester and service provider devices.

Referring again to the embodiment the client comprises an API key enrollment module that includes an API key generator and a credential processing module .

The server comprises an API key enrollment module that includes a credential extractor and a credential verifier . The modules and may be collectively viewed as an example of what is more generally referred to herein as an access control module of the server . Other arrangements of access control modules can be used in other embodiments.

The network may comprise for example a global computer network such as the Internet a wide area network WAN a local area network LAN a satellite network a telephone or cable network a cellular network a wireless network such as a WiFi or WiMAX network or various portions or combinations of these and other types of networks.

In one possible API key enrollment scenario client is implemented as a mobile telephone a laptop computer a tablet computer or other communication device that accesses the server over the Internet. Numerous other operating scenarios involving a wide variety of different types and combinations of processing devices are possible as will be appreciated by those skilled in the art.

As mentioned above the credentials are illustratively generated by the central manager . This may involve for example a user associated with the client authenticating to the central manager and obtaining the credential corresponding to that access control interval. It is assumed in an embodiment of this type that the user has previously established a user account with the central manager . It is further assumed that the server has been previously provisioned with information from the central manager that allows credential verifier to verify the credential or portions thereof when supplied to the server from the client in one or more API keys.

By way of example in provisioning the server a final value of a hash chain may be installed on the device in a secure manner using encryption. Such information is illustratively provisioned by the central manager over a secure channel with the server . After provisioning the server may be completely disconnected from the central manager such that future communications between the central manager and the server flow through the client with support of one or more associated users. Accordingly after the appropriate information has been provisioned to the server there is no need for continued network connectivity between the server and the central manager or any associated credential generation module.

The term user as utilized herein is intended to be broadly construed so as to encompass for example a human user associated with a given device or set of devices an automated user such as an application or other hardware or software component associated with a given device or any other entity that may control that device.

Credentials associated with respective access control intervals may be configured in some embodiments in the form of SSC application protocol data units APDUs of the type described in the above cited U.S. patent application Ser. No. 13 931 083 although a wide variety of other credential formats may be used in other embodiments. Some SSC APDUs utilize a combination of an intermediate hash value and a message authentication code or MAC and such credentials can be utilized herein.

An exemplary credential based API key process implemented in system will now be described with reference to the flow diagram of . It is to be understood that this particular process is exemplary only and additional or alternative processes can be carried out in other embodiments.

In this embodiment the exemplary credential based API key process includes steps through which are assumed to be performed by the client in interacting with the server and central manager .

In step the client obtains a credential associated with a particular access control interval. For example the credential may be obtained for a current access control interval by the credential processing module .

As will be described in more detail below in conjunction with a credential associated with a particular access control interval may be generated based at least in part on a corresponding intermediate value of a hash chain.

Although the credential is illustratively generated in the central manager in other embodiments the credential may be generated in the client itself or in another system entity. Also the central manager may be configured to communicate with multiple clients and multiple servers and can therefore generate credentials for each of multiple clients to utilize in accessing one or more servers.

Moreover in some embodiments the central manager can delegate to another system entity such as the client an ability to generate credentials for a limited time period comprising multiple access control intervals. Delegation of credential generation capability by the central manager can be configured so as to allow the client to generate these values without having a network connection to the central manager .

Credentials and other authentication information may be communicated between the client and the central manager using any of a number of different communication mechanisms some of which may involve network connections established over the network . For example such communications may be implemented using a web login SMS text messages or other techniques.

The central manager in some embodiments such as the embodiment to be described below in conjunction with is implemented in the form of what is referred to herein as a trusted API key service.

In other embodiments the central manager can be eliminated and the credentials can be generated in the client .

In generating a given credential based at least in part on a corresponding intermediate value of a hash chain an initial value of the hash chain is determined the initial value is hashed a designated number of times to obtain a final value of the hash chain and intermediate values of the hash chain are associated with respective access control intervals. The intermediate value associated with the particular access control interval is then selected as at least a portion of the credential.

Accordingly a given hash chain can be generated by applying multiple iterations of a designated one way hash function to an initial value in order to obtain respective ones of the intermediate values and the final value where the number of intermediate values of the hash chain in some embodiments corresponds to the desired number of access control intervals to be supported.

The hash function used to generate the hash chain may comprise any of a number of different known one way hash functions or key derivation functions including by way of example MD5 SHA 1 SHA 256 and BCrypt. Additional details regarding one or more of these and other conventional hash functions that may be adapted for use in embodiments of the present invention are disclosed in A. J. Menezes et al. Handbook of Applied Cryptography CRC Press 1997 which is incorporated by reference herein.

The final value of the hash chain is provided to the credential verifier of server using a separate secure connection established over the network possibly by the central manager via another type of channel distinct from the channel or channels used for its communications with the client and is utilized by the credential verifier of the server to verify a given credential.

The server and its credential verifier are examples of what are referred to herein as authentication entities. The credential in some embodiments incorporates an identifier or other information sufficient to allow the authentication entity to identify the corresponding final value.

It is to be appreciated however that the invention is not limited to use with credentials comprising intermediate hash values. For example in other embodiments the credential comprises a one time passcode or other type of tokencode generated by an authentication token implemented in or otherwise associated with the client . Such an authentication token illustratively comprises one of a hardware authentication token and a software authentication token. The latter can be implemented as an application running on the client .

In step an API key is determined based at least in part on the credential associated with the particular access control interval. For example in some embodiments the API key determined in step comprises the credential itself or more generally at least a portion of the credential. As one particular illustration of such an arrangement in an embodiment in which the credential comprises an intermediate value of a hash chain the API key could comprise that intermediate value or a portion thereof. It is also possible to determine the API key as a function of at least a portion of the credential in combination with other information. For example the API key may comprise an intermediate value of a hash chain and an identifier utilizable by credential verifier to determine a final value of the hash chain. Numerous alternative techniques can be used to determine the API key for an access control interval based at least in part on the credential for that access control interval.

In step the API key determined based on the credential associated with the particular access control interval is utilized in an API key enrollment protocol. For example an oauth consumer key field of a message of the API key enrollment protocol can be configured to incorporate the API key determined based at least in part on the credential associated with the particular access control interval.

An exemplary message of one possible API key enrollment protocol is shown in . In this protocol also known as the OAuth protocol the message more particularly comprises a get request token call in which the API key is referred to as an oauth consumer key. Additional details regarding the OAuth protocol can be found in IETF RFC 5849 The OAuth 1.0 Protocol April 2010 and IETF RFC 6749 The OAuth 2.0 Authorization Framework October 2012 both of which are incorporated by reference herein.

It is to be appreciated however that embodiments of the invention are not limited to use with the OAuth protocol. Accordingly numerous other standardized or non standardized API key enrollment protocols can be used. The term key enrollment protocol as used herein is therefore intended to be broadly construed.

In step the obtaining determining and utilizing operations of respective steps and are repeated for one or more additional instances of the API key enrollment protocol where the one or more additional instances correspond to respective ones of one or more additional access control intervals.

Thus in the present embodiment API keys will vary over access control intervals automatically based on the underlying credentials. Within a given access control interval a given API key and the corresponding credential upon which it is based can be reused multiple times as needed to support secure access by the client to services provided by the server . It is also possible to configure the system such that a given credential can only be used once or a designated maximum number of times within its corresponding access control interval.

Accordingly after completion of the API key enrollment process in step for the API key determined for a current access control interval in step the enrolled API key can be utilized by the client to access services provided by the server or a related service provider. The server receives the API key in conjunction with a particular access attempt made by the client within the current access control interval extracts the credential from the API key using credential extractor and authenticates the credential to control access to a protected resource in the particular access control interval.

As a more particular example assume that the credential associated with the particular access control interval is generated based at least in part on a corresponding intermediate value of a hash chain and that the intermediate hash value or a function thereof is inserted into an API key as described in step . In this case after the extraction of the intermediate hash value by the credential extractor the credential verifier identifies the particular access control interval determines a number of hash iterations associated with the particular access control interval applies the number of hash iterations to the intermediate value and compares the result to the final value of the hash chain. If the result of the application of the hash iterations yields the final value of the hash chain the credential is accepted as authentic and otherwise the authentication fails.

Although the process as illustrated in the figure assumes interaction of client with a single server separate instances of this exemplary process possibly performed at least in part in parallel with one another can be used to generate API keys for multiple servers in other embodiments.

The particular processing operations and other system functionality described in conjunction with the flow diagram of are presented by way of illustrative example only and should not be construed as limiting the scope of the invention in any way. Alternative embodiments can use other types of processing operations for credential based generation of API keys as disclosed herein. For example the ordering of the process steps may be varied in other embodiments or certain steps may be performed concurrently with one another rather than serially. Also the process steps may be repeated periodically in conjunction with respective distinct API key generation instances.

The client and server in the embodiment are implemented as respective processing devices. Each such processing device generally comprises at least one processor and an associated memory and implements one or more functional modules for controlling certain features of the system .

The processor may comprise a microprocessor a microcontroller an application specific integrated circuit ASIC a field programmable gate array FPGA or other type of processing circuitry as well as portions or combinations of such circuitry elements.

The memory may comprise random access memory RAM read only memory ROM or other types of memory in any combination. The memory and other memories disclosed herein may be viewed as examples of what are more generally referred to as processor readable storage media storing executable computer program code or other types of software programs.

Articles of manufacture comprising such processor readable storage media are considered embodiments of the present invention. A given such article of manufacture may comprise for example a storage device such as a storage disk a storage array or an integrated circuit containing memory. The term article of manufacture as used herein should be understood to exclude transitory propagating signals.

The network interface allows the client to communicate over the network with the server and may comprise one or more conventional transceivers.

One or both of API key generator and credential processing module of the client may be implemented at least in part in the form of software that is stored in memory and executed by processor .

The processor like processor in client may similarly comprise a microprocessor a microcontroller an ASIC an FPGA or other type of processing circuitry as well as portions or combinations of such circuitry elements.

The memory like memory in client may similarly comprise RAM ROM or other types of memory in any combination.

The network interface allows the server to communicate over the network with the client and may comprise one or more conventional transceivers.

One or both of credential extractor and credential verifier of the server may be implemented at least in part in the form of software that is stored in memory and executed by processor .

The above noted network interfaces and may also be used to support various types of communication utilizing additional or alternative channels for communication of hash chain final values and other related information between system entities.

For example a separate secure channel not involving communication over network may be utilized by the central manager to provide a final value of a hash chain to the server for use by the credential verifier .

It is to be understood that the particular set of elements shown in for providing credential based API key generation is presented by way of illustrative example only and in other embodiments additional or alternative elements may be used. Thus another embodiment may include additional or alternative devices and other system entities as well as different arrangements of device modules and other components.

As mentioned previously various elements of system such as modules and of client and modules and of server may be implemented at least in part in the form of software. Such software is stored and executed utilizing respective memory and processor elements of at least one processing device. The system may include additional or alternative processing platforms as well as numerous distinct processing platforms in any combination with each such platform comprising one or more computers servers storage devices or other types of processing devices.

Such processing platforms may include cloud infrastructure comprising virtual machines VMs and one or more associated hypervisors. An example of a commercially available hypervisor platform that may be used to implement portions of the system is the VMware vSphere which may have an associated virtual infrastructure management system such as the VMware vCenter . The underlying physical machines may comprise one or more distributed processing platforms that include storage products such as VNX and Symmetrix VMAX both commercially available from EMC Corporation of Hopkinton Mass. A variety of other storage products and other processing platform components may be utilized to implement at least a portion of the system .

As noted above some embodiments of the invention utilize intermediate hash values as at least portions of respective credentials. In generating a hash chain providing the intermediate values the selected hash function is applied to the initial value a designated number of times to generate each intermediate value. Each of the resulting intermediate values is assumed to be truncated to 50 bits in the present embodiment in order to limit the size of these values.

By way of example each intermediate value of a given hash chain may be generated using SHA 256 iterated 100 000 times. A 128 bit cryptographic key may be used as the initial value. This is assumed to be a secret value that is stored as one of a plurality of initial values in the central manager or other entity that generates the credentials and is not accessible to the server and its credential verifier .

At initialization the number of access control intervals to be supported is determined. For example using a time window of 4 days a given year will have 92 windows. To provide access control over a total period of 20 years the hash chain should be configured with 1 840 intermediate values in order to support respective ones of the 1 840 windows each corresponding to an access control interval. Of course these particular values are merely examples and numerous other alternative values may be used as appropriate to the needs of a given implementation.

The final value of the hash chain is obtained after 1 841 steps in each of which SHA 256 is iterated 100 000 times and the resulting output is truncated to 50 bits. The first step is applied to the initial value and the final step provides the final value with each of the first 1 840 steps generating an intermediate value that will be used in generating a credential for a corresponding one of the 1 840 access control intervals. The final value of the hash chain may be considered a public value and is deployed on the server and possibly one or more additional servers. As noted above it is assumed that a given such server does not have access to the initial value and therefore has no ability to compute intermediate values from the initial value. Instead it applies an appropriate number of hash iterations to a received intermediate value to determine if the result matches the final value.

Thus in the above described example a given intermediate value is generated by repeatedly hashing the previous value in the chain 100 000 times and then outputting the most significant 50 bits of the 256 bit result. After outputting the most significant 50 bits of the intermediate value the remaining bits are set to zero before starting the 100 000 hash iterations for the next value. This process is also referred to herein as flattening the hash chain values and is assumed to be utilized in the present embodiment.

The following pseudocode illustrates the hash chain generation process in the above described example 

As long as the selected hash function is a one way function and the initial value remains secret obtaining the final value does not help an attacker.

The hash function for each step is iterated 100 000 times to slow down a potential brute force attacker.

It should be noted that this exemplary hash chain generation can be performed quickly on a modern processing device. For example a processing device based on an Intel Core i7 processor with 10 cores running at 2.4 GHz can perform about 20 million hashes per second such that all of the 1 840 intermediate values and the final value of the hash chain described above can be generated in less than 9 seconds.

Consider an attacker that obtains an intermediate hash value for one access control interval. In order for the attacker to determine the intermediate hash value for the next access control interval the attacker must find a value that when hashed 100 000 times yields the value held by the attacker. Even with many processing devices of the type described above this will take far longer than the duration of the next access control interval.

The intermediate values are associated with respective access control intervals in the process of generating the credentials. As mentioned previously the final value can be a public value and may be deployed on multiple servers without providing any ability to compute intermediate values from an initial value. Instead the initial value is securely stored as indicated above and the intermediate values are used in generating credentials for respective access control intervals. This involves associating the intermediate values with the access control intervals.

In the present embodiment a first one of the intermediate values immediately following the initial value of the hash chain is associated with a final one of the access control intervals and this reverse ordering continues through the intermediate values until a final one of the intermediate values immediately preceding the final value of the hash chain is associated with a first one of the access control intervals.

Thus the first access control interval corresponds to the intermediate value immediately preceding the final value such that hashing that intermediate value once yields the final value. Similarly the second access control interval corresponds to the intermediate value that precedes the final value by two positions such that hashing that intermediate value twice yields the final value. This inverse numbering continues with later access control intervals corresponding to respective intermediate values that are closer to the initial value and which therefore must be hashed more times to yield the final value.

A more detailed example of this type of association between hash chain intermediate values and access control intervals is illustrated in . This may be viewed as an example of a time synchronous embodiment in which the hash chain intermediate values correspond to access control intervals defined by discrete periods of time. More particularly in this example the access control intervals are defined as respective months.

Starting from an initial value the steps of the previously described hash chain generation are iterated 11 times to produce a sequence of 10 intermediate values numbered 1 through 10 followed by a final value with the hash iteration process being indicated by the right facing arrow.

The final value itself is not used to generate a valid credential but the intermediate value 10 that immediately precedes it is used to generate a valid credential. This last intermediate value 10 is associated with the first access control interval which is the month of February in this example. The other intermediate values 9 through 1 are then associated with the other access control intervals continuing in the reverse ordering indicated by the left facing arrow. More particularly intermediate values 9 through 1 are associated with respective access control intervals denoted in the figure as March April May June July August September October and November. Thus in the present embodiment the intermediate values at the end of the hash chain are associated with the earliest access control intervals.

Although months are used in this example other time intervals such as hours days or weeks may be used to define access control intervals in other embodiments.

The final value of the hash chain is deployed on the server in a manner accessible to the credential verifier . As mentioned above the final value from the same hash chain can be provided to each of a plurality of servers or different final values generated for different hash chains can be provided to respective ones of the plurality of servers. The final values in the present embodiment are considered public values and accordingly do not need to be provided over a secure channel.

An intermediate value associated with a particular interval is utilized to generate a credential that the API key generator uses to generate an API key for that interval.

Upon receipt of an API key from the client in conjunction with an access attempt the credential is extracted by the credential extractor and the intermediate value of the hash chain is hashed an appropriate number of times to determine if the expected final value is obtained as part of the process for authenticating the credential in the credential verifier .

If the intermediate value of the hash chain is validated the client is granted access to the requested service although grant of access may possibly be conditioned on one or more additional checks beyond validation of the intermediate hash value. Otherwise the access attempt utilizing the API key is rejected.

As noted above additional checks may be incorporated into the authentication process. For example disable limit counters may be maintained that count the number of unsuccessful authentication attempts by a particular user within a given time frame. Further authentication attempts by that user after a specified disable limit has been reached may be automatically rejected.

Also a check of the current time may be performed against a stored high water mark. In embodiments that utilize time intervals such as such as hours days weeks or months to define access control intervals the credential verifier may be configured to incorporate or otherwise access a clock in order to determine how many times to hash the intermediate value before the final value is reached. When the clock reaches the start of a predetermined access control interval the credential verifier records this high water mark to disk or other nonvolatile storage. Then during the validation of an intermediate value the credential verifier checks the current clock value against the stored high water mark. If the current clock value precedes the high water mark in time the authentication request is rejected and additional auditing actions may be taken such as for example recording the suspected clock tampering incident to a log or alerting an administrator.

The high water mark may be recorded for example in a Last Login field of a secure data structure of the credential verifier as the latest time window for which a valid credential has been received by that module.

In an embodiment utilizing a credential of the type shown in the current time window is not explicitly included in the credential. Instead access control intervals corresponding to respective fixed time windows are utilized and it is assumed that the credential verifier knows the current time window.

Alternative formats may be used that explicitly carry an indication of time in the credential. This approach has the advantage of specifying the particular time period for which the credential is valid. In the context of the example given above as there are 8 760 hours in a year Start Hour and Duration fields may be included in the credential and used to uniquely indicate respective starting and ending hours. Alternative time indication arrangements could be used to reduce the bit widths of these fields.

As mentioned previously in some embodiments an API key determined based on a given intermediate hash value or other credential can be reused multiple times within the corresponding access control interval. Other embodiments of the invention can be configured to provide a one time passcode mechanism where an API key determined based on a given intermediate hash value or other credential is used only once and then discarded.

In one possible arrangement of this type there is assumed to be only one verifier checking the intermediate hash value against the stored final value. The verifier in this embodiment is the credential verifier of the server although other system entities can serve as verifiers in other embodiments. After a given intermediate hash value is used the corresponding credential is then marked as used by the verifier and cannot be used again. This makes the intermediate hash value a single use code and allows the system to defend against a replay of a previously issued credential.

For example the last used intermediate hash value may be associated with the previously described high water mark such that this intermediate hash value and all previously used intermediate hash values are no longer valid. Even if one or more intermediate hash values have not been used for example if hash value 10 of was never seen by the verifier and the verifier sees hash value 8 the verifier would set the high water mark at hash value 8 and disallow any future use of hash values 8 9 or 10. Such an arrangement advantageously prevents replay of an old credential. It also prevents other attacks in which the attacker tries to intercept an intermediate hash value and use it to generate other intermediate hash values closer to the final value.

Instead of maintaining a separate high water mark the verifier could instead simply update the stored final value to the hash value of the last valid credential. For example if the verifier sees hash value 8 of the verifier would simply prune the hash chain making hash value 8 the new final value. As a result there would be no way for an attacker to ever use hash value 8 or the now non existent hash values 9 or 10. This also makes subsequent authentications more efficient in that fewer applications of the hash function will be required to reach the new final value while also maintaining protection against the attacks described previously.

In some embodiments the hash chain intermediate values correspond to access control intervals defined by discrete periods of time although it is to be appreciated that other techniques may be used to define access control intervals in other embodiments.

In generating credentials a particular hash function an initial value and the number of time intervals to be supported are determined. As indicated previously various known one way hash functions such as MD5 SHA 1 and SHA 256 may be used as the hash function. Also a cryptographic key may be selected as the initial value. The initial value must be protected in order to protect the security of the access control process and accordingly should be stored in a secure memory accessible only to the central manager or other system entity that generates the credentials. The number of time intervals to be supported may be selected to accommodate at least the expected useful lifetime of the server or its associated services. As an illustrative example if the time intervals have a duration of one month generating a hash chain having about 10 000 intermediate values would handle many more years than the expected lifetime of the server or its associated services.

In an embodiment involving multiple hash chains having distinct initial values where different final values are provided to different servers the distinct initial values of the respective hash chains may be derived from a common key. For example each of the servers may have associated identifying information and the distinct initial values of the respective hash chains used to protect access to the respective servers may each be determined as a function of the common key and the identifying information for the corresponding server.

It is also possible to use the same base hash chain configuration to produce multiple distinct final values. For example one could combine an identifier of the server with a common initial value using addition XOR or other similar function.

In some embodiments efficiency advantages can be gained by replacing a linear hash chain with one based on a tree structure. For example a given hash chain may comprise a tree having one or more interior branches each defined by application of a one way hash function to a common key and identifying information.

It is to be appreciated that the particular credential formats described above in conjunction with are presented by way of example only and should not be construed as limiting the scope of the invention in any way. Numerous other credential formats may be used in other embodiments.

The API key service is a trusted third party relative to the service requester and the service provider and is illustratively implemented as a cloud based service although other implementations are possible. At least one processing device comprising the API key service is configured for communication with respective processing devices corresponding to the service requester and the service provider over one or more networks that are not explicitly shown in the figure.

The service requester service provider and API key service may be viewed in some implementations as corresponding generally to the client server and central manager respectively of the embodiment. Each of the service requester service provider and API key service is assumed to be implemented in a separate processing platform comprising one or more processing devices although in other embodiments multiple ones of the system elements such as service provider and API key service can be implemented at least in part on the same processing platform using different portions of one or more processing devices.

In the system the API key service receives a request for an API key obtains a credential and generates the API key based at least in part on the credential. The API key service provides the API key to at least one of service requester and service provider .

For example the service provider in some embodiments requests the API key from the API key service responsive to a request from the service requester . The service provider receives the API key from the API key service and utilizes the API key received from the API key service to validate a presented API key received from the service requester in conjunction with a service request from the service requester.

The API key service illustratively associates the API key with identification information of the service requester such as one or more of verification information and network address information of the service requester . For example the identification information of the service requester may be received in conjunction with registration of the service requester with the API key service .

The network address information of the service requester in some embodiments is maintained by the service provider and not by the API key service .

At least a portion of the identification information of the service requester is obtained by the service provider from the service requester in conjunction with registration of the service requester with the service provider .

Additionally or alternatively at least a portion of the identification information of the service requester is provided to the API key service by the service provider in conjunction with the request for the API key.

In some embodiments the API key service is implemented utilizing a plurality of servers and at least a portion of the identification information of the service requester is stored in a distributed manner over the plurality of servers.

The API key service upon receiving from the service provider a presented API key for validation in conjunction with a service request from the service requester generates a cryptographically secured assertion for the presented API key based at least in part on the identification information of the service requester . The assertion is utilized to validate the presented API key. For example utilizing the assertion to validate the presented API key illustratively comprises providing the assertion to the service provider in order to allow the service provider to validate the presented API key. The cryptographically secured assertion referred to herein is intended to be broadly construed and accordingly can take on any of a variety of different formats.

It should be noted that the embodiment does not utilize hash chain intermediate values as respective credentials. In addition the credentials in the embodiment need not be associated with respective access control intervals.

A more detailed example of the interactions between the service requester service provider and API key service will now be described with reference to the numbered arrows shown in . In this example the interactions include the following steps with SR SP and AKS denoting the service requester service provider and API key service respectively and each step corresponding to one or more of the numbered arrows shown in the figure 

1. The SR requests an API key from the SP in order to be able to submit service requests to the SP. The request for the API key includes any identity verification information required by the SP and the network address to which any responses to service requests should be sent. The identity verification information and the network address are examples of what are more generally referred to above as verification information and network address information respectively and still more generally as identification information of the SR. It should be noted that verification may itself be a multi step process as will be appreciated by those skilled in the art.

2. The SP securely requests the AKS to issue a plaintext token as the API key for the SR to use in requests. The plaintext token is an example of what is more generally referred to herein as a credential.

3. The AKS issues the API key to the SR and the SP. The AKS utilizes the identification information previously provided by the SP in order to provide the API key to the SR.

6. The AKS prepares a cryptographically secured assertion of the SR identity and attributes corresponding to the plaintext token and securely returns this assertion to the SP.

7. The SP compares the assertion against its registered information for the SR checks authorization for the request from that SR and if the SR is authorized sends the response to the registered network address for the SR.

The above described exemplary process provides the SP with a high degree of confidence that the response is being returned to an SR that is authorized to receive such a response. It uses the API key as a plaintext token representing the SR but bases its trust on the AKS and the information it provides in the assertion rather than on the API key itself.

In other implementations of the process above the SR identification information can be segmented across two or more AKS servers to minimize risks related to security breach in one of the AKS servers. Additionally or alternatively the SR identification information can be segmented across the SP and the AKS. In such an arrangement for example the registered network address could be maintained by the SP. Also in other implementations the SR could register directly with the AKS rather than the AKS using SR identification information provided by the SP. Numerous other variants of the embodiment are possible.

The illustrative embodiments described herein can provide a number of significant advantages relative to conventional practice. For example these embodiments are configured to avoid the above noted problems associated with use of static passwords. Moreover the credential generation and processing techniques disclosed herein can be readily deployed at low cost using existing API key protocols and infrastructure. Highly secure API keys can therefore be provided without changing current key formats or their manner of use in service requests.

Accordingly embodiments of the invention can be implemented in a wide variety of API key contexts including many different otherwise conventional systems that implement access control using API keys.

Moreover embodiments of the invention can be configured to carry other types of information in an API key field of a given message.

For example an API key field could be used as a response portion of a challenge response protocol. In one possible arrangement of this type after each successful authentication of a given client a server passes a random or otherwise unique value x back to the client as a challenge. The next time the client authenticates to the server the client computes x using a designated cryptographic function . The result is sent back to the server as a response to the challenge using the API key field.

As another example the API key field can be used to carry a public key signature along with a fixed client identifier. In one possible arrangement of this type the signature is over the client identifier server identifier and a unique value such as time of day. A tokenization server receives the client identifier determines the unique value and checks the signature. The tokenization server validates the signature and outputs an API key which is input to a resource server.

It should again be emphasized that the above described embodiments of the invention are presented for purposes of illustration only. Many variations may be made in the particular arrangements shown. For example although described in the context of particular system and device configurations the techniques are applicable to a wide variety of other types of information processing systems processing platforms networks and processing device configurations. Also different arrangements of API keys credential formats and access control processes may be used. Moreover the assumptions made herein in the context of describing some illustrative embodiments should not be construed as limitations or requirements of the invention and need not apply in other embodiments. Numerous other alternative embodiments within the scope of the appended claims will be readily apparent to those skilled in the art.

