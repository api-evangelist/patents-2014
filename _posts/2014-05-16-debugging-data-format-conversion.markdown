---

title: Debugging data format conversion
abstract: In an approach for generating a compiler listing using Debugging With Attributed Record Format (DWARF) debugging data, a processor receives DWARF debugging data associated with source code of a programming language. A processor extracts information from the DWARF debugging data, wherein the information comprises at least source code lines, variable declaration lines, and variable reference lines. A processor generates a compiler listing based on the information extracted from the DWARF debugging data, wherein the compiler listing includes at least a symbol table, and cross-reference information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09195567&OS=09195567&RS=09195567
owner: International Business Machines Corporation
number: 09195567
owner_city: Armonk
owner_country: US
publication_date: 20140516
---
The present invention relates generally to the field of debugging software and more particularly to generating a compiler listing using DWARF debugging data format information.

A debugging data format is a means of storing information about a compiled program for use by high level debuggers. Modern debugging data formats may store enough information to allow source level debugging. The Debugging With Attribute Record Format DWARF and symbol table entries STABS formats are the most widely used executable and linking format ELF . Other debugging formats include common object file format COFF PE COFF object module format OMF and IEEE 695.

DWARF is a more recent format for ELF files. DWARF was created to overcome shortcomings in STAB allowing for more detailed and compact descriptions of data structures data variable movement and complex language structures such as in C. The debugging information is stored in sections in the object file.

The basic descriptive entity in DWARF is the debugging information entry DIE . A DIE has a tag that specifies what the DIE describes and a list of attributes that fills in details and further describes the entity. Attributes may contain a variety of values constants such as a function name variables such as the start address for a function or references to another DIE such as for the type of a function s return value .

Aspects of an embodiment of the present invention disclose a method computer program product and computing system for generating a compiler listing using Debugging With Attributed Record Format DWARF debugging data. A processor receives DWARF debugging data associated with source code of a programming language. A processor extracts information from the DWARF debugging data wherein the information comprises at least source code lines variable declaration lines and variable reference lines. A processor generates a compiler listing based on the information extracted from the DWARF debugging data wherein the compiler listing includes at least a symbol table and cross reference information.

Embodiments of the present invention recognize that many modern compilers have moved to a standardized debugging data format called DWARF. Embodiments of the present invention recognize that not all modern debuggers support the DWARF debugging data format. Embodiments of the present invention propose a method computer program product and computer system that allows for the conversion of DWARF debugging data into a compiler listing. A compiler listing is a type of compiler output that contains information about a particular compilation. As a debugging aid a compiler listing is useful for determining what has gone wrong in a compilation.

In the depicted embodiment computing system includes server . Computing system may also include a network servers computing devices or other devices not shown.

Server may be a management server a web server or any other electronic device or computing system capable of processing program instructions and receiving and sending data. In some embodiments server may be a laptop computer tablet computer netbook computer personal computer PC a desktop computer a personal digital assistant PDA a smart phone or any programmable electronic device. In other embodiments server may represent a server computing system utilizing multiple computers as a server system such as in a cloud computing environment. Server contains source code compiler debugging data repository debugging data converter and debugger . Server may include components as depicted and described in further detail with respect to .

Source code is a generic set of source code to be compiled by compiler . Embodiments of source code may be written in COBOL C Smalltalk or other programming languages. In some embodiments source code resides on server . In other embodiments source code may reside on another server or another computing device provided that source code is accessible to compiler .

Compiler is a compiler that generates DWARF debugging data during the compilation of source code such as source code . A compiler transforms source code written in a programming language i.e. the source language into another computer language i.e. the target language which is often object code. In some embodiments compiler stores DWARF debugging data to a repository such as debugging data repository for access by debugging data converter . In some embodiments compiler is a function of an integrated development environment IDE . In other embodiments compiler is a stand alone compiler. An IDE is a software application that provides comprehensive facilities to computer programmers for software development such as source code editors build automation tools compilers interpreters debuggers etc. In one embodiment compiler resides on server . In another embodiment compiler may reside on another server or another computing device provided that compiler has access to source code and debugging data repository .

Debugging data repository may be a repository that may be written and read by compiler debugging data converter and debugger . DWARF debugging data and converted debugging data may be stored to debugging data repository . In some embodiments converted debugging data may be annotated to indicate corresponding DWARF debugging data. In one embodiment debugging data repository resides on server . In other embodiments debugging data repository may reside on another server or another computing device provided that debugging data repository is accessible to compiler debugging data converter and debugger .

Debugging data converter operates to convert DWARF debugging data into a compiler listing such that a debugger that does not support the DWARF format such as debugger extracts debugging information from the compiler listing. A compiler listing may include the following information assigned offsets into the object program for each source line in order to determine which source line is being executed when the program malfunctions a symbol table that includes information about variable declarations and assigned addresses in storage for variables and cross reference information that includes information indicating which variable s are referenced on each source line. In some embodiments debugging data converter converts DWARF debugging data into a compiler listing that is human readable. Debugging data converter may store the generated compiler listing to a repository such as debugging data repository . In one embodiment debugging data converter resides on server . In another embodiment debugging data converter may reside on another server or another computing device provided that debugging data converter has access to debugging data repository .

Debugger is a debugger that does not support the DWARF debugging data format. In embodiments of the present invention debugger supports the compiler listing generated by debugging data converter . A debugger is used to test and debug other programs. In one embodiment debugger resides on server . In another embodiment debugger may reside on another server or another computing device provided that debugger has access to debugging data repository .

In one embodiment initially a user may write source code such as source code . Source code may be any generic source code written in any one of a number of computer programming languages such as C Smalltalk or COBOL. Source code may be compiled by compiler . Compiler may be any compiler capable of generating DWARF debugging data during compilation of source code . In some embodiments compiler may store generated DWARF data to a repository such as debugging data repository .

In step debugging data converter receives DWARF debugging data. In some embodiments debugging data converter receives DWARF debugging data from a compiler such as compiler . In other embodiments debugging data converter accesses and retrieves DWARF debugging data from a repository such as debugging data repository . In still other embodiments debugging data converter is a function of debugger such that debugging data converter can convert DWARF debugging data into a debugging data format debugger can comprehend.

In step debugging data converter extracts source lines from the DWARF debugging data. DWARF debugging data is organized into blocks. Each block may contain information related to one or more source lines of source code . In some embodiments debugging data converter extracts each source line from each block and assigns each extracted source line a sequential line number. In some embodiments debugging data converter differentiates line numbers via a newline character. A newline character is a special character or sequence of characters signifying the end of a line of text. In some embodiments debugging data converter uses an application programming interface API to extract each source line. An API is a set of routines protocols and tools for building software applications by specifying how software components should interact. In some embodiments APIs used by debugging data converter are published as an open standard for UNIX .

In step debugging data converter builds a verbcode table. A verbcode table is a table including each verb associated with source code as deciphered from the DWARF debugging data along with one or more reference lines associated with each respective verb. A verb in the present context is a grammatical verb indicating an action to be taken within the computing language. For example IF ADD READ WRITE are each verbs. In some embodiments the verbcode table is organized alphabetically according to verb. In other embodiments the verbcode table may be organized in another manner.

In step debugging data converter extracts the data name and definition line for each variable of source code from the DWARF debugging data. DWARF debugging data comprises multiple debugging information entries DIEs . Each DIE has a tag which specifies what the DIE describes and a list of attributes which fill in details and further describes the entity. DIE attributes may contain a variety of values such as constants such as a function name variables such as the start address for a function or references to another DIE such as for the type of a function s return value . In some embodiments debugging data converter accesses each variable DIE i.e. DW TAG variable and retrieves from each variable DIE the respective definition line or declaration line and data name of the variable. In some embodiments the declaration line is an attribute included within the field DW AT decl line and the data name is an attribute included within the field DW AT name. In some embodiments debugging data converter may extract data name and definition line information for each variable through the use of one or more APIs.

In step debugging data converter builds a table of references. In embodiments of the present invention debugging data converter initially builds a reference list by accessing applicable information stored within the DWARF debugging data. In embodiments of the present invention a reference list includes each variable along with each respective line of source code within which the variable is referenced. In some embodiments debugging data converter may further identify source fragments which locate the parts of the source line that reference each particular variable. The DIE for a variable may include a DIE attribute indicating a list of source coordinates i.e. row column where the variable is referenced. Debugging data converter may use an identified row to identify a line of source code where the variable is referenced. In some embodiments debugging data converter may use a column as a parsing start position if further info regarding the variable s use was needed.

Using the retrieved source fragments debugging data converter may create a table to facilitate locating a fragment according to variable name. Debugging data converter may additionally determine whether each variable referenced in each source fragment is modified. Using the source coordinates where the variable is referenced debugging data converter can access the source fragments for the variable. Data debugging converter can match the row and variable name to an indicated DIE location at an offset where a DIE attribute indicates whether the variable in question is modified. This process can be used for each location the variable is referenced. In some embodiments if debugging data converter determines that a variable referenced in a source fragment is modified debugging data converter annotates the reference line of the source fragment within the table of variable references to indicate a location where the variable may be modified. In some embodiments the annotation is an M in from of the reference line. In some embodiments debugging data converter may determine the location in which each variable is referenced in source code and whether or not the source code line modifies the each respective variable using one or more APIs.

In step debugging data converter builds a symbol table. In embodiments of the present invention a symbol table includes information such as data names and associated structure hierarchy information base locator information and or assembler data definition information. In some embodiments debugging data converter retrieves a list of variables and associated structure hierarchy for each variable. Debugging data converter may determine variable structure hierarchy by accessing children or sibling DIEs related to a base DIE. In some embodiments debugging data converter may further collect base type info used to formulate a declaration or definition. A base type is the type of a unit of data such as an array. In some embodiments for example when source code was written in the COBOL programming language debugging data converter extract information such as base locator information from the DWARF debugging data that relates to the data division section of the COBOL program. The data division is the part of a COBOL program in which the format and layout of external files and databases and internally used variables and constants are defined. In some embodiments debugging data converter further accesses a location list of addressing expressions within the DWARF debugging data and processes the expressions to determine an offset of the respective variable or structure member. In some embodiments debugging data converter accesses information necessary to build the symbol table using one or more APIs.

In step debugging data converter builds an offset listing from information retrieved from the DWARF debugging data. An offset listing includes verbs such as the verbs discussed in reference to step along with the line number from the source code and the line offset value. The line offset value indicates the offset from the start of the program i.e. source code of the code generated for the respective verb. In some embodiments the offset value will be in hexadecimal notation. In some embodiments debugging data converter may gather line number information and line offset information using one or more APIs.

In step debugging data converter generates a static and or automatic map using information extracted from the DWARF debugging data. Each map may provide variable addressing. A static map lists all static variables and is sorted by hexadecimal offset. An automatic map lists for each block of the DWARF debugging data all automatic variables sorted by hex offset. In some embodiments debugging data converter may gather offset information using one or more APIs and information from the generated symbol table.

Server includes communications fabric which provides communications between computer processor s memory persistent storage communications unit and input output I O interface s . Communications fabric can be implemented with any architecture designed for passing data and or control information between processors such as microprocessors communications and network processors etc. system memory peripheral devices and any other hardware components within a system. For example communications fabric can be implemented with one or more buses.

Memory and persistent storage are computer readable storage media. In this embodiment memory includes random access memory RAM and cache memory . In general memory can include any suitable volatile or non volatile computer readable storage media.

Source code compiler debugging data repository debugging data converter and debugger are stored in persistent storage for execution and or access by one or more of the respective computer processors via one or more memories of memory . In this embodiment persistent storage includes a magnetic hard disk drive. Alternatively or in addition to a magnetic hard disk drive persistent storage can include a solid state hard drive a semiconductor storage device read only memory ROM erasable programmable read only memory EPROM flash memory or any other computer readable storage media that is capable of storing program instructions or digital information.

The media used by persistent storage may also be removable. For example a removable hard drive may be used for persistent storage . Other examples include optical and magnetic disks thumb drives and smart cards that are inserted into a drive for transfer onto another computer readable storage medium that is also part of persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices. In these examples communications unit includes one or more network interface cards. Communications unit may provide communications through the use of either or both physical and wireless communications links. Source code compiler debugging data repository debugging data converter and debugger may be downloaded to persistent storage through communications unit .

I O interface s allows for input and output of data with other devices that may be connected to server . For example I O interface may provide a connection to external devices such as a keyboard keypad a touch screen and or some other suitable input device. External devices can also include portable computer readable storage media such as for example thumb drives portable optical or magnetic disks and memory cards. Software and data used to practice embodiments of the present invention e.g. source code compiler debugging data repository debugging data converter and debugger can be stored on such portable computer readable storage media and can be loaded onto persistent storage via I O interface s . I O interface s also connect to a display .

The programs described herein are identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular program nomenclature herein is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

