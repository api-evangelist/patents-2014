---

title: System and method for providing access to data in a plurality of software development systems
abstract: Systems and method are provided for determining risk of product release failure in an environment where multiple independent releases come together into a shared environment. A risk factor for success or failure of a product release is based on release information input by a user and information input by other users regarding releases, the users typically on distinct development systems. The information from each distinct system is mapped (e.g., normalized and weighted) into a common schema. A risk index for the product release is determined. The risk index, risk factors, and/or associated information therewith, is presented to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09092575&OS=09092575&RS=09092575
owner: FMR LLC
number: 09092575
owner_city: Boston
owner_country: US
publication_date: 20140825
---
This application is continuation in part of co pending application Ser. No. 14 032 000 filed on Sep. 19 2013 which is owned by the assigned of the instant application and the disclosure of which is incorporated herein by reference in its entirety

The invention relates generally to software development management and planning systems and more particularly to accessing and managing information from a plurality of third party software development systems from a single application where each software development system has a unique data module. The invention further relates to creating an agile software development management system for a plurality of third party software development systems capable of agile processes such as a daily standup for a plurality of teams at the same or different location with the same or different software development management systems. The invention further relates to determining a risk of success or failure of a product release in an environment where multiple independent product releases come together into a shared environment.

The structure and progressive method of developing a software product is known as a software development process or a software development life cycle. Several models exist for such processes each with its own methodologies for approaches to tasks activities and personal that exist and take place during the process of development. For example a software development team may choose to utilize a waterfall model spiral modal iterative or incremental model agile methods or rapid development. Many models exist because project management can be difficult and without effective project management developing software can become uncontrollable get off track and end up being delivered late over budget and or with a lot of bugs or issues to fix. Software developers therefore always need a way to effectively manage the process of development to meet user expectations in terms of functionality cost and delivery schedules. Whenever software fails to meet these expectations it is often a cause of ineffective process management rather than ineffective software developers or programmers.

One of the more recent trends in these methods of software development is the Agile software development method. This method is a variant of an iterative and incremental development type strategy where requirements and solutions are created through collaboration of the software development team via self organizing and cross functional teams. The Agile software development method is aptly named for its promotion of agile adaptive planning and flexible response to changes in requirements. The Agile method breaks tasks into small incremental steps made with minimal planning. Iterations of the software are produced in short time frames as well typically lasting only one to four weeks. Each iteration generally involves minimal planning requirements design programming and testing. At the end of each iteration a working product is demonstrated which allows for short incremental steps on a working product. These small workable steps minimize the risk involved in each change or step and allows the project to easily adapt to new requirements or issues that pop up during development even when such changes are made late in the development process. Although each iteration does not particularly add much functionality to warrant a new release the method does provide a workable release with minimal issues at the end of each iteration.

The Agile method also promotes face to face interaction amongst the software development team and often management as well. Such interaction generally takes place amongst teams at the same location often even in the same room or bullpen to further promote the ability to collaborate change as needed and adapt to those changes or issues that arise. For example a popular agile process involves a Daily Standup in which each member of the team goes over their current or upcoming tasks and updates the team on the progress. This standup and other interaction often includes the use of sticky notes where each task is listed on a sticky note and moved along the board as the task goes through the process to completion. Similarly white boards or other bullet boards can be used to track tasks. As great as these physical representations are for collaborative efforts these physical representations are ineffective for management often requiring duplicative effort for management to audit the board create status reports to track history and of course such physical representations are difficult to send to remote team members or remote team locations. Daily contact communication and management of such agile processes are strained by the inability to effectively coordinate larger or geographically distant teams that cannot easily incorporate the collaborative spirit of the agile process and methods. Thus such physical collaboration and interaction is complicated by larger or distant teams that cannot all be in the same location.

Throughout the years project management tools that have been created to more effectively organize and document the software development process. Specifically in more recent years project management tools have been designed to aid developers using the agile method as well as other methods and to help larger and geographically distant teams interact over a network or the internet. For the sake of collaboration consistency and effectiveness such a management tool would actually require the consolidating and facilitating of project management product management customer management programmers testers etc. into a single environment or management tool. The reality is however that currently several management tools are utilized by the manager programmer or tester to accommodate their individual needs and no common management tool is used to accommodate everyone s needs throughout the development process. Further still different teams at different locations may choose to utilize different management tools that they are more familiar with or better suit their needs which further complicate the overall management process of software development. For example numerous tools are available some including RTC HP Quality Center QC Service Manager Clear Case CC Sonar PPMC Jira Fitness Cucumber GitHub Jenkins Evolven Clarity Visio or even Excel or Access to track the development process. Many of these tools lack an overall management capability and are only designed for a particular part or person in the development process. For example RTC tracks projects work items stories tasks releases iterations and signoffs whereas QC tracks test plans test cases test executions defects and root causes of defects. Likewise Clear Case may track only the source code or Sonar only tracks the build and the code quality metrics. Service Manager instead tracks release tickets change tickets incidents reports and overall problems. Other tools like CMDB track application registries product lines products databases and servers and Project Team tracks project team attributes personnel business deliverables and product alignment. On more of the management side PPMC Financials tracks project resources and project financials. Thus each of these tools does not have an overall management capability and are designed for specific parts of the development process.

As a more detailed example many delivery teams use RTC for planning and execution of software design and development. Unfortunately RTC lacks useful planning and tracking capabilities forcing teams to employ different tools and techniques outside of RTC adding unnecessary effort and complexity. These extra tools unfortunately leads to duplicative work difficult oversight inefficiency and can create a separation of information that should be viewed together or collaboratively amongst the various parts of the team. Further still these independent management tools are not designed to interact and are composed of unique data modules that are not compatible with one another making it difficult to take the data from one tool to another. Again this incompatibility leads to duplicative work difficult oversight inefficiency and can create a separation of information.

Although some tools offer suites of management tools that interact it can be difficult to get teams and or data to migrate to a different tool or suite of tools because people are creatures of habit and often managers programmers testers etc. in the software development process often get familiar or comfortable with certain tools making it hard and unlikely for personnel to adjust. Often this leaves such new tools unused and thus ineffective. Additionally these suits are incapable of interacting with other third party tools. The inability to effectively manage the plurality of software development tools utilized across the development process across various development teams across various development tools and across geographically disperse locations not only interferes with the collaborative style of the agile process but also breaks down the necessary oversight essential to effective project management via any software development methodology.

Another difficulty with managing development and releases of products e.g. software across teams is related to releasing products into a common environment where the product releases are from multiple independent teams. For example in Agile systems that espouse smaller quicker and more incremental changes to be built by independent teams the teams are not always synchronized with one another and one team can schedule to release a product at a time that effects the scheduled release of another s team product. For example Team A can schedule on day 1 a product release that causes changes to databases X. In order to change database X databases Y and Z must also be modified. Team B can schedule on Day 1 a product release that causes changes to database Z. Currently when Team B schedules the release to change database Z Team B likely can only see that database X has scheduled changes on Day 1 and thus thinks that no collision can occur. Therefore it is desirable to provide managers scheduling product releases into a common environment with accurate information regarding the likelihood of success of their release.

Described herein are various technologies and methods for providing a project management tool that enables teams to more effectively plan collaborate and communicate as well as provides a more intuitive way to manage agile projects. The technologies and methods described allow for tool and geographically disperse development teams to visualize and interact using a common electronic backlog without delay of double entry or transcribing from a plurality of physical or electrical management tools. These technologies and methods described provide a consolidated view of the project data for understanding the health of a project improving decision making and allowing teams to manipulate the data off a common data set without the need to do independent analysis or duplicative work.

The technologies and method describe also provide a product release risk assessment to a manager making release collisions and probability of release failure smaller. The technologies and methods allow for easier tracking and management of key factors that have the highest risk of impacting stability by virtue of the ability to collect and consider data from a multiple independent sources having varying formats.

Other advantages include providing systematic identification of dependencies between different projects releases assets rather than relying on detailed understanding and institutional knowledge of team members. Other advantages include identifying dependencies earlier in the process e.g. at a time of planning rather than having to wait for individual change tickets to be opened that identify affected assets.

Other advantages include the ability to identify collisions earlier which can allow teams to move their release dates at the beginning of development e.g. 12 weeks in advance versus what is typical after the release has been tested and packaged e.g. 12 days in advance .

Other advantages include less experienced team members are allowed to manage the release process without increasing risk and requiring less oversight from senior management which can lead to lower overall cost. Other advantages allow for identifying time windows where there is too much work going on versus available capacity or available time. Other advantages include identifying resource constraints and or bottlenecks where certain team members may be overcommitted.

Other advantages include by tracking failed releases based on affected assets teams can identify dependencies that may not have been identified or understood before leading to better configuration data in an IT asset management system.

The technologies and methods consistent with this invention overcome the software administration management and maintenance issues of having a plurality of software development tools in the prior art by providing in various embodiments a computer implemented method for a software development planning and management system operative across a plurality of software development systems including quality control systems project management systems and service manger systems where each software development system has a unique data model. The system comprises a plurality of application programming interfaces wherein an application programming interface is associated with at least one of the plurality of software development systems. Each application programming interface is able to communicate with the at least one of the software development systems via the unique data model. For example the application programming interface is capable of retrieving data from the at least one associated software development system. Additionally the application programming interface is capable of saving data to the at least one associated software development system. In one embodiment the invention provides that at least one repository contains the retrieved data from each of the associated software development systems. The repository is a temporary location for caching the retrieved data. In another aspect the invention further provides that at least one domain table maps the retrieved data from an associated software development system to the retrieved data from each of the other associated software development systems to create the set of integrated data. With a set of integrated data the data management module can cache changes to the set of integrated data in the at least one repository and only save changes upon user selection or indication to save the changes. When the user selects to save the changes the data management module records changes to the set of integrated data via the plurality of application programming interfaces to each of the associated software development systems from which the data was retrieved.

In further embodiment of the computer implemented method for administering a software development planning and management system the system includes a plurality of software development systems where each software development system has a distinct data model and the method comprises providing a plurality of application programming interfaces. Each application programming interface is associated with at least one software development system and is capable of retrieving data from the at least one software development system. Additionally the application programming interface is capable of saving data to the at least one software development system. The system establishes via a computing device a session with a user. After the session is established each application programming interface retrieves a set of data retrieved from each of the associated software development systems. The system then caches via a data repository the set of data retrieved from each of the associated software development systems. The data repository is again a temporary memory location. The data management module then forms a set of integrated data by creating a plurality of at least one domain tables that map the set of data retrieved from each of the associated software development systems to the set of data retrieved from each of the other associated software development systems. Then the data management module caches changes to the set of integrated data in the data repository and saves upon user selection via the plurality of application programming interfaces changes to the set of integrated data through the associated application programming interface to each of the associated software development systems from which the data was originally retrieved.

In another embodiment the computer implemented method further comprises deleting changes to the set of integrated data cached in the data repository when the session ends. In another aspect the computer implemented method further comprises caching the set of data retrieved from each of the associated software development systems via a plurality of data repositories. In a further embodiment a plurality of remote computing devices establishes a plurality of sessions by a plurality of users wherein the plurality of users change the set of integrated data in real time. In this embodiment the method further involves caching via the data management module changes to the set of integrated data in the data repository and saving upon user selection via the plurality of application programming interfaces changes to the set of integrated data through the associated application programming interface to each of the associated software development systems from which the data was originally retrieved.

In a further embodiment the data management module refreshes a session from the plurality of sessions upon a user selection to refresh. In this embodiment the data management module discards the set of data retrieved from each of the associated software development systems as well as discards the changes made to that set of data that was not previously saved. The system then retrieves via the plurality of application programming interfaces a new set of data from each of the associated software development systems the new set of data contains changes from the plurality of users. The data management module then caches the new set of data from each of the associated software development systems in the data repository. Then the data management module forms a new set of integrated data by creating a plurality of domain tables that map the new set of data retrieved from each of the associated software development system to the new set of data retrieved from each of the other associated software development systems. Further the data management module caches changes to the new set of integrated data in the data repository and then the plurality of application programming interfaces save the changes to the new set of integrated data through the associated application programming interface to each of the associated software development systems from which the data was originally retrieved.

In another aspect the computer implemented method further comprises throwing via the data management module an error when the set of data retrieved from each of the associated software development systems does not map to the set of data retrieved from each of the other associated software development systems. In yet another aspect the data management module automatically sends a report to a manager of the associated software development system when the error is thrown. In a further embodiment the data management module can query based on user input the set of integrated data and provide a query report containing information queried from the set of integrated data.

In another aspect the data management module provides a display view of the set of integrated data wherein a user associates a sub set of the set of integrated data to at least one task to be completed. In a further embodiment the computer implemented method further involves creating via the data management module at least one task to be completed wherein the user associates the at least one task to software development information. The software development information can include at least one of a phase in a timeline sub task status priority level task size personnel resource team software requirement software quality testing task software integration task software release task release date software defect or any combination thereof. The data management module then updates the sub set of the set of integrated data based on the associated software development information. The data management module caches changes to this sub set of the set of integrated data in the data repository or into a plurality of data repositories. Upon user selection to save the plurality of application programming interfaces save any changes to the set of integrated data through the associated application programming interfaces to each of the associated software development systems from which the data was originally retrieved.

In another embodiment the data management module displays on a graphical user interface a view of the plurality of tasks to be completed in the form of a plurality of sticky notes on a sticky board. A sticky note can contain at least one task to be completed and the software development information associated with the sticky note or task. The sticky board is a grid of cells each cell representing a relationship between the sticky note placed in the cell and at least one of the phase in the timeline sub task status priority level or any combination thereof or any other software development process information. It is noted that the graphical user interface could display the sticky notes on a sticky board comprised of another set up besides a grid cell that would have the same effect of placing the sticky note in a location that represented a relationship between the sticky note and some development process information. In another aspect the display via the data management module can depict the sticky notes varying in size. The size of the sticky note can be made proportional to an estimated amount of time needed to complete the associated at least one task. The size of the sticky note could also depict other software development information for example the number of people working on the task or the estimated amount of iterations to completion. In yet another aspect the data management module can display the sticky notes varying in color. The color of the sticky note can represent a relationship between the sticky note and at least one of the phase in the timeline sub task status priority level personnel resource team software requirement software quality testing task software integration task software release task release date software defect or any combination thereof or any other software development information. In another aspect the computer implemented method via the data management module can associate text relating to at least one task on the created sticky note. For example the user might associate a group name task name software requirement or any other development information to the created sticky note. Further the data management module can further associate text to the sticky note relating to at least one of the phase in the timeline sub task status priority level personnel resource team software quality testing task software integration task software release task release date software defect or any combination thereof. In another aspect the computer implemented method further comprising displaying via the data management module the sticky note at a location within a cell where the location of the sticky note within the cell represents a relationship between the sticky note placed in the cell and at least one of the phase in the timeline sub task status priority level personnel resource team software requirement software quality testing task software integration task software release task release date software defect or any combination thereof.

In another embodiment the data management module provides an interactive display view of the plurality of sticky notes wherein the user can drag at least one of the sticky notes from a first cell on the grid to a second cell on the grid. When the user drags the sticky note to a new location on the grid or other sticky board set up the data management module updates the software development information of the dragged sticky note based on the change in position of the sticky note from the first cell to the second cell. This change is then reflected in the merged data. The data management module caches these changes to the sub set of the set of integrated data in the data repository. This data is in this temporary location until upon user selection to save. When the user selects to save the changes the plurality of application programming interfaces saves the changes to the set of integrated data through the associated application programming interface to each of the associated software development systems from which the data was originally retrieved. In a further aspect the data management module can also provide an interactive display view of the plurality of sticky notes wherein the user changes the size of at least one of the sticky notes. The change in size reflects a change to the cached merged data updating the information for that sticky note. For example a change in size denotes a change to the amount of time to complete the task or as another example the amount of people working on the task. Thus upon the user s change in size the data management module updates the software development information of the at least one sticky note based on the change in size wherein the data management module caches changes to the sub set of the set of integrated data in the data repository. This change is temporary until the user selects to save the changes. Upon user selection to save the plurality of application programming interfaces saves the changes to the set of integrated data through the associated application programming interface to each of the associated software development systems from which the data was originally retrieved.

In another embodiment the data management module can also provide an interactive display view of the plurality of sticky notes wherein the user changes the color of at least one of the sticky notes. When the user selects to change the color of the sticky note the data management module updates the software development information of the at least one sticky note based on the change in color i.e. the data management module caches changes to the sub set of the set of integrated data in the data repository. Again this change is temporary until the user selects to save the changes. Upon user selection to save the plurality of application programming interfaces save the changes to the set of integrated data through the associated application programming interface to each of the associated software development systems from which the data was originally retrieved. In a further embodiment the data management module can further provide an interactive display view of the plurality of sticky notes wherein the user changes the text of at least one of the sticky notes. The data management module updates the software development information of the at least one sticky note based on the change in text by the user i.e. the data management module caches changes to the sub set of the set of integrated data in the data repository. This change is temporary however upon the user s selection to save the changes the plurality of application programming interfaces saves the changes to the set of integrated data through the associated application programming interface to each of the associated software development systems from which the data was originally retrieved.

In another aspect the data management module can provide an interactive display view of the plurality of sticky notes wherein the user can filter the sticky notes on the sticky board by at least one of the phase in a timeline sub task status priority level task size personnel resource team software requirement software quality testing task software integration task software release task release date software defect or any combination thereof or any other provided software development information.

In another aspect the invention involves a computer implemented method of determining risk of product release failure in an environment where multiple independent releases come together into a shared environment. The method involves providing a plurality of application programming interfaces at least two application programming interfaces are associated with at least two of a plurality of distinct development systems respectively and capable of retrieving data from and providing data to its respective development system of the two of the distinct plurality of development systems the plurality of development systems each having a distinct data model and including project management systems software development systems quality control systems change control systems service management systems asset management systems configuration management systems or any combination thereof. The method also involves receiving via one application programming interface of the at least two application programming interfaces a request for a determination of risk of product release failure within the environment the request including a date and time for the product release. The method also involves receiving via each application programming interface of the at least two application programming interfaces a set of risk factors retrieved from each software development system of the two distinct plurality of software development systems that has a product release scheduled each set of risk factors comprises one or more risk factors and a date for its respective product release. The method also involves normalizing via a computing device each distinct set of risk factors to a common set of risk factors the common set of risk factors is based on a user defined domain mapping. The method also involves assigning via the computing device each item in each set of normalized risk factors a weight the weight is based on the user defined domain mapping. The method also involves determining a risk index for each of set of normalized risk factors the risk index based on each item in each set of normalized risk factors and each item s assigned weight. The method also involves displaying via the one application programming interface of the at least two application programming interfaces the risk index for each set of normalized risk factors to the user.

In some embodiments each set of risk factors relates to a product change scheduled for its respective development system of the plurality of development systems.

In some embodiments the method also involves determining via the computing device a confidence factor for each risk factor in each set of risk factors the confidence factor based on a type of operational tool the request was received from. In some embodiments the method also involves displaying via the computing device the confidence factor to the user.

In some embodiments the request further includes a request for determination of risk of collision for each change included in the product release.

In some embodiments the risk factors include application criticality database criticality size of change complexity of change volatility of change velocity of change frequency of change technology obsolescence interdependency with other systems interdependency with other databases integration with other applications common data elements common infrastructure stability history market event holidays resource scarcity or any combination thereof.

In some embodiments the method also involves displaying via the one application programming interface of the at least two application programming interfaces an interactive display view of a calendar showing the risk index for each of set of risk factors on the date of its respective product release.

In some embodiments the interactive display view of the calendar further comprises a hourly view a day view a weekly view a monthly view or any combination thereof. In some embodiments in the hourly view daily view and or weekly view each risk factor names and value is displayed to the user.

In some embodiments the method also involves displaying via the one application programming interface of the at least two application programming interfaces an interactive display view of assets that are in release conflict with other assets.

In some embodiments assets comprises applications databases infrastructure components or any combination thereof.

In some embodiments the method also involves displaying via the one application programming interface of the at least two application programming interfaces an interactive display view that allows a user to choose a release window based on the risk index availability resources or any combination thereof.

In some embodiments the method also involves generating by the computing device an alert to inform managers of potential collisions and suggest changes the alert comprising a phone call an email message a text message or any combination thereof.

These drawing figures do not limit the claims to the specific embodiments disclosed and described herein.

The second step is the retrieval of this information from the master databases of the software development systems . Data utilized in these software development systems is generally stored in a master database within the individual development tool as depicted in . Typically these individual development systems have their own distinct or unique data model such that data persisted to one development system is not compatible with data persisted to another development system simply because such systems are not built to communicate with one another. Although some companies develop suites of software for tracking various steps in the software development process such as IBM s Rational suite which is a lifecycle management suite of tools these suites are typically not compatible with software programs from other companies like QC or CC. In contrast however the present system is able to facilitate the use of data from these individual systems or even from the suite of tools all within one system which cuts back on the users needs to coordinate efforts amongst the different systems. This facilitation is achieved by collecting information from the individual systems or tools in a manner that allows manipulation of such data by the user in one program. This facilitation is illustrated in where data from each of these systems is retrieved i.e. read from the master database of the individual systems and transferred to a temporary cache or data repository . Data from the master database of an individual system can be read by an application program interface API that is associated with the particular software development system. As shown in an API reads data from the master database of the RTC tool. An API can be associated with a plurality of software development systems and the API is capable of retrieving data from and saving data to the plurality of software development systems as long as the API is capable of interacting with each of the software development systems unique data models. Additionally an API can be associated with a plurality of software development systems with the same data model such as in the case of a suite of software development tools. In another embodiment data from the master database of a software development tool can also be read in bulk by an extract transformation load or ETL Pull which would grab all the data from each master database. In this embodiment the ETL reads a large data set such as an overnight batch feed which may be started in advance by the user to obtain a larger quantity of data from each of the software development systems. In another embodiment an API alternatively and typically reads a smaller data set from the master database for a more interactive approach that allows quicker reading and writing of smaller data sets. The present system therefore can be configured to allow the user to select whether an entire system pull is needed for a complete overview of all the data via an ETL or whether the user is looking for a more interactive approach consisting of using only a subset of data from all the systems via an API . Alternatively the present system can be configured such that the system automatically determines whether an ETL or API is required to pull the data based on the users request or actions. For example if the user selects to view data via a Release Dashboard which is described later in greater detail such a request requires a larger set of data. Therefore the present system can be configured to automatically switch to an ETL to retrieve the larger data sets. Alternatively the present system can be configured to alert the user that their request requires a larger set of data requiring an ETL Pull and thereby may require a longer period of time to retrieve. If however the user selects to view a smaller set of data such as via a Daily Standup View which is described in greater detail below the present system can be configured to automatically switch to an API to retrieve this smaller set of data. Therefore the present system can be configured to automatically switch to utilize an API to retrieve the smaller data set. Retrieval of smaller sets of data by an API is appropriate for interactive and less data intensive dashboards.

Once data from the master databases of the software development systems is read by the API or ETL the retrieved data is stored by the system in a temporary cache or data repository . Typically the cache is an intraday cache however it is understood that other temporary caching works within the illustrated embodiment as well. Data retrieved from each of the master databases of the individual software development tools can be cached in a plurality of temporary data repositories . Alternatively in another embodiment the data from each of the master databases of the individual software development tools can be cached in a single temporary data repository not shown in . Data transferred from a software development system to the cache or data repositories by the API or ETL is a one way transfer of data. Although APIs are generally capable of two way communication i.e. reading and writing data from associated software development systems the API in the present system is only utilized at this step in the process to retrieve or read the data from a software development tool to be loaded into a temporary data deposit . Data retrieved is not written back to the originating software development tool until the user selects to save the data or changes to the data. Therefore the data transferred to the temporary cache or data repository is not directly written back to the originating software development tool . Thus the data transferred to the temporary cache or data repository is considered temporary and is not permanently saved to any database. Therefore the present system can be configured such that data cached in this temporary repository can be deleted or flushed out on a periodic basis. Alternatively the present system can be configured such that the data can be deleted from the temporary repository in response to a user command to do so. In yet another embodiment the present system can be configured such that the data is deleted from the temporary repository upon the exit of the user from the system or upon the exit of the user from particular dashboards within the system without the user selecting to save changes made to the data on the particular dashboard exited. Further in yet another embodiment the present system can be configured such that the data is deleted from the temporary repository upon user request to refresh the data. Importantly this transfer of data to a temporary cache or data repository allows the pulled data to be manipulated by the user without compromising the integrity of the data stored in the master databases of the individual software development tools . The system allows the user to manipulate the data from multiple software development tools without fear of overwriting the master set of data stored in the master databases of the individual software development tools but allows the user to save data back to the master set of data stored in the master databases of the individual software development tools when the user is satisfied with the changes made to the data. This set up embraces the agile software development interaction allowing numerous manipulations to the merged set of data from the various software development systems that can occur in interactive development process such as a Daily Standup view thereby allowing the agile process to be conducted without hindrance and efficiently by only saving the data back to the originated tools once completed.

After the data is retrieved from the master databases of the individual software development tools and cached in a temporary data repository the software development planning and management system can access and load the data into the system s data management module for manipulation by a user i.e. such that the user has access to data from each of the individual software development systems. Alternatively in another embodiment the user can have access to a smaller subset of the data from a plurality of the individual software development systems. For example a subset of data from the data retrieved can be loaded for the user s view depending on the dashboard or view that the user is utilizing to view the retrieved data. As another example a subset of data from the data retrieved can be loaded for the user s view depending on the user s qualifications as an owner participant or manager of the system as described in more detail below.

With access to data from each of or a plurality of the software development tools the third step involves the user mapping the data from one software development tool to another software development tool or alternatively to a plurality of other software development tools as illustrated in the embodiment of . For example the present system allows the user to map data from the RTC software development tool to independent data from the QC software development system . Specifically the RTC software development system may contain information regarding project tracking work items stories tasks releases iterations and SDLC signoffs whereas data from the QC software development tool may contain information regarding test plans test cases test executions defects and root causes. The user can map or link data from one system to another such as linking a test case to a particular release or to a specific iteration. As another more detailed example the user can link a defect which a user software tester input into the QC tracking system during a test case to iteration information input in RTC system by a user project manager relating to the iteration that was being tested and thereby link the defect to a whole other set of the information regarding the specific iteration such as the release or story information.

In one embodiment any user can create edit or remove links from one software development tool data to another software development tool data. Alternatively in another embodiment only designated administrators can create edit or remove links from one software development tool data to another software development tool data. An administrator can be described herein as an owner manager or other user of the system capable of creating editing or removing links or other important information not desirable for editing by the full plurality of users. Note this is different from the session owner or session manager described later herein. Further displays a further embodiment where the Data Management Module program defines linkages of data sets from one software system to another as previously designated by users and existing in the Domain Tables of the present system . further displays the system also receiving information from an administrative user via an Administrative dashboard tool . As described above an administrative user can create edit or remove links between the data from one software development tool to another software development tool which affects or updates the links defined in the Domain Tables . The links from the Domain Tables creates a set of merged data that can be viewed or manipulated by the user or users of the system. Again the merged data gives the user a more complete view of the software development process across various phases tools and people involved in the process.

This merged data can be viewed and manipulated in many useful ways to improve the software development process which is the last step in this system overview. provides two example views the Administrative Tools view and the Sticky Notes view or dashboard. Among other administrative tasks the Administrative Tool view can be used to create edit or remove links between one software development tool and another or a plurality of software development tools. The Sticky Notes view as described in greater detail below is an electronic embodiment of the agile process currently done with physical sticky notes or notes. The present system s merged data allows for easier agile software development across multiple locations multiple tools and multiple teams. Another advantage of merged data is the ability to query data from all or a plurality of systems and create reports from these queries. The ability to query data from all or a plurality of systems makes it unnecessary to open each individual tool to query for the same information or related information and decreases duplicative efforts and time for the same administrative tasks.

All the merged data and changes to the merged data during a session however are also cached in a temporary data repository . Again the purpose of the temporary data repository is to allow for user interaction and manipulation of the data while protecting the integrity of the original data in each of the software development systems such that teams and users can work with the merged data in interactive settings and views such as the Daily Standup View and only save the changes when the user or group is in agreement as to the changes. Again this set up embraces the agile software development interaction allowing numerous manipulations to the merged set of data from the various software development systems without writing back or overwriting the data in the individual software development systems and only making permanent changes to the data in the originating tools when the user group or team has agreed to such changes.

Once the user or team is in agreement to the changes to the merged data the links between the data or any other changes to the data the user can select to save their intersession changes . When a user selects to save their intersession changes these changes are persisted back to the originating software development system i.e. if the data pertains to the project tracking work items stories tasks releases iterations and SDLC signoffs or other data tracked in RTC then the data is persisted back or written to the master database for the RTC system . If however the data pertains to test plans test cases test executions defects and root causes or other data tracked in the QC then the data is persisted back or written back to the master database for the QC system . Likewise for any other software development systems that had data read from their master database the changes are written back to the software development system that originated the data. When a new session is created or a session is refreshed the present system then again reads the data from each of the software development systems now containing the new updated data recently saved back to the software development systems and creates a set of merged data with the most recent changes included.

In another embodiment data can be refreshed into the temporary data repositories on a regular basis to avoid complications related to multiple user sessions and manipulations. In another embodiment when a first session is established the user becomes a session owner or session master having the capability of initiating and orchestrating the session. In this embodiment subsequent users are logged into the same session in a read only mode. During this session the session master has the ability to give control to a subsequent user who can then edit the merged data for example by moving updating or integrating data via an interactive graphical user interface described in more detail below. These changes are then saved back to the software development systems that originated the data. In this embodiment one user is a session master at any given time. Further in another embodiment a subsequent user can request permission from the session master to have control during the session. Likewise a subsequent user can request permission from the session master to share control during the session. Further in another embodiment the session master has the ability to take back control of a session from a subsequent user previously given control i.e. override the subsequent user if necessary. Or in a further embodiment an owner manager or administrator may have the ability to take control of a session from a first or subsequent user given control i.e. override the control of a non owner user.

When the data is read from individual software development systems the data is cached in a temporary data repository or data repositories . The data repositories are only temporary and are cleared if the user exits the system exits certain dashboard views of the data or requests a refresh of the data. Once the data is cached in the temporary data repositories the system can determine if the user is an administrator and if the user is an administrator the user is provided the capability to view edit or remove links between the plurality of software development tools . Additionally the owner or manager may be given rights or access to other information involved with the system . Alternatively the user could log in directly as an administrator when establishing a session with the present system . If the user is a project manager owner or other administrator the Administrative Tool view is provided to the user for editing links between the mapped data . If the administrative user edits the links between the mapped data then the Data Management Module redefines the linkages between the data sets from one software development system to another software development system which are then used to create the Domain Tables . In one embodiment if the user is not a project manager owner or other administrator then the system does not provide the user with the capability to edit the linkages between the plurality of software development systems and instead the Data Management Module defines the linkages between the data sets from one software development system to another or one software development system to a plurality of software development systems . The Data Management Module defines the linkages by utilizing previously saved links in previously created and saved Domain Tables by the administrators.

In one embodiment when the Data Management Module has created the Domain Tables from the defined links between the data sets from the plurality of software development systems these links create a set of linked or merged data . This merged data set is the data viewed in the available dashboards within the present system and is available for editing and manipulation by the user . In one embodiment the user has several actions available from the available dashboards presenting the merged data . The user can query the merged data such that a query is run on the merged data set retrieving data and information from the plurality of software development systems through one action and creating a query report for the user . For example the user may query information regarding a particular project name task or status and the system can export an Excel or similar spreadsheet document as a raw work item with all the information regarding that particular project area task or status . In another embodiment the system may produce a pivotable Excel or similar spreadsheet file of the queried data from the merged data specifically designed for easy pivoting the data by the user .

In another embodiment the user action can be the manipulation or change of the merged data . For example a user can change the links between the data from one software development system to another. The user can change data regarding the projects releases stories tests or other software development tracking information. As another example the user can be in the Sticky Notes dashboard or Daily Standup dashboard and move stickies from one release to another one iteration to another or change the properties of a sticky note to reflect the work being done or the completion of the task that the sticky represents. Therefore there are many ways that a user may manipulate the merged data . In one embodiment these changes however are only temporarily cached in a data repository to allow for faster interaction and to protect the integrity of the underlying original data in the originating software development systems. In this manner the master data is owned and managed by the existing owner of the data i.e. the originating software development system. If the user does not select to save the changes made to the merged data then the changes are not persisted back to the originating software development system. Rather these changes remain in the temporary data repository until the user selects to save changes selects to refresh the data or exits the session . If the user selects to save changes made to the merged data set in the system the data changes are written back or persisted back to the original software development system i.e. data originating from the RTC system regarding project tracking work items stories tasks releases iterations and SDLC signoffs is persisted back to the RTC system whereas data originating from the QC system regarding test plans test cases test executions defects and root causes is persisted back to the QC system . The data persisted back to the original software development systems is now the most up to date information. Therefore in one embodiment after the data is saved i.e. persisted back to the originating tools the data is re read from the plurality of software development tools loaded into the temporary data repository and merged to be displayed and manipulated again by the in session user . In this manner the system ensures that the most current information or data is provided to the user from the plurality of software development systems. If the user selects to refresh the view however i.e. refresh the merged data changes made to the merged data during the session are not saved to the originating system . Rather a new set of data is read from the plurality of software development systems and a new set of merged data is provided to the user for viewing and manipulation . Likewise if the user selects to exit the session any changes made without selecting to save changes are not saved to the originating system and a new set of data is again read from the plurality of software development systems when the user creates a new session .

For the purposes of however shows a plurality of releases in RTC being mapped to another system s information QC regarding software testing defect management product and incidents. As shown RTC or other similar software development system may only track the plurality of releases and the associated stories and tasks that are used to build that release. Another software development system may be used however to track the quality testing of that same software to be released. Herein as an example that tool can be QC . Therefore the present system links the stories in the release to the test and testing information associated with that release.

In for example Release A has a plurality of stories each of which must be tested for completeness functionality and or stability within the software developed. Therefore a single story again comprised of multiple tasks may require several different tests to thoroughly test its capabilities and quality to find any defects. This is exemplified in where Release A has Story 1 linked to a plurality of tests i.e. linked to Test Case 1 through Test Case N which are tracked in the separate software development QC . Tests tracked in QC may have a similar hierarchy as shown in where Test Plan P in QC is divided into several smaller test cases which can simply be smaller tests for smaller sets of functionality or quality aspects of the software being tested. Story 2 likewise is linked to a plurality of tests i.e. linked to Test Case 1 and Test Case 2 for the Test Plan for Story 2.

Likewise a test case can then be related to defects found within the system during the testing phase i.e. during implementation of the test case. These defects may be tracked in a separate system for various reasons. For example a larger software development firm can have different personnel set up to specifically deal with defects found in the software or a company may want to track the defect information in a separate system for the simple reason that the other system has a better tracking system allowing the company to customize how it tracks and resolves its defects. In the present system these software development systems can be kept separate and the information associated can be linked allowing the benefit of both the use of the individual tool as well as use of information collected from all tools. As shown in the tester using Test Case 1 in the Test Plan for Story 1 has uncovered Defect 1 and Defect 2 through Defect N during testing. These defects input by the tester and or software developer are shown here to relate to Non Product Z. A link is therefore created within the system between Test Case 1 in the Test Plan for Story 1 and Defect 1 and Defect 2 related to Non Product Z as these defects where found during Test Case 1 of the testing of the software developed. Likewise shows Story 1 with a testing plan Test Plan for Story 1 wherein Test Case 2 of the testing uncovered Defect 1 and Defect 2 related to Product Q. Therefore Product Q and Non Product Z defects are being tracked in the QC system separate from the management of the software quality tests however the present system links these defects to the tests allowing an overall and more complete way to manage the development of the software.

Similarly it is advantageous to link other related information in other software development systems. For example further shows defects tracked in the QC defect tracking system linked to the incident reports tracked in the Service Manager Incident system . shows Defect 1 linked or mapped to Incident 1 however in another embodiment a defect can of course be linked to more than one incident. For various reasons incident reports may be tracked in a separate software development tool than the system tracking the defects. For example a manager may only be tracking the incident reports created from those working on or testing specific software. Such manager may not oversee or be particularly interested in the release planning stories or test cases that led to the incident being tracked and is instead more concerned with the resolution of the incident. However the same manager may be interested in the defects related with the incident tracked in QC or the product line that the incident is associated with and tracked in the CMDB Portal system . Thus again the present system provides the ability to link between the various systems such that the information in the various systems can be better managed and tracked for a more overall comprehensive view of the software developed rather than the manager or user being limited to viewing or using one software tracking system at a time or managing several systems at one time. Allowing information to be viewed and manipulated in one system and then persisted back to multiple tracking systems reduces overhead duplicate work inconsistencies and again provides those working on the system a more comprehensive view of the development of the software from all angles i.e. development testing quality product line and more. merely provides an example of the links that can be created across various software development or tracking systems . In another embodiment more links can be created between the systems. Similarly more systems can be linked together as well.

In either embodiment a user with access to mapping capabilities can create mapping from various views. In at the top of the GUI screen this GUI embodiment shows the ability to map information from a Delivery Team view a Project view and a Release view. Note these views are exemplary. For example the Delivery Team is an exemplary title and can be synonymous with a Project Team or Agile Team. In another embodiment more views may be available to map from tests in the QC or from incident reports in the Service Manager. As shown the view selected and displayed in is the Delivery Team view. Again towards the top of the GUI screen shows that the user has accessed this particular view by going into the Home page selecting the Delivery Team view and selecting which delivery team and project to map to various release information. A particular delivery team can be associated with several projects releases products quality metrics or other information related to the development of the software. Further these projects releases products quality metrics and other information can be tracked in various software development systems. Due to difference in personnel differences in tools or otherwise these various pieces of the development process can even be named differently in each system. Thus in the provided example the user can select the delivery team project or release and map information from other software development systems to this particular delivery team. Here the user has already selected the delivery team name and project name to map to and the user adds in the mapping information such as the release name release manager QA manager status and target release date manually into the system. In another embodiment the user may map information related to a project or to a release. As shown as an example in the user has selected to map to a Delivery Team entitled ORRA Quality and Non Prod Environments and Project Name PPMC ORRA KI. In another embodiments the user can specify more details regarding the project product tests or other development information that the user desires to link to the particular delivery team or to a particular release. When the user has specified what object they would like to link to then the user can proceed to link information from other software development systems. For example as shown in the user has chosen to link to the delivery team ORRA Quality and Non Prod Environments and project name PPMC ORRA KI . As shown in the user can map release information to this delivery team from the RTC Rational Team Concert the QC Quality Center the Service Manager to projects and even to change tickets . By selecting the project team and project the user is now able to select the releases associated to this project in RTC QC Service Manager and more . In another embodiment the GUI may provide the user the ability to map from the view of the release information or from project information . As shown in the RTC is populated with all the releases associated to the project selected. Likewise for QC the user can select from the list of all the releases in QC to link to this project. For Service Manager the user can link release tickets to specific RTC iterations releases selected and likewise link to corresponding releases in QC. In one embodiment these release tickets can be filtered for selection for mapping according to the group or project defined. These mappings however are only saved and utilized to create links via the Domain Tables when the user selects to save these mappings. Therefore the user can add edit or remove these mappings as the user sees fit and save the changes when completed . In a further embodiment the system can be configured to throw an error when a selected set of data is unable to map to the selected data of another software development system. In a further embodiment the system can be configured to report such an error to the manager of the associated software development system from which the error was thrown such that the manager can correct the error.

As shown in once the data has been read into cache as shown in and then that data has been linked or mapped as exemplified in a set of merged data from a plurality of software development systems now exists that can be utilized to create GUI views for the user to view query search and collectively manage information from all angles of the software development process and with all the information from each of the plurality of software development systems being used by various teams at different stages of the process cycle and or at even different geographic locations. This wealth of information is essential to highly effective oversight of the software development process. For example demonstrates that this merged data can be used to give very detailed information about a particular release here Release Alpha without having to look at various software development tools to determine associate stories tasks defects test cases test execution status agile teams managers defect status manager reviews and more. All this information can instead be pulled together into one intuitive GUI . For example in one embodiment this merged data can be used to provide metrics regarding the number of stories tasked and the number of stories completed . Likewise the merged data can be used to provide metrics regarding the status of defects or the status of test execution and pass rate . In other embodiments with large teams and multiple managers the merged data can be used to help overhead determine which managers have signed off and approved a release . This additional oversight can help keep managers accountable by tracking managers their projects and their approvals . In another embodiment any of these metrics charts or other information can be clickable to drill down into further information linked to this metric information. In other embodiments as shown here in merged data can be easily utilized and reviewed by creating tree structures of the data such that the user can delve into each node to reveal specific stories test cases or defects as shown for example and easily manage all the information about a specific release. In another embodiment these trees can be tailored to provide links to the specific mapping involved with the selected data. For instance GUI screens could allow viewing of all project mappings that are in progress by a particular project team or within a particular release so these mappings can be reviewed edited or manipulated in a similar GUI to . Likewise GUI screens could allow viewing of all release mappings associated with a agile or delivery team to again allow selection of a mapping for review editing or manipulation by the user or users. Similarly in another embodiment any of the mappings such as incident group mappings could be presented to the user for review editing or manipulation.

Of course in other embodiments this merged data can be used in a GUI that is tailored to show different metrics or different information based on the user or based on the needs of the software development team. Such metrics can help manage the process over time by providing information about the health of the project and determine key points of interest or areas for improvement. For example provides a different embodiment for viewing and managing the merged data from the plurality of software development systems. Here in for example wherein the user has already selected the group to review and defined the key performance indicators KPI desired the system provides the ability to further query the project data to review the metric data associated with that project. The consolidation of this information is then easy to view and utilize or even print out as needed. In this manner the manager or user can collect a sizeable amount of information regarding a group project or other task without parsing through several different software development tools.

In this embodiment the user submits a query on the merged data to pull data on a specific goal and get a scorecard or status associated with the key performance indicators for each goal. Once all the data is merged it can easily be queried to produce such results and provide an overview of the status of other process related information as well such as projects tasks or releases. demonstrates this ability by displaying the status information in the form of information regarding completion to target comments and status for example all in one view for ease of review and management. In another embodiment metrics are also shown in the form of percentage complete and overall status such as on target minor variance and significant variance. In yet another embodiment as shown in such variance can be displayed through ease of color indication i.e. green for on target yellow for minor variance and red for significant variance . In another aspect the query can also call up data related to comments saved by a user regarding a particular task . A user might query data regarding only a certain variance for quick status about goals or tasks that are lagging behind schedule. For example according to the exemplified GUI the user might filter tasks in the red to find tasks with significant variance or off target. Again the original information could be directly input into the various software development systems by the project team or project manager and then the user or another user can use the present system to query merged data to retrieve metrics and stats about information from each of the plurality of software development systems to provide a quick and comprehensive overview to the user and or a manager. Further in another embodiment these key metrics can be tailored to compare divisions groups projects or other data significant or particular to the management of the development process.

In another embodiment this merged data can also be useful by allowing the managers developers testers and other team members to interactively use and manipulate the merged data as items change issues arise or other releases projects stories tasks tests or other process development items are created edited or deleted. Such interactive manipulation of the merged data again allows the user to have a consolidated view and or detailed view as needed allowing users to add edit and remove merged data in real time without going into each individual software development system. After editing and saving such changes data is persisted back to the plurality of software development systems keeping each of the systems current without duplicating effort. Such interactive manipulation is further shown and exemplified in .

For example is an example interactive GUI of a roadmap view. The roadmap view is a long term planning view which outlines all the features being developed i.e. as shown here all the parents of stories. Therefore the roadmap view is more of an overhead view of the features and functionalities being developed. In one embodiment shown in the roadmap view visually displays the relative size of the features. For example if one feature requires more work than another it would be visibly shown as larger in size than the other compare to . As a specific example in the Electrical feature in Release 1 has 4 stories and is shown as a larger feature than the Phone lines feature in Release 2. In the example embodiment each feature is listed in a column according to the release it is linked to. For example Electrical is linked to Release 1 and is therefore shown in the column for Release 1. In the particular embodiment shown in each feature is in a column where each column represents a release specifically tracked in RTC. In another embodiment the column can represent the releases provided from a different software development system. In a further embodiment for each release a capacity number can be set above the column which sets the maximum number of features capable or potential capable for release to the client or manager in the representative release. In a further embodiment this capacity number can be further represented by a red line or other indicator along the column as an intuitive indicator for when the maximum capacity is reached for each release. In another embodiment when items are linked for example when projects are linked with other work items such as stories tasks or tests the GUI can be configured for further interaction and allow the user to delve into other aspects of the feature not shown similar to the tree structures described above. For example a user can double click the feature to see the stories in that feature such that the column expands and contracts to show the details in each feature. In a further embodiment the features can be color coded for status priority release group or other aspect that helps visually represent information to the user.

In another embodiment these features can be interactive and be dragged and dropped into another release as a way to interactively manipulate the data in the feature as well as the information linked to the feature. For example if the Electrical feature will not be started until Release 2 then the user can drag the Electrical feature directly into the column for Release 2 such that the feature information and all related information and links are updated automatically for inclusion in Release 2. These updates are saved or persisted back to the underlying software development systems when the user saves these changes. Similarly in another embodiment if the user opens up one of the features and manually edits information associated with the feature such as changes the stories linked to the feature this information is also updated in the underlying software development systems when the user saves these changes. Again this interaction saves the user time and prevents duplicating work and creating inconsistencies created when the user has to go into several different systems to ensure the information is updated correctly into each system as appropriate. This additional saves for example a high level manager from having to know which system or systems to even update the data to in situations where the data may only be applicable to one or a few systems. The ease of interaction and updating information across a plurality of software development systems results in improved oversight and management of the development process.

In another embodiment the features stories or tasks can be displayed in the form of a plurality of electronic sticky notes on an electronic sticky board such as in . In these interactive views similar to the interactive feature of the individual tasks are represented as a sticky note on the sticky board in a location representing the relationship between the task or information of the sticky note and the release or phase in the timeline of the project. The sticky note can be representative of a feature story task or other sub task as configured in the software development systems. Similar to their physical counterpart in the agile process these sticky notes can be moved around on the electronic sticky board to change their representative meaning. For example in if the user decides that the work for Cut Hole in Wall should be assigned to Release 3 the user can drag the Cut Hole in Wall story sticky note to the sticky board under Release 3 for the appropriate work item. In this interactive example the user instantly updates all the information for the sticky note and Release 3 without going into individual tools to update the information. Further this interactive view allows agile teams to easily adapt to this new system and interact within teams and locations easily and in a way that embraces the agile development culture. In one embodiment the work item hierarchy is listed along the left hand side of the columns creating a grid like structure which further defines the information in a sticky note when it is placed on the board. For example the Build task and the Buy receiver and cables task are related to the Sound System in the work hierarchy however the Build task is in the backlog and Buy receiver and cables is related to Release 2. In this example the sticky note for Cut Hole in Wall would be updated to link to information regarding the work item Cable Ethernet if the sticky note was placed in this row . The data for this sticky note or story is then updated to be linked to Release 3 and work item Cable Ethernet . If however the user decides the Cut Hole in Wall story sticky notes can be worked on in Release 1 the interactive view allows the user to move the story to a previous release by again dragging and dropping the sticky note in the column for Release 1. This approach easily corresponds to the Daily Standups typically conducted in person during the agile process but allows importantly users and or teams in geographically dispersed locations to interact in the typical agile manner without the impact of different locations teams or tools. In another embodiment the user can simply click on the sticky note to bring up the information linked to the sticky note and the user can manipulate the linked information in this manner as well.

In similar to the title bars at the top of the columns aggregate the feature or story data to indicate the amount of work being done in the release. Also similar to the sticky notes size can be configured to be proportional to the amount of work or time to completion associated with the story or task. Likewise the sticky notes can be configured to be color coordinated to link the story or task to a status priority level personnel team requirement test integration release or other information related to the development process. In one embodiment as shown in the sticky notes are color coded to show what priority the work has i.e. low medium high critical or an unassigned priority. In another embodiment by updating a sticky note s information by editing the location size color or other linked information by opening the sticky note and editing the associated textual information the information will be updated and persisted back to the originating software development system when the user selects to save the changes . In another embodiment the user can also double click the sticky note to edit the information associated with the sticky note.

In another embodiment the user can double click the release column to further delve into the iterations associated with that particular release. For example if the user double clicked Release 1 column the user would be navigated to the iteration planning view for Release 1. The iteration planning view shown in is another embodiment that features the sticky notes. Similar to the release planning view the iteration planning view allows the user to interactively manipulate the merged data from the software development systems via the use of sticky notes or by clicking on the sticky notes and manually entering the informational changes. This view however is delving down another layer into the development process. As shown in the sticky notes are shown on a story board or sticky board and can be filtered or displayed according to size priority and even by iterations. Similar to the release planning view the sticky notes size can be configured to be proportional to the work load and the color or location can be configured to conform to its priority level in the iteration. Likewise the sticky notes are interactive and can be dragged and dropped in different locations representing a different status within the selected iteration. For example when the developer begins working on the story represented by the sticky note Contact ISP the developer can enter the system select the iteration Zeta iteration and move the sticky note for Contact ISP from the Not Started column to the In Progress column . Again as a further example when the developer has completed the tasks within the story Contact ISP the developer can enter the system again and move the sticky note for Contact ISP from the In Progress column to the Completed Column . This action for example can take place while the developer is working and the developer can sign on the system to update his progress on his work. Alternatively as a further example the developer can sign on to the system during a Daily Standup session together with other users of the system and edit this data in the presence or view of the other users to show his progress.

In this interactive manner the developer updates his work and saves the information back to the necessary software development systems without the need to go into each software development system and individually update the information in each system and or in a manner consistent with the agile method. Of course the developer s updates can then be seen by other members of the development team or manager such that the other members know that those tasks for the Contact ISP story have been completed . The completed story and tasks will then also be available for other users and managers in the completion and metric information exemplified in or available for the other users to view during an interactive session. Again in this manner the entire team stays informed and updated with current information that is directly useful and important in managing the development process.

Again the sticky note interactive process is particularly helpful for the agile process where agile or project team members like to participate in Daily Standup sessions. In the physical Daily Standup session each team member goes in front of the other team members to explain the status of his work and if appropriate moves or updates the sticky notes on the board. With this interactive electronic version team members in remote locations can easily participate in the same activity by actively moving their sticky notes and or updating the information contained in each. Not only are team members updating their sticky notes in the fields on the screen in real time but when the session is completed and the changes are saved all the changes are persisted back to the originated software development systems without the extra work of the team members then manually updated the individual systems as would be done after a typical session. Also team members can continue to use the software development systems that they are accustomed to working with on a daily basis because these systems are not replaced by the present interactive system. Rather users can utilize their own development systems yet still participate in the interactive sessions with their peers without having to be in the same location without having to duplicate work and without having to transcribe work into various software development systems which can lead to errors and inconsistencies. Thus the present system allows and improves the collaborative methodologies of the agile process by providing quicker updates to all systems keeping current information keeping team members informed and keeping remote team members interactive while still preserving the processes already in place for software development teams via various third party software development tools.

The software development planning and management system can be modified to include additional components not shown in that can interface with the components of the software development planning and management system to perform release risk assessment. For example when development of a particular product or iteration of a product is complete by a team it can be released into a shared environment used by many teams. When the product iteration is released the release can be successful partially successful or fail. The success partial success or failure of the release can be dependent upon many factors of the release e.g. size other releases etc. in the shared environment. The factors can be characterized as risk factor. Risk factors are factors that contribute positively or negatively to whether a product is more likely or less likely to experience a release failure when the product is released into a shared environment. For example if one team schedules a release in the shared environment at the same time as another team a collision between assets being modifying can occur and the release may fail. Another factor that can affect the success or failure of the release is the number of assets affected by the release. If the release affects a large number of assets it is more likely that the release will be unsuccessful due to the number of assets that need to be changed. Additional risk factors are discussed in more detail below.

To assist in minimizing the risk of release failure each time a user desires to schedule a release of a product into the shared environment the likelihood of a successful release can be determined and presented to the user. The likelihood of a successful release can be determined by employing the retrieval writing step shown above in to allow retrieval of risk factors from the system the user inputs the data into. The mapping step shown above in can be expanded and or modified to include additional domain tables capable of mapping risk factors retrieved from various development systems in the retrieval writing step into a common normalized scheme.

Once in a normalized scheme weights can be assigned to the risk factors and the risk that a release will be unsuccessful can be determined. The integration and display views step can be modified such that the display views GUIs include various ways for the user to view assess the risk of unsuccessful release. The particular display views GUIs for risk assessment are discussed in further detail below.

It is apparent to one of ordinary skill in the art that components of the software development planning and management system that are unnecessary for the assessment of release risk can be deleted for embodiments where only release risk determination is desired. It is also apparent to one of ordinary skill that although the discussion above focuses on software development the methods presented herein for assessment of release risk can be applied to products other than software.

For example changes to a network or telephony infrastructure that prevents associates from accessing their applications and or prevent applications and or databases from communicating with one another changes to servers mainframes desktops etc such as patches reboots upgrades configuration at the same time that project teams are planning to deploy their releases storage upgrades that can prevent databases from accessing data for a certain timeframe changes to operational job sequencing that can affect order in which applications can process data operational process dependencies such as commencing an activity before a prior activity is complete where the new activity is dependent on results from the earlier activity.

The information regarding deliverables input by the user can include planned functionality of a product release planned release dates and times and or products impacted by the release. The information regarding stories to be completed and or requirements that to be met can include specific changes being made at a business function level applications databases and or infrastructure that are impacted by the changes size of the changes results of testing and or known bugs. The incidents and events information can include planned events e.g. data center freeze disaster recovery drills and or holidays and or historical incidents for assets. The change control information can include specific configuration item CI changes date time and or duration of changes signoffs obtained how likely or not there will be a failure for the change and or non functional requirements. The IT assets information can include CI details for applications databases and or infrastructures dependencies between CI s and or CI criticality. The staffing information can include resource information e.g. role location and or effort amount spent on the project and or budget of the project.

This information via user input is stored in the various development systems including but not limited to a software development system a quality control system a service management system a change control system and others which include enterprise project management tools generally used to track various data throughout product development process.

The second step is the retrieval of the information from master databases of the development systems . The information that is retrieved from the master databases can include risk factors. The risk factors are included in the information that is input by the user in first step . The risk factors include size of the change complexity of the change criticality of the product known release difficulties historical release difficulties number of other releases testing history e.g. number of tests performed pass fail rate test case coverage etc. known bugs found during testing that are still open at time of release quantity of work to be done by each deployment team during specific time windows capacity resource availability of each deployment team during specific time windows completeness of release notes and non functional requirements signoffs from all parties received in time and whether they are complete or with concerns importance of function or department that uses the system being deployed and whether or not they have a workaround if the release fails location where the deployment work will be done e.g. offshore or remote locations and or market events.

The risk factors can be grouped into sets based on the particular development system the risk factors were retrieved from. In various embodiments the risk factors are grouped into sets based on type of risk factor such as deliverable based factors e.g. size complexity calendar based e.g. time of day market event asset based e.g. affected assets resource based factors e.g. development team deployment team user group and or relevance or accuracy of risk factor in predicting previous failures e.g. highly correlated vs. suggestive .

The third step involves mapping the risk factors in each risk factor set to a common schema based on user defined domain tables .

The mapping can include normalizing the risk factors such that a common set of risk factor names and or a common set of risk factor values exist in each risk factor set. Table 1 shows an example of mapping the risk factor names into a common name and the assigned value associated therewith.

The mapping can include assigning weights to the normalized risk factors. Table 2 shows an example of assigning weights to the normalized risk factors.

In Table 2 Min Value assigns a risk value of zero the lowest possible value to a risk factor if it is below the minimum threshold. If all risk factors are below the min value threshold then the weighted risk index is zero Max Value assigns a risk value of ten the highest possible value to a risk factor if it is above the maximum threshold. If all risk factors are above the max value threshold then the weighted risk index would be 10. Min and Max values and the weightings for each risk factor can be input by a user. These can differ by division or company. The range for the weighted risk index can be adjusted by a user too any range that a user would like to use. In various embodiments the weighted risk index can be a scale from 0 to 1 0 to 100 and or other min max range. In some embodiments for a weighted risk index input by a user on a scale other than 0 to 10 the weighted risk index can be normalized to a 0 to 10 scale. In some embodiments the Min and Max values are consistent for all groups that share a common environment. For example if two divisions have two different environments they can have different values and weightings for each risk factor and can even use different risk factors if they want. For example if two divisions share the same environment then they can share the risk index and have common values and weightings.

Once the data is mapped a risk index can be determined for each set of risk factors during the integration and display view step . The risk index can be determined as follows Risk EQN. 1 where Risk R is the risk that release R of product P will fail i is the risk factor w i is the weighting for risk factor n is the number of risk factors and f i is the risk factor value.

In some embodiments a confidence factor is determined for each risk factor. The confidence factor is an indicator as to how reliable the risk index is. For example if the information used to determine the risk index was input by a manager at the beginning of the development process the number of changes the date for the change etc. are likely to change during development of the release. Thus the risk index is less accurate as the data used to determine the risk index is likely to change. If the information used to determine the risk index was input by a manager two weeks before the release is to occur and has been fully tested then the risk index likely has a higher level of accuracy. The confidence factor can be determined by weighting user input data. The user input data e.g. confidence variables that contribute to the confidence factor include time until release source system from which the release date came from completeness of data whether the release is notional completeness of story backlog how affected CIs are determined.

In some embodiments for time until release if it close to release time yields a higher confidence months before release yields lower confidence. In some embodiments a source system of project management system yields low confidence a source system of change control system yields high confidence.

In some embodiments completeness of data of all risk factors collected yields higher confidence completeness of data of missing risk factors yields lower confidence. In some embodiments for a notional deliverable confidence is lower for a committed deliverable confidence is higher.

In some embodiments completeness of story backlog of well groomed e.g. work has been analyzing and scoped list of stories yields higher confidence and completeness of story backlog of wishlist of features e.g. ungroomed yields lower.

In some embodiments if affected CIs are determined is based on change ticket with CI identified has high confidence. In some embodiments if affected CIs are based on stories requirements with outlining work has medium confidence. In some embodiments if affected CIs are based on historical CIs that a project has modified yields a low confidence.

The mapped data can be viewed and manipulated in many useful ways to assess the risk of release failure and is the last step in this system overview. It is noted that the data can be viewed and manipulated at the development system a user input the information into and or a display that communicates with a database having mapped data . provides two example views the release interdependencies view and the collision map view or dashboard.

During a collision a release is typically not successfully and either can require a back out of the change and or resulting in a change induced incident that causes business disruption. Causes of the change induced incidents can include missed dependency between releases missed requirements that impact app performance human error during deployment defect or data issue introduced failed batch due to conflict with change or other resources and or configuration issue.

Graph shows exemplary change related collisions over time. Change related incidents can be incidents caused by a change and or release being put into the environment such as failed deployment software defect data defect configuration issue etc.

Graph shows exemplary related incidents over time. Related incidents are any incidents that the user desires to track. For example a user can track legacy related incidents caused by legacy obsolete technologies defect related incidents caused by software defects data related incidents caused by database errors configuration related incidents caused by hardware or software configuration batch related incidents caused by failed or late batch cycles vendor related incidents caused by late vendor feeds or failed deployment of vendor products and or others.

Graph shows exemplary number of incidents that are discovered during use vs. incidents that are discovered during monitoring over time.

During a collision a release is typically not successfully and either can require a back out of the change and or resulting in a change induced incident that causes business disruption. Causes of the change induced incidents can include missed dependency between releases missed requirements that impact app performance human error during deployment defect or data issue introduced failed batch due to conflict with change or other resources and or configuration issue.

The above described techniques can be implemented in digital and or analog electronic circuitry or in computer hardware firmware software or in combinations of them. The implementation can be as a computer program product i.e. a computer program tangibly embodied in a machine readable storage device for execution by or to control the operation of a data processing apparatus e.g. a programmable processor a computer and or multiple computers. A computer program can be written in any form of computer or programming language including source code compiled code interpreted code and or machine code and the computer program can be deployed in any form including as a stand alone program or as a subroutine element or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one or more sites.

Method steps can be performed by one or more processors executing a computer program to perform functions of the invention by operating on input data and or generating output data. Method steps can also be performed by and an apparatus can be implemented as special purpose logic circuitry e.g. a FPGA field programmable gate array a FPAA field programmable analog array a CPLD complex programmable logic device a PSoC Programmable System on Chip ASIP application specific instruction set processor or an ASIC application specific integrated circuit or the like. Subroutines can refer to portions of the stored computer program and or the processor and or the special circuitry that implement one or more functions.

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital or analog computer. Generally a processor receives instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and or data. Memory devices such as a cache can be used to temporarily store data. Memory devices can also be used for long term data storage. Generally a computer also includes or is operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. A computer can also be operatively coupled to a communications network in order to receive instructions and or data from the network and or to transfer instructions and or data to the network. Computer readable storage mediums suitable for embodying computer program instructions and data include all forms of volatile and non volatile memory including by way of example semiconductor memory devices e.g. DRAM SRAM EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and optical disks e.g. CD DVD HD DVD and Blu ray disks. The processor and the memory can be supplemented by and or incorporated in special purpose logic circuitry.

To provide for interaction with a user the above described techniques can be implemented on a computer in communication with a display device e.g. a CRT cathode ray tube plasma or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse a trackball a touchpad or a motion sensor by which the user can provide input to the computer e.g. interact with a user interface element . Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech and or tactile input.

The above described techniques can be implemented in a distributed computing system that includes a back end component. The back end component can for example be a data server a middleware component and or an application server. The above described techniques can be implemented in a distributed computing system that includes a front end component. The front end component can for example be a client computer having a graphical user interface a Web browser through which a user can interact with an example implementation and or other graphical user interfaces for a transmitting device. The above described techniques can be implemented in a distributed computing system e.g. a cloud computing system that includes any combination of such back end middleware or front end components. The above described techniques can be implemented as a Software As A Service SaaS model or using a multi tiered approach.

Communication networks can include one or more packet based networks and or one or more circuit based networks in any configuration. Packet based networks can include for example an Ethernet based network e.g. traditional Ethernet as defined by the IEEE or Carrier Ethernet as defined by the Metro Ethernet Forum MEF an ATM based network a carrier Internet Protocol IP network LAN WAN or the like a private IP network an IP private branch exchange IPBX a wireless network e.g. a Radio Access Network RAN and or other packet based networks. Circuit based networks can include for example the Public Switched Telephone Network PSTN a legacy private branch exchange PBX a wireless network e.g. a RAN and or other circuit based networks. Carrier Ethernet can be used to provide point to point connectivity e.g. new circuits and TDM replacement point to multipoint e.g. IPTV and content delivery and or multipoint to multipoint e.g. Enterprise VPNs and Metro LANs . Carrier Ethernet advantageously provides for a lower cost per megabit and more granular bandwidth options.

Devices of the computing system can include for example a computer a computer with a browser device a telephone an IP phone a mobile device e.g. cellular phone personal digital assistant PDA device laptop computer electronic mail device and or other communication devices. The browser device includes for example a computer e.g. desktop computer laptop computer mobile device with a World Wide Web browser e.g. Microsoft Internet Explorer available from Microsoft Corporation Mozilla Firefox available from Mozilla Corporation .

One skilled in the art will realize the technology can be embodied in other specific forms without departing from the spirit or essential characteristics thereof. The foregoing embodiments are therefore to be considered in all respects illustrative rather than limiting of the technology described herein. All changes that come within the meaning and range of equivalency of the claims are therefore intended to be embraced therein.

