---

title: Activity tracing diagnostic systems and methods
abstract: Systems and methods are disclosed for logging encoded diagnostic information from a sequence of processing operations, the processing operations generated by an activity in a computing environment. Diagnostic information is tracked by activity, across process boundaries where the processes can be in computationally isolated, or “sandboxed”. Within each process, diagnostic information for an activity is stored in an activity-specific buffer registered with a kernel in the computing environment. For each activity in the computing system, the kernel keeps a list of all processes that have performed, or are performing, a processing task of the activity. The kernel also keeps a reference to the activity-specific log buffers for the activity for each process associated with the activity. If a processing operation for an activity fails, all activity-specific logs from all processes that are associated with the activity can be collected. A report can be generated from the collected logs for the activity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09396089&OS=09396089&RS=09396089
owner: Apple Inc.
number: 09396089
owner_city: Cupertino
owner_country: US
publication_date: 20140930
---
This disclosure relates to the field of diagnostics in computing environments and in particular in one embodiment to tracing a processing activity across process boundaries or other boundaries such as computing environments through the processes that implement the activity.

The present U.S. Patent application claims priority under 35 U.S.C. 119 e of the U.S. Patent Application No. 62 005 935 filed on May 30 2014 entitled ACTIVITY TRACING DIAGNOSTIC SYSTEMS AND METHODS which is incorporated herein by reference to the extent it is consistent with this disclosure.

The present U.S. Patent application is related to the following U.S. Patent applications each of which is incorporated herein by reference to the extent they are consistent with this disclosure 

A computing environment includes one or more running processes. The processes can all be running on a single computing system or the processes can be spread across multiple computing systems in a networked based or cloud based computing environment. Each process in the computing environment can write diagnostic information to a log file. The log file of each process is private to the process that writes to the log file. The log file of a process is not accessible by other user based processes in the computing environment.

Each process in a computing environment typically includes multiple libraries and multiple frameworks that each generate one or more threads of execution that each write diagnostic information to their log file for that process. In addition each thread in a first process can request a service from a second process on the same computing system or on another computing system in the computing environment. The second process can generate multiple threads that each write diagnostic information to the log file of the second process. Thus within the log file for each process a substantial number of different threads are writing diagnostic information for the process and that information may be related to other processes.

Diagnostic information can include a wide variety of information about the state of threads that are executing within a process. This information is typically written to the log file as a free form text string. Writing a text string message to a log is computationally expensive compared to the execution of the thread for which the log entry is written. In addition most threads complete successfully without a failure. Therefore substantial computing resources are consumed in generating and storing a large amount of diagnostic information that is not related to a system failure and is of little or no assistance to a technician in determining a cause of a failure.

In the event of a failure of a thread in a process a technician collects all of the logs from all of the processes within the computing environment to determine the root cause of the failure even logs of processes that are not involved in the activity of the thread that failed.

Embodiments are described for tracing a sequence of processing operations initiated by a process receiving a processing activity or activity such as a user input or a system call. The sequence of processing operations for the activity is traced from the process receiving the activity and continuing up to a point that the sequence of processing operations either completes successfully or fails. In one embodiment diagnostic information for each processing operation in a sequence of processing operations of an activity can be logged in a log buffer that is specific to the activity such that the diagnostic information in the log buffer relates only to processing operations of one activity. An activity may be performed more than once. Thus a log buffer can include diagnostic information for multiple instances of an activity each instance having an associated sequence of processing operations. A sequence of processing operations of an activity can span multiple processes within the computing environment. In addition multiple instances of a sequence of processing operations for an activity can span multiple processes within the computing environment. In one embodiment each process runs in a different memory address space such that a first process cannot access the diagnostic information in the log buffer of a second process the processes are computationally isolated or sandboxed. A first process may require one or more services from a second process to complete the processing operations for an activity. The first process can request that a second process be sent a communication including a voucher having attributes of the first process. The second process can redeem the voucher and adopt the attributes of the first process when performing processing operations on behalf of the first process.

Each process performing a processing operation for an activity can have a log buffer for logging diagnostic information of processing operations in the sequence. Diagnostic information within the log buffer s can be used to generate a report that traces the sequence of processing operations of the processing activity and can trace the sequence across the boundaries of computationally isolated or sandboxed processes. A kernel or other software having the authorization to access sandboxed memory of each process can collect the data in the log buffers from each process s memory space.

A processing activity can be for example a request to get mail in an email program a request to perform a spell check operation in a word processing program or a request to perform a sort table operation in a database program. The activity can be assigned an activity identifier activity ID that is unique in one of the computing environment or a process in one embodiment. Each process that performs a processing operation for the processing activity can allocate and register an activity specific log buffer for logging diagnostic information related to the sequence of processing operations performed to complete the activity.

Using an email program as an example process and a request to get mail as an example of an activity in a process of the email program a sequence of processing operations may include a operation to fetch new mail from an email server an operation to sort the retrieved email an operation to index words within the retrieved emails for later searching and an operation to display the retrieved and indexed emails on a display screen. Diagnostic information for the fetch mail sort mail index mail and display mail operations can be logged in a log buffer that is specific to the get mail activity within the email process. In one embodiment diagnostic information from other activities and processing operations of the email process that are not related to the get mail activity such as compose mail send mail spell check and reply can be logged in different log buffers than the log buffer s for the get mail activity. In another embodiment logging of instances of the email process receiving one or more requests for a get mail operation a compose mail operation a send mail operation a spell check operation and an email reply operation can be stored in an activity buffer log buffer for the process.

An activity may require additional processing services outside of its own process. Using the get mail activity of the email process as an example again the fetch mail processing operation may require accessing a remote email server via the Internet. To access the email server the fetch mail processing operation can call an Internet services process that provides Internet services to the fetch mail processing operation on behalf of the email process. The email process can request a voucher with attributes of the email process the get mail activity and the fetch mail processing operation and can send the voucher to the Internet process via inter process communication. Upon receiving the voucher the Internet process can request registration of an activity specific log buffer for the get mail activity within the Internet process memory address space. Diagnostic information of Internet services processing operation s can be logged in the get mail activity log buffer of the Internet process. If a get mail activity processing operation fails within e.g. the Internet process then diagnostic information in all of the get mail activity log buffers can be collected and a report can be generated of diagnostic information that is all related to the get mail activity sequence of processing operations. In this example the get mail activity log buffer from the email process and the get mail activity log buffer from the Internet process can be collected and used to generate the report.

In another embodiment a process can log the receipt of one or more instances of one or more processing activities. For each activity received the process can determine whether the activity has an existing activity ID known to the process. In response to determining that the processing activity does not have an existing activity ID for the process the process can request and receive an activity ID that is unique within one of the computing environment or the process. In one embodiment an initial instance value is determined for the activity ID. The instance value can be used to distinguish a first instance of the processing activity received by the process from a subsequently received instance of the activity. In an embodiment if a subsequent instance of the activity is received by the process the instance value can be increased. Logging an occurrence of the activity ID can include storing a timestamp of the processing activity and the activity ID and in some embodiments an instance value of the activity ID. In one embodiment the process can further determine that the activity log buffer is within a threshold value of being full. If so an oldest activity log buffer entry can be overwritten with a new activity log buffer entry.

In yet another embodiment a computing environment can determine that a processing operation in a process has failed. The processing operation has an associated activity ID and in some embodiments an instance value of the activity ID. The computing environment can extract one or more log buffer entries from a log buffer that is associated with the activity ID within the process. A log buffer entry can include a timestamp a processing operation identifier an instance value of the activity and one or more parameters. Log buffer entries can be extracted based upon one or more of the timestamp processing operation identifier or instance value and further by one or more parameters. In one embodiment the log buffer entries can be extracted based on the processing operation having the activity ID of the failed processing operation. In addition or alternatively log entries of an activity log buffer of all activities received by the process can be extracted from the process in which the processing operation failed. In an embodiment the log buffers can be decoded into human readable text in one of the kernel or a diagnostic service. Activity log buffer entries can include a timestamp and an activity ID of an activity received by the process. In one embodiment activity log buffer entries further include an instance value of the activity ID of an extracted activity log buffer entry.

In still another embodiment a diagnostics service can receive one or more log buffers from a computing environment each log buffer corresponding to a different process. Each log buffer can contain log buffer entries associated with an activity ID that is also associated with a failed processing operation. In one embodiment each log buffer entry can include a process identifier that identifies one of the different processes a processing operation identifier a timestamp an activity ID an instance value associated with the activity ID and one or more parameters. The processing operation identifier can correspond to a text string that describes the processing operation logged. Log entries received from the one or more log buffers can be collated into an order. Log entries can be collated by timestamp by process identifier by processing operation identifier or activity ID or activity ID and instance value. In one embodiment for each of the collated log entries the entry can be translated into human readable text using the processing operation identifier to retrieve a message text and formatting string that can be used to format the one or more parameters into the message text to generate the human readable text. In one embodiment the processing operation identifier can be a hash value used to look up the message text and formatting string. The collated translated log entries can be transmitted to a crash reporting system. In some embodiments the log entries can be filtered according to filtering criteria such as a timestamp range a process identifier or an instance value of the activity ID. In one embodiment the one or more log buffers are received in response to a failure of a processing operation having the activity ID.

Some embodiments include one or more application programming interfaces APIs in an environment with calling program code interacting with other program code being called through the one or more interfaces. Various function calls messages or other types of invocations which further may include various kinds of parameters can be transferred via the APIs between the calling program and the code being called. In addition an API may provide the calling program code the ability to use data types or classes defined in the API and implemented in the called program code.

At least certain embodiments include an environment with a calling software component interacting with a called software component through an API. A method for operating through an API in this environment includes transferring one or more function calls messages other types of invocations or parameters via the API.

Other features and advantages will be apparent from the accompanying drawings and from the detailed description.

In the following detailed description of embodiments reference is made to the accompanying drawings in which like references indicate similar elements and in which is shown by way of illustration manners in which specific embodiments may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention and it is to be understood that other embodiments may be utilized and that logical mechanical electrical functional and other changes may be made without departing from the scope of the present disclosure. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

Embodiments are described for tracing processing operations generated by an activity across process and computing environment boundaries.

Examples of diagnostic information can include logging the receipt of a request for a service of a process logging the starting of execution of a process to fulfill the request logging a request by a thread for a service from another process logging a reply received by the thread from the another process logging the successful completion of the thread and logging the failure of execution of the thread. Diagnostic information in the prior art is typically a text message string that describes a computing action performed by a specific processing operation. The message string may conform to a standardized format. For example syslog Internet Engineering Task Force RFC 5424 is a computer diagnostic information message format in which messages are labeled with a facility code a severity level and additional information of the process that generated the message. Syslog messages vary in length and may be as long as 1024 bytes per message. Other diagnostic information formats include Common Log Format Extended Logfile Format and Pantheios in addition to proprietary formats.

The above diagnostic information logging formats and many proprietary logging formats include features similar to syslog. A disadvantage of these prior art logging methods is that formatting and storing lengthy text messages requires substantial computing resources. The processing overhead burden of logging text diagnostic information can be high enough to cause a system to miss logging of one or more significant processing events. Further in the prior art diagnostic logging may be disabled by default until explicitly enabled to reduce the performance burden of diagnostic logging on end user performance. When diagnostic logging is disabled to diagnose a problem an end user must first detect that a problem occurred then enable diagnostic logging and hope that the problem recurs and that the cause is captured by the diagnostic logging and is not missed due to the high processing overhead of the prior art logging. Another disadvantage of the prior art diagnostic logging is that most processing operations in a computing environment complete successfully. Thus the log files and contain substantial amounts of text that is related to processing operations that have successfully completed making it difficult for a technician to sift through the text of the successfully completed processing operations to find the diagnostic information of the few processing operations involved in a failure. In addition in the prior art each process logs diagnostic information for all processing activities performed by the process not just a specific processing activity associated with a failure. Further each log file and contains only diagnostic information of the process that generated the log file making it difficult to identify inter process relationships between processing operations in the separate log files.

In the prior art when a processing operation fails kernel reads and the respective log files and of all processes and in the computing environment regardless of whether the process performed a processing task related to the activity that resulted in a failed processing operation. The kernel passes all of the log files and to crash reporter via inter process communication . A technician extracts the text from log files and from the crash reporter and processes the text by aligning in time the log entries to match them in time in order to trace operations across process boundaries to determine a cause of the failure of the failed processing operation.

When a process e.g. process is initialized the process requests an allocation of memory from kernel for log buffers e.g. log buffers via interface . The kernel can return a reference to process via interface and the kernel can maintain a reference to the memory allocated for log buffer . Log buffer can include buffer for storing one or more instances of one or more activities received by the process and a log buffer for storing diagnostic information regarding a particular activity of the process. An embodiment of a log buffers memory structure such as log buffers is described in detail below with reference to . Similarly processes and can also request and receive an allocation of memory from kernel for log buffers and respectively via interfaces and respectively. In one embodiment interfaces and can be inter process communication sockets shared memory a system call or an Application Programming Interface API . Application Program Interfaces are described in detail below with reference to . Interfaces and need not be implemented using the same method. For example interface can be by shared memory whereas interfaces and are implemented via an API.

The following features will be described with reference to process . The features also apply to process and process . When a process e.g. process receives a request to perform a processing activity or activity process can request via interface that the kernel generate a unique identifier for the activity activity ID and return the activity ID to the process . The activity can originate from a user input or other user activity or from a system event. In one embodiment the activity ID is unique with respect to process . Alternatively the activity ID can be unique with respect to computing environment . Kernel can then generate an activity ID and store an activity description record for the activity. The activity description record maintains a linked list of processes that perform processing operations for the processing activity having the activity ID of the activity description record . The activity description record can include the activity ID and a text description of the activity such as request to get mail request to calculate spreadsheet request to sort database request to spell check document or other processing activity. The kernel can collect and store other relevant information in the activity description record such as a timestamp of the request for the activity ID a system identifier of a computing system making the request or a network interface address from which the request was received. Kernel can return the activity ID to the requesting process via interface . Process can determine an available log buffer within log buffers in which diagnostic information will be stored for the processing activity having the activity ID. Process can then request that kernel register process and a reference to log buffer with activity description of activity ID via interface . Kernel can then generate a process reference record for process and link the process reference record for process to the activity description record .

In an embodiment a processing operation for the activity that is running in process can call process to perform a service on behalf of process . In response to receiving a call from process for the activity process can send a voucher containing attributes of process and the processing activity to process . Vouchers are described in detail below with reference to . The voucher can be sent using inter process communication sockets shared memory system calls or API via the kernel using reference to interfaces and . On receipt of the voucher process redeems the voucher with voucher management module and obtains the activity ID from the voucher. If the activity ID is unknown to process then process can determine an available log buffer within log buffers in which diagnostic information will be stored for the processing activity having the activity ID. Process can then request that kernel register process and a reference to log buffer with activity description of activity ID via interface . Kernel can then generate a process reference record for Process and link the process reference record for process to the activity description record . In an embodiment process reference record for process is linked to activity description record at process reference record for process thereby indicating an implied ordering in which the respective processes were associated with the processing activity. Similarly process can request that process perform a service on behalf of process for the activity having the activity ID. Analogous operations are performed for process if either process or process calls process to perform a processing operation for the processing activity having the activity ID.

Assuming that processes and each perform a processing operation for the activity having the activity ID the resulting data structure in the kernel can include the activity description record for the activity and a linked list of all of the processes that perform one or more processing operations for the activity. Each process and has an identified log buffer for the activity within its respective log buffers and . Each log buffer can store diagnostic information of the processing operations for the activity generated by their respective processes and . In addition each process and can optionally have an activity log buffer that stores one or more instances of one or more activities received by the process. Collectively the activity log buffer and log buffer for an activity may be referred to as log buffers 3x0. The log buffers 3x0 can all be read by the kernel via the activity description record for the activity and the associated linked list of process reference records and that each contain a reference to their respective log buffer for the activity. In an embodiment the reference can include a reference to entire log buffer structure and and further include a descriptor value such as a memory offset a buffer number or other identifier that points within the log buffer structure and to identify a specific log buffer for the activity. In one embodiment the descriptor value need not be the same for all buffer structures and for a specific activity.

In the event that a processing operation of an activity fails the kernel can notify the crash reporter of the failure via interface . The crash reporter can request via communication interface that diagnostic service collect and process log buffers from the processes and that performed a processing operation for the activity. The diagnostic service can request via interface that the kernel collect all log files associated with the activity and and optionally activity log buffer . The log file collector can use activity description record to access the linked list of process reference records and that each reference a log file of a process that performed one or more processing operations for the activity. Log file collector can use the references to the log buffers 3x0 to read the log buffers 3x0 from each of the log buffers memory and for processes and respectively. The log file collector can then pass the collected log files 3x0 to the diagnostic service for processing. In addition to the log files 3x0 in one embodiment the log file collector can also pass information from the activity description record and or the process reference records e.g. and to the diagnostic service. The diagnostic service can translate the activity description record and or the process reference records and to human readable text. The diagnostic service can translate the log files into human readable text as described in detail below with reference to . The diagnostic service can perform additional processing on the log files before or after translating the log files into text as described in detail with reference to below. The diagnostic service can then transmit the processed and translated log files to the crash reporter via communication interface . Interfaces and and communication interface can be implemented using inter process communication shared memory sockets a system call or an Application Programming Interface API .

Activity log buffer can store an instance of each activity received by the process in which the activity log buffer is allocated. The activity log buffer for a process gives a technician a high level view of the processing activities requested of a process and the order in which the activity requests were received. The activity buffer is in effect a genealogy of the state of a process or breadcrumbs on a path leading up to a processing failure. In one embodiment each log entry in an activity buffer can include an activity identifier activity ID of an activity received by the process and the timestamp that the activity was received by the process. The activity ID can be used to reference descriptive information about an activity that is stored in the activity description record of a process. In one embodiment the activity ID can be used to retrieve a text string that describes the activity. The text string can be stored in a binary of the process in a library or other string pool accessible to the kernel . The activity buffer log entry can include a processor program counter PC in addition to the timestamp. The activity buffer log entry can further include an instance value of the activity indicating a specific instance of the activity being received by the process. Each activity received by a process has an associated log buffer in which diagnostic information is logged related to processing tasks for only one activity. Each log buffer entry can include a timestamp associated with the diagnostic information logged an instance value of the activity for which diagnostic information is being logged in this activity log buffer a message identifier message ID indicating a specific piece of diagnostic information about a processing operation and optional parameter values 1 and 2. The message ID and parameters and are described in detail with reference to below. Although parameters and are shown more parameters may be used. The data type of the parameters can differ from one another.

In one embodiment a portion of a log buffer can be carved out for each instance of a processing activity that logs diagnostic information to the log buffer . In such an embodiment storing the instance value can be optional.

In one embodiment the log buffers 3x0 are ring buffers. Alternatively logs 3x0 can be first in first out FIFO last in first out LIFO or other buffer data structure type. The logs 3x0 need not be the same buffer data structure type. In one embodiment each log 3x0 entry is of a fixed length. The length of activity log buffer entries can differ from the length of log buffer entries . The length of log entries of different activity log buffers within a log buffer memory of a process can differ. Although activity buffer and log buffers are both shown as having N entries 0 . . . N 1 this need not be the case. Different logs 3x0 can have different numbers of log entries. In an embodiment each log 3x0 entry has a fixed data length that is a multiple of a data type length the data type being known to the computing system on which the process is running. For example each log 3x0 entry in process can be a multiple of 32 bits while each log 3x0 entry in process can be a multiple of 64 bits. In an embodiment the number of entries e.g. N of a log buffer 3x0 is a power of two thereby enabling buffer management logic to use fast binary masking or modulo arithmetic for buffer management. Utilizing the above log buffer features diagnostic information logging is extremely fast and utilizes very little overhead processing. In one embodiment diagnostic information logging is always enabled always ON .

Buffer management data area includes memory for log buffer management variables pointers activity to buffer correspondence information and data references to manage the implementation of each log buffer 3x0.

In an example process receives a new processing activity registers the activity with the kernel thereby creating activity description record then process calls process to perform a processing operation for the activity on behalf of process . Additionally assume that process calls process to perform a processing operation for the activity on behalf of process and that the processing operation in process fails. Then the kernel can inform the crash reporter using interface that the processing operation in process for the activity has failed. The crash reporter using interface can request that the diagnostic service collect all relevant log buffers and produce a report to be passed to the crash reporter using interface . Process description records and in the linked list of processes that performed processing operations for the activity can each have a reference to their respective log buffer memories and and a reference to the relevant activity log buffer and log buffer for the activity collectively log buffers 3x0 contained therein. Log file collector in kernel can utilize these references to collect the log buffers 3x0 from each process and and pass the collected files to diagnostic service via interface .

In one embodiment diagnostic service can process the collected logs files prior to or as an operation of preparing the report . Processing the log files can include certain diagnostic information in one or more of the log buffers 3x0 such as excluding diagnostic information before a specified timestamp or program counter value or excluding high level activity information in activity logs buffers for one or more processes. Diagnostic service can then translate the diagnostic information contained with the processed log files to human readable text as described with reference to below.

In one embodiment interfaces and can be inter process communication sockets shared memory a system call or an Application Programming Interface API . Application Program Interfaces are described in detail below with reference to . Interfaces and need not be implemented using the same operation for all interfaces. For example interfaces and can be by shared memory e.g. whereas interfaces and can be implemented via an API e.g.

Optionally at operation the first process can also determine an activity log buffer within the log buffer memory for logging one or more instances of one or more activities received by the process. The activity log buffer can also be registered by the kernel and associated with the first process. After initialization the first process can begin receiving requests to perform processing activities.

In operation the first process receives a request to perform a processing activity. The first process can determine whether the activity is new to the first process or whether the activity has been previously received by the first process.

If the activity is new to the first process at operation the first process can request a new activity identifier activity ID for the activity from the kernel . The activity ID can be unique within the first process. In one embodiment the activity ID is unique within the computing environment .

In operation the first process can determine an available log buffer from within the log buffer memory for the process. The log buffer is for logging diagnostic information for the received activity ID.

In operation the first process can register the activity ID log buffer and a log buffer descriptor so that the kernel can access the specific log buffer for the activity within the one or more activity log buffers in log buffer memory . Registration can include generating an activity description record generating a process reference record e.g. and linking the process reference record to the activity description record . In one embodiment the registration process occurs within kernel . Alternatively registration can be implemented using a registration service accessible by the kernel .

An initial instance value of the activity ID can be set in operation . In one embodiment the initial instance value of the activity ID can be one.

If in operations the activity received by the first process is not a new activity for the process i.e. an instance of the activity was previously received by the first process then the first process can increase the instance value of the activity in operation . In one embodiment the activity instance value is increased by being incremented.

In operation the first process can optionally log the activity ID and instance value of the activity received by the process in activity log buffer . In one embodiment activity log buffer is a circular or ring buffer. Thus the activity log buffer can continuously log activity IDs and instance values as they are received. In one embodiment the activity log buffer overwrites the oldest activity ID and instance value in the activity log buffer as new activities and or instances of activities are received by the process.

In operation the first process can determine whether the log buffer for the activity is within a threshold value of being full. In one embodiment the threshold is within 10 of the number of buffer entries available for the buffer . If so in one embodiment the first process can determine a highest instance value for the activity that has successfully completed all processing operations for the activity within the process.

In operation the first process can then free buffer space in the log buffer for the activity at and below the highest instance for the activity that has successfully completed all processing operations for the activity within the first process. In another embodiment in operation the first process can call the kernel to determine for all processes that are or have been performing processing operations for the activity the highest instance value of the activity for which all processing operations for all processes performing a processing operation for the activity have successfully completed. In one embodiment the kernel can make the determination by maintaining a variable representing the highest instance value of the activity that has completed all processing operations for each process. The variable can be maintained by the kernel within the process reference record or for the process within the kernel. In another embodiment the kernel can inspect the activity log buffer of each process to make the determination. In yet another embodiment the first process can maintain a variable for tracking the highest instance value of an activity that has completed all processing operations for the first process. The first process can maintain this variable in the buffer management area .

In operation the first process can log diagnostic information for the activity ID and instance value in log buffer for the activity. Diagnostic information is described in detail with reference to .

In operation the first process can determine whether the services of a second process process B are needed to complete the processing activity. If the first process determines that processing of the activity does not require a service from a second process then the method resumes at operation .

In operation if the first process determines that the services of a second process process B are needed to complete the activity then the method continues at operation .

In operation the first process can request that voucher management module send a voucher reference e.g. to the second process as described in detail below with reference to . The first process can then request that the second process process B perform one or more processing operation behalf of the first process as shown in . The method continues at connector which is described with reference to .

In operation the second process process B is initialized. During initialization the second process can request an allocation of log buffer memory from the kernel e.g. log buffer memory of . The second process can request that the log buffer memory be registered with the kernel such that the kernel can read diagnostic information from the log buffer memory even after a processing operation of the first process has failed.

Optionally in operation the second process can also determine an activity log buffer within the log buffer memory for logging one or more instances of one or more activities received by the second process. The activity log buffer can also be registered by the kernel and associated with the second process. After initialization the second process can begin receiving requests to perform processing activities. In one embodiment the second process can receive a request from a first process at connector to perform a processing operation for an activity on behalf of the first process.

In operation the second process receives and redeems a voucher with attributes of the calling first process. In an embodiment the attributes include the activity ID and instance value of a processing activity. Upon redemption of the voucher the second process can adopt the attributes of the first process that are contained within the voucher for use in performing a processing operation on behalf of the first process.

In operation the second process can determine whether the activity corresponding to the activity ID is new to the second process or whether the activity has been previously received by the second process. The second process can also receive new processing activities requested directly of the second process at operation rather than via a call from a first process at entry point . Upon receiving a new activity requested of the second process directly the second process can request and receive an activity ID from the kernel as described in operation of above. For clarity the operation is not shown in .

If it is determined at operation that the activity is new to the second process then at operation the second process determines an available log buffer from within the log buffer memory for the second process. The log buffer is for logging diagnostic information for the activity ID received in the voucher or for a newly received activity.

In operation the second process can register the activity ID log buffer and a log buffer descriptor value or identifier so that the kernel can identify the specific log buffer for the activity from the one or more log buffers in log buffer memory . If the activity is new to the second process as determined in operation then registration can include in one embodiment the kernel generating an activity description record for the activity and can further include generating a process reference record e.g. and linking the process reference record to the activity description record. If the method is called at entry point then registration can include generating a process reference record e.g. and linking the process reference record to the activity description record . In one embodiment the registration process occurs within kernel . Alternatively registration can be implemented using a registration service accessible by the kernel .

If the activity was received directly by the second process then an initial instance value of the activity ID can be set in operation . In one embodiment the initial instance value of the activity ID can be one. If the method was called from a first process at entry point then the instance value for the activity can be set to the instance value for the activity that was received in the voucher at operation .

If in operation the activity received by the second process is not a new activity for the second process i.e. an instance of the activity was previously received by the second process then the second process can increase the instance value of the activity in operation . In one embodiment the activity instance value is incremented.

In operation the second process can optionally log the activity ID and instance value of the activity received by the second process in activity log buffer . In one embodiment activity log buffer is a circular or ring buffer. Thus the activity log buffer can continuously log activity IDs and instance values as they are received overwriting the oldest activity ID and instance value in the activity log buffer as needed.

In operation the second process determines whether the log buffer for the activity is within a threshold value of being full. In one embodiment the second process determines whether the log buffer is within 10 of the total number of entries for the log buffer . If so then in operation log buffer space for the activity in log buffer can be freed. In one embodiment the second process can determine a highest instance value for the activity that has successfully completed all processing operations for the activity within the process. The second process can then free buffer space in the log buffer for the activity at and below the highest instance for the activity that has successfully completed all processing operations for the activity within the second process. In another embodiment the second process can call the kernel to determine for all processes that are or have been performing processing operations for the activity the highest instance value of the activity for which all processing operations for the activity instance have successfully completed. In one embodiment the kernel can make the determination by maintaining a variable representing the highest instance value of the activity that has completed all processing operations for each process. The variable can be maintained by the kernel within the process reference record or for the process within the kernel . In another embodiment the kernel can inspect the activity log buffer of each process to make the determination. In yet another embodiment the second process can maintain a variable for tracking the highest instance value of an activity that has completed all processing operations for the second process. The second process can maintain this variable in the buffer management area .

In operation the second process can log diagnostic information for the activity ID and instance value in a log buffer for the activity. Diagnostic information is described in detail with reference to .

In operation the second process can determine whether the services of a third process process C are needed to complete the processing activity. If the second process determines that processing of the activity does not require a service from a second process then the method resumes at operation . The second process can receive new instances of activities at and or .

In operation if the second process determines that the services of a third process process C are needed to complete the activity then the method continues at operation . In operation the second process can request that voucher management module send a voucher reference e.g. to the third process as described in detail below with reference to . The second process can then request that the third process process C perform one or more processing operations on behalf of the second process at connector . Connector represents entry into a method substantially identical to that shown in at entry point with references within modified to indicate calling the third process process C by the second process process B.

In operation the process is initialized. During initialization the process can request an allocation of log buffer memory from the kernel e.g. log buffer memory of . The process can request that the log buffer memory be registered with the kernel such that the kernel can read diagnostic information from the log buffer memory even after a processing operation of the first process has failed.

In operation the process can determine an activity log buffer within the log buffer memory for logging one or more instances of one or more activities received by the process. The activity log buffer can also be registered by the kernel and associated with the process. After initialization the process can begin receiving requests to perform processing activities.

In operation the process receives a request to perform a processing activity. The process can determine whether the activity is new to the process or whether the activity has been previously received by the process. In one embodiment the determination can be made by the process inspecting the buffer data management area of the log buffer memory to determine whether the activity has a corresponding activity ID in the buffer data management area . In another embodiment the determination can be made by the process calling the kernel to determine whether the activity has a corresponding activity description record and whether the process has a corresponding process reference record e.g. linked to the activity description record . The call can be made by an API shared memory via a socket or inter process communication.

If in operation it is determined that the activity is new to the process the process can request a new activity identifier activity ID for the activity from the kernel . The activity ID can be unique within the process. In one embodiment the activity ID is unique within the computing environment . The request can be made via an API shared memory a socket or inter process communication.

In operation the process can register the activity with the kernel . In one embodiment registration can include the kernel generating an activity description record for the activity generating a process reference record e.g. for the process and linking the process reference record e.g. to the activity description record as described above with reference to . The process reference record e.g. can contain a reference to the activity log buffer the process the log buffer memory and the log buffer data management area such that the kernel can read the activity log buffer even after a failure of a processing task within the process. Alternatively registration can be implemented using a registration service accessible by the kernel .

An initial instance value of the activity ID can be set in operation . In one embodiment the initial instance value of the activity ID can be one.

If in operations the activity received by the process is not a new activity for the process i.e. an instance of the activity was previously received by the process then the process can increase the instance value of the activity in operation . In one embodiment the activity instance value is incremented.

In operation instances of activities received by the process can be logged in the activity log buffer . Logging can include storing a timestamp that the instance of the activity was received the activity ID of the activity and optionally the instance value of the activity received by the process. In one embodiment additional information can be logged with an instance of an activity including an internet address or socket number from which the request to perform the activity originated a system identifier of the computing system from which the request originated software and operating system identification etc.

A process e.g. process can have attributes that are to be shared with or transferred to a second process e.g. process . Process attributes can include a priority of a process security privileges an activity ID of a processing operation power management attributes activity scheduling attributes and other attributes of a process. A process e.g. process using interface can request that one or more process attributes be registered as a voucher by the voucher management module . The voucher management module can generate and store the voucher and return a voucher reference e.g. voucher reference via interface to the requesting process . If process e.g. requires the services of another process e.g. process then process can request that voucher management module prepare a voucher reference based upon the voucher referenced by voucher reference and send voucher reference to process . Alternatively in one embodiment process can pass voucher reference to process via inter process communication to become process s voucher reference . In one embodiment process passes voucher reference to process in the same call to process in which process requests that process perform a task on behalf of process . Voucher management module can prepare and register the voucher reference and send the voucher reference to process via interface . Process can then redeem the voucher reference with voucher management module such that process can adopt the attributes of process in accordance with the voucher referenced by voucher reference . Process can then call process to perform a processing task on behalf of process .

In one embodiment vouchers can be created destroyed reference counted copied validated or invalidated or maintained via voucher management module . Data structures corresponding to vouchers may be stored within voucher management module . In an embodiment voucher management module can destroy a voucher when the voucher is no longer referenced e.g. the voucher reference count is zero . Voucher references and can be references corresponding to actual vouchers stored in voucher management module . In an embodiment the voucher references and can further include a data structure having the voucher attributes stored by the voucher management module .

Voucher attributes and associated attribute values can be managed via an attribute manager residing in the kernel and or attribute manager s residing in user memory. Attribute manager s can be registered in voucher management module to provide different functions via corresponding attributes values or tags or keys in vouchers. These functions may include activity tracing importance donation power assertion management activity scheduling and other application functions.

In an embodiment an attribute manager can determine attribute values for a corresponding attribute e.g. as requested via voucher management module . An attribute manager can maintain runtime relationships among execution instances e.g. processes threads etc. referencing or having vouchers specifying the corresponding attribute vales. Attribute managers can request updates on properties e.g. security privileges priorities etc. of execution instances and or system components e.g. power management via system management module . A process attribute value of an attribute in a voucher can be changed by an attribute management module such as or . For example process can have a processing priority attribute with a processing priority number attribute value of e.g. 5. Process can request a voucher from voucher management module that includes an attribute for processing priority. Voucher management module can return a voucher reference to process . Process can then request that a voucher reference referencing the same voucher as voucher reference be sent to process . Process can receive and redeem the voucher referenced by voucher reference . Process can then adopt the same processing priority as process when performing processing operations on behalf of process . Attribute management module e.g. or can then change the processing priority attribute value for the voucher from 5 to 4 e.g. In response system management module can change the processing priority for the processes that reference the voucher having the changed attribute value. As a result processing operations performed by both process and process that are associated with the voucher referenced by vouchers and will be processed using processing priority .

A process can return a voucher by sending a message to the voucher management module . For example process performing a processing task on behalf of process can receive a voucher reference to a voucher containing processing attributes of process . After process completes a processing task on behalf of process process can request that voucher reference be returned to voucher management module . Accordingly a reference counter to the voucher stored within the voucher management module referenced by voucher reference can be decremented. If the reference count of a voucher reaches zero the voucher can be destroyed by the voucher management module .

In operation the kernel can detect a failure of a processing operation in a process within computing environment .

If a processing operation fails in operation the kernel can determine the activity ID and instance value of the failed processing operation.

In operation the kernel can notify the crash reporter of the failure of the processing operation. In one embodiment the crash reporter notifies the diagnostic service of the failure of the processing operation. In one embodiment the notification includes the activity ID and instance value of the failed processing operation.

In embodiments where the crash reporter notifies the diagnostic service of the failure in operation the diagnostic service can request the log buffers either or both the activity log buffers and the log buffers for an activity from all of the processes in the computing environment that performed a processing operation for the activity of the failed processing operation. In another embodiment in operation the crash reporter can request that the kernel send the log buffers from all processes in the computing environment that performed a processing operation for the activity and instance value of the failed processing operation to the diagnostic service .

In operation the kernel can collect log buffers from all processes that performed a processing task for the activity of the failed processing operation. Collecting log buffers can include one or both of activity log buffers and log buffers for the activity collectively and separately log buffers 3x0 . In one embodiment the kernel can perform the operation by looking up the activity description record of the activity having the failed processing operation. The kernel can then collect log buffers 3x0 from each process in the linked list of processes linked to the activity description record .

In one embodiment in operation the kernel can optionally filter the collection of log buffers 3x0 before passing the log buffers to the diagnostic service . Filtering can include operations for e.g. excluding log buffer 3x0 entries before a specific timestamp excluding successfully completed instances of the activity corresponding to the activity of the processing operation that failed or excluding activity instances in the activity log buffers of one or more specified activities.

In operation the kernel can pass the collected log buffers 3x0 optionally filtered to the diagnostic service .

If in operation the kernel did not detect a failure of a processing operation for an activity then in operation it is determined whether the processing operation is the last processing operation to complete the activity. If so then log buffer space used by one or more successfully completed instances of the activity can be marked as unused or otherwise reused such as by overwriting the data in the log buffer entries of one or more successfully completed instances of the activity. If in operation it is determined that this is not the last process operation to complete the processing activity then the method resumes at operation . Otherwise the method continues at operation .

In operation the kernel determines the highest instance value for the activity that has successfully completed all processing operations for the activity across all processes that have performed a processing ask to complete an instance of the activity.

In operation the kernel frees the log buffer space for all processes for the instances of the processing activity that have successfully completed all processing operations for the activity. In one embodiment freeing log buffer entries comprises marking freed log buffer entries as unused or available. Such entries can be overwritten with new log buffer information in accordance with the operations of through above.

In operation diagnostic service can receive a request to collect log buffers from the kernel the log buffers related to a failed processing operation of an activity. In one embodiment the request is received from the crash reporter . As described above with reference to the log buffers can include one or both of activity log buffers and log buffers for an activity collectively and separately log buffers 3x0 . As also described above in the collected log buffers 3x0 can optionally be filtered by the kernel before being passed to the diagnostic service .

In operation the diagnostic service can receive the collected log buffers 0 optionally filtered from the kernel .

In one embodiment in operation the diagnostic service can optionally filter the log buffers 3x0. Filtering can include operations for e.g. excluding log buffer 3x0 entries before a specified timestamp excluding log buffer entries corresponding to successfully completed instances of the activity or excluding activity instances in the activity log buffers of one or more specified activities.

In operation diagnostic service can collate the entries from the log buffers 3x0. Collating log buffers 3x0 can include collating log entries by timestamp by process identifier by processing operation identifier or activity ID or activity ID and instance value.

In operation the diagnostic service can decode each of the collated log entries into human readable text using the processing operation identifier to retrieve a message text and formatting string that can be used to format one or more optional parameters of the log buffer entries into the message text to generate the human readable text. Decoding of log entries is further described with reference to below.

In operation the decoded collated log entries can optionally be formatted into a report format with headings indentation page numbers etc.

In operation the decoded optionally filtered collated and optionally formatted log buffer entries can be passed to the crash reporter as a human readable text report.

To convert the encoded activity log buffer entry at slot into human readable text the timestamp and or program counter can be output in text form of its hexadecimal value or converted to a convention time value in hours minutes seconds milliseconds etc. Since a log buffer for an activity only logs diagnostic information for one activity for one process both the process name and the activity can be determined from the activity description record and e.g. the process reference record for process . The instance value of the log entry can also be output as a text value. Message ID references a text message e.g. message ID 0x4783 that is stored in programming code or other text table resources accessible by the kernel and by the diagnostic service . Example message ID 0x4783 contains a text message and formatting string Downloaded d KB of d KB requested. Parameter P1 can represent the number of KB downloaded so far and parameter P2 can represent the number of KB requested for downloading. Concatenating the timestamp string process description from activity description record process description from the process reference record e.g. the instance number of the activity and formatting in the parameters P1 and P2 the message is generated as human readable text for generating a report to pass to the crash reporter .

In Software Stack an exemplary embodiment applications can make calls to Services A or B using several Service APIs and to Operating System OS using several OS APIs. A and B can make calls to OS using several OS APIs.

Note that the Service 2 has two APIs one of which Service 2 API 1 receives calls from and returns values to Application 1 and the other Service 2 API 2 receives calls from and returns values to Application 2 Service 1 which can be for example a software library makes calls to and receives returned values from OS API 1 and Service 2 which can be for example a software library makes calls to and receives returned values from both OS API 1 and OS API 2 Application 2 makes calls to and receives returned values from OS API 2.

The computing system illustrated in is intended to represent a range of computing systems either wired or wireless including for example desktop computer systems laptop computer systems cellular telephones personal digital assistants PDAs including cellular enabled PDAs set top boxes entertainment systems or other consumer electronic devices. Alternative computing systems may include more fewer and or different components. The computing system of may be used to provide a client device and or a server device.

Computing system includes bus or other communication device to communicate information and processor coupled to bus that may process information.

While computing system is illustrated with a single processor computing system may include multiple processors and or co processors . Computing system further may include random access memory RAM or other dynamic storage device referred to as main memory coupled to bus and may store information and instructions that may be executed by processor s . Main memory may also be used to store temporary variables or other intermediate information during execution of instructions by processor .

Computing system may also include read only memory ROM and or other static storage device coupled to bus that may store static information and instructions for processor s . Data storage device may be coupled to bus to store information and instructions. Data storage device such as flash memory or a magnetic disk or optical disc and corresponding drive may be coupled to computing system .

Computing system may also be coupled via bus to display device such as a cathode ray tube CRT or liquid crystal display LCD to display information to a user. Computing system can also include an alphanumeric input device including alphanumeric and other keys which may be coupled to bus to communicate information and command selections to processor s . Another type of user input device is cursor control such as a touchpad a mouse a trackball or cursor direction keys to communicate direction information and command selections to processor s and to control cursor movement on display .

Computing system further may include one or more network interface s to provide access to a network such as a local area network. Network interface s may include for example a wireless network interface having antenna which may represent one or more antenna e . Computing system can include multiple wireless network interfaces such as a combination of WiFi Bluetooth and cellular telephony interfaces. Network interface s may also include for example a wired network interface to communicate with remote devices via network cable which may be for example an Ethernet cable a coaxial cable a fiber optic cable a serial cable or a parallel cable.

In one embodiment network interface s may provide access to a local area network for example by conforming to IEEE 802.11b and or IEEE 802.11g standards and or the wireless network interface may provide access to a personal area network for example by conforming to Bluetooth standards. Other wireless network interfaces and or protocols can also be supported. In addition to or instead of communication via wireless LAN standards network interface s may provide wireless communications using for example Time Division Multiple Access TDMA protocols Global System for Mobile Communications GSM protocols Code Division Multiple Access CDMA protocols and or any other type of wireless communications protocol.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

