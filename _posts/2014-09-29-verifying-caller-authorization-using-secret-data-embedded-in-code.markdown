---

title: Verifying caller authorization using secret data embedded in code
abstract: In a computer system operable at more than one privilege level, confidential code is securely customized to use secret data to establish a code protection domain without disclosing the secret data to a managing operating system. In operation, a security module executes at a higher privilege level than both the managing operating system and the confidential code. After the managing operating system loads the executable of the confidential code, the security module injects the secret data directly into an authorization instruction and a verification instruction included in the confidential code and then sets both the authorization instruction and the verification instruction as executable-only. As the confidential code executes at the assigned privilege level, the authorization instruction and the verification instruction use the secret data to distinguish between unauthorized and authorized execution of the confidential code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09398019&OS=09398019&RS=09398019
owner: VMware, Inc.
number: 09398019
owner_city: Palo Alto
owner_country: US
publication_date: 20140929
---
This application claims the benefit of U.S. Provisional Application No. 62 034 461 filed Aug. 7 2014.

Computer systems and applications executing within the computer systems are often configured to implement security measures designed to thwart malicious activity such as corrupting memory or accessing privileged information. For example two separate authorized software applications may share a confidential passkey that the applications use to authenticate data transmissions. However while such an authentication process reduces the security risk associated with a malicious user intercepting data transmissions the security provided may be breached if the confidential pass key is obtained by the malicious user.

As illustrated by this example of data transmissions secured by passkey maintaining the secrecy of some amount of data that is used by software applications is useful for implementing comprehensive security measures. In one attempt to limit the exposure of confidential data to unauthorized access the confidential data is changed frequently. While this approach limits the vulnerability of the confidential data to the change interval such an approach does not eliminate the vulnerability of the confidential data. Further in some scenarios the flexibility required to change confidential data periodically is not available or is too expensive to implement. Consequently there is a need for securing confidential data used by software applications particularly in the presence of a potentially compromised operating system in a more effective manner.

Each guest VM is configured to execute a guest operating system OS which may be a commodity operating system such as Microsoft Windows operating system or Linux operating system. Each guest VM is further configured to support guest applications apps and a thin agent . In one embodiment thin agent is an in guest driver that executes as part of guest OS and provides an interface including communications and access for certain system operations to a service application that executes as part of service appliance . In alternate embodiments thin agent is any in guest i.e. executes in guest OS component of any application that executes primarily outside guest OS .

Virtualization software is configured to manage and operate host server system . Virtualization software provides an execution environment for guest VMs and service appliances . Each guest VM and service appliance executes as an application in an independent context and virtualization software provides a more privileged context that may be used as a bridge between these independent contexts. Virtualization software may be implemented to include a kernel with hardware drivers for managing related hardware subsystems within host server system . In one embodiment virtualization software comprises a host operating system configured to provide system services to guest VMs . In other embodiments virtualization software comprises a hypervisor configured to provide certain system services to guest VMs . The hardware subsystems may include without limitation computational resources mass storage a networking interface input output interfaces a display controller and power management functions.

As shown virtualization software includes a multiplexer and a guest integrity module that both operate in the privileged context of virtualization software . Among other things guest integrity module works together with multiplexer to forward data messages between at least one thin agent and at least one service appliance . In one embodiment multiplexer implements a forwarding table that includes at least one entry for each thin agent and each service appliance . In such an embodiment multiplexer implements destination based forwarding whereby a data message is constructed to include a destination address that corresponds to at least one thin agent or at least one service appliance . When multiplexer receives the data message an associated destination address is matched to an entry within the forwarding table to determine a destination thin agent or service appliance for the data message. The destination thin agent or service appliance may be identified using a TCP IP transport control protocol internet protocol address a socket number a VM identifier or any other technically feasible identifier.

Each service appliance includes software service application and an access library . A given service appliance may execute as an application under control of virtualization software and may be implemented as a virtual machine with a guest OS that is configured to execute service application . In some embodiments service applications that implement security services may execute as applications under the control of virtualization software and are implemented in a single virtual machine known as a security virtual machine. Access library is configured so as to communicate with at least one thin agent via the multiplexer . In one embodiment access library opens a different socket connection for example via TCP IP to multiplexer for communication with each different thin agent . In alternative embodiments different message passing techniques may be implemented. For example a shared memory message passing system may be implemented for communication between thin agents and access libraries . In certain embodiments service appliance is configured to execute on a remote host server system that is coupled to host server system via a data network. In such embodiments service appliance establishes data connections such as TCP IP connections to one or more guest VMs within host server system and operates substantially identically to other service appliances . Similarly service appliance executing within host server system may connect to and provide services to VMs operating within the remote host server system.

Access library presents an application programming interface API not shown to service application . The API includes service calls for communicating with at least one thin agent . Communicating may include without limitation establishing a connection with thin agent configuring thin agent receiving event alerts from thin agent and accessing system resources for guest OS associated with thin agent . Events that may be reported include file system events process events memory events registry events and user events. Exemplary file system events include opening a file closing a file writing a file and modifying a file. Exemplary process scheduling events include mapping a file for execution starting a process and stopping a process. Certain types of events such as registry events may depend on a particular version of guest OS . The API may specify that certain events not be reported. For example service application may request that no events be reported or that only specific events be reported. In one embodiment the API enables a connection from service application to a specified thin agent within a guest VM to be established through multiplexer .

In this fashion access library and thin agent operate in concert to provide service application with access to system resources for associated guest OS . However since thin agent executes as part of guest OS thin agent is susceptible to any security breech that compromises the integrity of guest OS . For example in some embodiments thin agent and service application share a security key to authenticate data packets that are communicated between thin agent and service application via multiplexer and access library . In such embodiments the security of the communications is limited by the confidentiality of the security key. For this reason embodiments provide a guest integrity module that executes within virtualization software and is programmed to confidentially inject the security key provided by service application into thin agent prior to the transmission of data packets between thin agent and service application . Because guest integrity module operates at a more privileged security level than guest OS guest integrity module is able to bridge the context gap between thin agent and service application without exposing service application to a potentially compromised guest OS .

It should be recognized that the various terms layers and categorizations used to describe the virtualization components in may be referred to differently without departing from their functionality or the spirit or scope of the invention. For example host server system may include virtual machine monitors VMM not shown which implement the virtual system support needed to coordinate operations between virtualization software and their respective VMs. One example of virtualization software that may be used is a hypervisor included as a component of VMware s vSphere product which is commercially available from VMware Inc. of Palo Alto Calif. It should further be recognized that other virtualized computer systems are contemplated such as hosted virtual machine systems where the hypervisor is implemented in conjunction with a host operating system.

As shown security key instruction encapsulates a security key intermediate which is a constant operand. When security key instruction is executed by guest OS an instruction is performed on security key intermediate and any additional operands . Because security key intermediate is an immediate operand the value of security key intermediate is directly available in the instruction stream and to security key instruction . By contrast one or more additional operands may specify memory addresses that indirectly reference the corresponding values. It should be recognized that specifying the value of a constant via security key intermediate insulates the constant from security risks associated with memory accessible to guest OS .

An example security key instruction illustrates one instruction that is used to protect secret data. As shown security key intermediate is the value 1234565432100 where the immediate operand type is designated by instruction is mov and additional operand is rax i.e. the rax register . When guest OS executes example security key instruction the processing unit loads secret data 1234565432100 into the rax register from where it can be manipulated further such as being incorporated into a hashing algorithm.

To effectively inject secret data into executable code requires modifying the executable code in a confidential environment. Since guest integrity module executes at a higher privilege level than guest OS guest integrity module is able to inject the secret data without disclosing the secret data to guest OS . In one embodiment guest integrity module receives the secret data from service application via a secure transmission. Subsequently guest integrity module accesses Executable and Linkable format ELF file data that includes the executable code in addition to one or more relocation entries known as fixups that specify addresses in the executable code that are to be set to the secret data after the executable code is loaded.

As shown ELF file data includes a program header a section header and data . Notably section header includes security key fixup that specifies the address of security key intermediate . In operation as part of preparing executable code that is intended to hold the security key the software developer of the executable code inserts security key fixups into the corresponding ELF data file conveying that guest integrity module is to overwrite security key intermediates with the security key.

In alternate embodiments ELF may be replaced with any other format that supports relocations such as Windows Preinstallation Environment. Further it should be recognized that other techniques for obtaining and injecting secret data into executable code may be employed by guest integrity module .

To continuously hide the secret data from read access by guest OS guest integrity module uses the addressing and protection mechanisms provided by host server system . Host sever system carries out mappings from a guest virtual address space of guest VMs or any other applications running virtualization software to a machine address space of memory referred to herein as the host physical address space using nested page tables . As shown in nested page tables is a page translation hierarchy that includes a stage guest virtual address VA to guest physical address PA and a stage PA to machine address MA .

Both stage VA PA and stage PA MA include page table entries PTEs and each PTE includes inter alia a page number and permission bits . Page number indicates the next page in the page table translation hierarchy. If PTE is at the lowest level of the page table translation hierarchy then page number corresponds to a data page. In general attributes such as permission bits associated with a data page are defined by the more restrictive of the stage VA PA and the stage PA MA attributes traversed in the page table translation hierarchy. As shown permission bits include a read R bit a write W bit and execute X bit. For PTE if the read and write bits are each clear and the execute bit is set then the instruction referenced by PTE is execute only. If any PTE along the page table translation hierarchy traversed to translate an address in guest virtual address space to host physical address space is designated as execute only then guest OS is unable to read from the address or write to the address but is able to execute an instruction at the address.

In host server system guest OS is capable of modifying PTEs included in stage VA PA either via software or hardware mechanisms but guest OS is unable to modify PTEs included in stage PA MA . By contrast guest integrity module is capable of modifying PTEs included in stage PA MA . Guest integrity module leverages this difference in PTE accessibility in conjunction with permissions bits to protect security key instruction from attempts to ascertain the value of security key intermediate by guest OS .

More specifically before performing the security key fixup specified in ELF file data guest integrity module suspends guest OS and enables write access to PTE corresponding to security key instruction . After performing the security key fixup guest integrity module disables read and write access to PTE corresponding to security key instruction enables execute only access to PTE and unsuspends guest OS . Since guest OS is unable to read security key intermediate included in security key instruction the value of security key intermediate is protected from security breaches that compromise guest OS guest apps and thin agent .

It should be understood that illustrate one possible configuration of a page table translation hierarchy nested page tables and bits in PTE and the number and arrangement of elements in the page table translation hierarchy and PTE can be varied from what is shown. Host server system may employ any number of translation lookaside buffers TLBs as part of the page translation process. Further in alternate embodiments host server system may carry out mappings from the guest virtual address space to the host physical address space using shadow page tables to map guest virtual address spaces within guest VMs directly to the physical address space of memory. Embodiments include any mechanism that enables guest integrity module and not guest OS to designate the address corresponding to security key intermediate or a range of addresses that includes the address corresponding to security key intermediate as execute only. For example in some architectures the code pages accessed via extended page tables may be tagged as execute only.

This method begins at step where a software developer includes security key instruction in the code of thin agent . As part of security key instruction the software developer includes a placeholder e.g. a meaningless value to be replaced later as security key intermediate . At step the software developer inserts a security key fixup into ELF data file corresponding to thin agent . The security key fixup specifies the address of the placeholder and conveys that this address is to be overwritten with the security key.

At step guest OS loads ELF file data corresponding to thin agent . More specifically guest OS loads the executable for thin agent and may perform any number of fixups that are not associated with the security key. At step guest integrity module suspends guest OS . While guest OS is suspended guest OS is unable to perform operations and consequently guest integrity module may alter page table entries and the executable of thin agent without detection by guest OS . However if guest OS is already compromised then the executable of thin agent may also be compromised. To thwart any attempt at breaching security via thin agent guest integrity module verifies the executable for thin agent before exposing thin agent to any secure data. Guest integrity module may verify the executable for thin agent in any technically feasible fashion. For instance guest integrity module may independently load a second copy of the executable of thin agent via ELF file data and then compare the two copies of the executable of thin agent .

At step guest integrity module establishes the security key to match the security key that is expected by service application . For example if service application incorporates the security key as part of a hashing algorithm then security key instruction may be configured to cause thin agent to use the same security key as part of a complementary hashing algorithm. Guest integrity module may establish this security key in any fashion that preserves the confidentiality of the security key. For instance guest integrity module may receive the security key in a confidential transmission from service application and then ensure that the security key is not stored in memory accessible to guest OS at any time guest OS is active i.e. unsuspended . After establishing the security key guest integrity module processes the security key fixup in ELF file data overwriting the placeholder that is located at the address of security key intermediate with the security key.

To ensure the continued confidentiality of the security key while guest OS is still suspended guest integrity module modifies permission bits in stage PA MA page table entry corresponding to the page that includes the address of security key intermediate . More specifically guest integrity module disables read and write access and enable execute only access for a range of addresses that includes security key instruction step . At step guest integrity module unsuspends guest OS and thin agent executes in guest OS . In operation thin agent and service application cooperatively use the security key embedded in thin agent and known to service application for validation purposes without exposing the security key to security risks of guest OS .

This method begins at step where thin agent prepares data for transmission from guest VM to service appliance . As part of preparing the data thin agent executes a hashing algorithm that includes security key instruction step . Since security key instruction includes the value of the security key as security key intermediate thin agent is able to execute the hashing algorithm without loading the security key in memory accessible by guest OS and thus preserves the confidentiality of the security key. Thin agent then tags the packet of data based on the hashing algorithm and transmits the tagged packet of data to guest integrity module step in any technically feasible fashion. In some embodiments thin agent accesses an I O port specific to guest VMs known as a backdoor port to communicate with virtualization software including guest integrity module .

Upon receiving the tagged packet of data guest integrity module performs verification operations to ensure that the security key is valid. If at step guest integrity module determines that the security key is not valid then guest integrity module issues a security alert and discards the data packet . In this fashion if guest OS is compromised and attempts to transmit malicious data to service application then the security key enables guest integrity module to intercept the data isolating service application from compromised guest OS .

At step if guest integrity module determines that the security key is valid then guest integrity module forwards the tagged data packet to multiplexer . At step multiplexer routes the tagged data packet to service application . At step service application receives the tagged data packet and processes the data in the data packet. As part of receiving the tagged data packet service application may execute a hashing algorithm that is complementary to the hashing algorithm implemented by thin agent using the shared but confidential security key to recreate the original data.

As this method illustrates embedding a secure passkey in code enables confidential data transmission. In general embedding secure data in code enables a wide variety of powerful security measures. For instance developers may use guest integrity module to create a code protection domain establishing confidential data that is set by instructions only upon authorized entry to the code protection domain and subsequently checked by instructions executing in the code protection domain before executing confidential code.

As shown in developers include authorization code including move security key instruction at well defined entry points to code executed within the code protection domain . As also shown developers include verification code including compare security key instruction at verification points in confidential code executed within the code protection domain . Developers may establish any number of code protection domains with any number of entry points and any number of verification points . Developers may include any number of normal instructions in code executed within the code protection domain. Further developer may select any technically feasible register of CPU as authorization register and any confidential value as the security key.

Similarly to the techniques disclosed herein to enable confidential data transmission guest integrity module uses ELF files for the authorization code and the verification code to specify the addresses at which to insert the security key. Guest integrity module also uses nested page tables to disable read and write access to the security key. Guest integrity module coordinates these activities to maintain confidentially both while guest integrity module injects the security key into both the authorization code and the verification code as well as while guest OS executes.

This method begins at step where a software developer includes move security key instruction with a placeholder as an immediate operand in authorization code at a well defined entry point to the code protection domain. Correspondingly at step a software developer includes compare security key instruction with a placeholder as an immediate operand and appropriate branching instructions at a strategically selected point in confidential code.

At step the software developer inserts security key fixups into ELF data files corresponding to the executable code that include placeholders. Each security key fixup specifies the address of a placeholder and conveys that this address is to be overwritten with the security key. The software developer has now prepared the executable code for configuration using a security key that is not disclosed to guest VM .

This method begins at step where CPU is executing code. If the code that CPU is executing is authorization code step then this method proceeds to step and CPU executes move security key instruction included in authorization code . Notably the code protection domain is configured such that authorization code is included only at well defined entry points to the code protection domain. As part of step CPU sets the value of authorization register to the security key without loading the security key into memory accessible by guest OS and thus preserves the confidentiality of the security key. This method then returns to step where CPU continues executing code.

If at step the code that CPU is executing is not authorization code then this method proceeds directly to step . At step if the code that CPU is executing is verification code inserted to detect unauthorized access to the confidential code then this method proceeds to step . At step CPU executes compare security key instruction included in verification code comparing the value of authorization register to the security key. CPU performs this operation without loading the security key into memory accessible by guest OS . If at step the value of authorization register equals the security key then verification code allows execution of the confidential code and this method returns to step where CPU continues executing code.

At step if the value of authorization register does not equal the security key then verification code issues a security alert and exits step . Such a scenario occurs when this method does not enter the code protection domain at an authorized entry point and consequently any access of executable code within the code protection domain is unauthorized. For example a malicious application may branch into confidential code in an attempt to bypass any checks at the authorized entry points . Typically developers will include verification code in strategic locations within confidential code limiting the impact of unauthorized access to the code protection domain.

The embodiments disclosed herein detail specific use cases in which embedding secure data in code executed by a compromised operating system effectively thwarts attempts by the compromised operating system to obtain the secure data. However the described embodiments are to be considered as illustrative and not restrictive. Other use cases that leverage the same underlying techniques to securely inject secret data in code are envisioned. Further although host server system supports a virtualization environment any host server system that supports at least two levels of privilege and provides a mechanism to designate certain addresses as execute only may implement these security techniques.

The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present invention have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Virtualization systems in accordance with the various embodiments may be implemented as hosted embodiments non hosted embodiments or as embodiments that tend to blur distinctions between the two are all envisioned. Furthermore various virtualization operations may be wholly or partially implemented in hardware. For example a hardware implementation may employ a look up table for modification of storage access requests to secure non disk data.

Many variations modifications additions and improvements are possible regardless the degree of virtualization. The virtualization software can therefore include components of a host console or guest operating system that performs virtualization functions. Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claim s .

