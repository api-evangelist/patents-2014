---

title: Unrolling quantifications to control in-degree and/or out-degree of automaton
abstract: Apparatus, systems, and methods for a compiler are disclosed. One such compiler parses a human readable expression into a syntax tree and converts the syntax tree into an automaton having in-transitions and out-transitions. Converting can include unrolling the quantification as a function of in-degree limitations wherein in-degree limitations includes a limit on the number of transitions into a state of the automaton. The compiler can also convert the automaton into an image for programming a parallel machine, and publishes the image. Additional apparatus, systems, and methods are disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09298437&OS=09298437&RS=09298437
owner: Micron Technology, Inc.
number: 09298437
owner_city: Boise
owner_country: US
publication_date: 20140414
---
This patent application is a continuation of U.S. application Ser. No. 13 357 505 filed Jan. 24 2012 and now issued as U.S. Pat. No. 8 726 256 which claims the benefit of priority under 35 U.S.C. Section 119 e to U.S. Provisional Patent Application Ser. No. 61 436 051 titled UNROLLING QUANTIFICATIONS TO CONTROL IN DEGREE AND OR OUT DEGREE OF AUTOMATON filed on Jan. 25 2011 all of which are hereby incorporated by reference herein in their entirety.

A finite state machine FSM also referred to as a finite state automaton automaton or simply a state machine is a representation of states transitions between states and actions. A finite state machine can be used to design digital logic computer programs or images for a parallel machine. A finite state machine is a model of behavior composed of a finite number of states transitions between those states and outputs. A finite state machine can be represented as a graph where the vertices of the graph correspond to states of the finite state machine and the edges of the graph correspond to transitions between states which occur due to one or more inputs to the finite state machine. Finite state machines can also have probabilistic transitions fuzzy states or other oddities. A finite state machine has a finite internal memory an input feature and an optional output feature. Finite state machines with an output can be referred to as finite state transducers.

Applications of finite state machines include electronic design automation communication protocol design biology and artificial intelligence research and linguistics to describe the grammars of natural languages.

The following description and the drawings sufficiently illustrate specific embodiments to enable those skilled in the art to practice them. Other embodiments may incorporate structural logical electrical process and other changes. Portions and features of some embodiments may be included in or substituted for those of other embodiments. Embodiments set forth in the claims encompass all available equivalents of those claims.

This document describes among other things a compiler that converts source code into a machine code implementation of a finite state machine. The machine code can correspond to a target device in that the machine code is configured to implement the functions described by the source code on the target device. In an example the target device is a parallel machine and the machine code comprises an image for the parallel machine. In another example the target device comprises a computer having a Von Neumann architecture and the machine code comprises instructions for execution by a processor in the computer.

In any case the compiler converts the source code into a finite state machine embodying the functions described by the source code. In the process of compiling the source code the compiler converts the source code into an automaton. Using the automaton the compiler can identify and combine redundancies in the source code in order to optimize the resultant finite state machine implemented in the machine code. Additionally the compiler can take into account aspects or limitations of the target device when forming the automaton in order to reduce complexity of the resultant machine code and increase the efficiency of operation of the target device.

In an example the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings the source code can include a plurality of regular expressions regexs . A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains such as programming languages text editors network security and others. In an example the regular expressions supported by the compiler include search criteria for the search of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes printable and non printable within the data. In an example the compiler can support multiple different source code languages for implementing regexes including Perl e.g. Perl compatible regular expressions PCRE PHP Java and .NET languages.

Referring back to at block the compiler can parse the source code to form an arrangement of relationally connected operators. Parsing source code can create a generic representation of the source code. In an example the generic representation comprises an encoded representation of the regexs in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree also known as an abstract syntax tree in other examples however a concrete syntax tree or other arrangement can be used.

Since as mentioned above the compiler can support multiple languages of source code parsing converts the source code regardless of the language into a non language specific representation e.g. a syntax tree. Thus further processing blocks by the compiler can work from a common input structure regardless of the language of the source code.

The syntax tree includes a plurality of operators that are relationally connected. The syntax tree can include multiple different types of operators where different types of operators correspond to different functions implemented by the source code. That is different operators can correspond to different functions implemented by the regexes in the source code.

At block the syntax tree is converted into an automaton. An automaton comprises a software model of a FSM and can accordingly be classified as deterministic or non deterministic. A deterministic automaton has a single path of execution at a given time while a non deterministic automaton has multiple concurrent paths of execution. The automaton comprises a plurality of states. In order to convert the syntax tree into an automaton the operators and relationships between the operators in the syntax tree are converted into states with transitions between the states.

In order to effectively utilize the elements of the target device the compiler can form the automaton based on aspects or limitations of the elements of the target device. For example the elements may have certain restrictions on the number of transitions into or out of a given state in the automaton. In other examples hard restrictions may not be present but the compiler may limit the number of transitions into or out of a given state in order to simplify the processing required by the compiler to generate the machine code and or to improve the efficiency of operation of the machine code on the target device. More detail on limiting the transitions into or out of a given state is provided below with respect to .

Once the automaton has been formed at block the automaton can be optimized to among other things reduce its complexity and size. The automaton can be optimized by combining equivalent states among other things.

At block the automaton is converted into machine code for a target device. In one example the machine code comprises executable instructions for a processor in a Von Nuemann architecture. Here the machine code can comprise an executable program. In another example the machine code can comprise bits configured to program the hardware elements in a parallel machine. Here the machine code can comprise an image for loading onto the parallel machine.

At block the machine code can be published by the compiler. In an example the machine code can be published by saving the machine code to a computer readable medium. In another example the machine code can be published by sending the machine code to another device such as a loader for loading the machine code onto a parallel machine. In yet another example the machine code can be published by loading the machine code onto a parallel machine. In still another example the machine code can be published by displaying the machine code on a display device.

In an example the compiler can be implemented by instructions for a computer having a Von Nuemann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler. For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor. An example computer having a Von Nuemann architecture is shown in and described below.

One type of regex that can be described in the source code includes a quantification. Quantifications are well known in the art and are used to describe repeated patterns. As an example A B n1 n2C is a general regular expression where A B and C are sub expressions and B n1 n2 comprises a quantification. As described herein upper case letters are used to represent regular expressions or a portion of a regular expression e.g. a sub expression . Double quotation marks may be added around regular expressions or sub expressions to avoid confusion. Accordingly an upper case letter describing an expression can correspond to a search string for multiple input symbols. For example the expression A can correspond to the input string abbc .

Moreover it should be understood that the terms expression and sub expression are used herein for relational description only e.g. a sub expression is a portion of an expression and that the terms expression and sub expression should not be limited to any specific length syntax or number of characters. In particular source code can include a large number of characters including metacharacters and search characters of which the entire set of characters or any individual portion thereof can be considered an expression . For example each of the following can be considered an expression a bb d 5 20c b 0 10 b d and b .

A quantification is expressed in regex as B n1 n2 where B is a sub expression and n1 and n2 are integers specifying how many times the preceding sub expression is allowed to occur. B is referred to herein as a repeated sub expression since B is a sub expression that is repeated the number of times specified by n1 and n2. To match the quantification B n1 n2 the repeated sub expression B must be matched from n1 to n2 number of times. For example the regex B 5 7 would require the sub expression B to be matched 5 6 or 7 times. In the regex A B n1 n2C the sub expression A is referred to herein as a drive expression since the sub expression A when matched transitions to a quantification. Additionally to continue repeating and incrementing the count for the quantification the repeated sub expression s of the quantification must be matched consecutively. That is when a repeated sub expression is not matched during a given loop of the quantification the quantification ends. In an example the symbol also corresponds to quantification where the symbol preceding the can be identified either one or zero times.

Method begins at block where a quantification is converted to a non nullable form when a repeated sub expression of the quantification is nullable. If the repeated sub expression is not nullable the method proceeds to without converting the quantification. An expression is nullable when the expression can be matched by an empty string. For example the expression bc can be matched by either the input symbols bc OR an empty string. Accordingly the expression bc is nullable since the expression can be matched by an empty string. To convert a quantification corresponding to a nullable repeated sub expression to a quantification having a non nullable repeated sub expression the nullable portion of the repeated sub expression is removed. For example the expression bc becomes bc . In addition the number of loops to match the quantification is modified from n1 n2 to 0 n2. For example the expression ABn1 n2C is converted to AB 0 n2C where B is the non nullable form of B. In an example the quantification a bc 3 5d can be converted to a bc 0 5d .

In an example at block it is optionally determined whether the quantification is to be unrolled. As mentioned above unrolling a quantification can include rewriting the quantification with non quantification syntax and converting the non quantification syntax into an automaton. A consequence of this rewriting of the quantification is that the resulting unrolled syntax is implemented with general purpose states e.g. state machine elements and not special purpose states e.g. counters . In some situations however it may be desirable to implement the quantification with special purpose elements e.g. a counter and thus to not unroll the quantification. In other instances the quantification is unrolled. When the quantification is not unrolled method ends for that quantification. When the quantification can be unrolled at least in part method continues to block . The following conditions indicate an example of when can possibly be implemented with a counter and when a quantification is not to be implemented with a counter and is unrolled. It should be understood that although certain situations below are described as being possibly implemented by a counter in other examples these situations may be implemented by unrolling. In general all quantifications can be implemented by unrolling if desired.

Before determining whether a counter can be used to implement a quantification if B includes empty string the quantification of Bn1 n2 is rewritten as B 0 n2 where B is the no empty string version of B B B . For example bc 10 20 can be rewritten to bc 0 20 since these regexs accept the exact same data.

At block a quantification that can be matched with a single number of loops is unrolled to form an automaton having a plurality of the repeated sub expressions linked serially. A quantification having a single number of loops corresponds to a quantification where n1 equals n2. The quantification Bn1 for example can be unrolled as BB . . . B having n1 copies of B.

At block a quantification that can be matched with a multiple number of loops is unrolled when n1 does not equal n2 and when n1 equals and n2 is greater than 1. When n1 is greater than 1 the quantification is split into a first quantification that can be matched with n1 1 number of loops and a second quantification that can be matched with from one to n2 n1 1 numbers of loops. For example the quantification Bn1 n2 where n1 1 n2 1 and n1

The second quantification B1 n2 n1 1 can be unrolled based on the in degree and or out degree of the resulting automaton. Unrolling a quantification can create states that have a large in degree or a large out degree. In an example in degree corresponds to the number of transitions to a state of the automaton and out degree corresponds to the number of transitions from a state of the automaton. Accordingly the second quantification can be unrolled to control the transitions into the in degree or out of the out degree states when converting the second quantification into an automaton. For example the quantification can be unrolled to limit the in degree of each unrolled state to below a threshold number. Limiting the in degree can be performed for example to take into account aspects and or limitations of elements in the target device. Moreover limiting the in degree during unrolling can reduce the subsequent processing for the compiler.

In an example when unrolling the quantification B1 n2 n1 1 the automaton is generated as a trade off between in degree and out degree. Accordingly reducing the in degree may increase the out degree and reducing the out degree may increase the in degree. In an example to unroll the loop structure of the quantification B1 n2 n1 1 a number of transitions are made either to or from the unrolled states to make the automaton accept any string of k concatentated B where 1

Although method is described as corresponding to a single quantification method can be repeated for a plurality of quantifications within a syntax tree and the resulting separate automatons can then be linked into a larger automaton.

In an example an expression having a quantification is unrolled to limit one of the out degree or the in degree to less than a threshold. In an example to unroll the expression AB1 n1 to limit the in degree to a threshold a number of transitions for the quantification B1 n1 up to the threshold can be assigned as in transitions to the last state of the quantification B1 n1 and other transitions can be assigned as out transitions for the first state of the quantification B1 n1. Conversely to unroll an expression AB1 n1 to limit the out degree to a threshold a number of transitions for the quantification B1 n1 up to the threshold can be assigned as out transitions to the first state for the quantification and other transitions can be assigned as out transitions for the last state of the quantification B1 n1.

In other examples the in degree and out degree of an expression can be set to be certain ratio e.g. 1 to 1 2 to 1 of each other. In yet other examples the in degree and out degree of an expression can be set to be a certain ratio of each other up until a threshold is reached for either the in transitions or out transitions and then another ratio can be used or all of the transitions can be assigned as in transitions or out transitions respectively.

The description below with respect to pertains to example embodiments of implementing an automaton with limited in degree and or out degree in a parallel machine. The description with reference to pertains to example parallel machines for implementing quantifications and the description with reference to pertains to an example compiler to generate machine code to program the parallel machine to implement the quantification.

The parallel machine includes a plurality of programmable elements including general purpose elements and special purpose elements . A general purpose element can include one or more inputs and one or more outputs . A general purpose element can be programmed into one of a plurality of states. The state of the general purpose element determines what output s the general purpose elements will provide based on a given input s . That is the state of the general purpose element determines how the programmable element will react based on a given input. Data input to the data input port can be provided to the plurality of general purpose elements to cause the general purpose elements to take action thereon. Examples of a general purpose element can include a state machine element SME discussed in detail below and a configurable logic block. In an example a SME can be set in a given state to provide a certain output e.g. a high or 1 signal when a given input is received at the data input port . When an input other than the given input is received at the data input port the SME can provide a different output e.g. a low or 0 signal . In an example a configurable logic block can be set to perform a Boolean logic function e.g. AND OR NOR ext. based on input received at the data input port .

The parallel machine can also include a programming interface for loading a program e.g. an image onto the parallel machine . The image can program e.g. set the state of the general purpose elements . That is the image can configure the general purpose elements to react in a certain way to a given input. For example a general purpose element can be set to output a high signal when the character a is received at the data input port . In some examples the parallel machine can use a clock signal for controlling the timing of operation of the general purpose elements . In certain examples the parallel machine can include special purpose elements e.g. RAM logic gates counters look up tables etc. for interacting with the general purpose elements and for performing special purpose functions. In some embodiments the data received at the data input port can include a fixed set of data received over time or all at once or a stream of data received over time. The data may be received from or generated by any source such as databases sensors networks etc coupled to the parallel machine .

The parallel machine also includes a plurality of programmable switches for selectively coupling together different elements e.g. general purpose element data input port output port programming interface and special purpose elements of the parallel machine . Accordingly the parallel machine comprises a programmable matrix formed among the elements. In an example a programmable switch can selectively couple two or more elements to one another such that an input of a general purpose element the data input port a programming interface or special purpose element can be coupled through one or more programmable switches to an output of a general purpose element the output port a programming interface or special purpose element . Thus the routing of signals between the elements can be controlled by setting the programmable switches . Although illustrates a certain number of conductors e.g. wires between a given element and a programmable switch it should be understood that in other examples a different number of conductors can be used. Also although illustrates each general purpose element individually coupled to a programmable switch in other examples multiple general purpose elements can be coupled as a group e.g. a block as illustrated in to a programmable switch . In an example the data input port the data output port and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements.

In an example a single parallel machine is implemented on a physical device however in other examples two or more parallel machines can be implemented on a single physical device e.g. physical chip . In an example each of multiple parallel machines can include a distinct data input port a distinct output port a distinct programming interface and a distinct set of general purpose elements . Moreover each set of general purpose elements can react e.g. output a high or low signal to data at their corresponding input data port . For example a first set of general purpose elements corresponding to a first parallel machine can react to the data at a first data input port corresponding to the first parallel machine . A second set of general purpose elements corresponding to a second parallel machine can react to a second data input port corresponding to the second parallel machine . Accordingly each parallel machine includes a set of general purpose elements wherein different sets of general purpose elements can react to different input data. Similarly each parallel machine and each corresponding set of general purpose elements can provide a distinct output. In some examples an output port from first parallel machine can be coupled to an input port of a second parallel machine such that input data for the second parallel machine can include the output data from the first parallel machine .

In an example an image for loading onto the parallel machine comprises a plurality of bits of information for setting the state of the general purpose elements programming the programmable switches and configuring the special purpose elements within the parallel machine . In an example the image can be loaded onto the parallel machine to program the parallel machine to provide a desired output based on certain inputs. The output port can provide outputs from the parallel machine based on the reaction of the general purpose elements to data at the data input port . An output from the output port can include a single bit indicating a match of a given pattern a word comprising a plurality of bits indicating matches and non matches to a plurality of patterns and a state vector corresponding to the state of all or certain general purpose elements at a given moment.

Example uses for the parallel machine include pattern recognition e.g. speech recognition image recognition etc. signal processing imaging computer vision cryptography and others. In certain examples the parallel machine can comprise a finite state machine FSM engine a field programmable gate array FPGA and variations thereof. Moreover the parallel machine may be a component in a larger device such as a computer pager cellular phone personal organizer portable audio player network device e.g. router firewall switch or any combination thereof control circuit camera etc.

The FSM engine includes a plurality of programmable elements including general purpose elements and special purpose elements. The general purpose elements can be programmed to implement many different functions. These general purpose elements include SMEs shown in that are hierarchically organized into rows shown in and blocks shown in . To route signals between the hierarchically organized SMEs a hierarchy of programmable switches is used including inter block switches shown in intra block switches shown in and intra row switches shown in . A SME can correspond to a state of a FSM implemented by the FSM engine . The SMEs can be coupled together by using the programmable switches as described below. Accordingly a FSM can be implemented on the FSM engine by programming the SMEs to correspond to the functions of states and by selectively coupling together the SMEs to correspond to the transitions between states in the FSM.

In an example the input block the output block and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements. Accordingly bits from the image stored in the registers corresponding to the programming interface can be loaded on the SMEs . Although illustrates a certain number of conductors e.g. wire trace between a block input block output block and an inter block switch it should be understood that in other examples fewer or more conductors can be used.

In an example the row includes a first and second plurality of row interconnection conductors . In an example an input of a GOT can be coupled to one or more row interconnection conductors and an output can be coupled to one row interconnection conductor . In an example a first plurality of the row interconnection conductors can be coupled to each SME of each GOT within the row . A second plurality of the row interconnection conductors can be coupled to one SME of each GOT within the row but cannot be coupled to the other SME of the GOT . In an example a first half of the second plurality of row interconnection conductors can couple to first half of the SMEs within a row one SME from each GOT and a second half of the second plurality of row interconnection conductors can couple to a second half of the SMEs within a row the other SME from each GOT . The limited connectivity between the second plurality of row interconnection conductors and the SMEs is referred to herein as parity .

In an example the row can also include a special purpose element such as a counter a programmable Boolean logic element a field programmable gate array FPGA an application specific integrated circuit ASIC a programmable processor e.g. a microprocessor and other elements. Additionally in an example the special purpose element is different in different rows . For example four of the rows in a block can include Boolean logic as the special purpose element and the other eight rows in a block can include a counter as the special purpose element .

In an example the special purpose element includes a counter also referred to herein as counter . In an example the counter comprises a 12 bit programmable down counter. The 12 bit programmable counter has a counting input a reset input and zero count output. The counting input when asserted decrements the value of the counter by one. The reset input when asserted causes the counter to load an initial value from an associated register. For the 12 bit counter up to a 12 bit number can be loaded in as the initial value. When the value of the counter is decremented to zero 0 the zero count output is asserted. The counter also has at least two modes pulse and hold. When the counter is set to pulse mode the zero count output is asserted during the first clock cycle when the counter decrements to zero and at the following clock cycles the zero count output is no longer asserted even if the counting input is asserted. This state continues until the counter is reset by the reset input being asserted. When the counter is set to hold mode the zero count output is asserted during the first clock cycle when the counter decrements to zero and stays asserted when the counting input is asserted until the counter is reset by the reset input being asserted.

In an example a state machine element comprises a plurality of memory cells such as those often used in dynamic random access memory DRAM coupled in parallel to a detect line . One such memory cell comprises a memory cell that can be set to a data state such as one that corresponds to either a high or a low value e.g. a 1 or 0 . The output of the memory cell is coupled to the detect line and the input to the memory cell receives signals based on data on the data stream line . In an example an input on the data stream line is decoded to select one of the memory cells . The selected memory cell provides its stored data state as an output onto the detect line . For example the data received at the data input port can be provided to a decoder not shown and the decoder can select one of the data stream lines . In an example the decoder can convert an ACSII character to 1 of 256 bits.

A memory cell therefore outputs a high signal to the detect line when the memory cell is set to a high value and the data on the data stream line corresponds to the memory cell . When the data on the data stream line corresponds to the memory cell and the memory cell is set to a low value the memory cell outputs a low signal to the detect line . The outputs from the memory cells on the detect line are sensed by a detect circuit . In an example the signal on an input line sets the respective detect circuit to either an active or inactive state. When set to the inactive state the detect circuit outputs a low signal on the respective output regardless of the signal on the respective detect line . When set to an active state the detect circuit outputs a high signal on the respective output line when a high signal is detected from one of the memory cells of the respective SME . When in the active state the detect circuit outputs a low signal on the respective output line when the signals from all of the memory cells of the respective SME are low.

In an example an SME includes 256 memory cells and each memory cell is coupled to a different data stream line . Thus an SME can be programmed to output a high signal when a selected one or more of the data stream lines have a high signal thereon. For example the SME can have a first memory cell e.g. bit set high and all other memory cells e.g. bits set low. When the respective detect circuit is in the active state the SME outputs a high signal on the output when the data stream line corresponding to bit has a high signal thereon. In other examples the SME can be set to output a high signal when one of multiple data stream lines have a high signal thereon by setting the appropriate memory cells to a high value.

In an example a memory cell can be set to a high or low value by reading bits from an associated register. Accordingly the SMEs can be programmed by storing an image created by the compiler into the registers and loading the bits in the registers into associated memory cells . In an example the image created by the compiler includes a binary image of high and low e.g. 1 and 0 bits. The image can program the FSM engine to operate as a FSM by cascading the SMEs . For example a first SME can be set to an active state by setting the detect circuit to the active state. The first SME can be set to output a high signal when the data stream line corresponding to bit has a high signal thereon. The second SME can be initially set to an inactive state but can be set to when active output a high signal when the data stream line corresponding to bit has a high signal thereon. The first SME and the second SME can be cascaded by setting the output of the first SME to couple to the input of the second SME . Thus when a high signal is sensed on the data stream line corresponding to bit the first SME outputs a high signal on the output and sets the detect circuit of the second SME to an active state. When a high signal is sensed on the data stream line corresponding to bit the second SME outputs a high signal on the output to activate another SME or for output from the FSM engine .

In an example the compiler includes an application programming interface API that allows software developers to create images for implementing FSMs on the FSM engine . The compiler provides methods to convert an input set of regular expressions into an image that is configured to program the FSM engine . The compiler can be implemented by instructions for a computer having a Von Nuemann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler. For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor. An example computer having a Von Nuemann architecture is shown in and described below.

At block source code is parsed to form a syntax tree. Parsing creates a generic representation of the source code as explained above with respect to . In addition parsing can take into account regexs that are and are not supported by the FSM engine . Regexs that are supported can be converted into the appropriate machine code implementations however regexs that are not supported can for example generate an error or be converted into supported machine code that is close in functionality to the non supported regex.

At block the syntax tree is converted into an automaton. As mentioned above with respect to converting the syntax tree converts the syntax tree into an automaton comprising a plurality of states. In an example the automaton can be converted based partly on the hardware of the FSM engine .

In an example input symbols for the automaton include the symbols of the alphabet the numerals 0 9 and other printable characters. In an example the input symbols are represented by the byte values 0 through 255 inclusive. In an example an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example a transition from state p to state q on an input symbol i.e. p is shown by a directed connection from node p to node q.

In an example the automaton comprises general purpose states as well as special purpose states. The general purpose states and special purpose states correspond to general purpose elements and special purpose elements supported by a target device for which the compiler is generating machine code. Different types of target devices can support different types of general purpose elements as well as one or more different types of special purpose elements. A general purpose element can typically be used to implement a broad range of functions while a special purpose element can typically be used to implement a more narrow range of functions. In an example however a special purpose element can achieve for example greater efficiency within its narrow range of function. Accordingly a special purpose element can be used to for example reduce the machine cycles or the machine resources required to implement certain functions in the target device. In some examples the target device supports solely special purpose elements wherein multiple different types of special purpose elements are supported.

In an example where the compiler is generating machine code for the FSM engine the general purpose states can correspond to SMEs and the general purpose states are accordingly referred to herein as SME states . Moreover when the compiler is generating machine code for the FSM engine the special purpose states can correspond to counters and are accordingly referred to herein as counter states . In an example the SME states in the automaton map 1 1 to SMEs e.g. SME in the FSM engine with the exception of the starting state of the automaton which does not map to a SME. The counters may or may not map 1 1 to counter states.

In an example special transition symbols outside the input symbol range may be used in the automaton. These special transition symbols can be used for example to enable use of special purpose elements . Moreover special transition symbols can be used to provide transitions that occur on something other than an input symbol. For example a special transition symbol may indicate that a first state is to be enabled e.g. transitioned to when both a second state and a third state are enabled. Accordingly the first state is activated when both the second state and the third state are activated and the transition to the first state is not directly dependent on an input symbol. Notably a special transition symbol that indicates that a first state is to be enabled when both a second state and a third state are enabled can be used to represent a Boolean AND function performed for example by Boolean logic as the special purpose element . In an example a special transition symbol can be used to indicate a counter state has reached zero and thus transitions to a downstream state.

In an example an automaton can be constructed using one of the standard techniques such as Glushkov s method. In an example the automaton can be an free homogeneous automaton. Additional detail regarding converting the syntax tree into an automaton is provided with respect to below.

At block once the syntax tree has been converted to an automaton the automaton is optimized. The automaton can be optimized to among other things reduce its complexity and size. The automaton can be optimized by combining redundant states.

At block the optimized automaton is converted into a netlist. Converting the automaton into a netlist maps each state of the automaton to an instance of a hardware element e.g. SMEs special purpose elements on the FSM engine . Also the connections between the instances are determined to create the netlist.

At block the netlist is placed to select a specific hardware element of the target device e.g. SMEs special purpose elements corresponding to each instance of the netlist. In an example placing selects each specific hardware element based on general input and output constraints for of the FSM engine .

At block the placed netlist is routed to determine the settings for the programmable switches e.g. inter block switches intra block switches and intra row switches in order to couple the selected hardware elements together to achieve the connections describe by the netlist. In an example the settings for the programmable switches are determined by determining specific conductors of the FSM engine that will be used to connect the selected hardware elements and the settings for the programmable switches. Routing can take into account more specific limitations of the connections between the hardware elements that placement at block . Accordingly routing may adjust the location of some of the hardware elements as determined by the global placement in order to make appropriate connections given the actual limitations of the conductors on the FSM engine .

Once the netlist is placed and routed the placed and routed netlist can be converted into a plurality of bits for programming of a FSM engine . The plurality of bits are referred to herein as an image.

At block an image is published by the compiler. The image comprises a plurality of bits for programming specific hardware elements and or programmable switches of the FSM engine . In embodiments where the image comprises a plurality of bits e.g. 0 and 1 the image can be referred to as a binary image. The bits can be loaded onto the FSM engine to program the state of SMEs the special purpose elements and the programmable switches such that the programmed FSM engine implements a FSM having the functionality described by the source code. Placement block and routing block can map specific hardware elements at specific locations in the FSM engine to specific states in the automaton. Accordingly the bits in the image can program the specific hardware elements and or programmable switches to implement the desired function s . In an example the image can be published by saving the machine code to a computer readable medium. In another example the image can be published by displaying the image on a display device. In still another example the image can be published by sending the image to another device such as a programming device for loading the image onto the FSM engine . In yet another example the image can be published by loading the image onto a parallel machine e.g. the FSM engine .

In an example an image can be loaded onto the FSM engine by either directly loading the bit values from the image to the SMEs and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs and other hardware elements . In an example the hardware elements e.g. SMEs other elements programmable switches of the FSM engine are memory mapped such that a programming device and or computer can load the image onto the FSM engine by writing the image to one or more memory addresses.

Referring back to when converting the syntax tree into an automaton the in degree and or out degree of an unrolled quantification can be controlled. In an example the in degree and or out degree are controlled based on a threshold. The threshold can be for example based on a hardware limitation of the parallel machine for which the compiler is preparing an image. For example if a general purpose element of the parallel machine can have a maximum of 14 in transitions the threshold for unrolling can be set to less than or equal to 14 in transitions. In other examples the threshold for unrolling can be set such that a portion of the maximum in transitions are used. For example for a general purpose element having a maximum of 14 in transitions the threshold can be set to 7 in transitions to account for in transitions from expressions not in the expression being unrolled.

Unrolling can be formulated as a general graph problem described as following. illustrate graphs of four solutions to Problem 1 discussed below where the in degree and out degree are controlled. Different solutions provide different maximum length which is determined by the in degree and out degree threshold. Accordingly depending on the desired in degree and out degree a given solution may be chosen. The resultant in degree and or out degree of the automaton is a function of which solution is chosen to the two problems discussed below.

Problem 1 Extend path with in degree and out degree constraints . Given a directed path of length n and two unsigned integers p 1 and q 1. Denote the n 1 vertices as v0 v1 v2 . . . vn. The starting vertex of the path is v0 and the ending vertex is vn. Add edges to this path so that there is no loop introduced and for any k 1

Problem 2 Maximize path with in degree and out degree constraints . Given an infinite directed path and two unsigned integers p 1 and q 1. Denote the vertices as v0 v1 v2 . . . . Add edges to this path and find an ending vertex denoted as vm so that for any k 1

In an example Problem 2 is solved first. If the maximized path length m in not less than n Problem 1 can be solved easily. The four solutions described below with reference to are derived from the scatter and merge patterns discussed with respect to . The maximum length depends on the value of p and q.

In graph terms a scatter pattern can be described as an extension of a path with q vertices. Besides the edges comprising the original path the starting vertex v0 drives all the other vertices. The out degree of v0 is q 1 vq 1 is 0 and the other vertices v1 . . . vq 2 are 1. The in degree of v0 is 0 v1 is 1 and v2 . . . vq 1 is 2. For all k 1

Likewise in graph terms a merge pattern can be described as a path with p vertices. Besides the edges comprising the original path the ending vertex vp 1 is driven by all the other vertices. The in degree of vp 1 is p 1 v0 is 0 and the other vertices v1 . . . vp 2 are 1. The out degree of vp 1 is 0 vp 2 is 1 and v0 . . . vp 3 is 2. For all k 1

Method examples described herein can be machine or computer implemented at least in part. Some examples can include a computer readable medium or machine readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code such as microcode assembly language code a higher level language code or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further the code may be tangibly stored on one or more volatile or non volatile computer readable media during execution or at other times. These computer readable media may include but are not limited to hard disks removable magnetic disks removable optical disks e.g. compact disks and digital video disks magnetic cassettes memory cards or sticks random access memories RAMs read only memories ROMs and the like.

Thus other embodiments can be realized. For example an article of manufacture such as a computer a memory system a magnetic or optical disk some other storage device or any type of electronic device or system can include one or more processors coupled to a computer readable medium such as a memory e.g. removable storage media as well as any memory including an electrical optical or electromagnetic conductor having instructions stored thereon e.g. computer program instructions which when executed by the one or more processors result in performing any of the actions described with respect to the methods above.

The computer can take the form of a computer system having a processor coupled to a number of components directly and or using a bus . Such components can include main memory static or non volatile memory and mass storage . Other components coupled to the processor can include an output device such as a video display an input device such as a keyboard and a cursor control device such as a mouse. A network interface device to couple the processor and other components to a network can also be coupled to the bus . The instructions can further be transmitted or received over the network via the network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP . Any of these elements coupled to the bus can be absent present singly or present in plural numbers depending on the specific embodiment to be realized.

In an example one or more of the processor the memories or the storage device can each include instructions that when executed can cause the computer to perform any one or more of the methods described herein. In alternative embodiments the computer operates as a standalone device or can be connected e.g. networked to other devices. In a networked environment the computer can operate in the capacity of a server or a client device in server client network environment or as a peer device in a peer to peer or distributed network environment. The computer can include a personal computer PC a tablet PC a set top box STB a Personal Digital Assistant PDA a cellular telephone a web appliance a network router switch or bridge or any device capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that device. Further while only a single computer is illustrated the term computer shall also be taken to include any collection of devices that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The computer can also include an output controller for communicating with peripheral devices using one or more communication protocols e.g. universal serial bus USB IEEE 1394 etc. The output controller can for example provide an image to a programming device that is communicatively coupled to the computer . The programming device can be configured to program a parallel machine e.g. parallel machine FSM engine . In other examples the programming device can be integrated with the computer and coupled to the bus or can communicate with the computer via the network interface device or another device.

While the computer readable medium is shown as a single medium the term computer readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database or associated caches and servers and or a variety of storage media such as the processor registers memories and the storage device that store the one or more sets of instructions . The term computer readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the computer and that cause the computer to perform any one or more of the methodologies of the present invention or that is capable of storing encoding or carrying data structures utilized by or associated with such a set of instructions. The term computer readable medium shall accordingly be taken to include but not be limited to tangible media such as solid state memories optical and magnetic media.

The Abstract is provided to comply with 37 C.F.R. Section 1.72 b requiring an abstract that will allow the reader to ascertain the nature and gist of the technical disclosure. It is submitted with the understanding that it will not be used to limit or interpret the scope or meaning of the claims. The following claims are hereby incorporated into the detailed description with each claim standing on its own as a separate embodiment.

Example 1 includes a computer implemented method including converting a quantification into an automaton wherein converting includes unrolling the quantification to control an in degree of the automaton and converting the automaton into machine code corresponding to a target device.

Example 2 includes a computer readable medium including instructions which when executed by the computer cause the computer to perform operations comprising converting a quantification into an automaton wherein converting includes unrolling the quantification to control an out degree of the automaton and converting the automaton into machine code corresponding to a target device.

Example 3 includes a computer comprising a memory having software stored thereon and a processor communicatively coupled to the memory. The software when executed by the processor causes the processor to convert a quantification into an automaton wherein convert includes unroll the quantification to control an in degree or an out degree of the automaton and convert the automaton into machine code corresponding to a target device.

Example 4 includes a system comprising a computer configured to convert a quantification into an automaton wherein convert includes unrolling the quantification to control an in degree or an out degree of the automaton and convert the automaton into machine code corresponding to a target device.

Example 5 includes a computer implemented method comprising converting a quantification into an automaton wherein converting includes unrolling the quantification to control an out degree of the automaton and converting the automaton into machine code corresponding to a target device.

Example 6 includes a computer readable medium including instructions which when executed by the computer cause the computer to perform operations comprising converting a quantification into an automaton wherein converting includes unrolling the quantification to control an in degree of the automaton and converting the automaton into machine code corresponding to a target device.

In Example 7 the subject matter of any of Examples 1 6 can optionally include parsing an expression into a non language specific representation including the quantification.

In Example 8 the subject matter of any of Examples 1 7 can optionally include wherein parsing an expression into a non language specific representation comprises parsing a regular expression into a syntax tree.

In Example 9 the subject matter of any of Examples 1 8 can optionally include wherein converting includes when a repeated expression for the quantification is nullable unrolling the quantification as a quantification having a non nullable form of the repeated expression that can be matched zero times.

In Example 10 the subject matter of any of Examples 1 9 can optionally include wherein converting the automaton into machine code comprises converting the automaton into an image configured to program a parallel machine.

In Example 11 the subject matter of any one of Examples 1 10 can optionally include publishing the image.

In Example 12 the subject matter of any of Examples 1 11 can optionally include wherein unrolling the quantification to control an in degree of the automaton comprises unrolling the quantification as a function of an in degree limitation.

In Example 13 the subject matter of any of Examples 1 12 can optionally include wherein the in degree limitation includes a limit on the number of transitions into a state of the automaton.

In Example 14 the subject matter of any of Examples 1 13 can optionally include wherein unrolling the quantification to control an in degree of the automaton comprises unrolling based on an in degree constraint of the target device.

In Example 15 the subject matter of any of Examples 1 14 can optionally include wherein the quantification is a regular expression.

In Example 16 the subject matter of any one of Examples 1 15 can optionally include wherein unrolling the quantification to control an in degree of the automaton comprises unrolling the quantification to control an in degree of the automaton based on a threshold.

In Example 17 the subject matter of any of Examples 1 16 can optionally include wherein the threshold is based on a hardware limitation of the parallel machine.

In Example 18 the subject matter of any of Examples 1 17 can optionally include wherein unrolling includes limiting the out transitions for each state of the automaton to below a threshold number.

In Example 19 the subject matter of any of Examples 1 18 can optionally include wherein unrolling includes minimizing out transitions for each state of the automaton.

In Example 20 the subject matter of any of Examples 1 19 can optionally include wherein converting includes when a repeated expression for the quantification is nullable unrolling the quantification as a quantification having a non nullable form of the repeated expression that can be matched zero times.

In Example 21 the subject matter of any of Examples 1 20 can optionally include wherein converting includes when the quantification can be matched with a single number of loops unrolling the quantification to form an automaton having states representing a number of expressions equal to the single number linked in series wherein the expressions correspond to a repeated expression for the quantification.

In Example 22 the subject matter of any of Examples 1 21 can optionally include wherein when the quantification can be matched with a multiple number of loops the multiple number of loops including a first number of loops n1 and a second number of loops n2 unrolling the quantification includes splitting the quantification into a first quantification that can be matched with the n1 1 number of loops and a second quantification that can be matched with from one to a n2 n1 1 number of loops.

In Example 23 the subject matter of any of Examples 1 22 can optionally include loading the image onto a parallel machine.

In Example 24 the subject matter of any of Examples 1 23 can optionally include storing the image on a computer readable medium.

In Example 25 the subject matter of any of Examples 1 24 can optionally include controlling the in degree and out degree by trading off in transitions for out transitions in the automaton.

In Example 26 the subject matter of any of Examples 1 25 can optionally include wherein the in transitions for each state are limited to below a threshold number when unrolling.

In Example 27 the subject matter of any of Examples 1 26 can optionally include wherein the in degree is limited to a ratio of the out degree.

In Example 28 the subject matter of any of Examples 1 27 can optionally include wherein the in degree is limited to the ratio of the out degree until a threshold of in transitions are reached for a state of the automaton.

In Example 29 the subject matter of any of Examples 1 28 can optionally include wherein the machine code comprises an image configured to program a parallel machine and further comprising a device communicatively coupled to the computer and configured to load the image onto a parallel machine.

In Example 30 the subject matter of any of Examples 1 29 can optionally include wherein unrolling the quantification to control an in degree of the automaton comprises unrolling the quantification as a function of an in degree limitation.

In Example 31 the subject matter of any of Examples 1 30 can optionally include wherein the in degree limitation includes a limit on the number of transitions into a state of the automaton.

In Example 32 the subject matter of any of Examples 1 31 can optionally include wherein unrolling the quantification to control an in degree of the automaton comprises unrolling based on an in degree constraint of the target device.

In Example 33 the subject matter of any of Examples 1 32 can optionally include wherein unrolling the quantification to control an in degree of the automaton comprises unrolling the quantification to control an in degree of the automaton based on a threshold.

In Example 34 the subject matter of any of Examples 1 33 can optionally include wherein the threshold is based on a hardware limitation of the parallel machine.

In Example 35 the subject matter of any of Examples 1 34 can optionally include parsing a regular expression into a syntax tree.

In Example 36 the subject matter of any of Examples 1 35 can optionally include wherein converting the automaton into machine code comprises converting the automaton into an image configured to program a parallel machine.

In Example 37 the subject matter of any one of Examples 1 36 can optionally include publishing the image.

In Example 38 the subject matter of any of Examples 1 37 can optionally include wherein unrolling the quantification to control an out degree of the automaton comprises unrolling the quantification as a function of an out degree limitation.

In Example 39 the subject matter of any of Examples 1 38 can optionally include wherein the out degree limitation includes a limit on the number of transitions out of a state of the automaton.

In Example 40 the subject matter of any of Examples 1 39 can optionally include wherein unrolling the quantification to control an out degree of the automaton comprises unrolling based on an out degree constraint of the target device.

In Example 41 the subject matter of any of Examples 1 40 can optionally include wherein unrolling the quantification to control an out degree of the automaton comprises unrolling the quantification to control an out degree of the automaton based on a threshold.

In Example 42 the subject matter of any of Examples 1 41 can optionally include wherein the threshold is based on a hardware limitation of the parallel machine.

In Example 43 the subject matter of any of Examples 1 42 can optionally include wherein unrolling includes limiting the in transitions for each state of the automaton to below a threshold number.

In Example 44 the subject matter of any of Examples 1 43 can optionally include wherein unrolling includes minimizing in transitions for each state of the automaton.

In Example 45 the subject matter of any of Examples 1 44 can optionally include wherein converting includes when a repeated expression for the quantification is nullable unrolling the quantification as a quantification having a non nullable form of the repeated expression that can be matched zero times.

In Example 46 the subject matter of any of Examples 1 45 can optionally include wherein converting includes when the quantification can be matched with a single number of loops unrolling the quantification to form an automaton having states representing a number of expressions equal to the single number linked in series wherein the expressions correspond to a repeated expression for the quantification.

In Example 47 the subject matter of any of Examples 1 46 can optionally include wherein when the quantification can be matched with a multiple number of loops the multiple number of loops including a first number of loops n1 and a second number of loops n2 unrolling the quantification includes splitting the quantification into a first quantification that can be matched with the n1 1 number of loops and a second quantification that can be matched with from one to a n2 n1 1 number of loops.

Example 48 includes a parallel machine programmed by an image produced using the subject matter of any of Examples 1 47.

