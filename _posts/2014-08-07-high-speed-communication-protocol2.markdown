---

title: High speed communication protocol
abstract: The present disclosure involves systems, software, and computer implemented methods for providing high speed communication between a sending system and a receiving system. One computer-implemented method includes determining, by a computer, that data is available for serialization using a pointer transfer; getting a data block of the data from a memory; getting metadata corresponding to the data block; writing an original address of the data block to a transport layer; writing the data block to the transport layer; determining that the data corresponding to the data block contains pointers; and adding a referenced data block to one or more data blocks to be transferred to a receiving system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09560136&OS=09560136&RS=09560136
owner: SAP SE
number: 09560136
owner_city: Walldorf
owner_country: DE
publication_date: 20140807
---
The present disclosure relates to computer implemented methods software and systems for providing high speed communication between a sending system and a receiving system.

A computing system can communicate with one or more other computing systems over a network. Communication components associated with the computing system and or the network can be grouped according to layers. For example layers can include application presentation session transport network data link and physical layers. Each layer can be associated with one or more functions. For example the application layer can interact with software applications that implement a communicating component and the transport layer can provide the functional and procedural means of transferring variable length data sequences from a source to a destination host via one or more networks while maintaining the quality of service functions. In general a given layer can provide one or more services to a layer above the given layer and can consume one or more services provided by a layer below the given layer.

The present disclosure involves systems software and computer implemented methods for sending data from a sending system to a receiving system. One computer implemented method includes starting a process by operation of computer the process missing actual data required for the process to complete creating a proxy data object as a substitute for the actual data to allow the process to execute executing the process using the proxy data object until the actual data is required for the process to continue execution replacing the proxy data object with the actual data and continuing to execute the process with the actual data.

While generally described as computer implemented software embodied on tangible media that processes and transforms the respective data some or all of the aspects may be computer implemented methods or further included in respective systems or other devices for performing this described functionality. The details of these and other aspects and embodiments of the present disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

Other implementations of this aspect include corresponding computer systems apparatuses and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods. A system of one or more computers can be configured to perform particular operations or actions by virtue of having software firmware hardware or a combination of software firmware or hardware installed on the system that in operation causes or causes the system to perform the actions. One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that when executed by data processing apparatus cause the apparatus to perform the actions.

The foregoing and other implementations can each optionally include one or more of the following features alone or in combination 

A first aspect combinable with the general implementation wherein writing the data to the transport layer comprises adapting the data corresponding to the data block to requirements of a receiving system.

A second aspect combinable with any of the previous aspects comprising determining whether data is available upon a determination that the data corresponding to the data block does not contain pointers.

A third aspect combinable with any of the previous aspects comprising receiving the one or more data blocks to be transferred.

A fourth aspect combinable with any of the previous aspects comprising determining by a computer that data is available in the one or more data blocks getting a data block corresponding to the data from the transport layer getting the metadata corresponding to the data block and writing the data corresponding to the data block to a memory area of the receiving system.

A fifth aspect combinable with any of the previous aspects comprising determining by a computer that an unadapted pointer is available getting an original pointer value finding a data block where an original address equals the original pointer value and changing the unadapted pointer value to the address of the found data block.

A sixth aspect combinable with any of the previous aspects wherein the metadata contains information about a memory layout of the data and data type information including code page floating point formats and decimal places.

A seventh aspect combinable with any of the previous aspects wherein one or more of the pointers are indirect pointers the one or more indirect pointers each linked by zero or more other indirect pointers to a direct pointer that refers to a data block.

An eighth aspect combinable with any of the previous aspects wherein the metadata is transferred to the receiving system.

The subject matter described in this specification can be implemented in particular implementations so as to realize one or more of the following advantages. Data can be sent from a sending system to a receiving system without repeatedly sending metadata describing the data to be sent thus increasing transmission speed and reducing transmission payload. Data including one or more pointers can be sent from a sending system to a receiving system and the pointer associated data can be adapted on the receiving system. Other advantages will be apparent to those skilled in the art.

The details of one or more implementations of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the subject matter will become apparent from the description the drawings and the claims.

Communication protocols can be designed for data transfer between communication partners that may have different hardware different data representations and other differences. When using these communication protocols data can be transformed by a sending system from a source format to a common intermediate format before being sent. The intermediate format can be for example XML eXtensible Markup Language JSON JavaScript Object Notation or some other format. The data in the intermediate format can be sent from the sending system to a receiving system. The receiving system can transform the data in the intermediate format to data in a target format before the data is stored or otherwise used on the receiving system. Such transformation results in additional processing and transmission time. Additionally the intermediate format generally includes metadata which describes each item of data that is being transferred. The metadata increases the size of the data that is transferred e.g. the size of the data in the intermediate format is generally larger than the size of the data in the source format .

Some communication partners are homogeneous in that data used on the sending system is in a same format as data that is used on a receiving system. Such communication partners may communicate using repeated same or similar messages. For such types of communication a high speed communication protocol can be used in which an initial set of metadata is communicated between the communication partners and is only re transferred when necessary. Data can be transferred in a compact binary form over a long lasting connection. When possible data can be sent without any transformation. In certain cases data may be transformed when necessary. The high speed communication protocol can provide the fast transfer advantages of a binary bus like transfer along with some transformation features such as mapping of data types and code pages and adaption of pointers.

An application executing on the sending system can be configured to send data to an application executing on the receiving system . In some implementations the sending system is a client computing device the application is a client application the receiving system is a server computing device and the application is a server application. In some implementations the sending system is a server computing device the application is a server application the receiving device is a client computing device and the application is a client application. In some implementations both the sending system and the receiving system are server computing devices and both the application and the application are server applications.

The sending system e.g. the application can for example invoke a service or remote procedure call implemented by the receiving system and can transfer data from the memory to the receiving system . The receiving system can send a result of the call back to the sending system . An asynchronous service call can be invoked in which data is transferred from the sending system to the receiving system with the call being a non blocking call which returns to the sending system before the servicing of the asynchronous service call is finished. The asynchronous call can include a unique identifier associated with the invocation. A response and service call result which includes the unique identifier can be sent later asynchronously from the receiving system to the sending system after the servicing of the service call has completed.

The application can be configured to repeatedly generate a service message of the same type that is repeatedly sent to the application . Using a communication protocol in which the same metadata is repeatedly sent can be inefficient and unnecessary e.g. the same metadata may be unnecessarily transferred multiple times . The application can instead be configured to use a high speed communication protocol in which metadata on the sending system is sent once e.g. initially for a communication process or service and is only resent when necessary such as when a change occurs in the format of data to be sent from the sending system to the receiving system .

A data sending component can include a timestamp or some other identifier that uniquely identifies a version and data structure s associated with the service associated with the metadata when sending the metadata to the receiving system . A data receiving component can store the received metadata as metadata in memory along with the timestamp. The data sending component can include the timestamp associated with the metadata in each communication sent to the receiving system . The data receiving component can compare the received timestamp to a stored timestamp to determine whether the stored metadata is current. For example when the metadata changes the data sending component can generate a new timestamp associated with the updated metadata and can send the new timestamp in subsequent communications. The data receiving component can detect that the received timestamp is different than the stored timestamp and can send a request to the sending system to send updated metadata. As another example the sending system can send the updated metadata to the receiving system upon an update to the metadata .

The metadata can include information about a memory layout of data to be sent in memory of the sending system . For example the metadata can include data type information including code page floating point formats endianness of data big endian or little endian and decimal place information for the data to be sent . The metadata can also include information about one or more pointers that are included in the data to be sent . A pointer in the data to be sent can refer to another block of data such as a block of data that is included in the data to be sent or to another block of data that is included in another area of memory e.g. represented by referenced data . A block of data in the referenced data can also include one or more pointers such as to another block of referenced data .

In some implementations the metadata is sent from the sending system and stored as metadata on the receiving system. In some implementations metadata is exchanged between systems. That is in addition to the metadata being sent to the receiving system metadata e.g. metadata can be sent from the receiving system to the sending system which describes a memory layout for received data on the receiving system . A timestamp associated with the metadata exchange can be stored on each system in association with the respective exchanged metadata. The timestamp can be included with future communications sent between the sending system and the receiving system and can be evaluated to determine whether the exchanged metadata is current.

In some implementations one set of metadata is sent to or exchanged with the receiving system . In some implementations multiple sets of metadata are sent or exchanged between the receiving system and the sending system . For example the sending system and the receiving system may communicate using a set of several service calls. A set of metadata can be sent or exchanged for each service call included in the set of service calls.

The data sending component can when sending the data to be sent copy the data to be sent directly from the memory to a transport layer used by the interface . That is a binary representation of data stored in the memory can be directly copied from the memory to the transport layer. Such copying of binary data can save time and space and can prevent data loss as compared to sending non binary data. For example some communication protocols send data as text with binary data in memory being copied to text values before being sent. Such transformations take time and generally increase the amount of data to be sent. Additionally data can be lost such as when transforming a floating point number to a representation including a set of decimal characters.

In some implementations and for some sets of data the data sending component can transform or otherwise process some of the data to be sent on the sending system before the data is sent to the receiving system . For example when the sending system uses a longer character representation e.g. UTF16 Unicode Transformation Format 16 bit than the receiving system e.g. ASCII American Standard Code for Information Interchange 8 bit characters can be transformed on the sending system before sending to reduce the size of the transferred data. Other data transformations can be performed such as when the sending system uses a data type that is not supported on the receiving system . The data sending component can transform data to a data type that is supported by the receiving system before data is sent.

Other processing before sending is possible. For example data that is not needed on the receiving system can be excluded from being transferred. For example when a structure in the data to be sent has more fields than a structure in a received data area of the memory on the receiving system data in the fields that are included in the data to be sent but not in the received data area can be excluded from data sent to the receiving system .

The data sending component can perform processing related to pointers that are included in the data to be sent . For example the data sending component can detect both direct and indirect pointers in the data to be sent and can write associated address information to the transport layer along with referenced data that is referred to either directly or indirectly by the detected pointer s . As described in more detail below the data sending component can process pointers using either a pointer transfer process or an inlining process. A direct pointer is a memory address which points to some other data. An indirect pointer is for example a memory address that points to some other memory address with the other memory address being an address of some other data. An indirect pointer can have more than one level of indirection. For example a first indirect pointer can point to a second indirect pointer and the second indirect pointer can point to a third pointer the third pointer being a direct pointer which points at some other data.

The data receiving component can using the interface receive data sent from the sending system . The data receiving component can copy data from a transport layer associated with the interface directly to the received data area . As discussed above when transformation of data is needed such transformations are generally performed on the sending system before the data is sent. However when necessary the data receiving component may transform some data before or after copying data from the transport layer to the received data area .

For example received pointer related data can be processed by the data receiving component . The data receiving component can adapt one or more pointers to include a memory address associated with the memory e.g. such a pointer may have included a value associated with the memory when the pointer data was sent . When needed the data receiving component can allocate memory for received data in the received data area and or in one or more referenced data areas . As described in more detail below adaption of pointers can be performed for data received from a pointer transfer process or an inlining process.

As used in the present disclosure the term computer is intended to encompass any suitable processing device. For example although illustrates a single sending system and a single receiving system the system can be implemented using two or more sending systems or two or more receiving systems . Indeed the sending system and the receiving system may be any computer or processing device such as for example a blade server general purpose personal computer PC Mac workstation UNIX based workstation or any other suitable device. In other words the present disclosure contemplates computers other than general purpose computers as well as computers without conventional operating systems. Further the sending system and the receiving system may be adapted to execute any operating system including Linux UNIX Windows Mac OS Java Android iOS or any other suitable operating system. According to one implementation the sending system and or the receiving system may also include or be communicably coupled with an e mail server a Web server a caching server a streaming data server and or other suitable server.

Generally the interfaces and each comprise logic encoded in software and or hardware in a suitable combination and operable to communicate with the network . More specifically the interfaces and may each comprise software supporting one or more communication protocols associated with communications such that the network or interface s hardware is operable to communicate physical signals within and outside of the illustrated system .

The sending system includes one or more processors . Similarly the receiving system includes one or more processors . Each processor or may be a central processing unit CPU a blade an application specific integrated circuit ASIC a field programmable gate array FPGA or another suitable component. Generally each processor or executes instructions and manipulates data to perform the operations of the sending system or the receiving system respectively. Specifically each processor executes the functionality required to send data to the receiving system and each processor executes the functionality to process data received from the sending system .

Regardless of the particular implementation software may include computer readable instructions firmware wired and or programmed hardware or any combination thereof on a tangible medium transitory or non transitory as appropriate operable when executed to perform at least the processes and operations described herein. Indeed each software component may be fully or partially written or described in any appropriate computer language including C C Java JavaScript Visual Basic assembler Perl any suitable version of 4GL as well as others. While portions of the software illustrated in are shown as individual modules that implement the various features and functionality through various objects methods or other processes the software may instead include a number of sub modules third party services components libraries and such as appropriate. Conversely the features and functionality of various components can be combined into single components as appropriate.

As mentioned the sending system includes the memory and the receiving system includes the memory . In some implementations sending system and or the receiving system include multiple memories. The memory and the memory may each include any type of memory or database module and may take the form of volatile and or non volatile memory including without limitation magnetic media optical media random access memory RAM read only memory ROM removable media or any other suitable local or remote memory component. The memory and the memory may each store various objects or data including caches classes frameworks applications backup data business objects jobs web pages web page templates database tables database queries repositories storing business and or dynamic information metadata pointers and any other appropriate information including any parameters variables algorithms instructions rules constraints or references thereto associated with the purposes of the sending system or the receiving system respectively.

The sending system may generally be any computing device operable to connect to or communicate with the receiving system via the network using a wireline or wireless connection. In general the sending system comprises an electronic computer device operable to receive transmit process and store any appropriate data associated with the system of . The sending system can include one or more client applications including the application . The sending system can include one or more client applications. A client application is any type of application that allows the sending system to request and view content on the sending system . In some implementations a client application can use parameters metadata and other information received at launch to access a particular set of data from the receiving system . In some instances a client application may be an agent or client side version of the one or more enterprise applications running on an enterprise server not shown .

The sending system can be as mentioned a server device. As another example the sending system can be a client device. A client device is generally intended to encompass any client computing device such as a laptop notebook computer wireless data port smart phone personal data assistant PDA tablet computing device one or more processors within these devices or any other suitable processing device. For example a client device comprises a computer that includes an input device such as a keypad touch screen or other device that can accept user information and an output device that conveys information associated with the operation of the receiving system or the client device itself including digital data visual information or a graphical user interface GUI not shown .

A GUI of a client device can interface with at least a portion of the system for any suitable purpose including generating a visual representation of the application . In particular the GUI may be used to view and navigate various Web pages. Generally the GUI provides the user with an efficient and user friendly presentation of business data provided by or communicated within the system. The GUI may comprise a plurality of customizable frames or views having interactive fields pull down lists and buttons operated by the user. The GUI contemplates any suitable graphical user interface such as a combination of a generic web browser intelligent engine and command line interface CLI that processes information and efficiently presents the results to the user visually.

The term client client device and user may be used interchangeably as appropriate without departing from the scope of this disclosure. While a client device can be described in terms of being used by a single user this disclosure contemplates that many users may use one computer or that one user may use multiple computers.

At a determination is made as to whether data is available for serialization using a pointer transfer.

When data is available for serialization a first block of data is retrieved from a memory at . For example the memory can be a memory area of a sending system.

At corresponding metadata is retrieved. For example a size and data type of the first data block can be retrieved. In some implementations step is performed before step e.g. metadata for the first data block may be retrieved before the first data block is retrieved .

At an original address of the first data block is optionally written to a transport layer. In some implementations the original address of the first data block to be transferred is not written to the transport layer but original addresses of other data blocks processed at step e.g. via recursion as described below may be written to the transport layer.

When the data block contains one or more pointers one or more referenced data blocks are added at to one or more data blocks to be transferred to a receiving system.

After the referenced data block s are added or when the first data block does not contain pointers a determination is made as to whether additional data is available e.g. at . When additional data is available processing continues for the additional data e.g. for a next data block as described above for steps . When no additional data is available method stops.

At a determination is made as to whether data is available. For example a determination can be made as to whether data has been received from a sending system pointer transfer process.

When data is available a first data block of the available data is retrieved at from a transport layer.

At metadata corresponding to the first data block and or to the data expected from the pointer transfer process is retrieved. The metadata can be evaluated for example to identify a receiving system memory layout corresponding to the pointer transfer. The receiving system memory layout can specify for example data type information including the location in the memory layout of zero or more pointer fields. In some implementations step is performed before step e.g. metadata for the first data block may be retrieved before the first data block is retrieved .

At the data corresponding to the first data block is written to a memory area. For example the data can be written to a receiving system memory area. When the first data block includes one or more pointers a memory area can be allocated for each of the one or more pointers with the size of an allocated memory area being determined from the retrieved metadata. The addresses of the allocated memory areas can be stored in association with the metadata.

After the data corresponding to the first data block is written to the memory area a determination is made as to whether additional data is available e.g. at . When additional data is available processing continues for the additional data e.g. for one or more next data blocks as described above for steps and for the first data block.

For example a next data block can be retrieved from the transport layer at . Metadata corresponding to the next data block can be retrieved at . The data of the next data block can be written to the receiver system memory at step . When metadata corresponding to the next data block indicates that the next data block is a referenced data block the next data block can be written to an allocated memory area that corresponds to the next data block. The address of the allocated memory area can be stored in metadata that is associated with the next data block.

When additional data is not available e.g. at a determination is made at as to whether a first unadapted pointer is available. For example a determination can be made whether a first unadapted pointer is included in data written to the receiving system memory area.

When a first unadapted pointer is available a first original pointer value associated with the first unadapted pointer is retrieved at . The location of the first original pointer value within the memory area can be determined for example based on the retrieved metadata. The first original pointer value can be a value for example that was received from the transport layer.

At a data block is found for which a first original address value equals the first original pointer value. For example the first original address value can be or can be included in metadata associated with a first referenced data block included in data received from the transport layer.

At the first unadapted pointer value is changed to the address of the found data block. The address of the found block can be determined for example based on an address of a previously created memory area that is stored in metadata.

After the first unadapted pointer value is changed a determination is made e.g. at as to whether an additional unadapted pointer is available. When an additional unadapted pointer is not available the method stops. When an additional unadapted pointer is available processing continues for the additional unadapted pointer e.g. a next unadapted pointer as described above for steps and for the first unadapted pointer.

As part of generating the data block the sending system can access the data block access metadata corresponding to the data block e.g. to identify layout information associated with the data block and write the data from the data block to a communications transport layer e.g. as illustrated by a portion of the data block .

The sending system can determine that data in the data block includes pointers e.g. the first direct pointer and the indirect pointer . The sending system can in response to identifying a pointer write a referenced data block to the transport layer. For example the data block includes a first referenced data block that corresponds to the first referenced data block referred to by the first direct pointer and a second referenced data block that corresponds to the second referenced data block that is indirectly referred to by the indirect pointer .

In some implementations one or more pointer values are written to the transport layer before a referenced data block is written to the transport layer. For example the data block includes before the first referenced data block a pointer value that is the original address of the first referenced data block and is the value of the first direct pointer . As another example the data block includes before the second referenced data block a direct pointer value and an indirect pointer value . The direct pointer value corresponds to the address of the second referenced data block and to the value of the second direct pointer . As mentioned the second referenced data block corresponds to the second referenced data block . The indirect pointer value corresponds to the indirect pointer . The indirect pointer value the pointer value the direct pointer value the first referenced data block and the second referenced data block can be referenced in a pointer adaption process performed by a receiving system as described in more detail below.

The receiving system can identify the pointer value in the received data block and in response to identifying the pointer value can allocate a memory area of the size of the first referenced data block on the receiving system. The receiving system can write the contents of the first referenced data block to the memory area . The receiving system can adapt the first direct pointer to include the address of the allocated memory area e.g. an address value of 0x400 .

The receiving system can identify the indirect pointer value and the direct pointer value in the received data block . In response to identifying the indirect pointer value the receiving system can allocate a pointer memory area on the receiving system of the size of a receiving system memory address. In response to identifying the direct pointer value the receiving system can allocate a memory area of the size of the second referenced data block . The receiving system can write the contents of the second referenced data block to the memory area . The receiving system can copy the address of the memory area e.g. an address value of 0x300 to the pointer memory area . The receiving system can adapt the indirect pointer to include the address of the pointer memory area e.g. an address value of 0x250 .

At a determination is made as to whether data is available for serialization using an inlining transfer.

At corresponding metadata is retrieved. In some implementations step is performed before step e.g. metadata for the first data block may be retrieved before the first data block is retrieved from the sender area in memory .

At a first portion of the first data block is written to the transport layer starting at the beginning of the first data block and ending at a position corresponding to a found pointer value or ending when the end of the first data block is reached.

At a determination is made as to whether a pointer is available e.g. whether a pointer value was encountered in step . When a pointer value is not available method continues at to determine whether additional data is available in the sender memory area. When additional data is available method continues at to process the additional data as described above. When additional data is not available method either ends at or returns to the processing of an enclosing data block in a case of recursion. A recursion example is described below.

For example when a pointer is available e.g. at a determination is made at to recursively restart the method using sub data as the sender area in memory. For example the method can be restarted using the sender memory area that is referenced by the pointer encountered in step . Of note is that the value of the pointer is not written to the transport layer using the inlining transfer. When the processing for each sub data portion of a data block and each sub data portion of a sub data portion to possibly various levels is completed process continues for the data block at . At a next portion of the data block is retrieved from the transport layer the next portion beginning at a position in the data block immediately after the last found pointer and ending at either a position corresponding to a next found pointer or the end of the next data block. Method continues for the next portion of the data block at .

At a determination is made as to whether data is available. For example a determination can be made as to whether data has been received from a sending system inline transfer process.

When data is available a first data block corresponding to the available data is retrieved at from a transport layer.

At metadata corresponding to the first data block and or to the data expected from the inline transfer process is retrieved. The metadata can be evaluated for example to identify a receiving system memory layout corresponding to the inline transfer. The receiving system memory layout can specify for example data type information including the location in the memory layout of zero or more pointer fields.

At the data corresponding to the first data block is written to a receiving system memory area. In some implementations the receiving system memory area is preallocated. When the receiving system memory is preallocated and the first data block does not include any pointers the data from the first data block can be written to the receiving system memory area until the end of the first data block is reached. When the receiving system memory area is preallocated and the first data block includes one or more pointers a first portion of data from the first data block can be written to the receiving system memory area the first portion beginning at the start of the first data block and ending at the location of the first pointer included in the first data block.

When the receiving system memory area is not preallocated and when the first data block does not include pointers a memory area equal to the size of the first data block can be allocated and the data of the first data block can be written to the newly allocated memory area. When the receiving system memory area is not preallocated and when the first data block includes at least one pointer a memory area equal to the size of the first data block can be allocated and a portion of data from the first data block can be written to the newly allocated memory area the portion beginning at the start of the first data block and ending at the location of the first pointer included in the first data block.

At a determination is made as to whether a pointer is available e.g. whether the first data block includes at least one pointer . When a pointer is not available method continues at to determine whether additional received data is available. When additional received data is available method continues at to process the next data block as described above for the first data block. When additional received data is not available method either ends at or returns to the processing of an enclosing data block in a case of recursion. A recursion example is described below.

For example when a pointer is available e.g. at a determination can be made at to recursively restart the method using sub data. For example at a determination can be made that additional received data is available the additional received data corresponding to a first referenced data block. At data of the size of the first referenced data block can be retrieved from the transport layer. At metadata associated with the first referenced data block can be retrieved. The metadata can indicate for example the size and data type of the first referenced data block. In some implementations metadata is retrieved before corresponding data is retrieved from the transport layer. The first referenced data block can include only non pointer data or can include one or more pointers.

At data from the transport layer corresponding to the first referenced data block can be written to a receiving system memory area. When the receiving system memory area is not preallocated a receiving system memory area of the size of the first referenced data block can be allocated and the data from the transport layer can be written to the newly allocated memory area. In this example a pointer value that is located in the receiving system memory adjacent to e.g. immediately following the first portion of the first data block can be updated to include the value of the newly allocated memory area that includes the data of the first referenced data block. When the first referenced data block also includes one or more pointers a determination can be made as such at and processing for a data block referenced by a pointer included in the first referenced data block can be performed e.g. at etc. .

Similar processing e.g. recursion can be performed when the receiving system memory layout includes multiple levels of indirection using multiple pointers. When all processing related to the first portion of the first data block and the first referenced data block is completed processing can continue for a second portion of the first data block at . For example the second portion of the first data block can begin at a location in the first data block that begins after the first pointer and up to either the end of the first data block when the first data block does not include any additional pointers or to the next e.g. second pointer included in the first data block.

The inlined data block does not include the values of the first direct pointer the indirect pointer or the second direct pointer . Rather the receiving system inlines data and the inlining process includes referenced data in the inlined data block without including values of associated pointers that refer to the referenced data. The inlining process can for example retrieve the data block from the sending system memory area and write data from the data block to the transport layer starting from the beginning of the data block until the inlining process encounters a pointer value e.g. the first direct pointer e.g. as illustrated by the inclusion of the first data portion in the inlined data block .

The inlining process can process the data referenced by the first direct pointer e.g. the first referenced data block . The inlining process can write data from the first referenced data block to the transport layer e.g. as illustrated by the inclusion of the first referenced data block in the inlined data block starting from the beginning of the first referenced data block until either a pointer or the end of the first referenced data block is reached e.g. the end of the first referenced data block being reached in this example .

The inlining process can continue processing the data block and can write data to the transport layer starting from the start of the second data portion until a pointer value e.g. the indirect pointer is encountered e.g. as illustrated by the inclusion of the second data portion in the inlined data block . The inlining process can process the data referenced by the indirect pointer e.g. the second direct pointer . Since the data referenced by the indirect pointer is a pointer the inlining process can process the data referenced by the second direct pointer e.g. the second referenced data block . The inlining process can write data from the second referenced data block to the transport layer e.g. as illustrated by the inclusion of the second referenced data block in the inlined data block starting from the beginning of the second referenced data block until either a pointer or the end of the second referenced data block is reached e.g. the end of the second referenced data block being reached in this example . The inlining process can continue processing the data block and can write data to the transport layer e.g. as illustrated by the inclusion of the third data portion in the inlined data block starting from the start of the third data portion until the end of the third data portion is reached.

The receiving system can retrieve metadata associated with the inlined data block and or metadata associated with the data block . In some implementations the receiving system allocates memory for the data block in response to receiving the inlined data block . In some implementations the data block already exists in memory when the inlined data block is received. The receiving system can retrieve the first data portion from the inlined data block and write the contents of the first data portion to the first data portion of the receiving system memory area .

The receiving system can determine from the retrieved metadata that the data block is to include a pointer value in the first direct pointer which points to an allocated memory area that is the size of the first referenced data block . The receiving system can allocate a memory block e.g. the first referenced data block equal to the size of the first referenced data block set the value of the first direct pointer equal to the address of the first referenced data block and write the contents of the first referenced data block to the first referenced data block .

In some implementations when the inlined data block is received the data block and the first referenced data block already exist in receiving system memory and the first direct pointer already includes the address of the first referenced data block . In this example the receiving system can write the contents of the first referenced data block to the first referenced data block without allocating additional memory and without updating the first direct pointer .

The receiving system can write the contents of the second data portion to the second data portion and can write the contents of the third data portion to the third data portion . The receiving system can determine from the retrieved metadata that the data block is to include a pointer value in the indirect pointer which points to another pointer value. In implementations in which receiving system memory for the inlined data block is not pre allocated the receiving system can allocate a memory area e.g. the second direct pointer equal to the size of a receiving system memory address. The receiving system can set the value of the indirect pointer equal to the address of the second direct pointer e.g. an address value of 0x250 .

The receiving system can determine from the retrieved metadata that the second direct pointer is to point to a memory area of the size of the second referenced data block . In implementations in which receiving system memory for the inlined data block is not preallocated the receiving system can allocate a memory area e.g. the second referenced data block and can set the value of the second direct pointer to the address e.g. an address value of 0x300 of the second referenced data block . In implementations in which receiving system memory for the inlined data block is preallocated the receiving system can write the contents of the second referenced data block to the second referenced data block without allocating memory for the second referenced data block or the second direct pointer and without updating the indirect pointer or the second direct pointer .

The preceding figures and accompanying description illustrate example processes and computer implementable techniques. But system or its software or other components contemplates using implementing or executing any suitable technique for performing these and other tasks. It will be understood that these processes are for illustration purposes only and that the described or similar techniques may be performed at any appropriate time including concurrently individually or in combination. In addition many of the operations in these processes may take place simultaneously concurrently and or in different orders than as shown. Moreover system may use processes with additional operations fewer operations and or different operations so long as the methods remain appropriate.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry in tangibly embodied computer software or firmware in computer hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Implementations of the subject matter described in this specification can be implemented as one or more computer programs i.e. one or more modules of computer program instructions encoded on a tangible non transitory computer storage medium for execution by or to control the operation of data processing apparatus. Alternatively or in addition the program instructions can be encoded on an artificially generated propagated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine readable storage device a machine readable storage substrate a random or serial access memory device or a combination of one or more of them.

The term data processing apparatus refers to data processing hardware and encompasses all kinds of apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can also be or further include special purpose logic circuitry e.g. a central processing unit CPU a FPGA field programmable gate array or an ASIC application specific integrated circuit . In some implementations the data processing apparatus and or special purpose logic circuitry may be hardware based and or software based. The apparatus can optionally include code that creates an execution environment for computer programs e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. The present disclosure contemplates the use of data processing apparatuses with or without conventional operating systems for example LINUX UNIX WINDOWS MAC OS ANDROID IOS or any other suitable conventional operating system.

A computer program which may also be referred to or described as a program software a software application a module a software module a script or code can be written in any form of programming language including compiled or interpreted languages or declarative or procedural languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program may but need not correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network. While portions of the programs illustrated in the various figures are shown as individual modules that implement the various features and functionality through various objects methods or other processes the programs may instead include a number of sub modules third party services components libraries and such as appropriate. Conversely the features and functionality of various components can be combined into single components as appropriate.

The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. a CPU a FPGA or an ASIC.

Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors both or any other kind of CPU. Generally a CPU will receive instructions and data from a read only memory ROM or a random access memory RAM or both. The essential elements of a computer are a CPU for performing or executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio or video player a game console a global positioning system GPS receiver or a portable storage device e.g. a universal serial bus USB flash drive to name just a few.

Computer readable media transitory or non transitory as appropriate suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM DVD R DVD RAM and DVD ROM disks. The memory may store various objects or data including caches classes frameworks applications backup data jobs web pages web page templates database tables repositories storing business and or dynamic information and any other appropriate information including any parameters variables algorithms instructions rules constraints or references thereto. Additionally the memory may include any other appropriate data such as logs policies security or access data reporting files as well as others. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube LCD liquid crystal display LED Light Emitting Diode or plasma monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse trackball or trackpad by which the user can provide input to the computer. Input may also be provided to the computer using a touchscreen such as a tablet computer surface with pressure sensitivity a multi touch screen using capacitive or electric sensing or other type of touchscreen. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

The term graphical user interface or GUI may be used in the singular or the plural to describe one or more graphical user interfaces and each of the displays of a particular graphical user interface. Therefore a GUI may represent any graphical user interface including but not limited to a web browser a touch screen or a command line interface CLI that processes information and efficiently presents the information results to the user. In general a GUI may include a plurality of user interface UI elements some or all associated with a web browser such as interactive fields pull down lists and buttons operable by the business suite user. These and other UI elements may be related to or represent the functions of the web browser.

Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of wireline and or wireless digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN a radio access network RAN a metropolitan area network MAN a wide area network WAN Worldwide Interoperability for Microwave Access WIMAX a wireless local area network WLAN using for example 802.11a b g n and or 802.20 all or a portion of the Internet and or any other communication system or systems at one or more locations. The network may communicate with for example Internet Protocol IP packets Frame Relay frames Asynchronous Transfer Mode ATM cells voice video data and or other suitable information between network addresses.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

In some implementations any or all of the components of the computing system both hardware and or software may interface with each other and or the interface using an application programming interface API and or a service layer. The API may include specifications for routines data structures and object classes. The API may be either computer language independent or dependent and refer to a complete interface a single function or even a set of APIs. The service layer provides software services to the computing system. The functionality of the various components of the computing system may be accessible for all service consumers via this service layer. Software services provide reusable defined business functionalities through a defined interface. For example the interface may be software written in JAVA C or other suitable language providing data in extensible markup language XML format or other suitable format. The API and or service layer may be an integral and or a stand alone component in relation to other components of the computing system. Moreover any or all parts of the service layer may be implemented as child or sub modules of another software module enterprise application or hardware module without departing from the scope of this disclosure.

While this specification contains many specific implementation details these should not be construed as limitations on the scope of any invention or on the scope of what may be claimed but rather as descriptions of features that may be specific to particular implementations of particular inventions. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub combination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a sub combination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation and or integration of various system modules and components in the implementations described above should not be understood as requiring such separation and or integration in all implementations and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Particular implementations of the subject matter have been described. Other implementations alterations and permutations of the described implementations are within the scope of the following claims as will be apparent to those skilled in the art. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

Accordingly the above description of example implementations does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure.

