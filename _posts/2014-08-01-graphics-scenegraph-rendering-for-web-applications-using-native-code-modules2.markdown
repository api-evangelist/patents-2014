---

title: Graphics scenegraph rendering for web applications using native code modules
abstract: One embodiment provides a system that facilitates the execution of a web application. During operation, the system loads a native code module that includes a scenegraph renderer into a secure runtime environment. Next, the system uses the scenegraph renderer to create a scenegraph from a graphics model associated with the web application and generate a set of rendering commands from the scenegraph. The system then writes the rendering commands to a command buffer and reads the rendering commands from the command buffer. Finally, the system uses the rendering commands to render, for the web application, an image corresponding to the graphics model by executing the rendering commands using a graphics-processing unit (GPU).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619858&OS=09619858&RS=09619858
owner: Google Inc.
number: 09619858
owner_city: Mountain View
owner_country: US
publication_date: 20140801
---
This application is a continuation of U.S. application Ser. No. 12 497 456 filed on Jul. 2 2009 now U.S. Pat. No. 8 797 337.

The subject matter of this application is related to the subject matter in U.S. application Ser. No. 12 267 125 filed on Nov. 7 2008 now issued as U.S. Pat. No. 8 675 000.

The subject matter of this application is also related to the subject matter in U.S. application Ser. No. 12 174 586 filed on Jul. 16 2008 now issued as U.S. Pat. No. 8 368 705.

The subject matter of this application is also related to the subject matter in U.S. application Ser. No. 12 117 634 filed on May 8 2008.

The subject matter of this application is also related to the subject matter in U.S. application Ser. No. 12 117 650 filed on May 8 2008 now issued as U.S. Pat. No. 8 424 082.

The subject matter of this application is also related to the subject matter in U.S. application Ser. No. 12 268 004 filed on Nov. 10 2008 now issued as U.S. Pat. No. 8 352 967.

The present embodiments relate to techniques for executing web applications. More specifically the present embodiments relate to a method and system for providing graphics scenegraph rendering to the web applications using native code modules.

Computer systems often include a number of native applications that require complex three dimensional 3D scenes to be rendered such as computer games and computer aided design CAD systems. To render 3D scenes these native applications may use graphics application programming interfaces APIs that direct calculations related to graphics rendering to dedicated graphics processing units GPUs . The additional computational power provided by these GPUs can greatly improve graphics quality and throughput.

Web applications which have become more prevalent in recent years are typically written in scripting languages that are unable to utilize low level graphics APIs that provide graphics hardware acceleration. Instead graphics rendering for web applications is typically performed by CPUs instead of GPUs. The software based nature of web based graphics rendering may thus limit the graphics capabilities of web applications. However unlike native applications web applications provide a number of advantages. For example web applications are capable of executing on multiple platforms do not require installation and can be more secure than native applications.

The tradeoff between web application security and native graphics performance may be addressed using a browser plugin that renders graphics for web applications by interfacing with a local graphics hardware device e.g. a GPU . Such a plugin may correspond to a complex software system that includes various mechanisms for obtaining scene information from the web applications storing the scene information processing the scene information using transforms effects and shaders and sending commands to the graphics hardware for rendering the scene. The processing demands of the plugin may additionally require the plugin to be implemented using native code which is traditionally insecure. Moreover plugin installation traditionally requires that the browser be restarted which may lead to a poor user experience. Consequently the plugin itself may include a number of potential security vulnerabilities that may be exploited by other applications and or bugs that may lead to system failures.

Hence what is needed is a mechanism for safely executing native code for web based graphics rendering while maintaining communication between the native code and graphics hardware.

One embodiment provides a system that facilitates the execution of a web application. During operation the system loads a native code module that includes a scenegraph renderer into a secure runtime environment. Next the system uses the scenegraph renderer to create a scenegraph from a graphics model associated with the web application and generates a set of rendering commands from the scenegraph. The system then writes the rendering commands to a command buffer and reads the rendering commands from the command buffer. Finally the system uses the rendering commands to render for the web application an image corresponding to the graphics model by executing the rendering commands using a graphics processing unit GPU .

In some embodiments the system also validates the native code module prior to loading the native code module into the secure runtime environment.

In some embodiments the system also uses the scenegraph renderer to write buffer data associated with the rendering commands to a shared memory buffer and uses the buffer data to render the image by reading the buffer data from the shared memory buffer.

In some embodiments the shared memory buffer and the command buffer are implemented using an inter module communication IMC buffer.

In some embodiments the rendering commands are further executed using at least one of a trusted code module and a rendering engine.

In some embodiments the graphics model is obtained from at least one of the web application the native code module and a separate native code module.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present embodiments. Thus the system is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore methods and processes described herein can be included in hardware modules or apparatus. These modules or apparatus may include but are not limited to an application specific integrated circuit ASIC chip a field programmable gate array FPGA a dedicated or shared processor that executes a particular software module or a piece of code at a particular time and or other programmable logic devices now known or later developed. When the hardware modules or apparatus are activated they perform the methods and processes included within them.

Embodiments provide a method and system for facilitating the execution of a web application. The web application may be loaded in a web browser and executed on a computing system such as a personal computer PC a mobile phone a personal digital assistant PDA a graphing calculator a portable media player a global positioning system GPS receiver and or another electronic computing device. The web application may be obtained by the computing system from a server using a network connection with the server. For example the web application may be downloaded over the Internet from a website.

More specifically embodiments provide a method and system for rendering graphics for the web application. A native code module associated with the web application may be executed within a secure runtime environment within a plugin associated with the web browser. To render graphics for the web application the native code module may issue rendering commands to a trusted code module provided by the plugin using a command buffer interface.

In addition the native code module may provide a scenegraph renderer for the web application. The scenegraph renderer can include any type of software component or any combination of hardware and software components which provides functionality that enables a retained mode graphics for the web application by creating a scenegraph from a graphics model associated with the web application. For example the graphics model may include a set of shapes composed of triangles or polygons one or more light sources a camera and or one or more rendering effects e.g. shaders culling blending etc. . The resulting scenegraph may include any type of graph or tree data structure that is used the represent a graphics scene.

A scenegraph is a data structure such as a tree or a more general interconnected graph which is used to organize data associated with a graphical scene into a logical or spatial hierarchy comprising interconnected nodes wherein each node can specify an object or a transformation such as a rotation for an object. A node in scenegraph can have many child nodes but typically only one parent node. Moreover an operation applied to a parent node propagates to associated child nodes and possibly to other descendent nodes. Scene graphs can also be structured to group related objects into a compound object which can be manipulated and transformed as a single object.

The scenegraph renderer described above is also configured to generate a set of rendering commands from the scenegraph and to write the rendering commands to a command buffer provided by the command buffer interface. The trusted code module may then render an image corresponding to the graphics model by executing the rendering commands using a graphics processing unit GPU .

The native code module may additionally store rendering commands associated with components in the image for future issuance of the rendering commands with updated parameters. For example the native code module may issue rendering commands to animate a model across frames of the image by writing the same rendering commands for the model to the command buffer using updated parameters for each frame of the animation. Consequently embodiments may provide secure hardware accelerated graphics rendering and animation to web applications while requiring relatively few method calls from the web applications.

Computing system may correspond to an electronic device that provides one or more services or functions to a user. For example computing system may operate as a mobile phone personal computer PC global positioning system GPS receiver portable media player personal digital assistant PDA and or graphing calculator. In addition computing system may include an operating system not shown that coordinates the use of hardware and software resources on computing system as well as one or more applications e.g. web browser web application that perform specialized tasks for the user. For example computing system may include applications such as an email client address book document editor web browser and or media player. To perform tasks for the user applications may obtain the use of hardware resources e.g. processor memory I O components wireless transmitter graphics processing unit GPU etc. on computing system from the operating system as well as interact with the user through a hardware and or software framework provided by the operating system as described below.

Those skilled in the art will appreciate that computing system may include functionality to execute both native applications and non native applications. In other words computing system may include native applications such as web browser that are locally installed on computing system and specific to the operating system and or one or more hardware devices on computing system . Such applications may be compiled into native e.g. machine code that executes directly on one or more central processing units CPUs of computing system . Code execution for such applications may further be optimized by writing the applications in a combination of general purpose programming languages e.g. C C etc. and assembly language as well as utilizing libraries that provide hardware acceleration e.g. graphics hardware acceleration to the applications. However the installation of native applications may compromise the security of computing system and private data stored on computing system .

Computing system may also include functionality to execute platform independent non native applications. In particular computing system may obtain web application from one or more servers e.g. server server x using a network connection with the server s and load web application in web browser . For example web application may be downloaded from an application server over the Internet by web browser .

Once loaded web application may provide features and user interactivity comparable to that of native applications on computing system . For example web application may function as an email client document editor media player computer aided design CAD system and or computer game. Web application may also include dynamic user interface elements such as menus buttons windows sub windows icons animations and or other graphical objects that emulate analogous user interface elements in native applications. In other words web application may correspond to a rich Internet application RIA .

Furthermore web application may execute on computing system regardless of the type of platform e.g. operating system drivers etc. associated with computing system . Though platform independent applications such as web application may be more portable and secure than native applications such cross platform applications may lack certain performance capabilities of native applications.

More specifically non native applications such as web application may be written using scripting languages that are interpreted rather than compiled such as JavaScript JavaScript is a registered trademark of Sun Microsystems Inc. . The interpreted nature of web application and or other non native applications may result in significantly slower execution times for the non native applications than those of compiled native applications. Non native applications may also be unable to utilize low level libraries and or application programming interfaces API that are available for use by native applications. Consequently non native applications may provide limited functionality in certain tasks.

In particular web application may be unable to utilize graphics hardware acceleration e.g. from GPU in graphics rendering. For example web application may be written in a language e.g. Javascript that lacks an interface with GPU and or that is too slow to issue rendering commands at a rate that fully utilizes the hardware acceleration provided by GPU . Instead graphics rendering for web application may be performed using software that executes on a CPU of computing system rather than GPU . As a result graphics in web application may be suboptimal compared to graphics in native applications that employ graphics hardware acceleration.

Limitations in graphics rendering for web application may further preclude web application from providing features that utilize significant graphics processing resources including graphics hardware acceleration. For example web application may be unable to efficiently render and animate a complex three dimensional 3D model for a web based computer game.

To enable graphics support and graphics hardware acceleration for web applications operations related to graphics processing may be offloaded to a plugin in computing system . Plugin may expose the capabilities of GPU to web application thus allowing web application to utilize graphics hardware acceleration including the application of vertex and pixel shaders. Plugin based graphics hardware acceleration for web applications is described in a co pending non provisional application by inventors Robin Green Evangelos Kokkevis Matthew Papakipos and Gregg Tavares and filed 16 Jul. 2008 entitled Web Based Graphics Rendering System having Ser. No. 12 174 586 which is incorporated herein by reference.

As shown in plugin includes a native code module and a trusted code module . The interaction of native code module and trusted code module may allow plugin to provide graphics hardware acceleration for web application . Furthermore the validation of native code module by a validator in plugin and the execution of native code module within a secure runtime environment in plugin may facilitate the safe execution of rendering commands for web application by GPU as discussed in further detail below.

Like web application native code module may be obtained from one or more servers e.g. server server x by web browser . For example web application may provide a hyperlink to native code module on the Internet. Web browser may then download native code module from the Uniform Resource Locator URL specified in the hyperlink. Alternatively native code module may be specified by the user or by an external source such as another web application and or a native application.

In one or more embodiments plugin includes a variety of mechanisms to ensure the safe execution of native code module . In particular native code module may be validated by a validator provided by plugin prior to execution. Native code module validation is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr and Bennet S. Yee entitled Method for Validating an Untrusted Native Code Module having Ser. No. 12 117 634 and filing date 8 May 2008 which is incorporated herein by reference.

Once native code module is validated native code module may be loaded into a secure runtime environment provided by plugin . Native code execution in a secure runtime environment is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr Bennet S. Yee and Gregory Dardyk entitled Method for Safely Executing an Untrusted Native Code Module on a Computing Device having Ser. No. 12 117 650 and filing date 8 May 2008 which is incorporated herein by reference.

Because native code module may include binary code that runs directly on hardware native code module may be platform independent with respect to the operating system of computing system web browser and or other software components on computing system . As described in the above referenced applications plugin and or native code module may also include mechanisms for executing on a variety of instruction set architectures including the use of fat binaries and binary translators.

In other words native code module may correspond to a software module containing native code that runs directly on hardware provided by computing system such as a CPU. As a result native code module may be used to perform tasks that require substantial access to CPU resources on computing system including high level graphics rendering capabilities to web application . As discussed below native code module may implement a scenegraph renderer for web application . Alternatively native code module may securely provide a lower level rendering API such as an OpenGL or Direct3D library within secure runtime environment .

Furthermore some or all of web application may execute within native code module . For example web application may correspond to a 3D computer game that runs within web browser . As a result web application may include one or more native code modules that simulate physics in the computer game and or one or more native code modules that render real time 3D graphics in the computer game.

As mentioned previously native code module may interact with trusted code module to provide graphics hardware acceleration to web application . In particular native code module may receive graphics rendering requests from web application through a scenegraph interface with web application . The scenegraph interface may be provided by a plugin interface bridge that implements an inter process communication IPC mechanism such as a remote procedure call RPC mechanism and or socket mechanism between native code module and web browser .

Plugin interface bridge may allow native code module to operate as a plugin for web browser e.g. a Netscape Plugin Application Programming Interface NPAPI or ActiveX ActiveX is a registered trademark of Microsoft Corp. plugin without changes to the plugin architecture used by web browser . Plugin interface bridges between web browsers and native code modules are described in a co pending non provisional application by Antoine Labour Matthew Papakipos Shiko Okasaka and Jeff Timanns entitled Safe Browser Plugins for Native Code Modules having Ser. No. 12 268 004 and filing date 12 Jun. 2008 which is incorporated herein by reference.

The scenegraph interface may allow native code module and or scenegraph renderer to obtain and store a graphics model to be rendered for web application . The graphics model may include for example a set of shapes composed of triangles or polygons one or more light sources a camera and or one or more rendering effects e.g. shaders culling blending etc. . Furthermore the graphics model may be obtained from web application as an input file that describes the graphics model using a scene description language and or as a set of method calls from web application to native code module through plugin interface bridge . Alternatively the graphics model may be directly stored in native code module e.g. programmed into native code module and or obtained from a separate native code module not shown in computing system through an inter module communication IMC interface with the separate native code module.

The graphics model may then be stored as a scenegraph by scenegraph renderer . In other words scenegraph renderer may create a logical and or spatial representation of the graphics model using a graph of shape nodes transform nodes and or other types of nodes. The scenegraph may further allow native code module and or scenegraph renderer to perform advanced operations on one or more components of the graphics model. For example scenegraph renderer may perform transformations scene management clipping culling and or visibility operations on one or more nodes of the scenegraph. Finally the scenegraph may enable scenegraph renderer and or native code module to render an image corresponding to the graphics module using GPU .

Those skilled in the art will appreciate that the execution of native code module within secure runtime environment may prevent native code module from accessing hardware devices on computing system such as GPU . Instead native code module may generate a set of rendering commands from the scenegraph and transmit the rendering commands to trusted code module using a command buffer interface with trusted code module . In other words native code module may function as a software client that transforms high level shape nodes in a retained mode scenegraph into low level rendering commands that are executed using an immediate mode command buffer interface with trusted code module . Transformation of nodes in scenegraphs into rendering commands is described in further detail below with respect to .

To communicate with trusted code module native code module may write the rendering commands to a command buffer provided by command buffer interface . Native code module may also write buffer data to a shared memory buffer provided by command buffer interface . In one or more embodiments the command and shared memory buffers are implemented using an inter module communication IMC buffer. Transmission of rendering commands and or buffer data between native code module and trusted code module using IMC buffers is discussed below with respect to .

Trusted code module may operate as a software service that reads the rendering commands from the command buffer and the buffer data from the shared memory buffer. Because trusted code module executes outside secure runtime environment trusted code module may include the capability to communicate with GPU . As a result trusted code module may render images by executing rendering commands from the command buffer using a direct interface with GPU and or an interface with a rendering engine such as an OpenGL OpenGL is a registered trademark of Silicon Graphics Inc. or Direct3D Direct3D is a registered trademark of Microsoft Corp. renderer. The rendered image may then be displayed within web browser as output for web application . Secure web based graphics rendering with software clients software services and command buffer interfaces is described in a co pending non provisional application by inventor Antoine Labour and filed on the same day as the instant application entitled Command Buffers for Web Based Graphics Rendering having serial number TO BE ASSIGNED and filing date TO BE ASSIGNED which is incorporated herein by reference.

In one or more embodiments native code module includes functionality to store rendering commands associated with one or more components in the graphics model and or image. Native code module may then provide the stored rendering commands to trusted code module by writing the rendering commands to the command buffer without recalculating the values of the rendering commands. The rendering commands may additionally specify a set of parameters associated with the component such as vertex buffer data index buffer data effect data and or texture data. As a result multiple renderings of the component may be performed by writing the stored rendering commands to the command buffer and updating values for the components parameters using the command buffer and or shared memory buffer.

The storing of rendering commands may thus improve performance by reducing the amount of processing required by native code module to issue rendering commands to the command buffer. The reduction in processing may further allow web application to provide real time changes and or updates to the components parameters through plugin interface bridge . In other words the combined use of a scenegraph and stored rendering commands by native code module may reduce the number of method calls required between web application and native code module to a point that enables a non native web application to describe and or animate a complex 3D graphics model on computing system .

For example a character in a computer game may be associated with two components e.g. objects . A graphics model for the character may be obtained from web application as an input file and or as a series of method calls to native code module . Native code module may then create a scenegraph from the input file and or method calls and generate a set of rendering commands from the scenegraph. For example native code module may generate the following sequence of rendering commands from the scene graph 

To draw the character native code module may issue the sequence of rendering commands to the command buffer. To animate the character e.g. during each frame native code module may write the same rendering commands to the command buffer while changing only the parameters e.g. transformation matrices used in the animation. The updated parameters may be written to or stored in the command buffer shared memory buffer and or a different set of buffers e.g. vertex buffers . In other words because the inherent structure of the rendering commands is the same native code module may store the rendering commands for the character and insert the updated parameters into the stored command buffer structure instead of recalculating the rendering commands for each frame of the animation. Furthermore per frame changes to the parameters may be provided by web application through plugin interface bridge thus allowing web application to control the animation of the character.

In addition native code module may transmit rendering commands and or buffer data generated by scenegraph renderer to trusted code module by first accessing IMC buffer through the IMC interface then writing the rendering commands to command buffer and the buffer data to shared memory buffer using the command buffer interface. Similarly trusted code module may receive the rendering commands and or buffer data by first accessing IMC buffer through the IMC interface then reading the rendering commands from command buffer and the buffer data from shared memory buffer using the command buffer interface.

More specifically shape node includes a set of buffers that describe the geometry of the object e.g. vertices triangles etc. and or attributes of the objects e.g. colors textures etc. . Shape node also includes an effect that specifies shaders culling blending and or other settings for a graphics pipeline used to render the objects in the shape node. Finally shape node includes a set of parameters that are used to store values that affect the rendering of the object. Shape node and data associated with shape node are described in further detail in the above referenced applications.

As mentioned above shape node may be transformed into a set of rendering commands that are used to render an image corresponding to the graphics model. In particular shape node may be transformed into a set of resource management commands and a set of drawing commands by a scenegraph renderer e.g. scenegraph renderer of provided by a native code module. The scenegraph renderer may then write resource management commands and drawing commands to a command buffer for rendering using a trusted code module e.g. trusted code module of and or a GPU e.g. GPU of .

Resource management commands may be used by the scenegraph renderer to transmit resource data to the trusted code module through the command buffer interface. Consequently resource management commands include resource creation commands that create resources for use by the trusted code module. For example resource management commands may include commands for creating vertex buffers e.g. CreateVertexBuffer index buffers e.g. CreateIndexBuffer texture buffers e.g. CreateTextureBuffer and effects e.g. CreateEffect . Each resource creation command may further specify an identifier ID for the resource to be created so that the resource may be subsequently referenced through the command buffer interface.

Resource management commands may also include resource transfer commands that copy data stored within shape node to the resources created from the resource creation commands. For example resource management commands may include commands for transferring data to vertex buffers e.g. SetVertexBufferData index buffers e.g. SetIndexBufferData and texture buffers e.g. SetTextureBufferData for use by the trusted code module and or GPU. As with the resource creation commands each resource transfer command may specify the ID of the resource to which the data is to be transferred. For example the SetTextureBufferData command may reference the ID of the texture buffer created using the CreateTextureBuffer command as well as a shared memory buffer containing the texture buffer data. The trusted code module may then execute the SetTextureBufferData command by copying the data in the shared memory buffer to the texture buffer.

In addition some resource management commands may both create and transfer resources through the command buffer interface. For example the CreateEffect command may include a reference to a shared memory buffer containing source code for effect . When the CreateEffect command is executed the source code is transferred to memory accessible by the trusted code module.

Drawing commands may be used by the scenegraph renderer to request rendering of shape mode . In particular drawing commands may set resources used to render shape node . For example drawing commands may include commands for setting a vertex buffer e.g. SetCurrentVertexBuffer effect e.g. SetCurrentEffect and parameter e.g. SetParameter used to render shape node . Drawing commands may also include a Draw command that requests rendering of shape node using the resources set by the other drawing commands. Upon reaching the Draw command the trusted code module may communicate with the GPU to render the object represented by the current vertex buffer current effect and or one or more parameters.

As mentioned previously rendering commands for shape node may be stored for subsequent use to reduce the amount of computation required to reissue the rendering commands e.g. to animate shape node . As a result some or all of resource management commands and or drawing commands may be stored for subsequent rendering of shape node by the trusted code module. In addition changes to shape node may be propagated to the trusted code module without changing the inherent structure of the rendering commands. For example shape node may be animated by creating new resources and or updating existing resources using resource management commands and specifying the new or updated resources using drawing commands prior to redrawing shape node . Similarly shape node may be re rendered with different effects and or parameters by executing drawing commands with changes to the parameters of the SetCurrentEffect and SetParameter commands.

Initially a web application is loaded into a web browser operation . The web application may be obtained from a server by the web browser. The web application may also utilize graphics hardware acceleration in performing tasks for a user. For example the web application may be associated with a scenegraph renderer a graphics library a game engine a game a DCC or CAD tool a video processing application and or an image processing application.

To provide graphics hardware acceleration to the web application a native code module associated with the web application may be obtained operation . For example the native code module may be downloaded from a source specified by the web application. The native code module may also be validated operation prior to executing the native code module. If the native code module is not validated the native code module is discarded without having been executed.

If the native code module is validated the native code module is loaded into a secure runtime environment operation . The secure runtime environment may be provided by a plugin associated with the web browser. Within the secure runtime environment the native code module obtains a graphics model operation associated with the web application and creates a scenegraph from the graphics model operation . In other words the native code module may contain a scenegraph renderer that provides high level retain mode graphics rendering to the web application.

Next a set of rendering commands is generated from the scenegraph operation . The rendering commands may correspond to low level immediate mode commands used to render an image corresponding to the graphics model. The rendering commands are then written to a command buffer operation for execution by an independently executing software service e.g. a trusted code module outside of the native code module and secure runtime environment. In addition buffer data is written to one or more shared memory buffers operation to enable the transfer of data e.g. vertex data index data texture data effects etc. from the native code module to the software service.

The software service may read the rendering commands from the command buffer and the buffer data from the shared memory buffer s operation . Next the software service may use the rendering commands and buffer data to render the image by executing the rendering commands using a GPU operation . In particular the software service may interface directly with the GPU or access the GPU through a rendering engine such as an OpenGL or Direct3D renderer. Furthermore the image may be rendered by executing the rendering commands with the buffer data as parameters to the rendering commands. For example the rendering commands may use the buffer data to specify vertices indexes textures parameters and or an effect to be used in rendering the image.

The rendered image is then displayed in the web browser operation as output for the web application. For example the rendered image may correspond to an updated view of a CAD model or a new frame of a computer game.

First rendering commands are obtained for the component operation . The rendering commands may be obtained from a command buffer by a trusted code module for execution of the rendering commands. In addition the rendering commands may be generated from a shape node in a scenegraph corresponding to the component. The rendering commands are also stored operation . For example the rendering commands may be stored in memory outside the command buffer for subsequent retrieval and use after the rendering commands are overwritten in the command buffer with new rendering commands.

A set of parameters associated with the component is also obtained operation . For example the shape node may include parameters that include vertex index texture effect and or other data. The parameters may be obtained from the command buffer and or a shared memory buffer. The rendering commands are then executed using the parameters operation to render the component in the image.

The parameters may also be updated operation for subsequent rendering of the component. For example the parameters may be updated to animate the component in successive frames of the image. If the parameters are updated the updated parameters are obtained operation and the stored rendering commands are executed using the updated parameters operation . In other words the updated parameters may be inserted into the stored command buffer structure associated with the rendering commands in lieu of recalculating the rendering commands with the updated parameters from the command buffer.

The parameters may continue to be updated operation and obtained operation and the stored rendering commands executed using the updated parameters operation until the component is no longer rendered in the image. For example the stored rendering commands and parameters may be used to render and or animate a character in a computer game until the character is hidden from view or no longer exists in the computer game.

The foregoing descriptions of embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the embodiments to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present embodiments. The scope of the embodiments is defined by the appended claims.

