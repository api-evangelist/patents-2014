---

title: Encryption system in a virtualized environment
abstract: For a host that executes one or more guest virtual machines (GVMs), some embodiments provide a novel encryption method for encrypting the data messages sent by the GVMs. The method initially receives a data message to send for a GVM executing on the host. The method then determines whether it should encrypt the data message based on a set of one or more encryption rules. When the process determines that it should encrypt the received data message, it encrypts the data message and forwards the encrypted data message to its destination; otherwise, the method just forwards the received data message unencrypted to its destination. In some embodiments, the host encrypts differently the data messages for different GVMs that execute on the host. When two different GVMs are part of two different logical overlay networks that are implemented on common network fabric, the method in some embodiments encrypts the data messages exchanged between the GVMs of one logical network differently than the data messages exchanged between the GVMs of another logical network. In some embodiments, the method can also encrypt different types of data messages from the same GVM differently. Also, in some embodiments, the method can dynamically enforce encryption rules in response to dynamically detected events, such as malware infections.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09613218&OS=09613218&RS=09613218
owner: NICIRA, INC.
number: 09613218
owner_city: Palo Alto
owner_country: US
publication_date: 20140630
---
Enterprises e.g. financial service providers healthcare providers critical infrastructure providers etc. store valuable data and transfer it over networks. Information spreads across datacenters often through dedicated telco provided networks. Overlay networks provide the same service across the wide area network WAN on a public network for enterprises and are susceptible to threats such as snooping man in the middle attack MITM and forging. As enterprises widely adopt cloud based Software Defined Data Center SDDC instead of dedicated datacenters new challenges are introduced and protecting the data flowing into within and out of the cloud becomes a necessity. The privacy guarantee of private datacenters is no longer assumed and threats similar to those in the Internet prevail.

Cryptography protects data and communication channels from malicious parties provides confidentiality to enterprise dataflow in the cloud and provides control over the data to the enterprise. However current approaches to encrypt network data fall short in terms of contextual information isolation granularity or ease of management. For example IPSec has been a key game changer in business to business B2B virtual private networks VPNs and branch office networking. However IPSec tunneling by the edge devices is oblivious to the application context and the user generating the network traffic lacks granularity as it encrypts data in bulk and cannot address various internal threats as the traffic between the virtual machines VMs and the edge devices is in plaintext. Moreover the known problem with traditional IPSec is that both endpoints negotiate a security association and agree upon a key. In a network that includes N endpoints the number of keys in the secure overlay is O N .

In VM encryption provides contextual information for fine grained security decisions. However in guest encryption fails to isolate the protected data from the protection mechanism as they both reside in the guest. This scheme also suffers from inability for upgrades and is extremely difficult to manage from a centralized management console.

For a host that executes one or more guest virtual machines GVMs some embodiments provide a novel encryption method for encrypting the data messages sent by the GVMs. The method initially receives a data message to send for a GVM executing on the host. The method then determines whether it should encrypt the data message based on a set of one or more encryption rules. When the process determines that it should encrypt the received data message it encrypts the data message and forwards the encrypted data message to its destination otherwise the method just forwards the received data message unencrypted to its destination.

By employing this method a host frees up the GVMs from the encryption tasks while flexibly encrypting different GVM data messages differently. For instance in some embodiments the host encrypts differently the data messages for different GVMs that execute on the host e.g. encrypts the data messages from one GVM while not encrypting the data messages for another GVM . When two different GVMs are part of two different logical overlay networks that are implemented on a common network fabric the method in some embodiments encrypts the data messages exchanged between the GVMs of one logical network differently than the data messages exchanged between the GVMs of another logical network.

In some embodiments the method can also encrypt different types of data messages from the same GVM differently. For example by examining the destination identifiers e.g. destination MAC addresses destination IP addresses etc. in the header fields of the data messages the host can encrypt the data messages from a particular GVM to one destination e.g. a first destination GVM differently than the data messages from the particular GVM to another destination e.g. a second destination GVM . By examining the header field values e.g. the higher level L4 attributes the host can even differently encrypt different data messages that are part of different data flows between one pair of GVMs.

The method of some embodiments can dynamically create and enforce encryption rules in response to dynamically detected events. For instance in some embodiments the GVMs running on the host are scanned for malware periodically or continuously. When malware is detected on a GVM the GVM is tagged as an infected GVM. In response to such a tag the host uses the encryption method of some embodiments to encrypt the data messages sent by the infected GVM or to encrypt the data messages sent by the other GVMs on the same host as the infected GVM. In some embodiments the encryption method also dynamically adds and enforces encryption rules after detecting different flow based events.

When the method encrypts a received GVM data message the encrypted message has to be decrypted by a corresponding method at the destination of the GVM data message. In some embodiments the encryption and decryption operations of these two methods are statically synchronized as they are configured beforehand to use the appropriate encryption decryption keys for different data messages. For example when two GVMs on two different hosts operate as part of one logical network one or more controllers and or key managers in some embodiments provide the same cryptographic key s e.g. one identical key or a pair of associated keys that are transformed versions of each other to both hosts such that each host uses the provided key s to encrypt all GVM data messages at their source and to decrypt all data messages at their destination. In some of these embodiments the controllers and or key managers periodically refresh the keys that the hosts store for their prospective encryption and decryption operations.

In other embodiments however the encryption methodology is more dynamic. For instance in some embodiments a host s encryption method initially detects a condition e.g. a malware event or a flow based event that requires data messages from one or more of the host s GVMs to be encrypted. Upon detecting the condition the host s method identifies an encryption key uses the encryption key to encrypt some or all of the data message e.g. the payload and some or all of the message header and then includes a key identifier i.e. the key ID in the data message e.g. in the message header or in another header that is used to encapsulate the message header so that the data message s destination e.g. the destination host can know which key to use to decrypt the encrypted message.

The dynamic encryption methodology of some embodiments is a hypervisor based encryption scheme that uses guest introspection GI to get application centric and contextual metadata about network traffic in order to dynamically apply attribute based security policies on the GVM traffic and encrypt this GVM traffic accordingly. In some embodiments the hypervisor is a software layer e.g. an application over which the GVMs execute. The hypervisor in some embodiments implements the above described encryption and decryption methods.

In some embodiments the hypervisor also uses guest introspection to obtain application centric and contextual information about the applications that each GVM runs. To perform guest introspection the hypervisor in some embodiments communicates with a thin introspecting agent that is deployed on each GVM. The thin introspecting agent has a network introspection module that in some embodiments is called by the TCP IP stack each time the stack processes a new connection request. Through these calls the network introspection module captures 1 every new connection request e.g. both incoming and outgoing connection requests and 2 contextual information e.g. user identity and application context for the new connections. In some embodiments the thin introspecting agent includes other introspection modules that gather other introspection data. For example in some embodiments the agent includes file and system introspection modules that are used to scan the thin agent s GVM for malware.

The above described hypervisor based encryption scheme combines the best of in guest encryption and network based encryption. It avoids the overhead of key management of N to N GVMs and it performs encryption based on fine grained context aware policies. As such it provides context aware hypervisor based network encryption that dynamically enforces fine grained encryption policies while bridging the gap between having sufficient context to perform context aware encryption and maintaining isolation between the encryption and the GVM operations.

The preceding Summary is intended to serve as a brief introduction to some embodiments of the invention. It is not meant to be an introduction or overview of all inventive subject matter disclosed in this document. The Detailed Description that follows and the Drawings that are referred to in the Detailed Description will further describe the embodiments described in the Summary as well as other embodiments. Accordingly to understand all the embodiments described by this document a full review of the Summary Detailed Description the Drawings and the Claims is needed. Moreover the claimed subject matters are not to be limited by the illustrative details in the Summary Detailed Description and the Drawing.

In the following detailed description of the invention numerous details examples and embodiments of the invention are set forth and described. However it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.

For a host computing device the host that executes one or more guest virtual machines GVMs some embodiments provide a novel encryption method for encrypting the data messages sent by the GVMs. Examples of GVMs include webservers application servers database servers etc. In some cases all the GVMs belong to one entity e.g. an enterprise that operates a datacenter with multiple hosts. In other cases the host executes in a multi tenant environment e.g. in a multi tenant data center and different groups of GVMs belong to different tenants. As used in this document encryption refers to the encoding of plaintext data i.e. unencrypted data into a ciphertext format by using an encryption algorithm also called encryption operator or process that takes as input the plaintext data and an encryption key. Decryption refers to the conversion of the encrypted ciphertext data into plaintext data by applying a decryption algorithm also called decryption operator or process which relies on a decryption key on the encrypted ciphertext data.

In some embodiments the process of is performed by the host on which the GVMs execute. This process will be described below by reference to which illustrates one architecture for a host to intercept and encrypt outgoing GVM data messages and to intercept and decrypt incoming GVM data messages. Specifically illustrates a host that executes multiple GVMs a software forwarding element a set of one or more encryptors decryptors referred to as the encryptor set and a malware detecting SVM .

The software forwarding element SFE executes on the host to communicatively couple the GVMs of the host to each other and to other devices e.g. other GVMs outside of the host. As shown the SFE includes a port to connect to a physical network interface card NIC of the host and a port to connect to the virtual NIC VNIC of each GVM. In some embodiments the VNICs are software abstractions of the physical NIC PNIC that are implemented by the virtualization software e.g. by a hypervisor . Each VNIC is responsible for exchanging packets between its GVM and the SFE through its corresponding SFE port. As shown a GVM s egress datapath for its data messages includes 1 the GVM s VNIC 2 the SFE port that connects to this VNIC 3 the SFE and 4 the SFE port that connects to the host s PNIC.

Through its port and a NIC driver not shown the SFE connects to the host s PNIC to send outgoing packets and to receive incoming packets. The SFE performs message processing operations to forward messages that it receives on one of its ports to another one of its ports. For example in some embodiments the SFE tries to use header values in the GVM data message to match the message to flow based rules and upon finding a match to perform the action specified by the matching rule e.g. to hand the packet to one of its ports or which directs the packet to be supplied to a destination GVM or to the PNIC . In some embodiments the SFE is a software switch while in other embodiments it is a software router or a combined software switch router.

The SFE in some embodiments implements one or more logical forwarding elements e.g. logical switches or logical routers with SFEs executing on other hosts in a multi host environment. A logical forwarding element in some embodiments can span multiple hosts to connect GVMs that execute on different hosts but belong to one logical network. In other words different logical forwarding elements can be defined to specify different logical networks for different users and each logical forwarding element can be defined by multiple SFEs on multiple hosts. Each logical forwarding element isolates the traffic of the GVMs of one logical network from the GVMs of another logical network that is serviced by another logical forwarding element. A logical forwarding element can connect GVMs executing on the same host and or different hosts.

In the host architecture illustrated in the process is performed by the SFE ports and the encryptor s . The ports in some embodiments include one or more function calls to one or more modules that implement special input output I O operations on incoming and outgoing packets that are received at the ports. One of these function calls for a port is to an encryptor decryptor in the encryptor decryptor set . As further described below the encryptor decryptor performs the encryption decryption rule check and the encryption decryption operations on outgoing incoming data messages i.e. on messages that are sent by one of the GVMs and or that are received by the host for one of the GVMs . In some embodiments each port has its own encryptor decryptor while in other embodiments some or all of the ports share the same encryptor decryptor e.g. all the ports share one encryptor decryptor or all ports that are part of the same logical network share one encryptor decryptor .

Examples of other I O operations that are implemented by the ports include message encapsulation operations needed for sending messages along tunnels to implement overlay logical network operations. By implementing a stack of such function calls the ports can implement a chain of I O operations on incoming and or outgoing messages in some embodiments. Instead of calling the I O operators including the encryptor set from the ports other embodiments call these operators from the GVM s VNIC or from the port of the SFE. For instance as further described below the port in some embodiments calls a decryptor when it receives an encrypted GVM message from outside of its host and the GVM message has its L2 payload and L2 header values encrypted. The port in some embodiments calls the decryptor to decrypt this L2 encrypted message so that it can obtain the L2 header value that the SFE needs to identify the port to which it needs to pass the GVM data message.

As shown in the process initially receives at a data message to send from a GVM executing on the host. The process then determines at whether it should encrypt the data message based on a set of one or more encryption rules. In this determination in some embodiments is made at by 1 a port relaying to its encryptor the GVM data message that the port receives from the VNIC of the GVM that sent the message and 2 the encryptor using the GVM message s attributes to examine encryption rules that are stored in an encryption rule data store of the host. In some embodiments the port relays the GVM message by passing to the encryptor a reference e.g. a handle that identifies a location in memory that stores the GVM message to the GVM message.

The GVM message attributes that the encryptor decryptor uses in some embodiments to check the encryption decryption rules include the message header values. For instance the encryptor in some embodiments determines whether it should encrypt a GVM data message by using the data message s header values e.g. its L2 L4 attributes to identify an encryption rule that is applicable to the GVM data message. For an L2 frame the header values include the source and destination MAC addresses while for an L3 L4 packet the header values are the five tuple identifiers which include the packet s source identifier destination identifier source port destination port and protocol service . Also in some embodiments one or more of the identifier values can be logical values that are defined for a logical network e.g. can be virtual network identifier VNI for a VXLAN overlay network or a logical IP addresses defined in a logical address space . In other embodiments all of the identifier values are defined in the physical domains. In still other embodiments some of the identifier values are defined in logical domain while other identifier values are defined in the physical domain.

To determine at whether the GVM data message should be encrypted the encryptor uses the GVM message attributes to examine the encryption rules stored in the encryption rule data store in order to determine whether this data store contains a rule that identifies an encryption key for encrypting the received GVM data message. Similarly to decrypt at least some of the encrypted data messages a decryptor in some embodiments uses the message attributes of these encrypted data messages to search the encryption rules stored in the encryption rule data store to identify a rule that identifies a key for decrypting the received GVM data message. In some embodiments the decryptor identifies a key for decrypting a received encrypted GVM data message by using a key identifier that is inserted in the GVM data message by the encryptor of this message or by another module at the direction of this encryptor. The processes for decrypting encrypted messages will be further described below.

When the encryptor determines at that it should encrypt the GVM data message it at retrieves the GVM data message from memory e.g. at a location provided by the SFE port or GVM VNIC that called the encryptor encrypts the data message and passes the encrypted data message back to the SFE port that called it. The SFE port then sends the encrypted data message along the message s datapath.

When the encryptor determines at that it should not encrypt the GVM data message it directs at the module that called it to pass the GVM data message unencrypted along its datapath. In the example illustrated in this operation entails informing the SFE port to pass the GVM data message to the SFE so that the SFE can process the GVM data message to forward the message to its intended destination. After or the process ends.

By employing the process the host frees up the GVMs from the encryption tasks while flexibly encrypting the GVM data messages based on any number of encryption rules in the encryption rule data store . For instance based on these rules the host can encrypt differently the data messages for different GVMs that execute on it. One example of different encryption involves encrypting the data messages from one GVM while not encrypting the data messages for another GVM. Other examples of different encryption include encrypting different portions of the GVM messages e.g. encrypting just the L2 payload encrypting the L2 header and payload etc. using different encryption algorithms e.g. using AES128GCM encryption versus using AES256GCM encryption or using AES GCM encryption versus using AES CBC SHA1 HMAC encryption or using AES encryption versus using 3DES encryption using different encryption keys etc. Also as further described below some embodiments not only encrypt the payload of the GVM message but also 1 perform integrity check value ICV calculations on the GVM message payload and some or all of the unencrypted header values e.g. L3 L4 header values or logical network identifier values and then 2 encrypt the hash value that results from the ICV calculation along with the payload. After decrypting the payload along with the ICV generated hash the destination host can then authenticate the GVM data message by authenticating the hash value for the GVM data message s header value and payload. The encryption of the payload and the ICV generated hash will be further described below.

When two different GVMs are part of two different logical overlay networks that are implemented on common network fabric e.g. on a common set of host SFEs and one or more intermediate forwarding elements the process in some embodiments encrypts the data messages exchanged between the GVMs of one logical network differently than the data messages exchanged between the GVMs of another logical network.

In some embodiments the process can also encrypt different types of data messages from the same GVM differently. For example by examining the destination identifiers e.g. destination MAC addresses destination IP addresses etc. in the header fields of the data messages the host can encrypt the data messages from a particular GVM to one destination e.g. a first destination GVM differently than the data messages from the particular GVM to another destination e.g. a second destination GVM . By examining the header field values e.g. the higher level L4 attributes the host can even encrypt differently different data messages from one GVM to another GVM that are part of different data flows.

In some embodiments the malware detecting SVM of the host scans the GVMs of the host for malware periodically or continuously. Malware is malicious software used to disrupt computer operations gather sensitive information and or gain access to computer systems. Malware can appear in the form of executable code scripts active content and other software. Examples of malware include viruses spyware worms adware Trojan horses and other malicious programs

When the SVM detects malware on a GVM the SVM tags the GVM as an infected GVM. In response to such a tag the host uses the encryption process of some embodiments to encrypt the data messages sent by the infected GVM or to encrypt the data messages sent by the other GVMs on the same host as the infected GVM or both. As further described below the host performs this encryption by 1 defining an encryption rule for this event 2 using encryption policies that it stores to convert the security tag to a set of L2 L4 parameters that specify matching attributes for the encryption rule and 3 pushing this rule into the encryption rule data store . This dynamically created rule in some embodiments requires the encryptor or another module to include a key identifier with the encrypted GVM data message so that the destination host can know what key to use to decrypt the encrypted GVM data message.

The creation of an encryption rule in response malware related event is one example of how the encryption architecture of some embodiments can dynamically create and enforce encryption rules in response to a detected event. In some embodiments the encryption architecture can also dynamically add encryption rules to the encryption rule data store after detecting different flow based events. The dynamic addition of such encryption rules will be further described by reference to which presents a more detailed encryption architecture of some embodiments.

However before describing this more detailed architecture the encryption system of some embodiments will be described by reference to . As shown this system includes multiple virtualized hosts a set of controllers and a set of key managers . The virtualized hosts are similar to the host of except that the hosts each are shown to include an encryption agent for interacting with the controller set and the key manager set . In the SVM ports and VNICs and the rule data store are not shown in order to keep this figure s illustration simple. As shown in the hosts the controller set and the key manager set communicatively couple through a network which can include a local area network LAN a wide area network WAN or a network of networks e.g. Internet .

The network controllers provide control and management functionality for defining and managing the instantiation of one or more GVMs on each host. These controllers in some embodiments also provide control and management functionality for defining and managing multiple logical networks that are defined on the common software forwarding elements of the hosts. In some embodiments these controller also create security groups security policies including encryption policies and encryption rules. The key managers provide encryption keys for the various encryption rules that the hosts enforce. In some embodiments the key managers also periodically provide new encryption keys for one or more of the encryption rules in order to make it harder for third parties to break the encryption scheme.

In some embodiments the hosts for the source and destination GVMs of a GVM data message use encryption and decryption operations that are statically synchronized as they are configured beforehand to use the appropriate encryption decryption keys for different data messages. For example when GVMs and on hosts and are part of one logical network the controller set or key manager set provides the same cryptographic key s e.g. one identical key or a pair of associated keys that are transformed versions of each other to both hosts and such that each host uses the provided key s to encrypt all data messages that it receives from it own GVM or and to decrypt all data messages that it receives from the other host s GVM or . In some of these embodiments the controllers and or key managers periodically refresh the keys that the hosts store for their prospective encryption and decryption operations.

In other embodiments however the encryption process is more dynamic. For instance in some embodiments the encryption process of the host e.g. host initially detects a condition that requires data messages form one or more of the host s GVMs e.g. GVM to be encrypted. This detection can be based on an analysis of the header values of the GVM messages and or based on a malware scan of the GVM s . Upon detecting the condition the host s encryption process identifies an encryption key uses the encryption key to encrypt some or all of the data message e.g. the payload and some or all of the message header and then includes a key identifier i.e. the key ID in the data message e.g. in the message header or in another header that is used to encapsulate the message header so that the data message s destination e.g. the destination host can know which key to use to decrypt the encrypted message.

The dynamic encryption process of some embodiments is a hypervisor based encryption scheme that uses guest introspection GI to get application centric and contextual metadata about network traffic in order to dynamically apply attribute based security policies on the GVM traffic and encrypt the GVM traffic accordingly. illustrates an example of a hypervisor based encryption architecture of some embodiments. Specifically this figure illustrates a host that has many of the same modules as the host of such as the GVMs VNICs SFE SFE ports and encryptor set the SVM encryption rule data store and encryption agent .

As shown in the host also includes the hypervisor an encryption state cache key data stores and an encryption rule data store a flow based event detecting SVM and guest introspectors . The hypervisor is a software layer e.g. an application over which the GVMs and other host encryption modules execute. As further described below these encryption modules allow the host to encrypt and decrypt GVM data messages based on static and or dynamic encryption schemes. The encryption modules include the previously described encryptor decryptor set the encryption rule data store the SVMs and the encryption agent . These modules also include encryption state cache the key stores and encryption rule data store and the flow based event detecting SVM which will be further described below.

To facilitate its dynamic encryption operations the hypervisor uses guest introspection to obtain application centric and contextual information about the applications that each GVM runs. In some embodiments guest introspection provides information about sensitive data the applications and the users accessing them and where and how it flows in the network e.g. the source port associated with the connection session of the application that initiated a flow . It also allows the encryption system to identify the endpoints between which the network traffic needs to be secured provides a way to isolate the traffic cryptographically and protects it from the shared infrastructure.

To perform guest introspection the hypervisor in some embodiments communicates with the guest introspectors . In some embodiments each guest introspector is a thin introspecting agent that is deployed on a GVM . illustrates the various introspecting modules of a guest introspection GI agent of some embodiments. As shown the introspecting modules of the GI agent includes a file introspector a system introspector and a network introspector . In some embodiments the flow based event detecting SVM uses the network introspector to obtain real time data for the real time analysis that allows the SVM to report to the encryption agent new flow based events in real time so that this agent can push encryption rules in real time to the encryption rule data store for newly detected flow based events. Alternatively in some embodiments the malware detecting SVM uses the file and system introspectors and to gather batch data i.e. non real time data in an offline mode which allows this SVM to report malware events to the encryption agent . For these malware events the encryption agent can then push encryption rules to the data store that direct the encryptor set to encrypt the messages of the infected GVM and or the messages of the other GVMs on the same host.

As shown in the thin agent uses a multiplexing module that receives introspection messages from the various introspectors and and sends these messages to the correct destination e.g. to the correct SVM or . In some embodiments the introspectors provide the introspection messages to the multiplexor through a VM communication interface e.g. the VMCI interface of VMware Inc. .

The network introspector of the introspecting agent in some embodiments is called by the GVM s TCP IP stack each time the stack processes initiates or terminates a connection request. Through these calls the network introspection module captures 1 every new connection request e.g. both incoming and outgoing connection requests that is made by an application that is operating on the GVM and 2 contextual information e.g. user identity application context etc. for the new connections. In some embodiments different flows are differentiated based on the source port that is associated with the connection session that is associated with the flow.

For outgoing connections the network inspector in some embodiments can precisely identify which user initiated the connection including the Active Directory AD groups of which the user is a member. For instance if different users from the Finance and Human Resources groups of an enterprise are logged in on a terminal server the network introspector can identify which user from which group initiated a particular network connection. Also in some embodiments the network introspector provides the application context with each network connection initiated or accepted by a GVM. For instance the network introspector in some embodiments provides information about the application associated with every outgoing connection. For incoming connections it provides detailed information on the listening application in some embodiments. This information in some embodiments includes name of the process application hash publisher etc. The network introspector enables the gathering of this information without the need to do costly deep packet introspection on the received GVM data messages.

Through the multiplexor the thin guest introspecting agent in some embodiments provides the captured connection sessions and their associated contextual metadata to the flow based event detecting SVM . In some embodiments the SVM then examines its configuration and cache stores not shown to determine whether the captured event is an event for which it should provide a notification to the encryption agent and if so whether it has previously provided such a notification to the encryption agent . The SVM notifies the encryption agent of a flow based event when the SVM determines that the event is one for which the encryption agent needs to receive a notification. As further described below the agent then examines its encryption policies for the detected flow based event and if necessary creates and pushes encryption rule s to the encryption data store to address the newly detected flow based event. Based on the pushed rule s the encryptor set then encrypts the data messages related to the detected flow based event.

The file and system introspectors and are used by the malware detecting SVM to scan the thin agent s GVM for malware. In some embodiments the file and system introspectors are implemented like the endpoint introspecting agents of the vShield product of VMware Inc. Information about these introspectors can be found on the Internet in the following documents 

When this SVM detects a malware event on a GVM the SVM in some embodiments assigns the GVM with the appropriate malware tag e.g. an infected tag in its data store . The encryption agent then notices this malware tag e.g. by receiving notification from the SVM or by receiving a call back from the security tag data store . As further described below the agent then examines its encryption policies for the malware tag and if necessary creates and pushes encryption rule s to the encryption data store for the detected malware condition. Based on the pushed rule s the encryptor set then encrypts the data messages sent by the infected GVM or the data messages sent by the other GVMs on the host or both.

As shown in the encryption agent includes a controller manager interface an encryption agent processor and a publisher . The controller manager interface is responsible for handling the communication with the controller set and the key manager set . The agent processor processes events that it receives from the malware detecting SVM and the flow based event detecting SVM . Specifically after receiving one such event the processor examines encryption policies that it stores in to determine whether it should specify an encryption rule for the received event. The processor receives the encryption policies that it stores in the policy store from the controller set .

When the processor determines that it should specify an encryption rule for a received event the processor checks the agent s encryption rule data store to determine whether it already contains this rule. If not the processor specifies the encryption rule and stores this rule in the data store . In some embodiments the encryption processor also receives encryption rules from the controller set and stores these rules in the encryption data store . The processor in some embodiments supplies event data e.g. after receiving a flow based event or a malware event from the SVM or to the controller set through the interface . For some of the reported events the processor receives encryption rules from the controller set for the supplied event data.

For instance when the processor reports a flow based event that a doctor has logged onto an application on a first source GVM and that this application is in communication session with another application on a second destination GVM the controller set may detect that a nurse has logged onto the other second GVM application and push an encryption rule to the processor so that the flows from the first GVM s application to the second GVM s application can be encrypted. In some embodiments the processor also receives encryption rules from the controller set . Also when a GVM is powered on and this GVM is part of a security group with an associated encryption security policy the controller set will create encryption rules and provide them to the processor . In some embodiments the processor also receives from the controller set encryption policies after the processor reports the occurrence of a malware or flow based event. The processor stores the received encryption policies in its policy data store .

When the processor receives or specifies an encryption rule for its data store it contacts the key manager set through the interface and obtains the key that is identified by the key identifier of the encryption rule. The processor then stores the received key in its key data store . In some embodiments the encryption processor also interacts with the controller set and the key manager set to obtain encryption policies rules and keys in an offline batch mode. For instance the processor may receive such policies rules and keys when the encryption agent is initially being configured. Also it can receive such policies rules and keys when a GVM a logical forwarding element or logical network is being instantiated on the agent s host. Also the processor receives key updates periodically or on demand in order to perform key rotation on one or more encryption keys e.g. add or remove keys in the data store .

The publisher publishes new encryption rules and their associated keys from the data stores and to the encryption rule data store and key data store of the encryptor set . Once the encryption rule has been pushed into the data store by the encryption agent the rule can then be retrieved by the encryptor set so that the rule s associated key can be used to encrypt GVM data messages that are subsequently received from the GVM with the newly created connection session or the GVM with the malware tag. In some embodiments the encryptor set retrieves the rule s associated key from the key storage based on the key identifier that is provided by the rule.

To find the encryption rule the encryptor set first examines its encryption state cache that stores all the encryption rules that the encryptor set has recently used to encrypt data messages. As further described below this cache is smaller and is addressed differently than the encryption data store and therefore is faster to search than the encryption data store .

If the encryptor set does not find an encryption rule in its encryption cache it then examines the encryption rules in its encryption rule data store . As shown in the encryption rule data store in some embodiments can include logical network encryption rules security tag related encryption rules and other general flow based encryption rules . In some embodiments the logical network encryption rules specify different encryption keys for differently encrypting the GVM data messages of different logical networks. Security tag related encryption rules in some embodiments specify encryption rules for encrypting data messages from GVMs that have been tagged as infected and or GVMs that operate on hosts with at least one GVM that has been tagged as infected. In some embodiments flow based encryption rules specify encryption rules for statically or dynamically detected flow based events.

As shown in each rule or has a rule identifier set and a rule attribute set . For the logical network rules the rule identifiers in some embodiments are logical network identifiers e.g. virtual network identifiers VNIs of VXLAN based logical networks or virtual distributed router identifiers VDRIs of a logical router . For the security based rules and the general flow based rules the rule identifiers in some embodiments are arbitrary L2 L3 and L4 header parameters. In some embodiments the source port L4 parameter is used to differentiate GVM data message from different flows between the same two GVMs.

As shown the rule attribute sets for each of these rule types specifies 1 an encryption type that specifies the type of encryption decryption to use and 2 a key identifier that identifies the key to use for the encryption decryption. In some embodiments the rule attribute sets only specify the key identifiers and do not specify the encryption types because the key identifiers identify both the key and the type of encryption decryption. In some embodiments the rule data store stores its encryption rules in the same format as that shown in for the rule data store .

In some embodiments rule data store or is searched e.g. by the encryptor set or the agent by comparing one or more GVM message attributes e.g. message header values to the rule identifier sets to identify a rule that has a rule identifier set that matches the GVM message attributes. In some of these embodiments the rules are stored in the rule data store in a hierarchical way so that when two rules potentially match a GVM message attribute set the higher priority rule appears first in the order that the rule data store records are searched. Also in some embodiments the encryption rule data store has a default rule that is used when no other rule matches a GVM message attribute set this rule specifies no encryption key as no rule exists for encrypting the GVM data message for the received attribute set. In some embodiments when the default rule is returned to the encryptor set the encryptor set does not encrypt the GVM data message for which it is performing the check.

In some embodiments the encryption state cache stores the encryption rules based on hashed address values. These hashed address values are hashed versions of the messaged attribute sets that are used to store the encryption rules in the encryption rule data store . The hash address values specify memory locations in the cache that store the corresponding message attribute sets. Because of this addressing scheme the encryptor can search for matching records much faster in the cache than in the rule data store .

The above described hypervisor based encryption scheme combines the best of in guest encryption and network based encryption. It avoids the overhead of key management of N to N guests while providing encryption based on fine grained context aware policies. As a context aware hypervisor based network encryption that dynamically enforces fine grained encryption policies it bridges the gap between having sufficient context to make intelligent security decisions e.g. to perform context aware encryption and maintaining isolation between the encryption and the GVM operations. It uses guest introspection to identify sensitive data flow gather application centric and contextual information which it then uses to perform on demand attribute based encryption.

The encryption and decryption operations of the encryptor set will now be described by reference to . illustrates a process that the encryptor set performs to encrypt a GVM data message. In some embodiments an encryptor in the encryptor set performs this operation when its corresponding SFE port calls the encryptor to check whether a data message from the port s GVM should be encrypted and if so to encrypt this message.

As shown the process initially identifies at a set of message attributes that the process uses to identify an encryption rule that is applicable to the received GVM data message. For different types of encryption rules the message attribute sets that are used to retrieve the rules can be different. For instance when different encryption rules are specified for different logical network constructs e.g. for different logical forwarding elements such as logical switches logical routers etc. logical networks etc. the encryption rules are stored in the data stores e.g. data stores or based on logical network construct identifiers and the message attributes sets are the logical identifiers e.g. the VNIs VDRIs the logical MAC addresses the logical IP addresses etc. that are specified in the GVM data messages. When the encryption rules are specified for particular or arbitrary combination of L2 L4 header values the message attribute sets can include any combination of the L2 L4 header values of the GVM data message.

After the encryptor determines at whether its encryption state cache stores a cached encryption rule for the identified set of message attributes. As mentioned above each time an encryptor finds an encryption rule for a GVM data message in some embodiments it stores a copy of the encryption rule in the encryption state cache so that when it receives another GVM data message with the same identified message attribute set e.g. when it received another GVM data message that is part of the same data flow as the original GVM data message the encryptor does not have to search the encryption rule data store to identify an encryption rule for the subsequently received GVM data message. In some embodiments the encryption state cache stores the encryption rules based on hashed address values that are hashed versions of the messaged attribute sets that are used to store the encryption rules in the encryption rule data store . This addressing scheme allows the encryptor to search the cache faster than the rule data store . Hence before searching the rule data store the encryptor first generates a hash value from the message attribute set identified at and then uses this hash value to determine whether the cache stores a matching encryption rule for the received GVM data message.

When the process identifies at an encryption rule for the received GVM data message is in the cache the process at then retrieves a key identifier from the identified rule uses this identifier to retrieve a key from the key data store and encrypts the received GVM data message with the retrieved key. In some embodiments the process encrypts at the GVM data message s payload e.g. the L2 payload by using the identified encryption key while generating an ICV hash of the payload and some or all of the header values e.g. the physical L3 and L4 header values and or logical L2 or L3 header values so that the message s destination would have 1 to decrypt the encrypted portion of the GVM message and 2 to verify the authenticity and integrity of the payload and header values that were used for the ICV calculation.

For some or all of the GVM data messages the encryption process in some embodiments also encrypts at a portion of the GVM data message header. For GVM messages that are exchanged between machines associated with a logical network some embodiments encrypt all of the physical header values of the GVM message as they use the logical network identifier e.g. the VNI of GVM to identify the key for decrypting the encrypted GVM message. Some of these embodiments perform ICV operation on the logical network identifier e.g. the VNI and the payload so that the decryptor at the destination host can verify the authenticity and integrity of the encrypted GVM message.

After encrypting the GVM data message the process at sends the encrypted GVM data message along its datapath. In some embodiments this operation entails returning a communication to the SFE port that called the encryptor to initiate the process to let the port know that the encryptor is done with its processing of the GVM data message. The SFE port can then handoff the GVM data message to the SFE or can call another I O chain operator to perform another operation on the GVM data message.

When the cached encryption rule that was identified at is a rule that was dynamically created e.g. by the event detecting SVM after dynamically detecting an event e.g. after dynamic detection of the start of a connection session or dynamic detection of a malware event the encryptor has to make sure at that the key identifier for the key that is used to encrypt the GVM message is included in the GVM message header before it is sent. The process accomplishes this goal differently in different embodiments. In some embodiments the process passes at the key identifier to the SFE port that called it so that the port or an I O chain operator that it calls can insert the key identifier in the GVM message header. For instance in some embodiments one I O chain operator encapsulates the GVM message with a header for a logical network identifier that is used to establish an overlay logical network. In some of these embodiments the SFE port passes the key identifier that it receives from the process to the encapsulating I O chain operator so that it can include this key identifier in its header. In other embodiments the process inserts the key identifier in the GVM message header. In some embodiments the process encapsulates the GVM message with a header for a logical network and in some of these embodiments the process inserts the key identifier in the encapsulating header values. The marking of the key identifier in the GVM message header will be further described below.

When the process determines at that the encryption cache does not store an encryption rule for the received GVM data message the process searches at the encryption rule data store to identify an encryption rule that matches the received GVM message s attribute set identified at . In some embodiments the encryption rule data store has a default encryption rule that matches all GVM data message and is returned when no other encryption rule matches the attribute set of a received GVM message. The default encryption rule specifies that the received data message should not be encrypted e.g. specifies a default key identifier that corresponds to a no encryption operation . On the other hand non default encryption rules in the encryption data store specify key identifiers that identify keys for encrypting and decrypting the GVM data message.

After the process determines at whether it was able to identify an encryption rule that specifies an encryption key for encrypting the received GVM data message. If not e.g. if the process only identified a default encryption rule that does not provide an encryption key the process sends at the message unencrypted along the message s datapath. This operation entails informing its SFE port that it has completed processing the GVM data message. After the process transitions to where in the encryption cache data store it creates a record to indicate that no encryption should be performed for the received GVM data message. In some embodiments this record is addressed in the cache based on a hash value of the message attribute set identified at . The process does not create a record in the cache data store when it determines that a GVM data message should not be encrypted.

When the process determines at that it was able to identify at an encryption rule that specifies an encryption key the process then at retrieves a key identifier from the identified rule uses this identifier to retrieve a key from the key data store and encrypts the received GVM data message with the retrieved key. This encryption of the GVM data message at is identical to the encryption operation that was above described. For instance as described above the process encrypts the GVM data message s payload e.g. the L2 payload by using the identified encryption key while performing ICV operation on the payload and some or all of the header values e.g. the physical L3 and L4 header values logical L2 or L3 header values and or the logical network identifiers such as VNIs and VDRIs . For some or all of the GVM data messages the encryption process in some embodiments also encrypts at some or all of the GVM data message header e.g. encrypts some or all of the physical header values when the logical network identifier such as the VNI is used to identify the key for decrypting the encrypted GVM message .

After encrypting the GVM data message the process at sends the encrypted GVM data message along its datapath. Again in some embodiments this operation entails returning a communication to the SFE port that called the encryptor to initiate the process to let the port know that the encryptor is done with its processing of the GVM data message. The SFE port can then handoff the GVM data message to the SFE or can call another I O chain operator to perform another operation on the GVM data message.

When the cached encryption rule that was identified at is a rule that was dynamically created e.g. by the event detecting SVM after dynamically detecting an event e.g. after dynamic detection of the start of a connection session or dynamic detection of a malware event the encryptor has to make sure at that the key identifier for the key that is used to encrypt the GVM message is included in the GVM message header before it is sent. The different manners for accomplishing this goal in different embodiments were described above when the operation was being described.

After the process transitions to where in the encryption cache data store it creates a record to indicate that encryption key that should be used to encrypt GVM data message with message attribute sets that are similar to the set identified at . In some embodiments this record is addressed in the cache based on a hash value of the message attribute set identified at . After the process ends.

As shown the process initially identifies at a set of message attributes that the process uses to identify an encryption rule that is applicable to the received GVM data message. For different types of encryption rules the message attribute set that is used to retrieve the rule can be different. Several examples of such message attribute sets for different types of encryption rules were provided above while describing the process of . These examples are equally applicable to the discussion of the process of .

After the decryptor determines at whether its encryption state cache stores a cached encryption rule for the identified set of message attributes. Like an encryptor each time a decryptor finds an encryption rule for a GVM data message in some embodiments it stores a copy of the encryption rule in the encryption state cache so that when it receives another GVM data message with the same identified message attribute set e.g. when it received another GVM data message that is part of the same data flow as the original GVM data message the decryptor does not have to search the encryption rule data store s to identify an encryption rule for the subsequently received GVM data message. As mentioned above the encryption state cache in some embodiments stores the encryption rules based on hashed address values that are hashed versions of the messaged attribute sets that are used to store the encryption rules in the encryption rule data store. Accordingly before searching the rule data store the decryptor in some embodiments first generates a hash value from the message attribute set identified at and then uses this hash value to determine whether the cache stores a matching encryption rule for the received GVM data message.

When the process identifies at an encryption rule for the received GVM data message in the cache the process at then retrieves a key identifier from the identified rule uses this identifier to retrieve a key from the key data store and decrypts the encrypted portion of the received GVM data message with the retrieved key. In some embodiments part of the decryption operation at is to authenticate the ICV generated hash of the GVM message header and payload. Specifically when a portion of the received GVM data message e.g. its physical e.g. L3 or L4 header values or its logical e.g. VNI header values is hashed along with the payload through an ICV operation by the encryptor the decryption operation verifies this portion to validate the authenticity and integrity of the encrypted GVM data message.

After decrypting the GVM data message at the process at sends the decrypted GVM data message along its datapath. In some embodiments this operation entails returning a communication to the SFE port that called the decryptor to initiate the process to let the port know that the decryptor is done with its processing of the GVM data message. The SFE port can then handoff the GVM data message to the destination GVM or can call another I O chain operator to perform another operation on the GVM data message. After the process ends.

When the process determines at that the encryption cache does not store an encryption rule for the received GVM data message the process searches the encryption rule data store to identify an encryption rule that matches the message attribute set identified at . If the process cannot find an encryption rule that identifies a key and the GVM data message is encrypted e.g. as specified by field in the message the process in some embodiments initiates an error handling process to resolve the unavailability of a decryption key for decrypting the encrypted message. This error handling process in some embodiments queries the network agent to determine whether it or the controller set stores an encryption rule for the message attribute set identified at . When the agent has such an encryption rule it provides it to the process at . However in other embodiments the error handling process does not contact the network agent to obtain the key. Instead it just flags this issue for an administrator to resolve.

Assuming that the process identifies at an encryption rule that identifies a key the process at retrieves a key identifier from the identified rule uses this identifier to retrieve a key from the key data store and decrypts the received GVM data message with the retrieved key. In some embodiments part of the decryption operation at is to authenticate an ICV generated hash of the GVM message header and payload. Specifically when a portion of the received GVM data message e.g. its physical e.g. L3 or L4 header values or its logical e.g. VNI header values is hashed through an ICV operation along with the payload by the encryptor the decryption operation verifies this portion to validate the authenticity and integrity of the encrypted GVM data message.

After decrypting the GVM data message the process at sends the decrypted GVM data message along its datapath. In some embodiments this operation entails returning a communication to the SFE port that called the decryptor to initiate the process to let the port know that the decryptor is done with its processing of the GVM data message. The SFE port can then handoff the GVM data message to the destination GVM or can call another I O chain operator to perform another operation on the GVM data message.

After the process transitions to where in the encryption cache data store it creates a record to specify that decryption key that should be used to decrypt GVM data message with message attribute sets that are similar to the set identified at . In some embodiments this record is addressed in the cache based on a hash value of the message attribute set identified at . After the process ends.

For GVM data messages that are encrypted based on dynamically detected events e.g. dynamically detected connection sessions the GVM data messages in some embodiments include a key identifier that identifies the encryption key that was used to encrypt the message or the decryption key that should be used to decrypt the message. Some embodiments use a symmetric encryption scheme in which the same key is used to encrypt and decrypt the message or transposed versions of the same key are used to encrypt and decrypt the message. In these embodiments the GVM data message can be marked with the encryption key identifier or the decryption key identifier as the encryption and decryption keys are identical or related.

As shown the process initially extracts at the key identifier from the received GVM message. Next the process uses at the key identifier to retrieve a key from the key data store and then uses at this key to decrypt the received GVM data message. As mentioned above part of the decryption at is to authenticate the ICV generated hash of the received GVM data message s header and payload that is encrypted with the payload of the GVM data message. After decrypting the GVM data message the process sends at the decrypted GVM data message along its datapath. In some embodiments this operation entails returning a communication to the SFE port that called the decryptor to initiate the process to let the port know that the decryptor is done with its processing of the GVM data message. The SFE port can then handoff the GVM data message to the destination GVM or can call another I O chain operator to perform another operation on the GVM data message. After the process ends.

By applying fine grained encryption policies the encryption architecture of can easily achieve a variety of different encryption scenarios. For instance it can encrypt differently the data messages for different GVMs that execute on the host. This architecture can also differently encrypt the data messages exchanged between the GVMs of different logical networks in a data center that provides different logical networks to different users e.g. different departments different tenants etc. on shared a network infrastructure. This hypervisor based architecture can also encrypt different types of data messages from the same GVM differently. Through guest introspection it can gather malware data application centric data and contextual data and use this information to detect security events or other types of events. Once such events are detected it can then dynamically provide the encryptors with encryption rules necessary for performing on demand attribute based encryption of the GVM data messages.

Accordingly the two secure connections between GVM and GVMs can differ because they are established through two different keys. They can also differ by the different type of encryption operation that is performed for each connection. For instance the secure connection between GVMs and might be an L2 secure connection where L2 header and payload are encrypted while the secure connection between GVMs and might be an L4 secure connection where L4 header and payload are encrypted .

It might be beneficial to differently encrypt the GVM messages that GVM exchanges with GVMs and because the GVMs and might be used by different entities with which the GVM should have different secure connections. Also the GVMs and can be different types of machines e.g. one can be a webserver while the other is a database server that require different secure connections with the GVM . In fact the secure connections between the two different pairs of machines might need to be two different types of connections e.g. an L2 secure connections versus an L4 secure connections .

To illustrate the concept of logical network constructs illustrates an example of several logical switches that are defined by multiple software switches that execute on multiple hosts. Specifically this figure illustrates eight GVMs GVM to GVM that execute on two hosts and which include two software switches and respectively. As shown the two software switches and implement three logical switches and that connect three sets of GVMs for three different entities e.g. three different tenants . Logical switch connects GVMs and of host and GVM of host logical switch connects GVM of host and GVM of host and logical switch connects GVMs and of host and GVM of host .

In hypervisors software switches are sometimes referred to as virtual switches because they are software and they provide the GVMs with shared access to the PNIC s of the host. However in this document software switches are referred to as physical switches because they are items in the physical world. This terminology also differentiates software switches from logical switches which are abstractions of the types of connections that are provided by the software switches. There are various mechanisms for creating logical switches from software switches. VXLAN provides one manner for creating such logical switches. The VXLAN standard is described in Mahalingam Mallik Dutt Dinesh G. et al. 2013 05 08 VXLAN A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks IETF.

As mentioned above the encryption architecture of can also implement fine grained flow based encryption rules. To illustrate this capability illustrates an encryption scenario in which two different flows between the same pair of GVMs are encrypted differently. In this example the encryptor encrypts a first flow between GVMs and differently than a second flow between these GVMs. In some cases the encryptor just uses different keys to encrypt these two different flows. In other cases the encryptor uses different encryption schemes for these flows e.g. an L2 encryption scheme for one flow and an L4 encryption scheme for another flow or a first encryption algorithm for one flow and a second encryption algorithm for the other flow .

To identify the different encryption rules for the different flows the encryptor in some embodiments uses each flow s L2 L4 header values to identify an encryption rule with a matching attribute set. In some of these embodiments the source port identifier helps differentiate two flows that have otherwise identical header values. In other words the source port identifier can serve to distinguish two different connection sessions between two GVMs.

Also as mentioned above the event detecting SVM detects one or more events relating to the flows and in response has the encryption agent insert or remove encryption rules from the rule data store . As mentioned above the event detecting SVM obtains real time guest introspection GI data in order to detect one or more events relating to the flows so that it can start the process for the insertion of the encryption rules.

As further discussed above the malware detecting SVM obtains GI data in order to detect malware on the GVMs. Upon detecting malware this SVM assigns the appropriate malware tag to the GVM in a data store that it maintains. In response to this tagging the encryption agent pushes encryption rules into the encryption data store that cause the encryptor set to encrypt the messages sent from the infected GVM and or to encrypt the messages sent from other GVMs on the same host as the infected GVM.

The first stage in shows the packets of the GVM on a host being sent out without being encrypted. The second stage then shows that the SVM detects malware on GVM . In response to this detection the SVM identifies in its data store the GVM as being infected. Once the encryption agent notes this designation it pushes an encryption rule into the data store to designate that messages sent from GVM have to be encrypted. In some embodiments this encryption rule is indexed based on one or more attributes of the GVM e.g. its IP address its MAC address etc. .

The third stage then shows that because of this encryption rule the encryptor encrypts the data messages sent from the GVM . When a GVM is infected with malware it is useful to have its outgoing messages encrypted in case the malware gathers data from the GVM and sends this data to undesired destinations.

In the first two stages and are identical to the first two stages and of . However in response to the malware detected in the second stage of encryption policies that direct the behavior of the encryption agent in the event of an infected GVM direct the encryption agent to push one or more encryption rules into the data store to designate that messages sent from all uninfected GVM on the same host to be encrypted. In some embodiments each such encryption rule is indexed based on one or more attributes of the uninfected GVMs.

The third stage of then shows that because of the encryption rule s the encryptor encrypts the data messages sent from the GVM that is on the same host as the GVM . When a GVM is infected with malware it is useful to have messages sent from the other GVMs encrypted in case the malware tries to access the data of the uninfected GVMs through the share infrastructure e.g. in the host memory or disk storage .

As shown this process starts at when the SVM receives the GI data from a thin agent that is installed in a GVM. Next the process determines at whether the received GI data indicates that the GVM has been infected by malware. Any of the common anti virus techniques that are used to detect the existence of malware can be used to perform the malware detection at . In fact the malware detecting SVM in some embodiments is a commercially available third party SVM that scans GVMs in a hosted environment for malware. In some embodiments examples of these third party SVMs are SVMs that operate with the vShield Endpoint framework that is provided for the ESX hypervisor environment by VMware Inc.

When the received GI data does not indicate the existence of malware the process ends. On the other hand when the process determines at that the received GI data indicates the existence of malware the process assigns a malware tag to the GVM in the GVM security designation data store and then ends. In some embodiments the process assigns one of several different security tags based on one of several different levels of potential security conditions that it detects based on its analysis of the received GI data. In some embodiments some of these different security tags indicate different levels of confidence in the SVM s security assessment. In these or other embodiments some of the different security tags indicate different detected security conditions.

The process of conceptually illustrates a sequence of operations that the encryption agent processor performs in some embodiments. The processor performs this process each time that it detects a new security tag for a GVM that is executing on the processor s host. In some embodiments the processor detects this tag when it is called by the malware detecting SVM . In other embodiments the processor detects this tag because it gets a callback for which the processor previously registered from the security designation data store . In still other embodiments the processor periodically scans the security designation data store to identify security tags that have recently been added or modified for a GVM.

As shown this process starts a when the encryption agent processor detects a new security tag for a particular GVM that is executing on the processor s host. Next the process determines at whether one or more encryption rules need to be specified to address the detected security condition on the particular GVM. To make this determination the encryption agent processor examines its encryption rule data store to determine if it already contains the needed encryption rule s and if not then it examines the encryption policies that it stores in its policy data store in some embodiments. In other embodiments the processor makes the determination at by relaying the security tag to the virtualization controller set and having the virtualization controller set determine whether one or more encryption rules need to be specified. In still other embodiments the processor initially checks its own rule data store and or policy data stores for a newly detected security tag and only contacts the virtualization controller set for this tag when it does not have an encryption policy for this tag. In yet other embodiments the processor only checks either the rule data store or the policy data store for a newly detected security tag. For instance in some embodiments the processor does not have an encryption policy data store as encryption policies are not stored on the host. In some of these embodiments the processor only checks at its encryption rule data store when a new security condition is detected.

Also in some embodiments that employ multiple different security tags to specify multiple different security conditions the encryption policies of either the data store or the virtualization controller set may dictate GVM data message encryption for some of the security tags but not other security tags. This is because some of the security tags indicate security conditions that are severe enough to warrant the encryption of the GVM data messages while other security tags do not.

When the process determines at that it does not need to specify one or more encryption rules to address the newly detected security condition of the particular GVM the process ends. On the other hand when the process determines at that it needs to specify one or more encryption rules the process creates at the encryption rule s stores at the encryption rule s in its encryption rule data store and then ends. From the encryption rule data store any newly stored encryption rule gets published by the encryption rule publisher to the encryption rule data store s of any encryptor decryptor that has to enforce the rule as mentioned above.

Some embodiments encrypt the data messages of an infected GVM upon detecting its infection and or encrypt the data messages of other GVMs on the same host as the infected GVM after detecting the infection. To encrypt data messages from the infected GVM the process creates at encryption rule s that direct the infected GVM s encryptor to encrypt the GVM s data message. To encrypt data messages from the other GVMs on the same host as the infected GVM the process creates at encryption rule s that direct the encryptor s of the other GVM s to encrypt the data messages from the GVM s . As mentioned above each generated encryption rule in some embodiments identifies its encryption process and or its encryption key. Each encryption rule also has a rule identifier set that contains one or more header values that uniquely identify the GVM with the data messages that have to be encrypted.

The network introspector provides the captured connection sessions and their associated contextual metadata to the flow based event detecting SVM . In some embodiments the SVM then examines its configuration and cache stores to determine at whether the captured event is an event for which it should provide a notification to the encryption agent and if so whether it has previously provided such a notification to the encryption agent .

When the SVM determines that the received event data does not need to be reported the process ends. On the other hand when the SVM determines that the received event data has to be reported the SVM notifies at the encryption agent of the received flow based event and then ends. The agent then examines the encryption policies that it or the virtualization controller set maintains to determine whether it or the virtualization controller set needs to create and push encryption rule s to the encryption data store to address the detected flow based event. When encryption rule s are pushed the encryptor set then encrypts the data messages related to the detected flow based event by using the key s specified in the rule s .

The process of conceptually illustrates the operation of the encryption agent processor each time that the SVM reports a new flow based event. As shown this process starts at when the encryption agent processor receives a new flow based event from the SVM . Next the process determines at whether one or more encryption rules need to be specified to address the detected event for the particular GVM on which the flow based event was detected. To make this determination the encryption agent processor examines its encryption rule data store to determine if it already contains the needed encryption rule s and if not then it examines the encryption policies that it stores in its policy data store in some embodiments. In other embodiments the processor makes the determination at by relaying the event data to the virtualization controller set and having the virtualization controller set determine whether one or more encryption rules need to be specified. In still other embodiments the processor initially checks its own rule data store and or policy data stores for a newly detected event and only contacts the virtualization controller set for this event when it does not have an encryption policy for this event. In yet other embodiments the processor only checks either the rule data store or the policy data store for a newly detected event.

When the process determines at that it does not need to specify one or more encryption rules to address the newly detected event on the particular GVM the process ends. On the other hand when the process determines at that it needs to specify one or more encryption rules the process creates at the encryption rule s stores at the encryption rule s in its encryption rule data store and then ends. From the encryption rule data store any newly stored encryption rule gets published by the encryption rule publisher to the encryption rule data store s of any encryptor decryptor that has to enforce the rule as mentioned above. Each generated encryption rule in some embodiments identifies its encryption process and or its encryption key. Each encryption rule also has a rule identifier set that contains one or more header values that uniquely identify the flow associated with the detected event that has to be encrypted.

The encryption architecture leverages guest introspection to identify security and non security events to create context aware logical private networks. As described above by reference to guest introspection provides information about sensitive data the applications and the users accessing them and the timing and manner of the data flows in the network. This GI enabled encryption architecture identifies the endpoints between which the network traffic needs to be secured provides a way to isolate the traffic cryptographically and protects the traffic from other machines that share the common network and compute infrastructure.

Guest introspection e.g. its network introspector provides connection data to the event detecting SVM which in turn relays this information to the encryption agent . Guest introspection e.g. its file and systems introspectors and also provides file and system data to the malware detecting SVM which in turn defines the security posture of the GVMs. For a defined security posture e.g. an infected machine the encryption agent might supply the encryptor set with one or more encryption rules that require this set to encrypt the data messages of the infected machine and or of all the GVMs that operate on the same host as the infected machine.

In some embodiments the security postures are provided through a hypervisor based framework that allows SVMs from different vendors to gather GI data from the GVMs that operate on the hypervisor and provide security tags that define the security posture of these GVMs. Using the security tags applied on a GVM a third party SVM can provide information about what it detects on the GVM in order to allow other security modules to take action with respect to the GVM. For instance if an SVM s antivirus scan detects the presence of malware on GVM that the SVM is unable to clean the SVM can tag the GVM as infected. A firewall agent or SVM that operates on the hypervisor can then act on this tag and network quarantine the infected GVM. Similarly the encryption architecture can act on this tag to encrypt the messages of the infected machine and or of all others GVMs on the same host.

The network controller set includes one or more controllers that define logical overlay networks in a multi tenant environment in which multiple tenants share common compute host and network infrastructure in a datacenter. The logical networks can be thought of as networks connecting users and applications isolated from the physical switches and routers. For applications these networks can provide point to point connections. They can be L2 L3 or L4 networks with two or more endpoints.

By using fine grained encryption policies these logical networks can be made into logical private networks LPNs . Each LPN can have one or more micro segments and each micro segment can each be secured based on a specific security policy for that micro segment. For instance some embodiments encrypt connections between web servers and app servers of a logical network by using a first encryption key and a first encryption process while encrypting connections between the app servers and database servers of the logical network by using a second encryption key and a second encryption process. Some of these embodiments identify the different encryption processes and different keys for the different network segments based on different header portions of the GVM data messages exchanged between the GVMs of these network segments. For example some segments can be identified based on L2 and L3 parameters only while other segments can be identified based on L4 parameters.

In some embodiments the LPN are established by using Encapsulating Security Payload ESP frame format. ESP is a security encapsulation that provides privacy integrity non repudiation and authenticity of the payload. ESP protocol contains a Security Parameters Index SPI field that can uniquely identify the security properties of the LPN e.g. SPI identifies the encryption key for the destination of a GVM data message . ESP is widely used in IPSec inserted between IP and TCP UDP. In some embodiments ESP is inserted in appropriate layers to provide L2 L3 or L4 LPNs. ESP offload is supported by various NICs such as Intel Kawela and Intel Niantic.

In some embodiments the ESP encapsulation uses encryption and authentication to provide data privacy integrity and authenticity. For instance in some embodiments the ESP encapsulation uses AESGCM Galois Counter Mode in 128 bit or 256 bits which provides both encryption and authentication has better performance in contrast to the previous standard AES 128 CBC for encryption and SHAI HMAC for authentication. In some embodiments the ESP encapsulation not only encrypt the payload of the GVM message but also encrypts a hash value that is generated from an integrity check value ICV calculations on the GVM message payload and on some or all of the unencrypted header value e.g. L3 L4 header values or logical network identifier values of the GVM data message. After decrypting the payload along with the ICV generated hash the destination host can then authenticate the GVM data message by authenticating the hash value for the GVM data message s header value and payload.

In some embodiments the logical overlay and security encapsulation e.g. the ESP encapsulation is performed by the encryptor set which as mentioned above captures the traffic originating from a GVM. Through the LPN controller the security policies and specifications e.g. as encryption algorithm and key size are provided by the LPN manager of the network manager while the encryption is done by the encryptor set . For VXLAN overlay network the LPNs can secure L2 e.g. the encryption rules are selected based on L2 parameters . For traffic between a web server and a database server the LPNs can secure L4 e.g. the encryption rules are selected at least partially based on L4 parameters . Accordingly the encryptor set in some embodiments captures the outbound traffic of the GVM applies the appropriate security policy and encrypts the traffic. For incoming traffic on the destination GVM the encryptor set in some embodiments terminates the security overlay encapsulation.

In some embodiments the encryptor set is also responsible for authenticating the GVM VNICs with the LPN controller to restrict the member subscription into an LPN. In some embodiments an encryptor decryptor will be inserted for all VNICs on all the GVMs on each hypervisor. When the encryptor decryptor is inserted on a VNIC the encryptor decryptor registers certain information e.g. the VNIC information VM identifier host identifier etc. with the LPN controller . The encryptor agent in some embodiments is a user space daemon that acts on behalf of the encryptor set to communicate with the LPN manager the network controller s and the key manager s .

In some embodiments an LPN controller in the network controller manages multiple LPNs in a datacenter. In some embodiments that use more than one network controller each network controller controls a different set of logical networks and its LPN controller configures the encryption within the logical networks of its network controller . The LPN controller is responsible for authenticating and providing configuration information to the encryptor set . When the key needs to be rotated for an LPN the LPN controller ensures that all the encryptor sets on all of the LPN s hosts are synchronized. The LPN controller distributes keys to the encryptor set if a key manager is not available e.g. in a deployment that does not use a key manager appliance or is not accessible by the encryption agent e.g. because of firewall configurations etc . When the key manager is not accessible the LPN Manager in some embodiments fetches the keys and distributes them to the encryption agent through the LPN controller.

If required the LPN controller can send kill commands to an encryptor set to destroy the key material and sink all sensitive traffic. In some embodiments the LPN controller sends the kill commands at the direction of the LPN manager . When an LPN manager determines that a specific host has been compromised to a particular extent that would require its operations to be temporarily halted the LPN Manager can send the kill command to that host s encryption agent through the LPN controller . Through this controller the LPN manager also sends a kill command to a host when the LPN manager determines that the compute cluster or the datacenter in which the host operates is under severe attack so as to not be trustworthy anymore. On receiving the kill command from the LPN controller the encryption agent sets up a policy to sink all the network traffic and propagates rules regarding the same to the encryptors . These rules cause the agent and or encryptors to purge the keys that are being used and cause the encryptors to drop the GVM data messages to prevent the network traffic from flowing.

The LPN manager collects the statistics from the host encryptor agents which collects these statistics regularly from the encryptor sets of the hosts. The LPN manager in some embodiments allows a security administrator to define security policies and specifications e.g. as encryption algorithm and key size . The network manager includes a policy engine that assists the LPN manager with these operations. In some embodiments the LPN manager offloads the management of the keys to the key manager s while it maintains the security credentials to access the keys. The LPN manager in some embodiments creates the keys required for an LPN on the designated key manager as per the defined security policies but has the key manager set as the resource from which the host encryption agents pull the keys.

In some embodiments the key life cycle management is performed by the LPN manager . The key life cycle includes various states which in some embodiments includes pre active active deactivated compromised destroyed and destroyed compromised. These states are described in Management Interoperability Protocol Specification Version 1.2. Edited by Kiran Thota and Kelley Burgin 9 Jan. 2014 OASIS Committee Specification Draft 01 Public Review Draft 01. This specification can be found on the Internet.

As further described below the LPN manager creates a key ring with multiple active keys for an LPN e.g. for one tenant in a multi tenant datacenter . In some embodiments the LPN manager is responsible for the key rotation operation that adds new active keys to an LPN s key ring or remove keys that need to be inactive from the LPN s key ring. In other embodiments the key rotation responsibility is offloaded to the LPN controller as further described below. However even in some of these embodiments the LPN Manager will decide when to rotate the key but will offload the key rotation commands to the LPN Controller while passing it the key identifier s .

While the key life cycle management is performed by the LPN manager in some embodiments one of ordinary skill will realize that in other embodiments the key manager s perform this operation. The key manager set includes one or more key managers. In some embodiments a key manager is an enterprise key manager KM appliance e.g. a hardware appliance or software module hardened for security and it is responsible for storing and managing a large number of keys. When the encryption system is used in a multi tenant datacenter several different key managers provide key management operations for several different tenants in the datacenter. In other words each of several different tenants has their own unique set of one or more key managers that the tenant does not share with any other tenant. In some embodiments however one key manager might be shared between multiple tenants.

In some embodiments a key manager specifies constructs and mechanisms to define groups of keys for manageability and provides various security controls e.g. access control and authentication to access keys. In some embodiments the authentication mechanisms include public key infrastructure PKI certificates username password and shared secrets. PKI is a type of key management system that uses hierarchical digital certificates to provide authentication and public keys to provide encryption. PKI binds public keys with respective identities by means of certificate authority CA . The user identity is unique in each CA domain.

The key manager of some embodiments also enforces attestation of the requester to address the malicious requester threats. In some embodiments the key managers use Key Management Interoperability Protocol KMIP interface as the communication protocol between key management systems and encryption systems. The key managers use this protocol for allowing the encryption controllers managers to manage keys to manage key life cycles and to register clients. More information about the KMIP can be found in publicly distributed document Key Management Interoperability Protocol Specification Version 1.2. Edited by Kiran Thota and Kelley Burgin 9 Jan. 2014 OASIS Committee Specification Draft 01 Public Review Draft 01. This specification can be found on the Internet.

In some embodiments the key manager set manages all the keys for one or more entities e.g. tenants companies departments etc. . Each key is identified by the universally unique identifier UUID generated by the key manager set when the key is created. The LPN controller associates an SPI with each key and informs the encryption agents of the mapping information. The encryptor set has a set or ring of active SPIs the ring size is small for smaller deployments and large for larger deployments. The ring size affects the latencies involved in coordinating a large number of endpoints within the LPN. For a ring of size r keyring 0 r has r I entries of which r are active. Given the latest key key key rotation removes keyfrom the keyring and marks keyas the latest. In some embodiments key rotation process entails the following three steps.

1. The LPN controller directs each encryption node a to prefetch key the latest key from the key manager and b to receive traffic with keys from keyring o r 1 but transmit using only keys from keyring 1 r 1 i.e. without the key to be removed . All encryption nodes where the encryptor nodes are the encryptors that are associated with an LPN send the LPN controller an acknowledge message. After the keyhas been fetched the nodes place the new key in keyring r slot.

2. The LPN controller tells each node to receive using keys from keyring 1 r and confirm if keyhas been fetched. At this stage the nodes still transmit using keys from keyring 1 r 1 . All nodes send the LPN controller an acknowledge message.

3. The LPN Controller tells each node to transmit using keys from keyring 1 r . All nodes remove the key from keyring 0 . All nodes send the LPN controller an acknowledge message thereby confirming key rotation.

The above described key rotation process provides a reliable mechanism for rotating to a new key in a system that suffers from delay in synchronizing the key switch over of multiple nodes. This delay can be substantial e.g. many minutes or even into hours when the number of nodes is very large. Thus this mechanism provides a scheme for maintaining an old key as a viable key in the keyring for receiving traffic until all the nodes can confirm receiving the new key that will take the place of the old key in the keyring.

At any time the goal is to have a single key that is considered good but the keyring can include multiple other keys for an LPN to use. One benefit of having multiple potential keys is that the encryption system might have to changes keys at a rate faster than the rate that new keys can be added in a stable manner to the keyring for the LPN. For instance the LPN key might have to be changed after 10 minutes e.g. because a threshold amount of data such as 1 terabytes of data have been encrypted with the current key but it might take 20 minutes to add a new key to the keyring because a very large number of nodes e.g. a 1000 encryptor sets . Thus having extra keys in the keyring would allow the LPN controller to direct the hosts to rotate to a new key in the keyring after the 10 minute period even though it will take the LPN controller 20 minutes to add a new key to the keyring.

In some embodiments the LPN controller directs all the LPN encryptors to use a new key by sending them the SPI for the new key to use where the SPI 1 identifies the key in the keyring of each node and 2 identifies for the destination of an encrypted GVM data message the key that was used to encrypt the message. Alternatively the LPN controller directs all the LPN encryptors to jump to the next key in their keyrings.

In some embodiments the encryption architecture has several features and operations to ensure its security. First in some embodiments the guest agent integrity is ensured by a userworld process in the hypervisor. The userworld process checks that the guest agent has been loaded code memory pages unmodified and prevents attempts to tamper with the code by leveraging APIs to read write guest memory installing memory traces for read write execute and accessing guest CPU registers and state.

Second in some embodiments the encryptor set and encryption agent are packaged together and installed on the hypervisor together. In some embodiments a package integrity mechanism provides the software integrity guarantee and authenticity guarantee they are signed packages . Third through the encryption agent the encryptor set registers the VNIC identifier the GVM identifier the host identifier and other information with the LPN controller in some embodiments. The LPN manager in turn confirms with the compute inventory to make sure that the GVM and VNIC are indeed running on the specified host. In some embodiments the LPN manager also confirms the encryptor set authenticity based on the host s certificate e.g. host SSL certificate thumbprint .

Fourth in some embodiments the encryption agent communicates with key manager set the LPN manager and the LPN controller by using client server authentication processes e.g. SSL TLS processes . These processes authenticate the agent manager s and controller and encrypt messages between these authenticated modules.

Fifth in some embodiments the encryption agent fetches the key from the key manager only when required. In some embodiments the encryptor set stores the key only in memory e.g. in volatile memory and not on disk and periodically refreshes the key from the key manager as specified in the key management policy. When the encryptor set is removed from a VNIC the key in some embodiments is zeroed in memory and it unregisters with the LPN manager . The encryptor set is typically removed from a VNIC on a host when its associated GVM powers down or when the GVM migrates to another host.

Sixth to prevent the traffic from cryptanalytic attacks the keys are rotated in some embodiments. In some embodiments the key rotation is performed periodically. In other embodiments the key rotation is based on the amount of data that was encrypted by using a particular key e.g. is rotated after a terabyte of data is encrypted with the current key . When the encryption key usage that is collected by the LPN controller shows that the usage has exceeded a threshold amount the LPN controller in some embodiments performs the key rotation operation.

It should be noted that key rotation is different than refetching keys. Key rotation involves changing the encryption key for an LPN while refetching is fetching the same key. As mentioned above the LPN controller directs the encryptors of an LPN to switch to a new key in their keyrings by providing the SPI for the new key to use or by directing them to use the next key in their keyrings. The LPN controller might perform this action after noting that a threshold amount of data e.g. 1 terabytes of data has been encrypted with the current key.

On the other hand a key is refetched in some embodiments when the encryption agent on the hypervisor is reloaded or is programmed to fetch the same key periodically e.g. every day so that the audit logs on the key manager show the continued usage of this key. This is because in some embodiments when a VM powers down the key is destroyed by encryption agent but the Key Manager is not informed that the key is no longer in use.

As shown in the workflow starts with the security administrator incorporating a key manager in the network management system. This incorporation involves the pairing of the LPN manager with its associated key manager. When a tenant has multiple key mangers this pairing has to be done between the LPN manager and multiple key managers . shows that the pairing process starts with the security administrator directing the LPN manager to generate a certificate authority CA for itself and then registering this CA certificate with the key manager . As part of this registration the security administrator also obtains the key manager credentials e.g. from the key manager after registering the LPN manager credentials with the key manager and then registers these credentials with the LPN manager . In some embodiments the key manager credentials include one or more of the following key manager IP address the key manager port to access a public key infrastructure PKI certificate username password shared secrets etc. as mentioned above.

The LPN manager then sends a KMIP query request to its configured key manager to determine its capabilities and or protocol mechanisms. In response to this query the LPN manager obtains a KMIP query response that provides the requested information. As shown once the LPN manager has the key manager capabilities the security administrator can then direct the LPN manager to create security policies and assign security policies to security groups. Through the KMIP interface the LPN manager can then direct the key manager to create keys for the members of the security groups as shown.

Security groups can be initially empty. In some embodiments membership to the security groups can be statically or dynamically defined. Guest introspection allows grouping of GVMs into various security groups based on dynamically changing attributes such as user identity application context and or security posture of the GVM. Examples of such security groups include 1 GVMs with users logged on from the Finance group 2 GVMs running Apache server 3 GVMs containing malware 4 GVMs running on hosts with a GVM that has malware 5 GVMs containing sensitive HIPAA patient data etc.

As further shown the following events in some embodiments trigger updates to the security membership depending on the attributes used to define the groups 1 a user login logout event 2 an application initiating a connection 3 an application listening on a particular port and 4 a change in the security posture of a GVM e.g. whether it is tagged as having malware known vulnerable software sensitive data etc. .

In other words after detecting an event the encryption agent reports this event to the LPN manager and examines its encryption policy and rule data stores and to determine whether it has one or more encryption rules for the detected event. If so it pushes this rule to the LPN encryptor . In response to the reported event the LPN manager reports the event to the LPN controller which then determines whether it needs to push new encryption policies and or rules to the encryption agent to resolve the detected event. If so the LPN controller pushes the encryption rules and or policies to the agent which then pushes one or more encryption rules to the LPN controller to address the detected event.

Once GVM is moved to a security group the security policies including the encryption policy associated with that group are automatically applied to the traffic sent from and received for the GVM. When a GVM is powered on the encryptor set registers the VNIC with the LPN controller via the encryption agent . The LPN controller examines its data store to determine whether the GVM has been assigned a security policy based on its security group membership. If a security policy is found the LPN controller passes the corresponding security group configuration and encryption policy information to the encryption agent which then uses this information to push the correct encryption rules to the encryptor set s encryption rule data store in order to allow the encryptor set to enforce the security policy for this GVM. As mentioned above the LPN controller provides updated configuration and encryption policy information to the encryption agent when the security group membership dynamically changes.

When a GVM is booted up or is migrated to this host the encryptor is added to the chain of I O operations for appropriate VNICs. The encryptor gathers the details from the VNIC and logical switch and send the LinkUP message to the encryption agent. The encryptor set then asks the encryption agent for key information when it receives a GVM message that is sent from the booted up GVM to another GVM. In response the encryption agent asks the LPN controller to authenticate the endpoint i.e. to authenticate the VNIC of the GVM and provide key manager credentials and the lookup tables. Upon receiving key manager credentials and the lookup tables the encryption agent contacts the key manager specified by the LPN controller and obtains the needed key. The encryption agent then passes the requested key s to the encryptor set e.g. in a lookup table that includes the key s .

As shown the encryption agent periodically or on demand sends the encryptor set with Get Info requests in order to retrieve statistics from the encryptor set about its operation. The encryption agent then passes these statistics to the LPN controller and based on these statistics the LPN controller sends updates to the encryption agent which relays these updates to the encryptor set . In some embodiments the encryption agent periodically gathers statistics from the encryptor set and passes the statistics to the LPN controller in order to allow this controller to start the dynamic key rotation operations which were described above. In other words the stat gathering and update mechanism of is used in some embodiments to rotate keys.

As mentioned above the LPN manager also periodically or on demand collects statistics that the encryption agent gathers from the encryptor set . The LPN manager uses these statistics to visually represent the health of the LPN to the administrator user and the statistics can be displayed or provided as responses to REST APIs for various third party solutions which determine the network capacity optimizations etc. e.g. to optimize performance by moving around GVMs . The LPN manager is the single point of interaction for the administrators to define LPNs to check the health status green yellow red to provide any remediation and to perform troubleshooting debugging etc.

Two exemplary deployments of the context aware network encryption of some embodiments will now be described. The first example involves a software defined datacenter SDDC for a hospital. This datacenter has numerous users who may be part of different Active Directory groups such as Doctors and Nurses. The datacenter also runs the hospital Epic servers that store confidential patient data. In this system the administrator deploys security solutions to detect malware vulnerable software and sensitive HIPAA patient data on GVMs.

1. Security Policy 1 Only Doctors and Nurses can access patient data on Epic servers. All such accesses must be via secure and encrypted channels.

3. Security Policy 3 GVMs diagnosed with a virus or known malware risk level higher than medium must have all traffic dropped.

4. Security Policy 4 GVMs with confidential patient data on their disks that violates HIPAA policy must have all traffic encrypted.

6. Security Policy 6 GVMs with vulnerabilities of CVSS score higher than 8 must have all incoming and outgoing traffic dropped.

In order to comply with the aforementioned security policies the security administrator goes through the following process 

1. Create Security Group Doctors with dynamic membership criteria so that any GVM with a doctor logged on it becomes a member and drops out of membership when the doctor logs out.

2. Create Security Group Nurses with dynamic membership criteria so that any GVM with a nurse logged on it becomes a member and drops out of membership when the nurse logs off.

3. Create Security Group Epic Servers with dynamic membership criteria so that any GVM running Epic application and listening on a particular port becomes a member.

4. Create Security Group UnsecuredVMs with dynamic membership criteria based on the security tag HIPAA violation on a GVM.

5. Create Security Group Quarantine with dynamic membership criteria based on the security tags Vulnerable.CVSS 8 MalwareFound.Medium or MalwareFound.High on a GVM.

When an Epic application is initiated on a GVM the GVM becomes part of the Epic Servers security group. When a doctor or nurse logs on to a GVM it becomes a member of the Doctors Nurses security group. When the doctor or nurse tries to access the Epic server the appropriate security policy is enforced and the traffic is encrypted as defined by the policy. Similarly if a regular scan of the GVM detects HIPAA data on it the GVM is automatically moved to the UnsecuredVMs SG and all traffic to and from that GVM is encrypted. In this hospital system attributes can be used to trigger context aware network encryption in various scenarios. For instance it can be extended to the granularity of a single connection i.e. encryption decision can be made per connection based on the attributes of each individual connection such as initiating application .

The second example involves an SDDC for an online shopping place WonderDiapers.com. This datacenter uses a typical three tier web application deployment that runs webservers Web application App servers and database DB servers. The database servers contain sensitive credit card information. The administrator deploys security solutions to detect malware vulnerable software and the sensitive PCI data on these database GVMs.

1. Security Policy 1 Only the Database Administrator can access DB servers. All such accesses must be via secure and encrypted channels.

4. Security Policy 4 GVMs with confidential PCI data on their disks that violates PCI policy must have all traffic encrypted.

5. Security Policy 5 GVMs diagnosed with a virus or known malware risk level higher than medium must have all outgoing traffic dropped.

6. Security Policy 6 GVMs with vulnerabilities of CVSS score higher than 8 must have all incoming and outgoing traffic dropped.

In order to comply with the aforementioned security policies the security administrator goes through the following process 

1. Create Security Group Web with dynamic membership criteria so that any GVM that runs the Apache webserver application becomes a member.

2. Create Security Group App with dynamic membership criteria so that any GVM that runs data processing applications becomes a member.

3. Create Security Group DB with dynamic membership criteria so that any VM that runs Oracle database becomes a member.

4. Create Security Group DBAdmin with dynamic membership criteria so that any GVM with a user that belongs to the Database Administrator Group logged in becomes a member and drops out of membership when the administrator logs off

5. Create Security Group Quarantine with dynamic membership criteria based on the security tags Vulnerable.CVSS 8 MalwareFound.Medium or MalwareFound.High on a GVM.

At initial deployment the administrator deploys the Apache Webserver on several GVMs. Since the GVMs arc running the Apache application they become part of the Web Security Group. Similarly the App and DB Security Groups are populated when the three tier deployment is completed. At this point all App to DB traffic is automatically encrypted due to the policies above. Similarly all Web to App Security Group communication is encrypted. Also apart from the Web Security Group members the DB Security Group can only be accessed by a DB administrator. Any other user trying to access members of the DB Security Group will see that these requests are dropped.

At this point normal operations are in progress. Assume now that the deployed version of Apache on one of the webservers has known vulnerabilities with CVSS scores greater than 8. When the vulnerability scan runs weekly the vulnerability is detected the GVM is tagged with the Vulnerable.CVSS 8 tag. The particular Webserver is then moved to the Quarantine Security Group and it can no longer send or receive traffic. Similarly assume that high risk malware is detected on one of the Webservers. Again this particular Webserver GVM is tagged with the MalwareFound.High tag and is automatically moved to the Quarantine Security Group and is cordoned off for all network access.

To illustrate the dynamic addition of GVMs to security groups and the associated dynamic application of encryption rules to the security groups to the GVMs two example processes will now be described by reference to . illustrates a process that various components of the encryption system of some embodiments performs to dynamically add an infected GVM to a malware security group and to dynamically encrypt the data messages from this GVM based on the security group s encryption rule. After the malware infection has been resolved this process dynamically removes the GVM from the malware security group and stops encrypting its data messages as the group s encryption rule is no longer applicable to the GVM.

As shown the process starts when the malware detecting SVM detects at malware on a GVM executing on the SVM s host. Next this SVM assigns at an infected tag to the GVM in the security designation data store . Based on this designation the encryption agent processor has at the GVM added to a malware infected security group that this processor or the LPN controller maintains. When the processor maintains this security group s membership the processor in some embodiments adds the GVM s identifier to this membership and notifies the LPN controller to do the same. Otherwise the processor in some embodiments directs the LPN controller to add the GVM s identifier to this group s membership.

Next at the process creates an encryption rule that requires the encryption of the infected GVM s data messages and then pushes this encryption rule to an encryptor along the infected GVM s datapath e.g. pushes the encryption rule data store of the encryptor for the infected GVM . In some embodiments the agent processor pushes this rule by first resolving an encryption policy that it maintains or sending the detected malware event to the LPN controller which either sends this agent an encryption policy to resolve or pushes an encryption rule to this agent after the controller resolved the policy. The policy that is being resolved either by the agent or the LPN controller is a policy that requires the encryption of the data messages sent by a malware infected GVM. After resolving this policy and generating an encryption rule for the malware infected GVM the processor stores the encryption rule in its rule data store from where it is published to the encryption rule data store of the infected GVM s encryptor .

Once this rule is stored in the data store the infected GVM s encryptor encrypts at the data messages from the infected GVM by using the encryption key that is identified in the encryption rule. As mentioned above the encryption processor 1 retrieves from the appropriate key manager the encryption keys for rules that it receives or creates and 2 stores these keys in the key data store from where the keys get published to the encryptor s key data store by the publisher .

At some point a system administrator removes at the malware from the infected GVM. In response the infected tag for this GVM is removed at from the security designation data store manually by the administrator or in an automated manner based on the malware detecting SVM s assessment that the malware infection has been removed. Once the infected tag is removed the GVM is removed at from the malware infected security group by the processor or the LPN controller . Next at the encryption rule that was created and pushed at is removed from the data stores and . In some embodiments the encryption agent processor directs the removal of this rule from these data stores.

The SVM then examines at its configuration and determines that the captured event is an event for which it should provide a notification to the encryption agent processor . For instance the detected event is a login event and the captured contextual metadata might show that a doctor logged into a particular application. When the SVM determines that the received event data has to be reported the SVM notifies the encryption agent processor of the received flow based event.

The processor then examines at the security groups that it or the LPN controller maintains and determines e.g. directly or indirectly through the LPN controller that the detected flow needs to be added to a particular security group. For example the particular security group might be for doctors who logon on to the particular application. Once the detected flow is added to a particular security group the process applies at the security policy of the security group to the detected flow. This application entails the encryption processor or the LPN controller creating encryption rule s to address the detected flow based event and pushing the encryption rule s to the processor s rule data store . From this data store the encryption rule is published at to the encryption rule data store of the encryptor of the GVM at which the flow based event was detected. One example of such an encryption rule would be an encryption rule that specifies a particular encryption process and or encryption key for encrypting messages that are sent for flows relating to a doctor s interaction with the particular application.

Once this rule is stored in the data store the GVM s encryptor encrypts at the data messages from the GVM by using the encryption key that is identified in the encryption rule. As mentioned above the encryption processor 1 retrieves from the appropriate key manager the encryption keys for rules that it receives or creates and 2 stores these keys in the key data store from where the keys get published to the encryptor s key data store by the publisher .

From the network introspector the event detecting SVM at some point receives GI data that indicates the end of the detected flow based event. After detecting the end of the flow based event at the process removes at the encryption rule from the data store of the encryptor of the GVM from which the flow emanated. In some embodiments the encryption agent processor directs the removal of this rule from these data stores. Along with the encryption rule the process in some embodiments removes from the processor s policy data store the encryption policy as well if one such policy was pushed by the LPN controller.

In the above described processes e.g. processes and encryption rules and or policies are sent from the LPN controller to a host s encryption agent . One of ordinary skill will understand that in some embodiments security group membership and or membership updates are sent from the LPN controller to a host encryption agent . For instance in some embodiments the LPN controller sends to a host s encryption agent a security group and an encryption policy that is applicable to the security group. The encryption policy requires a particular encryption for a first type of data flow e.g. the policy requires encryption of data messages exchanged between two machines on which two medical practitioners such as doctors and nurses are logged .

When the LPN controller later determines that an initiated data flow on a particular GVM of the host is a first type data flow e.g. is a flow between a doctor that is using the GVM with a nurse on another host s GVM the LPN controller in some embodiments adds the particular GVM to the security group and notifies the host s encryption agent of the addition of this GVM as a member of the security group. Based on this updated membership the encryption agent processor generates an encryption rule for the encryptor of the particular GVM to use when assessing whether the encryptor should encrypt first flow type data messages from the particular GVM. When the LPN controller or encryption agent processor later determines the end of the detected data flow the particular GVM is removed from the security group and based on this updated membership the encryption rule that was previously provided to the encryptor is discarded in some embodiments. In some embodiments rules and or policies are removed from their respective data stores after a period in which they do not get used.

Many of the above described features and applications are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium also referred to as computer readable medium . When these instructions are executed by one or more processing unit s e.g. one or more processors cores of processors or other processing units they cause the processing unit s to perform the actions indicated in the instructions. Examples of computer readable media include but are not limited to CD ROMs flash drives RAM chips hard drives EPROMs etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.

In this specification the term software is meant to include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments the software programs when installed to operate on one or more electronic systems define one or more specific machine implementations that execute and perform the operations of the software programs.

The bus collectively represents all system peripheral and chipset buses that communicatively connect the numerous internal devices of the computer system . For instance the bus communicatively connects the processing unit s with the read only memory the system memory and the permanent storage device .

From these various memory units the processing unit s retrieve instructions to execute and data to process in order to execute the processes of the invention. The processing unit s may be a single processor or a multi core processor in different embodiments. The read only memory ROM stores static data and instructions that are needed by the processing unit s and other modules of the computer system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instructions and data even when the computer system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device .

Other embodiments use a removable storage device such as a floppy disk flash drive etc. as the permanent storage device. Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments the invention s processes are stored in the system memory the permanent storage device and or the read only memory . From these various memory units the processing unit s retrieve instructions to execute and data to process in order to execute the processes of some embodiments.

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the computer system. The input devices include alphanumeric keyboards and pointing devices also called cursor control devices . The output devices display images generated by the computer system. The output devices include printers and display devices such as cathode ray tubes CRT or liquid crystal displays LCD . Some embodiments include devices such as a touchscreen that function as both input and output devices.

Finally as shown in bus also couples computer system to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the Internet. Any or all components of computer system may be used in conjunction with the invention.

Some embodiments include electronic components such as microprocessors storage and memory that store computer program instructions in a machine readable or computer readable medium alternatively referred to as computer readable storage media machine readable media or machine readable storage media . Some examples of such computer readable media include RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives read only and recordable Blu Ray discs ultra density optical discs any other optical or magnetic media and floppy disks. The computer readable media may store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations. Examples of computer programs or computer code include machine code such as is produced by a compiler and files including higher level code that are executed by a computer an electronic component or a microprocessor using an interpreter.

While the above discussion primarily refers to microprocessor or multi core processors that execute software some embodiments are performed by one or more integrated circuits such as application specific integrated circuits ASICs or field programmable gate arrays FPGAs . In some embodiments such integrated circuits execute instructions that are stored on the circuit itself

As used in this specification the terms computer server processor and memory all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification the terms display or displaying means displaying on an electronic device. As used in this specification the terms computer readable medium computer readable media and machine readable medium are entirely restricted to tangible physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals wired download signals and any other ephemeral or transitory signals.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. For instance while the encryption decryption processes were described above by reference to the host architecture and one of ordinary skill will realize that these processes could be implemented in a variety of different architectures that capture and encrypt decrypt GVM messages at variety of different locations along their egress path out of the host. For instance in some embodiments the encryption decryption processes are implemented in the PNIC of the host. In other words the PNIC of the host in some embodiments examines the GVM messages to determine whether it should encrypt decrypting them before sending them out of the host or sending them to their destination GVMs. In some embodiments the PNIC performs other functions such as defining logical networks e.g. through the user of technologies such as SRIOV .

Also a number of the figures e.g. conceptually illustrate processes. The specific operations of these processes may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process.

Much of the discussion above relates to capturing and encrypting data messages sent from GVMs in a multi VM hosted environment. However one of ordinary skill will realize that the encryption architecture of some embodiments can be used to encrypt and decrypt data messages from any data end node such as storage nodes etc. . Accordingly all of the above described encryption architectures such as the architectures of and the above described processes e.g. of are equally applicable for encrypting and decrypting data messages from arbitrary data nodes in a virtualized environments. Also the architecture of some embodiments can be used to provide other cryptographic services such as signing messages for verification purposes etc. In view of the foregoing one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details but rather is to be defined by the appended claims.

