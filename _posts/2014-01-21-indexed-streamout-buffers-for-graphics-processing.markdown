---

title: Indexed streamout buffers for graphics processing
abstract: A graphics processing unit (GPU) includes an indexed streamout buffer. The indexed streamout buffer is configured to: receive vertex data of a primitive, and determine if any entries in a reuse table of the indexed streamout buffer reference the vertex data. Responsive to determining that an entry of in the reuse table references the vertex data, the buffer is further configured to: generate an index that references the vertex data, store the index in the buffer, and store a reference to the index in the reuse table. Responsive to determining that an entry does not reference the vertex data, the indexed streamout buffer is configured to: store the vertex data in the buffer, generate an index that references the vertex data, store the index in the buffer, and store a reference to the index in the reuse table.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09299123&OS=09299123&RS=09299123
owner: QUALCOMM Incorporated
number: 09299123
owner_city: San Diego
owner_country: US
publication_date: 20140121
---
This application claims the benefit of U.S. Provisional Application No. 61 755 381 filed 22 Jan. 2013 the entire content of which is incorporated herein by reference.

This disclosure relates to stitching of primitives in graphics processing and more particularly to buffering techniques in a graphics processing unit GPU .

A graphics processing unit GPU may implement a graphics rendering pipeline to render image data. The graphics rendering pipeline may include multiple stages comprising programmable units and fixed function units that may operate on vertex data and store the vertex data in one or more different types of buffers. The vertex data may include 3 D coordinates such as x y and z coordinates. The vertex data may also include perspective data and other attributes.

In general the techniques described in this disclosure are directed to implementing an index streamout buffer useful for streaming out vertex coordinates stored in the index buffer. In accordance with the techniques of this disclosure the indexed buffer may receive vertex coordinates for a strip of a particular primitive type. The index buffer of a GPU may receive from a pipeline stage of the GPU a vertex of a primitive to be stored in an index streamout buffer. The index buffer may determine if the vertex is already stored in the index buffer responsive to determining that the vertex is already stored in the index buffer the index buffer may store an index value that references the already stored vertex in the index buffer. Responsive to determining that the vertex is not already stored in the index buffer the index buffer may store the received vertex in the index buffer generate an index value that references the stored vertex and storing the generated index value in the index buffer. The index buffer may be further configured to streamout the stored vertex in the indexed buffer to a pipeline stage of the GPU.

In one example the disclosure describes a method performed by a graphics processing unit GPU comprising receiving by an indexed streamout buffer vertex data of a primitive determining by the indexed streamout buffer if any entries in a reuse table of the indexed streamout buffer reference the vertex data storing by the indexed streamout buffer the index in the indexed streamout buffer and responsive to determining that an entry of the entries currently stored in the reuse table does not reference the vertex data storing by the indexed streamout buffer the vertex data in the indexed streamout buffer and storing by the indexed streamout buffer a reference to the stored index in the reuse table of the indexed buffer.

In another example the disclosure describes a graphics processing unit GPU comprising at least one processor a memory and an indexed streamout buffer. The indexed streamout buffer is configured to receive vertex data of a primitive determine if any entries in a reuse table of the indexed streamout buffer reference the vertex data generate an index that references the vertex data store the index in the indexed streamout buffer and responsive to determining that an entry of the entries currently stored in the reuse table does not reference the vertex data store the vertex data in the indexed streamout buffer and store a reference to the stored index in the reuse table of the indexed buffer.

In another example the disclosure describes a non transitory computer readable storage medium having stored thereon instructions that upon execution cause at least one processor to receive vertex data of a primitive determine if any entries in a reuse table of an indexed streamout buffer reference the vertex data generate an index that references the vertex data store the index in the indexed streamout buffer responsive to determining that an entry of the entries currently stored in the reuse table does not reference the vertex data store the vertex data in the indexed streamout buffer and store a reference to the stored index in the reuse table of the indexed buffer.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

Modern mobile devices such as laptop computer tablet computers smartphones and digital media players may include a CPU Central Processing Unit a graphics processing unit GPU and system memory. When rendering graphics as part of executing an application the CPU may transmit instructions and graphics data to the GPU. In some examples the graphics data may be in the form of vertices which may comprise one or more data structures that describes a point in 2D or 3D space.

The application executing on the CPU may communicate with the GPU in accordance with an application programming interface API . For instance the application may communicate with the GPU in accordance with the DirectX API developed by Microsoft or the OpenGL and OpenGL ES API developed by the Khronos Group as two examples. For purposes of illustration and to ease with understanding the techniques described in this disclosure are generally described in the context of the DirectX and OpenGL APIs. However aspects of this disclosure should not be considered limited to the DirectX and OpenGL APIs and the techniques described in this disclosure may be extended to other APIs as well.

DirectX and OpenGL each define graphics processing pipelines that are to be implemented by a GPU. These graphics processing pipelines may include a combination of programmable stages as well as fixed function stages. Some recent versions of the APIs such as the Direct3D 11 API and the OpenGL 4.x API include a tessellation process that is to be performed by the GPU.

Some graphics rendering stages may compute the vertices of primitives comprising one or more polygons which may eventually be rasterized and output by the GPU for display. In some examples the vertices output from one stage e.g. a geometry shader may be stored in an output buffer referred to as a streamout buffer . In some examples an indexed streamout buffer of the GPU may streamout i.e. read or make available the contents of the streamout buffer to an input assembler stage for another rendering pass. The streamout buffer may streamout the vertex data stored in the streamout buffer so that a programmer can debug the graphics rendering process.

When streaming out data from the streamout buffer the vertices of each of the primitives may be streamed out in a specific order. In some examples the vertices of one primitive may also be included in one or more primitives that are also streamed out. The techniques of this disclosure are directed to an indexed streamout buffer that reduces the vertex data storage requirements of the streamout buffer. In some examples the indexed streamout buffer may also reduce the memory bandwidth requirements and power consumption associated with the streamout buffer.

An indexed streamout buffer as described in this disclosure may be useful for tile based graphics rendering architectures. Tile based rendering architectures generally involve two passes through the GPU s pipeline for graphics to be rendered 1 a binning pass and 2 a rendering pass. The GPU reuses the output of the binning pass as the input to the rendering pass. Once the GPU completes the rendering pass the GPU may output the rendered contents of the framebuffer for display.

In tile based rendering the same vertices may be repeatedly written to a vertex buffer. An indexed streamout buffer may reduce the storage requirements associated with requests to storing the same vertex data to an indexed buffer. An indexed streamout buffer may also reduce the bandwidth required to output the vertices stored in the indexed streamout buffer from the binning pass to the input assembler stage as input to the rendering pass.

In some situations it may be more advantageous to utilize an indexed streamout buffer as opposed to a non indexed streamout buffer. To specify when an indexed streamout buffer should be used the techniques of this disclosure also include an API call that configures a GPU graphics pipeline to use an indexed streamout buffer. The draw call may be part of an API such as OpenGL DirectX OpenCL etc.

CPU may execute various types of applications. Examples of the applications include operating systems web browsers e mail applications spreadsheets video games or other applications that generate viewable objects for display. Instructions for execution of the one or more applications may be stored within system memory . CPU may transmit graphics data of the generated viewable objects to GPU for further processing.

For example GPU may be specialized hardware that allows for massive parallel processing which functions well for processing graphics data. In this way CPU offloads graphics processing that is better handled by GPU . CPU may communicate with GPU in accordance with a particular application processing interface API . Examples of such APIs include the DirectX API by Microsoft and the OpenGL by the Khronos group however aspects of this disclosure are not limited to the DirectX and the OpenGL APIs and may be extended to other types of APIs that have been developed are currently being developed or are to be developed in the future.

In addition to defining the manner in which GPU is to receive graphics data from CPU the APIs may define a particular graphics processing pipeline that GPU is to implement. GPU in illustrates the graphics processing pipeline defined by the Direct3D 11 API. As described in more detail illustrates the graphics processing pipeline of the OpenGL 4.x API.

Examples of CPU and GPU include but are not limited to a digital signal processor DSP general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. In some examples GPU may be specialized hardware that includes integrated and or discrete logic circuitry that provides GPU with massive parallel processing capabilities suitable for graphics processing. In some instances GPU may also include general purpose processing and may be referred to as a general purpose GPU GPGPU .

System memory may comprise one or more computer readable storage media. Examples of system memory include but are not limited to a random access memory RAM a read only memory ROM an electrically erasable programmable read only memory EEPROM flash memory or any other medium that can be used to carry or store desired program code in the form of instructions and or data structures and that can be accessed by a computer or a processor.

In some aspects system memory may include instructions that cause CPU and or GPU to perform the functions ascribed to CPU and GPU in this disclosure. Accordingly system memory may be a computer readable storage medium comprising instructions that cause one or more processors e.g. CPU and GPU to perform various functions.

System memory may in some examples be considered as a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that system memory is non movable. As one example system memory may be removed from device and moved to another device. As another example a system memory substantially similar to system memory may be inserted into device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

The execution of the applications on CPU may cause CPU to generate a plurality of primitives that connect together to form the viewable content. Examples of the primitives include points lines triangles squares or any other type of polygon. CPU may define these primitives by their respective vertices. For example CPU may define coordinates and color values for the vertices. The coordinate values may be three dimensional 3D coordinates or 2D coordinates.

To perform graphics operations GPU may implement a graphics processing pipeline. Executing a graphics processing pipeline may include performing functions as defined by software or firmware executing on GPU and performing functions by fixed function units that are hardwired to perform very specific functions. The software or firmware executing on the GPU may be referred to as shaders and the shaders may execute on one or more shader cores of GPU . Shaders provide users with functional flexibility because a user can design the shaders to perform desired tasks in any conceivable manner. The fixed function units however are hardwired for the manner in which the fixed function units perform tasks. Accordingly the fixed function units may not provide much functional flexibility.

As indicated above the graphics processing pipeline illustrated in is a graphic processing pipeline substantially as defined by Direct3D 11. In this example GPU may include one or more of input assembler stage vertex shader stage hull shader stage tessellation stage domain shader stage geometry shader stage indexed streamout buffer rasterizer stage pixel shader stage and output merge stage . GPU may include more stages than those illustrated and in some examples GPU may not necessarily include all of the illustrated stages. Also the specific ordering of the stages is provided for purposes of illustration and should not be considered limiting.

Input assembler stage may read primitive data e.g. patches points lines and or triangles from system memory as defined by CPU and assemble the control points to form primitives that can be used by other stages of the graphics processing pipeline of GPU . For instance input assembler stage may read the coordinates color values and other such information of the primitive data. Input assembler stage may also assemble vertices into primitive types such as patches line lists or triangle strips. The coordinates color values and other such information may be commonly referred to as attributes of the primitive. Based on the attributes of the control points input assembler stage may determine the general layout of the primitive. In this manner input assembler stage may assemble the primitive. Input assembler stage may also read control point data from system memory . The control points may be used during the stages used to implement tessellation of a patch comprising the control points. Input assembler stage may be a fixed function unit.

Vertex shader stage may process the vertices from input assembler stage . For example vertex shader stage may perform per vertex operations such as transformations skinning morphing and per vertex lighting. Vertex shader may receive compiled shaders written in a language such as high level shader language HLSL and execute the instructions and or flow control of the compiled shaders on the vertices. Vertex shader stage may be a programmable unit as opposed to fixed function units such as input assembler etc.

Hull shader stage is one of three stages along with tessellation stage and domain shader that implements tessellation of a patch comprising a number of control points. Hull shader stage receives control points of a patch as processed by vertex shader stage processes the control points and outputs control points for a processed patch. In other words hull shader stage receives an input patch as processed by vertex shader stage processes the input patch and outputs an output patch. Hull shader stage may perform various functions for processing the input patch. For example hull shader stage may modify the coordinates of the control points to change the locations of the control points or may even add or delete control points.

In addition hull shader stage may determine values that indicate how many primitives are to be added to the patch generated by hull shader stage i.e. the output patch . Hull shader stage may utilize various criteria to determine how many primitives are to be added to the patch. Described below are two example criteria that hull shader stage may utilize to determine how many primitives are to be added to the patch. However aspects of this disclosure are not so limited and hull shader stage may utilize any criteria to determine how many primitives should be added to the patch.

As one example hull shader stage may utilize information indicative of the depth of the patch to determine how many primitives should be added. For instance a patch that is further away from the perspective of the viewer may not need high resolution because objects further in distance appear blurry in real life. However a patch that is closer from the perspective of the viewer may need higher resolution because objects closer in distance appear sharper in real life. In this example hull shader stage may determine that fewer primitives should be added to the patch that is further away and more primitives should be added to the patch that is closer relative to one another.

As another example hull shader stage may determine how many primitives should be added based on the size of the patch. For a smaller sized patch hull shader stage may determine that fewer primitives should be added because the patch encompasses a smaller area. For a larger sized patch hull shader stage may determine that more primitives should be added because the patch encompasses a larger area.

Based on a determination of how many primitives should be added hull shader stage may output a domain type and values that indicate how many primitives are to be added to the patch to tessellation stage . The values that indicate how many primitives are to be added to the patch in the Direct3D 11 API are referred to as tessellation factors e.g. tessfactors .

The domain may be a considered as a template shape that tessellation stage uses for tessellation purposes. Examples of the domain type include a line a triangle a quad e.g. a four sided polygon or any other type of polygon. The domain may be a two dimensional 2D shape even if the patches define a three dimensional 3D surface or a 2D surface. When the domain is a line the domain may be a one dimensional 1D shape i.e. a line even if the patches define a 3D surface a 2D surface or a 1D surface. For purposes of illustration the techniques described in this disclosure are described with respect to the domain being a 2D surface. For instance the techniques are described with domain shapes that are the triangle or quad.

In some examples hull shader stage may not explicitly indicate the domain type. Rather tessellation stage may determine the domain type based on the number of transmitted tessfactors. For example the presence of four tessfactors may indicate that the domain type is a triangle domain type and the presence of six tessfactors may indicate that the domain type is a quad domain type.

In some examples a quad domain may be defined by 2D Cartesian coordinates u v . In some examples a triangle domain may be defined by Barycentric coordinates. Barycentric coordinates utilize three coordinates to identify any point within the triangle. In other examples it may be possible to define the quad domain with Barycentric coordinates or Cartesian coordinates and the triangle domain with Cartesian coordinates or Barycentric coordinates. In general a domain of any type may be defined using any coordinate system.

Tessellation stage may tessellate e.g. divide the domain into a plurality of primitives. It should be understood that in this example tessellation stage is not dividing the patch outputted by hull shader stage into primitives but rather dividing the domain into the primitives. In some examples tessellation stage may not even have access to the patch outputted by hull shader stage . Tessellation stage may be a fixed function unit although aspects of this disclosure need not be so limited.

Tessellation stage may output the vertices of the plurality of primitives of the domain to domain shader stage in the normalized coordinate system e.g. the u v coordinates or the u v w coordinates as applicable . The function of domain shader stage may be to map the vertex coordinates as received from tessellation stage on to the patch. For example while tessellation stage may not receive information of the patch as defined by hull shader stage domain shader stage may receive such information from hull shader stage .

Domain shader stage may execute for each vertex coordinate outputted by tessellation stage . With the coordinates of the control points of the patch from hull shader stage domain shader stage may determine the location of the vertex as outputted by tessellation stage on the patch. Because tessellation stage outputs vertices of the plurality of primitives generated by tessellation stage and domain shader stage adds these primitives to the patch the combination of hull shader stage tessellation stage and domain shader stage together add additional primitives to the patch. This results in a mesh of primitives that are added to the patch creating a higher resolution more detailed patch as compared to the patch defined by CPU . In this manner hull shader stage tessellation stage and domain shader stage implement a tessellation process.

Geometry shader stage receives the vertices of the primitives added to the patch by domain shader stage and may further generate additional vertices for the primitives to add even more resolution. Rasterizer stage receives the primitives from geometry shader stage and converts the primitives into pixels for the display. For example the primitives may be defined as vectors that indicate the interconnection of the primitives and may be defined in a coordinate space that is independent of the display on which the image is to be displayed. Rasterizer stage converts these vectors into the display coordinates and performs any additional functions such as removing points within primitives that are occluded.

In some examples Geometry shader stage may output vertices to indexed streamout buffer or to rasterizer stage . The streamout buffer may streamout the vertices stored in the buffer to input assembler stage . The streamout buffer may also streamout the vertices stored for debugging e.g. to CPU . Although described as receiving vertex data from geometry shader stage the streamout buffer may be positioned after other stages in the graphics pipeline of GPU e.g. after vertex shader .

Indexed streamout buffer indexed streamout buffer may comprise an indexed buffer in accordance with one or more techniques of this disclosure. An indexed buffer is a particular type of buffer that may store indices or pointers to data in the buffer in order to avoid having to store multiple copies of the same piece of data. In embodiments in accordance with the techniques of this disclosure indexed streamout buffer may receive and store vertex data e.g. vertex coordinates such as x y and or z coordinates in the vertex buffer.

When GPU is configured to store and streamout vertex data in indexed streamout buffer logic in indexed buffer determines whether vertices to be written to indexed streamout buffer are currently stored in indexed streamout buffer . If the vertex data is not currently stored in the vertex buffer indexed streamout buffer stores the vertex data in streamout buffer and also stores an index that points to the vertex data in indexed streamout buffer . If the vertex data is already stored in the vertex buffer indexed streamout buffer does not write the vertex data to indexed streamout buffer and writes an index that points to or references the vertex data to indexed streamout buffer .

Whenever GPU writes vertex data to indexed streamout buffer logic in indexed streamout buffer also writes the index pointing to that vertex to a reuse table of indexed streamout buffer . The reuse table stores a number of recently stored index values. The storage logic in indexed streamout buffer checks the reuse table to determine whether a particular vertex is stored in indexed streamout buffer . By limiting the number of entries in the reuse buffer the storage logic only compares the vertex data to be written against the limited number of indices in the reuse table which may reduce the power consumption and or number of comparisons required to determine whether a particular vertex is stored in indexed streamout buffer . Further details of indexed streamout buffer are described in greater detail below with respect to .

In some examples an application running on GPU may specify a DrawAutoIndexed mode of operation for the indexed streamout buffer by executing a DrawAutoIndexed method. The DrawAutoIndexed method may operate in a manner similar to the DrawAuto method of the DirectX API. The DrawAuto method is a method that may be invoked by an application once work has been processed by the stages of a GPU rendering pipeline and stored in a streamout buffer for reuse. If the streamout buffers are bound or configured to streamout data to the input assembler in a subsequent rendering pass the DrawaAuto method handles the details of transmitting data stored in the streamout buffers back to the input assembler stage for further processing without requiring the application to specify the amount of data that is contained in the streamout buffer. In some examples the DrawAuto Indexed method may receive as an input argument a primitive type. The primitive type may be a primitive type such as a point line triangle quad curve or another primitive type etc.

In a similar manner to the DrawAuto method a GPU configured in the DrawAutoIndexed method may inspect the contents of streamout buffer if streamout buffer is bound to i.e. configured to streamout to input assembler stage . GPU then provides the appropriate number of vertices and primitives to the input assembler to render the entire contents of the buffer with no interaction from the application or program executing on GPU . The DrawAutoIndexed mode may reduce the CPU interaction needed to manage the graphics processing pipeline of GPU . The DrawAutoIndexed mode may also be useful for saving values output from geometry shader and for avoiding performing costly vertex transformations for vertices that require further processing by the shader stages in the graphics processing pipeline.

To consume i.e. streamout the vertices stored in the indexed streamout buffer an application may utilize the DrawAutoIndexed method. To utilize the DarwAutoIndexed method a primitive type e.g. a triangle must be specified for the indexed streamout buffer. During the streamout process GPU fetches the vertices for the specified primitive type based on the indices stored in the indexed streamout buffer and vertices stored in the reuse table. GPU reads out the vertices from the indexed streamout buffer in the order specified by the indexed streamout buffer until all the vertices of all the primitives stored in the indexed streamout buffer have been read out which may be based on the indexfilledsize value. Additional details of reading from and writing to RB and streamout buffer are described further below with respect to .

In accordance with the techniques of this disclosure indexed streamout buffer may be configured to receive vertex data of a primitive determine if any entries in a reuse table of the indexed streamout buffer reference the vertex data generate an index that references the vertex data store the index in the indexed streamout buffer and responsive to determining that an entry of the entries currently stored in the reuse table does not reference the vertex data store the vertex data in the indexed streamout buffer and store a reference to the stored index in the reuse table of the indexed buffer.

Pixel shader stage receives the pixels as outputted by rasterizer stage and performs post processing to assign color values to each of the pixels that are to be displayed. For example pixel shader stage may receive constant values stored in system memory texture data stored in system memory and any other data to generate per pixel outputs such as color values. Pixel shader stage may also output opacity values that indicate the opaqueness of the pixels.

Output merge stage may perform any final pixel processing. For example output merge stage may utilize depth information to further determine whether any of the pixels should be removed from being displayed. Output merge stage may also perform blending operations to generate final pixel values.

Output merge stage may output the final pixel values to a frame buffer generally located within system memory but which may be located within GPU . A display processor not shown may retrieve the pixel values from the frame buffer and cause pixels of a display not shown of device to illuminate accordingly to the pixel values to cause the display to display the image.

Accordingly in some examples the techniques described in this disclosure may increase the computational efficiency of the graphics processing pipeline of GPU relative to the case where indexed streamout buffer is not an indexed streamout buffer. Utilizing an indexed streamout buffer may reduce the vertex memory storage requirements memory bandwidth and power consumption relative to using a non indexed streamout buffer.

The OpenGL 4.x graphics processing pipeline may function in a substantially similar fashion as the Direct3D 11 graphics processing pipeline. Accordingly for purposes of brevity reference is made to to describe components that are similar to both the Direct3D 11 graphics processing pipeline and the OpenGL 4.x graphics processing pipeline.

As illustrated in the example of GPU includes input assembler vertex shader tessellation control shader primitive generator tessellation evaluation shader geometry shader indexed streamout buffer clipping unit rasterizer fragment shader and post processor . Similar to in the example illustrated in GPU may include more or fewer components than those illustrated in . Also the specific ordering of the unit is provided for purposes of illustration and should not be considered limiting.

In some ways the tessellation process with the OpenGL 4.x graphics processing pipeline may be substantially similar to the tessellation process with the Direct3D 11 graphics processing pipeline. For example OpenGL 4.x tessellation process may rely upon patches and control points in the manner similar to that described above with respect to . For instance input assembler and vertex shader of may function substantially similar as input assembler stage and vertex shader stage of respectively.

As more examples for tessellation indexed streamout buffer of may function substantially similarly to indexed streamout buffer of . For example indexed streamout buffer may be configured to stream vertices to input assembler or for debugging. Primitive generator may function in a substantially similar manner as tessellation stage .

Tessellation evaluation shader of may function substantially similarly to domain shader stage of . For example tessellation evaluation shader may receive the vertices of the generated primitives from primitive generator and add the primitive to the patch outputted by tessellation control shader . In this manner the graphics processing pipeline of the OpenGL 4.x API may perform tessellation on a patch to increase the resolution of the patch.

Geometry shader may function substantially similar to geometry shader stage . Geometry shader may output vertices to streamout buffer . In some examples streamout buffer may be an indexed streamout buffer and may streamout vertices to input assembler . Although illustrated as being positioned after geometry shader streamout buffer may also be positioned after vertex shader as an example.

The combination of clipping unit and rasterizer in may function substantially similarly to rasterizer stage in . Fragment shader and post processor in may function substantially similar to pixel shader stage and output merge stage in respectively. Post processor may output the final pixel values to a frame buffer and the display processor may retrieve the pixel values from the frame buffer and cause a display to illuminate according to the pixel values to display the image.

As described above tessellation control shader primitive generator and tessellation evaluation shader of function substantially similar to hull shader stage tessellation stage and domain shader stage of respectively for implementing the tessellation process. Accordingly both the Direct3D 11 and the OpenGL 4.x APIs rely upon two programmable shader units and one fixed function unit to implement the tessellation process.

Vertex storage illustrates a portion of streamout buffer designed to store vertex data i.e. two dimensional x y coordinate pairs and or three dimensional x y z coordinate pairs. In addition to storing vertex data vertex storage may also be configured to store other types of data as well. In the example of vertex storage is illustrated as storing vertices V0 V6 vertex V0 is stored twice in this example . The vertices of vertex storage are illustrated as being stored by storage logic in top first bottom last order with V0 being stored first and V6 being stored last i.e. most recently in time .

Index storage stores index values indices . Each of the indices references or points to a single vertex stored in vertex storage There is a one to one correspondence between an index of index storage and a vertex of vertex storage . Each arrow indicates the particular vertex that an index points to or references. As an example arrow from I7 to V6 indicates that index I7 references points to or corresponds to vertex V6.

Reuse table stores indices that correspond to and are also stored in index storage . However the number of indices stored in reuse table may be smaller than the maximum number of indices that may be stored in index storage . When vertex data is to be written to indexed streamout buffer storage logic determines if any of the indices in reuse table point to an index in index storage that references the same vertex as the vertex to be stored i.e. whether the vertices associated with the indices in reuse table are already stored in vertex storage .

If the vertex to be stored is not referenced by any of the indices in reuse table storage logic stores the vertex in vertex storage . Storage logic also generates and stores an index that refers to the vertex in index storage . Storage logic also stores the generated index value in reuse table entry . In some instances reuse table may already contain a maximum number of entries indices . In this instance storage logic overwrites the oldest index entry of reuse table with the index that references the newly stored vertex.

If reuse table already includes an index value that references a vertex that is stored in vertex storage storage logic stores an index in index storage and does not modify the reuse table. Storage logic does not store a vertex in vertex storage . Additional examples illustrating the operation of indexed streamout buffer will be illustrated in and A D.

Vertices are a sequence of input vertices that input assembler stage or input assembler may receive as input. Input vertices comprise the set V0 V1 V2 V1 V3 V4 V1 V2 V3 V0 V4 V2 V2 V5 V6 V5 V2 V4 V5 V2 V6 . Input vertices may comprise some or all of the vertices of the primitives of .

Vertex shader stage vertex shader geometry shader stage and or geometry shader may process vertices to generate additional vertices corresponding to output vertices of primitives corresponding to the primitives of .

The table of also includes index filled size buffer filled size indices written and primitives written columns. The first index filled size indicates the number of indices that have been written to indexed streamout buffer . The indices written column indicates which vertices have been written to index storage of indexed streamout buffer . The Buffer filled size column value indicates a number of bytes consumed by the vertices written to indexed streamout buffer . In each entry of the Buffer filled size column the number is followed by V which is representative of the number of bits or bytes that a vertex requires. For example a vertex may comprise three 32 bit values i.e. 96 bits per vertex. The primitives written column indicates the number of primitives written to indexed streamout buffer .

The IndexFilledSize column indicates a number of indices that storage logic has attempted to write to index storage and the Indices Written column indicates the actual number of indices written to index storage . Storage logic increases the value of the IndexFilledSize value responsive to each storage request to indexed streamout buffer . Storage logic only increases the value of the Indices Written value if storage logic actually writes an index to index storage i.e. if storage logic has not stored a number of indices greater than or equal to the maximum index capacity of indexed streamout buffer .

A programmer or graphics API may query the value of IndexFilledSize to determine whether indexed streamout buffer is currently full. More particularly indexed streamout buffer is allocated with an initial maximum vertex capacity which an application may query. For example an API call may allocate indexed streamout buffer with n maximum index capacity of 100 indices. For each vertex storage request storage logic increases the value of IndexFilledSize and Indices Written by the number of indices stored in index storage .

However once the written exceeds the maximum index capacity of indexed streamout buffer storage logic only continues to increase the value of IndexFilledSize in accordance with the number of indices that the application requests to write the buffer. Storage logic does not increase the number of the Indices Written value which indicates the actual number of indices written value to index storage . Thus an application may query the values of IndexFilledSize and the number of indices written. If storage logic determines that IndexFilledSize is greater than the number of indices written the application may determine that indexed streamout buffer is at maximum index capacity and may cease writing indices to index storage .

The first row of table of corresponds to primitive vertices V0 V1 V2 being written to indexed streamout buffer . Because no vertices have been written to indexed streamout buffer before this reuse table vertex storage and index storage are all empty. Storage logic determines that none of the entries in the reuse table reference any of vertices V0 V1 and V2. Consequently storage logic writes V0 V1 and V2 to vertex storage and generates indices I0 I1 and I2 which reference V0 V1 and V2. Storage logic stores I0 I1 and I2 in reuse table and in index storage . Storage logic also updates the number of indices written to three the buffer filled size to three vertices 3V and the number of primitives written to one.

Next storage logic attempts to store primitive comprising vertices V2 V1 and V3 to indexed streamout buffer . The results of the storage are detailed in the second row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in the reuse table reference V2 V1 or V3.

Currently Index I2 which references V2 and I1 which references V1 are stored in the reuse table. Because there is a reference in reuse table for vertices V2 and V1 storage logic writes indices I2 and I1 into index storage but does not write any vertex data into vertex storage for these vertices. Storage logic determines that vertex V3 is not referenced by an index in the reuse table. Therefore storage logic stores vertex V3 in vertex storage . Storage logic also generates index I3 which reference V3 and stores I3 in reuse table and in index storage . Finally storage logic updates the number of indices written by adding three to the number of vertices written bringing the total to 6. Storage logic increments the number of vertices written by one corresponding to V3 being written and increments the number of primitives written to two.

Storage logic subsequently attempts to store primitive comprising vertices V3 V4 and V2 to indexed streamout buffer . The results of the storage are detailed in the third row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V3 V4 or V2.

Currently Index I3 which references V3 and I2 which references V2 are stored in reuse table . However there is not an entry in reuse table corresponding to V4. Because there is a reference in the reuse table for vertex V3 storage logic writes indices I3 into index storage . Storage logic next handles V4 by writing V4 to vertex storage and generating an index I4 that references V4. Storage logic stores I4 in index storage and overwrites the oldest entry of reuse table the oldest entry was I0 . Storage logic then writes I2 which references V2 to index storage . Finally storage logic updates the number of indices written by adding three to the number of indices written bringing the total to 9. Storage logic increments the number of vertices written by one corresponding to V4 being written bringing the total to five. Storage logic also increments the number of primitives written to three.

Storage logic next stores primitive comprising vertices V5 V6 and V7 to indexed streamout buffer . The results of the storage are detailed in the fourth row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V5 V7 or V7.

Currently no indices that reference V5 V6 or V7 are stored in reuse table . Storage logic handles V5 V6 and V7 by writing each of the vertices to vertex storage and generating indices I5 I6 and I7 respectively. Because of the three new indices I5 I6 and I7 storage logic stores I5 I6 and I7 in index storage and overwrites the three oldest entries of reuse table I1 I2 and I3 . Finally storage logic updates the number of indices written by adding three to the number of indices written bringing the total to 12 increments the number of vertices written by three bringing the total to eight and also increments the number of primitives written to four.

After writing primitive storage logic next stores primitive comprising vertices V7 V6 and V8 to streamout buffer . The results of the storage are detailed in the fifth row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V7 V6 or V8.

Indices I7 and I6 reference V7 and V6 respectively. No index currently in reuse table references V8. Because I7 and I6 reference V7 and V6 storage logic writes indicates V7 and V6 to index storage . Because no index references V8 storage logic stores V8 in vertex storage and generates index I8. Storage logic stores I8 in index storage and overwrites the oldest index of reuse table I4 with I8. Finally storage logic updates the number of indices written by adding three to the number of vertices written bringing the total to 15 increments the number of vertices written by one bringing the total to nine and also increments the number of primitives written to five.

After writing primitive storage logic next stores primitive which is composed of vertices V9 V10 and V11 to streamout buffer . The results of the storage are detailed in the sixth and final row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V9 V10 or V11.

Currently no indices that reference V9 V10 or V11 are stored in reuse table . Storage logic handles V9 V10 and V11 by writing each of the vertices to vertex storage and generating indices I9 I10 and I11 respectively. Because of the three new indices I9 I10 and I11 storage logic stores I9 I10 and I11 in index storage and overwrites the three oldest entries of reuse table I5 I6 and . Storage logic also updates the number of indices written by adding three to the number of vertices written bringing the total to 18 increments the number of vertices written by three bringing the total to 12 and also increments the number of primitives written to six.

The contents of indexed streamout buffer after storing output primitives are illustrated the contents of index storage and respectively. Index storage includes all of the indices written in table of . However each index may be only a few bits as compared to 64 bits per vertex coordinate stored. The number of indices stored is therefore equal to the number of entries in non indexed streamout buffer . However vertex storage stores fewer vertices 12 than the 18 vertices sorted by non indexed streamout buffer . Thus relative to a non indexed streamout buffer streamout buffer may reduce the amount of vertex data that is stored for streamout.

Vertex shader stage vertex shader geometry shader stage and or geometry shader may process vertices to generate additional vertices corresponding to output vertices of primitives corresponding to the primitives of which are stored in streamout buffer as illustrated in greater detail in table in .

The table of also includes index filled size buffer filled size indices written and primitives written columns. The indices written column indicates which vertices have been written to index storage of streamout buffer . The index filled size indicates the number of indices that have been written to streamout buffer . Buffer filled size indicates a number of vertices written to streamout buffer and the primitives written column indicates the number of primitives written to streamout buffer . The number of vertices written is denoted as a number followed by the letter V. In the examples of the V is representative of the number of bytes required to represent a vertex. For example a three dimensional vertex having three double precision i.e. 64 bit floating point values may consume 3 64 192 bits per vertex as one example. Other vertex sizes may also be possible. Storing the amount of bytes used to store the vertices may be used by storage logic as well as by other GPU stages during indexed buffer streamout.

As described above the Indices Written value indicates the number of indices that storage logic has written to indexed streamout buffer and IndexFilledSize indicates the number of vertices that storage logic has attempted to write to indexed storage . If the value of IndexFilledSize exceeds the number of indices actually written an application may determine that indexed streamout buffer has reached its maximum index storage capacity i.e. is full .

The first row of table of corresponds to primitive vertices V0 V1 V2 being written to streamout buffer . Because no vertices have been written to streamout buffer before this the reuse table vertex storage and index storage are all empty. Storage logic determines that none of the entries in the reuse table reference any of vertices V0 V1 and V2. Consequently storage logic writes V0 V1 and V2 to vertex storage and generates indices I0 I1 and I2 which reference V0 V1 and V2. Storage logic stores I0 I1 and I2 in reuse table and in index storage . Storage logic also updates the number of indices written to three the buffer filled size to the size of three vertices 3V and the number of primitives written to one.

Next storage logic attempts to store primitive comprising vertices V1 V3 and V4 to indexed streamout buffer . The results of the storage are detailed in the second row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V1 V3 or V4.

Currently Index I1 references V1. Because there is an index in the reuse table that references vertex V1 storage logic writes index I1 into index storage but does not write any vertex data into vertex storage for these vertices. Storage logic determines that vertices V3 and V4 are not referenced by an index in reuse table . Therefore storage logic stores vertices V3 and V4 in vertex storage . Storage logic also generates indices I3 and I4 which reference V3 and V4 respectively. Storage logic stores I3 and I4 in reuse table and in index storage . Finally storage logic updates the number of indices written by adding three to the number of vertices written bringing the total to 6. Storage logic increases the number of vertices written by two corresponding to V3 and V4 being written and increments the number of primitives written to two.

Next storage logic attempts to store primitive comprising vertices V1 V2 and V3 to streamout buffer . The results of the storage are detailed in the third row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in the reuse table reference V1 V2 or V3.

Currently Index I1 which references V1 I2 which references V2 and I3 which references V3 are each stored in reuse table . Because there is an index in reuse table that references vertices V1 V2 and V3 storage logic writes indices I1 I2 and I3 into index storage but does not write any vertex data into vertex storage for these vertices. Storage logic also updates the number of indices written by adding three to the number of vertices written bringing the total to 9. Storage logic does not increment the number of vertices written because only indices and no vertices were written to indexed streamout buffer and increments the number of primitives written to three.

Storage logic subsequently attempts to store primitive comprising vertices V0 V4 and V2 to streamout buffer . The results of the storage are detailed in the fourth row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V0 V4 or V2.

Currently none of the indices in reuse table reference V0. Therefore storage logic stores V0 in vertex storage and generates a new index I0 that references V0. Storage logic stores V0 in index storage and in reuse table overwriting the oldest entry I1 with I0. Because I4 and I2 which reference V4 and V2 are currently stored in reuse table storage logic stores I4 and I2 in index storage . Finally storage logic updates the number of indices written by adding three to the number of indices written bringing the total to 9. Storage logic increments the number of vertices written by one corresponding to V0 being written bringing the total to six. Storage logic also increments the number of primitives written to four.

Storage logic next stores primitive comprising vertices V2 V5 and V6 to streamout buffer . The results of the storage are detailed in the fourth row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V2 V5 or V7.

Currently reuse table stores I2 which references V2. No indices currently in reuse table reference V5 or V6. Because I2 references V2 storage logic stores I2 in index storage . For vertices V5 and V6 storage logic generates indices I5 and I6 respectively and stores I5 and I6 in index storage as well as in reuse table . Storage logic overwrites the oldest entries of reuse table I3 and I4 with I5 and I6 respectively. Finally storage logic updates the number of indices written by adding three to the number of indices written bringing the total to 12 increments the number of vertices written by two bringing the total to eight and also increments the number of primitives written to five.

Storage logic subsequently attempts to store primitive comprising vertices V5 V2 and V4 to streamout buffer . The results of the storage are detailed in the fourth row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V5 V2 or V4.

Index I5 in reuse table references V5 and I2 references V2. Therefore storage logic stores I5 followed by I2 in vertex storage . Storage logic determines that none of the indices in reuse table reference V4. Therefore storage logic stores V4 in vertex storage and generates Index I4 which references V4. Storage logic stores I4 in index storage as well as in reuse table and replaces the oldest entry I0. Additionally storage logic updates the number of indices written by adding three to the number of indices written bringing the total to eighteen. Storage logic increments the number of vertices written by one corresponding to V4 being written bringing the total to nine. Storage logic also increments the number of primitives written to four.

In this example the last primitive that storage logic subsequently attempts to store is primitive comprising vertices V5 V2 and V6 to streamout buffer . The results of the storage are detailed in the seventh last row of the table of . In attempting to write primitive to indexed streamout buffer storage logic determines whether any entries currently in reuse table reference V5 V2 or V6.

Indices I5 I2 and I6 in reuse table reference V5 V2 and V6 respectively. Therefore storage logic stores I5 followed by I2 and finally I6 in index storage . Storage logic also increases the number of indices written by three bringing the total to 21 and increments the number of primitives written to seven. No vertices are written as a result of attempting to store so storage logic does not change the number of vertices stored in table .

The contents of indexed streamout buffer after storing output primitives are illustrated the contents of index storage and respectively. Index storage includes all of the indices written in table of . However each index may be only a few bits as compared to 64 bits per vertex coordinate stored. The number of indices stored is therefore equal to the number of entries in non indexed streamout buffer . However vertex storage stores fewer vertices nine than the 21 vertices sorted by non indexed streamout buffer . Thus relative to a non indexed streamout buffer streamout buffer may reduce the amount of vertex data that is stored for streamout.

In order to utilize an indexed streamout buffer a program may explicitly specify that an indexed streamout buffer is to be used to store vertex data. Line performs an allocation of a vertex buffer using a CreateBuffer method call which is part of DirectX. The CreateBuffer method call takes three arguments a bufferDesc argument an initData argument and a pointer that will reference the vertex buffer once the allocation is complete.

In order to allocate an indexed buffer as opposed to a non indexed buffer an application must specify e.g. using the bufferDesc argument that the buffer should be an indexed buffer. The bufferDesc argument in this example may have a type of D3D11 BUFFER DESC or another struct type in versions other than DirectX 11 which is a struct that defines a description of the vertex buffer to be allocated. The bufferDesc struct may have a BindFlags member. An application may set the value of the bufferDesc.Bindflags member to specify that the buffer to be allocated should be an indexed buffer that is used for streamout rather than a non indexed buffer.

As described above after GPU stores vertices to an indexed streamout buffer the indexed streamout buffer may streamout the vertices back to a preceding stage to be used in additional rendering pass. For example streamout buffer may streamout vertices to input assembler stage for use as input in a second rendering pass of a tile based GPU architecture.

To specify that a stage of GPU should consume the contents of an indexed streamout buffer an application invokes a special draw command that takes the indexed streamout buffer as input. The draw call may be named DrawAutoIndexed and is referenced by numeral in . DrawAutoIndexed may take as arguments a pointer to an indexed streamout buffer as well as a primitive type. The pointer to the vertex buffer is g pVertexBuffer and the variable primType specifies the primitive type of all the vertices stored in the indexed streamout buffer.

When GPU executes the DrawAutoIndexed call indexed streamout buffer streams out both the indices stored in index storage as well as the vertices stored in vertex storage . It is up to the consuming stage of the GPU pipeline e.g. input assembler stage to reconstruct the original sequence of vertices based on the streamed out indices and vertices as well as the primitive type specified in the DrawAutoIndexed call. In some examples the consuming stage may reconstruct the original sequence of vertices in hardware.

Streamout buffer may also have some maximum number of indices that it may store. To determine whether all vertices that GPU attempts to write actually get written to streamout buffer streamout buffer may expose two variables 1 an IndexNeeded and 2 an IndexFilledSize variable which indicates the maximum index capacity of indexed streamout buffer . Whenever storage logic increases the IndexNeeded variable by the number of indices written when writing one or more indices to index storage .

If the IndexNeeded variable exceeds the value of IndexFilledSize storage logic is able to determine that indexed streamout buffer is full and cannot store additional indices. Any attempts to store more vertices than indexed streamout buffer will fail if IndexNeeded is greater than IndexFilledSize. Storage logic also ensures that if GPU attempts to write a primitive to indexed streamout buffer and indexed streamout buffer has insufficient index capacity and or vertex capacity to store all the indices and vertices of the primitive but could store some of the indices that none of the indices or primitives e.g. vertices get stored to indexed streamout buffer . An application executing on GPU may query the IndexNeeded and IndexFilledSize parameters of streamout indexed buffer .

Also in various examples an application may streamout from one or more indexed buffers and one or more non indexed buffers. However each streamout from a non indexed buffer may require one type of method call e.g. a DrawAuto method call whereas each streamout from an indexed buffer may require a call to the different DrawAutoIndexed method call.

In the example of indexed streamout buffer of GPU may receive vertex data e.g. vertices of a primitive e.g. from a shader such as a geometry shader or vertex shader . Indexed streamout buffer may determine whether any entries of reuse table reference the vertex data . Index streamout buffer may generate an index that references the vertex data and store the index in the indexed streamout buffer . Responsive to determining that an entry of the entries currently stored in reuse table does not reference the vertex data No branch of decision block storage logic may store the vertex data in vertex storage of indexed streamout buffer storage logic may further store a reference to the stored index in reuse table .

In some examples the entries of the reuse table are associated with vertices stored in the vertex buffer. In this example storing a reference in the reuse table comprises determining whether the reuse table is full and responsive to determining that the reuse table is full overwriting an oldest entry of the reuse table with the reference to the stored index.

In various examples indexed streamout buffer may have a maximum capacity and a current index capacity. Indexed streamout buffer may be further configured to determine whether storing an index that references the vertex data will exceed the maximum index capacity. Responsive to determining that storing the index will exceed the maximum index capacity storage logic may mark the indexed streamout buffer as full and prohibit additional vertex data and indices from being stored by the streamout indexed buffer.

In various examples indexed streamout buffer may be further configured to store in the indexed buffer a number of primitives written to the indexed buffer. Indexed streamout buffer may also be configured to stream out the vertex data to a pipeline stage of GPU .

In another example to responsive to storing the index storage logic of indexed streamout buffer may be configured to increase a count of indices stored in the index buffer. In another example the method of may include executing a draw call that specifies the indexed buffer is used for streaming out the stored vertex and in some examples the draw call may specify the indexed buffer as a streamout argument and or a primitive type.

It is to be recognized that depending on the example certain acts or events of any of the techniques described herein can be performed in a different sequence may be added merged or left out altogether e.g. not all described acts or events are necessary for the practice of the techniques . Moreover in certain examples acts or events may be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors rather than sequentially.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on a computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise random access memory RAM read only memory ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs i.e. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

