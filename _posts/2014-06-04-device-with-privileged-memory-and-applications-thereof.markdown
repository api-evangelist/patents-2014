---

title: Device with privileged memory and applications thereof
abstract: A device includes a key store memory, a rule set memory, a plurality of cryptographic clients, and a key store arbitration module. The key store memory stores a plurality of cryptographic keys and the rule set memory stores a set of rules for accessing the cryptographic keys. A cryptographic client is operable to issue a request to access a cryptographic key(s) and, when access to the cryptographic key is granted, execute a cryptographic function regarding at least a portion of the cryptographic key to produce a cryptographic result. The key store arbitration module is operable to determine whether the request to access the cryptographic key is valid; when the request is valid, interpret the request to produce an interpreted request; access the rule set memory based on the interpreted request to retrieve a rule of the set of rules; and grant access to the cryptographic key in accordance with the rule.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09058297&OS=09058297&RS=09058297
owner: VIXS Systems, INC
number: 09058297
owner_city: Toronto, Ontario
owner_country: CA
publication_date: 20140604
---
The present U.S. Utility patent application claims priority pursuant to 35 U.S.C. 120 as a continuation of U.S. Utility application Ser. No. 12 490 777 entitled DEVICE WITH PRIVILEGED MEMORY AND APPLICATIONS THEREOF filed Jun. 24 2009 issued as U.S. Pat. No. 8 781 127 on Jul. 15 2014 which claims priority pursuant to 35 U.S.C. 119 e to U.S. Provisional Application No. 61 094 541 entitled METHODS FOR SYSTEM ON A CHIP CRYPTOGRAPHIC KEY ACCESS AND STORAGE filed Sep. 5 2008 both of which are hereby incorporated herein by reference in their entirety and made part of the present U.S. Utility patent application for all purposes.

This invention relates to generally devices that include memory and more particularly to securing access to the memory within the device.

The desire to keep video content of DVD s and or other copyrighted or proprietary information that is stored in a digital format secure from unauthorized use e.g. unauthorized copying distribution etc. is driven by a sector of the population that places little to no value on the intellectual properties rights of others. As such the battle between creating security systems for digital information and the hackers that attempt to break them continues.

This battle is intensifying with the integration of electronic device features being implemented on a single device e.g. computer with DVD functionality and is further intensified by video processing hardware being implemented as stand alone system on a chip SOC devices. In many instances the video processing hardware SOC uses an operating system that allows end users to write their own applications which means that the user s application may share the same processors and memory space as the security system. This makes the security operations vulnerable. To reduce the vulnerability video processing hardware needs to be constrained to performing only specific intended types of cryptographic operations.

In addition video processing devices which include the video processing hardware SOC are embedded with licensed secret keys for compliance with one or more of a plurality of video application standards e.g. BD DTCP CPRM Cable Card etc. . Typically such a video application standard includes a revocation mechanism whereby if a secret key value is made public the security functions of the compromised devices are revoked and the devices are rendered inoperable. As such it is highly desirable that the secret keys are stored in such a way that they are not accessible to the firmware of the device in order to avoid revocation . This is typically done by storing the secret keys in a one time programmable OTP memory.

While using OTP memory has become a primary mechanism for storing secret keys within video processing devices it is not a failsafe approach. For example a security issue arises when multiple cryptographic clients e.g. a hardware block that performs a specific cryptographic algorithm such as RSA TSD 1394 DMA etc. . . . may issue read or write requests to the OTP memory asynchronously and that the requests are not atomic. In addition as a result of granularity associated with OTP memory large key values are partitioned into smaller blocks which have special read write rules that are imposed on every block. Thus it becomes necessary to associate a macro level restriction on cryptographic clients down to every micro level block access performed by the client.

As a specific example the RSA algorithm can perform a 2048 bit RSA operation which requires 32 reads of 64 bit blocks from the key store to assemble the exponent. If a key is intended to be used as a 2048 bit exponent then every 64 bit block read must be associated with the intended purpose of the key i.e. blocks have to have an attribute indicating which cryptographic client is permitted to access a particular block associated with a larger key.

Another security problem is that cryptographic strength often relies on using large keys e.g. up to 2048 bits for RSA or 256 bit for some AES modes . However if the large key is used one 64 bit block at a time by a weaker cryptographic client then large keys may be attacked 64 bits or less a time. Yet another way to attack large keys is to overwrite portions of the key with 0 s and then perform the intended operations but with the remainder of the weakened key. Every time a portion of the key is decimated in this way the remainder can be determined because portions of the key are now known.

Still further some cryptographic clients have the ability to perform operation at various levels of strength for example the RSA can be configured for variable size modulus or 3DES can be degraded into a DES operation. This can be exploited by a hacker to perform weaker operations and thereby attack large keys with degraded operations. Even further some cryptographic clients use control words CWs and initial vectors IVs within the security operations. The integrity of a security system may be attacked by using a CW as an IV in an operation where the clear text and the CW are known which could be used to reveal the CW value.

Another important aspect of maintaining the integrity of cryptographic operations is controlling the destination of the cryptographic operation results. For example content exported from the SOC poses a far greater risk than content which is retained within the SOC. Yet another mode of attack involves using a key a CW or an IV to decrypt content instead of encrypting the content. For example the intention may be to encrypt content however a hacker may use a key store value to decrypt the content.

In addition to the threat of hackers the security of the secure content information is at risk from unauthorized public disclosure. For example if a disgruntled employee posts the algorithm and location of the keys on the Internet the security of the algorithm is lost. As such the risk to security systems is not just from outsider breaking the security of the algorithm but also from an insider intentionally compromising the integrity of the security system.

Therefore a need exists for a security device architecture that at least partially overcomes one or more of the above mentioned security issues.

The processing module may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor micro controller digital signal processor microcomputer central processing unit field programmable gate array programmable logic device state machine logic circuitry analog circuitry digital circuitry and or any device that manipulates signals analog and or digital based on hard coding of the circuitry and or operational instructions. The processing module may have an associated memory and or memory element which may be a single memory device a plurality of memory devices and or embedded circuitry of the processing module. Such a memory device may be a read only memory random access memory volatile memory non volatile memory static memory dynamic memory flash memory cache memory and or any device that stores digital information. Note that when the processing module implements one or more of its functions via a state machine analog circuitry digital circuitry and or logic circuitry the memory and or memory element storing the corresponding operational instructions may be embedded within or external to the circuitry comprising the state machine analog circuitry digital circuitry and or logic circuitry. Further note that the memory element stores and the processing module executes hard coded and or operational instructions corresponding to at least some of the steps and or functions illustrated in .

In an example of operation one or more of the IO interfaces receives an instruction to display a video file. The video file may be from a DVD stored in the hard disk and or flash memory received from a satellite receiver received from a cable set top box and or any other source of video content data. Note that the one or more of the IO interfaces and or may receive the video file. The video file is encrypted using a particular encryption program and one or more cryptographic keys as prescribed by one or more video standards.

In this example the processing module coordinates the retrieval of the video file from the main memory the hard disk and or flash memory the IO interface and or and or other source. The encrypted video file may include video data audio data video graphics data and or any other type of data requiring security. The processing module evokes a cryptographic client algorithm e.g. RSA DES etc. and retrieves a cryptographic key from a secure memory location e.g. a privileged memory . The secure memory location will be described below with reference to one or more of .

The processing module decrypts the encrypted data using the cryptographic client algorithm and the cryptographic key to produce decrypted data. The decrypted data is provided the graphics processing module . The video graphics processing module may be a video graphics card a video graphics engine a video graphics processor a combination thereof and or any other device for rendering video data. In this example the graphics processing module converts the decrypted data into video data and stores it in the graphics memory for subsequent display.

The video graphics display device has three classes of memory access. The most secure class allows access to the system memory e.g. main memory and or the hard disk and or flash memory and to IO devices via the IO interfaces and allows access to the graphics memory e.g. frame buffer and allows access to the secure memory location. The next level of secure access allows access to the system memory and to IO devices via the IO interfaces and . The third access level allows access to system memory.

The privileged memory section may be implemented using one or more one time programmable OTP memories RAM and or ROM. The OTP memory may be used to store a default set of the cryptographic keys and a rule set section . The key store section stores one or more cryptographic keys for one or more of the cryptographic clients in an OTP memory RAM and or ROM. The key store section may include memory blocks where one or more blocks store a cryptographic key. The rule set section stores rules for accessing the key store section . The various rules will be described in greater detail with reference to at least some of .

The device of also includes an arbitration module which may be part of the operation system stored in the privileged memory and or a separate module e.g. a stand alone state machine a stand alone processor etc. . Regardless of its location the arbitration module coordinates access to the key store section based on the rule set. In this manner access requests must come from authorized firmware components e.g. real cryptographic clients and the request must be in a specific manner based on the identity of the requestor as delineated in the rule set. If either fails e.g. unauthorized requestor e.g. firmware being manipulated by a hacker or invalid request manner the arbitration module will deny the request ignore the request or provide random data in response to the request.

With such an embodiment the security of a hardware system and the flexibility of a software system are substantially achieved. For instance by utilizing a single OTP to store permanent rules for accessing the keys the vulnerability of a software system is substantially avoided and the inflexibility of a hardware system which uses hard wired single function for a single standard is also substantially avoided.

If however at step the request is determined to be valid the method continues at step where the arbitration module interprets the request for access to the cryptographic key to produce an interpreted request. This will be described in greater detail with reference to . The method continues at step where the arbitration module accesses the rule set memory based on the interpreted request to retrieve a rule of the set of rules. An example of a rule will be described with reference to .

The method continues at step where the arbitration module grants access to the cryptographic key in accordance with the rule. Note that the rule set may indicate that the access is not to be granted as such in accordance with the rule includes denying the request ignoring the request or providing random data. The method continues at step where when access to the cryptographic key is granted the cryptographic client executes a cryptographic function regarding at least a portion of the cryptographic key to produce a cryptographic result.

The source section indicates an initiator of the cryptographic result and the destination section indicates where the cryptographic result will be sent. The valid sources and destinations include the system main memory the key store section the IO registers and or the graphics memory. The cryptographic algorithm being used may be identified as ANY NONE AES DES 3DES Multi 2 DVB C2 CSS MDMI HDCP 1394 M6 RSA ECC and or Register.

In an embodiment an adjacent rule may be used. For instance when a particular client initiates an encryption operation the Rule Store determines what Key blocks in the Key Store can be accessed. By the improvement a further bit is included in the Rules whereby when the Rule is implemented it determines the order in which the Key Store blocks may be accessed. More restrictively a particular sequence of blocks is prescribed. Less restrictively groups of Key Store blocks are accessed in a prescribed order.

In an embodiment the rule store section contains bit masks associated to Key Store blocks. The Bit Mapping for rules is as follows 

In this embodiment a rule is a group of bits e.g. 16 which dictates how a corresponding block e.g. 64 bits in the key store may be accessed. By default since all bits in the OTP default to 0 the blocks that have un initialized rules provide unlimited access i.e. no restrictions .

With respect to an adjacent rule it provides certain cryptographic clients the ability to write the result of a cryptographic operation back into the key store . This is may be useful in cases where the security system makes use of key ladders e.g. a structure where a key is used to decrypt an encrypted key the resulting decrypted key may then be used in a subsequent key ladder step or it may be used to decrypt content and where the key is used to decrypt content is itself the end product of several cryptographic operations. In this context the adjacent rule is used to enforce a particular order to be adhered to when deriving the key i.e. the 1key must be adjacent to step which must be adjacent to step etc. . . . where the last step of the ladder culminates with the key intended to decrypt content. Note that the adjacent rule field more than 1 bit to indicate a range of adjacent locations e.g. 5 bits to provide 32 adjacent locations . For example instead of the result or an operation being permitted to be written to just the next i.e. adjacent location the rule has extra bits allocated that define the permission to write the result to the next N blocks i.e. a plurality of adjacent locations . This adds flexibility when dealing with a multi stream system where multiple end keys are calculated using the same ladder.

If the request is valid the method continues at step where the arbitration module provides at least a portion of the cryptographic key to the cryptographic client. For example the key may be stored in multiple blocks and the arbitration module provides some or all of the blocks the cryptographic client in response to one request. The method continues at step where the cryptographic client executes the cryptographic algorithm utilizing the at least a portion of the cryptographic key on content data to produce encrypted data or decrypted data. Note that in an embodiment even though a cryptographic client may make multiple requests and get portions of the key it typically will use the entire key for a cryptographic operation.

If however the request is valid the method continues at step where the arbitration module provides access to a block of memory in the key store memory for the at least a portion of the cryptographic key for the cryptographic client. The method continues at step where the cryptographic client executes the cryptographic function to write the at least a portion of the cryptographic key into the block of memory.

The method branches at step depending on whether the type of cryptographic algorithm is in a class type of a plurality of class types. If not the method continues at step where the request is denied. If however the type is in a class the method continues at step where the arbitration module establishes a bit boundary corresponding to the class type for accessing the cryptographic key. For example If Algorithm ANY DES DVB C2 CSS M6 Multi 2 HDCP Register then the Key Store may be accessed on a 64 bit boundary If Algorithm AES 3DES ECC then the Key Store may be accessed on a 128 bit boundary If Algorithm RSA then the Key Store may be accessed on a 1024 bit boundary and If Algorithm NONE then the Key store may be not be accessed on any boundary.

There is an OTP programming Interface which corresponds to a set of registers which permit reading or write 64 bits at a time into a specific OTP block. For every block there are 2 bits of associated OTP memory i.e. the Read Lock Out Bits 0 . . . 255 and the Write Lock Out Bits 0 . . . 255. These bits default to 0 factory default and may be programmed one time to 1. Once the bit is set to 1 it may never be re programmed to a 0. When the corresponding read lock out bit is set form a 0 to a 1 then the associated 64 bit OTP block may never be read via the register interface. When the corresponding write lock out bit is set form a 0 to a 1 then the associated 64 bit OTP block may never be written via the register interface.

This is a fundamental interlock required to secure secret values into the hardware device. There are a few scenarios 

During the initial writing the cryptographic key to the key store memory at step from the OTP the copy may utilize an obfuscation function. For example blocks of 64 bits i.e. Block j which are to be written to the OTP i.e. OTP i are obfuscated using a function comprising symmetric binary operators OP n and a re mapping function i.e. j i j . The obfuscation function h may be defined as follows OTP HKB x OP Block 

The corresponding reverse obfuscation function h implemented between the OTP and the Key Store uses the following obfuscation function. KeyStore OTP OP HKB Note that h is a j op j i mapping and h is a i op j j mapping which means that the bit ordering in the Block and the HKB are different i.e. if a hacker had access to the Block value and the HKB value then the bit ordering would not correspond.

An obfuscation key block may be a 64 bit pattern written into one or more blocks of the OTP. The obfuscation key block may default to 0x0 . . . 0 and may be programmed uniquely per chip or uniquely per customer or uniquely per product or may default to 0x0 . . . 0. In addition the obfuscation key block should have a similar number of 0 s as 1 s 10 i.e. non trivial value to ensure secure obfuscation.

The obfuscation functions may be used to secure the key store loading stage of secure key deployment. It allows for a secure way to embed keys in to OTP memory. This provides an important operational security mechanism which secures cryptographic values within the OTP and provides some security in the factory environment.

The privileged memory section which may be implemented using one or more one time programmable memories includes a privileged data section and a rule set section . The privileged data section stores data that is of a privileged nature and should not be accessible to a user of the device or to a hacker. Such data includes one or more cryptographic keys for one or more of the cryptographic clients other device security features etc. The privileged data section may include memory blocks where one or more blocks store a privileged data element. The rule set section stores rules for accessing the privileged data section .

The device of also includes an arbitration module which may be part of the operation system stored in the privileged memory and or a separate module e.g. a stand alone state machine a stand alone processor etc. . Regardless of its location the arbitration module coordinates access to the privileged data section based on the rule set. In this manner access requests must come from authorized firmware components e.g. real cryptographic clients operating system firmware functions other device security functions etc. and the request must be in a specific manner based on the identity of the requestor as delineated in the rule set. If either fails e.g. unauthorized requestor e.g. firmware being manipulated by a hacker or invalid request manner the arbitration module will deny the request ignore the request or provide random data in response to the request.

The method continues at step where the arbitration module determines whether the request is valid. This may be done by accessing the rule set based on the requestor and the type of request e.g. read privileged data and or to write privileged data . In addition the arbitration module may verify the format of the request to insure that includes a read write indication an address of the at least a portion of the privileged data and an indication regarding use of the privileged data. If any of these checks fail the request is invalid and the method proceeds to step via step where the request fails. If however the request is valid the method continues at step where the arbitration module interprets the request to produce an interpreted request. The interpretation will be described in greater detail with reference to . The method continues at step where the arbitration module grants access to the at least a portion of the privileged data in accordance with the rule.

A further embodiment may include an additional multi bit field for encrypt decrypt that specifies whether a cryptographic client is required to perform an encrypt or decrypt operation e.g. ANY 00 Encrypt 10 Decrypt 01 NONE 11 . A least constraining state is the 00 un programmed state and a most constraining state is 11 None . Another embodiment may include increasing the size of the read and write algorithm field from 4 bits to 6 bits to specify 64 different algorithms which allows for many more algorithms to be added.

In another embodiment a skip function may be used to reduce the number of one time programming OTP steps required to populate the Key Store by loading one root key into the Key Store and then having the keys for other sections of the key ladder calculated from the root rather than having them all loaded during successive steps of the OTP process. In this way certain OTP steps are obviated.

In yet another embodiment a repeat function may be used to avoid redundancy. For instance the OTP block includes an indicator stored with certain of the Rules in the Rule Store to indicate whether that Rule is to be repeated to load it in other locations in the Key Store ladder. Once again this obviates the requirement of having an OTP step for every location in the Key Store ladder.

In a further embodiment an Encrypt Decrypt rule may be used. In particular a pair of bits are added to each Rule which signify that the client can encrypt and decrypt 00 that the client can do one of encrypt and decrypt 1 0 and 0 1 and that the client can copy but not encrypt or decrypt the result to another location in the Key Store.

As may be used herein the terms substantially and approximately provides an industry accepted tolerance for its corresponding term and or relativity between items. Such an industry accepted tolerance ranges from less than one percent to fifty percent and corresponds to but is not limited to component values integrated circuit process variations temperature variations rise and fall times and or thermal noise. Such relativity between items ranges from a difference of a few percent to magnitude differences. As may also be used herein the term s coupled to and or coupling includes direct coupling between items and or indirect coupling between items via an intervening item e.g. an item includes but is not limited to a component an element a circuit and or a module where for indirect coupling the intervening item does not modify the information of a signal but may adjust its current level voltage level and or power level. As may further be used herein inferred coupling i.e. where one element is coupled to another element by inference includes direct and indirect coupling between two items in the same manner as coupled to . As may even further be used herein the term operable to indicates that an item includes one or more of power connections input s output s etc. to perform when activated one or more of its corresponding functions and may further include inferred coupling to one or more other items. As may still further be used herein the term associated with includes direct and or indirect coupling of separate items and or one item being embedded within another item. As may be used herein the term compares favorably indicates that a comparison between two or more items signals etc. provides a desired relationship. For example when the desired relationship is that signal has a greater magnitude than signal a favorable comparison may be achieved when the magnitude of signal is greater than that of signal or when the magnitude of signal is less than that of signal .

The present invention has also been described above with the aid of method steps illustrating the performance of specified functions and relationships thereof. The boundaries and sequence of these functional building blocks and method steps have been arbitrarily defined herein for convenience of description. Alternate boundaries and sequences can be defined so long as the specified functions and relationships are appropriately performed. Any such alternate boundaries or sequences are thus within the scope and spirit of the claimed invention.

The present invention has been described above with the aid of functional building blocks illustrating the performance of certain significant functions. The boundaries of these functional building blocks have been arbitrarily defined for convenience of description. Alternate boundaries could be defined as long as the certain significant functions are appropriately performed. Similarly flow diagram blocks may also have been arbitrarily defined herein to illustrate certain significant functionality. To the extent used the flow diagram block boundaries and sequence could have been defined otherwise and still perform the certain significant functionality. Such alternate definitions of both functional building blocks and flow diagram blocks and sequences are thus within the scope and spirit of the claimed invention. One of average skill in the art will also recognize that the functional building blocks and other illustrative blocks modules and components herein can be implemented as illustrated or by discrete components application specific integrated circuits processors executing appropriate software and the like or any combination thereof.

