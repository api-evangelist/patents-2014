---

title: Device location application programming interface
abstract: Media, methods and interfaces are provided for interfacing a mobile device and an application virtual machine to provide location information of the mobile device from a secondary source. When location information supplied by a first source to the application virtual machine contains invalid values for device location, a secondary source is utilized to provide the location information. No new processing thread is spawned for collection of back-up source configurations. Thus, interfaces initiate the first and second location determination methods in a single request. The power consumed by the mobile device to retrieve the device location information from a secondary source is reduced by the absence of additional configuration collection threads. Interfaces include a primary location component, a verification component, a backup location component, and a location update component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09414190&OS=09414190&RS=09414190
owner: Sprint Communications Company L.P.
number: 09414190
owner_city: Overland Park
owner_country: US
publication_date: 20141210
---
This application is a continuation of U.S. Pat. No. 8 954 987 U.S. application Ser. No. 13 533 663 filed Jun. 23 2012 which is a divisional of U.S. Pat. No. 8 250 584 U.S. application Ser. No. 12 173 077 filed Jul. 15 2008 which are incorporated in their entirety by reference herein.

Many mobile devices today such as cellular phones and personal data assistants PDAs use the Java 2 Platform Micro Edition J2ME framework as an underlying platform. This framework is prevalent for use with devices that are unable to take full advantage of other platforms such as Java Standard Edition because of resource limitations like reduced memory capacity interface limitations etc. Even with such constraints each edition of the framework must meet standards that are regularized in response to a Java Specification Request JSR . Through the Java Community Process JCP updated versions optional packages and newly found needs can be codified. Basic and optional specifications allow users foundational device capabilities as well as the ability take advantage of web services. Such application programming interfaces APIs enable web functions such as secure and trustworthy connections and wireless online payments. Another burgeoning area of optional packages is apparent in the combination of cellular phones and personal data assistants PDAs with previously separate devices such as cameras music players and global positioning system GPS devices. However the focus in some specifications on resource limited devices results in providing standardization that may not be the most efficient use of the device s computational capabilities. For example many mobile devices now have multiple means for determining the location of the device. Yet the secondary means typically requires multiple processing threads to collect configuration parameters each time the secondary method is used. Unnecessary processing then consumes power shortening battery life.

Embodiments of the invention are defined by the claims below. A high level overview of embodiments of the invention is provided.

In a first embodiment a computer implemented method interfaces a mobile device and an application virtual machine to provide location information of the mobile device from a secondary source. Location information supplied by a first source is provided to the application virtual machine. Whether or not the location information provided to the virtual machine contains valid values for device location is determined. If the location information contains valid values for device location that information is provided to subsequent virtual machines as needed. However if the location information does not contain valid values a secondary source is utilized to provide the location information.

In a second embodiment computer readable media perform a method of interfacing a mobile device and an application virtual machine for retrieval of device location information from multiple sources. The power consumed by the mobile device to retrieve the device location information from a secondary source is reduced. Whether location information received from a first source contains invalid values for device location is verified. Upon verification that the location information received from the first source contains invalid values for device location location information from a second source is retrieved. This backup process occurs without spawning a new processing thread for the collection of secondary source configurations.

In a third embodiment an interface between a mobile device and an application virtual machine initiates a first and second location determination method in a single request. The interface includes a primary location component a verification component a backup location component and a location update component. The primary location component is operable to return a first set of values from a first source configured to return mobile device location information. The verification component is operable to confirm the validity of the first set of values received. The backup location component is operable to return a second set of values from a second source configured to return mobile device location. The location update component is operable to in a single request query the primary location component the verification component and the backup location component to ascertain current mobile device location information.

Embodiments of the invention provide methods media and interfaces for mobile devices to provide device location information to application virtual machines VMs . More particularly mobile devices are configured to query a second source for determining device location in a more efficient manner. Improving the application programming interface API that provides this functionality can reduce mobile device processing required by simplifying implementation of location queries into single threaded requests. Using predetermined settings for certain variables associated with the second source and the device allows the API to avoid spawning new threads to retrieve the configuration data. Additionally the reduction in mobile device processing reduces the power needed by the mobile device to fulfill the query. Another improvement is the reduction of development complexity for mobile device providers. Thus by encouraging efficient processing several aspects of the development and use of the mobile device are augmented.

Throughout the description of the invention several acronyms and shorthand notations are used to aid the understanding of certain concepts pertaining to the associated system and services. These acronyms and shorthand notations are intended to help provide an easy methodology of communicating the ideas expressed herein and are not meant to limit the scope of the invention. The following is a list of these acronyms 

Further various technical terms are used throughout this description. An illustrative resource that fleshes out various aspects of these terms can be found in Newton s Telecom Dictionary by H. Newton 24th Edition 2008 .

Embodiments of the invention include among other things a method system or computer program product. Accordingly the embodiments may take the form of a hardware embodiment a software embodiment or an embodiment combining software and hardware. In one embodiment the invention takes the form of a computer program product that includes computer useable instructions embodied on one or more computer readable media.

Computer readable media include both volatile and nonvolatile media removable and non removable media and contemplates media readable by a database a switch and various other network devices. By way of example and not limitation computer readable media comprise media implemented in any method or technology for storing information. Examples of stored information include computer useable instructions data structures program modules and other data representations. Media examples include but are not limited to information delivery media RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile discs DVD holographic media or other optical disc storage magnetic cassettes magnetic tape magnetic disk storage and other magnetic storage devices. These technologies can store data momentarily temporarily or permanently.

The invention will be described within the context of mobile devices with which it is compatible. As such these mobile devices use the Java 2 Platform Micro Edition J2ME framework as an underlying platform. As discussed above a Java Specification Request JSR is part of the standardization process for this platform. One basic specification is JSR 30 which was developed as a first minimum library set needed to enable the use of virtual machines VMs . This specification implements what is also known as version 1.0 of the Connected Limited Device Configuration CLDC . The specification and its update JSR 139 for CLDC 1.1 are concerned with the most resource constrained devices such as low memory cell phones and pagers. Another such foundational specification is that describing the Mobile Information Device Profile MIDP which provides a graphical user interface GUI API as part of JSR 37. This aspect of the overall platform also has been updated in the form of JSR 118 which implements MIDP 2.0. In the context of the invention the mobile devices described will be able at a minimum to utilize JSR 139 for CLDC 1.1. Of course there are devices that implement standards that extend beyond this specification and therefore are compatible with the invention.

The figures in general will use similar numbering conventions from figure to figure where practical to show like or substantially similar features. With regard initially to an exemplary operating environment for implementing embodiments of the invention is shown and designated generally as mobile device operating environment alternatively referred to as mobile device . Mobile device is but one example of a suitable mobile environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should mobile device be interpreted as having any particular dependency or requirement relating to any one or combination of modules or components illustrated.

Embodiments may be described in the general context of computer code or machine useable instructions including computer executable instructions such as program modules being executed by a cellular phone a personal data assistant PDA or other handheld mobile device. Generally program modules including routines programs objects modules data structures and the like refer to code that performs particular tasks or implement particular data types. Embodiments may be practiced in a variety of system configurations including hand held devices consumer electronics specialty computing devices etc.

With continued reference to mobile device includes a bus that directly or indirectly couples the following components one or more processors memory one or more presentation components input output I O components I O ports and an illustrative power supply . Bus represents what may be one or more busses such as an address bus data bus or combination thereof . Although the various blocks of FIG. are shown with lines for the sake of clarity in reality delineating various modules is not so clear and metaphorically the lines would more accurately be grey and fuzzy. For example one may consider presentation components such as a display screen to be an I O component. Also processors have memory. The inventors hereof recognize that such is the nature of the art and reiterate that the diagram of is merely illustrative of an exemplary mobile device that can be used in connection with one or more embodiments. Distinction is not made between such categories as web enabled cellular phone personal data assistant etc. as all are contemplated within the scope of and reference to mobile device. 

Mobile device typically includes a variety of computer readable media. By way of example and not limitation computer readable media may comprise Random Access Memory RAM Read Only Memory ROM Electronically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technologies CDROM digital versatile disks DVD or other optical or holographic media magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices carrier wave or any other medium that can be used to encode desired information and be accessed by mobile device .

Mobile device includes one or more processors that read data from various entities such as memory or I O components . Memory includes computer storage media in the form of volatile and or nonvolatile memory. Memory may be removable non removable or a combination thereof. Exemplary devices for memory include solid state memory hard drives optical disc drives etc. Presentation components present data indications to a user or other device. Exemplary presentation components include a display screen speaker vibrating module etc. I O ports allow mobile device to be logically coupled to other devices including I O components some of which may be built in. Illustrative components include a keyboard microphone cursor or focus movement buttons satellite devices touch pad or touch screen scanner etc.

As one of ordinary skill in the art will appreciate the inner workings of even an unsophisticated mobile device can constitute thousands of components instructions and the like. As previously discussed the ability to draw distinct lines is nearly impossible because of the interoperability of many of those components. A block diagram representing interaction of certain components of a mobile device according to embodiments of the invention is depicted in greatly simplified form and will be described below. More specifically this diagram represents the interaction of a mobile device s operating system OS with application virtual machines within memory components of the device. Between the OS and the memory component are application programming interfaces that enable various functions provide access for other memory locations and generally enable applications to be used on the device. However it should be noted that these components may have many more connections to other components not show for the sake of clarity.

Turning now to memory is not intended to contain only the data structures and modules shown but is simplified for the ease of illustration. Processors and busses will be integrally involved in the reading and writing of data stored within memory . Again for the sake of clarity an operating system is shown as a discrete component or module in communication with three memory locations and and application programming interfaces . Memory locations and are not meant to limit the memory to memory having only three addressable locations outside of the other modules and components. This is illustrative in nature. Memory may have thousands or millions of storage locations depending on the resources of the device. Operating system functions with memory locations by accepting instructions through a set of application programming interfaces APIs . This allows applications running on the mobile device to interact with memory locations other applications and physical components that are part of or connected to the mobile device.

Continuing with three application virtual machines VMs are shown numbered as a VM a VM and a VM . These can be Java application virtual machines that carry out any type of tasks manipulating files of different media types. For mobile devices that use the J2ME platform these applications are known as MIDlets. Looking at the exemplary applications in VM may be a utility MIDlet that allows a user to upload photos for use as the GUI wallpaper image. As another example VM could be a utility application for the download of ringtones and other audio clips. As a final illustration VM could be a navigational application for presenting the location of the mobile device to the user and directions to user specified destinations. These are exemplary applications that are common to the devices described above and below and should not be construed as limiting the scope of the present invention. Instead all applications consistent with the J2ME platform particularly those that help determine or utilize device location information are contemplated within the scope of the described embodiments.

In the application VMs are in communication with APIs so that the applications may properly interact with operating system and memory storage locations . APIs will include some or all of the JSR compliant APIs described above including foundational specifications such as JSR 139 for VM enablement and JSRs or for GUI and assorted other functions. Other specifications that may be necessary for the operation of mobile device have been omitted for the sake of clarity and many specific optional packages will not be described. However APIs will include at least one package that improves upon an optional API found in JSR 179. JSR 179 is responsible for enabling determination of the mobile device s location allows for components such as GPS mechanisms to communicate with their respective applications. Many mobile devices today have more than one mechanism with which to determine location. The improved API allows a single request for location update to contact both a primary and secondary source. This extends the capabilities of JSR 179 compliant devices by conducting the update faster as new processes do not need to be instantiated to contact the secondary source. This reduction also maximizes computational efficiency and therefore minimizes device power consumption.

The following description will focus on methods of interaction and processes of interfacing components according to embodiments of the invention. A first method involves receiving location information for a mobile device from a secondary source via the improved API. After values for location information are received from a first source a component validates the data. If the data is valid then a second source is not needed and the received information can be disseminated to other application virtual machines as needed. If the values are not valid then a second source is queried using pre selected configurations.

Now describing a method for receiving location information for a mobile device from a secondary source via an improved API is depicted. A set of values for mobile device location information is received at a step . An example of these values could be a set of latitudinal and longitudinal values along with an altitude reading all of which denote the precise location of the device. At a step the validity of these values can be determined.

There are a number of ways in which values can be deemed valid or invalid. one method is through a check of ranges that bound certain values. Latitudinal and longitudinal readings are one such example. When used to denote a surface location a latitudinal value must range from South Pole to North Pole between 90 and 90 degrees respectively. Of course this measurement is relative to the equatorial reference of zero degrees. Likewise a longitudinal coordinate will be measured from the reference point of the prime meridian and will range between 180 to 180 degrees. Measuring eastward distance in the positive is the normal convention with westward distance from the prime meridian measured in a negative fashion. Another convention is simply referring to all measurements as positive but giving a directional qualifier i.e. north south east and west. The validity of a received value can be based on determining whether the latitudinal coordinate is between 90 and 90 degrees and the longitudinal coordinate is between 180 and 180 using the first convention. Values would simply need to be between zero and 90 or zero and 180 in the second convention. This range can be truncated or otherwise modified depending on the device and the application. For a navigational application that is confined to North America only the range is reduced to positive latitudes and negative longitudes. Second convention coordinates would need a north or west designator in order to provide a valid location somewhere in North America.

Naturally there are other checks that may be performed to deem values valid or not. A required accuracy can be established so that a measurement must be within a certain resolution. Again using the latitude longitude conventions the 180 degrees of latitude equate to roughly 69 miles per degree. The longitude values vary from the equator to the pole ranging from 69 to zero miles respectively. Each degree of latitude can be divided into 60 minutes thus equaling slightly more than one mile per minute. Those 60 minutes can be sub divided into 60 seconds which equates to approximately 100 feet per second of latitude Longitudinal measurements will vary from the described distances at a maximum to zero as they approach a pole. One requirement that a location determination method may require is accuracy within a fraction of a second so that a location is determined within a specified number of feet.

Latitudinal and longitudinal requirements are not the only available means of rendering values valid or invalid. Another instance would be requirements for additional information. For example an altitude measurement can be required for a valid set of values. However if no value is available for this one aspect it could negate what would otherwise denote that the device in a valid location. Likewise a requirement for additional address information from an address database may be needed for a complete set of valid values. A calculation providing the speed and direction that a mobile device is traveling may be required. Again these are simply illustrative and should not be construed as limitations to the scope of the invention.

Returning to if the values received at step are valid using the configurable criteria as established the validity check at step directs the method to a step . At step the values can be shared with any other application virtual machine that may need those values e.g. a navigation system. This effectively ends the method without requiring the use of a secondary source. However if the values received at a step are not valid then a second source is queried as the method is directed to a step . Once the query is processed a second set of values is returned that denote the mobile device s current location information at a step .

One aspect of this query is the pre determined configurations supplied with the request. This could be required data as explained above. Examples of device configurations that may be pre determined are information requirement settings. For instance suppose that altitude measurements are a part of typical location determination. Certain sources may require that an altitude value be determined and passed back to the application virtual machine. However if the backup source is used for ascertaining the mobile device s location then the requirement for an altitude measurement may be completely disregarded. Thus by automatically setting the configuration of this parameter to FALSE a value is no longer needed to return valid information. There may be a number of these parameters that require a configuration value of some sort which will be discussed further below with respect to .

A second method can be performed utilizing an improved API to reduce the power consumption of the device. Values associated with location information from a first source are received. Upon verification that the values received from this first source are invalid meaning another source for location information is needed a second source is queried for the relevant data. The second source is queried utilizing pre configured values for criteria associated with that source. Because the pre configured values are utilized additional processing threads are not needed for configuration retrieval. This reduces the computational resources required and in turn reduces the power consumption of the mobile device.

Now a method for receiving location information for a mobile device from a secondary source via an improved API shown in will be described. At step a set of values for mobile device location information is received. This same numbering convention is intended to convey that the step is substantially similar to step depicted in . Departing from the previous method at a step verification of the invalidity of these values is performed. Thus if the values are not invalid the process ends at step by virtue of the first source providing the location. Once again this means that the location values are shared to applicable application virtual machines. However if the values are indeed invalid step is performed to query a second source.

Rather than put the mobile device through a resource intensive check of numerous parameters those values are established ahead of time as part of the query. Retrieval of these settings typically requires the use of a new processing thread by the application virtual machine. Thus by only using a pre determined configuration that does not require this retrieval and with it no new thread computing resources can be conserved.

Another manner in which to simplify a backup request is to ensure that secondary information such as altitude speed direction and address information are not required. This leads to more efficient operation of the mobile device as well as prolonged battery power by streamlining the computation required. This can also be ensured by the pre configuration of the source values. A discussion of these parameters and their effects are outlined below.

Turning to description of a simplified diagram of pre configured values for backup location determination methods are depicted. Saved within a mobile device a set of values are intended to be exemplary and any one individual value should not limit the scope of the invention. Values are used by a set of APIs to enable an application virtual machine . However the fact that they are pre determined is one novel aspect of the invention. Set includes a cost allowed preferred power consumption speed and course requirement address information requirement altitude requirement horizontal accuracy setting vertical accuracy setting and preferred response time . Cost allowed speed and course requirement address information requirement and altitude requirement all are shown to have settings of FALSE. As those values indicate these are simply Boolean values that determine whether or not the requirement is necessary. Accuracy settings and along with preferred response time all show NO REQUIREMENT as the pre configured setting. Again this is intended to show that no specified accuracy or response time are needed. There could just as easily be a requirement for the accuracy to fall within some number of feet or within some fraction of a degree of latitude longitude. The lack of a preferred response time could also be modified to a specified number of minutes seconds or fraction thereof. Finally with regard to set preferred power consumption is set to POWER USAGE LOW in order to reduce battery power consumed while determining the mobile device s location. This could be part of a two tiered system of LOW and HIGH settings a three tiered system adding a MEDIUM value or any other manner of setting the value consistent with the JSR 179 standard.

When implemented embodiments of the invention can be thought to exist between the physical device or physical components of the device and the application virtual machines that exist on the device. The remainder of the description will outline this process in a high level component context. A device location update component will be in communication with in turn a primary location determination module a verification module and a secondary location determination module. This occurs with a single process for requests to each successive module. The location determination modules are in communication with their respective physical components and the modules that accompany their function. Once complete the update component can pass information to any application virtual machine that requires such data. Thus the update modules and those that it communicates with are seen on an interface level sitting between the physical device components on the device level and the application VMs on the application level.

Applications are separated by a dotted line from location update component which is depicted in an interface level. Also included on the interface level is a primary location determination module a verification module and a secondary location determination module . There are a series of arrows to denote the processing thread that instantiates communication between the modules. The like numbered arrows denote a single thread thus thread and are actually the same processing thread operating at different stages of the API communications. Again one novel aspect of the invention is the ability of a single request to query both determination modules without the need to spawn a new thread for backup configuration parameter collection.

A first location determination source and a second location determination source are separated from the interface level by a second dotted line. These are in the device layer and represent the physical components needed for determining location information such as GPS components. These two components are in communication with the individual modules responsible for returning information from the physical devices and are represented with a set of communications and a set of communications .

Putting the entire flow together one of ordinary skill in the art can see how update module queries primary location determination module through communication . This query results in a set of values being returned from primary source as a result of communications . Those values are passed to verification module by communication . If the verification module finds valid values then the values are sent straight to update module through a communication . However if the verification module examines the values and confirms that a second source must be queried to obtain valid values communication is sent to secondary location determination module . Module receives a set of values from secondary physical components as a result of communication . Thus secondary location determination module is able to convey the values to location update module through communication . Once update module has received values from whatever source has provided it those values may be shared with applications as needed through a communication .

Many different arrangements of the various components depicted as well as components not shown are possible without departing from the spirit and scope of the present invention. Embodiments of the invention have been described with the intent to be illustrative rather than restrictive. Alternative embodiments will become apparent to those skilled in the art that do not depart from its scope. A skilled artisan may develop alternative means of implementing the aforementioned improvements without departing from the scope of the present invention.

It will be understood that certain features and subcombinations are of utility and may be employed without reference to other features and subcombinations and are contemplated within the scope of the claims. Not all steps listed in the various figures need be carried out in the specific order described.

