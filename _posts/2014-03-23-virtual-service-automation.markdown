---

title: Virtual service automation
abstract: A data source is identified that includes transaction data describing a set of transactions involving a particular software component and each transaction in the set of transactions includes a request and a corresponding response to the request. In some aspects, a modification to the data source is detected and the service model is caused to be generated based on detecting the modification. The service model is to model responses of the particular software component to requests in transactions based at least in part on the transaction data. A virtual service is caused to be generated based on the service model. The resulting virtual service can be configured to receive requests and generate virtual responses to the requests based on the service model to simulate responses of the particular software component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09531609&OS=09531609&RS=09531609
owner: CA, Inc.
number: 09531609
owner_city: Islandia
owner_country: US
publication_date: 20140323
---
The present disclosure relates in general to the field of computer development and more specifically to software development involving coordination of mutually dependent constrained systems.

Modern software systems often include multiple programs or applications working together to accomplish a task or deliver a result. For instance a first program can provide a front end with graphical user interfaces with which a user is to interact. The first program can consume services of a second program including resources of one or more databases or other programs or data structures. In some cases multiple interoperating computer programs and resources can be controlled or developed by a single entity such as a single enterprise publisher or developer. In other instances interoperating programs and resources can be developed and controlled by different parties. In some cases access to a system component can be constrained in connection with the testing or development of the program or its constituent components that are to interoperate with the other components for instance when the component is a live production database and cannot be conveniently brought offline is owned or controlled by a third party or is itself under development.

According to one aspect of the present disclosure a data source can be identified associated with a service model to be generated at least in part from transaction data deposited in the data source. The transaction data can describes a set of transactions involving a particular software component and each transaction in the set of transactions can include a request and a corresponding response to the request. Generation of the service model and corresponding virtual service can be automated. In some aspects a modification to the data source can be detected and the service model can be generated based on detecting the modification. The service model can model responses of the particular software component to requests in transactions based at least in part on the transaction data. A virtual service can be generated based on the service model. The resulting virtual service can be configured to receive requests and generate virtual responses to the requests based on the service model to simulate responses of the particular software component. In other aspects attributes of the service model and or virtual service used to configure and generate the service model and or virtual service can be identified from the transaction data and used in the automation among other examples such as described and shown herein.

As will be appreciated by one skilled in the art aspects of the present disclosure may be illustrated and described herein in any of a number of patentable classes or context including any new and useful process machine manufacture or composition of matter or any new and useful improvement thereof. Accordingly aspects of the present disclosure may be implemented entirely in hardware entirely software including firmware resident software micro code etc. or combining software and hardware implementations that may all generally be referred to herein as a circuit module component or system. Furthermore aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable media having computer readable program code embodied thereon.

Any combination of one or more computer readable media may be utilized. The computer readable media may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an appropriate optical fiber with a repeater a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable signal medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present disclosure may be written in any combination of one or more programming languages including an object oriented programming language such as Java Scala Smalltalk Eiffel JADE Emerald C CII VB.NET Python or the like conventional procedural programming languages such as the C programming language Visual Basic Fortran 2003 Perl COBOL 2002 PHP ABAP dynamic programming languages such as Python Ruby and Groovy or other programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider or in a cloud computing environment or offered as a service such as a Software as a Service SaaS .

Aspects of the present disclosure are described herein with reference to flowchart illustrations and or block diagrams of methods apparatuses systems and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable instruction execution apparatus create a mechanism for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that when executed can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions when stored in the computer readable medium produce an article of manufacture including instructions which when executed cause a computer to implement the function act specified in the flowchart and or block diagram block or blocks. The computer program instructions may also be loaded onto a computer other programmable instruction execution apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatuses or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring now to a simplified block diagram is shown illustrating an example computing environment including a virtualization system one or more transaction data source servers e.g. one or more application server systems e.g. including web servers application servers database systems mainframe systems and other example. One or more development servers e.g. among other example systems that can make use of virtual services provided through virtualization system can also be provided in environment . Virtualization system can be utilized to virtualize components of resources hosted by systems upon which other systems and their constituent components e.g. may depend. Virtual service models can be generated corresponding to interactions between the components of applications databases and services provided through hosted by systems and systems e.g. that consume these services. A virtual service can be launched based on the virtual service model. A virtual service can operate to stand in for the modeled component by simulating the modeled component s responses to requests and other messages received from other components e.g. components dependent on the modeled component . The modeled or virtualized component synthesized using a corresponding virtual service can be used in place of the real world component for instance when the component or system hosting the component is offline allows limited access e.g. is managed or owned by a third party under development or repair or is otherwise unavailable allowing software components dependent on the virtualized component to still be executed tested developed etc. against the simulations provided by the virtualized component.

Virtual service models can be based on transactions between components including transactions between applications services databases and other components. A transaction can include one or more requests and corresponding responses to the requests. Transaction data can describe the requests and corresponding responses. Such transaction data can be based on recorded instances of the transactions. Such instances can be monitored and recorded and include recorded real world transaction instances as well as recorded test transaction instances involving the component s to be modeled. Alternatively transaction data can be user defined or otherwise derived to describe desired idealized predicted or hypothetical responses of a particular component to various types of requests in various types of transactions. In some instances such transaction data can be derived by identifying expected behavior of a particular component from specification data log files Web Services Description Language WSDL or Web Application Description Language WADL descriptions or other structured or unstructured data describing the component s responses to various types of requests and other functionality and behavior of the component in transactions of particular types. Regardless of how the transaction data is generated the transaction data can be processed to identify patterns and behaviors relating to how one component responds to particular messages received from other components. Transaction data can describe requests and corresponding responses together with attributes of the respective requests and responses. In some cases requests and responses can be transmitted between components over one or more networks e.g. among other examples.

Computing environment can further include one or more user computing devices that can be used to allow users to interface with and consume resources of virtualization system application servers development system etc. For instance users can utilize computing devices to automatically launch a virtual service based on transaction data in one or more data sources e.g. hosted by one or more source servers . A user can also define how virtual services can be automatically launched from transaction data in response to defined triggers e.g. detection of a change to the transaction data that can cause automatic launching of the virtual service without further intervention of a user. User computing devices can also be used to define or generate transaction data as well as sources for the storage of transaction data. Users such as administrator users can further utilize user computing devices to instrument software components manage recording of transactions between applications and databases administer the generation of corresponding virtual services and perform other tasks in connection with the generation maintenance and use of virtual service models. In some cases such virtual services can be used in connection with the development and testing of an application portion of an application or other component that is dependent on one or more other components such as a web service mainframe system database etc. among other potential uses.

In general servers clients computing devices network elements database systems user devices and systems etc. e.g. etc. in example computing environment can include electronic computing devices operable to receive transmit process store or manage data and information associated with the computing environment . As used in this document the term computer processor processor device or processing device is intended to encompass any suitable processing device. For example elements shown as single devices within the computing environment may be implemented using a plurality of computing devices and processors such as server pools including multiple server computers. Further any all or some of the computing devices may be adapted to execute any operating system including Linux UNIX Microsoft Windows Apple OS Apple iOS Google Android Windows Server etc. as well as virtual machines adapted to virtualize execution of a particular operating system including customized and proprietary operating systems.

Further servers clients network elements systems and computing devices e.g. etc. can each include one or more processors computer readable memory and one or more interfaces among other features and hardware. Servers can include any suitable software component or module or computing device s capable of hosting and or serving software applications and services including distributed enterprise or cloud based software applications data and services. For instance in some implementations a virtualization system data source server application server or other sub system of computing environment can be at least partially or wholly cloud implemented web based or distributed to remotely host serve or otherwise manage data software services and applications interfacing coordinating with dependent on or used by other services and devices in environment . In some instances a server system subsystem or computing device can be implemented as some combination of devices that can be hosted on a common computing system server server pool or cloud computing environment and share computing resources including shared memory processors and interfaces.

While is described as containing or being associated with a plurality of elements not all elements illustrated within computing environment of may be utilized in each alternative implementation of the present disclosure. Additionally one or more of the elements described in connection with the examples of may be located external to computing environment while in other instances certain elements may be included within or as a portion of one or more of the other described elements as well as other elements not described in the illustrated implementation. Further certain elements illustrated in may be combined with other components as well as used for alternative or additional purposes in addition to those purposes described herein.

Virtual services represent a significant advancement over early technologies utilizing conventional mocking and stubbing implementations to provide a stand in for an available component. Virtual services can more accurately synthesize a virtualized component s role in transactions with other component and can enable smarter more life like synthesized responses such as responses dynamically generated to account for request sensitive values and time sensitive values stateless and stateful responses responses in transaction conversations sessions and correlated transaction contexts responses simulating performance of the virtualized component e.g. responsive to an assumed processor or memory load bandwidth or other network restrictions availability etc. among other examples.

While virtual services represent an advance from prior solutions enabling more efficient and accurate modeling of dependent systems traditional virtual services can still involve complex and specialized set up and administration leading to resources being dedicated to training or hiring expert administrative users to manage the generation and use of virtual services for an organization. In some cases multiple separate experts may be involved in the deployment of a virtual service an expert in the system that is to consume the virtual service an expert in the system with the components that are to be virtualized and a virtual services expert. An improved system is described that can simplify creation and management of virtual services by automating the generation and deployment of virtual services eliminating the need in some cases of a separate virtualization expert to enjoy the benefits of virtualization using virtual services among other example advantages.

At least some of the systems described in the present disclosure such as the systems of can include functionality providing at least some of the above described features that in some cases at least partially address at least some of the above discussed issues as well as others not explicitly described. For instance in the example of a simplified block diagram is shown illustrating an example environment including a virtual service system that includes a model generator adapted to assist in the generation of service models e.g. that can be used by virtual service engine to deploy virtual services to simulate behavior of one or more modeled components in transactions with at least one other software component. The virtual service system can further include an automation engine that permits automation of service model generation and virtual service deployment with minimal or no user intervention from transaction data . The automation engine can define and detect conditions for triggering the generation or update of a service model from transaction data sourced from the virtual service system e.g. at data store or from other sources e.g. defined as a repository of transaction data that is to serve as the basis of a corresponding service model modeling the transaction s described in the transaction data. Automation engine can detect when transaction data has been provided or updated and trigger automatic generation of a service model and launch of a corresponding virtual service. Automation engine can monitor data sources for the transaction data including sources to which transaction data can be added through one or more interfaces provided to outside users or systems. The automation engine can further operate with or trigger a corresponding model generator that can detect and determine request response attributes from transaction data detected by the automation engine and further generate or update a corresponding service model that can be used to also launch a virtual service that would otherwise or normally be manually provided or defined by a user e.g. using user device . The automation engine can also parse data in the transaction data to identify aspects of the service model and or virtual service to be automatically generated using the virtual service system including the transport protocol to be used by the virtual service e.g. HTTP JMS Java etc. data recorder attributes ports queues classes etc. the data format of the transactions to be modeled e.g. SOAP XML copybook etc. among other examples. These automatically determined attributes can be used to automate generation updating of a service model and or virtual service.

In addition to virtual service system computing environment can further include other systems devices and resource including one or more user devices e.g. systems hosting components that can be virtualized using virtual service system such as application servers database system among other examples. Transaction data can be defined by users or from data describing functionality of one or more components to be modeled or that are to interact with a component to be modeled. Transaction data can also include transaction data describing actually transactions that have been monitored and recorded for instance using connection monitors e.g. or agents e.g. deployed on one or more components involved in the recorded applications among other mechanisms.

In one example implementation a model generator can be provided that includes hardware and software based components such as data manager and service model generator . An example data manager can interface with various recording components such as monitors e.g. that monitor request and response communications e.g. over a port or network e.g. between components engaged in transactions as well as agents e.g. instrumented on the components participating in the transaction to obtain transaction data from the monitoring. Data manager can also obtain transaction data e.g. from a variety of other sources e.g. . Indeed sources or stores of transaction data e.g. can be designated for use in a generating a service model to instantiate a corresponding virtual service. Such stores e.g. can include directories and servers of data describing requests and corresponding responses in transactions including request response files packet capture data an organization s web server an email inbox or other folder among potentially limitless other stores of various forms of transaction data. Virtual service system can further include source adapters that include logic for interfacing with different types of outside transaction data e.g. and transaction data sources e.g. . Source adapters can further include logic for pre processing a corresponding type of transaction data to extract request response pairs in transactions described in the transaction data and prepare the processed transaction data for use in service models generated by the virtual service system . In some instances a single service model can be generated from transaction data from multiple different sources and or of multiple different types. Source adapters can normalize information included in various forms of transaction data to allow a combination of different transaction data to be used to assemble a single service model that describes the universe of requests that may be fielded and that defines how responses to these requests are to be synthesized. A model generator can include service model generator logic that can utilize normalized transaction data to generate such service models . In some implementations at least a portion of the logic or library of source adapters can be integrated within the model generator allowing service models to be generated from a variety of different transaction data e.g. from a variety of different sources e.g. .

Transaction data e.g. can describe request response pairs within transactions including attributes of the requests and responses such as the values included in the requests and responses timing of the requests and responses the transport details regarding how the requests and responses are communicated between components among other examples. Transaction data e.g. can further describe one or more characteristics associated with the activity and or the context in which that activity occurs. For instance transaction data can be generated to describe monitored transactions. Transaction data can include information collected by the monitoring components e.g. agents connection monitor etc. describing characteristics observed by the monitoring component including information beyond the attributes of the recorded requests and responses such as information concerning the context or environment in which the recording takes place. Transaction data e.g. can include for example a frame identifier which identifies a message in a transaction a parent identifier which identifies the requester that generated the request sent to the component or sub component monitored by the agent a transaction identifier identifying the transaction with respect to the component or sub component being monitored and an identifier that identifies the monitoring component that captured or generated the monitoring data among other examples. Characteristics can further include other information describing the message or transaction such as a system clock value current processor and or memory usage contents of the request contents of the response to the request identity of the requester that generated the request identity of the responder generating the response to the request Java virtual machine JVM statistics structured query language SQL queries SQLs number of database rows returned in a response logging information e.g. messages logged in response to a request and or response error messages session identifiers database connection identifiers simple object access protocol SOAP requests other values generated by the monitored component that are not provided in the request or the response web service invocations EJB method invocations EJB entity lifecycle events heap sizing and the so on. Characteristics can also include the thread name of a thread processing the request to generate the response the class name of the class of an object invoked to process the request to generate the response a Web Service signature used to contain the request and or response arguments provided as part of the request and or response a session identifier an ordinal e.g. relating to an order within a transaction the duration of time spent processing the request and or generating the response state information a local Internet Protocol IP address a local port a remote IP address a remote port among other examples.

Monitoring components can monitor and report characteristics independently for each transaction in which the monitored component being monitored participates. In addition to monitoring the performance of a single component and aggregating information about that component over a multitude of transactions such that information about the performance of individual transactions can for example be averaged based upon the observed performance of the component over the course of performing the multitude of transactions monitoring components can additionally detect characteristics that are specific to and correlated with a specific transaction between a particular component and another component. More particularly detected characteristics can be specific to and correlated with a particular request and or response generated as part of a transaction.

As noted above transaction data can be manually created by users derived from data describing functionality of the component to be modeled or generated from monitoring of actual transactions. In the case of transaction data generated from transaction monitoring a variety of monitoring mechanisms components or logic can be used to capture requests and responses between components. Such components can include components such as connection monitor that can monitor communications between components over ports or networks e.g. . In one example implementation a connection monitor can include a processor memory and monitoring logic implemented in software and or hardware of the connection monitor .

Other monitors can be used to record transaction including agents e.g. instrumented on one or more of the components e.g. application involved in a transaction. In some implementations a virtual service system can include an agent manager that can include functionality for interfacing with one or more agents e.g. instrumented in virtual machines applications or software components such as software components involved in transactions involving a Java based system database .NET based system or other system or component. For example in some implementations agents can include functionality similar to functionality described for instance in U.S. patent application Ser. No. 11 328 510 titled Instrumentation System and Method for Testing Software filed Jan. 9 2006 which is hereby incorporated by reference in its entirety as if completely and fully set forth herein. Agent manager can manage recording of transactions using deployed agents e.g. . Agents can capture data as it enters or exits the software component including data describing method calls and other requests and corresponding responses that are exchanged between the instrumented software component s and other components. Agents can be used for instance to capture transactions between an application and a database using for instance a database API e.g. used by the software component or application virtual machine etc. to interface with databases among other examples. Not only can agents capture the contents of requests and responses but agents can also capture context data such as session data connection data timing data and other information that can be used to associate various requests and responses together. Agents can inspect the internal data of a component upon which it is implemented and such internal data can also be reported as context data. Such context information can be further used to identify correlations between multiple services or components within a transaction context.

In some cases instrumentation agents e.g. or agents can be software implemented agents that are configured to provide visibility into the operations of each instrumented component to one or more agent managers provided in connection with a virtualization system. Each instrumentation agent e.g. can be configured to detect requests and responses being sent to and from the component in which that agent is embedded. Each agent can be configured to generate information about the detected requests and or responses and to report that information to an agent manager e.g. within coupled to or otherwise associated with a virtual service system . Additionally each agent can be configured to detect and report on activity that occurs internally to the component in which the agent is embedded.

In some cases there may be a single instrumentation agent per component while other embodiments may be implemented differently. For example in some systems there can be a one to one correspondence between the number of instrumentation agents within a component and the number of processes or other subcomponents to be monitored within that component. In such embodiments each instrumentation agent monitors and reports on its corresponding sub component. In other instances a single agent can monitor and have visibility into multiple components among other examples.

In some implementations a model generator can obtain a variety of information concerning transactions from the various forms of transaction data e.g. identified as corresponding to the transactions and components to be modeled. Service model generator can organize this information for instance to group information relating to common transaction fragments transactions and sessions involving multiple transactions and generate service models from the transaction data e.g. . Service models can include models that model a single service or component as well as composite service models that model multiple services and or components within a business transaction including multiple correlated transactions involving the multiple components among other examples.

As noted above service model generator can organize information in monitoring data so that information that describes characteristics of a particular transaction or business transaction involving multiple correlated transactions is grouped with other information describing the same transaction. Thus individual frames each of which can be received from a different instrumentation agent or other monitoring component can be organized into groups of frames that describe a complete transaction. Such grouping can be based on detecting correlations between requests and responses including timing information indicating a temporal relationship between the transactions common tags inserted by an agent in intercepted requests and responses an identified parent child or requester responder relationship between components in the transaction common values e.g. transaction ID customer ID session ID etc. included in captured requests and responses recurring patterns in conversations or flow between the components participating in transactions among other examples.

In some cases agents and other monitoring components can be provided with functionality for tagging data of a request or response monitored by the agent before it exits or enters the component it monitors the tag identifying a particular session or transaction to which the request or response and corresponding characteristic information belongs. After being sorted the frames can be arranged in ascending or descending order for instance using timing information inserted tag data or other information. For example the frames can be sorted according to a timestamp indicating when each frame was generated when one or more requests identified in each frame were generated or received and or when one or more responses identified in each frame were generated or received. In some embodiments the frames can be sorted based upon multiple pieces of timing or other flow information. Additionally a flow can be identified by identifying the requester responder parent child relationships of each portion of the business transaction among other information.

Within a group of frames associated with the same transaction or session service model generator can order the frames such that the flow of the transaction can be followed from the start of the transaction to the end of the transaction. Each frame can include a field that identifies that frame e.g. a frame ID as well as a field that identifies a parent frame e.g. a parent frame ID . The value of each frame s parent frame ID can equal another frame s frame ID. These frame identifiers can be generated in some cases by the agents. In one embodiment the frame identifiers can be generated from information identifying the IP address or other addressing information port number session identifier or other information used by the monitored component or sub component the amount of data sent or received by the monitored component during the monitored activity and or the instrumentation agent itself.

A virtual service engine can use a set of expected requests and responses defined in service models to provide one or more virtual services simulating operation of a modeled component such as a database applications e.g. mainframe components or other component. Service models can further support stateful virtualization and imitate a series of particular requests in a session. In one example virtual service engine can include hardware and software based components such as virtualization engine among potentially other example components. Virtualization engine can be provided to instantiate or launch virtual services from service models . Instantiation of a virtual service can include deploying logic in a computing device and or virtual machine that is to host the virtual service and serve as the redirect target for intercepted requests intended for the real world or live version of the component simulated using the virtual service. Virtualization engine can build a virtual service environment within a hosting device or virtual machine and provision the virtual service environment with virtual service logic that is access a particular one of the service models and generate synthetic responses to received requests based on the particular service model.

A service model can be provided to stand in for an unavailable real world version of the modeled component. For example it can be identified that a dependency of an application e.g. such as another application e.g. is unavailable. A virtual service model corresponding to the dependency can be identified and a corresponding virtual service simulating the other application e.g. can be initiated. Such virtual services can be generated and provided according to principle described in U.S. Pat. No. 8 112 262 entitled Service Modeling and Virtualization among other examples. For instance in some cases virtualization engine can provision a virtual service in a virtual machine with which a software component can interact with directly in lieu of the modeled dependency. In other instances virtualization engine can utilize agents e.g. to provide the responses of a virtualized dependency. For example virtualization engine can communicate with agents provisioned on the consuming system to intercept particular requests from the consuming component and generate synthetic responses consistent with a transaction defined in a corresponding service model that mimics the response that would be received from a live version of the dependency.

As noted service models e.g. generated by a model generator can be based on requests and responses between two or more software components or systems such as an application e.g. and database e.g. hosted by database system . Requests that are to be sent to a real world version of a virtualized component can be intercepted and directed to the virtual service standing in its place. A virtualization engine and or virtual service logic provisioned on a host of the virtual service can receive intercepted requests intended for the virtualized component and identify respective transactions or request response pairs defined in a service model e.g. corresponding to the virtualized component that corresponds to a request of that type and having similar attributes values or types. The service model can further describe characteristics of the transactions. Such information can include timing information identifying time thresholds or limits at which particular requests and or responses are detected or sent e.g. in order to identify the delay between when the request was detected and or sent and when the associated response was detected and or sent and the like. Virtual services instantiated from such service models can embody these performance characteristics captured or defined in the service model including response times network bandwidth characteristics processor usage etc.

In one example a virtualization engine can be configured to identify and describe requests and responses in each of a variety of different protocols as well as the pertinent information from each. Thus service models can include configuration information identifying the basic structure of requests and responses for each of several supported communication protocols. Depending upon the protocol in use for instance requests can take the form of method calls to an object queue and topic type messages e.g. such as those used in Java messaging service JMS requests to access one or more web pages or web services database queries e.g. to a structured query language SQL or Java database connectivity JDBC application programming interface API packets or other communications being sent to a network socket and the like. Similarly responses can include values generated by invoking a method of an object responsive messages web pages data state values e.g. true or false and the like.

Service models can be used as the basis of virtual services modeling the software components providing the requests and or responses modeled in the service models . Virtual services can capture and simulate the behavior data and performance characteristics of one or more unavailable or inaccessible component making synthetic substitutes of the components available for instance in connection with development and testing efforts throughout the software lifecycle among other advantages. Virtual services generally can provide functionality beyond traditional piecemeal responders or stubs through logic permitting the recognition of input requests and generation of outputs responses that are stateful aware of time date and latency characteristics support such transaction features as sessions SSL authentication and support string based and dynamic request response pairs among other features. Service virtualization and other virtual models can be leveraged for instance when live systems are not available due to project scheduling or access concerns. In cases where components have not been built yet environments can employ virtual services to rapidly model and simulate at least some of the software components to be tested within an environment. Virtual services can be invoked and executed in a virtual environment implemented for instance within on premise computing environments agents in private and public cloud based lab using virtual machines traditional operating systems and other environments among other examples.

As noted above in some implementations when a service model is used to instantiate a virtual service the virtualization process can involve comparing new requests generated by a requester e.g. a client application under development to the request information stored in a corresponding service model. For example if a new request containing a particular command and attributes is received the service model can be searched for a matching request that contains the same command and attribute. If a matching request is found the virtualization process returns the response as identified by information stored in service model associated with the matching request to the requester.

In many situations the requests provided to a virtual service will not be exactly the same i.e. containing the same request as well as the same attribute s as the requests identified in service model. For example a request provided to the corresponding virtual service may contain the same request but a different attribute or set of attributes. A service model can further include information usable to handle these requests. For instance transactions containing requests that specify the same command can be identified as being of the same transaction type. Alternatively a set of transactions can be identified as being of the same type if all of those transactions have requests that include the same command as well as the same number and type of attributes. The particular technique used to identify whether two or more transactions are of the same type can be protocol specific in some embodiments e.g. classification of transactions can be at least partially dependent upon the particular communication protocol being used between the requester and the server .

For each unique type of transaction included in a service model some implementations of a service model can further provide information or instructions for use by a virtual service in generating responses to requests with unknown attributes e.g. an unknown attribute that was not observed as part of the monitored traffic or even specified by a user during a manual service model building process . Further service models can also include information describing how to respond to an unknown request e.g. a request that contains a command that was not observed as part of the monitored traffic . As an example the request portion of this service model information can indicate e.g. through the use of a wildcard command identifier that all unknown types of requests that are not otherwise identified in service model should match this request. The response portion of the generated information can include an appropriate response among other examples.

In addition to adding information describing unknown transactions of known and unknown types some implementations of service models can support time sensitive responses. In such embodiments response information in the server model can facilitate substitution of time sensitive attributes for actual observed attributes. For instance an actual attribute 10 59 PM Oct. 1 2009 can be replaced with a time sensitive value such as SYSTEM CLOCK 11 HOURS . When the service model is used to generate responses by the virtual service the time sensitive value can be used to calculate the appropriate attribute to include in each response e.g. based on the current system clock value . To illustrate in this particular example if the service model is being used by a virtual service and the response attribute includes the time sensitive value SYSTEM CLOCK 11 HOURS the response generated based upon the service model will include the value generated by adding 11 hours to the system clock value at the time the request was received. In general time sensitive values specify an observable time such as a time value included in a request or the current system clock time and a delta such as an amount of time to add or subtract from the specified observable time. Time sensitive values can be included in the response information for all types known and unknown of transactions.

In some implementations a service model can further include information facilitating the use of request sensitive values to be included in responses generated by the virtual service using the service model. A request sensitive value can link an attribute included in the request to a value to be included in the response. For example response information in a service model can indicate that a particular request attribute be used as the basis of a particular attribute of the response to be returned in response to the request.

When the model is used the response generated by the virtualized service will include the value indicated by the request sensitive value. For example the model can include three known transactions of a given transaction type as well as one unknown transaction of that type. The information describing the unknown transaction can indicate that the single response attribute is a request sensitive attribute that should be the same as the first attribute of the request. A request of that type that contains an unknown first attribute i.e. an attribute that does not match the attribute s stored for the three known transactions of that type in the model can be sent to the virtualized service. In response to receiving this request and accessing the request sensitive value specified in the response information for the unknown transaction the virtualized service returns a response that includes the value of the first attribute that was contained in the received response. As an example if the information describing a known transaction of type A indicates that the request includes the string UserID as the first request attribute and that the corresponding response includes the string UserID as its second response attribute a request sensitive value specifying REQUEST ATT first request attribute can be generated for the second response attribute in the service model among many other potential examples including more complex examples with more complex dependencies defined in the service model between certain request attribute and request sensitive response attributes.

A service model can include still additional information. For example a service model can identify characteristics of each transaction in order to identify availability windows for a corresponding software component modeled by the service model load patterns for the software component and the like. For example if an access window is identified for a particular type of transaction a corresponding service model can be generated to include a characteristic indicating that a response or a particular type of response will only be generated if the request is received during the identified access window among many other potential examples.

Turning to a simplified block diagram is shown representing an example view of an example service model . For instance shows information that can be maintained as part of a service model. In this particular example service model can include a row for each of several transactions. Each row of service model can identify a command zero or more attributes zero or more characteristics and one or more response attributes. This service model can be stored in a spreadsheet table database or any other data structure.

In this example transaction A is a transaction corresponding to a scenario defined in an interaction contract defined between two or more developers. In other instances transaction A can be a transaction that was an observed transaction that actually occurred between a requester and a server component being modeled as detected for instance by an agent or other tool. The information describing transaction A can include request information which includes command and zero or more defined attributes . The information describing transaction A can also include response information describing the expected response that corresponds to the request. This response information can also include one or more attributes. Characteristics can include zero of more characteristics of transaction A defined based on scenarios of the interaction contract. These characteristics can include timing information describing a threshold delay of a response to a request or the like as described above.

Transaction B can be of the same transaction type as transaction A since both transactions included a request that contained command . Transaction B is described by attributes which can have values that differ from those attributes defined in the request of transaction A characteristics which can again differ from those for transaction A and response which can also have a value that differs from the response defined for transaction A .

In this example information describing n an integer number known transactions of the same type as transactions A and B is stored in service model . These known transactions are transactions that were either generated from scenario data or manually specified by a user. As part of the model building process information describing an n 1th transaction of the same type has been added to service model by the service model generator. This n 1th transaction labeled transaction 1 can describe an unknown transaction of a known type of transaction. Such an unknown transactions is of a known type because it has the same command command as the other transactions of this type. However unlike the other known transactions of this type unknown transaction 1 can be used to respond to requests containing command and unknown attributes that do not match those known attributes stored for transactions A not shown . The information describing transaction 1 thus includes information e.g. wildcard information identifying unknown attributes 1 such that any request that includes command and an attribute that does not match the defined attributes stored for the actual transactions e.g. such as transactions A and B will match the request information for transaction 1 . The information describing transaction 1 can also include default characteristics 1 and default response 1 . These default values can be copied from the corresponding fields of an actual response of the same type.

Information describing another set of transactions of a different type can also be stored within the service model for a particular software component. As shown m 1 transactions including transaction A B and 1 of a type of transaction in which the request includes command can be stored in service model . Like transactions A and B transaction A can be another transaction corresponding to a scenario and involving the particular software component. Further the information describing this transaction can also include the corresponding command attributes if any defined characteristics if any and corresponding response .

In some instances a model generator can automatically generate a set of requests and responses together with corresponding attributes and characteristics of the requests and responses based on computer parsable scenario data provided to the model generator. In some implementations a user can supplement the transaction defined by the model generator with one or more user specified transactions for instance in the event of a change or exception to the interaction contract or to capture a nuance not adequately detected and captured by the model generator among other examples. For instance a user can enter the information describing such a transaction via a user interface. The information describing transaction B can include command zero or more user specified attributes zero or more user specified characteristics and a user specified response . In some embodiments the user is prompted for entirely new information for each of these user specified fields. In other embodiments the user can be allowed to select an existing field e.g. of another user specified transaction or of an automatically detected transaction to copy into one or more of these fields. It is noted that a user can also create a user specified transaction by modifying information describing an actual transaction. As shows user supplied transaction information can be stored in the same model as transaction information generated from parsing of scenario data of an interaction contract. In other instances service models can be generated that are dedicated to user supplied transaction information while others are dedicated to transaction information generated from scenario data by a model generator among other examples.

In some instances a service model can also include information describing an unknown transaction 1 . The information describing transaction 1 was added to service model after m an integer number which does not necessarily have the same value as n known transactions were described by the model. The information describing this unknown transaction 1 can be used to handle requests of the same type e.g. containing command that specify unknown attributes. Accordingly the information describing transaction 1 can include command unknown attributes 1 i.e. attribute information that will match any attributes not identified in the known attributes stored for the other m transactions of this type default characteristics 1 and default response 1 . Further transactions of an unknown transaction of unknown type e.g. can also be defined in a service model . For instance the information describing transaction can be used to respond to any request of a type not already described by another row of service model . Accordingly a request containing a command other than commands and could be responded to using the information describing transaction among other examples. As shown the information describing transaction includes unknown command information which is configured to match any command not already specified in service model unknown attribute information which is configured to match all attributes if any associated with unknown commands default characteristics and a default response . As with the default characteristics and responses associated with unknown transactions of known type transaction s default characteristics and response can be user specified.

Turning to a simplified block diagram is shown illustrating representing example features of an example service model for use in virtual services supporting stateful and stateless transactions. Statefulness of a transaction can be identified from parsing of scenario data to generate a service model supporting the modeling of such stateful transactions. In the example of a data model is shown that includes five data patterns traffic pattern conversation pattern transaction pattern request pattern and response pattern . Traffic pattern can be used to store information identifying a particular software application to be developed in accordance with an interaction contract and the transactions of such an application. Each service model can include a single instance of traffic pattern . As shown traffic pattern includes created field which stores date information identifying when the service model of that particular application was initially created. Traffic pattern also includes lastModified field which stores date information identifying the most recent time at which any of the information in the service model of the particular service was modified.

Traffic pattern can also include an unknownResponse field . UnknownResponse field can store information identifying the particular instance of the response pattern that stores information identifying the response to use for unknown transactions of unknown types. Accordingly in embodiments employing the data pattern of if an unknown transaction of unknown type is detected by a request processing module the request processing module will use the response pattern instance identified in unknownResponse field to generate a response.

Traffic pattern includes conversations field . Conversations field can identify one or more instances of conversation pattern . Conversation pattern stores information representing a set of two or more stateful transactions. Such a set of stateful transactions is referred to herein as a conversation. The instance s of conversation pattern identified in conversations field identify all of the conversations for the application to be modeled. If the particular service does not include any stateful transactions e.g. if no stateful transactions are identified from scenarios defined for an interaction contract conversations field will not identify any instances of conversation pattern .

Traffic pattern can additionally include statelessConversation field . This field can identify one or more instances of transaction pattern . Transaction pattern stores information representing a transaction. Each instance of transaction pattern identified in statelessConversation field stores information identifying a stateless transaction. StatelessConversation field can identify instances of transaction pattern associated with both known and unknown transactions of known types. If the particular service being modeled does not include any stateless transactions statelessConversation field will not identify any instances of transaction pattern . Type field can store one of two values INSTANCE or TOKEN that identifies the type of stateful transactions if any provided by the service being modeled.

As noted above conversation pattern can store information identifying a set of stateful transactions. A given service model can include n instances of conversation pattern where n is an integer that is greater than or equal to zero. Conversation pattern can include a starter field . This field stores information identifying an instance of transaction pattern associated with a starter transaction. The starter transaction is a transaction that acts as the first transaction in a stateful series of transactions e.g. a login transaction . In at least some embodiments all starter transactions can be unknown transactions of known type as will be described in more detail below. The particular transaction type to use as a starter transaction can be specified by the model generator or a user during the service model configuration process.

Conversation pattern also includes reset field . Reset field stores information identifying one or more instances of transaction pattern each of which is associated with a reset transaction such a reset transaction can be a known or unknown transaction . The value of reset field can be provided by a user e.g. the user can be prompted to identify the reset transaction s for each conversation . A reset transaction is a transaction that if detected causes the flow of the conversation to return to the point just after performance of the starter transaction. Conversation pattern also includes a goodbye field . This field stores information identifying an instance of transaction pattern associated with one or more goodbye transactions of known or unknown type for the conversation. A goodbye transaction is a transaction that causes the conversation to end. To reenter the conversation after a goodbye transaction is performed the starter transaction for that conversation would need to be re performed.

Transaction pattern stores information identifying a transaction. Transaction pattern includes request field responses field parent field children field and matchTolerance field . Transaction pattern can be used to store stateful and stateless transactions in some instances the same transaction can occur both within a conversation and in a stateless situation where no conversation is currently ongoing . Transactions that are always stateless will not include values of parent field children field or matchTolerance field .

Request field identifies the instance of request pattern that stores information identifying the request e.g. by command and attributes portion of the transaction. Similarly responses field identifies one or more instances of response pattern that store information identifying the response s that are part of that transaction. Each instance of response pattern stores one response attribute e.g. like those shown in and thus if responses field identifies multiple response patterns it indicates that each of the identified response patterns should be used to generate a response when the corresponding request is received.

Parent field stores a value identifying the instance of transaction pattern associated with the transaction that occurs immediately before the current transaction in a conversation. Thus if transaction pattern stores information identifying the second transaction in a conversation where the starter transaction is the first transaction in the conversation parent field can identify the instance of transaction pattern associated with the starter transaction. Similarly children field can store information identifying each instance of transaction pattern associated with a child transaction of the current transaction. Thus if transaction pattern stores information identifying the second transaction in a conversation children field can store information identifying the instance of transaction pattern that stores the third transaction in the conversation. It is noted that children field can identify more than one transaction.

MatchTolerance field can store one of three values STRICT CLOSE or LOOSE. The stored value indicates the match tolerance for a request received immediately subsequent to the current transaction. Strict tolerance indicates for instance that if a conversation is ongoing the request received immediately after the current transaction is only allowed to match transactions identified in the current transaction s children field . If instead close tolerance is specified the request received immediately after the current transaction can match any of the current transaction s children as well as any of the current transaction s sibling transactions. Further if loose tolerance is specified even more transactions are candidates for matching the next received request and so on.

Request pattern can include a command field attributes field and characteristics field . Each instance of request pattern stores information identifying a particular request. A service model generator can allocate an instance of request pattern for each transaction of known or unknown type. Command field can store a string that identifies the command contained in the request. Attributes field can store a parameter list that includes zero or more parameters each of which represents an attribute of the request. Characteristics field can store a parameter list identifying zero or more characteristics associated with the request. Each parameter in the list can identify a different characteristic. Examples of characteristics can include the time at which the request was sent the system clock time at which the request was received by the service being modeled network and or system conditions that were present when the request was received and the like. The parameters stored in characteristics field can be used to generate time sensitive values as well as to model actual conditions such as response timing and availability window among other examples.

Response pattern can include an attribute field and a characteristics field . Attribute field stores a string that represents a response attribute. As noted above a given transaction can have multiple response attributes e.g. responses field of transaction pattern can identify multiple instances of response pattern and thus generating a response can involve accessing multiple response patterns in order to include the string identified in each of the response patterns attribute field in the response. Attribute field can store one or more response attributes as well as values like request sensitive values and time sensitive values generated by the service model generator. Characteristics field can store a parameter list containing zero or more parameters. Each parameter can identify a characteristic of the response such as the system clock time when the response was sent to the requester by the service network and or system conditions that were present when the response is to be sent and the like.

Returning briefly to the discussion of an example computing environment can further include other systems. For instance application servers can be provided that each host one or more applications e.g. . An application server e.g. can include one or more processors e.g. and one more memory elements e.g. . In some instances software components of applications e.g. hosted by application servers can access one or more databases e.g. on using one or more database APIs or drivers e.g. . Databases can be hosted by external database systems e.g. with which applications can interact over one or more networks e.g. . Database systems e.g. can include one or more processors e.g. and one more memory elements e.g. along with a database management system DBMS e.g. such as a DBMS configured to interface with and manage connections with potentially multiple applications including applications using one or more database APIs e.g. to access a database among other examples.

Computing environment can further include one or more user devices e.g. that can be used to administer the generation of service models and instantiation of corresponding virtual services through a virtual service system e.g. . In some implementations trained administrative users can utilize a user device to administer aspects and tasks in the virtualization of a particular component. For instance an administrator can manually administer recording of transaction data e.g. start and stop a recording tool define characteristics of a corresponding service model that is to be generated from the transaction data and define attributes of a virtual service that is to be instantiated from the service model e.g. the technology and transport to be employed where and how the virtual service is to be deployed etc. among other examples. For instance a user may be asked to start a recorder manually configure the transport protocol to be used by the virtual service e.g. HTTP JMS Java etc. manually configure recorder endpoint details ports queues classes etc. manually identify the data format of the transactions to be modeled e.g. SOAP XML copybook etc. manually deploy the virtual service e.g. identify a corresponding virtual service model and deploy the virtual service on a particular virtual service environment and manually start the virtual service among other examples. These and other steps can be automated using

Service virtualization can be simplified through the provision of an automation engine that can cause a virtual service to be created and launched automatically in response to a user or system merely providing transaction data that describes request response pairs in a transaction. In some examples a user can utilize a GUI e.g. to provide transaction data to a data source. The transaction data can be provided by the user through a variety of mechanisms such as an email inbox web server directory or other mechanism that can allow transaction data to be transferred from the user e.g. from the user device memory to a data source or store e.g. monitored by automation engine . A user can define e.g. through one or more GUIs e.g. rules for generating and launching a virtual service from transaction data detected at a data source. For instance a user can define a pointer to the data source such as a directory and cause the pointed to data source to be monitored e.g. by automation engine for changes to transaction data stored added to the data source. Additionally in some implementations a user can define conditions for triggering the automated generation and launch of a virtual service from transaction data added to a designated source e.g. such as a source to which recorded transaction data is automatically deposited e.g. by connection monitor such as a threshold amount of data type of update time between updates to the source among other potential examples. An example user device e.g. can provide GUIs e.g. allowing a user to perform such activities and include a processor memory an operating system one or more software applications among other example hardware and or software components.

Turning now to a simplified block diagram is shown illustrating a flow in components used in an example automation of generating and launching a virtual service. A virtual service can be provisioned in a virtual service environment automatically from transaction data detected within data sources e.g. . A plurality of different data sources e.g. can be provided for accepting new transaction data. Source adapters can be provided for each type of transaction data that may be processed to identify request response pair information that can be used to construct service models. The source adapters can process particular types of transaction data by automatically opening or unpacking the data e.g. unzipping decrypting and other tasks parsing the transaction data to identify the information describing request response pairs and normalizing in some cases the data for consumption by an automation engine and later a service model generator among other example tasks. The automation engine can monitor data sources for new transaction data that includes request response pair information. The automation engine can utilize results of the source adapter processing to determine that new or modified data is present within a data source that is relevant to the generation or modification of a corresponding service model. The automation engine can further automatically identify from the transaction data attributes of the virtual service that is to result such as the technology e.g. Java Bean SOAP XML etc. . The automation engine can provide this information to other components of a virtual service system such as the service model generator and virtual service engine to automate the generation of a service model modeling requests and responses involving a particular component in various transactions and automate the launching of a virtual service from the service model. The launched virtual service can be provided within a virtual service environment that can then serve as a stand in for a real world software component modeled by the generated service model.

Turning to another simplified block diagram is shown illustrating automation of various tasks within development of a virtual service using a virtual service system. In some implementations a user may perform each of tasks manually in that the user interacts with corresponding user interfaces of the virtual service environment system to define and administer each aspect and step in the development of a virtual service. Such a hands on approach may not always be appropriate or optimal particularly for organizations who seek to utilize virtual services but lack the expertise or confidence to navigate the manual building of a virtual service. In this particular example the only steps to be performed by a person system or organization seeking to generate and launch a virtual service is the preparation and provision of transaction data . The transaction data can be prepared through a variety of ways including through user definition of request response pairs in transactions involving a particular component to be modeled monitoring actual transaction between the particular component and at least one other component defining or extracting other structured or unstructured data that describes request response behavior of the particular component among other examples. The transaction data can be provided to a data source that is accessible to the virtual service system and merely providing the transaction data can by itself trigger and enable the automation of remaining steps to result in the launch of an available virtual service based on the prepared transaction data . For instance detection of provided transaction data can cause the virtual service system to be launched and service models to be generated or updated based on request response pairs identified in the provided transaction data . A virtual service can be generated from the corresponding service model and the virtual service can be provisioned and launched within a virtual service environment implemented using one or more virtual machines. To the user in such examples transaction data is provided as an input and a virtual service is launched and made available as a response to the provision of the transaction data without in some cases any further intervention on the part of the user or system providing the transaction data .

In the example of a simplified block diagram is shown illustrating that a virtual service can be continuously and automatically updated and redeployed in some instances using an automation engine of a virtual service system. Transaction data describing request response pairs can be used to generate a service model from which a virtual service can be created. As additional or otherwise modified transaction data corresponding to the component and transactions modeled by the service model are detected e.g. by an automation engine the underlying service model can be automatically and dynamically modified to incorporate the information included in the new changed or otherwise modified transaction data. Further a virtual service can be created based on the updates to the service model and the virtual service can be deployed and started all in response to the detected modification to the transaction data. A data source identified as corresponding to the service model and virtual service can continue to be monitored . As modifications are detected the service model and virtual service can be re created to account for new information such as new request response pairs included in the modified transaction data. The virtual service can be re deployed with the modified virtual service with the cycle continuing as additional changes are made to the underlying transaction data. In some cases transactions can be monitored involving a live version of the software component modeled by the service model and the transaction data generated from the monitoring can be input to the monitored data source to cause the corresponding virtual service to be continuously and dynamically updated and re launched to account for the evolving knowledge gleaned from the monitoring among other examples.

In some implementations a virtual service system can be made available as a remote or cloud based service to multiple customers in that functionality for generating and launching virtual services is served remote from the organization using the service. A variety of use cases can utilize such an architecture. Additionally the generation of virtual services can be automated in response to a variety of different inputs. In one example illustrated in the simplified block diagram of one or more email inboxes can be provided for accepting transaction data that is to be used in the generation of a virtual service. A particular inbox data source can be designated as corresponding to a virtual service that is to model a particular software component. The inbox can be monitored by an automation engine of a virtual service system . A user e.g. using user device or system can upload transaction data including information describing one or more request response pairs through an email sent through an email interface to inbox . The email can include the transaction data as an attachment such as a zip file including one or more transaction data files. Source adapters of the virtual service system can process the email to access and open the attachment extract transaction data and process transaction data to identify request response pair information contained in the transaction data . The request response pair information can be identified and trigger generation of service model by model generator . Virtual service engine can also be invoked in response to the email and corresponding generation of service model to build the virtual service from the service model . Attributes of the virtual service can be identified from transaction data such as the technology to be emulated by the virtual service the type of virtual service e.g. whether the virtual service is implemented using one or more agents transport connection details of the transactions to be virtualized e.g. hostname port queue names class names etc. data format details for use in normalizing the data e.g. SOAP structure XML elements copybook format etc. response time characteristics e.g. delays change of delays over time etc. integration of meta data from external systems e.g. integration of performance response time data from an application performance management system among other examples and desensitization of data contained in the responses among other examples. The virtual service engine can provision or deploy the virtual service within a virtual service environment and the virtual service can be started to interact with a consuming system all in response to the sending of email in some implementations.

Turning to a simplified block diagram is shown illustrating another example implementation utilizing a web interface through which a user e.g. using user device or system can upload transaction data e.g. to a directory or other data store designated as associated with the modeling of one or more particular software components through a virtual service e.g. . Like the inbox in the example of the directory can be monitored by an automation engine or other logic of virtual service system to detect modifications or additions to transaction data e.g. upon which a service model is to be built for use in generating virtual service . As in other examples a source adapter can process transaction data received through the web interface to identify request response information that can be used in the generation of service model . Further in some implementations uploading the transaction data over web interface to director can trigger the automatic generation updating of service model and the generation and launching of virtual service all without further intervention or instructions of the user or system that is effectively requesting the virtual service through the provision of transaction data

In yet another example shown in the simplified block diagram of an API can be provided through which an application server or other system can interface with a data source monitored by an automation engine of a virtual service system . A system can send transaction data to the data source using API . Detecting new request response information in transaction data can trigger the automatic generation of service model and launch e.g. generation and deployment of a corresponding virtual service . In the example of a simplified block diagram is shown of a monitoring component such as a connection monitor or instrumentation agent that monitors requests and responses in transaction between two or more components such as a first component hosted on system and a second component hosted on system . One of systems can host the software component s that is to be simulated using the resulting virtual service . Transaction data generated by the monitor can be streamed copied forwarded or otherwise sent to a data source that is designated as a source of transaction data for a particular service model and virtual services launched from the service model. Like other data sources an authentication engine can monitor data source and automatically cause service model to be updated and a new version of virtual service to be launched as new transaction data is generated from the monitoring of monitor .

It should be noted that a virtual service system e.g. can support and monitor multiple different types of data sources e.g. provide multiple different interfaces through which transaction data can be conveniently supplied to data sources monitored by an automation engine e.g. and generate service models from multiple different types of transaction data. For instance a single virtual service system can concurrently enable each of the examples and features of . Additionally a model generator can utilize request response information obtained from multiple different types of transaction data e.g. from multiple different data sources e.g. and or through multiple different interfaces e.g. . Further while in some instances a service model and corresponding virtual service can be generated substantially immediately in response to detected modifications to transaction data in some implementations updating a service model or launching a corresponding virtual service from detected modifications to transaction data can be periodic scheduled or according to predefined triggers among other examples.

Turning to simplified flowcharts is presented illustrating example techniques involved in automatically generating and launching a virtual service. For instance a data source can be identified that is associated with a service model to be generated from transaction data provided to the data source. In some examples the data source can be associated with a user account and a user can designate that the particular data source is associated with a particular virtualization activity. A modification to transaction data within the data source can be detected . The modification can include for instance a change to a particular file that includes transaction data already within the data source addition of a new transaction data to the data source among potentially other examples. A service model that models responses of one or more particular software components to various requests within one or more types of transactions can be automatically generated based on and in some cases in response to detecting the modification to the transaction data. The service model can be generated from the transaction data. A virtual service can also be generated based on detecting the modification to the transaction data. The virtual service e.g. the logic used to provide the virtual service based on the generated service model can be prepared or otherwise generated based on the service model. The generated virtual service can be deployed for instance in a virtual machine or other virtual service environment based on detecting the modification to the transaction data. Upon starting the deployed virtual service another component can send requests to the virtual service as if the virtual service were the particular software component and the virtual service can simulate responses of the particular software component based on the received requests among other examples.

The flowcharts and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various aspects of the present disclosure. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular aspects only and is not intended to be limiting of the disclosure. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of any means or step plus function elements in the claims below are intended to include any disclosed structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present disclosure has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the disclosure in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the disclosure. The aspects of the disclosure herein were chosen and described in order to best explain the principles of the disclosure and the practical application and to enable others of ordinary skill in the art to understand the disclosure with various modifications as are suited to the particular use contemplated.

