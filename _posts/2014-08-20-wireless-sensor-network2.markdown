---

title: Wireless sensor network
abstract: A networked system for managing a physical intrusion detection/alarm includes an upper tier of server devices, comprising: processor devices and memory in communication with the processor devices, a middle tier of gateway devices that are in communication with upper tier servers, and a lower level tier of devices that comprise fully functional nodes with at least some of the functional nodes including an application layer that execute routines to provide node functions, and a device to manage the lower tier of devices, the device instantiating a program manager that executes a state machine to control the application layer in each of the at least some of the functional nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09541631&OS=09541631&RS=09541631
owner: Tyco Fire & Security GmbH
number: 09541631
owner_city: Neuhausen am Rheinfall
owner_country: CH
publication_date: 20140820
---
This application claims priority under 35 U.S.C. 119 e to provisional U.S. Patent Application 61 973 962 filed on Apr. 2 2014 entitled Wireless Sensor Network and provisional U.S. Patent Application 61 946 054 filed on Feb. 28 2014 entitled Wireless Sensor Network the entire contents of which are hereby incorporated by reference.

This description relates to operation of sensor networks such as those used for security intrusion and alarm systems installed on commercial or residential premises.

It is common for businesses and homeowners to have a security system for detecting alarm conditions at their premises and signaling the conditions to a monitoring station or to authorized users of the security system. Security systems often include an intrusion detection panel that is electrically or wirelessly connected to a variety of sensors. Those sensors types typically include motion detectors cameras and proximity sensors used to determine whether a door or window has been opened . Typically such systems receive a very simple signal electrically open or closed from one or more of these sensors to indicate that a particular condition being monitored has changed or become unsecure.

However such networks generally use a combination of wired and wireless links between the computing devices with wireless links usually used for end node device to hub gateway connections. Virtually all of the devices involved in the network use some form of simple software but in the end nodes and hub gateway this software is simple in form involves little advanced capability in data reduction and decision making and is quite static meaning that the software typically does not change frequently. However when the software on these lower level devices is updated which is not frequently traditional boot loading methods are used. However these boot loading methods are time consuming energy consuming and require rebooting of the updated device which can present a security alarm issue.

According to an aspect a networked sensor system includes an upper tier of server devices the server devices including processor devices and memory in communication with the processor devices. The system also includes a middle tier of gateway devices that are in communication with one or more of the upper tier server devices and a lower level tier of devices that include fully functional sensor nodes with at least some of the fully functional sensor nodes including an application layer that executes routines to provide node sensor functions and an application layer manager to manage the application layer in the at least some of the functional nodes in the lower tier of devices.

The network can use a combination of wired and wireless links preferable wired between the tiers especially with wireless links between the middle and lower tier connections for example end node device to hub gateway . The devices involved in the network can include advanced capabilities areas such as data reduction and decision making and the capabilities of the device are dynamically changeable meaning that the software can be updated without the traditional boot loading methods avoiding the time consuming energy consuming and rebooting required by the updated device thus avoiding potential security alarm issues when such sensor and other end node devices are updated. This enables management of such sensors and other end node devices having advanced capabilities in data reduction and decision making.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention is apparent from the description and drawings and from the claims.

Described herein are examples of network features that may be used in various contexts including but not limited to security intrusion and alarm systems. Example security systems may include an intrusion detection panel that is electrically or wirelessly connected to a variety of sensors. Those sensors types may include motion detectors cameras and proximity sensors used e.g. to determine whether a door or window has been opened as well as other types of sensors . Typically such systems receive a relatively simple signal electrically open or closed from one or more of these sensors to indicate that a particular condition being monitored has changed or become unsecure.

For example typical intrusion systems can be set up to monitor entry doors in a building. When a door is secured a proximity sensor senses a magnetic contact and produces an electrically closed circuit. When the door is opened the proximity sensor opens the circuit and sends a signal to the panel indicating that an alarm condition has occurred e.g. an opened entry door .

Data collection systems are becoming more common in some applications such as home safety monitoring. Data collection systems employ wireless sensor networks and wireless devices and may include remote server based monitoring and report generation. As described in more detail below wireless sensor networks generally use a combination of wired and wireless links between computing devices with wireless links usually used for the lowest level connections e.g. end node device to hub gateway . In an example network the edge wirelessly connected tier of the network is comprised of resource constrained devices with specific functions. These devices may have a small to moderate amount of processing power and memory and may be battery powered thus requiring that they conserve energy by spending much of their time in sleep mode. A typical model is one where the edge devices generally form a single wireless network in which each end node communicates directly with its parent node in a hub and spoke style architecture. The parent node may be e.g. an access point on a gateway or a sub coordinator which is in turn connected to the access point or another sub coordinator.

Referring now to an exemplary global distributed network topology for a Wireless Sensor Network WSN is shown. In the distributed network is logically divided into a set of tiers or hierarchical levels 

In an upper tier or hierarchical level of the network are disposed servers and or virtual servers running a cloud computing paradigm that are networked together using well established networking technology such as Internet protocols or which can be private networks that use none or part of the Internet. Applications that run on those servers communicate using various protocols such as for Web Internet networks XML SOAP RESTful web service and other application layer technologies such as HTTP and ATOM. The distributed network has direct links between devices nodes as shown and discussed below.

The distributed network includes a second logically divided tier or hierarchical level referred to here as a middle tier that involves gateways located at central convenient places inside individual buildings and structures. These gateways communicate with servers in the upper tier whether the servers are stand alone dedicated servers and or cloud based servers running cloud applications using web programming techniques. The middle tier gateways are also shown with both local area network e.g. Ethernet or 802.11 and cellular network interfaces

The distributed network topology also includes a lower tier edge layer set of devices that involve fully functional sensor nodes e.g. sensor nodes that include wireless devices e.g. transceivers or in some implementations just transmitters or receivers which in are marked in with an F as well as constrained wireless sensor nodes or sensor end nodes marked in the with C . In some embodiments wired sensors not shown can be included in aspects of the distributed network .

Constrained computing devices as used herein are devices with substantially less persistent and volatile memory compared to other computing devices sensors in a detection system. Currently examples of constrained devices would be those with less than about a megabyte of flash persistent memory and less than 10 20 kbytes of RAM volatile memory . These constrained devices are configured in this manner generally due to cost physical configuration considerations.

In a typical network the edge wirelessly connected tier of the network is comprised of highly resource constrained devices with specific functions. These devices have a small to moderate amount of processing power and memory and often are battery powered thus requiring that they conserve energy by spending much of their time in sleep mode. A typical model is one where the edge devices generally form a single wireless network in which each end node communicates directly with its parent node in a hub and spoke style architecture. The parent node may be e.g. an access point on a gateway or a sub coordinator which is in turn connected to the access point or another sub coordinator.

Each gateway is equipped with an access point fully functional node or F node that is physically attached to that access point and that provides a wireless connection point to other nodes in the wireless network. The links illustrated by lines not numbered shown in represent direct single hop network layer connections between devices. A formal networking layer that functions in each of the three tiers shown in uses a series of these direct links together with routing information used at intermediate routing capable devices to send messages fragmented or non fragmented from one device to another over the network.

The WSN implements a state machine approach to an application layer that runs on the lower tier devices and . Discussed below is an example of a particular implementation of such an approach. States in the state machine are comprised of sets of functions that execute in coordination and these functions can be individually deleted or substituted or added to in order to alter the states in the state machine of a particular lower tier device.

The WSN state function based application layer uses an edge device operating system not shown but such as disclosed in the above mentioned provisional application that allows for loading and execution of individual functions after the booting of the device without rebooting the device so called dynamic programming . In other implementations edge devices could use other operating systems provided such systems allow for loading and execution of individual functions after the booting of the device preferable without rebooting of the edge devices.

Referring now to an embodiment an application layer manager is shown. The application layer manager is generic in the sense that the application layer manager does not depend upon a specific application solution or business logic details in the devices that are updated e.g. devices lower tier . The application layer manager handles pass offs changes in functions currently operating from function to function on e.g. the nodes e.g. devices . These pass offs are requested by actual state functions executing in the nodes or devices .

The application layer manager accomplishes such pass offs changes in functions currently operating using a transition table that serves as a central descriptor for the state functions. Inputs to the application layer manager include parsed messages from the network layer via interface . The application layer manager includes interrupt and polling based inputs via processor peripheral interrupts from interrupt interface and polled sensor peripheral inputs via interface .

The application layer manager involves characterizing inputs sufficiently to apply rules that dictate changes in configuration stored data and or precipitate message generation. The application layer manager has rules and a configuration manager as well as a message generator parser . The application layer manager uses network message and sensor processor peripheral based inputs local data stores for transition table and lists configuration management functions rules set and report generation capabilities as shown.

Referring to an application module set includes an application layer for the edge devices and is shown. The application module set includes a layer that is managed by the application layer manager and a layer that is not managed by the application layer manager. In this embodiment the application layer manager is separate from e.g. isolated from these other firmware modules used at the edge of the WSN e.g. wireless web modules EDFF s etc. not shown in order to apply changes in the application layer code without requiring changes to code in these other modules. In addition as shown real time processing of motion ISR and motion filter are not handled by the application layer manager whereas motion report generator and heart beat generator are handled by the application layer manager.

The application module set depicted in the example of includes functions managed by the application layer e.g. a motion report generator and heartbeat generator that are in communication with a stack . Changes to the application layer are possible by having an understanding of the details of the workings of the application layer without the need to fully understand all of the details of these other isolated modules. This is desirable as different groups of individuals and or systems may be tasked with the coding and maintenance of the respective modules. Also the application layer is configured in a general way that supports the upgrading of portions of the application layer e.g. individual business rules reports filters and other functions without requiring updating of the entire application layer.

Referring now to an exemplary situation involving the Application layer manager App Mgr where there are two states State 1 with functions A B and C and State 2 with functions D and E is shown. The transition table governs state transitions.

The transition table shows what state or states in the case of a nondeterministic finite automaton a finite semi automaton or finite state machine will move to based on the current state of the machine and other inputs. A state table is essentially a truth table in which some of the inputs are the current state and the outputs include the next state along with other outputs. A state table is one of several ways to specify a state machine other ways being a state diagram and a characteristic equation.

State 1 is the normal state and has an entry point Func A. Normally State 1 executes Func A which requests Func B which requests execution of Func C. In the example a condition occurs actual condition is implementation specific and the detail of which is not necessary to understand what follows . Under this situation with the condition occurring State 1 transitions to State 2 when Func B requests execution of Func D rather than Func C. State 2 may exists for only one cycle D E exit or many cycles D E D E . . . exit . However when the exit occurs in this example it does so without calling any function. By default then the AppMgr s Idle function runs Func A since it is the entry point function.

Referring to a typical application on a motion sensor handles a motion sensor s raw data with an interrupt routine the motion sensor interrupt service routing directly calls a motion filter that maintains its own state and declares when appropriate a motion event . The motion event is handled after perhaps a bit of un deterministic latency by a motion report generator that calls a wireless program stack to place the report into that stack s out going queue. The motion report generator waits for an ACK message and re sends the message as necessary until an ACK is received. A heartbeat message is generated periodically and placed into the wireless stack out going message queue and an ACK is awaited. Heartbeat messages are not re submitted after delivery failure but a new heartbeat message is not sent until the result of the previous send is obtained from the wireless stack. 

Referring now to the application layer is configured to satisfy the requirement of modularity by defining and linking together different portions of the application layer so that individual portions are updatable over the wireless link without breaking the overall application. The application layer instantiates an object that is a fundamental building block for application layer machine. The object has an array of function pointers with each function serving as a keeper e.g. holding of a particular state and a special manager function application layer manager or AppMgr that tracks which function is running in the machine i.e. which array index is in effect .

State transitions are accomplished by the current function transferring function control to the next appropriate function marking entrance into the new states e.g. FuncD in by changing this index or asking AppMgr to change the index. The AppMgr is general with hardwired business logic residing in the individual state functions rather than in the AppMgr and individual states are changed by replacing the corresponding function with a new version of that function transmitted from an external host such as a gateway. Thus making changes to an allowed state transition either adding a new transition or deleting an old one is accomplished by replacing the functions which participate in the state change with the new functions.

In some embodiments the AppMgr is configured to actually change the current index value for the current state function whereas in others the old function directly activates the new function without using the AppMgr as an intermediary. This is because the AppMgr has a mapping of allowed transitions and check for violations of this mapping i.e. a given function tries to pass control to another function and in so doing make a state transition that is not allowed . This helps to verify that changes to the state machine behavior are valid and that changes to the state machine behavior actually take place since an error message will be generated by AppMgr when an erroneous state change is requested by a function. Otherwise individual states are changed by replacing the corresponding function with a new version of that function .

Let p AppFunc i be a pointer to the iapplication function. Let N i be the current index value maintained by AppMgr N i is a global variable that retains its value from one pass through AppMgr to the next.

AppMgr is a root function that is executed by a EDFF scheduler such as in the operating system running on the edge device. AppMgr runs completely through every few milliseconds. Each time AppMgr runs AppMgr executes the function pointed to by p AppFunc N i . In some embodiments the state machine can be implemented as a set of arrays whereas in more complex implementations the state machine is implemented as a set of functions that are linked through a linked list to allow for an indeterminate number of states in the state machine.

For some states only one function call may be required. That is p AppFunc N i would run once and then N i would change to a different value say N k so that on the next call of AppMgr a different state would be entered i.e. p AppFunc N k would run . For other states the corresponding function might run many times before N i changes. An example of the single run function would be the sending of a report. An example of the multi run function would be the activity of a sensor filter that acts on raw data from a sensor device.

The various functions p AppFunc i not only decide when they should request that AppMgr make a state change but these functions indicate what new function s e.g. what new value s of N i AppMgr should choose from as AppMgr is configured to be fairly generic and thus all business logic including the description of transitions between states is contained in the p AppFunc functions.

The two p AppFunc functions need to have different tasks done at the same time for example simultaneously filtering data from two sensors e.g. de bouncing a switch and filtering motion data from an accelerometer. One general approach to providing an AppMgr is to run two state functions at a time execute both with each pass through AppMgr . Another approach keeps AppMgr simple and just requires that application states provided with code to make calls to each other and thus invoke each other. That is p AppFunc N i requests execution of p AppFunc N k upon termination of execution of p AppFunc N i and vice versa. In effect the two app functions split the time and attention of AppMgr without AppMgr planning for time sharing.

The various versions of p AppFunc are maintained in an executable code repository in the gateway and cloud and each such function can have an ID number that is used to differentiate one version of a function from another and in many cases the differences in the generations or versions of the function may be small but important so getting exactly the right ID number . Inside a given function the requested change to a different function or state becomes very specific with respect to a code version therefore there is logical that the parameter used by a function to request a state change function change is actually the ID number of the new function.

A simple way to manage versions is to give App Layer state functions their own file type. File type is maintained as one of the fields in the file index in e.g. flash memory so that the initialization process of AppMgr during bootup searches for files of that type in the flash memory and produces the array of function pointers with index i running from 0 to a maximum value i max.

During this initialization AppMgr maps each value i to a function p AppFunc i and that function s corresponding function ID and produces a table showing for each function ID the corresponding index value i and the allowed state transitions function IDs for functions reachable from the current function .

For example during the course of operation of the current function e.g. p AppFunc N i with its function ID e.g. 0x31C7 the function might return to AppMgr a return value of 0x396B. This return value is a request to run the function p AppFunc having the function ID 0x396B. AppMgr uses the state table to determine if request to run p AppFunc having the function ID 0x396B is a transition that is allowed for function ID 0x31 C7 and if so what value of i corresponds to function 0x396B. If it is a valid request AppMgr sets N i equal to the new value of i corresponding to function ID 0x396B and upon next execution of AppMgr the new function ID 0x396B would run.

During initialization of AppMgr and the producing of the state table simple graph analysis algorithms run to ensure that each state is reachable no states are isolated and to make sure that all states are part of a single state machine i.e. there are not two smaller and totally separated sets of states . The state table validation also requires that no state transition can involve a transition to a non existent function.

AppMgr always has a stem state idle state with function ID 0x0001 that runs when the index N i is undefined. Initialization of the state machine is done in a second state initialize state with its own generic function with function ID 0x0000. Any time any of the functions change e.g. by a wireless download of a new function or functions AppMgr will re run function 0x0000 and then transition to state function 0x0001. It is a further requirement that one and only one of the user supplied functions in the complete function set is identified as the entry state. This is the state called by 0x0001 automatically. From that point on the user supplied functions request the state changes as part of their return values.

Returning to the state diagram and the table mentioned above the table below is now populated with the state transitions for the example application described above.

The above example is simple for purposes of illustration of the concept. However more complex application sets can also be used. For example suppose there are two states in a node the first state corresponding to the perpetual running of functions A B and C in a continuous loop and the second state corresponding to the running of functions D and E in another perpetual loop. In the first state the normal state function A the entry function runs to completion and requests to AppMgr that it run function B. When function B is complete it requests function C which in turn requests function A. Because function A is the entry function and the loop A B C A . . . is a closed loop functions D and E will normally not run. However under special conditions suppose function B when it exits requests function D rather than C. Function D and E then run in a loop D E D E . . . until one of them requests a function in the first loop. In this way functions or sets of functions correspond to states and functions operating in each state manage the state transitions.

When a function exits with no new function requested AppMgr Idle will simply run the entry point function again. In some cases with very simple nodes there may be NO entry function in which case the idle function will just run itself until an event initiated function is run.

Referring back to a hypothetical generic situation where there are two states State 1 with functions A B and C and State 2 with functions D and E . State 1 is the normal state and has the entry point Func A. Under special circumstances State 1 transitions to State 2 when Func B requests the execution of Func D rather than Func C. State 2 may exists for only one cycle D E exit or many D E D E . . . exit but when exit occurs in this example it does so without calling any function. By default then the AppMgr s Idle function runs Func A since it is the entry point function.

The sensors provide in addition to an indication that something is detected in an area within the range of the sensors detailed additional information that can be used to evaluate what that indication may be without the intrusion detection panel being required to perform extensive analysis of inputs to the particular sensor.

For example a motion detector could be configured to analyze the heat signature of a warm body moving in a room to determine if the body is that of a human or a pet. Results of that analysis would be a message or data that conveys information about the body detected. Various sensors thus are used to sense sound motion vibration pressure heat images and so forth in an appropriate combination to detect a true or verified alarm condition at the intrusion detection panel.

Recognition software can be used to discriminate between objects that are a human and objects that are an animal further facial recognition software can be built into video cameras and used to verify that the perimeter intrusion was the result of a recognized authorized individual. Such video cameras would comprise a processor and memory and the recognition software to process inputs captured images by the camera and produce the metadata to convey information regarding recognition or lack of recognition of an individual captured by the video camera. The processing could also alternatively or in addition include information regarding characteristic of the individual in the area captured monitored by the video camera. Thus depending on the circumstances the information would be either metadata received from enhanced motion detectors and video cameras that performed enhanced analysis on inputs to the sensor that gives characteristics of the perimeter intrusion or a metadata resulting from very complex processing that seeks to establish recognition of the object.

Sensor devices can integrate multiple sensors to generate more complex outputs so that the intrusion detection panel can utilize its processing capabilities to execute algorithms that analyze the environment by building virtual images or signatures of the environment to make an intelligent decision about the validity of a breach.

Memory stores program instructions and data used by the processor of the intrusion detection panel. The memory may be a suitable combination of random access memory and read only memory and may host suitable program instructions e.g. firmware or operating software and configuration and operating data and may be organized as a file system or otherwise. The stored program instruction may include one or more authentication processes for authenticating one or more users. The program instructions stored in the memory of the panel may further store software components allowing network communications and establishment of connections to the data network. The software components may for example include an internet protocol IP stack as well as driver components for the various interfaces including the interfaces and the keypad. Other software components suitable for establishing a connection and communicating across network will be apparent to those of ordinary skill.

Program instructions stored in the memory along with configuration data may control overall operation of the panel.

The monitoring server includes one or more processing devices e.g. microprocessors a network interface and a memory all not illustrated . The monitoring server may physically take the form of a rack mounted card and may be in communication with one or more operator terminals not shown . An example monitoring server is a SURGARD SG System III Virtual or similar system.

The processor of each monitoring server acts as a controller for each monitoring server and is in communication with and controls overall operation of each server. The processor may include or be in communication with the memory that stores processor executable instructions controlling the overall operation of the monitoring server. Suitable software enable each monitoring server to receive alarms and cause appropriate actions to occur. Software may include a suitable Internet protocol IP stack and applications clients.

Each monitoring server of the central monitoring station may be associated with an IP address and port s by which it communicates with the control panels and or the user devices to handle alarm events etc. The monitoring server address may be static and thus always identify a particular one of monitoring server to the intrusion detection panels. Alternatively dynamic addresses could be used and associated with static domain names resolved through a domain name service.

The network interface card interfaces with the network to receive incoming signals and may for example take the form of an Ethernet network interface card NIC . The servers may be computers thin clients or the like to which received data representative of an alarm event is passed for handling by human operators. The monitoring station may further include or have access to a subscriber database that includes a database under control of a database engine. The database may contain entries corresponding to the various subscriber devices processes to panels like the panel that are serviced by the monitoring station.

All or part of the processes described herein and their various modifications hereinafter referred to as the processes can be implemented at least in part via a computer program product i.e. a computer program tangibly embodied in one or more tangible physical hardware storage devices that are computer and or machine readable storage devices for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a network.

Actions associated with implementing the processes can be performed by one or more programmable processors executing one or more computer programs to perform the functions of the calibration process. All or part of the processes can be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array and or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only storage area or a random access storage area or both. Elements of a computer including a server include one or more processors for executing instructions and one or more storage area devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more machine readable storage media such as mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks.

Tangible physical hardware storage devices that are suitable for embodying computer program instructions and data include all forms of non volatile storage including by way of example semiconductor storage area devices e.g. EPROM EEPROM and flash storage area devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks and volatile computer memory e.g. RAM such as static and dynamic RAM as well as erasable memory e.g. flash memory.

In addition the logic flows depicted in the figures do not require the particular order shown or sequential order to achieve desirable results. In addition other actions may be provided or actions may be eliminated from the described flows and other components may be added to or removed from the described systems. Likewise actions depicted in the figures may be performed by different entities or consolidated.

Elements of different embodiments described herein may be combined to form other embodiments not specifically set forth above. Elements may be left out of the processes computer programs Web pages etc. described herein without adversely affecting their operation. Furthermore various separate elements may be combined into one or more individual elements to perform the functions described herein.

Other implementations not specifically described herein are also within the scope of the following claims.

