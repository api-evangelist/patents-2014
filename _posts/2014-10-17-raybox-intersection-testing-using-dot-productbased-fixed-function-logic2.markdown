---

title: Ray-box intersection testing using dot product-based fixed function logic
abstract: A method and apparatus for ray tracing may include using texture pipeline hardware of a GPU to perform ray intersection testing for a first ray and a first shape. Using the texture pipeline hardware to perform ray intersection testing may include calculating a plurality of dot products with the texture pipeline hardware, and determining whether the first ray intersects the first shape based on the plurality of dot products.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09607425&OS=09607425&RS=09607425
owner: QUALCOMM Incorporated
number: 09607425
owner_city: San Diego
owner_country: US
publication_date: 20141017
---
This disclosure relates to graphics processing and more particularly to techniques for ray box intersection testing.

Ray tracing is a computer graphics technique used to generate 3D images for display. More specifically ray tracing is the process of tracing three dimensional 3D rays through a 3D scene and finding ray primitive intersections so that a two dimensional 2D representation of the 3D scene may be displayed. One technique used in ray tracing is determining ray triangle intersections. Given an input ray and a set of triangles the goal of the algorithm is to determine which triangles are intersected by the ray and or a set of intersection points. In order to accelerate the ray tracing operation primitives e.g. triangles are typically organized into an acceleration data structure ADS that hierarchically groups scene primitives.

Examples of accelerated data structures include a bounding volume hierarchy BVH tree k dimensional KD tree grid etc. The ADS may be recursively traversed by performing ray intersection tests on the hierarchy of scene primitives to determine the primitives of the scene that are intersected by the ray. In order to trace a ray through a BVH tree two types of operations are typically used ray box intersection testing e.g. ray AABB axis aligned bounding box intersection testing and ray triangle intersection testing.

Techniques of this disclosure generally relate to ray tracing. For example aspects of this disclosure generally relate to re using hardware units in a texture pipeline of a graphics processing unit GPU to perform certain aspects of ray tracing including for example ray box intersection testing. In particular in some examples dot product units of a texture unit of a rendering pipeline may be used during ray box intersection testing.

The details of one or more aspects of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the techniques described in this disclosure will be apparent from the description and drawings and from the claims.

Aspects of this disclosure generally relate to graphics processing. In some examples the techniques may be related to ray primitive intersection testing.

Aspects of this disclosure may relate to a method and apparatus for ray tracing that may include using texture pipeline hardware of a graphics processing unit GPU to perform ray intersection testing for a first ray and a first shape. Using the texture pipeline hardware to perform ray intersection testing may include calculating a plurality of dot products with the texture pipeline hardware and determining whether the first ray intersects the first shape based on the plurality of dot products.

Device may include additional modules or units not shown in for purposes of clarity. For example device may include a speaker and a microphone neither of which are shown in to effectuate telephonic communications in examples where device is a mobile wireless telephone or a speaker where device is a media player. Device may also include a video camera. Furthermore the various modules and units shown in device may not be necessary in every example of device . For example user interface and display may be external to device in examples where device is a desktop computer or other device that is equipped to interface with an external user interface or display.

Examples of user interface include but are not limited to a trackball a mouse a keyboard and other types of input devices. User interface may also be a touch screen and may be incorporated as a part of display . Transceiver module may include circuitry to allow wireless or wired communication between device and another device or a network. Transceiver module may include modulators demodulators amplifiers and other such circuitry for wired or wireless communication.

CPU may be a microprocessor such as a central processing unit CPU configured to process instructions of a computer program for execution. CPU may comprise a general purpose or a special purpose processor that controls operation of device . A user may provide input to device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include for example an operating system a word processor application an email application a spreadsheet application a media player application a video game application a graphical user interface application or another program. Additionally CPU may execute GPU driver for controlling the operation of GPU . The user may provide input to device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to device via user interface .

The software applications that execute on CPU may include one or more graphics rendering instructions that instruct CPU to cause the rendering of graphics data to display . In some examples the software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct 3D API an X3D API a RenderMan API a WebGL API or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU e.g. through GPU driver to cause GPU to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include a list of graphics primitives e.g. points lines triangles quadrilaterals triangle strips etc.

GPU may be configured to perform graphics operations to render one or more graphics primitives to display . Thus when one of the software applications executing on CPU requires graphics processing CPU may provide graphics commands and graphics data to GPU for rendering to display . The graphics data may include e.g. drawing commands state information primitive information texture information etc. GPU may in some instances be built with a highly parallel structure that provides more efficient processing of complex graphic related operations than CPU . For example GPU may include a plurality of processing elements such as shader units that are configured to operate on multiple vertices or pixels in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to draw graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than drawing the scenes directly to display using CPU .

GPU may in some instances be integrated into a motherboard of device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of device or may be otherwise incorporated within a peripheral device configured to interoperate with device . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry. GPU may also include one or more processor cores so that GPU may be referred to as a multi core processor.

GPU may be directly coupled to graphics memory . Thus GPU may read data from and write data to graphics memory without using a bus. In other words GPU may process data locally using a local storage instead of off chip memory. Such graphics memory may be referred to as on chip memory. This allows GPU to operate in a more efficient manner by eliminating the need of GPU to read and write data via a bus which may experience heavy bus traffic. In some instances however GPU may not include a separate memory but instead utilize system memory via a bus. Graphics memory may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

In some examples GPU may store a fully formed image in system memory . Display processor may retrieve the image from system memory and output values that cause the pixels of display to illuminate to display the image. Display may be the display of device that displays the image content generated by GPU . Display may be a liquid crystal display LCD an organic light emitting diode display OLED a cathode ray tube CRT display a plasma display or another type of display device.

In accordance with aspects of the present disclosure GPU may organize a plurality of primitives in a hierarchical data structure. GPU may include a texture pipeline that is configured to calculate dot products and to perform a ray intersection test e.g. a ray box intersection test based on the calculated dot products.

Memory available to CPU and GPU may include system memory and frame buffer . Frame buffer may be a part of system memory or may be separate from system memory . Frame buffer may store rendered image data.

Software application may be any application that utilizes the functionality of GPU . For example software application may be a GUI application an operating system a portable mapping application a computer aided design program for engineering or artistic applications a video game application or another type of software application that uses 2D or 3D graphics.

Software application may include one or more drawing instructions that instruct GPU to render a graphical user interface GUI and or a graphics scene. For example the drawing instructions may include instructions that define a set of one or more graphics primitives to be rendered by GPU . In some examples the drawing instructions may collectively define all or part of a plurality of windowing surfaces used in a GUI. In additional examples the drawing instructions may collectively define all or part of a graphics scene that includes one or more graphics objects within a model space or world space defined by the application.

Software application may invoke GPU driver via graphics API to issue one or more commands to GPU for rendering one or more graphics primitives into displayable graphics images. For example software application may invoke GPU driver via graphics API to provide primitive definitions to GPU . In some instances the primitive definitions may be provided to GPU in the form of a list of drawing primitives e.g. triangles rectangles triangle fans triangle strips etc. The primitive definitions may include vertex specifications that specify one or more vertices associated with the primitives to be rendered. The vertex specifications may include positional coordinates for each vertex and in some instances other attributes associated with the vertex such as e.g. color coordinates normal vectors and texture coordinates. The primitive definitions may also include primitive type information e.g. triangle rectangle triangle fan triangle strip etc. scaling information rotation information and the like. Based on the instructions issued by software application to GPU driver GPU driver may formulate one or more commands that specify one or more operations for GPU to perform in order to render the primitive. When GPU receives a command from CPU graphics processing pipeline decodes the command and configures graphics processing pipeline to perform the operation specified in the command. For example input assembler in graphics processing pipeline may read primitive data and assemble the data into primitives for use by the other graphics pipeline stages in graphics processing pipeline . After performing the specified operations graphics processing pipeline outputs the rendered data to frame buffer associated with a display device.

Frame buffer stores destination pixels for GPU . Each destination pixel may be associated with a unique screen pixel location. In some examples frame buffer may store color components and a destination alpha value for each destination pixel. For example frame buffer may store Red Green Blue Alpha RGBA components for each pixel where the RGB components correspond to color values and the A component corresponds to a destination alpha value. Although frame buffer and system memory are illustrated as being separate memory units in other examples frame buffer may be part of system memory .

In some examples GPU includes shader units graphics processing pipeline texture pipeline and graphics memory . One or more shader programs may execute on shader units in GPU . Shader units may include processor cores each of which may include one or more components for fetching and decoding operations one or more arithmetic logic units for carrying out arithmetic calculations one or more memories caches and registers.

GPU may designate shader units to perform a variety of shading operations such as vertex shading hull shading domain shading geometry shading pixel shading and the like by sending commands to shader units to execute one or more of a vertex shader stage a hull shader stage a domain shader stage a geometry shader stage and a pixel shader stage in graphics processing pipeline . In some examples GPU driver may be configured to compile one or more shader programs and to download the compiled shader programs onto one or more programmable shader units contained within GPU . The shader programs may be written in a high level shading language such as e.g. an OpenGL Shading Language GLSL a High Level Shading Language HLSL a C for Graphics Cg shading language etc. The compiled shader programs may include one or more instructions that control the operation of shader units within GPU . For example the shader programs may include vertex shader programs that may be executed by shader units to perform the functions of a vertex shader stage hull shader programs that may be executed by shader units to perform the functions of a hull shader stage domain shader programs that may be executed by shader units to perform the functions of a domain shader stage geometry shader programs that may be executed by shader units to perform the functions of a geometry shader stage and or pixel shader programs that may be executed by shader units to perform the functions of a pixel shader. A vertex shader program may control the execution of a programmable vertex shader unit or a unified shader unit and include instructions that specify one or more per vertex operations.

Graphics memory is storage or memory that physically integrated into the integrated circuit of GPU . Graphics memory may store an ADS that hierarchically groups scene primitives e.g. triangles . In some examples the ADS may be stored in system memory in shader memory of shader units or in shared system graphics memory not shown . GPU may organize a plurality of primitives in the ADS.

Texture pipeline is a programmable pipeline of hardware units that perform a texturing function. Texture pipeline may include a number of hardware texturing units each in communication with a corresponding shader processor . In some examples there is a one to one correspondence between shader processors and corresponding hardware texturing units in texture pipeline .

Shader processors may execute many instructions. When a shader processor detects a texture processing instruction among the instruction via an op code in a particular sub field of the instruction it sends a request to the corresponding texture unit in texture pipeline . The texture unit in texture pipeline upon receiving the request from the corresponding shader processor determines the type of texturing operation to perform based on the op code in the instruction and performs the operation which generally involves inter alia the calculation of dot products performed on specialized dot product hardware in texture pipeline . Texture pipeline includes fixed function hardware units that perform dot products natively. In some examples pipeline also includes fixed function hardware units that perform minimum and maximum operations natively.

In some examples of the disclosure a particular texture type is defined to be used to perform a ray intersection test in the texture pipeline . This texture type is not literally a texture type but is more accurately a buffer type. In some examples the corresponding shader processor sends the information including the buffer type for ray intersection tests or an index to the buffer to the corresponding texture unit in texture pipeline and the information may include information for the ray and the shape for which the ray intersection determines whether or not there is an intersection between the ray and the shape.

In some examples of the disclosure texture pipeline determines whether or not there is an intersection between the ray and the shape and passes the results of the test back to the corresponding shader processor . In other examples texture pipeline performs a portion of the test rather than the entire test or performs certain operations of the test rather than the entire test. In some examples texture pipeline performs the intersection check by performing operations such as calculating one or more dot products in specialized fixed function dot product hardware in texture pipeline and performing one or more minimum and or maximum operations in specialized fixed function hardware in texture pipeline .

In some examples the shape is a box and texture pipeline may be used for ray box intersection testing. In some examples the input information for the ray box intersection testing is provided to texture pipeline . The input information may include for example bounding box information. In some examples the bounding box information may be stored in buffer which in some examples is a specialized linear buffer in the texture pipeline that may store many bounding boxes. Texture pipeline indexes the bounding boxes in buffer and retrieves a relevant bounding box from buffer when needed.

In some examples the basic block of the filtering pipe is a DP4 unit which may perform a dot product of two 4 component vectors with one 4 component vector for each RGBA pixel. In other examples other architecture for pipeline may be employed. In some examples each DP4 unit performs a dot product for two four component inputs and one DP4 unit is implemented by two DP2 units that each performs a dot product for two two component inputs.

Some examples of texture pipeline use 4 component vectors employing four color channels red green blue and alpha.

In some examples texture pipeline employs bilinear texture filtering and the bilinear filter contains four DP4 units.

Ray tracing is a computer graphics technique used to determine ray triangle intersections. Given an input ray and a set of triangles the goal of the algorithm is to determine which triangles are intersected by the ray. Different types of intersection queries can be made Nearest hit NH intersection Any hit intersection and or All intersections. In order to accelerate the ray tracing operation triangles primitives are typically organized into an acceleration data structure ADS such as a bounding volume hierarchy BVH tree KD tree grid etc.

BVH is an unbalanced binary tree with two types of nodes. Interior nodes are nodes that represent a region of space described by axis aligned bounding boxes AABB and have two children. Leaf nodes are nodes that also represent a region of space but do not have any children. Instead they reference a set of triangles contained in the bounding box.

In some examples in order to trace a ray through a BVH tree two types of operations are required ray box intersection tests and ray triangle intersection tests. In typical scenes the number of ray box intersection tests is roughly five to twenty times greater than the number of ray triangle intersection tests.

GPU may systematically determine the primitive in primitives that is intersected by ray by dividing scene hierarchically arranging the divided portions of scene and recursively traversing the hierarchy of the divided portions of scene . is a block diagram illustrating partitioning scene into bounding volumes. As shown in GPU may conceptually partition primitives into bounding volumes. A E bounding volumes . Bounding volumes may be axis aligned bounding boxes AABBs which may be bounding boxes having a minimized area within which all points of the enclosed primitives may lie. The bounding boxes may be axis aligned such that the edges of the boxes may be parallel to the coordinate axis e.g. the x y and z axis .

Bounding volume A may be a bounding box that bounds all primitives of scene . Bounding volumes B and C may be subsets of bounding volume A in that bounding volumes B and C bound a subset of the portion of scene bound by bounding volume A. Bounding volume B may bound primitives A and B and bounding volume C may bound i.e. spatially encompass primitives C D and E. Bounding volumes D and E may be subsets of bounding volume C and may bound a subset of the portion of scene bound by bounding volume C. Bounding volume D may bound primitives C and D and bounding volume E may bound primitive E.

In the example shown in GPU may partition primitives into five bounding volumes . GPU may use more than or fewer than five bounding volumes . For example GPU may create additional bounding volumes as subsets of bounding volume B to individually bound primitives A and B respectively. In some examples CPU may also be configured to partition primitives into bounding volumes .

Because bounding volume A bounds all primitives of scene GPU may associate root node A with bounding volume A. GPU may associate nodes B and C which are child nodes of root node A with bounding volumes B and C respectively because bounding volumes B and C are each subsets of bounding volume A. GPU may link primitives A and B with node B because bounding volume B associated with node B bounds primitives A and B and because there are no additional bounding volumes that are subsets of bounding volume B.

GPU may associate bounding volumes D and E with nodes D and E which are child nodes of node C because bounding volumes D and E are each subsets of bounding volume C associated with node C. GPU may link primitives C and D with node D because bounding volume D associated with node D bounds primitives C and D and because there are no additional bounding volumes that are subsets of bounding volume D. GPU may also link primitive E with node E because bounding volume E associated with node E bounds primitive E and because there are no additional bounding volumes that are subsets of bounding volume E.

GPU may traverse BVH tree to determine the primitive of primitive that intersects ray by performing ray box intersection tests for the bounding volumes associated with nodes of BVH tree . GPU may start traversal of BVH tree by performing a ray box intersection test for bounding volume A associated with root node A. If GPU determines that ray intersects bounded volume A GPU may continue to traverse BVH tree to node B and GPU may perform a ray box intersection test for bounding volume B associated with node B. If GPU determines that ray does not intersect bounded volume B GPU may recursively traverse BVH tree up to node A and down to node C and GPU may perform a ray box intersection test for bounding volume C associated with node C. If GPU determines that ray intersects bounded volume C GPU may continue to traverse BVH tree to node D and GPU may perform a ray box intersection test for bounding volume D associated with node D. If GPU determines that ray intersects bounded volume D GPU may perform a ray primitive intersection tests for primitives linked to node D. Therefore GPU may perform a ray primitive intersection test for primitive C and may also perform a ray primitive intersection test for primitive D. GPU may determine from the ray primitive intersection test for primitive D that ray does intersect primitive D. After GPU determines that ray does intersect primitive D GPU may continue to recursively traverse BVH tree up to node C and down to E and GPU may perform a ray box intersection test for bounding volume E associated with node E. GPU may determine based on the ray box intersection test that ray does not intersect bounding volume E thereby ending traversal of BVH tree for ray .

After a start block the process proceeds to block where a plurality of dot products are calculated using the texture pipeline hardware. The process then moves to block where it is determined whether the first ray intersects the first shape based on the plurality of dot products. The process then advances to a return block where other processing is resumed.

In some examples process is employed to perform ray box intersection testing to determine whether or not the ray intersects the box. However the techniques of the disclosure are not so limited and in other examples other shapes may be employed. In some examples the intersection testing is between a ray and a rectangle.

In some examples the texture pipeline hardware may receive bounding box information and the ray definition from the GPU e.g. a shader processor or GPU driver and perform dot product operations and other operations. In some examples the texture pipeline hardware will output the result of the intersection test i.e. whether or not the first ray and the first shape intersect along with any application data to be passed along if any . In some examples the output result of the intersection test is a Boolean value representing whether or not the ray and the shape intersect.

In some examples a ray is represented by the ray origin o and the normalized direction vector d of the ray. A point on a ray can be expressed as r t o dt where t is from 0.0f inf . In some examples the direction vector is normalized by being defined as having a length of one.

A 3D axis aligned bounding box is represented by two of its opposite corner points bbMin Xmin Ymin Zmin and bbMax Xmax Ymax Zmax . In some examples bbMin and bbMax are two opposite corners where bbMin is the corner of the two opposite corners that is closest to the origin. The term the origin should not be confused in the term ray origin the origin refers to the point at coordinates 0 0 0 whereas the term ray origin or origin of the ray refers the starting of the ray. That is in geometry a ray is defined as a line that starts at a given point and goes off infinitely in a particular direction this starting point is referred to as the origin of the ray which is different than the origin which is the point at coordinate 0 0 0 although in some circumstances the origin of the ray could coincidentally be at the origin.

In process the ray shape intersection testing is performed by an algorithm which is formulated to use dot products where the texture pipeline hardware is employed to perform the dot products used in the algorithm.

In some examples the bounding box information may be stored in a specialized linear buffer in the texture pipeline which may store many bounding boxes. In other examples the specialized linear buffer may be stored in a suitable location other than the texture pipeline such as the system memory GPU memory a specialized memory and or the like. The texturing unit indexes the bounding boxes in the buffer and retrieves a relevant bounding box from the buffer when needed.

In some examples ray box intersection testing may begin initially with an instruction that is processed by a shader processor. When the shader processor determines based on the op code in a particular sub field of the instruction that the instruction is a texturing processing instruction it sends the request to a texture unit that corresponds to the shader processor where the texture unit is part of the texture pipeline. In some examples ray boy intersection tests employ a specially defined texture type i.e. buffer type . The shader processor may send the texture unit information such as the origin of the ray the direction of the ray and an index to the bounding box information stored in the buffer. The texture pipeline may respond by accessing the information identified by the indices and then performing the ray box intersection by employing an example of process . In some example process results in an indication as to whether or not the ray and the box intersect such as a Boolean value indicating whether or not the ray and the box intersect. In some examples the texture pipeline returns to the shader processor the Boolean value and may also return other information such as application specific data to the shader processor. In some examples the application specific data may include data related to traversing the ADS such as pointers to the next children in the tree and the like.

Examples of process leverage filtering pipeline inside the texture pipeline. In some examples the basic block of the filtering pipe is a DP4 unit which may perform a dot product of two 4 component vectors.

Each of dot product units is configured to calculate a dot product. In some example each dot product unit is a fixed function dot product hardware unit. Dot product units may operate as means for calculating a plurality of dot products with the texture pipeline hardware. Min max block is configured to perform a min max function on the dot products generated by dot product units . There are several examples of min max functions that may be performed in various examples with one exemplary version of the min max function performed by min max block discussed in greater detail below. In some examples min max block performs the min max function to generate tMin.xyz and tMax.xyz from the dot products. Max block performs a max function based on one or more outputs from min max block and min unit performs a min function based on one or more outputs from min max block . The outputs of max block and min block are used to determine the result of the ray shape intersection shape such as in some examples a Boolean value indicating whether or not there is an intersection between the ray and the shape. Blocks may operate together as means for determining whether the ray intersects the shape based on the plurality of dot products calculated by dot product units .

Although shows four dot product units in other examples more or fewer dot product units may be employed. In some examples three dot product units may be employed rather than four.

In some examples max block performs a max function on tMin.xyz and outputs tNear as a result of the max function. Similarly in some examples min block performs a min function on tMax.xyz and outputs tFar as a result of the max function. In some examples tNear and tFar are employed to derive a Boolean value indicating whether or not there is an intersection between the ray and the shape.

In some examples the texture pipeline includes fixed function hardware units that perform dot products natively which may correspond to dot product units in some examples. In some examples the texture pipeline also includes fixed function hardware units that perform minimum and maximum operations natively which may correspond to blocks in some examples.

In the above example the operator signifies a dot product of two 2 component vectors. The dot product is applied per component i.e. separately for the x component y component and z component . The scalar version is shown below.

As can be seen the x component of the vector t is calculated by performing a dot product of two vectors where the first vector has an x component having a value given by the x component of bbMin and a y component have a value given by the negative of the x component of the ray origin and the second vector has an x component given by the x component of the normalized reciprocal ray direction vector and a y component given by the x component of the normalized reciprocal ray direction vector. The y component of the vector t is calculated by performing a dot product of two vectors where the first vector has an x component having a value given by the y component of bbMin and a y component have a value given by the negative of the y component of the ray origin and the second vector has an x component given by the y component of the normalized reciprocal ray direction vector and a y component given by the y component of the normalized reciprocal ray direction vector. The z component of the vector t is calculated by performing a dot product of two vectors where the first vector has an x component having a value given by the z component of bbMin and a y component have a value given by the negative of the z component of the ray origin and the second vector has an x component given by the z component of the normalized reciprocal ray direction vector and a y component given by the z component of the normalized reciprocal ray direction vector.

The vector t is calculated in the same manner as the vector t except that bbMax is used in the place of bbMin.

As shown above in some examples after the dot product calculations the vectors t and t are obtained. In some examples minimum and maximum operations are performed on t and t to generate tMin and tMax. The value tMin is generated as a vector based on the minimum value of each corresponding component while the value tMax is generated as a vector based on the maximum value of each corresponding component. That is the x value of tMin is the lesser of the x coordinates of t and t the y value of tMin is the lesser of the y coordinates of t and t and the z value of tMin is the lesser of the z coordinates of t and t. Similarly the x value of tMax is the greater of the x coordinates of t and t the y value of tMax is the greater of the y coordinates of t and t and the z value of tMax is the greater of the z coordinates of t and t.

The values of tNear and tFar are derived from tMin and tMax based on minimum and maximum determinations. The value tNear is a scalar value which is the maximum value from among the values of each component of the vector tMin. Similarly the value tFar is a scalar value which is the minimum value from among the values of each component of the vector tMax.

The test is completed by a final comparison. If either tNear is greater than tFar or tFar is less than zero the result in false indicating the ray and the box do not intersect. Otherwise the result is true indicating that the ray and the box do intersect.

This final comparison compares the maximum entry distance and minimum exit distance to determine if they form a valid interval i.e. entry distance

To make use of the texture pipeline hardware in some examples the computation is mapped onto the DP4 units in the filtering pipeline of the texture pipeline. As shown in the following may be used as inputs to the ray box intersection test in some examples as follows.

In some examples one or more of the DP4 units function to not only compute one dot product of two 4 component vectors but also to compute two dot products of two 2 component vectors. In some examples in order to calculate the slab distances some of inputs to DP4s may be duplicated and some may remain unused. The table below shows the relevant connections in accordance with one example 

In some examples in order to perform ray box intersection testing the texture pipe receives access to two kinds of input data bounding box information and a ray definition.

In some examples the ray definition and BVH node index is stored in shader processor registers and passed to the texture pipeline with each intersection request. In some examples node indices are computed during the build process and the texture pipeline computes the node address using linear addressing.

As discussed above the bounding box information is contained inside each node of the BVH tree. In some examples the bounding box information is stored in memory as linearized tree nodes each having a fixed element node size. In some examples the bounding box information is addressable by the texture pipeline as a new BVH texture type. The bounding box information is addressed as a texture type even though it is not actually a texture more accurately it may be referred to as a buffer type rather than a texture type.

In addition to a new texture type a new texture pipeline filtering mode may perform ray box intersection testing.

The texture pipeline is configured to accept the BVH texture type and the format accommodates the following variables rayOrigin rayDirRcp textureID and node index.

In some examples the result of the ray box intersection test is a one bit true false value representing whether or not the ray and the box intersect. However in some examples the texture pipeline sends back more data than that to the shader processor.

In some examples the BVH node structure contains a misc field that contains application specific data. The misc field typically refers to information about where the next child node is the number of triangles in a leaf node and or the like. The shader processor may use this information for the tree traversal. In some examples this information is sent back to the shader processor along with the ray box intersection test result.

After a start block the process proceeds to block where a shader processor of the GPU fetches an instruction. The process then moves to block where it is determined whether the fetched instruction is a ray box intersection test instruction. If not the process returns to a return block where other processing is resumed.

If however the determination at decision block is positive the process advances to block where the shader processor sends intersection test information to the texture pipeline hardware. In some examples the intersection test information sent to the texture pipeline hardware may include information such as information such as the origin of the ray the direction of the ray and an index to the bounding box information stored in the buffer and an index to the special buffer type for ray box intersection testing.

The process then proceeds to block where texture pipeline hardware calculates a plurality of dot products. The process then moves to block where the texture pipeline hardware determines whether the ray intersects the block based on the plurality of dot products. The process then proceeds to block where the results of the ray box intersection test are sent from the texture pipeline hardware to the shader processor. The process then advances to a return block where other processing is resumed.

As previously discussed with regard to determination block at which a determination is made as to whether or not the instruction is a ray box intersection test an instruction may be identified as a ray box intersection test instruction by having an op code identifying that it is a texture instruction. If the op code in the instruction is identified as indicating that the instruction is a texture processing instruction then the determination at decision block is positive.

For instance in some examples the calculated dot products are two three component vectors each component having an x component a y component and a z component. At block the texture pipeline hardware determines a per component minimum of each dot product which may be given as tMin so that the x component of tMin is the minimum from among the x component of each of the dot products the y component of tmin is the minimum from among the y component of each of the dot products and the z component of tMin is the minimum from among the y component of each of the dot products. Similarly at block the texture pipeline hardware determines a per component maximum of each dot product which may be given as tMax so that the x component of tMax is the maximum from among the x component of each of the dot products the y component of tMax is the maximum from among the y component of each of the dot products and the z component of tMax is the maximum from among the y component of each of the dot products.

The process then moves to block where the texture pipeline hardware determines the maximum from among the per component minimums and the minimum from among the per component maximums. As discussed above a per component minimum of each dot product was determined at the previous block which may be given as tMin so that the x component of tMin is the minimum from among the x component of each of the dot products the y component of tMin is the minimum from among the y component of each of the dot products and the z component of tMin is the minimum from among the y component of each of the dot products. Accordingly tMin is a vector having an x component a y component and a z component. At block the texture pipeline hardware determines the maximum of the value of the x component of tMin the value of the y component of tMin and the value z component of tMin is determined and assigns the value of tNear which corresponds to the maximum entry distance.

Further in some examples the per component maximum of each dot product was determined at the previous block which may be given as tMax so that the x component of tMax is the maximum from among the x component of each of the dot products the y component of tMax is the maximum from among the y component of each of the dot products and the z component of tMax is the maximum from among the y component of each of the dot products. Accordingly tMax is a vector having an x component a y component and a z component. At block the texture pipeline hardware determines the minimum of the value of the x component of tMax the value of the y component of tMax and the value z component of tMax and assigns the minimum as the value of tFar which corresponds to the minimum exit distance.

The process then moves to decision block where the texture pipeline hardware makes a determination as to whether there is a valid interval i.e. tFar is not less than zero and the exit distance tFar is greater than the entry distance tNear . If so the process advances to block where the texture pipeline hardware indicates that the ray and the box intersect. The process then proceeds to a return block where other processing is resumed.

If however the determination at decision block is negative the process proceeds to block where the texture pipeline hardware indicate that the ray and the box do not intersect. The process then proceeds to a return block where other processing is resumed.

It is to be recognized that depending on the example certain acts or events of any of the techniques described herein can be performed in a different sequence may be added merged or left out altogether e.g. not all described acts or events are necessary for the practice of the techniques . Moreover in certain examples acts or events may be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors rather than sequentially.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored on or transmitted over as one or more instructions or code a computer readable medium and executed by a hardware based processing unit. Computer readable media may include computer readable storage media which corresponds to a tangible medium such as data storage media or communication media including any medium that facilitates transfer of a computer program from one place to another e.g. according to a communication protocol.

In this manner computer readable media generally may correspond to 1 tangible computer readable storage media which does not include propagating signal per se or 2 a communication medium such as a signal or carrier wave. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer readable medium.

By way of example and not limitation such computer readable storage media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also any connection is properly termed a computer readable medium. For example if instructions are transmitted from a website server or other remote source using a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared radio and microwave then the coaxial cable fiber optic cable twisted pair DSL or wireless technologies such as infrared radio and microwave are included in the definition of medium.

It should be understood however that computer readable storage media and data storage media do not include connections carrier waves signals or the like but are instead directed to tangible storage media. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

Instructions may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition in some aspects the functionality described herein may be provided within dedicated hardware and or software modules configured for encoding and decoding or incorporated in a combined codec. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs e.g. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

