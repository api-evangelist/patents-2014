---

title: Systems and methods for supporting transactional message handling
abstract: In accordance with embodiments disclosed herein, there are provided methods, systems, and apparatuses including, for supporting transactional message handling in an on-demand service environment including, for example: enqueuing a message specifying a transaction to be processed via a host organization; inserting a row into a database of the host organization associating the message with a status of pending, wherein the row is autocommitted to the database upon insertion; updating the status for the row to ready if a commit operation for the transaction is initiated; requesting a lock on the row; and performing final processing for the transaction based on the status for the message and based further on whether the lock is obtained for the row. Final processing may include, for example, a transaction roll back, a transaction commit, a transaction requeue, a termination of transaction processing, or an orphaned transaction clean up.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09519547&OS=09519547&RS=09519547
owner: salesforce.com, inc.
number: 09519547
owner_city: San Francisco
owner_country: US
publication_date: 20140916
---
This application is related to and claims priority to the provisional utility application entitled SYSTEMS AND METHODS FOR SUPPORT TRANSACTIONAL MESSAGE HANDLING filed on Jun. 24 2011 having an application No. 61 501 069 the entire contents of which are incorporated herein by reference and this application is further related to and claims priority to the non provisional utility application entitled SYSTEMS AND METHODS FOR SUPPORTING TRANSACTIONAL MESSAGE HANDLING filed on Nov. 1 2011 having an application Ser. No. 13 286 726 which was issued as U.S. Pat. No. 8 838 526 on Sep. 16 2014 the entire contents of which are incorporated herein by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Embodiments of the invention relate generally to the field of computing and more particularly to methods and systems for supporting transactional message handling in an on demand service environment.

The subject matter discussed in the background section should not be assumed to be prior art merely as a result of its mention in the background section. Similarly a problem mentioned in the background section or associated with the subject matter of the background section should not be assumed to have been previously recognized in the prior art. The subject matter in the background section merely represents different approaches which in and of themselves may also correspond to embodiments of the claimed inventions.

With respect to modern database systems the concept of atomicity represents the idea that transactions having multiple sub parts either fully complete or be fully rejected. Consider for example a bank transaction. A successful transaction may include 1 a withdrawal from a first account and 2 a credit to a second account. However if a problem were to occur during the transaction it is feasible that an account is credited without a corresponding withdrawal or alternatively that a withdrawal occurs without a corresponding credit. It may therefore be preferable that an entire transaction is rejected outright rather than completing partially. Thus continuing with the example above if both the withdrawal and the credit are not successful then both are rejected or prevented rather than allowing for a partially successful transaction.

Data stored within a database is said to be persistent when it is written to the database and then committed to the database thus making the data available for later retrieval. Some data is persistent by its nature and is thus is kept persistently. Other data is transient by nature and thus its usefulness is fleeting and the data is soon discarded. For example a persistent record of a successful withdrawal and credit from the above example may be kept. However a message or instruction to perform a particular action may be transient and need not be retained once the message or instruction has been completed.

Using a database to store transient data such as messages and instructions dispatched by a messaging system burdens the database system with a computational load particularly in an on demand system responsible for a large number of varied tasks. For example using the database system for transient data may include enqueuing a message or instruction for an action to be taken into a database inserting a record having the transient data necessary to perform the message or instruction into the database and then once message or instruction is completed removing the record of transient data from the database as it is no longer needed and dequeuing the message or instruction from the database. The database provides transactional atomicity but the computational burden on the database will increase as the number of messages and transactions increases.

A messaging system which does not utilize a database to ensure transactional atomicity either lacks transactional atomicity or must implement complex mechanisms to ensure atomicity such as a two phase commit or distributed transaction.

It may be desirable to unload computational burden from such a database and also negate the need for messaging systems which implement complex mechanisms to ensure atomicity. The present state of the art may therefore benefit from the methods systems and apparatuses for supporting transactional message handling in an on demand service environment as described herein.

Described herein are systems devices and methods for supporting transactional message handling in an on demand service environment.

In one embodiment such mechanisms include enqueuing a message specifying a transaction to be processed via a host organization inserting a row into a database of the host organization associating the message with a status of pending wherein the row is autocommitted to the database upon insertion updating the status for the row to ready if a commit operation for the transaction is initiated requesting a lock on the row and performing final processing for the transaction based on the status for the message and based further on whether the lock is obtained for the row. Final processing may include for example a transaction roll back a transaction commit a transaction requeue a termination of further transaction processing or an orphaned transaction clean up.

In the following description numerous specific details are set forth such as examples of specific systems languages components etc. in order to provide a thorough understanding of the various embodiments. It will be apparent however to one skilled in the art that these specific details need not be employed to practice the embodiments disclosed herein. In other instances well known materials or methods have not been described in detail in order to avoid unnecessarily obscuring the disclosed embodiments.

In addition to various hardware components depicted in the figures and described herein embodiments further include various operations which are described below. The operations described in accordance with such embodiments may be performed by hardware components or may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor programmed with the instructions to perform the operations. Alternatively the operations may be performed by a combination of hardware and software.

Embodiments also relate to an apparatus for performing the operations disclosed herein. This apparatus may be specially constructed for the required purposes or it may be a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition embodiments are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the embodiments as described herein.

Embodiments may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the disclosed embodiments. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. a machine e.g. computer readable transmission medium electrical optical acoustical etc.

Any of the disclosed embodiments may be used alone or together with one another in any combination. Although various embodiments may have been partially motivated by deficiencies with conventional techniques and approaches some of which are described or alluded to within the specification the embodiments need not necessarily address or solve any of these deficiencies but rather may address only some of the deficiencies address none of the deficiencies or be directed toward different deficiencies and problems where are not directly discussed.

In accordance with one embodiment a message specifying a transaction is enqueued to be processed via the host organization a row is inserted into a database of the host organization associating the message with a status of pending and the row is autocommitted to the database upon insertion. In accordance with such an embodiment the status for the row is updated to ready if a commit operation for the transaction is initiated but remains as pending absent the initiation of such a commit operation. In accordance with this embodiment a lock on the row is requested and the host organization performs final processing for the transaction based on the status for the message and based further on whether the lock is obtained for the row .

For example final processing may include performing a transaction roll back performing a transaction commit performing a transaction requeue performing transaction processing termination or performing a clean up operation for one or more orphaned transactions.

In accordance with one embodiment the message broker enqueues the message via the enqueue API on behalf of a requesting application or on behalf of a requesting client device A C. For example client devices A C may submit requests to the host organization for processing triggering the message broker to enqueue message . In one embodiment the message queue framework inserts the row into the database and causes the database to autocommit the row to the database upon insertion. For example the message queue framework may implement an out of band commit operation to ensure the row is inserted and committed to the database regardless of whether further processing occurs.

In accordance with one embodiment message is received at the message queue framework of the host organization from the message broker and the message queue framework responsively inserts the row into database of the host organization instructing the database to autocommit the row upon insertion.

In one embodiment the message broker lacks native transactional atomicity. For example the message broker may be a turn key messaging application which provides basic messaging services but lacks complex mechanisms to ensure transactional atomicity. For example the message broker may not natively implement two phase commit processing distributed transactions or other mechanisms to ensure transactional atomicity. In such an embodiment the host organization and the message queue framework operate with no expectation or requirement that the message broker be aware of distributed transactions support such distributed transactions or utilize a two phase commit process. In such a way it is possible to utilize a less complex messaging system within the host organization than messaging systems which natively support transactional atomicity.

Practice of the disclosed embodiments may therefore enable a more simplistic messaging system to be utilized while also off loading computational burden from a database which no longer must store transient data. For example although a row is inserted into the database the message itself is not required to be stored by the database . Data which must be persistently stored such as the creation of an account may be stored by the database whereas fleeting information such as the need to create the account need not be imposed upon the database . Further still transactional atomicity is ensured and various failure modes are tolerated thus ensuring a more resilient operational environment.

In accordance with one embodiment the message queue framework intercepts the message enqueued at an enqueue API of the message broker and triggers the row insertion responsive to receiving the message through the interception.

In one embodiment the message is dispatched to a worker to process the transaction specified by the message . The message queue framework may facilitate the dispatch into the application server pool via the message transport . In one embodiment the message queue framework enqueues multiple messages and the message transport performs the dispatch or a dedicated dispatcher retrieves queued messages and dispatches them into the application server pool . In one embodiment the workers within the application server pool request a queued message for dispatch.

In accordance with one embodiment the worker having received a message for processing requests a lock on the row . For example the worker may request a mutually exclusive lock or request a lock for update thus attempting to establish exclusive authority over the row corresponding to the received message . Requesting a lock for a row does not however guarantee that the lock will be obtained as will be described in further detail below.

In accordance with one embodiment the worker implements or performs the final processing for a message and the corresponding transaction specified by a message. Final processing may take various forms including performing a transaction roll back performing a transaction commit performing a transaction requeue terminating further processing for a transaction and performing a transaction clean up operation for orphaned messages.

In accordance with one embodiment the worker assigned or dispatched with a message and specified transaction performs one or more of the following operations the worker requests the lock on a row the worker determines that a lock was successfully obtained the worker processes the transaction specified by the message responsive to obtaining the lock the worker updates the status for the row to ready responsive to successfully completing processing the transaction the worker marks the row for deletion and the worker initiates a commit operation to simultaneously commit the processed transaction to the database and commit deletion of the row from the database . Thus the transaction may be successfully processed committed rendering the row as no longer necessary. In such an embodiment the message is processed by committing a deletion of the row to the database.

In one embodiment dispatching the message to a worker includes communicating the message via the message transport to the worker to perform the final processing. In one embodiment the worker corresponds to or implements an execution thread within one of a plurality of application servers of the host organization to perform the processing.

As depicted row which is inserted into the database includes multiple fields. In one embodiment row includes at least three fields a first field for an organization identifier OrgID associated with the message a second field for a message tracker identifier MsgID to uniquely identify the message among a plurality of messages and a third field for the status . Where the message is not associated with a particular customer organization A C an null value empty field or other placeholder may be used to indicate a lack of customer organization A C context with respect to the message and its specified transaction .

As depicted the host organization initiates final processing block for example via resources within an application server pool such as a worker or a work execution thread. In one embodiment performing final processing for the transaction includes performing a first determination that the lock on the row is obtained block performing a second determination that the status for the row is pending block and rolling back the transaction and discarding the message by removing the row from the database block based on the first and second determinations blocks and . In one embodiment the first and second determinations blocks and collectively indicate the message does not need to be processed because processing of the transaction has failed and processing logic of the host organization draws such a conclusion block .

In one embodiment committing the transaction to the database and processing the message block includes marking the row for deletion and simultaneously committing the transaction to the database and committing the deletion of the row to maintain transactional atomicity.

In one embodiment the first and second determinations blocks and collectively indicate that the processing of the transaction is active but not complete and the and the message is not yet ready to be processed and processing logic of the host organization draws such a conclusion block .

In one embodiment the first and second determinations blocks and collectively indicate that processing of the transaction is active but a connection to a client device having originated the transaction has failed and processing logic of the host organization draws such a conclusion block .

In one embodiment requeuing the message with a time delay enables an application server processing the transaction to a maintain exclusive authority for processing the transaction b complete processing of the transaction and c initiate the commit operation. In one embodiment the commit operation includes the application server marking the row for deletion and simultaneously committing the transaction to the database and committing the deletion of the row to maintain transactional atomicity.

For example it is possible that a message broker receives a request and enqueues an appropriate message to undertake processing of a transaction responsive to the request but then loses a connection to a requesting client device. This may occur if the client device crashes goes off line or due to other causes. Where that message is dispatched and is being actively processed it may be acceptable for the processing to complete and commit to the database. The message broker may attempt to notify the requestor later or simply complete the processing and commit the successful result.

By requeuing the message with a time delay block the active processing is allowed to complete without a worker thread attempting to concurrently duplicate the processing for a given transaction. After the time delay the status may be re checked to determine what if any further processing is required. For example if the client device or the message broker were to re request the same transaction be processed that second erroneous transaction is prevented from processing so long as the original application server or worker maintained its lock on the row.

Thus in accordance with one embodiment subsequent to requeuing the message the host organization reinitiates performing the final processing for the transaction e.g. by returning to block after the time delay.

In one embodiment performing final processing for the transaction block includes determining that the status is non existent B and that the lock cannot be obtained C because the row does not exist in the database and terminating all further processing for the transaction based on the row not existing in the database.

In one embodiment determining that the status is non existent and that the lock cannot be obtained because the row does not exist in the database blocks A C collectively indicate that the processing of the transaction has previously completed successfully resulting in the transaction being committed and the row being deleted and processing logic of the host organization draws such a conclusion block .

For example because the row is autocommitted it is guaranteed to exist in the database when the message is enqueued. Therefore it is acceptable to conclude that the absence of the row for an enqueued message is the result of the row being inserted with a pending status advanced to a ready status and then deleted as a result of a commit operation triggered responsive to successful processing for such a transaction.

In accordance with one embodiment an enqueued message specifying the transaction to be processed is determined to be an erroneous message. For example the message may be deemed to be a duplicate or a redundant message for a transaction that has already successfully processed based on the determination that the row has been deleted from the database block A .

Based on the first second and third determinations blocks and a clean up operation for the enqueued message is initiated block . In one embodiment the first second and third determinations blocks and collectively indicate that the enqueued message has been orphaned and that it will not be consumed and processing logic of the host organization draws such a conclusion block .

In accordance with one embodiment the clean up operation block includes discarding the message by removing the row from the database and committing the deletion of the row.

In accordance with one embodiment the host organization initiates a clean up operation block on a repeating periodic basis. For example a cron job or similar administrative function may be utilized to automatically trigger the clean up operation on a periodic basis. In one embodiment the clean up operation includes identifying a set of one or more enqueued orphan messages based on each of the one or more enqueued orphan messages meeting the following criteria determining that a row corresponding to the enqueued orphan message is not locked e.g. block in which it is determined that a lock for a row is available or obtained determining the row corresponding to the enqueued orphan message has a status of pending block and determining the enqueued orphan message has been enqueued for a time period in excess of a threshold block .

Orphaned messages may occur due to the autocommit instruction for the row insertion. For example where a message is enqueued and a row is responsively inserted and autocommitted it is feasible that no further action is taken because for example the message broker crashes or loses connectivity or some other error occurs which prevents the receipt and fulfillment of further required information or events necessary for proceeding with processing of the transaction. Thus a message will exist in the queue yet there will be no mechanism by which the message is naturally consumed. For example the message is not being actively serviced and is not being dispatched and thus after a pre determined period of time the clean up operation engages to delete the orphaned message.

In one embodiment the first second and third determinations blocks and collectively indicate that the transaction associated with the enqueued message is actively processing and requires a longer than expected processing period and processing logic of the host organization draws such a conclusion block A .

Thus although an expiration period has been exceeded processing may be permitted to continue e.g. by skipping the clean up operation for the enqueued message as in block B . Eventually the transaction will successfully complete commit and cause the message to be processed triggering removal of the row.

In one embodiment the database is communicably interfaced with a plurality of client devices A C through the host organization . In one embodiment the database of the host organization as set forth at includes or implements a multi tenant database system within the host organization as is depicted in the embodiment of . In such an embodiment the host organization receives a plurality of requests from a plurality of customer organizations A C. For example the incoming requests solicit processing by the host organization via the multi tenant database system thus triggering the message broker and message queue framework to operate collectively with the various described elements to enqueue an appropriate message and initiate appropriate processing of a specified transaction corresponding to the enqueued message .

In one embodiment each customer organization A C is an entity selected from the group consisting of a separate and distinct remote organization an organizational group within the host organization a business partner of the host organization or a customer organization A C that subscribes to cloud computing services provided by the host organization .

Multi tenant database system includes a plurality of underlying hardware software and logic elements that implement database functionality and a code execution environment within the host organization . In accordance with one embodiment multi tenant database system implements a non relational data store and a relational data store . The hardware software and logic elements of the multi tenant database system are separate and distinct from a plurality of customer organizations A B and C which utilize the services provided by the host organization by communicably interfacing to the host organization via network . In such a way host organization may implement on demand services on demand database services or cloud computing services to subscribing customer organizations A C.

Thus in accordance with one embodiment the multi tenant database system implements hardware and software elements that are shared by a plurality of separate and distinct customer organizations A C each of the separate and distinct customer organizations being remotely located from the host organization having the multi tenant database system operating therein.

In one embodiment requests are received at or submitted to a web server within host organization . Host organization may receive a variety of requests for processing by the host organization and its multi tenant database system including the solicitation of services and transactions which require the creation and enqueuing of messages . Such requests may be received from one or more of the plurality of customer organizations A C via the network . Incoming requests received at web server may specify which services or transactions from the host organization are to be provided such as query requests search request status requests data base transactions a processing request to retrieve update or store data on behalf of one of the customer organizations A C and so forth. Web server may be responsible for receiving data requests from various customer organizations A C via network and provide a web based interface to an end user client machine originating such data requests for example a client computing device at or operating within a customer organization A C.

In accordance with one embodiment a non transitory computer readable storage medium stores instructions that when executed by a system in a host organization for example when executed by a processor and memory of such a system the instructions cause the system to perform operations including enqueuing a message specifying a transaction to be processed via the host organization inserting a row into a database of the host organization associating the message with a status of pending. In one embodiment the row is autocommitted to the database upon insertion updating the status for the row to ready if a commit operation for the transaction is initiated requesting a lock on the row and performing final processing for the transaction based on the status for the message and based further on whether the lock is obtained for the row .

In accordance with one embodiment the stored instructions when executed cause the system to perform further operations including performing final processing for the transaction by performing a first determination that the lock on the row is not available and dispatching the message to a worker within the application server pool to process the transaction specified by the message . In one embodiment such a worker performs the following operations the worker requests the lock and the worker performs final processing for the transaction specified by the message responsive to obtaining the lock by updating the status for the row to ready responsive to successfully completing processing the transaction . The worker further marks the row for deletion and the worker initiates the commit operation to simultaneously commit the processed transaction to the database and commit deletion of the row from the database.

In one embodiment system includes a memory and a processor or processors . For example memory may store instructions to be executed and processor s may execute such instructions. System includes bus to transfer transactions and data within system among a plurality of peripheral devices communicably interfaced with bus . System further includes web server and or request interface for example to receive requests including those soliciting or specification transactions to be processed to return responses and to otherwise interface with remote clients such as client devices located within customer organizations A C. Web server and or request interface may operate as a request interface to receive instructions messages transaction requests and so forth on behalf of the host organization in which the system operates. Some requests received at web server may be transaction requests to be transacted against a multi tenant database system communicably interfaced with the host organization in which the system operates.

System is further depicted as having a message transport to communicate and dispatch messages to connected execution resources such as workers application servers an application server pool etc. System includes file repository to provide storage as necessary for the system . System further includes global caching layer to provide caching services to communicably interfaced devices and systems.

Distinct within system is a message broker and message queue framework either or both of which may be installed into system or exist separate from system either or both of which may further be hardware based such that each is enabled by the hardware of system in conjunction with the system s processor s and memory to carry out the described capabilities.

Thus in accordance with one embodiment such a system includes a processor to execute instructions a request interface to receive a request from a client device a message broker to enqueue a message specifying a transaction to be processed via the system and a message queue framework to insert a row into a database communicably interfaced with the system. In one embodiment the row associates the message with a status of pending. In one embodiment the message queue framework further autocommits the row to the database upon insertion. In one embodiment system includes a message transport to dispatch the message to a worker thread in one of a plurality of application servers communicably interfaced with the system . In one embodiment the worker thread or an equivalent execution resource updates the status for the row to ready if a commit operation for the transaction is initiated requests a lock on the row and performs final processing for the transaction based on the status for the message and based further on whether the lock is obtained for the row.

In one embodiment the worker thread performs final processing for the transaction by performing one or more of the following a the worker thread to rollback the transaction and discard the message when the lock on the row is obtained and the status for the row is pending b the worker thread to commit the transaction to the database and process the message by committing removal of the row from the database when the lock on the row is obtained and the status for the row is ready c the worker thread to requeue the message with a time delay and schedule the system to reinitiate performing the final processing for the transaction after the time delay when the lock on the row is denied and the status for the row is pending d the worker thread to terminate all further processing for the transaction when the status is non existent and the lock cannot be obtained because the row does not exist in the database and e the worker thread to initiate a clean up operation for the enqueued message when the lock on the row is available and the status for the row is pending and the enqueued message has exceeded a time threshold.

In one embodiment the system further includes a web server to implement the request interface to receive the request from the client device. In one embodiment a multi tenant database system implements the database and is communicably interfaced with the system.

Method begins with processing logic for receiving a message specifying a transaction to be processed via a host organization block .

At block processing logic inserts a row into a database of the host organization associating the message with a status of pending.

At block processing logic dispatches the message to a worker to process the transaction specified by the message.

At block processing logic updates the status for the row to ready if a commit operation for the transaction is initiated.

At block processing logic performs final processing for the transaction based on the status for the message and based further on whether the lock is obtained for the row. For example final processing may include a transaction roll back a transaction commit a transaction requeue a termination of transaction processing an orphaned transaction clean up skipping a scheduled clean up operation and so forth. Such operations are set forth in detail above with reference to .

The exemplary computer system includes a processor a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. static memory such as flash memory static random access memory SRAM volatile but high data rate RAM etc. and a secondary memory e.g. a persistent storage device including hard disk drives and a persistent database and or a multi tenant database implementation which communicate with each other via a bus . Main memory includes a message broker and a message queue framework . Main memory and its sub elements e.g. and are operable in conjunction with processing logic and processor to perform the methodologies discussed herein.

Processor represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processor may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processor is configured to execute the processing logic for performing the operations and functionality which is discussed herein.

The computer system may further include a network interface card . The computer system also may include a user interface such as a video display unit a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. an integrated speaker . The computer system may further include peripheral device e.g. wireless or wired communication devices memory devices storage devices audio processing devices video processing devices etc. .

The secondary memory may include a non transitory machine readable or computer readable storage medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable storage media. The software may further be transmitted or received over a network via the network interface card .

While the subject matter disclosed herein has been described by way of example and in terms of the specific embodiments it is to be understood that the claimed embodiments are not limited to the explicitly enumerated embodiments disclosed. To the contrary the disclosure is intended to cover various modifications and similar arrangements as are apparent to those skilled in the art. Therefore the scope of the appended claims should be accorded the broadest interpretation so as to encompass all such modifications and similar arrangements. It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the disclosed subject matter is therefore to be determined in reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

