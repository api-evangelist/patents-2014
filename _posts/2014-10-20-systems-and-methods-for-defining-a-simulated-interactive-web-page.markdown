---

title: Systems and methods for defining a simulated interactive web page
abstract: The system includes a novel software application interactive representation modeling language, a software application () operative to use the modeling language to create, read and modify interactive representation models of the proposed applications, a memory () to store requirement data and interactive representation model data, a software application () operative to read and update the interactive representation model data across a computer network, a software application () operative to maintain a record of the requirements and to administer operation of the system, a software application () operative to render interactive representations of the proposed applications in browser readable format, a software application () operative to allow multiple instances of other applications to access interactive representation data and requirement data residing in the memory and a software application () operative to allow an individual user's interactions with the system to be broadcast across a networked system to other users.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09361069&OS=09361069&RS=09361069
owner: iRise
number: 09361069
owner_city: El Segundo
owner_country: US
publication_date: 20141020
---
This application is a continuation application of U.S. application Ser. No. 14 339 706 filed Jul. 24 2014 which is a continuation application of U.S. application Ser. No. 13 856 137 filed Apr. 3 2013 which is a continuation application of U.S. application Ser. No. 11 671 331 filed Feb. 5 2007 now abandoned which is a continuation application of U.S. application Ser. No. 10 763 080 filed Jan. 22 2004 now U.S. Pat. No. 7 174 286 issued Feb. 6 2007 which is a continuation application under 35 U.S.C. 365 c and 35 U.S.C. 120 of prior PCT application PCT US02 23816 filed Jul. 26 2002 which was published as WO 03 010684 A1 on Feb. 6 2003 under PCT Article 21 2 in English which claims the benefit under 35 U.S.C. 119 e of U.S. Provisional Application No. 60 308 052 filed Jul. 26 2001 the entireties of which are hereby incorporated by reference herein.

This application is related to i copending application entitled SYSTEM AND PROCESS FOR GATHERING RECORDING AND VALIDATING REQUIREMENTS FOR COMPUTER APPLICATIONS Ser. No. 10 484 541 which is the National Phase of prior PCT application PCT US02 23816 filed Jul. 26 2002 to ii copending application entitled SYSTEMS AND METHODS FOR COLLABORATIVE PROGRAMMING OF SIMULATIONS OF COMPUTER PROGRAMS Ser. No. 10 763 012 filed Jan. 22 2004 which is also a continuation application of prior PCT application PCT US02 23816 and to iii copending application entitled SYSTEMS AND METHODS FOR A PROGRAMMING ENVIRONMENT FOR A SIMULATION OF A COMPUTER APPLICATION Ser. No. 10 762 428 filed Jan. 22 2004 now U.S. Pat. No. 7 349 837 issued Mar. 25 2008 which is also a continuation application of prior PCT application PCT US02 23816.

The present invention is directed to a system and process for gathering recording and validating requirements for computer applications in the fields of requirements analysis for computer application development and of computer application development.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by any one of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention has applicability in the field of design and development of computer software applications for businesses and other entities particularly concerning large complex systems adapted for networks including private networks as well as public networks such as the Internet.

With the increasing complexity involved in the development of computer programs that embody very sophisticated business logic specification of the requirements of these programs before they are actually built i.e. programmed into computer readable code is important to timely and cost effective production of these systems.

As organizations are forced to do more with less the need to deliver such applications on time and on budget without sacrificing quality presents a bigger challenge than ever before. One of the major problems in these fields is system definition i.e. the effective identification of accurate complete and unambiguous requirements for the system or application. This is especially true of applications used on the Internet. These applications must meet requirements related not only to graphic design content and usability but also related to complex scenarios of user system interactions that are not complete and accurate requirements from outset and may not even be documented before starting the application design.

Traditional software development falls typically into several main disciplines. The first is known as the waterfall software development life cycle approach. The second approach attempts to improve the effectiveness of the waterfall approach by introducing prototypes into the development lifecycle early in the development cycle. Each of these approaches is associated with significant problems.

The waterfall approach is a development method that is linear and sequential. Waterfall development has distinct goals for each phase of development. Once a phase of development is completed the development proceeds to the next phase and there is no turning back. This phase of development is analogous to the flow of water over a waterfall it cannot flow back to the top of the waterfall. In the waterfall design approach the requirements gathering phase typically results with capture of requirements on paper documents. Typically the system designers generate a paper based design from the paper based requirements. The system developers then interpret the paper based design and convert it into executable computer code. Typically the executable code is then delivered to the testers who then evaluate the code to determine if the resulting computer application meets the requirements.

While waterfall development allows for departmentalization and managerial control it does not allow for much reflection or revision. Iterations of the design process require iterations of the entire process. However once an application is in the testing stage it is very difficult to go back and change something that was not well thought out in the concept stage. Also typically problems are not discovered until system testing and requirements must be fixed before the system is designed. Requirements evolution makes the development method unstable. Often during the design and code writing phases requirements inconsistencies missing system components and unexpected development needs are discovered. Also system performance cannot be tested until the system is almost coded and under capacity may be difficult to correct. For these reasons the standard waterfall model has been associated with the failure or cancellation of a number of large systems.

Known alternatives to the standard waterfall design approach include modified waterfall approaches that include those that start with a very rough notion of the system and become more detailed over time analogous to going over several smaller waterfalls spiral waterfall design and those that include overlapping phases and sub projects modified waterfalls .

Other known design approaches include the staged delivery approach in which the designer reviews the concept requirements analysis and architectural design phases and then implements these phases shows them to the customer as the components are completed and then goes back to the previous phase s if needed.

All of these waterfall type approaches suffer from the same or similar problems however. The iterative approach through the phases even when overlapped results in static requirements being interpreted into static designs and developments. Because the requirements for most systems are not well understood in the beginning the costs for development often become excessive and delivery schedules originally estimated must be revised. Finally because complex systems typically are not well understood in terms of their actual implemented behaviors it is only through actual interaction with the system that the system designers and business analysts truly begin to understand what has been built. Although the lessons learned may be valuable during waterfall implementations they cannot easily be taken advantage of due to the prohibitive costs of re factoring the designs and implementations to reflect the new requirements that spring from these lessons.

The second general approach the prototyping of critical parts of the application was developed partly in response to the problems associated with the waterfall and modified waterfall approaches. As used herein the term prototype and its variations in the context of the design of computer applications means the use of some form or stage of application code or the use of static images to represent computer screen display.

The prototyping of critical parts referred to sometimes herein as code prototyping also was developed in response to awareness in the field of the invention that software product development tends to move along four paths 1 ideas to product 2 low technology to high technology 3 drawings to code and 4 appearance and behavior to performance. In the code prototyping approach a prototype code is built to test the results of the planning phase during which the developers attempt to understand the users and the users needs and how those were to be addressed in the software application. The prototype code is then measured to see how the user reacts and understands the developer s work and is analyzed to see which parts of the prototype are doing well and which parts are not. In this prototyping approach the prototype is actually code that is intended to accomplish the intended purpose of designated parts of the overall software application and is therefore referred to herein as a coded prototype. 

The prototyping approach also has been associated with numerous problems foremost among them is that prototypes are typically written in computer languages that only programmers can understand and use. Thus the prototypes are still developed as traditional computer programs by programmers. This has several drawbacks. The first drawback is that business analysts who are the people most likely to understand the needs and desires for the computer application cannot develop the prototype without reliance on computer programmers and must translate and communicate these needs and desires to computer programmers in order to have them construct the prototype. This communication is traditionally inefficient and translation errors tend to be introduced because of the differences in the interpretation of the needs and desires for the prototype between two constituencies with differing backgrounds and skill sets. Second in many organizations skilled programming resources are preferentially assigned to fixing existing computer systems or completing development of systems that are soon to be placed in production. Thirdly programming resources need potentially expensive hardware and software tools to accomplish their work. Fourthly because prototypes are frequently constructed using the same infrastructure that the eventual application will be deployed upon prototyping efforts are frequently delayed until strategic hardware acquisition development software acquisition and training have been completed.

Yet another problem with prototyped systems is that they tend to become a replacement for actual development of the envisioned system. There is a tendency to attempt to field a completed or near completed prototype. Because the programmers were originally building just a subset of the system for demonstration purposes short cuts typically are taken in this phase that lead to systems that do not scale well and have significant performance problems.

Yet another problem with coded prototypes is that they suffer from poor documentation often because the prototype and the requirements are not represented within the same context.

Another problem with coded prototype based developments arises from the tendency for difficult problems to be pushed to the future and not solved by the time of product completion so that the initial hope of the prototype is not met by the subsequent product.

Because of these limitations another prototyping approach referred to as static prototyping has evolved. In this approach only an image of the user interface of the prospective computer application is developed. This image may be created using commonly available drawing and diagramming software and may be created without some of the drawbacks associated with employing programming resources to create a coded prototype. Prototypes created in this manner however suffer from additional drawbacks. Foremost among them is that such static prototypes created with drawing and diagramming software are unable to convey to stakeholders an understanding of or how the application will behave. Prototypes constructed in this manner do not exhibit many of the interactive behaviors of computer applications e.g. navigation from screen display to other screen display computation storage and retrieval of data. They are therefore referred to as static image prototypes herein. It is commonly known in the field of the current invention that stakeholders are much more apt to identify potential errors or omissions in the early phases of software development if they are permitted to interact with a prototype that does exhibit these interactive behaviors.

To summarize the forgoing discussion of background art coded prototypes suffer from drawbacks derived from the need to utilize computer programmers in their construction and static image prototypes suffer from drawbacks derived from the fact that they are inherently not interactive.

In addition the evolutionary delivery design process a cross between evolutionary prototyping and staged delivery is known.

Within the context of the above described software design approaches many systems analysts simply use a pad of paper to record requirements they gather from the eventual users of the computer program being envisioned for development. Still other systems analysts use word processing programs to write specifications in a prose style. Several design methodologies have emerged to graphically describe the use of iteration with computer programs and how these programs are to be organized internally. Ultimately these specifications all coalesce to static representations of the proposed or prospective computer program that computer programmers must either read on paper or read from a computer screen to gain an understanding of what the systems analysts interpreted what the users meant when they designed the system. The programmers must then write the code that represents their best interpretation of what the systems analysts and the users meant when the static system specification was created. Finally after the computer programmers create the computer software code it is tested by the systems analysts and users to determine if the programmers interpretation of the system specification that is in turn the system analysts interpretation of the requirements from users of the proposed computer system meets the users requirements. In complex systems that must interact with multiple users playing different roles and in turn interact with multiple other computer programs also playing different roles the probability of interpreting the users requirements correctly the first time is quite remote. This necessitates frequent code changes and reinterpretations first by the users second by the systems analysts and third by the computer programmers. This cycle is repeated until the computer programmers rewrite the software enough times to embody what the users require of the system. The reliance on static documents to transfer the requirements into a correct computer program results in repeated cycles of development. These cyclic and redundant development activities inflate the cost of the resulting system.

As such the programmers at the end of the cycle of research and development of a large program or system typically are left to discover all of the ambiguous hidden and conflicting requirements as they actually write software code. This invariably leads to failures of the code to correctly embody the users requirements longer development cycles increased costs and lower quality end products.

In addition known computer application development approaches typically do not include input from all of the various stakeholders. Rather it is generally business managers who determine the need for the application and then business analysts translate these needs into the domain specific jargon appropriate to the problem being solved and finally the computer programmers translate the business domain information into executable code. This serial process leads to misunderstandings unresolved issues and misconceptions.

Finally another problem with known software application development approaches is that software testers are provided with only a document for use in developing quality assurance and acceptance tests and acceptance testing can occur only at the end of the development cycle. This is an additional source of delay and problems because the quality assurance engineers are then required to conduct their own interpretation of all of the prior development work.

The right of priority for the present invention is claimed on the basis of U.S. Provisional Patent Application Ser. No. 60 308 052 filed Jul. 26 2001. The disclosure of invention contained therein is incorporated by reference as if set forth fully herein.

With reference to the overall process of a preferred mode of the present invention is shown at including its requirements gathering recording and validation steps. Upon starting the process initial requirements for a proposed or prospective computer software implemented application are collected at . The computer application that is intended to be developed and deployed based on the requirements and an interactive representation generated using the present invention is referred to alternatively as the proposed application the prospective application the intended application and the subject application.

The requirements are then recorded in an electronic requirements repository or memory shown at . Next an initial interactive representation model sometimes referred to as an IRM of the prospective application is created at . In the course of adding to or creating the initial interactive representation model at associations between requirements and elements of the interactive representation may be recorded in an electronic repository or memory. Then the interactive representation model and the requirements along with their associations between them may be reviewed at . During the course of reviewing the interactive representation and requirements at requirements may be added and associated to elements of the interactive representation. Following the review at a determination is made at on whether the interactive representation model and the requirements are sufficiently complete. If they are sufficiently complete then they are provided as outputs of the process at which serve as inputs for generation of the actual code for the prospective application. If they are not sufficiently complete then the requirements are modified at and or the interactive representation model is modified at . In the course adding to and or modifying requirements at or when modifying and or adding to the interactive representation model at associations between requirements and elements of the interactive representation may be recorded in the electronic repository or memory.

The term user s and the term stakeholder s herein refer collectively and individually to persons who participate in the process of the present invention and or utilize the software components of the present invention. The term user s include s but is not limited to business analysts programmers project managers business managers and users of the prospective or subject application. The term user s also means 1 individuals who will use or are intended to use the subject application once it has been developed and deployed and or 2 individuals who represent the proposed application users in the process of the present invention particularly with respect to communicating their needs and desires relative to the behavior of the prospective application. For example when gathering and validating the requirements for a subject application that will be used by the general public for example a retail internet application for the sale of books or compact disks it is unlikely that a significant number of the subject application s eventual users the general public will be available to participate in the process of the present invention. Instead marketing representatives product mangers and similar individuals would act as proxies or surrogates for the subject application s end users. Thus as used herein the term proposed application user s refers to both the true user s of the subject application as well as to those acting as their proxies.

As used herein the term requirement s refers to a statement or portion of a statement regarding the desired or necessary behavior of a prospective or subject computer implemented software application or a set of proposed applications. A collection of one or more requirements is a subset of the information that is typically provided to computer programmers and typically enables them to develop a computer application. For example a subset of the requirements for a retail internet application might include the following requirements 

The initial requirements for the subject application are recorded at and subsequently modified or added to at by business managers business analysts programmers and subject application users. Within this context an advantageous feature of the present invention is its ability to enable multiple users to view and edit the requirements over a computer network.

Another advantageous feature of the present invention is its ability to enable flexible definition of a classification structure for the requirements and assignment of each requirement to one or more of these classifications. For example different classifications could include order management requirements technical requirements and requirements from external clients. Another advantageous feature of the present invention is its ability to designate the e mail addresses of other users and interested parties such that any change to the electronic record of the requirements causes an e mail to be sent to each address to notify the recipient of the change. Also the present invention provides the ability to establish the value of several attributes of the requirements. For example type subtype priority status and assigned to attributes may be established. Other advantageous features of the present invention include its ability to record electronic discussions regarding the requirements its ability to store and retrieve various electronic documents with each requirement and its ability to produce on screen or printed reports of the requirements. Still other advantageous features of the present invention include its ability to record defect reports and tasks related to requirements. In this context a defect report includes statements regarding incorrect or undesirable behavior of the prospective application that can optionally be tracked in the present invention after providing the outputs of the invention at to individuals involved in the development and deployment of the prospective application. In this context tasks refer to an optional record of activities to be performed or activities that have been performed by users during the course of the use of the invention. These functions are provided by a software application that is part of the present invention. This application is programmed preferably in Java language and provides requirements management functionality for the preferred implementation of the present invention.

A feature of the overall process is creation of an interactive representation sometimes referred to as IR and or an interactive representation model sometimes referred to as an IRM of the prospective application. For the purposes of the present invention the term interactive representation means 1 a simulation of the behavior of a prospective application that is used to review conformance of behavior to the desired or necessary behavior of the prospective application before it is developed and deployed or 2 the result of interpreting and executing an IRM. The IRM is an executable set of computer data that defines how an IR behaves. In a preferred embodiment of the present invention this computer data is stored in terms of fundamental units referred to as primitives or rules and relationships among these rules that are permitted by an interactive representation modeling language sometimes referred to herein as IRML. More specifically IRML refers to a language created as part of the present invention and used in the embodiments of the invention to specify the behavior of an interactive representation. That language is represented in terms of the fundamental rules or primitives that are used to create and execute interactive representations. As used herein the term primitive refers to the most basic indivisible unit in a language specifically including the IRML used in the present invention and its alternate embodiments. A list of preferred IRML primitives for preferred embodiments is provided in Table II.

One or more users create the initial IRM at and modify and or add to the IRM at through various mouse and keyboard gestures understood by one of the software components of the present invention as will be described in detail. Using this software referred to as Studio a user defines the appearance and behavior of an interactive representation by 1 adding IRML primitives to the IRM 2 setting their attributes and in some cases their location and 3 establishing relationships between and among these IRML primitives as will also be described in detail. The requirements for the prospective application are then associated to the primitives in the interactive representation. Each association is recorded in a single electronic system of record. Examples of activities that can be performed by a user during creation of the initial interactive representation model at or modifying and or adding to the interactive representation model at include 

The user may also define attributes effecting the appearance and behavior of these various user interface components in the interactive representation. Alternatively users may choose to specify very minimal information regarding the appearance of the subject application and focus instead on later steps in this process. The process of creating the user interface of the IRM continues until the user has defined one or more pages that are intended to represent the user s understanding of the desired or needed behavior of the subject application.

The Studio software component enables the user to request that the interactive representation be displayed by the simulation software component at any time. This is also an advantageous feature of the present invention because in permits users to review the work done to date and or to evaluate the extent to which the interactive representation reflects the users interpretation of the requirements. In accordance with the principles of the present invention it is intended that users will iteratively modify the IRM and review its compliance with the requirements through use of the simulator component of the invention as will be described in detail hereinafter.

It might appear that the presentation of the process for developing an IRM as described herein implies a progression from user interface definition to user interface flow definition and only then to definition of more complicated behavior of the IRM. However another advantageous feature of the present invention is that it enables these activities to occur to varying degrees as will be described in detail below in any order in the overall system as desired by the users. Furthermore the activities described in this process may be distributed among multiple users working collaboratively on one or more IRMs. Furthermore in other implementations of the present invention one or more of such activities may be omitted from the process without significant impact on the efficacy of the process. For example the activity of defining additional behaviors in the IRM may be omitted if the users conclude that the requirements and interactive representations are sufficiently complete to express the users needs and desires. With respect to the above functions another advantageous feature of the present invention is the ability of its Studio software component to enable the user through a series of simple mouse movements to record an association between one or more requirements and one or more primitives that have been added to the IRM. Similarly the Studio software component enables the display of associations that have been previously defined.

Yet another advantageous feature of the present invention is the capability of the Studio software component working in concert with the Music software component to enable multiple users to collaboratively and simultaneously work on the same IRM. In the preferred embodiment of the present invention several users may utilize individual copies of the Studio component on different computers and in the context of the present invention each individual copy is referred to as an instance of the Studio. Modifications to the IRM made by one user working with that user s instance of the Studio are seen by other users working with their instances of the Studio on a near real time basis. Furthermore these changes are immediately visible to any user who is executing the IRM. As would be evident to a person skilled in the art this near real time capability constitutes another advantage of the invention relative to computer systems in which users must publish the results of their work to other users or computer systems in which users must actively retrieve the results of others work. For example consider two users Jon and Stephen working collaboratively and simultaneously on the creation of a single IRM. As Jon adds new primitives to the model using his instance of the Studio component Stephen s instance of the Studio program displays the new primitives on a near real time basis. Unlike many known computer systems Jon does not need to instruct his instance of the Studio to update Stephen s instance nor does Stephen need to request the latest IRM from Jon s instance. As used herein the term collaboration and its variations refer to the shared creation of two or more individuals with complementary skills by their interacting to create a shared understanding of a proposed software application that none had previously possessed or could have created alone. The goal of collaboration is the creation of value resulting from interactions among the collaborators. Collaboration as thus defined and as enabled by the system and process of the present invention enables near real time access by all collaborators. Thus in accordance with the principles of the present invention the IRM serves as both a model and as a guide or road map for identifying and reducing ambiguity that arises during creation of a proposed software application before it is coded or deployed.

Similarly changes to the requirements made by the ION or Studio software components are reflected in all other instances of ION and the Studio. This dynamic sharing of requirements and IRM information facilitates effective communication between all users of the system and contributes to higher quality requirements and IRMs. Furthermore this dynamic sharing of information coupled with the feature of a single electronic record of the requirements and IRM of a particular subject application reduces the need for users to maintain and reconcile multiple copies of the same information.

The next step in the overall process of the present invention is the review of interactive representation and requirements shown at . In this step the interactive representation of the subject application in conjunction with the associated requirements may be reviewed iteratively by business managers business analysts programmers and proposed application users. In the presently most preferred embodiment or mode of practicing the invention two activities are available for accomplishing this task simulation and simulcasting as will be described in detail below.

Simulation is an activity that begins when a user executes an interactive representation model by choosing the simulate menu item in the ION software component or the simulate menu item in the Studio software component. This choice causes the simulator component of the present invention to render the selected page of the IRM to the user s browser. As referred to in the present invention the term simulator means a software component of the present invention that renders an interactive representation of a proposed application and related requirement information based on an interactive representation model and associated requirement information.

The simulator initially provides a list of the pages in the application to the user. The user then chooses the page at which they would like to simulate and calls the simulator again. Upon receiving the request for this page the simulator creates a temporary memory area to build a response to the user s request. The simulator then visits the primitive that represents the page requested by the user and processes that primitive along with all of the primitives contained by that page. As it visits primitives the simulator incrementally builds up its response. Some primitives are used to display variable data to users and for each of these primitives the simulator starts a separate process to determine the values of these variables. Once all the necessary primitives have been visited and their corresponding portion of the response has been appended to the response the response is sent back to the user. Typically the user then enters data and clicks on a button or link to submit this data for processing. The simulator receives this submission and extracts the values entered by the user into the fields that were presented to them. It then passes these values to primitives in the IRM that call standard sub routines that process the data and in turn pass the results of such processing on to other sub routines for further processing. This continues until all processing is complete at which point the simulator begins construction of the response to the user in the same way it constructed the user s first request for a page. Once completed the simulator passes its response to the user and waits for another request. This process repeats until the user has completed their interactive representation session.

Another advantageous feature of the present invention is its capability to display the requested page in a certain format referred to as Meta mode. In Meta mode the requirements associated to the primitives contained on the page through use of the Studio software component are displayed on the user s browser in addition to display of the page itself. Furthermore each of the primitives that is visually represented on the page is automatically assigned a reference number and each of the requirements displayed is cross referenced to these numbers. In the present invention this display of the IRM page and the cross referenced requirements is referred to as requirements in context . This feature of the present invention is intended to facilitate each user s understanding of the requirements and to significantly increase the likelihood of discovery of erroneous or incomplete requirements at this stage of the overall process. In addition preferred embodiments of the present invention provide the capability to produce a report that contains the image of the page the automatically assigned cross reference numbers and the cross referenced requirements.

Simulation continues as the user though mouse and keyboard gestures interacts with the interactive representation. For example the user may enter text into text inputs presented in the interactive representation or may click buttons presented in the interactive representation. Each of these interactions is then communicated by the user s browser to the simulator software component. The simulator software component then evaluates each interaction and responds by rendering a new page to the user s browser with the new page including the result of each interaction. In this way the user is presented with an experience very similar to what would be experienced if that user were interacting with the completed proposed application. This capability is also advantageous because it greatly increases the likelihood of discovering erroneous or incomplete requirements at this stage of the overall process.

The simulator software component also provides as yet another advantageous feature a capability for the user to enter newly discovered requirements directly into the user s browser during simulation and for these requirements to be stored by the ION software component into the repository of requirements for the subject application.

As used in describing the present invention the term simulcasting refers to an activity that is identical to that of simulation but with the following differences. When simulcasting an individual user s interaction with the IRM through the simulator is broadcast to other users. The individual user whose interaction is broadcast is referred to as the lead user. The users viewing the interaction are referred to as following users. This provides another way in the present invention to review interactive representations and requirements as shown at . Furthermore the simulcastor software component provides the capability for a following user who is viewing the interaction broadcast through the simulcastor software to temporarily initiate each such user s own interaction with the IRM and at a time chosen by the lead user to be returned to the broadcast simulation. In the preferred implementation this capability is provided by the simulcastor. The simulcastor is a software program application implemented using Java language in an applet framework. Alternatively known commercial web casting applications such as for example Web Ex could be used to provide this or similar functionality. The preferred embodiment however is advantageous relative to this alternative because the preferred embodiment does not require purchase or configuration of additional software nor does it require additional training for effective use.

In the next step of the overall process of the present invention the user or several users determine if the requirements and the IRM are completed sufficient at to warrant proceeding to providing outputs to design and delivery of the actual code for the prospective application at .

If the requirements and or the IRM of the proposed application is determined to be incomplete the process of the present invention enables the user to modify and or add requirements at and or to modify and or add to the IRM at . As used herein the terms incomplete or insufficiently complete when used in reference to requirements or the interactive representation by way of example and not by way of limitation refer to instances where either the requirement or interactive representation does not accurately represent the needs and or desires of the users regarding the behavior of the prospective application or when changes to the interactive representation or requirements could better communicate to the designers and developers the intended behavior of the application.

The actions taken at are operationally the same as the combination of actions taken at and at with one difference. The difference is that in the case of step users edit the previously described requirements to increase conformity with the needs and or desires of the users and or by adding newly discovered requirements.

The actions taken at are operationally the same as those at with one difference. The difference is that the users modify or add to the interactive representation model to increase conformity with the needs and or desires of the users.

The process then proceeds to step review interactive representation and requirements and subsequently to step in which again a determination is made on whether the requirements and or the interactive representation model are sufficiently complete.

When the interactive representation model and the requirements are sufficiently complete the process proceeds to provide outputs to design and delivery at . These outputs are used by the individuals involved in the design programming testing and deployment of the proposed application as a description of the needed and desired behavior of the proposed application. This step preferably includes utilizing the ION software component of the invention to generate various reports that can then be provided to programmers designers architects testing personnel and others involved in the actual development and or deployment of code for the proposed application.

These reports are the result of yet another advantageous feature of the present invention i.e. the ability of the ION software component working in conjunction with the simulator software component to generate such reports such as a functional specification report. An example of such a report is shown in described below. This report depicts a visual image of the appearance of a page or pages in the IRM as well as a list of requirements that are associated with user interface components that appear on the page or pages. Furthermore the functional specification report automatically provides a numerical cross reference between the user interface components and their associated requirements. In practical application of the present invention steps and occur iteratively as the requirements and IRM incrementally approach completion. Another advantageous feature of the present invention is that 1 this iterative process results in better communication between and among users regarding the needs and desires of the users relative to the subject application and 2 changes made in steps and are immediately recorded such that step can occur within seconds of steps and .

Also in practical application of the principles of the present invention users may elect to begin the process at step when it is believed that the user s has have sufficient knowledge regarding the needs and or desires for the subject or prospective application to begin at this step in the overall process.

One embodiment is a method of defining a simulated interactive Web page where the method includes displaying on a computer display a programming area comprising one or more HTML user interface components for the simulated interactive Web page displaying on the computer display an area for primitives and enabling a user to draw a graphical coupling from a selected HTML user interface component to a selected primitive wherein execution of the simulated interactive Web page is based at least in part on an interpretation of the graphical coupling.

One embodiment is an interpreted interactive representation modeling apparatus that is executable in an interactive graphical user interface where the apparatus includes a user interface component displayed in the interactive graphical user interface where the user interface component includes at least two visible branches where the visible branches are visible at least during configuration of the instruction for the interpreted interactive representation modeling language a Boolean condition associated with at least a first branch and a second branch of the at least two visible branches where the first branch is associated with a first state of the Boolean condition and where the second branch is associated with a second state of the Boolean condition where the association of the Boolean condition is visibly displayed in the interactive graphical user interface at least during configuration of the instruction an interactive component responsive to user interaction during execution of the instruction where the interactive component monitors data flow inputs to the interactive graphical user interface for a selection of a state of the Boolean condition at least a first executable instruction associated with the first branch where the first executable instruction is activated upon the detection of a selection of the first state of the Boolean condition such that the first executable instruction is conditionally executed and at least a second executable instruction associated with the second branch where the second executable instruction is activated upon the detection of a selection of the second state of the Boolean condition such that the second executable instruction is conditionally executed.

One embodiment is an interpreted interactive representation modeling apparatus where the apparatus includes a user interface component displayed in an interactive graphical user interface where the user interface component includes at least three visible branches where the visible branches are visible at least during configuration of the instruction for the interpreted interactive representation modeling language an integer mode condition associated with at least a first branch a second branch and a third branch of the at least three visible branches wherein the first branch is associated with a first integer value of the integer mode condition the second branch is associated with a second integer value of the integer mode condition the third branch is associated with a third integer value of the integer mode condition wherein the association of the integer mode condition is visibly displayed at least during configuration of the instruction an interactive component responsive to user interaction during execution of the instruction where the interactive component monitors for a selection of a value for the integer mode condition at least a first executable instruction associated with the first branch where the first executable instruction is activated upon the detection of a value corresponding to the first integer value of the integer mode condition at least a second executable instruction associated with the second branch where the second executable instruction is activated upon the detection of a value corresponding to the second integer value of the integer mode condition and at least a third executable instruction associated with the third branch where the third executable instruction is activated upon the detection of a value corresponding to the third integer value of the integer mode condition.

One embodiment is a method of interacting with a user to define a behavior of a portion of an interactive presentation where the interactive presentation corresponds to a simulation model where the interactive presentation and the user interact via an interactive graphical user interface where the method includes monitoring a manipulation of a cursor by a pointing device monitoring a graphical dragging and dropping of a first graphical symbol to a first area in the interactive graphical user interface such that a user interface component appears in the first area where the user interface component corresponds to a conditionally executed instruction receiving a name for the user interface component receiving a name and a text description for a requirement for the user interface component identifiably storing the name of the user interface component the name of the requirement and the text description of the requirement with the user interface component monitoring a dropping of a second graphical symbol into the first graphical symbol in the pane of the interactive graphical user interface and at least partly in response to the dropping of the second graphical symbol adding a first branch to the first graphical symbol where the first branch corresponds to a first code that is executed upon selection of the first branch during run time monitoring a dropping of a third graphical symbol into the first graphical symbol in the pane of the interactive graphical user interface and at least partly in response to the dropping of the third graphical symbol adding a second branch to the first graphical symbol where the second branch corresponds to a second code that is executed upon selection of the second branch during run time and receiving a data flow input control for the first graphical symbol where the data flow input is associated with the first graphical symbol such that when the interactive simulation of the simulation model runs in the interactive graphical user interface a combination of the data flow input control and a data flow input received during run time control the branching of the first graphical symbol to the first branch and to the second branch.

One embodiment is a method of automatically configuring at least a portion of a behavior for an instruction for a requirements validation computer program where the method includes providing a user interface component in an interactive graphical user interface monitoring conditional branches added to the user interface component where the conditional branches control program flow for the requirements validation computer program automatically associating the conditional branches with a Boolean state when there are two conditional branches associated with the user interface component and automatically associating the conditional branches with an integer mode when there are at least three conditional branches associated with the user interface component.

One embodiment is a computer system that is configured to define a simulated interactive Web page where the computer system includes a component configured to display on a computer display a programming area comprising one or more HTML user interface components for the simulated interactive Web page a component configured to display on the computer display an area for primitives and a component configured to enable a user to draw a graphical coupling from a selected HTML user interface component to a selected primitive wherein execution of the simulated interactive Web page is based at least in part on an interpretation of the graphical coupling.

One embodiment is a computer system that is configured to define a simulated interactive Web page where the computer system includes a means for displaying on a computer display a programming area comprising one or more HTML user interface components for the simulated interactive Web page a means for displaying on the computer display an area for primitives and a means for enabling a user to draw a graphical coupling from a selected HTML user interface component to a selected primitive wherein execution of the simulated interactive Web page is based at least in part on an interpretation of the graphical coupling.

One embodiment is a computer program embodied in a tangible medium for defining a simulated interactive Web page where the computer program includes instructions configured to display on a computer display a programming area comprising one or more HTML user interface components for the simulated interactive Web page instructions configured to display on the computer display an area for primitives and instructions configured to enable a user to draw a graphical coupling from a selected HTML user interface component to a selected primitive wherein execution of the simulated interactive Web page is based at least in part on an interpretation of the graphical coupling.

One preferred embodiment of the current invention includes several software components. These components and their interaction are described in this section with reference to . The software components of the present invention may stored individually or collectively on any computer readable medium such as by way of example including but not limited to conventional hard disks CD ROMS Flash ROMS nonvolatile ROM RAM and floppy disks.

A standard browser such as preferably Microsoft Internet Explorer is used to present the user interface of the ION component of the present invention as well as the user interface to the simulator component of the present invention. The browser and ION component interact over a computer network utilizing a TCP IP and HTTP or HTTPS communication protocols . Similarly the browser and the simulator interact over the computer network utilizing TCP IP and HTTP or HTTPS . The browser component runs on a computer system typically referred to as a client computer.

The ION component of the present invention is used to edit information regarding requirements defect reports and tasks and information regarding administration used for the operation of the present invention such as user names and passwords.

The simulcastor component runs within a standard browser not depicted in and is used to present the interactive representation to multiple users concurrently. The simulcastor component also interacts with the simulator component over computer network utilizing TCP IP and HTTP or HTTPS protocol .

The studio component of the present invention is used to edit the IRM and the requirements and interacts with the music client component . Communication between these components is implemented through use of conventional Java method calls. The music client component communicates with the music server component over computer network utilizing TCP IP and HTTP or HTTPS prototype .

The music client component at and of the present invention working in conjunction with the music server component of the present invention provide access to information about the requirements and IRM as well as administrative information stored in the repository files to the ION component the simulator component and the studio component .

The music server component mediates the storage and retrieval of information regarding the requirements tasks defect reports and the IRM among multiple users of this information and reads and writes transactions reflecting changes to this information to the repository files . The music server component also communicates any changes to the information made by one user on a near real time basis to other users accessing the same information and provides for grouping of related updates to this information.

The repository files component is a set of computer files encoded in an industry standard format called Extensible Markup Language XML that contains information regarding the IRM requirements defect reports tasks and administrative information used in the operation of the present invention such as user names and passwords. XML offers a flexible format for storing different data and other advantages as would be understood by an individual skilled in the art. The ION simulator and music server components as well as an instance of the music client run on a computer system typically a server that runs a Servlet and Java Server Page JSP container . Communication among these components is implemented through use of conventional Java method calls.

Alternative embodiments of the present invention could be implemented through use of a commercially available version of a container such as BEA WebLogic or IBM WebSphere containers. However such alternative embodiments would require users of the present invention to pay license fees to the vendor of those containers.

Another way to describe the role and interaction of the Studio IRML and the simulator in the present invention is to relate each to common definitions that are familiar to those skilled in the art. The studio can be considered to be a specialized editor used to edit the IRML language. IRML is subsequently processed by the simulator which is similar in function to an interpreter. As with other editors including for example text editors integrated development environment editors and language specific editors the studio is used to create and maintain a set of computer instructions i.e. a program or in the present invention an IRM for later execution by another program or application. IRML in this context is a specialized computer language designed for use by business analysts and other users not familiar with traditional computer languages like HTML Java or C . The IRML language is designed to be presented graphically by the Studio and is another advantageous feature that permits individuals without programming experience to create IRM s Like other interpreters the simulator is capable of translating a language in this case IRML into instructions that can be ultimately executed by a computer and when so executed results in the interactive representation of the present invention.

In an alternative embodiment of the present invention a commercially available editor computer program such as Microsoft .NET Studio and or a commercially available interpreter computer program could be used in place of the studio and or simulator respectively. However these commercially available computer programs would need to be modified significantly to provide the ability to associate requirements to elements of the interactive representation model and to present these requirements in the context of the interactive representation. Furthermore this alternative embodiment would suffer from some of the drawbacks of prior art with respect to the fact that commercially available editors and interpreters are designed for use by computer programmers. Another disadvantage of this alternative embodiment is that these commercially available computer programs are not specifically designed for creation of interactive representation models but rather for the development of prospective computer applications and therefore may require performance of additional costly activities to achieve a similar effect e.g. declaration of variable types declaration of database record definitions specification of deployment configuration and or installation and configuration of additional database management computer programs.

Similarly in an alternative embodiment of the present invention IRML could be replaced by a single or combination of several existing computer languages such as C Java or Visual Basic . Because these are general purpose computing languages they contain many more primitives and rules for construction than IRML and therefore require additional time and effort in the creation of an IRM. Furthermore this alternative embodiment would suffer from some of the drawback of prior art with respect to the fact that commercially available computing languages are designed for use by computer programmers.

With reference to preferred and alternate software components of the preferred embodiment of the present invention will be described.

The first software component is a computer program that enables the user to read create and modify interactive representation models. Preferably the program is written in Java language. For convenience this program is referred to as Studio and is shown at in . The IRM s in Studio are represented in IRML. depicts operation of the Studio component.

Studio implements three high level processes start up process process user input and process incoming messages .

During the start up process the Studio software calls another software component of the system referred to as the Music Client and requests that an interactive representation model be retrieved from the server and made available for reading and modification at . Upon successful retrieval of an IRM the Studio component displays a visual representation of the IRM as well as other information about the IRM and enters an await state during which time it can receive and process either user input or incoming messages .

The Studio program monitors for user input via keystroke or mouse action. Upon receipt of such information the Studio program performs a function represented at in based on what information was received from the user. The following are examples of the functions that the Studio software performs 

The Studio program then evaluates whether the requested function is valid at . At determination is made at whether or not to exit the program. If the requested function is valid the Studio program executes that function .

If the function changes the information contained in the IRM as determined at then the Studio component updates the IRM by calling the Music Client and updating the electronic record as will be described in greater detail below. In some cases as determined at the Studio program makes immediate changes to the screen displayed to the user that reflect the update at . In other cases the Studio program does not make immediate changes but waits until the music server responds via the music client and then processes the update as incoming messages are processed shown at .

During processing of incoming messages at the studio program receives messages from the local music client whenever a remote music client updates the IRM via the music server. The Studio program then updates the screen displayed to the user reflecting the update shown at unless the studio program has already made these changes under the process user input process described above.

In the preferred embodiment the studio program is written in Java language and utilizes some components of the conventional Swing and AWT libraries that are part of the Java System Developers Kit Java SDK . Alternatively the Studio program could be written in another language such as for example C C or Visual Basic.

The second software component of the preferred embodiment of the present invention is a computer program used to read and update IRM s stored on a server computer across a computer network. The term computer network refers to a private network usually internal to a company or some other organization and also refers to a public computer network such as the Internet. This second software component is for convenience referred to as the music client. The music client preferably is written in Java language. The other software components of the preferred system of the present invention i.e. the Studio ION and simulator programs also use the music client to read and update IRM s. The music client program also enables changes made to an IRM by a studio program running on a computer at one user s location to be transmitted on a near real time basis to other studio programs that are running on different computers. The music client software program that is running on the same computer as a particular studio software program is referred to as the local music client. Music client software programs that are running on other computers are referred to as remote music clients.

The music client software program implements numerous commands that relate to reading and updating IRM s. The preferred commands that the music client of the preferred embodiment processes are listed below in Table I along with a description of the effect of each. The music client software program can be best understood by a person skilled in the art as the implementation of an Application Programming Interface API which is shown in Table I. The first column of the table contains Java method calls that are supported by the music component as would be understood by a person skilled in the art. Commands in this preferred embodiment are provided as Java method calls. The other software components of the preferred embodiment of the present invention that use the music client utilize these commands to access and manipulate information regarding the requirements and the IRM. The descriptions of the effect of the commands listed in Table I below include the terms Tape and Note. Note refers to the basic record that the music software program processes and may contain information about IRML primitives that are part of the IRM and may contain information about the IRM itself and or about requirements. Tape refers to a collection of notes typically the set of notes that collectively comprise a single IRM of a proposed application and its requirements.

The third software program included in a preferred embodiment of the present invention is a computer program that provides the capability to allow multiple simultaneous studio ION and or simulator instances to access IRM s and requirement data residing in a file on a server. This third program is referred to as the Music Server. The Music Server shown at in also coordinates transmission of updates made by the studio ION and or simulator programs to other studio ION and or simulator programs when they access the same IRM.

The music server and the music client programs communicate using Hypertext Transfer Protocol an industry standard communications protocol commonly referred to as HTTP. The music server and the music client can also communicate using Hypertext Transfer Protocol Secure an industry standard encrypted communications protocol commonly referred to as HTTPS.

Alternatively the music server software program could be implemented using a different computer language for example C C or Visual Basic each of which is well known. Similarly the communication between the music server and the music client programs could be implemented using another protocol for program to program communication across computer networks such as for example Remote Method Invocation RMI or Distributed Component Object Model DCOM both of which are well known to those skilled in this field.

Alternatively the functionality provided by the combination of the music server and music client software programs of the present invention could be provided through use of a combination of various commercially available database programs and or messaging programs. Examples of commercially available database programs suitable for use in the present invention include Oracle and SQL Server. Examples of commercially available messaging programs that are suitable for use in the present invention include MQ Series Vittria and Java Messaging Service JMS .

In another alternative embodiment of the invention IRM and requirements data files could be stored on one or more server computers or could be distributed across multiple computers that were running studio ION and or simulator and were utilizing file sharing provided by the computers disk operating systems to share this data.

The third software component of the present invention the interactive representation modeling language referred to as IRML is a language created for and used in the current invention to specify the behavior of interactive representations. The language is represented in terms of 1 primitives and 2 allowed connections between and among these primitives. The list of IRML primitives along with their functions allowed containment relationships allowed outbound connections and allowed inbound connections are presented in Table II Table III Table IV and Table V respectively below.

There are nine classes of primitives in IRML in the preferred embodiment of the present invention 1 user interface components referred to as tags 2 user interface components referred to as input tags 3 user interface components referred to as container tags or containers 4 comments 5 flow labels 6 decisions 7 references 8 constants and 9 actions.

The first three classes of primitives the user interface tags input tags and container tags are similar. The variation in their functions is readily apparent from their descriptions in Tables I V and from the detailed discussions of the control flow and data flow visitation algorithms below. These user interface components and the relationships among them define how the interactive representation will appear to the user as will be described in regard to the simulator component. The relationships among the user interface components represents information that is important to how the interactive representation will appear to the user. The definition of a primitive itself is not sufficient to represent all of the information necessary to explain its function. The relationships between user interface components and other types of primitives is often required to fully describe the interactive representation.

The user interface components in the preferred embodiment represent a subset of conventional user interface components that are available to developers to program a proposed application that is represented by an interactive representation model. These include such components as page form table button text text input and image. Specifically in the preferred embodiment the user interface components are derived from and function in a manner similar to a subset of the user interface components defined in Hypertext Markup Language a standard programming language commonly known as HTML. HTML is typically used by programmers to develop subject applications. Alternatively the user interface components could be derived from and function in a manner similar to those defined by other languages such as Microsoft Windows Visual Basic or the Apple Macintosh OS.

The fourth class of primitives comments provide the user with the ability to annotate the IRM. Comments are not processed by the simulator and do not impact the behavior of the interactive representation. They can be viewed in the Studio component.

The fifth class of primitives flow labels allows users to label data flow relationships between other primitives. Their function is similar to that of variable names in other computer languages as would be evident to a person skilled in the art. The detailed processing of flow labels is described in regard to the simulator component of the present invention.

The sixth class of primitives decisions defines the conditional execution of other primitives. In the preferred embodiment decisions function in a manner similar to that of IF . . . THEN and CASE statements found in conventional computer languages. Alternatively decisions could be based on other conditional or branching structures found in conventional computer languages or derived from common behaviors found in conventional computer applications.

The seventh class of primitives references allow the reuse of portions of an IRM or of other IRMs. The attributes of a reference include a unique identifier for one or more instances of other IRML primitives elsewhere in an IRM. Using a reference primitive is similar to copying one or more instances of primitives but is more efficient from a maintainability perspective. For example common behavior that occurs in several places within an IRM can be specified once and referenced from the places where it occurs. This reference feature of the present invention allows specification of a single simultaneous change to the common behavior rather than a serial or sequential change to the behavior wherever it occurs. In this sense a reference primitive functions to permit simultaneous global changes to an IRM.

The eighth class of primitives constants provide a method of storing data that is commonly used and is relatively static in an interactive representation. For example days of the week a company s product types and valid zip code State combinations are constants.

Finally the ninth class of primitives actions define how data will be transformed derived stored retrieved sorted or otherwise manipulated by the interactive representation. In the preferred embodiment actions include typical ways that computer systems manipulate data and are not specific to any particular computer programming language. Alternatively the actions could be closely based on one or more existing computer languages.

Unlike most known computer software programming languages the preferred implementation of the IRML of the present invention does not explicitly designate the order in which actions are executed or user interface components are rendered. Instead the order of execution is inferred by the simulator component of the present invention from the relationships among primitives as will be described in detail below. This advantageous feature of the present invention relieves the user of the task of specifying order of execution and significantly simplifies the process of creating and maintaining an IRM. Alternatively a language similar to IRML could be implemented in a form that did require explicit ordering of execution.

Also unlike most computer implemented software programs programs using an IRML in accordance with the principles of the present invention preferably do not require the explicit definition of data records separately from how the data contained in those records is manipulated. For example in a typical conventional computer software program a user would need to define to the database subsystem or subroutine that an invoice record contained an invoice number a total amount a vendor identification and typically other data. Separately the user would need to define in that computer application or program that an invoice record contained the same data in the code used to manipulate this data from the database. However because the simulator software component of the present invention working in combination with the music software component is capable of storing and retrieving data without reliance on a static definition of the data contained in a data record the preferred IRML of the present invention enables the user to specify only the manipulation of the data and enables inferring of data record definition from this specification. This advantageous feature of the present invention relieves the user of the task of explicitly describing the definition of data records and relieves the users of the task of ensuring that the same definition is required for each time the corresponding record in the application is manipulated. Alternatively although not preferred the IRML of the present invention could be implemented utilizing a separate static definition of data records.

Additionally unlike most computer languages the preferred IRML of the present invention does not require explicit designation of the type of data that is manipulated by the IRM. Instead all data is considered to be of type string and the implementation of certain actions that manipulate this data include logic to behave in a predictable manner regardless of the true type of the data contained within the string. The term string is well known to those skilled in this field. For example an action named math add will produce the sum of two numbers if it is supplied with two strings that contain numbers. If the math add action receives either two alphanumeric strings or one alphanumeric string and a string that contains a number it will produce the string NaN indicating that one of the inputs is Not a Number. This feature relieves the user from specifying the type of data being manipulated by the system and eliminates the need for the user to ensure agreement between the type of data provided to actions and the type of data that actions expect and or require when processing. Alternatively and although not preferred an IRML in accordance with the principles of the present invention could be implemented in a form that required explicit typing of data.

The fourth computer application included in the preferred embodiment of the present invention provides users with a browser based program that maintains a record of the requirements for a subject application that administers the implementation of the present invention maintains a record of defect reports related to the subject application and its requirements and maintains a record of task performed or to be performed by users of the present invention. For convenience this fourth application is referred to as ION. For purposes of the present invention administration of the implementation consists of activities necessary for the efficient functioning of the overall invention but not including frequently performed activities such as creation of the IRM presentation of interactive representations or recording and editing of requirements. For example administration of the implementation includes establishing user names and passwords creation of files to store IRM information and definition of the range of valid values for attributes of requirements. A detailed discussion of the functions and features provided by ION is provided under Use of the Invention below.

ION is also preferably written in Java using the J2EE Java 2 Enterprise Edition framework. Preferably ION is constructed utilizing standard industry practices for the construction of web based applications and therefore its detailed processing can be inferred from the description of its functions and features described under Use of Invention below by an individual skilled in the art.

In operation the ION program utilizes the music client to retrieve and update requirements that are stored at the music server. As alternative embodiments in accordance with the principles of the present invention the fourth software application could be written in other languages such as for example C C or Visual Basic. Also as yet another alternative the fourth application could be written with one of several proprietary web application development environments for example the Broadvision or ATG Dynamo brands of environments. Also as yet another alternative ION could be replaced by a commercially available requirements management system such as Rational Software s RequistiePro. However drawbacks of this alternative embodiment include a lack of integration with other components of the invention and additional costs required to acquire configure and administer a commercially available requirements management system.

The fifth software application used in the preferred embodiment of the present invention referred to for convenience as simulator is a computer program that renders interactive representations of prospective computer applications by accepting requests from the user s browser interpreting the IRM composing an HTML response to the user s requests and communicating its response to the user s browser. This fifth application is also preferably written in Java language. Alternate embodiments of this fifth computer software application within the principles of the present invention could be written in any of the C C or Visual Basic languages.

The process embodied by the simulator is depicted in further detail in and described below. The simulator processes using a request response cycle similar to that of other conventional computer applications that interact with standard browsers. During the simulation process a user s browser generates several types of requests including but not limited to requests to display pages requests to display images and requests to process data entered by the user. These requests are referred to as a form submit requests. The simulator in turn composes a response in the form of an HTML page and sends this to the browser. This request response cycle is repeated and results in the interactive representation.

The simulator process starts when the simulator receives a request shown at from the user s browser. Upon receipt of the request the simulator determines if there is a valid session shown at for the specific user that made the request. If the user does not have a valid session the request is redirected at by the simulator component to the ION component where the user is authenticated to the system a session is initiated and the simulator process ends. In the present invention the term session refers to a set of variables stored in the server computer s memory and that contain information regarding a user and the user s interactions with the ION and or simulator components of the present invention. This information is maintained for a period between the receipt of an initial request from the user s browser and the termination of the session when the user has chosen to log off the system or when the session has been terminated due to exceeding the maximum time allowed for a session.

If the user has a valid session the simulator process begins to determine the type of request that has been received from the user by determining if an image was requested as shown at . If an image was not requested the process continues to determine if a page or decision was requested as shown at . Otherwise the process continues to process image request as shown at . Process image request retrieves the appropriate image stored with the IRM and returns it to the browser and enables the browser to present this image to the user. Typically this variant of request is communicated to the simulator after the simulator has already serviced requests for one or more pages. This is because the simulator s response to a page request may include one or more references to images that the browser will automatically request from the simulator upon receipt of the page. After returning an image the simulator process ends.

The simulator continues to ascertain the type of request by determining if a page or decision was requested as shown at . If a page or decision was requested the simulator process evaluates if a specific page was requested as described in the next paragraph and shown at . Otherwise it continues to ascertain the type of request by determining if a form was submitted as shown at .

If a page or decision was requested the simulator evaluates the request to determine if a specific page was contained in the request as shown at . If a specific page was not requested the simulator interprets this as a request for a list of the pages that exist in the current IRM and proceeds to find all pages in the current IRM. It then returns a list of them to the user s browser and ends processing.

If the simulator had determined that a specific page or decision was requested at the simulator continues by determining if the requested page can be found in the current IRM at . If the page cannot be found the simulator returns a page not found message to the browser at and ends processing. Otherwise the simulator proceeds to execute the control flow visitation algorithm shown at beginning at the specified page or decision. The control flow visitation algorithm as will be described in detail below proceeds to evaluate the IRM and accumulate HTML to be returned to the user s browser in the subsequent step return accumulated HTML to browser as shown at . The control flow visitation algorithm recursively collects all of the user interface components that are contained within the page and constructs HTML representing these components. If a decision is specified then the control flow visitation algorithm at first evaluates the decision to identify the correct page and then proceeds as described above.

After the control flow visitation algorithm has completed the simulator proceeds to return accumulated HTML to the browser and ends.

If a page or decision was not requested at the simulator continues to ascertain what type of request was submitted by determining if a form was submitted as shown at . If this is the case the simulator process continues to process form submit as shown at and described in regard to . The simulator extracts all values submitted in form and packages them into data tokens at and invokes the data flow visitation algorithm in push mode at . Upon completion of the data flow visitation algorithm the simulator determines if a page or decision has been requested at in connection with the form submit request and invokes the control flow visitation algorithm at for the page or decision. Upon completion of processing of the form submit the simulator returns accumulated HTML to browser as shown at and ends processing. If a form has not been submitted the process continues to row selection from dynamic table requested at .

Process row selection depicted at from a dynamic table is a specialized process implemented by the simulator and that functions to support the IRML primitive named dynamic table that is an advantageous feature of the best mode of the present invention. A dynamic table is an IRML primitive that can be used to emulate common behavior of computer applications wherein a list of data separated into rows is presented to a user and the user is allowed to select one of the rows for further processing. After the dynamic table has been presented to the user on a previous iteration of the simulator request response cycle the user may choose a row presented in the table that is then handled by this process. For example a proposed application may present a list of orders placed by a client or a list of reservations made by a frequent flyer. The proposed application user may then select one of these orders or reservations for further processing. The corresponding computer processing that would be necessary for the subject application to understand which order or reservation was selected by the proposed application user may be complicated and not intuitive. This feature of the simulator is advantageous because it handles this processing automatically by removing the necessity that it be specified in the IRM. Once the simulator has completed processing of the dynamic table row request at it returns accumulated HTML to the user s browser at otherwise it ends processing at .

The simulator repeats the process described above upon receiving additional requests from the browser until the user makes no more requests.

In general the preferred embodiment of the control flow visitation algorithm is a computer program based on a pattern found in conventional software designs and commonly known as a visitor pattern. It functions to construct the simulator s response to a request from a browser. This response appears in the browser in a manner similar to how it would appear in the completed proposed application. This response is composed of nested HTML tags which the browser uses to present a page to the user. The control flow visitation algorithm is an automated process that constructs this nested set of HTML tags based on the IRM.

Understanding the function of the control flow visitation algorithm is facilitated by understanding that the IRM is a collection of primitives and the relationships between and among them. In the context of the control flow visitation algorithm important relationships include those that designate the flow of data i.e. dataflow those that designate containment of user interface components i.e. containment those that designate references and those that designate the flow of the interactive representation i.e. control flow . Thus an IRM can be characterized or depicted as a series of circles representing primitives and arrows representing relationships. Such a depiction is presented and described in detail in regard to .

The control flow visitation algorithm begins processing at the primitive representing the page requested by the user shown at . The control flow visitation algorithm begins to accumulate HTML at this point by adding a tag that represents the beginning of a page into a temporary space used to accumulate HTML. The simulator process continues by examining the properties of the page primitive and appending additional HTML code to the temporary space based on these properties including for example the name of the page. The simulator then follows the containment relationships represented by the arrows between the page primitive and the primitive contained by the page in this case the form primitive shown at or similarly from page primitive to text primitive . The simulator then appends a tag representing the beginning of the form into the temporary space. The simulator then examines the properties of the form primitive and adds additional HTML codes to the temporary space. Continuing in its recursive process it then visits each of the contained primitives at and in order from left to right sequentially processing each primitive and adding more HTML codes to the temporary space. The primitives depicted at and have no containment arrows leading from them and therefore the simulator process recognizes these as tags. When processing tags the simulator performs several functions before appending HTML to the temporary area. For example the simulator determines if there are any data flow arrows pointing into the primitive. If so the simulator begins another process called the data flow visitation algorithm which will be described in detail below. In the case of a constant primitive the data flow visitation algorithm follows the arrow backwards to the constant primitive depicted at where it obtains the value of the constant and ends processing. The control flow visitation algorithm can then complete adding the necessary HTML code to present this constant value in the text input field specified by the text input primitive as shown at and append this HTML code to the temporary area. This tag processing continues to process the primitives shown at and .

After having processed all of the contained objects in the form primitive shown at the control flow visitation algorithm then returns to the form primitive itself. Because it has encountered this form primitive before the control flow visitation algorithm now appends closing HTML code to the temporary space indicating the end of the form. Similarly the control flow visitation algorithm returns to the page primitive at and appends the closing HTML code for the page to the temporary area. This temporary area is then returned to the process that called the control flow visitation algorithm and in general this accumulated HTML is returned to the user s browser.

The interactive representation experienced and seen by the user for this example is depicted in . In this example a page with two text input fields is shown.

While performing the process described above the control flow visitation algorithm assigns a unique cross reference number to a subset of the user interface component primitives that it encounters underlined labels 2 through 4 in the example of . When the simulator is operating in Meta Mode the control flow visitation algorithm automatically inserts HTML code into the temporary area that causes these cross reference numbers and their accompanying text to be displayed on the user s browser to the immediate right of each user interface component.

In general the preferred embodiment of the data flow visitation algorithm is a computer program based on the conventional visitor pattern much like the control flow visitor algorithm. It functions to provide a facility for the interactive representation to simulate the processing of data common in proposed applications.

The data flow visitation algorithm relies on a feature provided by the Music Client another software component of the present invention that has been previously described in which the IRM being executed by the simulator is kept in the memory of the computer on which the simulator and music client are running. The data flow visitation algorithm processes a subset of the primitives contained in the IRM and which are held in the computer memory and appends data records to this memory that represents the partial results of its computation. With respect to the preferred embodiment of the present invention these data records are referred to as tokens. Because they are intermediate results of the processing of a single request from the user s browser to the simulator tokens are only stored in memory and the music client is not used to store them in the music server. Tokens are stored in memory and associated to specific primitives. This relationship is referred to as tokens stored at a primitive. In the context of the present invention to cache a token means to store it temporarily in the computer memory at a particular primitive.

The data flow visitation algorithm begins processing when it is invoked by the simulator either from the control flow visitation algorithm as previously described or from the process form submit process shown in or the process row selection from dynamic table process also shown in . In the detailed description that follows it will be shown that the data flow visitation algorithm in several cases may also be invoked by itself. This is a common computer programming technique referred to as recursion as would be understood by an individual skilled in the art. For the purpose of the present invention recursion is defined as an algorithmic technique where a function in order to accomplish a task calls itself with some part of the task. This is also the definition found at the National Institute of Standards and Technology web site at the Dictionary of Algorithms and Data Structures DADS . The preferred embodiment of the simulator utilizes the advantageous recursion features inherent in the Java language.

At the time the data flow visitation algorithm is invoked it is directed to begin its processing at a specific primitive in the IRM and it is invoked in one of two modes referred to as push and pull with their meanings implied as each is individually described in detail below. In general the data flow visitation algorithm process moves data in the form of tokens entered by the user during simulation of the IRM as well as causing primitives of the class action to process the data. The data flow visitation algorithm moves the data along relationships between primitives called data flow relationships. Each data flow relationship can be thought of as an arrow connecting two primitives. When the data flow visitation algorithm is processing a primitive and needs to get data from a different primitive from which an arrow points the pull mode of the data flow visitation algorithm is used. When the data flow visitation algorithm has completed processing a primitive and needs to send this data along the data flow relationship arrows emanating from the processed primitive the push mode of the data flow visitation algorithm is used.

The push mode of processing of the data flow visitation algorithm is depicted at in . Beginning the process the data flow visitation algorithm evaluates what class of primitive it has been asked to process through a series of steps depicted at and . Primitive classes are described above. If it cannot identify the type of primitive it has been asked to process the data flow visitation algorithm returns an error at and ends processing.

If the data flow visitation algorithm has been asked to process a decision or tag primitive it temporarily caches the token at the current primitive shown at . In the context of the present invention to cache a token means to store it temporarily in the computer memory that also contains the IRM. After caching the token the process ends.

The data flow visitation algorithm may also be asked to process a flow label primitive at . To process a flow label primitive the data flow visitation algorithm first determines if there is a token already cached at the flow label primitive at step . Since the data flow visitation algorithm can be called multiple times in the processing of a single request from the user s browser to the simulator it is possible that the current primitive may have already been visited by a previous execution of the data flow visitation algorithm. This initial check performed by the data flow visitation algorithm when processing flow label primitives prevents duplicate tokens from being cached. If a token is already present the process ends otherwise the token is labeled with the name of the flow label primitive at and the token is cached for further processing by another execution of the data flow visitation algorithm at . The process then continues as the simulator examines the IRM to determine all data flow exits at . Data flow exits in the context of the current invention are primitives that have data flow relationships directed to them from the current primitive in the IRM. For each of the data flow exits that exist the data flow visitation algorithm process is invoked again.

If the data flow visitation algorithm has been asked to process an input tag primitive for example at or in or a container tag primitive the simulator checks to see if a token is currently cached at the primitive at . If not the data flow visitation algorithm process ends. If so at the data flow visitation algorithm process removes the token from the cache and proceeds to find all data flow exits at as described in detail previously. For example the primitives depicted at and both have a data flow exit to the primitive at via math add primitive in . Typically this processing of input tag primitives and containers occurs during the execution of the data flow visitation algorithm process when it is called from the process from submit step . Because step has already cached the data submitted by the user this process simply has the effect of advancing the tokens to the data flow exits that are related in the IRM to the primitive being processed.

If the data flow visitation algorithm has been asked to process an action primitive at the data flow visitation algorithm first determines if the action has already been executed at and if it has the data flow visitation algorithm ends processing. If the action has not yet been executed the data flow visitation algorithm caches the current token at the action primitive at step and proceeds to find all inputs to the action that have not yet had tokens stored at the primitive for them at step . Actions cannot be executed by the data flow visitation algorithm or simulator unless all of the needed inputs to the action have been cached at the action primitive by the data flow visitation algorithm therefore the data flow visitation algorithm evaluates all data flow inputs at step before continuing. In the context of the present invention data flow inputs refer to primitives that have data flow relationships directed to the current action primitive in the IRM. If no token is cached for one or more of the data flow inputs the process continues to step where the data flow visitation algorithm is invoked in pull mode to obtain the needed tokens. This step is bypassed if all necessary tokens are cached at the action primitive. The process continues by executing the action at step . Execution of the action is performed by placing all of the tokens that have been cached at the action primitive by the data flow visitation algorithm and invoking a java sub routine that handles the actual processing of the action. The behavior of each action primitive i.e. the behavior of its specific java sub routine is discussed in Table II. After the Java sub routine has completed processing the execute action step continues by collecting the data token s that has have resulted from the execution. This these data token s are then passed along for additional processing by the find all data flow exits step and subsequently by another invocation of the data flow visitation algorithm as was previously described in the context of processing flow label primitives.

If the data flow visitation algorithm has been asked to process a model reference at the data flow visitation algorithm first caches the current token at the model reference primitive . Similar to the processing for actions described in detail above the data flow visitation algorithm evaluates if all data flow inputs for the model reference have cached tokens at and . If so the process ends. Otherwise the data flow visitation algorithm is invoked in pull mode for each of the primitives for which no token was cached. Note that the data flow visitation algorithm does not cause the primitive referenced by the model reference primitive to be executed this invocation is left to the control flow visitor process described in detail above.

The other mode of processing embodied in the data flow visitation algorithm is the pull mode which is depicted at in . To begin the pull process the data flow visitation algorithm evaluates what class of primitive it has been asked to process through a series of steps depicted at and . Primitive classes are shown in the first column of Tables II V. If it cannot identify the type of primitive it has been asked to process the data flow visitation algorithm returns an error at and ends processing.

If the data flow visitation algorithm operating in pull mode has been asked to process a constant primitive at the data flow visitation algorithm examines the constant primitive and extracts the value s stored with the constant primitive in the IRM at step . These values are then placed in a token which is returned at to the process that invoked the data flow visitation algorithm in pull mode. The process then ends.

If the data flow visitation algorithm operating in pull mode has been asked to process a flow label primitive at the data flow visitation algorithm first determines if there is a token already cached at the flow label primitive at step . If there is a token cached it is returned at to the process that invoked the data flow visitation algorithm in pull mode. The process then ends. If there is not token cached the process continues by invoking the data flow visitation algorithm in pull mode at for the data flow input associated with the current flow label primitive. Note that IRML connection rules as detailed in Tables IV and V ensure that only one data flow input will be present. When the data flow visitation algorithm process invoked at completes the returned token is labeled with the name of the data flow label primitive at . The data flow visitation algorithm continues by caching the returned and named token at the data flow label primitive at and finding all data flow exits as was previously described at . The data flow visitation algorithm is then invoked in push mode at . After the data flow visitation algorithm invoked at completes the token cached at is returned to the process that called the data flow visitation algorithm in pull mode and the data flow visitation algorithm process ends.

If the data flow visitation algorithm operating in pull mode has been asked to process an input tag primitive at the data flow visitation algorithm first determines if a token is cached at the input tag primitive at . If no token is cached an empty token i.e. a token containing no data is returned to the process that invoked the data flow visitation algorithm depicted at . If a cached token is found at the input tag primitive it is removed from the cache at the input tag in step returned to the calling process at and the data flow visitation algorithm process ends.

If the data flow visitation algorithm process operating in pull mode has been asked to process an action primitive at the data flow visitation algorithm first determines last primitive visited by the process that invoked the data flow visitation algorithm in pull mode as depicted at . The last visited primitive s identifier referred to as the origin is stored temporarily at step to allow the correct token to be returned to the process that invoked the data flow visitation algorithm in the later step which shall be described in detail below. The process continues by finding all data flow inputs to the action primitive being processed for which a token has not been cached which is depicted at step . If the data flow visitation algorithm determines that all data flow inputs have not already been cached at it invokes the data flow visitation algorithm in pull mode for each of the missing tokens at . After the data flow visitation algorithm invoked at has returned the necessary token s or if the data flow visitation algorithm had determined that all data flow inputs had already been cached at the data flow visitation algorithm continues to step . In step the data flow visitation algorithm determines if the action primitive it has been asked to process has already been executed. If the action has already been executed the data flow visitation algorithm using the identifier stored in step returns the appropriate token for the origin at step to the process that invoked the data flow visitation algorithm in pull mode. If the action has not been executed the data flow visitation algorithm process continues to execute action. Execution of the action is performed by placing all of the tokens that have been cached at the action primitive by the data flow visitation algorithm and invoking a java sub routine that handles the actual processing of the action. The behavior of each action primitive i.e. the behavior of its specific java sub routine is discussed in Table II. After the Java sub routine has completed processing the execute action step continues by collecting the data token s that has have resulted from the execution. This these data token s are then passed along for additional processing by the find all data flow exits step and subsequently by another invocation of the data flow visitation algorithm in push mode at . After the invocation of the data flow visitation algorithm at has completed the process proceeds to return the appropriate token to the process that invoked the data flow visitation algorithm at as was previously described.

If the data flow visitation algorithm operating in pull mode has been asked to process a model reference primitive as depicted at the data flow visitation algorithm determines the origin for the request at as previously described in the context of processing action primitives. After completing step the data flow visitation algorithm determines if the current model reference primitive has already been executed and if so returns the appropriate token for the origin at step which is identical to the previously described step . The data flow visitation algorithm process then ends. If the data flow visitation algorithm determines that the model reference primitive has not been executed at it proceeds to collect the necessary inputs to the action at steps and . The processing performed by these steps is identical to that previously described for steps and respectively. After step has been completed the data flow visitation algorithm returns an empty token to the process that had called it in pull mode and ends processing.

With reference to use of the present invention will be described particularly in regard to the preferred embodiment as described above. In this regard it is the people who participate in the application definition process by managing requirements building the IRM or validating an IR of the application to whom the following description of the invention is directed. Also this description of how to use the invention is presented in two sections the first section directed to the interactive network online interface and the second directed to the interactive representation model creation and modification interface.

Referring to the web based interface application and simulator application of the present invention is installed on server and communicates with a browser . Each user accesses the interface and or simulator applications to manage the requirements and access the interactive representation sometimes referred to as the simulation for a prospective application. In accordance with terms accepted in the art individual screens presented by the web based interface are sometimes referred to as pages. 

The web interface of the present invention is accessed in a conventional fashion through a convention web browser that has access to a server that is hosting the software of the present invention. After completing conventional log on procedures the user will be presented with a default screen sometimes referred to as a dashboard similar to that shown in . A typical screen will have a main menu an application selector and a logout button.

The dashboard contains filtered requirement lists for example My Requests My Discussions and a filtered list of tasks labeled My Tasks and shown at as shown in . The dashboard also contains search functionality that allows the user to search the requirements repository for a word phrase or requirement identifier. The requirements listed in each of the filter sections on the dashboard are ordered with the most recently updated requirement at the top. To view all the requirements in a list the name of the list is clicked for example My Requests . To collapse the requirements list the down arrow link is clicked for example arrow for the My Requirements list. A second click on the arrow is used to expand the requirements list.

The repository may be searched through use of the search feature located at the top of the dashboard. The word phrase or identifier for the requirement s for the desired search is typed and one of the radio buttons any all phrase or identifier that corresponds to the type of search criteria desired is clicked. The server will then present a page not shown containing the results of the search.

There are two ways to create requirements in the repository through the web based interface. One way described in Adding Requirements in Meta mode below allows users to add requirements in context during simulation operating in Meta mode. Alternatively users can add requirements to the repository by using the Requirements Create Requirements main menu option in conventional fashion to create a new requirement. Similarly users can modify existing requirements in the repository by using the Requirements Modify Requirement main menu option in conventional fashion. The screen or page used to create or modify a requirement is sometimes referred to as the requirement edit page. In addition to the name and text description of the requirement the attributes listed in Table VI below can be assigned to the requirement. The table also describes the meaning of the attribute and its allowable values.

Users acting in a project or team management capacity can use tasks to manage and track the activities and responsibilities of individuals involved in the process of collecting and validating requirements for the prospective application. A task represents a unit of work that may have a start date end date assignee and a list of associated requirements. There are two ways to create a task using the Tasks Create Task main menu option where by the user can create an isolated task that has no association to any requirement or defect report and using the Create Task button on the requirement edit or defect report edit pages whereby the user can create a task that is automatically associated to the requirement or defect report being edited. In either case the create task page is presented which allows the user to record the name description and other attributes for the task. Similarly users can modify existing tasks in the repository by using the Tasks Modify Task main menu option in conventional fashion. The screen or page used to create or modify a requirement is sometimes referred to as the task edit page. In addition to a task name and description the following Table VII lists task attributes available in the preferred embodiment describes attributes and the range of acceptable values for these attributes.

There are two ways to create a defect report using the Defect Create Defect main menu option whereby the user can create an isolated defect that has no association to any other requirement and using the Create DR button on the requirement edit page whereby the user can create a defect that is automatically associated to the requirement being edited. In either case the create defect report page is presented which allows the user to record the name description and attributes for the defect report. Similarly users can modify existing defect reports in the repository by using the Requirements Modify Requirement main menu option in conventional fashion. The screen or page used to create or modify a defect report is sometimes referred to as the defect report edit page. The attributes that can be entered for a defect report are listed in Table VIII below along with the description of the attribute and the range of allowable values for the attributes.

Requirements and defect reports can be organized into appropriate hierarchical classifications for additional context and organization in conventional fashion. An advantageous feature of the current invention is that a requirement may be designated to more than one classification simultaneously. Classifications can be used organize lists of requirements on pages and printed reports in conventional fashion.

Notifications refers to a feature that allows users to receive email messages when a requirement defect report or task is changed. These email messages which are automatically generated by the invention include the information previously recorded for the requirement the new information recorded and the user that made the change. A user may be added to the notification list when creating or editing a requirement defect report or task by selecting the user names that should be notified from a list of the users with access to the system that are not currently designated to receive notifications and moving it to the list of users that are currently designated to receive notifications. Users names may also be moved from the list of users that are currently designated to receive notifications and moved to the list of users with access to the system that are not designated to receive notifications.

Users may designate a list of requirements that are related to a particular requirement by selecting said requirements from a list of the requirements in the repository in conventional fashion. Similarly relationships between and among requirements defect reports and tasks can be established.

A complete change history is maintained automatically for every requirement change request and defect report in the repository. To view the change history the user opens the requirement change request or defect report in edit mode clicks on the History tab. A list of all changes the modifying user and the modification dates is then displayed. Optionally the Select View drop down to filter may be used to filter the change history by a particular type of change for example to show only changes to the status attribute.

The Discussion feature allows users to converse regarding a particular requirement defect report or change request in the form of an on line threaded discussion as would be understood by an individual skilled in the art. The record of such a conversation are stored in the repository so they can be referred to at any point for decisions opinions and general information submitted by the discussion participants.

Attachments allow you to add supporting documents to the repository. This can be useful for example when a diagram clarifies a requirement or a screen image supports a defect report. To add an attachment to a requirement or defect report 

Once the file has been uploaded it is part of the attachment pool in the repository that contains all the files that have been uploaded for the current prospective application.

Alternatively a requirement can be tied to any file that exists in the attachment pool instead of uploading the same file twice. This is useful if the user has a number of requirements that are supported by one document.

If a requirement has an attachment then an attachment icon will be displayed on the Attachment tab. Typically the icon will appear to be a sheet of paper with a corner folded over and a paperclip on the top of the paper.

Existing requirements and defect reports can be viewed in a variety of conventional manners using the Requirement View Requirements main menu option Tasks can be viewed in a similar conventional fashion using the Task View Tasks main menu option. The View Requirements page is organized into two major areas the filter area and the list area. The filter area contains a set of conventional filters that allow the user to view a subset of all the requirements and defect reports in the repository. The list area contains the subset of the requirements or defect reports. Once any filter or variety thereof is selected pressing the Go button will apply the filters and refresh the list. The format of the requirement list can be presented in a variety of fashions by selecting a format from the drop down list named Format . The preferred options are described in Table IX below.

Custom Filters define a predefined customizable set of conditions that can quickly filter the list as desired. They can be used to apply delete or edit an existing custom filter as well as create a new custom filter. These actions are accomplished in a conventional fashion and the selection of particular filter criteria is considered to be within the ordinary skill of the art.

Quick filters allow the user to apply and combine attribute based filters to the requirement list. When multiple quick filters are selected the result set includes all requirements that meet ALL of the specified filter criteria. For example if the Requested By quick filter is set to used and the Status quick filter is set to approved then all the results shown in the requirements will be requested by user 1 and approved in status.

The classification filter allows the user to filter out requirements that are not contained by the classification selected in the classification filter drop down. To filter by classification the user selects the classification that contains the requirements desired and their requirements will be recursively included in the list.

The search filter allows the user to search the entire repository or the filtered requirements currently presented on the list for a word phrase or requirement identifier. To search for a requirement the word phrase or identifier of the requirement desired is typed in the search criteria prompt. Then the radio button that represents type of search criteria being used is clicked and the Go button is clicked to execute the search. When the page is refreshed only requirements that contain the specified search criteria are included in the list.

The list area displays a set of requirements that meet the filter criteria specified in the Filter Area of the View Requirements page. The requirements are organized by classification and formatted according to the Format drop down in the filter area.

The default view for the lists area shows a list of the classifications that contain requirements that meet the filter criteria. Each classification is collapsed by default. To expand a classification and examine its contents the user clicks on the symbol to the left of the classification name. Alternatively the user may click the Expand All button to expand all collapsed classifications. Similarly to collapse a classification the symbol is clicked or the Collapse All button is used.

Requirements designated to the Trash classification are automatically filtered out of all requirements lists so they are essentially stored in a deleted state. To remove a requirement out of the trash open the Trash classification in the View requirements list find the requirement to revive and use the classification drop down to put the requirement into a classification other than Trash.

The reporting feature of the preferred embodiment includes two pre built reporting templates that the user can use to produce electronic reports of data contained in the repository that can be subsequently printed the Functional Specification Report sometimes referred to as the FSR and the Requirements Inventory Report sometimes referred to as the RIR. These reports are described in detail below.

By default both reports draw on the data that exists in the repository at the time report is generated. However the user can produce historical reports using by specifying a previously created version tag as described below.

With reference to the Functional Specification Report contains at least one image of a page from the interactive representation rendered by the simulator depicted in at which includes reference numbers and associated with respective user interface elements. The image is identical to what a user would see when executing the interactive representation using the simulator component as previously described in Meta mode also as previously described. In addition the functional specification report contains with reference to a list of the requirements associated with the page presented at and or the user interface components contained therein. Only requirements that are associated to the pages included in the report will be printed in the FSR. Additionally and with reference to the FSR may optionally contain a summarization of the control flow connections that originate from the primitives contained on the page s included in the report at . This section includes the name and an icon indicating the type of the primitive from which the control flow connection originates and the name and an icon indicating type of the primitive at which the control flow terminates. If the control flow terminates at a decision this section of the report shows the name of the decision the labels on its branches e.g. T F 0 1 2 3 and the name and an icon representing the type of the primitive at which the control flow from these branches terminate. Additionally the FSR shows the name of all decision primitives and pages that have contained primitives with control flow connections terminating at the page that is the subject of the report along with an icon indicating their type.

Furthermore with reference to the FSR optionally includes a list of all primitives contained on the page that have data flow connections terminating at them at along with primitives name an icon indicating the type of primitive the data flow label for the connection an icon representing the type of the primitive that is the source of the data flow connection and the name of the primitive that is the source of the data flow connection.

Furthermore with reference to the FSR optionally includes a list of primitives contained on the page that have data flow connections originating from them at along with an icon indication the type of the primitive. In addition the name of the connecting data flow s label and the name and an icon representing the type of the primitive at which the data flow terminates. If the data flow terminates at a primitive and that primitive has data flow connections originating from it the reports continues listing connection information with new primitives starting a new line until all primitives that are connected by data flow are encountered and listed on the report. In the preferred embodiment the studio component includes a feature that would prevent users from creating an IRM that would cause the FSR s process to experience an endless loop. Furthermore in practice most regions of interconnected dataflow are not more than 5 levels deep.

These report sections are advantageous features of the present invention because they communicate the requirements in the context of static images extracted from the interactive representation as well as control and data flow connection information that is useful to the individuals that will be designing and programming the prospective application.

In the preferred embodiment the FSR is delivered as an HTML document that can be displayed and printed by a browser. To generate the FSR 

The Requirement Inventory Report RIR contains the set of requirements that meet filters applied on the report parameter page. The report is produced in PDF format making it easy to distribute. To generate the Requirement Inventory Report 

The server will present the RIR report in PDF format in a new browser window. shows a sample of the RIR content.

Version tags are bookmarks in the history of an application simulator application. The reporting feature can use version tags to generate historical reports. To generate a version tag 

Reports can now be optionally run against the version tag to produce historical views of the database.

As the project team iteratively builds the IRM in concert with the requirement data for a proposed application all users with access to the application may view and validate the simulation for that proposed application through the online interface. To simulate the proposed application the menu option Simulate Simulate from the main menu is selected. The system will display a browser window containing a list of pages in the IRM. Clicking on the name of a page initiates a simulation session. The interactive representation of proposed application can be viewed in one of two modes Clean or Meta. The buttons at the top of the simulation page can be used to toggle between Clean and Meta mode.

With reference to The Meta mode shows the simulated page with superscript enumerations uniquely identifying all the visible user interface components in the simulation area . The Meta mode also includes an add requirement area that allows users to add and view requirements that describe the simulated page without needing to return to the create requirements page and a list of the requirements associated with the visible user interface components at enumerated with corresponding numbers.

Users can add requirements to the repository using the Add Requirement section of the Meta mode page. To add a requirement 

All requirements that are currently associated to the simulated page or elements on the simulated page are shown in a list below the simulated page . The requirements are organized into groups labeled according to the element to which they are associated. split into for clearer publication shows the simulation in Meta mode and highlights the relationship between the requirements and their associated user interface components. For example line highlights the relationship between the list page with superscript and the requirement numbered . Similarly for example line highlights the association between the user interface element superscripted with the requirement number . Other user interface elements in are similarly labeled with superscripts that indicate requirements related to the respective user interface elements.

The Clean mode allows users to view the simulated application in its purest form and an example screen is shown in . The buttons and in the upper right area of the simulation window allow the user to toggle between clean mode and Meta mode . Clean mode displays the pure prototype HTML without any superscripts or requirement data. This allows users to get a more realistic feel for the application being defined.

The simulcastor component allows multiple users to follow a leading user who is exiting an interactive representation model. Any user may lead or follow a simulcast session. To start and lead a simulcast session 

The Studio interface allows the user to build the proposed application s interactive representation that is iteratively validated through simulation. The Studio client is started by double clicking on the Studio icon on the client computer. When the login window appears the user may or must provide the data listed in Table X below before beginning a Studio session.

Primitives are the building blocks that allow the user to rapidly build the IRM. In general primitives can be added to the IRM in three different ways depending on user preference 

To add primitives from the toolbar two options are available. The drag and drop approach allows the user to drag an element from the toolbar area and drop it at the desired location in the IRM. The insertion point approach allows the user to place the insertion point where the user wants the element to be located on the whiteboard The raised buttons on the toolbar that represent the element wanted are simply clicked to add.

Pages are special primitives. They are used throughout the application as references and organizational structures. Pages are top level primitives They can only be inserted directly on the gray area of the whiteboard. The Page icon is typically an illustration of a sheet of paper not shown in vertical orientation and with a corner folded over.

User interface primitives are pages and any other primitives as identified in Table II above are primitives that can be contained in a page. User interface primitives are shown as Toolbar Icons. In general a user can add a primitive to a page by following the process described in the adding primitives section. However some user interface tag primitives e.g. the select primitive text input primitive etc. must be contained by the form primitive.

The radio button primitive allows the simulation user to pick one value from a set of options. The options are defined by the first data flow connected to the radio button primitive. Additionally the second data flow connected to the radio button primitive can be used to define the radio button option that is selected by default when the simulator presents the page. To create a radio button set 

If there is only one data flow input for the radio button primitive then by default no option will be selected when the page is displayed in simulation. However the user can use a second data flow input to define the default value. If the value of the second data flow matches one of the values in the first data flow input then that value will be selected be default. If the value of the second data flow does NOT match one of the values in the first data flow input then the second data flow value will be added to the radio button set and set as the default.

The select primitive allows the user to add drop down lists also known as selects to the IRM Like a radio button primitive the select primitive allows the simulation user to pick one value from a set of options. The list of options available to the simulation user is defined by the first data flow input connected to the primitive. The second optional data flow input connected to the primitive can be used to set a default value that appears when the page containing the select primitive is simulated. To add a select primitive 

If there is only one data flow input line connected to the select primitive then by default the first value in the data flow input e.g. the first value listed in the Constant will be the default value when the drop down is displayed in simulation. However the user can use a second data flow input to define a different default value. If the value of the second data flow matches one of the values in the first data flow input then that value will be selected be default. If the value of the second data flow does NOT match one of the values in the first data flow input then the second data flow value will be added to the select options and set as the default.

Button primitives allow the user to represent HTML button inputs. They primarily exist to submit form data and allow page navigation. To create a button 

Conditional HTML CHTML primitives allow the user to add dynamic presentation logic to the interactive representation. Depending on the single data flow input the CHTML displays one of its numerous branches. Similar to navigation decisions CHTML primitives can exist in Boolean or integer mode. In Boolean mode the CHTML logic is based on the existence of incoming data flow. In integer mode the CHTML logic is based on the value of the incoming data flow. A CHTML primitive is in Boolean mode until a third branch has been added at which time the primitive is transformed automatically to integer mode. To create display logic 

The interactive representation IRM now includes conditional HTML logic that displays the T branch if the data flow input contains any value other than 0 zero . Otherwise the F branch is displayed.

The user can turn a CHTML primitive into integer mode to IRM more than two display alternatives. To create an integer mode CHTML primitive 

The interactive representation model IRM now includes display logic that shows one of numerous branches depending on the VALUE of the incoming data flow. If the value of the data flow is an integer value corresponding to one of the CHTML branches then that branch will be displayed in simulation. If the value is null 0 zero or anything else not represented by the CHTML branches then the 0 zero branch will be displayed by default.

Dynamic Table primitives allow the user to create interactive representations of lists of data typically database driven lists. In simulation a dynamic table primitive appears as a table that contains one row for each data token or row passed to it during the processing of the simulator. The column names shown in the interactive representation and the data to be displayed from each of the tokens of the dynamic table are defined by the primitives placed in the dynamic table.

The data tokens that are displayed in a dynamic table typically come from a several actions related to each other using data flow. Typically these actions are a find and unpack action chain. The data flow outputs from the unpack action usually flow into the primitives contained in the dynamic table. To create a dynamic table 

Put one primitive into the dynamic table to represent each column that should appear in the interactive representation.

Connect data flow from an unpack action to one or more of the primitives contained in the dynamic table.

Dynamic table columns may be designated as sources of control flow allowing simulation users to click on a link in a row of data to navigate to another page as shown in . When navigation flow is established from a primitive in a dynamic table that link will be present on every row in the simulated table. Dynamic tables also have a specialized feature that allows the user to IRM simulate the behavior of a subject application wherein a data token is selected from a dynamic table. When a user clicks on a link in a dynamic table the data token represented by the row containing the link is passed out of the dynamic table as output data flow and used in subsequent processing.

Furthermore dynamic tables can be used for batched updates. This feature allows the user to simulate a common function of subject applications wherein a editable list of data tokens is presented. To add this functionality to the IRM the dynamic table must be contained in a form primitive and the dynamic table receive data flow input from an unpack action. Furthermore the primitives contained within the dynamic table must be of the class user interface components input tags. During simulation when a button primitive that is contained in the same form as the dynamic table is clicked all data tokens containing the values entered by the simulation user are submitted to the simulator for processing. Typically in the context of using dynamic table for batched updates the contained primitives in the dynamic table are each related to an update action primitive while the origin of the set of data tokens is related to the first input of the update action primitive. The specialized dynamic table processing in the simulator ensures that the appropriate data token s is are updated by the update action primitive. A typical usage of a dynamic table in this respect is shown in

The image primitive allows the user to add images to the interactive representation. The user can specify the source file for the image and connect the image to other primitives with control flow. To add an image to the IRM 

As previously described action primitives define how data will be transformed derived stored retrieved sorted or otherwise manipulated by the interactive representation. In the preferred embodiment actions include typical ways that computer systems manipulate data and are not specific to any particular computer programming language. The example illustrated in shows the use of a text.add action. The text.add action appends each of its inputs to each other resulting in a single string containing the characters found in its inputs. Its function is similar to that of a concatenation operator found in conventional programming languages. In this case the text.add action is being used to concatenate the first name provided by the simulation user with a space and the last name also supplied by the user during simulation. The inputs to the action in this example are the data flow connections labeled firstName and lastName originating from text input primitives labeled fnameInput and InameInput respectively. When the user simulates the page labeled My Page the page containing the text input primitives labeled fnameInput and InameInput is presented to the user whereupon they may enter values into each of these fields and click the button primitive labeled Go Button. After the simulator completes processing the form submit that was triggered when the user clicked the button the values that were entered by the user are passed in the form of data tokens to the text.add action as described above. The text.add primitive executes its internal concatenation routine and returns a data token labeled fullName. Then the page labeled My Page is redisplayed with the computed full name displayed at the text field labeled full name. 

Decisions define the conditional execution of other primitives. In the preferred embodiment decisions function in a manner similar to that of IF . . . THEN and CASE statements found in conventional computer languages. Alternatively decisions could be based on other conditional or branching structures found in conventional computer languages or derived from common behaviors found in conventional computer applications.

Decisions process in either Boolean or integer modes depending on the number of control flow outputs that are connected to them int the IRM. A decision with less than three control flow outputs evaluates in Boolean mode. When connecting the control flow outputs the first control flow connection made by the user designates the path of processing if the boolean data token it receives from its input data flow has the value of False whereas the second connection made by the user designates the path of processing if the data token it receives from its input data flow has the value of True. The example illustrated in shows a decision named Check Login Status that evaluates based on whether or not a profile data token is available in the session as follows 

If there is any profile data object in session then the decision evaluates to true and the simulator s processing follows the T branch and hence the My Account Page constructed by the simulator and returned to the user for display. If there is no profile data token in session then the decision evaluates to false and the simulator s processing follows the F branch and hence the Login Page is displayed.

A decision with three or more control flow outputs evaluates in integer mode. An integer navigation decision evaluates on the integer value of the data flow input. If the value of the data flow input is null or anything other than the integers specified by navigation flow output labels then the navigation flow defaults to follow the 0 branch. The example illustrated in shows a decision named access level check that evaluates based on the access Level data token of the profile data token stored in session as follows 

If the access level data token contains a to 0 1 or 2 then the simulator will present the pages labeled Access Level Zero Access Level One or the Access Level Two respectively.

Interactive representation Flow filters help control the whiteboard area by allowing the user to show and hide various interactive representation primitives and flow lines. Model filters can be applied to the entire whiteboard using the options available in the view main menu option. The user can also apply filters to selected primitives using filter buttons in the toolbar area with six such buttons included in the preferred embodiment having the names and functions listed in Table XI below. This allows the user to show and hide flow lines and primitives that directly related to the selected primitives. To apply the filters available in the toolbar 

As an interactive representation model grows the value of whiteboard real estate increases. Collapsing and expanding containers allows the user to minimize the amount of whiteboard space occupied by the user s pages. To collapse a container 

Double click on a container name. This collapses an expanded container. Collapsed containers only display their italicized primitive name. The contents of the container and the flow lines leading in and out of the container are hidden from the whiteboard view.

Double clicking on the italicized name of a collapsed container will expand the container to its previous state showing all of its contents.

Similar to collapsing and expanding containers any interactive representation primitives can be suppressed from the whiteboard view using the show and hide options available in the right click menu. To hide a primitive right click on the element to hide and select Hide from the menu options. Whenever a container directly contains a hidden primitives the container name becomes italicized. Double clicking on an italicized primitives name exposes its hidden relationships. Additionally the user can select Show All from the View main menu option to show all hidden primitives across the entire whiteboard.

The user can search the whiteboard area to find primitives based on name. To find an element in the whiteboard 

When a primitive is locked the user can view the primitives and its properties but can t modify it. The user who locked the primitives is allowed to unlock it. However if another user locked the primitives then only that may unlock it. Locking and unlocking are applied recursively to containers. Therefore if a user locks a container primitive for example a table form or page all the contents of that container are also locked. The same rule applies to the unlock operation except that primitives that were locked by another user will remain locked. To lock a primitive 

Selecting multiple primitives allows the user to apply most whiteboard operations for example copy move and hide or to edit primitives properties simultaneously. To select multiple primitives on the whiteboard the user can use the lasso or Ctrl left click. Use the lasso to select multiple primitives by left clicking on the gray area of the whiteboard and dragging the mouse to create a rectangle that contains the desired primitives. Alternatively hold down the Ctrl key while clicking on the primitives to be selected.

The user may quickly scroll the whiteboard coordinates to focus on a particular page by using the center on feature. To center on a page 

The user can use the Simulate toolbar button or the right click menu to simulate a particular page from the Studio application. To use the toolbar 

Properties allow the user to control the details of any primitives. The property editor allows the user to adjust these properties making the interactive representation model more realistic. The property editor pane is displayed on the right side of the Studio application window. The user can drag the left border to adjust the width. When a primitive in the whiteboard is selected the properties for that element will be displayed in the property editor pane. If the user would rather use the property editor pop up F7 is pressed to toggle between pane and pop up modes. In pop up mode the user can access the properties for a primitive by selecting the Properties option from the right click menu or by shift right clicking on a primitive as shown in .

With reference to the user can use the project browser to access the list of requirements and the interactive representation model pages for the current application. The tabs at the top of the project browser can be used to switch between lists. The user can use F5 to toggle the project browser between on and off. Common activities executed in the project browser area include 

Centering the Whiteboard on a Page from the Project Browser To center the whiteboard on a particular page 

A requirement is typically associated to a primitive when the requirement describes a needed or desired behavior of the subject application that the primitive represents in the interactive representation model. This association controls the presentation of requirements in the simulation Meta mode as well as their inclusion and placement on the functional specification report. This association is reflected on both the Meta mode page and the functional specification report through the use of automatically generated superscript numbers as was previously described. To create an association between a requirement and a primitive 

The whiteboard will highlight and center on the first primitive that is associated to the requirement. If there is more than one primitives associated to the selected requirement pressing F3 will find find next .

The filters under the List main menu option allow the user to filter the requirement list according to the Modeled attribute. To filter out requirements that are not modeled 

While the present invention has been described in connection with what is presently considered to be the most practical and preferred embodiments it is to be understood that the invention is not to be limited to the disclosed embodiments but to the contrary is intended to cover various modifications and equivalent arrangements included within the spirit of the invention which will be set forth in claims in a corresponding utility application and to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structures.

