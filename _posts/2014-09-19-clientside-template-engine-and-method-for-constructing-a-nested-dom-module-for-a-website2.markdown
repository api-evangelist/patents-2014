---

title: Client-side template engine and method for constructing a nested DOM module for a website
abstract: A method in a client web browser for constructing a nested Document Object Model (DOM) module for a website. The module includes a module template, which includes tags to be replaced with data, and a module Driver, which includes functional code for creating a nested data structure. A client-side templating engine retrieves data from a data source that includes data for populating the tags and data for creating a plurality of data blocks for the nested data structure. The templating engine populates the tags in the module template with the data for the tags, and the module Driver sequentially creates the data blocks using the data for creating the data blocks. Upon completion of each data block, the module Driver appends the completed data block to the module template to create the nested data structure. The completed module includes the template with populated tags and the nested data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09646103&OS=09646103&RS=09646103
owner: MyMojo Corporation
number: 09646103
owner_city: McKinney
owner_country: US
publication_date: 20140919
---
This application is a Continuation in Part of U.S. patent application Ser. No. 14 478 132 filed Sep. 5 2014 which is a Continuation in Part of U.S. patent application Ser. No. 14 458 347 filed Aug. 13 2014 which is a Continuation in Part of U.S. patent application Ser. No. 14 328 630 filed Jul. 10 2014 the disclosures of which are fully incorporated herein by reference.

The present disclosure relates to a client side templating engine and method for constructing a nested Document Object Model DOM module for a website.

A website document which is designed to be viewed in a web browser comprises HyperText Markup Language HTML markup and various assets which are parsed by the web browser and laid out to form a visible web page. The assets include images Cascading Style Sheet CSS documents JavaScript documents as well as any embedded media. The common practice and industry standard is to load the HTML of the page and then parse other assets to alter the layout of that HTML place images as needed and set listeners triggers on various Document Object Model DOM elements in order to react to user input. The DOM is an Application Programming Interface API for valid HTML and well formed XML documents. It defines the logical structure of documents and the way a document or data is accessed and manipulated. This procedure typically causes the website to be parsed as a monolithic document with JavaScript and CSS resources loaded either in the header of the DOM and or near the bottom so that scripts can attach listeners to or otherwise alter referenced DOM elements.

In the case of a conventional static website when the user clicks on a link for example a link from a home page to a sub page of the website the browser destroys the DOM instance for the home page and unloads it from memory. The browser then sends an HTTP request to the server requesting information from the server for the sub page. The browser then creates a new DOM instance for the sub page. Thereafter this process of downloading resources creating a new DOM instance and then destroying the DOM instance and starting over is repeated for each new page requested by the user.

At step the browser interprets and executes the JavaScript code and displays the somesite.com home page to the user. At step the user browses the home page and at step attempts to view content that was not included in the original content data received from the server. For example the user may click on a link to a sub page of the somesite.com website. In response the browser destroys the DOM instance for the home page and unloads it from memory at step . At step the browser then sends an HTTP request to the server requesting information from the server for the sub page of somesite.com. The process then repeats with the browser creating a new DOM instance for the sub page. Thereafter this process of downloading resources creating a new DOM instance and then destroying the DOM instance and starting over is repeated for each new page requested by the user.

In order to break the monolithic nature of a website and cause the content to be delivered in a modular fashion a templating system is often used. In such a system reusable HTML markup code is used as a template and a data source is used to populate various portions of the template before being rendered as needed within the webpage. There are basically two types of templating systems those that run on the server side and those that run on the client side. In both instances a data source is used to populate various fields within an HTML template and the resulting HTML code is returned to the web browser for display.

Server side templating engines separate presentation development from data modeling and business logic development and provide a code base that is easier to maintain and change as needed. Server side templating engines also allow for HTML template code to be reused which reduces the amount of code that has to be written which in turn reduces the chances for bugs or breaking functionality when changes are made. However server side templating engines return full HTML documents to the client and much of the HTML being transferred in the response from the server is likely to be duplicated blocks of code with different values in the fields. For example the following HTML is repeated three times with different values 

The HTML for each element is a simple tag group and it is repeated with different first names inserted. However because the HTML was rendered in the server side code the entire string of HTML code is sent to the client. In this small example the amount of code is negligible. However on large websites with extremely large numbers of repeating objects this is very inefficient and requires much more bandwidth than should be necessary.

Client side templates send a copy of the template to the client s browser along with structured data to serve as a data source and the template is populated with JavaScript in the browser. This method greatly reduces bandwidth usage between the client and server on sites that have a large amount of content with duplicated formatting.

Client side templates are typically managed by templating engines that are written in JavaScript. Therefore they run within the JavaScript virtual machine built into the web browser. In this scenario only one copy of the template is sent in the response from the web server along with a string of structured data to be used for populating the template. The templating engine in the web browser is then called in JavaScript code within the document to parse the data source replace the tags appropriately within the template and then render the template as many times as needed within the browser.

Most importantly however is the fact that this is the total amount of code that would be required to be sent in the web server response and the data string could be sent in separate calls to the server as needed.

Thus using client side templates provides a large decrease in bandwidth required for a large website containing several blocks of repeated markup sections. Additionally since the HTML template is already loaded into the browser additional calls to the server for more data can be made asynchronously to populate a site with fresh content or additional content in response to time passing or user interaction of the page.

Client side templating engines are typically written in JavaScript and are available with open source as well as commercial licensing. While they produce the advantages stated above none are as robust as their server side counterparts with regard to nesting embedded logic and the capability to pass complex data structures.

This method of programming allows for reuse of presentation mark up code HTML and separates the data from the presentation for maintainability and readability of the code. However when scaled to larger sites performance degrades quickly because the compilation of templates and the bloat in the third party templating engine library is expensive in terms of processing resources. Additionally the excess polling problem mentioned previously is not addressed. Once the template is compiled values are replaced and HTML is generated the JavaScript must search the DOM for the correct element to populate with the results. Again this causes increasingly poor performance as the size of the site grows and the number of DOM elements increases. The possibility of class collisions also still exists.

When building an interactive web application client side code written in JavaScript is typically used to attach event listeners onto DOM elements run specific callback functions when those events are triggered and manipulate the DOM elements as necessary to provide feedback for user interaction. In all but the smallest and simplest applications it is often necessary to include more than one script tag in the DOM which includes the JavaScript code to manage the application. This is especially the case when creating modular applications in which each module contains a script block to control the module to which the script block is attached.

The problem shown in this example can be avoided by having a unique ID for each div tag and writing the JavaScript to reference the tag by the ID attribute. However this limits code reuse and many other advantages gained by using a modular template driven website composition.

The typical method of developing a website does not lend itself to modularity and performance is greatly reduced as the site scales in size and traffic. The trend is for websites to use a variety of disparate data sources to build content in a modular fashion and then to compile the modules together to form a webpage. As the number of different types of modules increases or even the number of modules of a single type increases class collisions and excess DOM polling create instability and performance degradation in the browser as well as an increased load on the server. Additionally because the modules are loaded synchronously as the page is rendered the poor performance of a single module negatively affects all other modules below it in the DOM structure.

It would be advantageous to have a method of assembling the contents of a website that overcomes the deficiencies of traditional website design methodologies. The disclosed solution provides the bandwidth savings and performance enhancements of the typical client side solution with the robust feature set that server side engines typically employ. This is achieved in part by encapsulating each module and programming the software to sandbox the CSS and JavaScript for each module to avoid collisions while at the same time allowing modules to interact on a specified level as needed during user interaction.

The present disclosure provides a method of software development that creates a modular website in which each module contains an HTML template as well as a JavaScript block referred to as a Driver which when initialized provides the data source and any DOM manipulation instructions necessary to make the template elements behave as desired. The combination of these elements creates a website that is modular and capable of using disparate data sources while eliminating the performance degradation and class collisions associated with other methods.

The method includes the development of a client side templating engine which uses simple string replacement to populate elements from a data source. The templating engine does not require compilation and does not contain code for logical operators or other unnecessary functionality found in other commercial and open source offerings. The engine performs all of the functionality required to return HTML from a call to a single function. Calling this function from JavaScript code and sending the correct information in the call allows the templating engine to retrieve the proper template as well as retrieve and parse the data source. The templating engine retrieves all required information from a server side controller when called correctly thus eliminating the need to specify a data source for the module. Additionally the module templates may be compressed and cached in the client s browser as JavaScript Object Notation JSON files so that repeated calls for the same template does not require a request being sent to the web server. This greatly improves bandwidth utilization performance and scalability of the web application.

The method also utilizes class namespacing in the CSS portions of each module. This eliminates class collisions and speeds up DOM polling when attaching listeners to DOM elements or when manipulating DOM elements.

Each module includes a Driver written in JavaScript. The Driver receives instructions from the calling script and performs a number of functions. The Driver retrieves data from a defined data source for the module populates and renders the template portion of the module attaches listeners to the DOM elements of the template and manipulates the DOM elements of the template as needed in order to allow user interaction with the module.

The Driver code for each module may be initialized and run asynchronously rather than having one module waiting for another. This functionality improves the user experience and ensures the performance of each module does not affect the performance of other modules. The client web browser dynamically loads in any order a plurality of modules comprising Hypertext Markup Language HTML markup for a webpage when one or more HTML scripts are running asynchronously elsewhere on the webpage. The web browser is implemented in a computer having a processor and a memory and the web browser is in communication with a website server via a network connecting the computer and the web server. The web browser receives from the web server information for creating a DOM from the plurality of modules. The processor performs the following steps for each module separating the module into two functional parts 1 a module template comprising HTML markup that includes tags to be replaced with data and 2 a module Driver comprising an identifier tag and functional code controlling the operation of the module Driver. The functional code controlling the operation of the module Driver causes the module Driver to populate the identifier tag with an internal identifier for the module thereby creating a unique ID attribute for the Driver which enables the Driver to operate independent of other drivers that control other modules.

When the module Driver includes a driver variable the client web browser may also set the driver variable to reference the module Driver thereby loading the functional code into memory and removing the module Driver from the DOM.

When the module Driver includes a display variable the client web browser may also set the display variable to reference in the module template a DOM element that can be found relative to the module Driver thereby sandboxing all actions by the module Driver into the referenced DOM element in the template. This DOM element is preferably the DOM element immediately prior to the module Driver. Referencing the DOM element in the template prevents collisions with the scripts running asynchronously elsewhere on the webpage and eliminates polling for matching DOM elements.

One embodiment of the present disclosure is directed toward a method of loading separate DOM modules utilizing self referencing of running script elements. Each DOM module is separated into a module template and a module Driver following the template wherein the module template comprises HTML markup that includes tags to be replaced with data and the module Driver comprises an identifier ID tag a driver variable a display variable and functional code controlling the operation of the module Driver. The web browser is implemented in a computer having a processor and a memory and the method comprises the processor performing the following steps for each DOM module 

executing the functional code controlling the operation of the module Driver to ensure the ID tag is set as a unique identifier for the module thereby creating a unique ID attribute for the Driver which enables the Driver to operate independent of other drivers that control other modules 

executing the functional code controlling the operation of the module Driver to set the driver variable to reference the module Driver thereby loading the functional code into memory and removing the module Driver from the DOM and

executing the functional code controlling the operation of the module Driver to set the display variable to reference in the module template a DOM element that can be found relative to the module Driver thereby sandboxing all actions by the module Driver into the referenced DOM element in the template preventing collisions with the modules running asynchronously elsewhere on the webpage and eliminating polling for matching DOM elements.

The method allows the loading of modules either sequentially or dynamically in any order even when another script is running asynchronously elsewhere on the page. The method also allows nested modules to be loaded to create parent child relationships between modules while maintaining the correct context for the running code within each individual module.

Another embodiment is directed toward a computer implemented method of constructing nested modules. In this embodiment a first module may call for a second module which when parsed becomes one or more smaller repeatable parts of the first module. This allows for modules themselves to be modular and allows for better maintainability faster development and more efficient processing of the Drivers controlling the modules.

One particular embodiment is directed toward a computer implemented method and web browser for utilizing the client side templating engine to construct a nested website DOM module. A processor within a computer executes code stored in a non transitory memory to perform the method which includes receiving by the client side templating engine a single call to create the nested DOM module. The client side templating engine then retrieves data from a data source the data from the data source including data for populating the tags in the module template and data for creating a plurality of data blocks to be included in a nested data structure. The client side templating engine populates the tags in the module template with the data for the tags and the module Driver sequentially creates the plurality of data blocks using the data for creating the data blocks. Upon completion of each data block the module Driver appends the completed data block to the module template to create the nested data structure. In response to the single call to create the nested DOM module the client side templating engine then returns the nested DOM module including the template with populated tags and the nested data structure.

Another embodiment is directed toward the DOM module Driver in a client side templating engine executed by a processor controlling a client side web browser. The DOM module Driver is configured to create a nested data structure for a DOM module that includes the DOM module Driver and a module template. When the web browser makes a single call to the client side templating engine to create the DOM module the DOM module Driver sequentially creates a plurality of data blocks using data objects obtained from a data source. Upon completion of each data block the DOM module Driver appends the completed data block to the module template to construct the nested data structure. In response to the single call to create the nested DOM module the client side templating engine returns to the web browser the DOM module including the nested data structure.

The number of data blocks appended by the DOM module Driver is not limited by the client side templating engine. Additionally it should be noted that additional levels of complexity can be achieved when at least one of the data blocks appended by the DOM module Driver includes multiple smaller data blocks.

Further features and benefits of embodiments of the disclosure will become apparent from the detailed description below.

The present disclosure will now be described more fully hereinafter with reference to the accompanying drawings. The invention may however be embodied in many different forms and should not be construed as limited to the embodiments set forth herein rather these embodiments are provided so that this disclosure will be thorough and complete and will fully convey the scope of the invention to those skilled in the art. In the drawings like reference signs refer to like elements. Additionally it should be understood that the invention can be implemented in hardware or a combination of software stored on a non transitory memory and executed by a general purpose computer or microprocessor. Various servers and systems disclosed herein are understood by those skilled in the art to include processors non transitory memories and software comprising computer program instructions to be executed by the processors thereby causing the servers and systems to perform the stated functions.

Once initialized the Driver receives instructions from the calling script and may retrieve data from a defined data source for the module populate and render the template portion of the module attach listeners triggers to the DOM elements of the template and manipulate the DOM elements of the template as needed in order to enable user interaction with the module.

In this manner the complex data object that was originally passed to the Katy Library to create the album is cascaded down as needed to build as many nested layers as necessary. The nesting levels are unlimited by the library and multiple level complex data objects can be cascaded down through any number of layers to build very complex but modular website content.

Looking in further detail at the client side templating engine of the present disclosure the following features become evident with the engine given the nickname Katy Library all methods are prefixed with katy  

The ability to pass complex data structures. Data streams are typically passed as JavaScript object instances or JavaScript array instances but are usually limited to a single level and with all elements of the object having string values.

Supporting this type of complex data structures enables other robust features of the Katy Library specifically nesting as described above and embedded logic and other client side code. Embedded logic and other client side code provide additional capabilities. For example the template may include a mixture of HTML and JavaScript code and the data source can be used to populate fields in any portion of that template. The JavaScript can then run complex logical calculations on the data and display different portions of the template or display portions of the template differently depending on the results of those calculations. Additionally JavaScript code can be used similarly to manage the DOM elements of the HTML template in order to attach event listeners to those objects or manipulate the objects based on user interaction or other events. Such code may be implemented in module Drivers which often accompany the template code.

The template may include various tags such as the tag with the ID of content div which becomes a container for the content that will be generated. The template may also include various DOM elements that provide the functionality of the module once populated by the Driver . The Driver may include an ID tag a Display variable which is set to a DOM element in the template an initialization function and call function modules . The call function modules may include a data retriever module a tag replacer a listener attacher and a DOM element manipulator .

Once initialized the Driver receives instructions from the calling script and may retrieve data from a defined data source for the module populate and render the template portion of the module attach event listeners triggers to the DOM elements of the template and manipulate the DOM elements of the template as needed in order to enable user interaction with the module.

The coding structure of also allows nested modules to be loaded to create parent child relationships between modules while maintaining the correct context for the running code within each individual module.

At step the web browser receives from the web server information for creating a DOM from the plurality of modules. At step the control processor performs the following steps for each module At step the module is separated into two functional parts 1 a module template comprising HTML markup that includes tags to be replaced with data and 2 a module Driver comprising an identifier tag and functional code controlling the operation of the module Driver. At step the functional code controlling the operation of the module Driver causes the module Driver to populate the identifier tag with an internal identifier for the module thereby creating a unique ID attribute for the Driver. This enables the Driver to operate independent of other drivers that control other modules.

At step when the module Driver includes a driver variable the method may also include the step of setting the driver variable to reference the module Driver thereby loading the functional code into memory and removing the module Driver from the DOM.

At step when the module Driver includes a display variable the method may also include the step of setting the display variable to reference in the module template a DOM element immediately prior to the module Driver thereby sandboxing all actions by the module Driver into the referenced DOM element in the template preventing collisions with the scripts running asynchronously elsewhere on the webpage and eliminating polling for matching DOM elements.

At step the control processor determines whether the last module has been processed. If not the method returns to step and repeats for each additional module until the last module has been processed. The method then ends at step .

At step the functional code causes the Driver to set the driver variable to reference the module Driver thereby loading the functional code into memory and removing the module Driver from the DOM. At step the functional code causes the Driver to set the display variable to reference in the module template a DOM element that can be found relative to the module Driver thereby sandboxing all actions by the module Driver into the referenced DOM element in the template. This DOM element is preferably the DOM element immediately prior to the module Driver but it may be a different DOM element in the template as long as the element can be queried using CSS selector syntax relative to the Driver. In this case there has to be a way to determine the specific DOM element since many of the modules will be repeated. A list of selectors may be found at the website for jQuery api.jQuery.com with the extensions category selectors . However since the code is loaded in a modular fashion and the Driver is included in the module with the display or template the simplest solution is to query the DOM element immediately prior to the module Driver.

Setting the display variable in this manner prevents collisions with the scripts running asynchronously elsewhere on the webpage and eliminates polling for matching DOM elements.

Another embodiment of the present disclosure is directed toward a computer implemented method of constructing a nested website DOM module utilizing the client side templating engine running within the JavaScript virtual machine built into the client web browser. A processor for the client web browser such as control processor within a client computer executes code stored in a non transitory memory to perform the method which includes receiving by the client side templating engine a single call to create the nested DOM module. The client side templating engine then retrieves data from the data source . The data from the data source may include data for populating the tags in the module template and data for creating a plurality of data blocks to be included in a nested data structure. The client side templating engine populates the tags in the module template with the data for the tags and the module Driver sequentially creates the plurality of data blocks using the data for creating the data blocks. Upon completion of each data block the module Driver appends the completed data block to the module template to create the nested data structure. In response to the single call to create the nested DOM module the client side templating engine then returns the nested DOM module including the template with populated tags and the nested data structure.

The number of data blocks appended by the DOM module Driver is not limited by the client side templating engine. Additionally it should be noted that additional levels of complexity can be achieved when at least one of the data blocks appended by the DOM module Driver includes multiple smaller data blocks.

In the drawings and specification there have been disclosed typical preferred embodiments of the invention and although specific terms are employed they are used in a generic and descriptive sense only and not for purposes of limitation the scope of the invention being set forth in the following claims.

