---

title: Systems, methods and machine readable mediums for defining and executing new commands in a spreadsheet software application
abstract: Systems, methods and machine-readable mediums for defining and executing new commands in a spreadsheet application are provided. A method may include receiving a declaration command in a first spreadsheet cell. The declaration command identifying a command name for the new command and operations performed for the command name based on a plurality of second spreadsheet cells. A system may include a processor programmed to evaluate the declaration command in the first spreadsheet cell according to the instructions stored in a storage device, receive the command name and at least two parameters identifying at least one input spreadsheet cell and at least one output spreadsheet cell of the spreadsheet application, create a new command for the spreadsheet application, and evaluate the new command as identified by the command name in a second spreadsheet cell for execution. The computer readable mediums provide instructions to cause the processor to perform the operations above.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09384182&OS=09384182&RS=09384182
owner: Exigen Properties, Inc.
number: 09384182
owner_city: Tortola
owner_country: VG
publication_date: 20140102
---
The present application is a continuation application of U.S. patent application Ser. No. 12 603 342 filed Oct. 21 2009 and entitled Systems Methods and Machine Readable Mediums for Defining and Executing New Commands in a Spreadsheet Software Application which claims the benefit of and priority to Prov. U.S. Pat. App. Ser. No. 61 171 003 filed Apr. 20 2009 the contents of which are hereby incorporated herein by reference in their entirety.

This disclosure relates to executing functions and more particularly relates to systems methods and machine readable mediums for defining and executing new commands in a spreadsheet software application.

Systems methods and machine readable mediums for defining a new command in a spreadsheet application are disclosed. The method may include receiving a declaration command in a first spreadsheet cell. The declaration command identifies a command name for the new command and operations performed for the command name based on a plurality of second spreadsheet cells. In one embodiment the method may further include translating the command declared in a spreadsheet language to a fragment of code in a predetermined programming language. The method may include receiving the command name and at least two parameters in the first spreadsheet cell. The at least two parameters identifying the plurality of second spreadsheet cells. The plurality of second spreadsheet cells includes at least one input cell to receive at least one input parameter of the new command and at least one output cell to provide a return result of the new command.

In one embodiment the declaration command may be programmed to cause the processor to receive the command name from a third spreadsheet cell receive a parameter to identify an input cell for the new command in a fourth spreadsheet cell and receive a parameter to identify an output cell for the new command in a fifth spreadsheet cell.

The computer readable mediums provide instructions to cause the processor to perform the operations above. In one embodiment the computer readable medium has stored thereon a set of instructions which when executed by a computer having a processor and a memory causes the computer to receive a declaration command in a first spreadsheet cell of a spreadsheet application. The declaration command defining a command name as a new command callable in a second spreadsheet cell.

In one embodiment a system for executing a new command in a spreadsheet application is provided. The system may include a storage device and a processor. The storage device may be used to store code instructions for implementing a declaration command for assigning in the spreadsheet application a command name as the new command with at least two parameters. The processor may be programmed to receive code instructions for invoking the declaration command in a first spreadsheet cell and receive the command name and the at least two parameters. The at least two parameters associated with input and output spreadsheet cells. The processor may also be programmed to assign the at least two parameters to the command name and execute code instructions for invoking the command name in a second spreadsheet cell to execute the new command based on the at least two parameters.

In another embodiment the system may include a storage device to store instructions for implementing a declaration command. The declaration command assigning a command name as the new command with at least two parameters. The system may also include a processor programmed to evaluate the declaration command in a first spreadsheet cell according to the instructions stored in the storage device receive the command name and at least two parameters identifying at least one input spreadsheet cell and at least one output spreadsheet cell of the spreadsheet application and create a new command for the spreadsheet application. The processor may then evaluate the new command as identified by the command name in a second spreadsheet cell by receiving data from the at least one input spreadsheet cell and providing data to the at least one output spreadsheet cell.

In the description that follows the present inventions may be described in reference to one or more embodiments that facilitates user friendly interface for programming in a spreadsheet. The present inventions however are not limited to any particular application nor is it limited by the examples described below. Various modifications to the disclosed embodiments may be apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the inventions. Therefore the description of the embodiments that follow are for purposes of illustration and not limitation.

The display device may be communicatively coupled to the computing device to display the spreadsheet. In one embodiment the display device may be a desktop monitor or a handheld screen. The input device may also be communicatively coupled to the computing device to input data or commands in the spreadsheet and or select one or more user interfaces of modules operative with the spreadsheet for execution. In one embodiment the input device may be a keyboard and or a computer mouse. As can be appreciated the display device may be integrated with the input device as in the case with a touch screen device.

As can be appreciated the computing device may include one or more processors for implementing one or more functional modules such as a spreadsheet application module a translation module and a declaration command module . As used herein the term module refers to logic implemented in hardware and or software. It may include a collection of software instructions possibly having entry and exit points written in a programming language such as for example Java Microsoft Visual Basic or C . A software module may be compiled and linked into an executable program or installed in a dynamic link library or may be written in an interpretive language such as Java. It may be appreciated that software modules may be callable from other modules and or may be invoked in response to detected events or interrupts. Software instructions may be embedded in firmware such as an EPROM. It may be further appreciated that hardware modules may be comprised of connected logic units such as gates and flip flops and or may be comprised of programmable units such as programmable gate arrays. The modules described herein are preferably implemented as software modules but could be represented in hardware or firmware.

In one embodiment each module is provided as a modular code object where the code objects typically interact through a set of standardized function calls. In one embodiment the code objects are written in a suitable software language such as Java or C but the code objects can be written in any low level or high level language. In one embodiment the code modules are implemented in Java and compiled on a computing device running a spreadsheet application. Alternatively the code modules can be compiled with their own front end on a kiosk or can be compiled on a cluster of server machines and transmitted through a cable packet telephone satellite or other telecommunications network. Artisans of skill in the art may recognize that any number of implementations including code implementations directly to hardware are also possible.

The computing device may also include a storage device such as a database for storing data including spreadsheet data . As is understood by a person skilled in the art the spreadsheet data may include content information in one or more spreadsheet cells. As is well known database categories can be combined further divided or cross correlated and any combination of databases and the like can be provided from within the computing device . In one embodiment any portion of the database can be provided externally from the computing device either locally or remotely over a network. The external data from an external database can be provided in any standardized form which the processor can understand. For example an external database at a provider can advantageously provide end user data in response to requests from the processor in a standard format such as for example name user identification and computer identification number and the like and the end user data blocks are transformed into a function call format which the code modules can understand.

As can be appreciated the database may be used to store arrange and retrieve data including instructions for implementing a declaration command. The declaration command may be used to assign in the spreadsheet application a command name as a new command with at least two parameters. The database may be a storage device such as a machine readable medium which may be any mechanism that provides i.e. stores and or transmits information in a form readable by a processor. For example the machine readable medium may be a read only memory ROM a random access memory RAM a cache a hard disk drive a floppy disk drive a magnetic disk storage media an optical storage media a flash memory device or any other device capable of storing information. Additionally machine readable medium may also comprise computer storage media and communication media. Machine readable medium includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Machine readable medium also includes but is not limited to RAM ROM EPROM EEPROM flash memory or other solid state memory technology CD ROM DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

The spreadsheet application module may be provided as a modular code object interacting through a set of standardized spreadsheet function calls. The spreadsheet application module may be used to transmit and retrieve data such as the spreadsheet data . The spreadsheet application module may be operatively associated with one or more modules for example the declaration command module to perform a set of functional calls. The declaration command module may provide code instructions for implementing a declaration command to assign a command name as a new command with at least two parameters. The declaration command module may be an add on module to a spreadsheet application program or an integrated part of the spreadsheet program. The spreadsheet application module may also be operatively associated with the translation module to translate the spreadsheet data into a piece of code in a programming language.

In one embodiment the processor may be configured programmed and or provided code instructions from one or more modules to facilitate programming define a new command and execute the new command in a spreadsheet application. For example the processor may be programmed to receive code instructions for invoking the declaration command in a first spreadsheet cell and to receive the command name and the at least two parameters. The at least two parameters are associated with input and output spreadsheet cells. The processor may be further programmed to assign the at least two parameters to the command name and execute code instructions for invoking the command name in a second spreadsheet cell to execute the new command based on the at least two parameters.

In one embodiment the translation module may be configured or programmed to translate the logic of the declared function into a source code in a predetermined programming language.

In another embodiment the processor may be configured programmed and or provided code instructions to evaluate the declaration command in a first spreadsheet cell according to the instructions stored in the storage device receive the command name and at least two parameters identifying at least one input spreadsheet cell and at least one output spreadsheet cell of the spreadsheet application and create a new command for the spreadsheet application. The processor may also be configured programmed and or provided code instructions to then evaluate the new command as identified by the command name in a second spreadsheet cell by receiving data from the at least one input spreadsheet cell and providing data to the at least one output spreadsheet cell.

As is understood by persons skilled in the art a conventional spreadsheet recognizes either a built in function created by the manufacturer of the spreadsheet application or a user written function whose construction would require development of its logic in a software language by a software engineer and not in the spreadsheet language by the non software specialist user of the spreadsheet model.

In one embodiment the declaration command may be programmed to provide instructions to the processor to receive the command name from a third spreadsheet cell. The declaration command may also be programmed to provide instructions to the processor to receive a parameter to identify an input cell for the new command in a fourth spreadsheet cell and receive a parameter to identify an output cell for the new command in a fifth spreadsheet cell.

As can be appreciated the declaration command may be implemented as an add on module to the spreadsheet application module or integrated with spreadsheet application module . In the add on module implementation the new command Credit Rate may be created and enabled for invocation in the user s spreadsheet by means of a standard API published by the manufacturer of the spreadsheet product. For example the declaration command may follow the rules and satisfies the constraints defined for the category user defined by Microsoft Corporation published in Microsoft Office Excel 2007 Developer Reference and incorporated herein by reference.

Next the processor invokes a proxy function associated with the declaration command according to an embodiment of the present disclosure . The proxy function is called to perform the operations for the installation of a user defined function to implement the command declared by the declaration command. For example the external source may be a Java script source or any other source utilizing a predetermined programming language.

Once the proxy function is invoked the processor may then determine if the declaration command module is installed . If the declaration command module is not installed the processor prompts an error message and terminates the proxy function . If the declaration command module is installed then the processor evaluates if the parameters provided are valid . If the parameters are invalid the processor prompts an error message and terminates the proxy function . If the parameters are valid then the processor evaluates if a cell monitoring code module posted a result . The cell monitoring code module performs appropriate actions for the implementation of the new command when any spreadsheet cell s is are changed by the user. When the user enters the declaration command in a cell the proxy function and the cell monitoring code module separately invoked by the spreadsheet. If no result has been posted from the cell monitoring code module the processor prompts a response pending message and terminates the proxy function . If a result has been posted from the cell monitoring code module the processor provides the text message generated by the cell monitoring code module and terminates the proxy function .

If the command declaration was a removed prior declaration the processor replaces the fragment of the code in Visual Basic for Applications and removes in the spreadsheet application the Name object referencing the cell into which the declaration was inserted . The processor may then determine if a new command is declared . Similarly if the command is not a removed prior declaration the processor determines if a new command is declared . If it is not a new command the processor terminates cell monitoring with no action .

Alternatively if a new command is declared the processor evaluates if the declaration command satisfies naming and parameter rules . For example in one embodiment the declaration command invoked in a spreadsheet cell should include in brackets and or quotation marks a function name in double quotes followed by a comma followed by the output cell address followed by another comma followed by at least one input cell address to be used as input parameters.

If the declaration command does not satisfy the naming and parameter rules the processor prompts an error message and terminates cell monitoring . If the declaration command satisfies the naming and parameter rules the processor may be programmed to insert in the spreadsheet application a Name object referencing the cell into which the declaration was inserted and a fragment of the code in Visual Basic for Applications . The processor may also post a message reporting success of installation of the new command re evaluate the cell into which the declaration was entered by the user and terminate the operations of the cell monitoring code module .

When a user invokes the new command the automatically generated code for the new command may cause the processor to perform the following operations. First the processor may be programmed to cause the movement or a copy of the input parameters in the above example cells E4 and F4 of into the proper place of in the spreadsheet which contains function s logical definition in this case into cells D5 and D6 of . The processor may then cause the spreadsheet in to perform any calculations in the event that the spreadsheet itself invokes other functions. The internal processing may perform similar operations on all of them recursively and until all of the downstream functions complete their calculations. It may then take the output parameter in this case cell D12 of and return that as a return value of the CREDIT RATE function to be displayed to the user. It may do such conversion of the datatypes as is dictated by the spreadsheet. In the case of Excel it may return all values as VARIANT types with the STRING NUMBER and DATE set in accordance with the format defined by the user for the cell in which he she wishes to see the output.

Next the processor calls the new command and evaluates if the cell monitoring code module posted results from a previously requested execution . In one embodiment it may be assumed that if the cell monitoring code module posted results from a previously requested execution the reason for the call was not to receive a response to the previously requested execution. As such the processor may be programmed to create a new instance of the message object and insert values of input parameters into the object . The processor may then place the new instance into the collection of messages in a mailbox that contains all outbound requests from all functions of this type from all active spreadsheets invoked by the call of the new command . The processor may also output a waiting for response message .

In one embodiment it may be assumed that if the cell monitoring code module did not post results from a previously requested execution the reason for the call was to receive the response to the previously requested execution. As such the processor may be programmed to retrieve the inbound message from the message queue and retrieve the return value . The processor may then release or destroy the message object and output the return value .

Next the processor may be programmed to evaluate the inbound mailbox to determine if it contains requests for calls to a user defined new command . If not then the processor terminates evaluation of the inbound mailbox . If the inbound mailbox contains requests for calls to a user defined new command the processor may be programmed to take the next request from the message queue and obtain the location of the target spreadsheet input and output cells and the list of input parameter values provided . As explained above the processor may also move parameters provided in the message into the target spreadsheet input cells cause the target spreadsheet to recalculate save inbound message queue and create new temporary message queue set in a public place so that all subsequent requests may be deposited there . Next the processor may recursively perform calculations on other commands invoked in the spreadsheet . The processor may then re evaluate inbound mailbox to determine if the other commands invoked contain requests for calls to a user defined new command.

As can be appreciated the scope of the new command created in this manner may not be limited to the spreadsheet in which it was declared i.e. the function can be called directly without any further qualifications from any spreadsheet and that same name can be used in two different spreadsheets without mutual interference . Furthermore the processor may be programmed to automatically monitor the new command s logic once it has been declared and activated for use. If the user changes a formula in the spreadsheet which is contained in an input or output cell and identified as a parameter of the new command the processor may be programmed to detect the changes i.e. changes which could potentially produce different result than the one obtained from the last call even if the same exact input parameters were used . Once such change is detected the processor may be programmed to perform recalculate operation on all cells which contain the reference to the new command.

As is understood by a person skilled in the art declaring a new command in a spreadsheet application may be utilized in retrieving data from a DATABASE or a static TABLE expressing an IF THEN ELSE sequence and creating new LOOPS in the spreadsheet application.

One of the biggest challenges facing a spreadsheet application user is the ability to organize data in a way that would permit an automatic translation of reference between the spreadsheet and the real database. While the spreadsheet keeps data in tables of rows and columns the software applications keep the data in databases originally indexed files such as IMS and VSAM later relational database such as DB2 Informix or Oracle . State of the art technology for keeping application data today are relational databases with an object model superimposed over it using an MDA Model Driven Architecture techniques and popular products such as Hybernate.

There are multiple solutions and tools which extract data from databases and populate the spreadsheets. In most cases however the original data model which implements a potentially complex interrelationship between data elements is not propagated into the spreadsheet making a translation of the logic from spreadsheet into the working application impossible.

One embodiment of the present disclosure introduces a full concept of the data object and of object model into the spreadsheet language. It calls for creation of an in memory object database which would fully mimic the structure of the application data model except for its application related methods. The in memory replica may be populated with the extract of the application s database when developing a component of the existing application and by the spreadsheet directly if developing a brand new application. The fields properties of the replica may be available to all spreadsheet calculations including any user defined functions as discussed above.

A declaration command shown in as a DECLARE DATABASE command may be used to activate the model described in the spreadsheet. illustrates a spreadsheet implementing a declaration command to define a new command as a database for retrieving data according to one embodiment of the present disclosure. In this example the cell range of B6 to F84 is identified as a parameter to the new command to provide the entire set of data.

Once the logical model with its inner relationships is created whether by hand by the user or generated from the applications domain model it can now be easily populated with a number of instances of test data as is suitable to the user. illustrates an exemplary spreadsheet with populated data. The free formatted table of data may be created by the user when constructing a new application or generated as a sample of the applications data when adding an application component . The data occupy range B92 P129 of the spreadsheet in . An exemplary declaration command is entered into cell B92 of the spreadsheet as OL DECLARE DATA InitialData B92 P129 expression.

The exact syntax by which field declarations in the DECLARE DATABASE expression are related to the cells with data values can and may vary widely. In our particular implementation a columnar notation is being used. If a user wishes to supply data for a field called ADDRESS which is a part of ADDRESS HISTORY collection belonging to a PERSON object the user would insert a column within the range of cells embraced by DECLARE INITAL DATA declaration. Because the language implemented allows for multiple fields called ADDRESS one can be part of ADDRESS HISTORY collection another a part of SCHOOLS objects third a part of COMPANY object for example the user may supply a fully qualified name such as PERSON.ADDRESS HISTORY.ADDRESS as a column header.

Resulting series of columns may have fields from various levels of the objects. In the example above it may include single properties of a PERSON LAST NAME FIRST NAME current RENT and ADDRESS as well as properties of the collections historical ADDRESS and RENT from the ADDRESS HISTORY collection .

In one embodiment not all fields have to be filled. They can be in any order. Collections instances can be placed anywhere. Each collection has a key. For example CID is a key to a PERSON while STAR YEAR is the key to ADDRESS HISTORY.

In one embodiment the processor may be programmed with instructions for an UPSERT relational function that is to update when present and insert when not. In the example above the first five rows of the first DATA section all deal with the properties of the same person Octvaius Thurinus CID of 072 219. By repeating the CID on 5 rows we can now add two FRIENDS CIDs 068 208 and 963 173.1 and 5 historical residences starting at START YEAR 1972 1984 1986 2000 and 2004 respectively.

The program may relate the fields of each collection to its key FIRST NAME Octavius to the CID 068 208 ADDRESS of Rue Cherche Midi Paris and RENT of 99 to the START YEAR of 2000 etc. Similarly Pompeus has 5 friends but only 2 prior residences while Cornelia Scipio has no friends at all. Once the user confirms the data by hitting the enter key for the cell B92 which contains the DECLARE INITIAL DATA if no errors were found the user may get a confirmation text in the cell indicating success of the declaration. From this point onward the data may automatically be available to the user in the spreadsheet language.

a BY KEY. The proper key of the collection to which the field being accessed through this function belongs 072 129 for Person or 2000 for START YEAR

b BY INDEX. A user may retrieve any field of any collection by using simply indexes 5 for 5th person Magnus 2 for second ADDRESS

c NESTING. Properties of collections require a proper reference to the instance of the object to which this collection belongs FRIENDS 2 PERSON 1 may be used to retrieve 2nd friend of the first person in the data. ADDRESS ADDRESS HISTORY 2000 FRIENDS 2 PERSON 963 173.3 may be used to return Rue Cherche Midi Paris by requesting the residence of year 2000 for the 2nd friend Octavius as it happens to be of the person with CID of 963 173.3 Magnus .

d Either the key or the index can be provided in the function call explicitly as above or as a cell reference.

e NESTING can follow the same convention the example on preceding page can be implemented by the user as 

iii. Cell A3 may contain a function FRIENDS 2 A 2 or it can have FRIENDS B 2 A 2 assuming B2 contains number 2 in it at the time.

iv. Cell A4 may have ADDRESS HISTORY 2000 A 3 or ADDRESS HISTORY B 14 A 3 with 2000 being placed in C14

A user has full freedom of combining the two techniques and doing something like cell A2 FRIENDS 2 PERSON A1 and cell A3 ADDRESS ADDRESS HISTORY 2000 A2 

As shown in the user invokes the new command First Name of the person identified by CID 072 219. The expression First Name B14 is entered into cell D14 of the spreadsheet in producing the first name requested Octavius the outcome which which can be seen on . The user may enter a number of cells with values of CIDs for example B14 through B19 of . By simply selecting cells C14 and D14 and dragging down the selection he may obtain the combinations of last name first name for the list of customers identified by the keys in positions B14 to B19 as shown in .

The operation can be performed along multiple collections. For example in the user may place a number of CIDs and obtained names as was just described in columns 14 through 19. To obtain all the past residence addresses for each of these people access by index may be used. Index values 1 through 4 may be placed in row 13 columns E through H. As can be appreciated for Excel implementation the user may fix the row 13 of the index by prefixing it with making the reference E 13 and fix the column B of the customer ID by reserving it through the use of in the person Id cell as B14 . The command may then be copied in column E rows 9 through 13 as shown in and across columns E through H for the rows 8 to 13 as shown in .

In one embodiment the declaration command may be used to support an option by which an application can be specially prepared for BI operations with our tool thorough construction of special user friendly Data Dictionary implemented as a sub class over original application data model. This feature may be used to enable project teams define human friendly names for data fields in order to improve readability of spreadsheets. In this case the mapping between application data model and the data model in a spreadsheet is accomplished by means of reading application s data schemas which connect the dictionary to the data model.

In certain applications maintaining large volumes of static data representing constants in various calculations may be needed. Typical examples are found in insurance lending and other applications. illustrates a callable new command for a static table according to an embodiment of the present disclosure. defines an exemplary set of discount rates for ZIP 10011 Owned type of insured property for 1 or 2 or 3 bedrooms zones A and B and 4 street ranges 14 20 21 29 30 33 33 42 . While this example illustrates a two dimensional table artisans would understand that the present disclosure may be applied to multi dimensional database or tables.

One embodiment of the present disclosure may be directed to the translation between the two manners of expressing the data representing tabular data in spreadsheet and managing it in the database. More specifically the elements of the table as illustrated in can be easily referred to in the spreadsheet language through the use of explicit row and column identifiers. In some spreadsheet products a special direction may be given by the user to create the reference names out of column and row labels. In either case however the linguistic framework is untranslatable into an application system outside of the spreadsheet.

One embodiment of the present disclosure may introduce a general spreadsheet language extension which would permit reference to the data elements through the expressions which are easily found in the language of applications. One implementation Excel for spreadsheet product and Open L for the code generator and run time uses the DECLARE TABLE command as shown on .

As is the case with functions and other forms of data the new command called RISK RATES may be defined by the user and callable in the spreadsheet. The new command takes dimensions of the table as its inputs and returns the value of the corresponding cell. For example the table in has five dimensions for readability shaded in grey . In one embodiment the new command may not require any declaration of names of dimensions or their datatypes. The processor may be programmed to infer the number of dimensions from the geometric shape of the table and their datatypes from the FORMAT property of the cells in which they are entered.

The intersection may be determined by tracing the cells leftward and upward until reaching the row or a column which contain the section keyword. Cell G 11 runs into non empty cell G 10 before reaching the row 8 which hosts the section corner of the table . It runs into non empty cell F 11 before reaching the column E. As a result it may be deemed to belong to a full intersection and is therefore a cell. In contrast each of the cells G8 G9 and G10 have no non empty cells to the left of them preceding column E which makes them into column dimensions. Each of E11 and F11 have no non empty cells between themselves and row 8 which makes them into row dimensions.

Our implementation permits the user to omit repetition of identical values on the right of the column and down the row dimensions. In the example above and below cells H8 and I8 are deemed to act as if they contained the value 10011 simply because 10011 is the nearest non empty value to the left of them. By the same rationale H9 and I9 may be treated as if they contained Owned. Cell E12 may be treated as if it contained code A and E14 as if it contained B .

As can be appreciated other table dimensions may be implemented with the declaration command of the present disclosure. A table may have no non empty cells between section and the right most edge of the declaration range. The table may be deemed to have no column dimensions is all rows table . As such the last column may be treated as column of values and the rest starting at the column which contains the section indicator as row dimensions. Alternatively a table may be deemed all columns because all is empty between section and the lower boundary of the declaration range. As such the last row may be treated as row of values and the rows from the one containing section to the end of the range as column dimensions.

In one embodiment the declaration command does not call for explicit declaration of the dimension names and formats. In the exemplary embodiments the reference to dimensions is instead positional. The user asks for cell values through the new command identifying the table name of the declaration in our example RISK RATES . The user may then supply the exact number of dimension values for the table 5 in this example . In the example illustrated in the relative position may be going from left to right 

a If this is all columns type table the dimensions may be listed in the order from lower to higher in the sequence of rows starting from the row nearest to the data.

b If this is all rows type table they may be listed from right to left in sequence of column starting from the column nearest to the data.

c If this is a table which contains both rows and column the row dimensions may be listed first in right to left columnar sequence followed by row dimension in bottom up row sequence.

As an example the input RISK RATES 33 42 B 3BD Owned 10011 may reference the value 0.5710 in cell I14 of . As can be appreciated data tables can spread across multiple worksheets and multiple workbooks. According to an embodiment of the present disclosure the spreadsheet language may be used to define a continuum of tables all united into a single reference name or organized among multiple names.

Artisans would understand that functions and operations described above can be implemented using special purpose circuitry with or without software instructions. For purposes of illustration the following description provides exemplary implementations.

The embodiments of the present disclosure can be used as a component of an overall IT infrastructure. It co operates with other elements such as Application Domain Models Application Logic etc. It can co exist and co operate with other tools open or proprietary. The embodiments of the present disclosure may be programmed for Java based environments.

At this point a special process is invoked which converts the Excel expressed logic into production ready application as follows 

All OL FUNCTIONS become Java functions with the same name as the same calling protocol of inputs and outputs or dot Net functions or the functions of the target language . Parameters may be passed by position or by name as may be described later in details sections.

The compiler follows the chain of calculations embedded in a workbook which is enabled by public interfaces to spreadsheet products in case of Excel Microsoft publishes Office Object Model for Excel which permits well defined method of reading the spreadsheet logic in its complete semantics .

All references to the data objects are converted into regular target language data references. This is possible because the application domain model has same properties and same structures as the properties and structures in Service Model for Excel carrying same exact names and same exact parameters for all GET methods.

All OL TABLES are converted into target language static data tables and their access functions become access functions in Java. The functions carry the same names and accept same parameters.

They are implemented as on demand functions i.e. unlike regular Excel functions they do not perform their primary job on each invocation but only when the user requests their operation explicitly by touching the cell in which they are defined this choice of syntax and the exact manner by which the user indicated his desire to perform the appropriate task can vary and is subject to implementer s creativity for example it could be done through hotkeys or buttons .

These functions may be on demand functions to perform both heavy and infrequent duties such as creation of a whole new function or method or change of the base data model. As may be seen below we do not need to re run the declaration step of a function when the user changes the logic of an already defined function all such changes may become immediately active and all caller cells may be immediately recalculated.

The code for Language Extensions may be delivered in the case of Excel implementation as an Excel Add In standard practice described by Microsoft a standard method to extend Excel functionality .

On initialization the Add In installs what s called EVENT HANDLERS procedures which may be called by Excel every time a cell in Excel is CHANGED or a workbook is OPENED CLOSED or a sheet is CALCULATED. An exemplary code implementation may be as follows 

On Demand functions may be serviced by the event handling procedure ON CHANGED. An exemplary code implementation may be as follows 

The procedure may be invoked by Excel after change operations had been completed. The procedure is given addresses of cells that had been affected by the change according to Excel specification published in the above referenced book . The procedure may examine the nature of the change performed by the user. In particular it may be looking for 

d Change to one of the range parameters which constitute the body of DATABASE DATA TABLE or DECISION TREE declarations

e Change to one or more cells on which a previously defined FUNCTION declaration depends for its result.

The procedure may perform proper bookkeeping operations for each of the newly introduced declarations. In particular it may insert an invisible Excel NAME object into user s workbook using standard WORKBOOK.NAMES.ADD method. The NAME property of the newly inserted object is a concatenation of a standard prefix for each of On Demand functions e.g. OLfunction OLfunction  for function etc. and of the name given to the function by the user e.g. credit rate resulting in OLfunction credit rate . The REFERENCE property of the NAME object is the location of the declaration. This technique permits the product to discover location of the declaration regardless of the column row and cell insertions and deletion performed by the user over the lifespan of the declaration since Excel may maintain the always correct reference to the cell location identified by the name.

It may then perform operations proper for each newly defined declaration and described for each below. In the event a previously defined declaration had been eliminated by the user the handler may reverse the bookkeeping effects which were introduced on its creation such as eliminate the corresponding NAME object . It may also remove the fragments of code it inserted into users workbooks at the same time.

In some cases instead of removing them altogether it may replace them with the versions which produce the test Function At Location Had Been Removed . One objective is to give the user an easily interpretable error instead of the regular NAME which Excel may put into the calling cell if the function is simply removed.

For changes in declarations parameters in the body of parameter ranges and in the formulas on the function dependency chain the ON CHANGE event handler may upon having implemented the requested operation through essentially a repetition of actions done on its original introduction force a re execution of all instances of formulas which include calls to OL managed client functions. This operation is accomplished through rewrite of a fragment of the VBA code in the user s workbook which corresponds to the On Demand function being affected and then calling a CALCULATE method on all worksheets of the workbook.

For each On Demand OpenL DECLARE function a proxy function coded in Visual Basic for Applications and carrying the identical name may be automatically created in the workbook of the user. The duty of proxy On Demand functions is three fold 

To report success or failure of the proper operation of an On Demand tasks described immediately below

To provide the locations and type definitions of function parameters during run time described in the FUNCTIONS section . This is one of the possible techniques which allow the implementer not to create any additional storage for Language Extension metadata and use exclusively standard storage provided by the workbook.

On workbook OPEN event the controlling program may perform RESTORE RUN TIME ENVIRONMENT operation which is described below and which depends on the object being restored. In some cases Excel may activate the ON OPEN event and load the controlling program even if it had been previously de installed as the Add In using other workbooks. In these cases the controlling program may perform all de initialization operations that it would normally do against the workbook active at the time of de installation.

On Add In de install the program may remove all workbook connectivity to itself. It is our choice to leave a version of proxy functions in place in the user s workbook rather than eliminate them. These are called INACTIVE versions and their purpose is to report OpenL had been de activated message to the owner of the workbook. The objective is enable users re install the program if the de installation occurred accidentally or in case of change of mind and re activate all the workbook s functionality without having to re code the workbook.

For each new declaration the ON CHANGE handler may perform as follows. The parameters of the declaration are parsed out of the declaration command verified for correctness and error messages are communicated to the requesting user in cases of problems.

For each new command its cell location is registered as an invisible Excel Name object referencing the cell in which the function is written OLfunction credit rate in the example which we are following . This permits the controller program to know the location of the function declaration command even if the worksheet is changed by the user performing insertions and deletion and movement and copying of cells rows and columns.

Using published Add In APIs see Microsoft Office Excel 2007 Developer Reference incorporated herein by reference the controlling program may automatically insert a fragment of Visual Basic for Applications code into the user s workbook. An exemplary code implementation may be as follows 

This makes the function CREDIT RATE available to Excel user as a legal Excel function. The controlling program may connect the newly created VBA code fragment with the main codeline in the Add In in this case an internal function called OL call New through a standard interface object called reference .

When Excel calls the function CREDIT RATE following user s writing it into one or more cell formulas in the workbook it may immediately pass control to a general program called OL call NEW which may be included with the Add In. This program may know both the name of the function which calls it by decoding the second parameter and the target spreadsheet.

The second parameter OLfunction credit rate may also be an Excel name object which contains the actual cell address of the DECLARE function for the CREDIT RATE. This may permit the OL call NEW program determine which parameters need to be placed where in the target spreadsheet once CREDIT RATE is invoked. This completes the operation of DECLARE FUNCTION operation. The new function may now be called.

Last act of the on change controlling program performing declaration of a FUNCTION is to force the recalculation of all cells in the workbook which used the function in cases when its parameters are being changed as opposed to cases when it is fully created recall that the re declaration is not required if the function logic changes only if the number or the order of parameters does .

This is accomplished by various methods. The easiest is to update the invisible name OpenL or use DIRTY CALCULATE methods of Excel standard library against caller sheets or use DIRTY CALCULATE methods against the recorded locations of calling functions. For certain versions of the Excel the update of Visual Basic code in the body of the workbook and executing ACTIVESHEET.RANGE A1 .FORMULA ACTIVESHEET.RANGE A1 .FORMULA may do the job.

The parameters of the declaration are parsed out of the declaration command verified for correctness and error messages are communicated to the requesting user in cases of problems.

For each newly created database declaration its cell location is registered as an invisible Excel Name object referencing the cell in which the function is written. The name is comprised form the standard prefix OLdatabase  OLdatabase  and the name chosen by the user and provided as the first parameter of declaration. This permits the controller program to know the location of the function declaration command even if the worksheet is changed by the user performing insertions and deletion and movement and copying of cells rows and columns.

The range parameter of DECLARE DATABASE is interpreted by a special program which creates a run time dictionary of data fields and their relationships or reports user errors if such are found . The run time dictionary may be stored in PUBLIC storage of Visual Basic for Applications which would make it available to all subsequent programs throughout the entire Excel session until the workbook closes.

This run time structure is restored on every workbook OPEN as described above as RESTORE RUN TIME ENVIRONMENT operation. The restoration is identical to the execution of new declaration except for registration of the new function in Excel Names collection.

Using published Add In APIs the controlling program may insert a fragment of Visual Basic for Applications code into the user s workbook one for each property field of the declaration. An exemplary code implementation may be as follows 

This makes Last Name a legal and callable Excel function whose purpose was described in the first part of this paper. The new function may be connected through REFERENCE object member of Add Ins collection to the function called OL Get Prop. When called it may pass its input parameters along with the name. OL Get Prop is a general function may use the name passed to it as a name of the property whose value is being sought by the user.

Function names created for data properties may be edited for compliance with Excel syntax special characters such as blanks may be replaced by legal characters such as underscores and in case of name conflict with existing Excel functions the names may be disambiguated by appending underscores to them.

Due to special features of Excel Language Extension there is no problem with duplicate property names in database definitions the details of which technique may be described below.

The parameters of the declaration are parsed out of the declaration command verified for correctness and error messages are communicated to the requesting user in cases of problems. For each newly created load declaration its cell location is registered as an invisible Excel Name object referencing the cell in which the function is written. This permits the controller program to know the location of the function declaration command even if the worksheet is changed by the user performing insertions and deletion and movement and copying of cells rows and columns.

The range parameter of DECLARE DATA LOAD may be interpreted by a special program which creates a run time structure of data elements and their relationships or reports user errors if such are found . The run time dictionary may be stored in PUBLIC storage of Visual Basic for Applications which would make it available to all subsequent programs throughout the entire Excel session until the workbook closes.

This implementation may utilize nested ARRAY OF VARIANTS data type provided by Visual Basic for Applications to store the structure but many alternatives would be possible. This run time structure is restored on every workbook OPEN as described above as RESTORE RUN TIME ENVIRONMENT operation. The restoration is identical to the execution of new declaration except for registration of the new function in Excel Names collection.

The parameters of the declaration are parsed out of the declaration command verified for correctness and error messages are communicated to the requesting user in cases of problems.

For each newly created static data declaration its cell location is registered as an invisible Excel Name object referencing the cell in which the function is written. This permits the controller program to know the location of the function declaration command even if the worksheet is changed by the user performing insertions and deletion and movement and copying of cells rows and columns.

The range parameter of DECLARE TABLE may be interpreted by a special program which creates a run time structure of data elements and their relationships or reports user errors if such are found . The run time dictionary may be stored in PUBLIC storage of Visual Basic for Applications which would make it available to all subsequent programs throughout the entire Excel session until the workbook closes.

This implementation may utilize nested ARRAY OF VARIANTS data type provided by Visual Basic for Applications to store the structure but many alternatives would be possible.

One difference between TABLE and DATABASE structure is the nature of the data loads and of the metadata caused by difference of intended usages. While DATABASE is a reflection of the application data model and has a typical object structure the TABLES are special cases of multi dimensional data which require a lot less metadata definitions. Also DATABASE may be used to contain a sub set of application data intended for testing while TABLES may be used to provide production system information such as risk rates for insurers etc. As such TABLES may not follow a two step declaration process as the DATABASE does schema followed by data . Both are inferred from the layout of tables themselves. There may also be differences between the layouts of the data too while database data reside in one worksheet and follows single horizontal pattern the tables are expected to be provided in multiple fragments spanning multiple sheets or even workbooks and their layout may vary depending on user s preferences on a case by case basis. Some layouts may be in rows some in columns and some in a mix.

This run time structure is restored on every workbook OPEN as described above as RESTORE RUN TIME ENVIRONMENT operation. The restoration is identical to the execution of new declaration except for registration of the new function in Excel Names collection.

Using published Add In APIs the controlling program may insert a fragment of Visual Basic for Applications code into the user s workbook one for each declared table name uniquely tables can be declared on multiple sheets the user would supply the same name for all such fragments and fragments collections . Below is a sample code used in the current implementation. An exemplary code implementation may be as follows 

This makes Risk Rates a legal and callable Excel function whose purpose and usage was described in the first part of this paper. OL MTABLE GET is a function very similar to OL Get Prop and is described in greater detail below.

Since spreadsheet products in general and Excel in particular do not permit modification of context inside user written functions due to above rationales the execution structure of one embodiment of the present disclosure is based on a messaging protocol between the caller and the called. Basically the caller function sends a message to the target spreadsheet and returns an intermediate value. Target spreadsheet may be driven in sequence of calls emitted against it as per outstanding message queue .

Upon performing the calculation on behalf of a message it may deposit the response in a return message and proceed to calculate the response to the next. The return message is implemented as a wake up call to the source cell containing the calling expression. The cell is forced by it into recalculation calling the same function once again. This time however the special program which implements message broker logic may hand over the return value to the function code which may in turn return it to the spreadsheet product which may dutifully display it.

Spreadsheet products in general and Excel in particular have a propensity to call functions just in case relying on the them being free from side effects and to be faithful to the second principle of declarative languages same results for same inputs . Wake up calls therefore may be followed by just in case new invocations unless care is taken NOT to execute those the cycle of message out temporary return wake up return message can repeat endlessly.

Below is a description of steps taken by the calling function such as above described CREDIT RATE during its execution. These operations are being performed for one or more embodiments by the function previously referred to as OL call NEW which receives control from the calling function on each invocation.

First the location of the function invocation may be determined using standard published method APPLICATION.THISCELL. See Microsoft Office Excel 2007 Developer Reference incorporated herein by reference in its entirety. For example if CREDIT RATE . . . expression is found in a cell D14 of Sheet1 the run time value of the reference to may be Sheet1 SERVICE SHEET D 14.

Next the function inquires it had previously emitted a message requesting execution of an OL function and if so whether there is a waiting response. The responses are placed in a specially designated DOCUMENT SCRIPTING associative array and standard methods are provided by Microsoft to interrogate the presence of objects in it. Specifically during an ON OPEN event the following code designates the variable MsgPost as the associative array 

The following code places a return message directed towards the calling cell the program performing the operation may be described later in message broker section 

Special provisions may be made to handle cases when a cell contains expressions which invoke multiple OL functions or the same function multiple times as for example in 

When a call to an OL function is received from a location which already has the outstanding message requesting function execution it a determination may be made as to whether we are dealing with the subsequent invocation of the same function instance or a distinct instance located in the same cell. The criteria applied may be

If there are multiple invocations of the same function with the same exact parameters we may treat it as a single instance. If the function finds a response to its previously emitted call the return message may contain the callItem object described below which on return includes the return value. The function may retrieve it and return it to Excel for rendering to the user. An exemplary code fragment may be as follows 

If no responses to previous requests are found the function may send a new message requesting execution of the appropriate function. Using OLFunction  name object described above it may locate the declaration command for the function being called Set funcAddress wBcode.Names OLfucntion creditrate . RefersToRange method may be used as prescribed by the Microsoft Office Excel 2007 Developer Reference . It may parse out the parameters expected by it using the same parsing method as was used by ON CHANGE control program. It may verify that the number and the types of the parameters presented right now match those expected by the target function. If mismatch is discovered the error message may be returned and the function may exit. Otherwise 

It may create a new instance of callItem message object. The object may serve as a parcel destined for the roundtrip from caller to the message broker who may execute the request contained therein and back to the caller upon completion this time carrying the result. It may fill the object with the information specifying the request workbook and address of the declaration of the function being called values of parameters requested and locations of parameters expected and trace data to assist in problem resolution and trouble shooting. For example 

For the outgoing a different courier mechanism may be used. Instead of associative array a plain COLLECTION object may be used. The difference is motivated by the fact that unlike the SCRIPTING DOCUMENT the COLLECTION has a built in notion of order of messages. While this is not essential for the correct execution of the calculations the execution of calls in the sequence which Excel determined based on its logic has highest likelihood of best performance. For example 

The function may return a text indicating that the cell is waiting for response from the message broker. Excel may flash this text in the cell which may or may not be observed by the user depending on which worksheet it is and the speed of calculation. An exemplary code implementation may be as follows 

The return message may arrive instantaneously. The function command may be called again and perform the above described operations.

In order to perform tasks contained in messages send back responses and implement the wake up call there is a fragment of code referred to herein as Message Broker . Message Broker may be implemented as an ON CALCULATE event handler of the Add In program. According to Excel specification it is granted its execution time after all calculations on the sheet take place in other words after all the cells which Excel deems as in need to recalculate the value of our function have been invoked.

In order to assure non interference with both itself and other components of processing a special lock may be implemented in the system. One basic function is that both message broker and ON CHANGE event handler may abstain from activity while the lock is reserved. The lock may be reserved at the start of both ON CHANGE and Message Broker and released immediately before return. An exemplary code implementation may be as follows 

If OL pReserve rHSheetChange .pp 1 Then Exit Sub OLpReserve function sets the lock if it has not been set yet but returns if it finds it set.

In one embodiment the message broker proceeds as follows. For each outstanding message taking them off the queue one at a time it may move the inputs into the locations of the target spreadsheet known to it from the invisible name object which points to the function definition which contains its parameter addresses . An exemplary code implementation may be as follows 

This event causes Excel to recalculate the target spreadsheet with the new cell values parameters as per its primary behavior. This may in turn drive more calculate events all event handlers may become inactive when either one of them is doing work including Message Broker. Message Broker does not need to be granted control at this stage. It already has it. Message Broker may continue executing messages until it exhausts the queue. An exemplary code implementation may be as follows 

If the target spreadsheet itself contains calls to downstream functions the message queue may have additional members added to it during the step of target calculation. Message broker has special provision by which he may assure to process all the messages emitted by the target and by downstream targets too during calculation call for a particular client message before declaring this message fully serviced and putting it into return post. This may be accomplished by pushing the entire outstanding message queue aside creating a new message queue into which all messages created during servicing the message would be deposited. The message broker may call itself recursively except this time it may read from the new message queue. The operation can repeat for as long as there are functions calling further functions. When the downstream chain of function calls gets exhausted the message broker may return. At this point it may drop the special new queue and recover the one it set aside and proceed with the next message residing there. An exemplary code implementation may be as follows 

Call OLfuncCtl in case the special post office has downstream calls process them by calling message broker recursively

When the calculation of the target completes which may occur after the last parameter is moved in the execution returns back to Message Broker as from the function call . Message Broker may obtain function s result from the declared return cell and deposit it in the callItem messaging object to be deposited in the MsgPost queue described earlier in On Demand section destined for the cell which contains the function reference. An exemplary code implementation may be as follows 

A wake up call may then be directed towards the cell that contains function reference known to the message broker from the call Item object being processed. The cell may be made dirty in Excel terminology which in turn causes Excel to call the function defined in cell formula as per its primary logical definition. In some releases of Excel the wake up is accomplished by executing RANGE.FORMULA RANGE.FORMULA method on the RANGE which is the cell containing the reference.

The Message Broker may then return execution of control to Excel and releases the lock when and only when there are no more messages in the queue to process. At this stage the process may dictate that all cells in the workbook which contain function calls are in calculated states. Excel goes quiet and the user gets control of the active worksheet.

The service layer implementation choices are nearly infinite. One implementation may use a series of VBA techniques to overcome some programmatic limitations of VBA. The storage may be reserved as variable size array of variants for example DIM DataT AS VARIANT. Both database and tables maintain logical notion of rows and columns within rows with the provision that some columns may contain a reference to multi value collections more rows . Language reference in VBA needs to be Array i j k . . . n which is possible as a direct syntax. In order to ease the implementation of a priori undetermined number of reference levels the technique of calling a reference function recursively may be deployed as follows 

On the recursive invocation the data array may popped up two levels and driven into row i column j position. The recursion proceeds during the search until either a search criteria is determined unfulfillable or the target item is found at which point the recursion may unwind. DataT being declared as Public Global variable permits modifications such as filling empty elements with more array data from inside these functions. During processing of declaration phases the program may create a dictionary structure which defines attributes of every property of the data model or the dimension of every table .

Data access functions inserted into users workbook just as in the case of OL functions immediately pass control to OL standard functions OL Get Prop and MTableGet correspondingly. These perform the following operations. They interpret the provided parameters each according to its own proper syntactical convention analyze for errors report if found. They devise the array of access keys to follow the chain of recursive array for the appropriate number of levels. For each level of recursion the access key contains a the identity of the data field sought by the user and b the value for the key or array index to be used in lieu of the key. The function s result as returned is determined by the type of object being requested. For a regular field property of the data model as well as for the value of Table cell the result is actual value of the field or cell sought. For a head of a collection person friends address history it is an object Id or key . Key is a string which includes all information necessary to obtain the exact location of the sub array of values for each field property which belongs to a particular instance of the collection. For example a key for PERSON 072 219 is a string OL KEY 0 1 C Person 3 1 R 072 219 from which it can be obtained that all fields belonging to this collection instance can be found at location DataStorage 0 3 . This means that CID Person 072 219 is found at DataT 0 3 0 while Last Name Person 072 219 at DataST 0 3 2 etc.

If one of the parameters is a partial key of a parent object it may be disaggregated into the array of the above structure. For example a reference to Friends 2 Person 1 may return the key 

This key may be disaggregated into the access array providing a starting position DataT 0 0 12 1 to be used for the subsequent search. The disaggregated key also contains the information about the collection itself. This permits resolving any ambiguity of references. For example the property Start Year exists in multiple collections it is a key property of Address History collection for each Person it is also found in Schools Jobs Summer Schools etc. Last Name is a property of Person but since Friends have same properties as Persons the reference Last Name is inherently ambiguous.

A proper property reference however is a fully cascade of functions coded directly or through intermediate cells as in Start Year Address History 2 Person 072 219 or Last Name Friends 963 173.3 Person 072 219 . Since the functions may be called in inside out order by Excel OL Get Prop function may receive the appropriate collection key as one of its inputs. It may therefore recognize which instance of the property among the multiple possibilities it should treat as the target of the query.

If the value of the sought property or table cell is not found either because the parent collection does not have the instance or the property contains NULL the function causes Excel to display N A error value in the cell by using Excel CVerr vbNA standard call documented in Microsoft Office Excel 2007 Reference. Upon receiving control back from OL GetProp or MTableGet the part of the code which had been inserted into the user s workbook may complete the logic by presenting the returned value back to Excel in the proper datatype. An exemplary code implementation may be as follows 

As can be appreciated the present disclosure permits a business domain specialist working in a spreadsheet to declare an arbitrary section of his or her model coded in the spreadsheet as a new command now callable from anywhere in the spreadsheet without having to call on the services of anyone with the programming language skills. The new command is available to the person working in the spreadsheet as well to the members of the person s team when he or she is operating in the team environments.

Artisans would appreciate that the present disclosure can benefit individuals and project teams engaged in development of software applications and components of software applications which deal with analytically sophisticated problems such as 

The present disclosure may be applicable in the more generic domain of Business Intelligence discipline delivering unique benefits to individuals and teams engaged in development and maintenance of analytically more sophisticated class of reports such as management reporting and dashboards. In some cases it may be useful in maintenance of statutory reports as well.

The lingua franca of business decision maker is a spreadsheet. The language of software application is a combination of database definitions and data management methods object models functions and procedures user interfaces all written in a plethora of programming and modeling languages available at any given point in time and constantly evolving.

In one embodiment the processor may be programmed to translate from a spreadsheet language to a software language using the translation module . It may also define the method and the process of translation. It defines the method and scope of applicable backward translation from software into spreadsheet .

In one practical implementation the processor may be programmed to evaluate general extensions in a specific spreadsheet language for example Microsoft Excel using one of the published and fully Microsoft supported Excel extension frameworks. The present disclosure can be implemented to other spreadsheet products as well.

One commercial implementation of the present disclosure plans to deliver a working translation between the Excel language and an Open Source software application backbone such as OpenL. The resulting technology may allow business specialists in the target domains to manufacture new additional components of existing software applications such as for example adding a premium rates management component to an insurance business process management application as well as to create a whole new application such as for example a portfolio performance measurement dashboard for a private equity fund with greatly reduced and in many cases completely eliminated need for slow and costly involvement of IT personnel.

In one embodiment the declaration command can be implemented with other spreadsheet products especially spreadsheet products that can be extended by third parties. While some products notably Excel publish an open extension framework which would permit third parties to implement embodiments of the invention others can be extended by their manufacturers.

As is understood by a person skilled in the art the syntax described herein is for illustration purpose only. Based on the grammar of the spreadsheet language extension described here the syntax is open to implementers to decide. For example while the use of keywords DECLARE FUNCTION to specify the user s directive to create a new function in Excel is described herein any other combination of keywords expressing the same directive can be used.

As can be appreciated the present disclosure may be utilized for the modern software environments which include Object Modeling layer as a prerequisite dependency. The present disclosure may also be used in archaic software environments such as COBOL based systems built during pre MDA or even pre Relational epochs .

In this description various functions and operations may be described as being performed by or caused by software code to simplify description. However those skilled in the art may recognize that what is meant by such expressions is that the functions result from execution of the code instructions by a processor such as a microprocessor. Alternatively or in combination the functions and operations can be implemented using special purpose circuitry with or without software instructions such as using Application Specific Integrated Circuit ASIC or Field Programmable Gate Array FPGA . Embodiments can be implemented using hardwired circuitry without software instructions or in combination with software instructions. Thus the techniques are limited neither to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system.

While some embodiments can be implemented in fully functioning computers and computer systems various embodiments are capable of being distributed as a computing product in a variety of forms and are capable of being applied regardless of the particular type of machine or computer readable media used to actually effect the distribution.

At least some aspects disclosed can be embodied at least in part in software. That is the techniques may be carried out in a computer system or other data processing system in response to its processor such as a microprocessor executing sequences of instructions contained in a memory such as ROM volatile RAM non volatile memory cache or a remote storage device.

Routines executed to implement the embodiments may be implemented as part of an operating system or a specific application component program object module or sequence of instructions referred to as computer programs. The computer programs typically include one or more instructions set at various times in various memory and storage devices in a computer and that when read and executed by one or more processors in a computer cause the computer to perform operations necessary to execute elements involving the various aspects.

A machine readable medium can be used to store software and data which when executed by a data processing system causes the system to perform various methods. The executable software and data may be stored in various places including for example ROM volatile RAM non volatile memory and or cache. Portions of this software and or data may be stored in any one of these storage devices. Further the data and instructions can be obtained from centralized servers or peer to peer networks. Different portions of the data and instructions can be obtained from different centralized servers and or peer to peer networks at different times and in different communication sessions or in a same communication session. The data and instructions can be obtained in entirety prior to the execution of the applications. Alternatively portions of the data and instructions can be obtained dynamically just in time when needed for execution. Thus it is not required that the data and instructions be on a machine readable medium in entirety at a particular instance of time.

Examples of computer readable media include but are not limited to recordable and non recordable type media such as volatile and non volatile memory devices read only memory ROM random access memory RAM flash memory devices floppy and other removable disks magnetic disk storage media optical storage media e.g. Compact Disk Read Only Memory CD ROMS Digital Versatile Disks DVDs etc. among others.

The computer readable media may store the instructions. In general a tangible machine readable medium includes any mechanism that provides i.e. stores and or transmits information in a form accessible by a machine e.g. a computer network device personal digital assistant manufacturing tool any device with a set of one or more processors etc. .

In various embodiments hardwired circuitry may be used in combination with software instructions to implement the techniques. Thus the techniques are neither limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system.

Although some of the drawings illustrate a number of operations in a particular order operations which are not order dependent may be reordered and other operations may be combined or broken out. While some reordering or other groupings are specifically mentioned others may be apparent to those of ordinary skill in the art and so do not present an exhaustive list of alternatives. Moreover it should be recognized that the stages could be implemented in hardware firmware software or any combination thereof.

The disclosure includes methods and apparatuses which perform these methods including data processing systems which perform these methods and computer readable media containing instructions which when executed on data processing systems cause the systems to perform these methods.

While the methods and systems have been described in terms of what are presently considered to be the most practical and preferred embodiments it is to be understood that the disclosure need not be limited to the disclosed embodiments. It is intended to cover various modifications and similar arrangements included within the spirit and scope of the claims the scope of which should be accorded the broadest interpretation so as to encompass all such modifications and similar structures. The present disclosure includes any and all embodiments of the following claims.

It should also be understood that a variety of changes may be made without departing from the essence of the invention. Such changes are also implicitly included in the description. They still fall within the scope of this invention. It should be understood that this disclosure is intended to yield a patent covering numerous aspects of the invention both independently and as an overall system and in both method and apparatus modes.

Further each of the various elements of the invention and claims may also be achieved in a variety of manners. This disclosure should be understood to encompass each such variation be it a variation of an embodiment of any apparatus embodiment a method or process embodiment or even merely a variation of any element of these.

Particularly it should be understood that as the disclosure relates to elements of the invention the words for each element may be expressed by equivalent apparatus terms or method terms even if only the function or result is the same.

Such equivalent broader or even more generic terms should be considered to be encompassed in the description of each element or action. Such terms can be substituted where desired to make explicit the implicitly broad coverage to which this invention is entitled.

It should be understood that all actions may be expressed as a means for taking that action or as an element which causes that action.

Similarly each physical element disclosed should be understood to encompass a disclosure of the action which that physical element facilitates.

In this regard it should be understood that for practical reasons and so as to avoid adding potentially hundreds of claims the applicant has presented claims with initial dependencies only.

To the extent that insubstantial substitutes are made to the extent that the applicant did not in fact draft any claim so as to literally encompass any particular embodiment and to the extent otherwise applicable the applicant should not be understood to have in any way intended to or actually relinquished such coverage as the applicant simply may not have been able to anticipate all eventualities one skilled in the art should not be reasonably expected to have drafted a claim that would have literally encompassed such alternative embodiments.

Further the use of the transitional phrase comprising is used to maintain the open end claims herein according to traditional claim interpretation. Thus unless the context requires otherwise it should be understood that the term compromise or variations such as comprises or comprising are intended to imply the inclusion of a stated element or step or group of elements or steps but not the exclusion of any other element or step or group of elements or steps.

Such terms should be interpreted in their most expansive forms so as to afford the applicant the broadest coverage legally permissible.

