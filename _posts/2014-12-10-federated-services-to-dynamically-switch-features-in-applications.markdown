---

title: Federated services to dynamically switch features in applications
abstract: An application binary is received at an intermediate federated service layer before deployment of the application binary at the application store. At the intermediate federated service layer multiple copies of application binaries are generated concurrently. At the intermediate service layer, program code of the copies of application binaries is concurrently parsed and features of copies of application binaries are matched with features of operating system. If the features match, corresponding program codes are flagged to switch off, and re-generated as custom application binary and deployed in application store. The custom application binary and a container along with features corresponding to operating system of a mobile device are downloaded to a mobile device. A request to access a set of features is received from the custom application binary at the container. If the set of features match the features of the operating system request is allowed through the container else it's blocked.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268561&OS=09268561&RS=09268561
owner: SAP SE
number: 09268561
owner_city: Walldorf
owner_country: DE
publication_date: 20141210
---
Mobile applications are developed to execute on different kinds of client devices such as mobile phones electronic tablets portable computers etc. Typically the mobile applications are developed for specific versions of operating system or platform. The development effort is directly proportional to the number of versions of operating systems. If an application is developed for a latest version of an operating system the application may support or be compatible with one or more earlier versions of the operating system however for the application to be compatible with a complete set of earlier versions of the operating systems the application may have to be developed for the individual earlier versions of the operating systems. It is challenging to develop an operating system version agnostic application that is compatible across operating systems versions or platforms.

Embodiments of techniques for federated services to dynamically switch features in applications are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. A person of ordinary skill in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In some instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

For example displaying direction in a digital map may be a function. An individual function in the application 1 may correspond to a feature or a number of features. The features may be hardware based such as a magnetometer sensor software based such as application widgets based on the version of operating system etc. For example the displaying direction in a digital map function may correspond to a feature of accessing or reading data to and from a magnetometer sensor available in a client device such as a mobile device where the magnetometer sensor is used to identify cardinal directions.

Various techniques of parsing the program code for features and or functionalities may be used. One such technique is static analysis where the program code is scanned line by line and keywords corresponding to features are used to identify features in the program code. For example various keywords such as sensor type magnetic field magnetic field calibrated magnetic north etc. can be used to identify the feature magnetometer sensor in the program code of application 1 binary. Application 1 may be a three dimension compass application that uses data from the underlying magnetometer sensor in the mobile device. Similarly application 1 may use various other features such as gyroscope sensor microphone speaker etc. of the mobile device to execute the application effectively.

 Application 1 binary may be deployed in application store corresponding to various versions of operating systems. The various versions of operating systems may include major versions such as major version increments like version 1.0 version 2.0 etc. and minor versions such as minor version increments like version 1.1 version 1.2 etc. The various versions of operating systems may also include operating systems from various vendors and platforms such as Android iOS Microsoft Windows BlackBerry etc. Individual versions of the operating systems support certain sets of features for example versions of operating systems such as Android 4.0 and Android 2.3 support gyroscope sensor whereas the versions of operating systems Android 2.2 and Android 1.5 do not support gyroscope sensor.

While the code scan service in the intermediate federated service layer concurrently parses or scans the program code in the individual copies of the application 1 binary switch features service in the intermediate federated service layer compares the features of copies of the application 1 binary with features of the corresponding versions of operating systems. A custom switch in the form of a label or flag may be injected and defined with two states ON and OFF in the copies of the application 1 binary. The injection or code injection of a custom switch may use any form of custom code injection techniques. Code may also be injected to perform other functions such as add a missing function call exception handling etc. When the features of the copies of the application 1 binary do not match with features of the corresponding versions of operating systems switch features service identifies portions of program code in functions corresponding to the features not matched. Switch flags are injected and sets to OFF at the start of identified portions of program code in the copies of the application 1 binary to disable the features that are not matched. Setting the switch flags to OFF indicates disabling the portions of program code in the copies of the application 1 binary that are not matched or not supported by the corresponding versions of operating systems. Disabled portions of program code remains unexecuted until enabled again by setting the switch flags to ON .

When the features of copies of the application 1 binary match with features of the corresponding versions of operating systems switch features service identifies portions of program code in functions corresponding to the matched features. Switch flags are injected and set to ON at the start of the identified portions of program code in the copies of the application 1 binary that are matched or supported by the corresponding versions of operating systems. Setting the switch flags to ON indicate enabling the portions of program code in the copies of application 1 binaries. In some cases the portions of program code are enabled by default and setting the switch flags to ON may be optional. The portions of program code that are enabled are executed in the copies of the application 1 binary. After the switch features service sets the switch flags to ON and OFF in the copies of the application 1 binary they are re generated as custom application binaries that are compliant or compatible with the corresponding versions of operating systems. For example a copy of application 1 binary is re generated as a first custom application 1 binary that is compliant or compatible with the operating system 1 version. The first custom application 1 binary is automatically deployed in the application store corresponding to operating system 1 version.

Similarly another copy of application 1 binary is re generated as second custom application 1 binary that is compliant compatible with the operating system N version. The second custom application 1 binary is automatically deployed in the application store corresponding to version operating system N . Similarly application N can be automatically deployed as a first custom application N corresponding to operating system 1 and can be automatically deployed as a second custom application N corresponding to operating system N .

In one embodiment a new application binary may be developed for a latest version of operating system and using intermediate federated service layer the new application binary can be deployed in corresponding lower versions of operating systems. While the code scan service concurrently parses or scans the program code of copies of the new application binary switch features service compares the features of the copies of the new application binary with the features of corresponding lower versions of operating systems. When the features in the copies of the new application binary do not match with features of the corresponding lower versions of operating systems switch features service identifies portions of program code in functions corresponding to the features not matched. Switch flags are injected and set to OFF at the start of the identified portions of program code in the copies of the new application binary. The copies of the new application binary is re generated as new custom application binaries that are compliant compatible with lower versions of operating systems and deployed in the application store .

In one embodiment a new application binary may be developed with future enhancements features but the future enhancements features may be disabled in a specific version of the new application binary. Using intermediate federated service layer the new application binary can be deployed in corresponding versions of operating systems. While the code scan service concurrently parses or scans the program code of copies of the new application binary switch features service in the intermediate federated service layer compares the disabled future enhancements features with the features of corresponding versions of operating systems. When the disabled future enhancements features match with the features of the corresponding versions of operating systems switch features service identifies portions of program code in functions corresponding to disabled future enhancements features. Switch flags are injected and set to ON at the start of the identified portions of program code to enable the disabled future enhancements features in the copies of the new application binary. The copies of the new application binary are re generated as new custom application binaries that are compliant compatible with corresponding versions of operating systems and deployed in the application store .

In one embodiment a new version of application such as a major version or a minor version may be deployed corresponding to various versions of operating systems in the application store . For example a new version of application 1 binary such as application 1.1 may be ready for deployment that may include updates i.e. additional features bug fixes etc. in comparison to the prior version of application 1 binary. While the code scan service concurrently parses or scans the program code of copies of the application 1.1 binary switch features service compares the features of copies of the application 1.1 binary with the features of corresponding versions of operating systems. When the features of copies of the application 1.1 binary match the features of the corresponding versions of operating systems switch features service identifies portions of program code in functions corresponding to matched features. Switch flags are injected and set to ON at the start of the identified portions of program code. When the features in the copies of application 1.1 binaries do not match with features of the corresponding versions of operating systems switch features service identifies portions of program code in functions corresponding to the features that are not matched. Switch flags are injected and set to OFF at the start of identified portions of program code in the copies of application 1.1 binaries. The application 1.1 binaries are re generated as custom application 1.1 binaries that are compliant compatible with corresponding versions of operating systems and deployed in the application store .

In one embodiment new versions of operating systems may be available. Database update service may be a lookup service that looks up for new versions of operating systems release from various sources and updates the master database . For example database update service may use Rich Site Summary RSS to subscribe to various other sites to retrieve features corresponding to new versions of operation systems as RSS feeds and the RSS feeds are updated in the master database . In one embodiment manual update of master database may be used to manually enter the features corresponding to new versions of operating systems. The master database has updates of different versions of operating systems and their corresponding features. When a new version of operating system 1 is available such as operating system 1.1 features corresponding to operating system 1.1 are updated in the master database . Application 1 is to be deployed corresponding to the operating system 1.1 in the application store . Code scan service is used to scan the program code corresponding to a copy of application 1 binary. Switch features service sets switch flags to ON and OFF corresponding to features in the program code in the copy of application 1 binary supported by the operating system 1.1 . The copy of application 1 binary is re generated as a custom application 1 binary that is compliant compatible with the operating system 1.1 version. The custom application 1 binary is deployed in the application store corresponding to operating system 1.1 version. Similarly other applications are re generated as custom application binaries and deployed corresponding to operating system 1.1 version.

The application 1 binary is to be deployed corresponding to various versions of operating systems such as operating system 1 operating system 2 operating system N etc. Operating system 1 supports various features such as feature B feature N etc. The application 1 binary is received at an intermediate federated service layer prior to deployment at the application store . At the intermediate federated service layer multiple copies of the application 1 binary corresponding to various versions of operating systems are generated concurrently. Code scan service in the intermediate federated service layer concurrently and or consecutively parses or scans the program code in the individual copies of the application 1 binary. When the code scan service parses the program code in a copy of the application 1 binary the features supported by the copy of the application 1 binary such as feature A feature B feature C and feature N are compared with the features corresponding to the operating system 1 such as feature B and feature N .

 Feature A and feature C of the copy of the application 1 binary does not match with the features of the operating system 1 and the switch features service identifies portion of program code in function A and portion of program code in function C and injects switch flags and sets the switch flags to OFF . The copy of the application 1 binary is re generated as a custom application 1 binary. The custom application 1 binary is deployed in the application store corresponding to the operating system 1 . Similarly custom application 1 binary and custom application 1 binary are concurrently re generated and deployed for the available version of the operating systems operating system 2 and operating system N respectively in the application store .

Upon determining that features associated with the copies of the application binary do not match features corresponding to versions of the operating systems at portions of program code in functions corresponding to the features not matched are identified. Switch flags are injected and concurrently set to OFF at the start of identified portions of program code corresponding to the features in the corresponding copies of the application binary. At custom application binaries corresponding to the copies of the application binary are dynamically re generated. At the re generated custom application binaries are automatically deployed in corresponding versions of operating systems in the application store. Process steps to may be performed in the intermediate federated service layer.

For example consider a scenario where a request is received from mobile device to download application 1 application 3 and application N from the application store . When a request is received from a client device such as a mobile device to download applications from the application store the application store determines that container 1 is supported by operating system 1 executing in the mobile device . A notification to download and install container 1 is displayed in the mobile device . The user may choose to download container 1 and install in the mobile device . Alternatively the user may choose to download and install container 1 at a later point of time. The container 1 is downloaded and installed once for the first time and that may be an automatic download or a manually initiated download. Whenever container 1 is updated to a new version the new version of container 1 can be updated automatically from the application store . The applications application 1 application 3 and application N along with container 1 are downloaded to the mobile device from the application store . The container 1 may be downloaded in parallel with the applications application 1 application 3 and application N or the applications may be downloaded immediately following the download of the container 1 . The downloaded applications are executed within the container 1 on the mobile device .

The container 1 in the application store retrieves features corresponding to operating system 1 from the master database . The applications application 1 application 3 and application N execute within the container 1 in the mobile device . During execution or running of the applications the container 1 intermediates the interactions between the applications application 1 application 3 and application N and the operating system 1 . The container 1 handles function calls from the applications and determines whether to delegate the function calls to the operating system 1 or not. The applications application 1 application 3 and application N may have a certain set of features and the applications may request access to corresponding set of features in the operating system 1 via the container 1 . The container 1 intercepts the requests received from the applications and compares the set of features of the applications with the features corresponding to the operating system 1 . The requests may be in the form of a function call such as API call. When the set of features of the applications matches with the features of the operating system 1 the requests to access are allowed through the container 1 and delegated to the operating system 1 . When the set of features of the applications does not match with the features of the operating system 1 the requests to access are not allowed through the container 1 and the requests are blocked at the container 1 . The allowing and blocking of requests to access occurs at runtime when the applications are executing or running within the container 1 in the mobile device .

In one embodiment when the user downloads container 1 and installs in the mobile device the user may choose to set the container 1 as a default container for the applications currently installed in the mobile device . When the container 1 is set as a default container the previously installed applications and the applications that may be installed in the future may execute within container 1 as explained above. In another embodiment when the user may not choose to set the container 1 as a default container the applications installed along with the container 1 or the applications selected by the user may execute within the container 1 . In this scenario the applications not selected execute outside the container 1 . Individual applications can be selected and configured to execute within the container 1 based on a customizable user setting .

In one embodiment the operating system 1 in the mobile device can be updated or upgraded to a newer version such as operating system 2.1 . The database update service determines the new operating system 2.1 availability and updates the master database with the operating system 2.1 corresponding features. When the operating system 1 is updated to operating system 2.1 in the mobile device the update service requests the master database to receive updated features corresponding to operating system 2.1 from the master database . The update service updates the container 1 with updated features corresponding to operating system 2.1 in the mobile device . The container 1 intercepts the request received from the applications and compares the set of features of the applications with the updated features corresponding to the operating system 2.1 . When the set of features of the applications matches the updated features of the operating system 2.1 the request to access is allowed through the container 1 to the operating system 2.1 at runtime. When the set of features of the application does not match the updated features of the operating system 2.1 the request to access is not allowed through the container 1 and the request is blocked at the container 1 at runtime.

In one embodiment the applications such as application 1 application 3 and application N can be updated or upgraded to newer versions with additional features. For example if application 1 is updated to a new version such as application 1.1 the new version application 1.1 is downloaded and executed within the container 1 . The container 1 intercepts the request received from the application 1.1 and compares the set of features of the application 1.1 with the features corresponding to the operating system 1 . When the set of features of the application 1.1 matches the features of the operating system 1 the request to access is allowed through the container 1 to the operating system 1 at runtime. When the set of features of the application 1.1 does not match the features of the operating system 1 the request to access is not allowed through the container 1 and the request is blocked at the container 1 at runtime.

For example when a request is received from application 1 in the form of an application programming interface API call to access feature B in the operating system 1 the container 1 intercepts the received API call and compares feature B of application 1 with the features corresponding to operating system 1 such as feature A feature B feature C feature D and feature N in the container 1 . The feature B of application 1 matches the feature B associated with the operating system 1 and the API call is allowed through the container 1 to the operating system 1 at runtime. When a request is received from application 1 in the form of an API call to access feature F associated with the operating system 1 feature F of application 1 is compared with the features of the operating system 1 in the container 1 . The feature F of application 1 does not match the features of the operating system 1 and the API call is blocked at the container 1 at runtime. In one embodiment the database update service receives updates of operating systems and updates the master database . The update service requests the master database to receive updates of operating systems to the container 1 as explained in detail with reference to .

In one embodiment federated services to dynamically switch features in applications in a combination of deploy time and run time is explained below. Consider a scenario where a game application binary is to be deployed corresponding to various versions of operating systems such as android 1.5 android 2.3 and android 4.0 in an application store. Game application supports features such as gyroscope sensor ambient light sensor etc. The operating system android 2.3 supports features such as gyroscope sensor accessing multiple cameras etc. android 4.0 supports features such as gyroscope sensor Wi Fi P2P etc. The game application binary is received at an intermediate federated service layer prior to deployment at the application store. At the intermediate federated service layer multiple copies of the game application binaries are generated concurrently. While code scan service scans or parses the program code in a first copy of the application binary the switch features service identifies that the feature in the first copy of game application binary such as ambient light sensor does not match with the features gyroscope sensor and Wi Fi P2P of the android 4.0 operating system and switch flags are set to OFF at the start of portions of program code in the first copy of game application binary. The first copy of game application binary is packaged and re generated as a first custom game application binary and is deployed in the application store corresponding to android 4.0 operating system.

The application store also includes a container supported by Android operating system to provide a runtime execution environment for the game application . A request is received from a mobile device to download first custom game application binary from the application store. Based on the request received from the mobile application the application store determines the container supported by the Android operating system executing in the mobile device. The container in the application store retrieves features of android 1.5 operating system such as auto pairing live folders etc. from the master database. In response to the received request from the mobile device the container with the features auto pairing live folders of operating system android 1.5 along with first custom game application binary is downloaded to the mobile device from the application store. When an API function call to access gyroscope sensor is received from the first custom game application binary executing in the container in the mobile device the container intercepts the received API call and matches feature gyroscope sensor of the first custom game application binary with the features auto pairing live folders of operating system android 1.5 . The feature gyroscope sensor of the first custom game application does not match with the features of android 1.5 operating system and accordingly the API function call to access gyroscope sensor is blocked at the container.

The various embodiments described above have a number of advantages. With the federated services to dynamically switch features in applications in both deployment time and runtime applications can be developed to be compatible with one version of operating system and during deploy time and or runtime implementations described above the applications can be made compatible with any version of operating system automatically without additional effort or human intervention. There is no additional development effort required by application developers to develop separate applications compatible with individual versions of operating systems. The federated services to dynamically switch features in applications are compatible with different platforms or versions of operating systems.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open Data Base Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in detail.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the one or more embodiments are described herein for illustrative purposes various equivalent modifications are possible within the scope as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

