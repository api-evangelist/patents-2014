---

title: Code optimization based on customer logs
abstract: A system includes reception of a plurality of findings output by runtime checks executed by a plurality of computing systems, determination of whether a first one of the findings is a duplicate of an already-stored finding, storage, in a case it is determined that the first finding is not a duplicate of an already-stored finding, of the first finding in association with a finding identifier, and generation of a message including the finding identifier and information describing a problem associated with the finding.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600505&OS=09600505&RS=09600505
owner: SAP SE
number: 09600505
owner_city: Walldorf
owner_country: DE
publication_date: 20140923
---
According to conventional database architectures a client application interacts with an application executing on an application server. In response to requests received from the client application the application acquires stored data from an underlying database system performs any necessary processing and provides a response to the client application.

Recently developed database architectures integrate transaction based e.g. Online Transaction Processing and analytics based e.g. Online Analytical Processing processing with the underlying database system. These architectures support execution of applications within the database system i.e. without the need of an application server . These database systems may support existing database programming languages but some existing application code in certain programming languages may need to be adapted in order to perform as intended.

The aforementioned database systems may implement an in memory database whose high performance processing allows performance critical portions of business logic to be executed at the database level. An in memory database may utilize columnar data storage and existing application code may benefit from optimizations which leverage such columnar storage.

Adaptation and or optimization of application code for execution in conjunction with databases may proceed via manual analysis or using static code analyzing tools. Such approaches are unsatisfactory in view of the typical enormous number of source code lines and the use of dynamic coding. Moreover static code analyzing tools exhibit a high rate of false positives which eventually require manual analysis. Runtime checks are more efficient and effective but it is not possible to cover all portions of code and every business aspect with such checks.

The following description is provided to enable any person in the art to make and use the described embodiments and sets forth the best mode contemplated for carrying out some embodiments. Various modifications however will remain readily apparent to those in the art.

Briefly some embodiments operate to transfer the logs of checks running in several disparate deployed systems to a central repository and to optimize application code based on the logs.

Each of systems is a computing system which executes application code. For example system may comprise a computing system executing a suite of business applications for an enterprise. At least a portion of the code of the business applications may be executed at the database level. Each of systems may comprise a customer of a developer of the suite of business applications.

Each of systems also executes runtime checks which analyze the corresponding system at runtime. These runtime checks may be provided by the developer of the application code or developed by the entities managing each of systems e.g. customer specific checks . The runtime checks may be selectively activated within each of systems and do not analyze application source code.

In one example a runtime check executed by one of systems records all events where a SELECT into an unsorted internal table without an ORDER BY clause or subsequent SORT is followed by specific statements that require the internal table to be sorted such as AT NEW AT END OF AT FIRST AT LAST DELETE ADJACENT DUPLICATES FROM . . . READ TABLE . . . BINARY SEARCH. This check may detect source code which may not work as expected. Every check record in the result view provides two source code positions the position in which the SELECT statement is located and the position in which the statement which requires the internal table to be sorted occurs. The call stack of the latter is available via the corresponding context menu for the check record.

In another example a runtime check records all events where the internal table itab in the clause . . . FOR ALL ENTRIES IN itab within a SELECT statement is empty. In such cases the runtime engine might ignore the WHERE condition in the same SELECT statement. Consequently all rows from the database table are returned in the result set of the SELECT statement. This is not the intended behavior in most cases.

The log data generated by the checks is transferred from systems to system according to any synchronous or asynchronous schedule. Each system may transfer the log data according to its own respective schedule. According to some embodiments no business data is transferred. Rather the log data includes only metadata which is needed to understand the problem. According to some non exhaustive examples the metadata may specify activated functionality memory usage and support packages.

Performance of the checks may result in creation of messages for storage among test dashboard messages . Messages are made available to terminal which may use the messages to inform modification of development code .

Initially at S a plurality of findings are received. The findings are output by runtime checks of customer computing systems. As used herein a finding consists of any information describing a real or potential problem caused by application code. A finding may identify an error or an opportunity for code optimization.

Transmission of the findings may occur at any time or according to any schedule. For example findings may be received at S whenever new findings are available and when previously received findings have been completely processed according to process .

Application programming interface implements a function IMPORT NEW DATA. The function takes data available in storage device and transfers it to tables of customer data . Any old data within customer data from previous transfers is overwritten.

One of the newly received findings is identified in S. For example a first finding of customer data may be identified in S. Next at S it is determined whether the identified finding is a duplicate of an already stored finding. In this regard as will be further understood from the description below tables of processed data store findings which have previously been received. If the finding identified at S is not a duplicate of a finding stored in processed data the finding is stored in processed data along with an associated finding ID. Flow then proceeds to S to determine whether any other findings which were received at S remain in customer data . If so flow returns to S to identify another finding.

If it is determined at S that an identified finding is a duplicate of an already stored finding flow proceeds to S. At S it is determined whether the finding has been addressed by a support package. For example the record of the existing finding in processed data may indicate that a correction for the existing finding has already shipped with a certain support package. If so it is also determined whether the customer associated with the finding of customer data has this support package. If not e.g. due to a low level or expired service agreement flow proceeds to S to ignore the finding and on to S.

Flow proceeds from S to S if the duplicate finding has not been addressed by a support package or if it has been addressed by a support package of the associated customer. At S it is determined whether the finding is assigned to an exception. In this regard exceptions table associates exceptions with various finding IDs. An exception associated with a particular finding ID may indicate that the finding is not relevant and the new duplicate finding should be ignored. The ability to record exceptions may be useful in case that a runtime check reports false positive findings where no correction is needed. Flow proceeds to S to ignore the finding of customer data if the corresponding duplicate finding of processed data is assigned to an exception.

Alternatively if the corresponding duplicate finding of processed data is not assigned to an exception it is determined at S whether the finding was recently stored in processed data . If so the finding may still be in the process of being addressed and therefore it is not necessary to store the newer duplicate finding in processed data . Flow therefore proceeds to S.

If it is determined at S that the finding was not recently stored in processed data the existing finding may be marked as outdated in processed data and flow returns to S. As described above S includes storage of the new finding and an associated finding ID in processed data .

Flow continues to cycle among S through S as described above until it is determined at S that no more received findings of customer data remain to be processed. At this point a message is generated for each finding of processed data which was stored at S i.e. the newly stored findings and not the findings stored in processed data prior to execution of process . For each stored finding the generated message includes an associated finding ID information describing a problem and information describing a proposed solution.

According to some embodiments data consolidator passes a newly stored finding of processed data to test dashboard framework . Optimization check class executes a check of the finding within the framework and generates a message at S based on the results of the check. The message is stored among dashboard messages . The foregoing process repeats for each newly stored finding.

A developer may operate computing device to access test dashboard messages user interface . Test dashboard messages user interface displays the dashboard messages generated at S. If the developer implements a software optimization or other correction based on one of the messages the developer accesses exceptions and resolutions user interface to input an identifier of the optimization correction and an identifier of a support package including the optimization correction. This identifiers are stored in processed data table via API in association with the finding based on which the message was generated. In this regard each message may include a finding ID of the finding based on which the message was generated.

Similarly if the developer reviews a message in user interface and determines that the message need not be addressed the developer accesses exceptions and resolutions user interface to input an exception for the message. An indication of the exception is stored in exceptions table in association with the finding based on which the message was generated using the finding ID specified in the message.

According to some embodiments once a correction or optimization is implemented and offered to customers e.g. via instructions and or via a support package and the correction optimization begins to be applied to customer systems the number of received findings associated with the correction optimization will decrease. Once the correction optimization is applied to all customer systems the associated findings should cease to be received.

Apparatus includes processor operatively coupled to communication device data storage device one or more input devices one or more output devices and memory . Communication device may facilitate communication with external devices such as a reporting client or a data storage device. Input device s may comprise for example a keyboard a keypad a mouse or other pointing device a microphone knob or a switch an infra red IR port a docking station and or a touch screen. Input device s may be used for example to enter information into apparatus . Output device s may comprise for example a display e.g. a display screen a speaker and or a printer.

Data storage device may comprise any appropriate persistent storage device including combinations of magnetic storage devices e.g. magnetic tape hard disk drives and flash memory optical storage devices Read Only Memory ROM devices etc. while memory may comprise Random Access Memory RAM .

Each of data consolidator API test dashboard framework and check class may comprise program code executed by processor to cause apparatus to perform any one or more of the processes described herein. Embodiments are not limited to execution of these processes by a single apparatus. Data may comprise one some or all of customer data processed data exceptions and dashboard messages as described above. Data storage device may also store data and other program code needed for providing database functionality and or which are necessary for operation of apparatus such as device drivers operating system files etc.

The foregoing diagrams represent logical architectures for describing processes according to some embodiments and actual implementations may include more or different components arranged in other manners. Other topologies may be used in conjunction with other embodiments. Moreover each system described herein may be implemented by any number of devices in communication via any number of other public and or private networks. Two or more of such computing devices may be located remote from one another and may communicate with one another via any known manner of network s and or a dedicated connection. Each device may comprise any number of hardware and or software elements suitable to provide the functions described herein as well as any other functions. For example any computing device used in an implementation may include a processor to execute program code such that the computing device operates as described herein.

All systems and processes discussed herein may be embodied in program code stored on one or more non transitory computer readable media. Such media may include for example a floppy disk a CD ROM a DVD ROM a Flash drive magnetic tape and solid state Random Access Memory RAM or Read Only Memory ROM storage units. Embodiments are therefore not limited to any specific combination of hardware and software.

Embodiments described herein are solely for the purpose of illustration. Those in the art will recognize other embodiments may be practiced with modifications and alterations to that described above.

