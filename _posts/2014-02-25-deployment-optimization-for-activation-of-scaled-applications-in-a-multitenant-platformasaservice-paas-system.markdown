---

title: Deployment optimization for activation of scaled applications in a multi-tenant platform-as-a-service (PaaS) system
abstract: A mechanism for optimization of deployment of applications for activation in a multi-tenant Platform-as-Service (PaaS) system is disclosed. A method of the disclosure includes receiving, by a processing device, a request for deployment of an application source code on a node. The node is provided by the PaaS system. The method also includes implementing, by the processing device, a build, prepare and distribute functionality to convert the application source code into a build result prepared for distribution as a deployment artifact code. The method further includes implementing, by the processing device, a deployment functionality to activate the deployment artifact for the deployment in the node by not incurring downtime.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09342299&OS=09342299&RS=09342299
owner: Red Hat, Inc.
number: 09342299
owner_city: Raleigh
owner_country: US
publication_date: 20140225
---
The embodiments of the disclosure relate generally to platform as a service environments and more specifically relate to deployment optimization for activation of scaled applications in a multi tenant PaaS system.

Currently a variety of Platform as a Service PaaS offerings exists that include software and or hardware facilities for facilitating the execution of web applications in a cloud computing environment the cloud . Cloud computing is a computing paradigm in which a customer pays a cloud provider to execute a program on computer hardware owned and or controlled by the cloud provider. It is common for a cloud provider to make virtual machines hosted on its computer hardware available to customers for this purpose.

The cloud provider typically provides an interface that a customer can use to requisition virtual machines and associated resources such as processors storage and network services etc. as well as an interface a customer can use to install and execute the customer s program on the virtual machines that the customer requisitions together with additional software on which the customer s program depends. For some such programs this additional software can include software components such as a kernel and an operating system and or middleware and a framework. Customers that have installed and are executing their programs in the cloud typically communicates with the executing program from remote geographic locations using Internet protocols.

PaaS offerings typically facilitate deployment of applications provision hosting capabilities provide the facilities to support the complete life cycle of building and delivering applications and services. Typically these facilities operate as one or more virtual machines VMs running on top of a hypervisor in a host server.

A na ve approach to application deployment that a PaaS provider may offer is to stop the application apply new code build deploy activate and restart the application. As such the application is taken offline temporarily causing notable downtime between the stop and the restart which can lead to incoming requests failing during this period.

Embodiments of the disclosure provide for a mechanism for optimization of deployment for activation of scaled applications in a multi tenant PaaS system. The scaled application may refer to scaling of applications in change of size e.g. add remove gears for the application . The deployment optimization described in embodiments of the disclosure may provide support for activation of applications in a PaaS system without downtime. In one embodiment when a software developer or end user deploys an application on the PaaS system including making a code change in the application they may provide updated source code for the application to the PaaS environment. Embodiments of the disclosure introduce functionality to support optimized deployment hereinafter deployment of the application including updates of the application without downtime for activation.

In one embodiment deployment support is provided via a coordinator component of the application. The coordinator component may be a gear for the application. In one embodiment the coordinator component builds the application and distributes it for activation. The coordinator component provides functionality such as configuration templates scripts dependencies to run an application and or add a feature to an application and implements deployment functionality so that the application is deployed without downtime. Deployment of an application allows for updates to the application s source code to take effect without down time of the application to minimize total amount of deployment time for the application.

In one embodiment a method of the disclosure includes receiving a request for deployment of an application source code on a node. The node is provided by the multi tenant PaaS system. The method also includes implementing by a coordinator component a build prepare and distribute functionality to convert the application source code for the application into a build result prepared for distribution as a deployment artifact. The method further includes implementing by the coordinator component a deployment functionality to activate the deployment artifact in the node by not incurring downtime.

Prior solutions for optimizing deployment of the applications for activation include the PaaS platform to generally stop build deploy activate and restart the application to deploy the code or implement the code changes. As such the application is taken offline temporarily causing a significant downtime between the stop and the restart which leads to incoming requests to fail during this period. Embodiments of the present disclosure overcome these disadvantages by optimizing deployment of the applications to avoid downtime and to minimize the deployment time for activation of the applications.

Clients and are connected to hosts and the cloud provider system via a network which may be a private network e.g. a local area network LAN a wide area network WAN intranet or other similar private networks or a public network e.g. the Internet . Each client may be a mobile device a PDA a laptop a desktop computer or any other computing device. Each host may be a server computer system a desktop computer or any other computing device. The cloud provider system may include one or more machines such as server computers desktop computers etc.

In one embodiment the cloud provider system is coupled to a cloud controller via the network . The cloud controller may reside on one or more machines e.g. server computers desktop computers etc. and may manage the execution of applications in the cloud . In some embodiments cloud controller receives commands from PaaS provider controller . Based on these commands the cloud controller provides data e.g. such as pre generated images associated with different applications to the cloud provider system . In some embodiments the data may be provided to the cloud provider and stored in an image repository in an image repository not shown located on each host or in an image repository not shown located on each VM .

In one embodiment each VM running applications for the PaaS provider controller includes a source code management SCM system sometimes referred to as SCM or revision control system. One example of such an SCM or revision control system is Git available as open source software. Git and other such distributed SCM systems usually include a working directory for making changes and a local software repository for storing the changes. The packaged software application can then be pushed from the local Git repository to a remote Git repository. SCM system on VMs stores the remote repositories for each application running on the VM so that the application code may be edited by others with access or the application may be executed by the VM .

While various embodiments are described in terms of the environment described above those skilled in the art will appreciate that the facility may be implemented in a variety of other environments including a single monolithic computer system as well as various other combinations of computer systems or similar devices connected in various ways. For example the data from the image repository may run directly on a physical host instead of being instantiated on a VM .

In one embodiment the client layer resides on a client machine such as a workstation of a software developer and provides an interface to a user of the client machine to a broker layer of the PaaS system . For example the broker layer may facilitate the creation and deployment on the cloud via node layer of software applications being developed by an end user at client layer .

In one embodiment the client layer includes a source code management system sometimes referred to as SCM or revision control system and a local software repository for storing the changes for each application associated with the end user of the PaaS system . The packaged software application can then be pushed from the local SCM repository to a remote SCM repository at the node s running the associated application. From the remote SCM repository the code may be edited by others with access or the application may be executed by a machine. Other SCM systems work in a similar manner.

The client layer in one embodiment also includes a set of command tools that a user can utilize to create launch and manage applications. In one embodiment the command tools can be downloaded and installed on the user s client machine and can be accessed via a command line interface or a graphical user interface or some other type of interface. In one embodiment the command tools communicate with an application programming interface API of the broker layer and perform other applications management tasks in an automated fashion using other interfaces as will be described in more detail further below in accordance with some embodiments.

In one embodiment the broker layer acts as middleware between the client layer and the node layer . The node layer includes the nodes on which software applications are provisioned and executed. In one embodiment each node is a VM provisioned by an Infrastructure as a Service IaaS provider such as Amazon Web Services. In other embodiments the nodes may be physical machines or VMs residing on a single physical machine. In one embodiment the broker layer is implemented on one or more machines such as server computers desktop computers etc. In some embodiments the broker layer may be implemented on one or more machines separate from machines implementing each of the client layer and the node layer or may implemented together with the client layer and or the node layer on one or more machines or some combination of the above.

In one embodiment the broker layer includes a broker that coordinates requests from the client layer with actions to be performed at the node layer . One such request is application creation. In one embodiment when a user using the command tools at client layer requests the creation of an application or some other action such as changes in currently running application to manage the application the broker first authenticates the user using an authentication service . In one embodiment the authentication service may comprise custom authentication methods or standard protocols such as SAML Oauth etc. Once the user has been authenticated and allowed access to the system by authentication service the broker uses a server orchestration system to collect information and configuration information about the nodes 

In one embodiment the broker uses the Marionette Collective MCollective framework available from Puppet Labs as the server orchestration system but other server orchestration systems may also be used. The server orchestration system in one embodiment functions to coordinate server client interaction between multiple sometimes a large number of servers. In one embodiment the servers being orchestrated are nodes which are acting as application servers and web servers.

For example if the broker wanted to shut down all applications on all even numbered nodes out of 100 000 nodes the broker may provide one command to the server orchestration system . Then the server orchestration system generates and distributes a message to all nodes to shut down all applications if the node is even using a messaging and queuing system. Thus in one embodiment the broker manages the business logic and model representing the nodes and the applications residing on the nodes and acts as a controller that generates the actions requested by users via an API of the client tools . The server orchestration system then takes the actions generated by the broker and orchestrates their execution on the many nodes managed by the system.

In one embodiment the information collected about the nodes can be stored in a data store . In one embodiment the data store can be a locally hosted database or file store or it can be a cloud based storage service provided by a Software as a Service SaaS provider such as Amazon S3 Simple Storage Service . The broker uses the information about the nodes and their applications to model the application hosting service and to maintain records about the nodes. In one embodiment data of a node is stored in the form of a JavaScript Object Notation JSON blob or string that maintains key value pairs to associate a unique identifier a hostname a list of applications and other such attributes with the node.

In embodiments of the disclosure the PaaS system architecture of is a multi tenant PaaS environment. In a multi tenant PaaS environment each node runs multiple applications that may be owned or managed by different users and or organizations. As such a first customer s deployed applications may co exist with any other customer s deployed applications on the same node VM that is hosting the first customer s deployed applications . In some embodiments portions of an application are running on multiple different nodes . For example as shown in components of application run in both node and node . Similarly application runs in node and node

In addition each node also maintains a cartridge library . The cartridge library maintains multiple software components referred to herein as cartridges that may be utilized by applications deployed on node . A cartridge can represent a form of support software or middleware providing the functionality such as configuration templates scripts dependencies to run an application and or add a feature to an application . In one embodiment the cartridges support languages such as but not limited to JBoss PHP Ruby Python Perl and so on. In addition cartridges may be provided that support databases such as MySQL PostgreSQL Mongo and others. Cartridges may also be available that support the build and continuous integration environments such as a Jenkins cartridge. Lastly cartridges may be provided to support management capabilities such as PHPmyadmin RockMongo 10gen mms agent cron scheduler and HAProxy for example. Adding an instance of a cartridge from cartridge library to an application provides a capability for the application without the customer who owns the application having to administer or update the included capability.

In embodiments of the disclosure an end user of PaaS system may provide application code updates to one or more applications of the end user hosted by PaaS system . The application code updates may include a coordinator component that indicates the application is to be deployed using an optimized deploy hereinafter deploy functionality. In one embodiment the coordinator component builds the application and distributes it for activation. In other embodiments mechanisms other than a coordinator component trigger the deployment such as an environmental variable or any other trigger mechanism.

In one embodiment deployment functionality refers to an ability to optimize speed of activation of the application. When the end user creates a new application the coordinator component is automatically created in each of the nodes . The packaged software application including the coordinator component can then be provided e.g. pushed from the local SCM repository to a remote SCM repository . In some embodiments there is a remote SCM repository on each node that the application executes. The remote SCM repositories store the application for editing and or for execution on the node 

In one embodiment the coordinator component is a gear for the application. The coordinator component is responsible for deployment functionality across a variety of different cartridge types that an application may run irrespective of the type of cartridge. As a result an end user of the PaaS platform does not have to be aware of or implement deployment functionality in each cartridge instance type that application may use. Instead the coordinator component and the PaaS platform take care of all tasks related to deployment.

Each node also includes a server orchestration system agent configured to track and collect information about the node and to perform management actions on the node . Thus in one embodiment using MCollective as the server orchestration system the server orchestration system agent can act as a MCollective server. The server orchestration system then acts as the MCollective client that can send requests queries and commands to the MCollective server on node .

As previously mentioned cartridges provide the underlying support software that implements the functionality of applications . In one embodiment an application may utilize one or more cartridge instances that are run in one or more resource constrained gears on nodes . Cartridge library provides an OS based location outside of all application gears that acts as a source for cartridge instantiations that provide functionality for an application . An application may use more than one cartridge instance as part of providing functionality for the application . One example of this is a JavaEE application that uses a JBoss AS7 cartridge with a supporting MySQL database provided by a MySQL cartridge. Each cartridge instance may include a software repository that provides the particular functionality of the cartridge instance .

A gear is a resource constrained process space on the node to execute functionality of an application. In some embodiments a gear is established by the node with resource boundaries including a limit and or designation of the amount of memory amount of storage and security types and or labels to be applied to any functions executed by the gear . In one embodiment gears may be established using the Linux Containers LXC virtualization method. In further embodiments containers may also be established using cgroups SELinux and kernel namespaces to name a few examples.

In some embodiments a gear is also known as a container. In some embodiments cartridges instances for an application may execute in gears dispersed over more than one node . In other embodiments cartridge instances for an application may run in one or more gears on the same node .

Nodes may also include remote SCM repositories for each application running on the node . The remote SCM repositories are the same as their counterparts described with respect to .

In one embodiment when updated application source code is received e.g. via a push operation in an application s remote SCM repository the remote SCM repository invokes coordinator component to run a number of hooks to build prepare and distribute the application.

As discussed above a build is executed for the application code. A build is a process that converts source code into a build result. A build result is eventually prepared for deployment distributed to some or all of an application s gears and finally activated on those gears. The prepare and distribute may happen immediately as part of the workflow wherein the coordinator component builds the application and distributes it. A build result includes the application code and or anything produced by the application s build process e.g. a .war file . The build result may represent the state of the repositories and the dependencies on the gear after the build has been executed.

In one embodiment preparing a build result for deployment involves the execution of a prepare platform action and a user defined prepare action hook if one exists . If the prepare platform action is passed a file as an input it extracts the file into the specified deployment directory. The prepare user action hook is part of the application s source code in which users may execute custom code to modify the build result prior to its distribution to the application s gears. An example use case for the prepare action hook is using it to download environment specific files that do not belong in the application s repository to the build result directory. In another example a use case for the prepare action hook is creating a unique identifier and a symlink for the unique identifier. A symlink is a special type of file that contains a reference to another file or directory. In one embodiment the build result may be compressed to minimize disk space usage.

A build result that has been prepared for distribution is a deployment artifact. As discussed above the deployment artifacts have unique identifiers that are created by the prepare platform action after the user defined prepare action hook has been executed. Once the deployment artifact has been created it may be distributed to some or all of an application s gears. In one embodiment the deployment artifact is copied to the gears.

For example in the case of a git SCM system a post receive git hook is setup on the remote Git repository that calls into the coordinator component to perform the deployment process. The coordinator component calls into cartridge hooks associated with the cartridges to allow the cartridges to execute cartridge specific build logic. The coordinator component builds the application for distribution as a deployment artifact. In one embodiment the functionality to implement deployment of the deployment artifact is represented at deploy module .

In some embodiments the deploy module functions to activate the applications for deployment without down time. This may include not stopping execution of the application to avoid downtime. In one embodiment without down time may refer to zero down time. The deploy module activates the deployment artifact for deployment making it the active code running for a gear. As discussed above a deployment artifact is the built and prepared result.

In one embodiment when activating the deployment artifact a scale replace method is used. A scale replace method may include creating a new gear and the deleting an old gear. As discussed above a gear is a resource constrained process space on the node to execute functionality of an application. In one embodiment the application has at least one gear i.e. first gear before the activation is started. A new gear is created to host the new deployment artifact. The deployment artifact is copied into the newly created gear which is later started for execution. The first gear is deleted after successful execution of the deployment artifact in the new gear. Accordingly the gears are scaled down which results in additional disk space available on the node. As such more space may be needed for example with two gears during the deployment than before or after the deployment with one gear.

The minimum time to deploy the deployment artifact for the activation without downtime using the scale replace method is described by deploy gears extra cap 1 gear create gear deploy gear activate where N gears is the number of gears in the application N extra cap is the extra capacity in number of gears T gear create is the time to create a new gear with an instance of the cartridges T gear deploy is the time to copy the deployment artifact onto disk from the source and T gear activate is the time to swap the artifact to the newly deployed version and start the gear.

In another embodiment when activating the deployment artifact an in place method is used. The in place method may include preserving all the gears before the activation is started. Accordingly the scale factor of the gears may or may not be altered since the total number of gears remains the same. The in place method may also include storing the deployment artifact at a temporary location such as a deployment directory and stopping execution of at least one gear among all the gears. The in place method may further copy the deployment artifact from the temporary location into a run time directory of at least one gear the gear in which the execution is stopped which is distributed to the rest of the gears. Then all the gears are started for execution with the deployment artifact.

The minimum deployment time to deploy the deployment artifact for activation without down time using the in place method is deploy gears extra cap fraction 1 gear activate as the gear deploy may be executed before the deployment begins. N fraction N gears number of gears that are allowed to be down at any given point in time. For example there are 10 gears and only 1 gear is allowed to be down at a time. As such there will be 10 0 10 0.1 1 activate time 9 T gear activate .

In one embodiment similar methodology as discussed above with respect to the in place method for roll back of the deployment artifact as an activation. In some embodiments when all the gears are preserved and previous deployment artifacts are retained roll back of the active deployment artifact to a previous deployment artifact may be executed. In one embodiment the roll back includes stopping execution of the application in a subset of the application s gears returning back to a previous deployment directory and invoking an activate command for a previous deployment ID in order to activate a previous deployment artifact.

In one embodiment a user may disable automatic deployments of the applications and choose instead to deploy the applications via the methods described above.

In some embodiments the node generates the current deployment status of the application deployed and provides it to the broker layer . The current status may include details of the successful and failed deployments.

In one embodiment the broker maintains the current status of all the application s gears including the current deployment ID and information about previous deployments. Whenever a deployment or rollback of the application succeeds the node informs the broker of the application s gear deployments. In one embodiment the broker may provide the current status of the application gear to the client layer . In one example the broker may send the current status of the application gear to the client layer upon request from the client. In another example the broker may automatically send the current status of the application gear to the client layer .

In one embodiment the broker may not be available. In such embodiment a fall back mode is implemented where a deployment or the roll back of the applications are directed by an external tool connected to the nodes using the capabilities available on the gears . This may be accomplished by ensuring that the build prepare distribute and activate steps can be invoked by direct connection to the node . Such steps may be invoked in any gear with the Git repository to any coordinator component . In one embodiment the reporting and coordination of the requests from the client layer with actions to be performed at the node layer may be maintained by an external tool.

Method begins at block where a request for deployment of an application source code on a node of a multi tenant PaaS system is received from an end user. The request may be provided to a broker of the multi tenant PaaS system from the end user via command line tools or by communicating directly with application interface API of the broker. At block a SCM repository is created for the application source code. Once the SCM repository is created the user may git push changes to the application source code in the SCM repository. As discussed above the SCM repository is a git remote repository maintained on a node of the multi tenant PaaS system.

At block build prepare and distribute functionality is implemented to convert the application source code into a build result prepared for distribution as a deployment artifact. As discussed above a build is run for the application code. A build is a process that converts source code of the application into a build result. A build result is eventually prepared for deployment distributed to some or all of an application s gears and finally activated on those gears. The prepare and distribute may happen immediately as part of the work flow wherein the coordinator component builds the application and distributes it. A build result that has been prepared for distribution is the deployment artifact.

At block deployment functionality is implemented to activate the deployment artifact for deployment in the node by not incurring down time. In one embodiment the not incurring downtime is without down time which refers to zero down time. The deployment functionality activates the deployment artifact for deployment making it the active code running for a gear.

At block a new gear is created to host the updated application source code. As discussed above a gear is a resource constrained process space on the node to execute functionality of an application. In one embodiment the application has at least one gear i.e. first gear before the activation is started. In one embodiment the first gear hosts a currently executing application. At block a deployment artifact which is ready for deployment is copied into the new gear. At block the deployment artifact is started for execution in the new gear. At block the first gear which is already in the application is deleted. In one embodiment the first gear is deleted after successful execution of the deployment artifact in the new gear.

The minimum deployment time to deploy the deployment artifact without down time using the method is described by deploy gears extra cap 1 gear create gear deploy gear activate where N gears is the number of gears in the application N extra cap is the extra capacity in number of gears T gear create is the time to create a new gear with an instance of the cartridges T gear deploy is the time to copy the deployment artifact onto disk from the source and T gear activate is the time to swap the artifact to the newly deployed version and start the gear.

At block the deployment artifact which is ready for deployment is stored at a temporary location. A temporary location may be a deployment directory. At block execution of at least one gear i.e. first gear already in the application is stopped. As discussed above the application has the first gear before the activation is started. Also as discussed above a gear is a resource constrained process space on the node to execute functionality of an application. At block the deployment artifact from the temporary location is copied from the temporary location into deployment directory in the first gear. At block the first gear is restarted for execution of the deployment artifact.

The minimum deployment time to deploy the deployment artifact without down time using the method is deploy gears extra cap fraction 1 gear activate as the gear deploy may be executed before the deployment begins. N fraction N gears number of gears that are allowed to be down at any given point in time.

The computer system includes a processing device e.g. processor CPU etc. a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be complex instruction set computing CISC microprocessor reduced instruction set computer RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processing device is configured to execute the processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device communicably coupled to a network . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine accessible storage medium on which is stored software embodying any one or more of the methodologies of functions described herein. The software may also reside completely or at least partially within the main memory as instructions and or within the processing device as processing logic during execution thereof by the computer system the main memory and the processing device also constituting machine accessible storage media.

The machine readable storage medium may also be used to store instructions to implement a deploy module to perform deployment optimization in a multi tenant PaaS system such as the deploy module described with respect to and or a software library containing methods that call the above applications. While the machine accessible storage medium is shown in an example embodiment to be a single medium the term machine accessible storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine accessible storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instruction for execution by the machine and that cause the machine to perform any one or more of the methodologies of the disclosure. The term machine accessible storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

In the foregoing description numerous details are set forth. It will be apparent however that the disclosure may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the disclosure.

Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as sending receiving creating activating providing executing copying storing symlinking stopping restarting deleting implementing or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The disclosure also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a machine readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the method steps. The structure for a variety of these systems will appear as set forth in the description below. In addition the disclosure is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the disclosure as described herein.

The disclosure may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the disclosure. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. etc.

Whereas many alterations and modifications of the disclosure will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description it is to be understood that any particular embodiment shown and described by way of illustration is in no way intended to be considered limiting. Therefore references to details of various embodiments are not intended to limit the scope of the claims which in themselves recite only those features regarded as the disclosure.

