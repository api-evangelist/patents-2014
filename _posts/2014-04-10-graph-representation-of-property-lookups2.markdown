---

title: Graph representation of property lookups
abstract: An embodiment of an object property management system using a dataflow architecture that expresses an application data as a directed acyclic graph and propagates data through the graph in an ordered, predictable way based on connections between the graph nodes. In one embodiment, the object property management system uses proxy nodes to arrange a dynamic graph for property data propagation for nested properties to allow property relationships to automatically adjust based on changes to a property value within the hierarchy of the property path.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09589068&OS=09589068&RS=09589068
owner: Apple Inc.
number: 09589068
owner_city: Cupertino
owner_country: US
publication_date: 20140410
---
In Object Oriented Programming data objects can be defined to have both data elements and methods of behavior. In some programming languages objects can also have properties which are an integration of data and method. Properties can be read from or written to like a data element but those reads and writes are translated to an underlying set of methods that are used to access e.g. get set compute transform etc. the property values. The properties can be bound to other properties such that a change in one property is reflected in a different property.

In some languages nested properties are supported in which one property can contain other properties or can contain an object that can include additional properties. Object property management can quickly become complex in nested property scenarios in which the value of one property can be defined by multiple other properties such that setting one property can lead to a cascade of changes throughout a set of properties that are dependent upon the changed property. Current object property systems provided by programming languages and application frameworks attempt to manage this complexity via a variety of techniques. However the current system may not be application dataflow aware in that the system may not account for the direction and hierarchy of the dataflow within the application as designed by the application or the application developer.

In one embodiment an electronic device comprising one or more processors having one or more processor cores executes instructions stored in memory to provide an object property system. To provide the object property system the processor receives a property lookup request including a root object and a property path and parses the property path to determine a property to associate with each section of the property path. For each section of the property path the processor creates a proxy node and couples the proxy node with a graph node of the determined property.

In one embodiment a data processing system comprising a memory device and a processor is configured to implement the object property system which includes a root object and a first property of the root object which has a value defined at least in part by a path of nested properties including a second property or via the second property via a complex relationship such as a derived property or complex binding. The path of nested properties can be used to specify a dependency hierarchy for the property nesting in which the second property is based. The first property of the root object can access the value of the second property via at least one proxy node which couples one or more of a downstream node and an upstream node of the respective properties and automatically adjusts the node arrangements.

In one embodiment a computer implemented method is implemented at a proxy node of an object property system. The method comprises receiving a notice at the proxy node of a change in a value of a property within the property path automatically disconnecting the proxy node from an associated property in the property path in response to receiving the notice and performing a property lookup to retrieve a set of graph nodes for a new property wherein the set of retrieved graph nodes for the new property includes an upstream graph node and a downstream graph node. The method further includes coupling with the upstream node in the set of retrieved graph nodes when the proxy node is configured as an upstream proxy node and coupling with the downstream node in the set of retrieved graph nodes when the proxy node is configured as a downstream node proxy node.

The above summary does not include an exhaustive list of all aspects of the embodiments. It is contemplated that the embodiments include all systems and methods that can be practiced from all suitable combinations of the various aspects summarized above and also those disclosed in the detailed description below.

Other features will be apparent from the drawings listed above and from the detailed description which follows.

An embodiment of the object property management system can be implemented using a dataflow architecture that expresses an application s data e.g. properties bindings and data transformations as a directed acyclic graph. Data propagates through the graph in an ordered and predictable way based on the connections between the graph nodes. Redundant or cyclical updates to property bindings and observers are avoided by defining an upstream data flow and a downstream data flow for object properties. To facilitate the data flow each instance of an object property can have one or both of an upstream node and a downstream node. Each node can have any number of parent or child nodes.

In one embodiment upstream and downstream imply a relative authority where a first property or property instance is bound upstream of a second property the first property is considered more authoritative than the second property. When a property is to be changed the upstream node of the property sends a request upstream towards the truth instance to request a change in the authoritative value of the property. If the truth instance accepts the request and updates the truth a notification of the update is sent through a chain of downstream nodes for each bound property.

Additional information on the use of upstream and downstream nodes within the property system can be found in co pending application Ser. No. 14 162 688 filed on Jan. 23 2014 which is incorporated herein by reference.

An exemplary property binding is shown between PersonView.gender and the current instance of the property defined by the person.identity.gender property path. The value of the PersonView.gender property reflects the value of the identity.gender property of the assigned Person data structure. An exemplary assignment is illustrated at block in which the person property of PersonView is currently assigned to the value Alex. Alex is defined as a data structure having an identity.gender value of Female as shown at block . After the assignment shown at block which can occur for example in response to the selection of a value in the user interface for the web based application an exemplary query of the PersonView.person object returns the values defined by the Alex data structure as shown at block .

The illustrated objects and properties will be described based upon the exemplary assignments shown in . The PersonView object object is shown including the person property of the PersonView object . As illustrated the person property is a data structure that is linked via a pointer to a Person instance e.g. Alex which is an instance of the person property . The person property includes a nested identity property . The illustrated Person instance is linked via a pointer to an Identity instance e.g. Alexis . The Identity instance includes a gender property which is assigned a Female value or a pointer to the value .

The exemplary illustration of shows a binding between the PersonView.gender property and the Alexis.gender property . To create the binding the property system performs a lookup to retrieve the upstream node and downstream node of the Alexis.gender property and the upstream node and downstream node of PersonView.gender . For simple e.g. non nested property lookups the property system can use an object and key lookup within a dictionary that maps property names to their respective upstream and downstream nodes. For example a dictionary lookup of the Alexis.gender property using the Alexis instance can be performed to retrieve the upstream node and downstream node for the property instance. Once the nodes are retrieved the system can create a property binding between the PersonView.gender property and the Alexis.gender property by creating an upstream graph edge and a downstream graph edge . The binding associates the PersonView.gender property to the value or a pointer to the value of the Alexis.gender property .

In the exemplary illustration of the PersonView.gender property is downstream from the Alexis.gender property indicating that Alexis.gender has more authority in the binding relationship and is closer to the true value of the binding. The PersonView.gender property can send requests via the upstream node and receive notifications via the downstream node . However the graph arrangement shown is not intended to be limiting as the precise connections as to the upstream and downstream nodes can vary. For example the upstream node can also couple as a child of upstream node and downstream node can also couple as a parent of downstream node .

A nested lookup can be performed using a property path instead of the individual property instances. Performing a lookup using a property path utilizes a root object and a property path to a nested property. Using the example of a path lookup can be performed using PersonView as the root object and Person.identity.gender as the property path. Such lookup would return the graph nodes for whichever instance if any is reachable in the current property configuration. However should a change occur to any of the properties in the property chain above the target property the graph could become invalid such that the binding would no longer be correct.

For example if PersonView.person is assigned a new value the nodes previously returned from the path lookup may continue to reflect the property state at the time nodes were initially retrieved. To maintain validity after a change to one or more of the properties in a link of nested properties the nodes returned from a previous nested lookup would have to be manually updated by the program logic that uses the bindings e.g. the binding consumer . If the binding consumer is required to manage these updates manually the application using the bindings may become defect prone and difficult to maintain. Additionally the performance of the host data processing system may suffer due to increased system resource overhead.

An embodiment of the property system described herein enables the automatic management of property observer and bindings for nested property systems via the use of proxy nodes and the use of chained lookups using a property path. The property path is representation of a list of properties that is used to create relationships between properties. The property path has a base property from which other properties in the property path depend and a target property that depends upon the other properties in the property path.

To facilitate the dynamic nature of a property path lookup a set of proxy nodes is returned from a path lookup instead of the set of actual graph nodes associated with the property.

In one embodiment each proxy node automatically manages the respective graph connections of the node in response to any changes in the state of properties along the property path. A binding consumer can use the proxy nodes as the consumer would use the original nodes while avoiding the need for manual node maintenance when a property in a nested property relationship changes. The proxy nodes are automatically created by the proper during a property lookup for a nested property using a property path. Each proxy nodes manages graph connections such that the proxy node appears identical to the actual node for the respective property based on the state of the property nesting.

In one embodiment the property system provides a reference counting feature which tracks the number of connections to each node. The proxy nodes can use their reference counts to perform automatic management of their system resources. For example once a proxy node is connected to the graph the node and can be configured to self delete when it no longer used.

In one embodiment three downstream proxy nodes are created when creating an observer for a property referenced by the illustrated path. In one embodiment an additional upstream proxy node can be created e.g. proxy node for example during the creation of a two way binding. The last proxy nodes in the chain e.g. are the terminal proxy nodes. The terminal proxy nodes can be configured to couple to the graph nodes of whatever property is targeted by the property that resolves from the property path and to automatically re couple to a different property in response to a change in the property path. The upstream proxy node that is created for two way bindings can also be considered a terminal proxy node. In the exemplary illustration the PersonView.person.identity.gender property path resolves to the identity.gender property of the Alexis instance of the Identity property. If the value PersonView.person is changed to select a different person the proxy nodes can be automatically reconfigured to connect to the graph nodes of the new PersonView.person.identity.gender.

At the time of creation for the illustrated binding a link from the base property e.g. person property of the PersonView object to the root proxy node can be created along with a link to the second proxy node and the links to couple the second proxy node to the upstream and downstream terminal proxy nodes. The link between the base property and the root proxy node enables data flow to the root proxy node which allows the node to receive the update notice that is used to react to a change in the value of the person property . The root proxy node may not require a recouple in response to the change notification as the value of the base property may change but the associated nodes are not likely to change.

The link between the root proxy node and the second proxy node allows the root proxy node to notify the second proxy node of a change to the base property. The second proxy node can respond by decoupling a link from the currently connected nodes of the previously associated property and creating a new link to the nodes of the new property. The second proxy node can propagate the notification along a link to the downstream terminal proxy node and a link to the upstream terminal proxy nodes which can each respond by decoupling their respective links e.g. . The terminal proxy nodes can then reconfigure the node connections to link to the nodes of the new target property.

In one embodiment the consumer of the binding for the PersonView.gender property uses the proxy nodes returned by an object and path lookup in the same way as the actual graph nodes returned by an object and key lookup. Accordingly the upstream graph edge can be used in the same manner as upstream graph edge of and downstream graph edge can be used in the same manner as downstream graph edge . It will be noted that the binding hierarchy e.g. parent child relationship between the PersonView.gender property and the root proxy nodes is not limited to the configuration shown.

The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. or a combination of hardware and software. The software can be embodied as instructions on a non transitory machine readable storage medium for execution by processing hardware. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described can be performed in a different order. Moreover some operations can be performed in parallel rather than sequentially.

In one embodiment the root proxy node includes logic which receives the notice . In one embodiment each proxy node including the root proxy node can be configured to automatically propagate any incoming notice to the other proxy nodes. In one embodiment the root proxy node inspects the root property to determine if the new value of the property differs from the previous value and only transmits the notice if the new value of the property is different.

A change to the value of the root property is not likely to result in a change in the node structure for the root proxy node . However the other proxy nodes may have to reconfigure. As illustrated the second proxy node in response to the property change notice disconnects from the downstream node of its assigned property in the chain and performs a lookup for the nodes of the new property. In one embodiment the new property value is included in the notice . The second proxy node can use logic to perform a property lookup to acquire at least the downstream node of the associated property. Having acquired the downstream node of the new property the logic can perform operation to couple to the new downstream node.

One embodiment of the terminal proxy node includes logic that can vary based on the configuration of the node as the terminal proxy node can be configured as an upstream node or a downstream node. For observer objects only a downstream node is required and the logic of the terminal proxy node can be configured to respond to a notice by performing an operation that includes disconnecting from the existing node retrieving a new downstream node that is associated with the new property to observe and coupling to the new downstream node. For a property binding a first instance of the terminal proxy node is configured as a downstream node and a second instance of the terminal proxy node can be configured as an upstream node. As an upstream node the logic of the terminal proxy node can be configured to perform an operation that includes coupling to the new downstream node.

The flushing stage of an embodiment is shown at block which visits each graph node and instructs the graph to perform the logic of each respective node. In general each node is configured to push data onto their child nodes. An upstream node is configured to push requests upstream to each child node while a downstream node is configured to push responses and notifications downstream to each child node. In one embodiment the proxy nodes are configured to listen for change notifications from their parent node which is either the downstream node of the property node which the node proxies or from the proxy node of the previous path section. If value of the previous proxy node in the chain has changed the proxy node can disconnect from old node connect to new node if any new node exists and retrieve the value of the node. In one embodiment if the value of the property that the proxy node is a proxy for changes the proxy node simply propagates the change notice.

The notifying stage of one embodiment is shown at block . During the notify stage each node is visited to notify the node that the data flow is complete. Having notice that the data flow has completed the logic of each node can perform certain final operations. For example a parent node can dynamically allocate data structures for use during the flush stage to relay information to child nodes. During the notify stage the parent node can free those resources. In one embodiment the node order for the notify stage can be performed in reverse of the node order of the flush stage to allow child nodes to use those data structures during notify stage operations. In one embodiment a proxy node can query a reference count during the notify stage and automatically free allocated resources and self delete once the node is no longer used.

For the root property e.g. the property at the root object the system can create a root proxy node and couple the root proxy node to a downstream node of the associated property of root object which is shown at block . In one embodiment a proxy node is created for each path section. As shown at block an embodiment creates a proxy node for the next property and couples the proxy node to the downstream node of the associated property in property path. The system can determine as shown at block whether the last created proxy node is a terminal proxy node. If the last created proxy node is not a terminal node the system returns to block to create an additional node for the next property path section.

When the system reaches the end of the property path and the last created node is a terminal proxy node as determined at block the system can determine whether to create an upstream proxy node. For observers which simply monitor a property for notice that the property has changed an upstream node may not be required. For a property binding in particular a two way property binding an embodiment of the system proceeds to block where the system creates an upstream proxy node and then couples the upstream proxy node with the proxy node of previous section of property path. Before coupling a proxy node to the associated property as shown at block and an embodiment can perform a lookup e.g. object and key lookup on the property to retrieve the relevant graph nodes for the respective properties.

In one embodiment each proxy node is configured as a downstream node by default. However proxy nodes can be upstream nodes. At block the proxy node logic determines whether the proxy node is configured as an upstream node. If the proxy node is an upstream node the node performs the logic indicated at block and couples to the upstream node of the new property. If the proxy node is a downstream node as determined at block the logic proceeds to block where the node couples to the downstream node of the new property.

An embodiment of the object property management system as described herein can be implemented within an application development framework that facilitates the observation and binding of nested properties. For example an embodiment of the system can be implemented as one of the application or system frameworks illustrated in the exemplary software architecture of . An embodiment can also be implemented as an application framework used in network or web based applications as in the exemplary software architecture of . The system can also be performed on one of the exemplary data processing systems shown in and .

During application development a software developer can make use of an operating system vendor provided application framework that includes a set of application programming interfaces API that enable the developer s application to make use of services provided by the vendor s operating system to user applications. The application framework can be one of any number of application frameworks designed to provide application developers with toolkits and software libraries to access specific functionality provided by a service provider. For example the application framework can be a user interface framework such as the Application Kit framework or the UI Kit framework each provided by Apple Inc. of Cupertino Calif. which provide objects with which developers can implement a graphical event driven user interface. The application framework can also be a data services framework that facilitates in one embodiment synchronous cloud base storage across multiple devices using for example iCloud storage also provided by Apple Inc.

The software components are illustrated with a division between user space and a kernel space. Although other arrangements are possible user applications e.g. user application and some operating system components e.g. operating system user interface layer and core operating system layer execute in user space. In kernel space the operating system kernel and a set of device drivers operate in the kernel and device driver layer . The kernel and device driver layer manage the underlying functionality of the operating system and provide a formalized and secure mechanism for user space software to access data processing system hardware.

A user interface UI application framework provides a mechanism for the user application to access UI services provided by the operating system OS UI layer . Underlying operating system functions that are not related to the user interface are performed in the core operating system layer . One or more data management frameworks such as a core app framework can be made available to a user application to facilitate access to operating system functions.

The exemplary user application may be any one of a plurality of user applications such as a web browser a document viewer a picture viewer a movie player a word processing or text editing application an email application or other applications known in the art. The user application accesses instructions in an exemplary UI app framework for creating and drawing user interface objects such as buttons windows dialogs controls menus and other user interface elements and components as are known in the art. The UI application framework also provides additional functionality including menu management window management and document management as well as file open and save dialogs and copy and paste handling. The exemplary UI app framework implements an embodiment of the application dataflow aware property and binding system described herein to enhance the efficiency of dataflow among the various property bindings used during execution of instructions provided by the framework.

The core operating system layer contains operating system components that implement features including and related to application security system configuration graphics and media hardware acceleration and directory services. Multiple application frameworks including the core app framework provide a set of APIs to enable a user application to access core services that are essential to the application but are not directly related to the user interface of the application. The core app framework can facilitate an application s access to database services credential and security services backup services data synchronization services and other underlying functionality that may be useful to an application.

For example using a core app framework an application can provide functionality that allows a user application to automatically synchronize application content between multiple client devices. The core app framework or equivalent application frameworks can provide access to remote server based storage for functionality including synchronized document storage key value storage and database services. Document storage synchronization allows a user application to access a common data store containing user visible file based content from multiple devices. Key value storage allows a user application to share small amounts of data such as user preferences or bookmarks among multiple instances of the user application across multiple client devices. The user application can also access server based multi device database solutions via the core app framework .

The dataflow of the synchronization for the ubiquitous key value store can be performed using one or more embodiments of application dataflow aware property and binding as described herein. A first instance of a property can be stored in the ubiquitous key value store which is managed by the user application a second instance of the property can be stored in the key value store of the data processing system which is managed by the operating system and a third instance of the property can be stored in the remote key value store on a distributed storage system. Each instance of the property is bound to another instance of the property. Each instance includes an upstream node to send requests to set change or update the property and a downstream node to receive notifications of property changes.

In the exemplary software architecture the path of the property binding dataflow is defined based on which of the instances of the property is designated the most authoritative instance for the property. In one embodiment the most authoritative instance is considered the truth and is designated as the key value store of the data processing system . In such embodiment a change to the property at the user application can trigger the transmission of a request to change the value of the property over a message channel via the upstream node of the instance. The instance of the property at the key value store of the data processing system receives the request and in one embodiment validates the request based on a set of validation conditions e.g. data range data type etc. before setting the truth to the requested value. Subsequently a notification including the new value is transmitted via the downstream node of the property at the key value store over message channel and message channel . After receiving the notification via their respective downstream nodes the value stored at the remote key value store and the value reflected in the ubiquitous key value store provided to the user application via the application framework is changed to the new value.

Alternatively an embodiment may designate the key value store of the remote storage system as the truth. In such embodiment when a request that is received at the upstream node of the property stored in the key value store the instance propagates the request to the key value store of the remote storage over message channel . Additionally a notification of the truth received at the downstream node of the instance of the property stored in the key value store can be propagated to the instance of the property used by the user application over message channel .

Although the application aware property and binding system is described in conjunction with the exemplary software architectures illustrated it will be understood that the methods and systems described will have broad application to data binding and synchronization on data processing systems.

A display controller and display device can be used to provide a graphical user interface as discussed herein. Additionally a wireless transceiver may be available to transmit and receive data via one or more wireless technologies such as Wi Fi infrared Bluetooth or one or more variants of wireless cellular technology. One embodiment of system contains one or more camera devices configured in both a front and rear facing configuration though similarly configured systems each with a front facing camera can be one of many optimal configurations. The data processing system can also include one or more input devices that allow a user to provide input to the system. Input devices can include a keypad or keyboard alone or in conjunction with a touch or multi touch panel that is overlaid on the display device . Additionally embodiments of the data processing system can also include a device for providing location awareness services such as a Global Positioning System GPS device or its equivalent.

It is to be noted that the data processing system as represented in is by way of example. One or more buses or interfaces which are not shown can be used to interconnect the various components as is well known in the art. As well additional components not shown may also be part of the system in certain embodiments. In certain embodiments fewer components than shown may also be used.

The data processing system can also include nonvolatile storage memory which may be a hard disk drive flash memory optical memory other types of memory systems that maintain data after all power is removed from the system. The nonvolatile memory and the memory can both couple to the one or more buses using known interfaces and connection techniques. A display controller is coupled to the one or more buses in order to receive display data to be displayed on a display device which can display any one of the user interface features or embodiments described herein. The display device can include an integrated touch input to provide a touch screen. The data processing system can also include one or more input output I O controllers which provide interfaces for one or more I O devices such as one or more mice touch screens touch pads joysticks and other input devices including those known in the art. The I O controller can also provide interfaces for one or more output devices e.g. speakers . The input output devices are coupled through one or more I O controllers as is known in the art. Additionally one or more network interfaces can also be coupled to the one or more buses to provide access to one or more networks.

While shows that the nonvolatile memory and the memory are coupled to the one or more buses directly rather than through a network interface it will be appreciated that the data processing system can utilize a nonvolatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface or wireless interface such as a wireless Wi Fi transceiver or a wireless cellular telephone transceiver or a combination of such transceivers. As is known in the art the one or more buses may include one or more bridges or controllers or adapters to interconnect between various buses. In one embodiment the I O controller includes a USB adapter for controlling USB peripherals and can control an Ethernet port or a wireless transceiver or combination of wireless transceivers.

The techniques and methods described herein may be carried out in a data processing system in response to its processor executing a sequence of instructions contained in a volatile non transitory memory such as the memory or the non volatile memory or a combination of such memories. In various embodiments hardwired circuitry may be used in combination with software instructions thus the techniques are not limited to any specific combination of hardware circuitry and software or to any particular source for the instructions executed by the data processing system.

Non transitory machine readable storage medium comprises any type of machine readable storage medium including floppy disks flash memory devices optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions as opposed to media specifically designed or designated for carrying transitory propagating signals. In various embodiments software instructions stored on a machine readable storage medium can be used in combination with hardwired circuitry. Thus the techniques are not limited to any specific combination of hardware circuitry and software or to any particular source for the instructions executed by the data processing system associated an apparatus for performing one or more of the operations described herein.

As described herein if it is said that an element A is coupled to or with element B element A can be directly coupled to element B or be indirectly coupled through for example element C. When the specification or claims state that a component feature structure process or characteristic A triggers or causes a component feature structure process or characteristic B it means that A is at least a partial cause of B but that there also can be at least one other component feature structure process or characteristic that assists in causing B. If the specification or claim refers to a or an element this does not mean there is only one of the described elements.

In one embodiment the system described herein represents a classical property graph consisting of normal properties and a mix of two way and one way bindings. The classical property graph can be implicit in nature where the implicit graph is represented explicitly as a directed acyclic graph made up of nodes which each perform some action. In one embodiment triggering a node triggers all of the child nodes of the triggered node. Each child node is triggered through to the leaf nodes of the graph. Where a node is considered a truth node the node is a node of the property designated as the most authoritative property of the graph and the most upstream node of the graph. Where a first property e.g. property A is upstream of a second property e.g. property B property A is closer to truth than property B. Accordingly property A s downstream node is a parent of property B s downstream node and property B s upstream node a parent of property A s upstream node. Thus when property A s downstream node is triggered property B is also triggered and when property B pushes data upstream property A will receive it.

In one embodiment an electronic device comprises one or more processors having one or more processor core. The electronic device executes instructions stored in memory to provide an object property system. To provide the object property system the processor receives a property lookup request including a root object and a property path and parses the property path to determine a property to associate with each section of the property path. For each section of the property path the processor creates a proxy node and couples the proxy node with a graph node of the determined property. In one embodiment the electronic device implements the graph as a directed acyclic graph of nodes.

In one embodiment the processor of the electronic device executes instructions to establish and maintain a relationship between multiple properties of one or more objects managed by the object property system. The relationship can be constructed by creating a root proxy node for a root property to receive updates from the root property when the value of the root property changes. In one embodiment the root property is defined as the base property in the property path that is provided when creating the property relationship. The root proxy node can then be coupled with the root property of the property path.

In one embodiment a data processing system comprising a memory device and a processor is configured to implement the object property system which includes a root object and a first property of the root object which has a value defined at least in part by a path of nested properties including a second property or via the second property via a complex relationship such as a derived property or complex binding. The path of nested properties can be used to specify a dependency hierarchy for the property nesting in which the second property is based. The first property of the root object can access the value of the second property via at least one proxy node which couples one or more of a downstream node and an upstream node of the respective properties and automatically adjusts the node arrangements.

In one embodiment a computer implemented method is implemented at a proxy node of an object property system. The method can comprise receiving a notice at the proxy node of a change in a value of a property within the property path automatically disconnecting the proxy node from an associated property in the property path in response to receiving the notice and performing a property lookup to retrieve a set of graph nodes for a new property wherein the set of retrieved graph nodes for the new property includes an upstream graph node and a downstream graph node. The method further includes coupling with the upstream node in the set of retrieved graph nodes when the proxy node is configured as an upstream proxy node and coupling with the downstream node in the set of retrieved graph nodes when the proxy node is configured as a downstream node proxy node.

The above description does not include an exhaustive list of all aspects of the embodiments. It will be evident that various modifications and changes can be made thereto and it will be apparent to those skilled in the art that many further modifications and adaptations can be made. It is contemplated that the embodiments include all systems methods and devices that can be practiced from all suitable combinations of the various aspects described above. Accordingly the scope of the various embodiments is not to be determined by any specific example provided above but only by the claims below.

