---

title: Cross-view malware detection
abstract: In an example, a cross-view detection engine is disclosed for detecting malware behavior. Malware may attempt to avoid detection by remaining in volatile memory for as long as possible, and writing to disk only when necessary. To avoid detection, the malware may also provide a pseudo-driver at a file system level that performs legitimate-looking dummy operations. A firmware-level driver may simultaneously perform malicious operations. The cross-view detection engine detects this behavior by deconstructing call traces from the file system-level operations, and reconstructing call traces from firmware-level operations. If the traces do not match, the object may be flagged as suspicious.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09609005&OS=09609005&RS=09609005
owner: McAfee, Inc.
number: 09609005
owner_city: Santa Clara
owner_country: US
publication_date: 20140925
---
This application relates to the field of computer security and more particularly to a cross view malware detection engine.

Security research has evolved into a perpetual arms race between security researchers on the one hand and malware authors on the other hand. Security researchers for their part are primarily concerned with detecting and remediating malware to protect end users and enterprises from malice and harm. In contrast malware authors are concerned with avoiding detection so that their malware objects can continue to propagate across enterprises and networks.

In an example a cross view detection engine is disclosed for detecting malware behavior. Malware may attempt to avoid detection by remaining in volatile memory for as long as possible and writing to disk only when necessary. To avoid detection the malware may also provide a pseudo driver at a file system level that performs legitimate looking dummy operations. A firmware level driver may simultaneously perform malicious operations. The cross view detection engine detects this behavior by deconstructing call traces from the file system level operations and reconstructing call traces from firmware level operations. If the traces do not match the object may be flagged as suspicious

The following disclosure provides many different embodiments or examples for implementing different features of the present disclosure. Specific examples of components and arrangements are described below to simplify the present disclosure. These are of course merely examples and are not intended to be limiting. Further the present disclosure may repeat reference numerals and or letters in the various examples. This repetition is for the purpose of simplicity and clarity and does not in itself dictate a relationship between the various embodiments and or configurations discussed.

Different embodiments many have different advantages and no particular advantage is necessarily required of any embodiment.

One manifestation of the security arms race may be seen in disk operations performed by certain classes of malware objects. In one example an antivirus agent is installed on a user machine to detect certain classes of write operations by executable objects. Experiential data indicate that these types of write operations are generally performed only by malware.

In particular a goal of certain malware objects is to remain persistent on the end user s machine such as across reboots and computer crashes. Thus it is not sufficient for the malware object to simply remain in nonvolatile memory. However remaining in nonvolatile memory is the executable object s best option for evading detection in certain embodiments. Thus in one embodiment a root kit may try to avoid dynamic analysis. For example the ZeroAccess rootkit uses two techniques to modify and store persistent data on disk without being detected by dynamic analysis. In the first it uses a low level API to create a new disk volume on which it can store malicious executables. This volume is invisible to the user and to certain security agents running on the system.

In the second technique it creates a kernel mode driver. This driver calls file system APIs directly bypassing interfaces that may be monitored by antimalware agents. This driver secretly creates a configuration file in the file system and returns fake data whenever security software requests a read to infected files. Since the malicious executable resides in kernel space it need not use interfaces monitored by system call based dynamic analyzers.

In another example the TDSS rootkit also bypasses file system analysis by storing its malicious driver in raw disk sectors and overwriting the Master Boot Record MBR . The MBR loads the malicious code from the raw disk sectors during boot. This read may not be detected in dynamic analysis.

Thus a traditional anti malware engine may have difficulty detecting the malware object. However the malware object must ultimately write to disk to remain persistent. Thus certain embodiments of anti malware engines detect and flag suspicious write operations. This may subject the executable object to additional scrutiny and may ultimately result in the malware object being correctly identified as malware.

Continuing the arms race certain malware objects spoof legitimate looking disk operations at a higher more abstract level of operation while simultaneously performing low level less abstract disk operations such as raw writes to the desk without going through the file system driver. An anti malware agent operating on the computer may see only the legitimate looking disk operations to maintain a persistent copy of the malware on machine. Thus the anti malware agent may continue to believe that the disk is malware free while in fact the malware object has successfully avoided detection.

It is therefore beneficial to provide a system and method of cross view malware detection wherein a cross view detection engine is provided to monitor both high level disk operations and low level disk operations. In this context a high level disk operation is a disk operation performed such as through an application programming interface API it s file system driver or other legitimate avenue providing abstraction of file system operations. A low level disk operation is an operation that occurs below the level of a file system driver or other legitimate abstraction mechanism. It should be noted that these examples of high level and low level operations are provided by example only and are not intended to be limiting. In certain embodiments of the present Specification there may be some overlap between operations considered low level operations and high level operations. Thus in one embodiment a low level operation is any operation that is performed at a lower level of abstraction then a high level operation. Thus one example distinguishing feature between a high level operation and a low level operation is that they do not operate on identical levels of abstraction.

In one example a cross view detection engine monitors both high level disk operations and low level disk operations in the background. This may be accomplished for example by operating the cross view detection engine as a background process operating with elevated system privileges. These elevated system privileges may be in one example only slightly less privileged than the operating system itself. In another example a cross view detection engine is provided in firmware or in extremely low level software such that it actually operates at a privilege level higher than the operating system. Practitioners in the art may recognize that selection and design of a particular cross view detection engine and the level of privilege that it operates at are design decisions that may be dictated by design constraints. It is therefore intended that any such variations on a cross view detection engine be included with in this Specification.

In another example a cross view detection engine includes two or more components. One component is a firmware level driver operating with essentially unrestricted privileges while a second component is a file system level driver which may interact with the operating system and file system via operating system hooks and which may have application level privileges or elevated system privileges on the operating system. These two components may cooperate to detect malware disk operations.

In one embodiment it may be presumed that if an executable object simultaneously performs a dummy high level disk operation while also performing a low level disk operation that does not match the high level disk operation the executable object can safely be deemed malware.

By their nature low level disk operations will not be inherently or naturally comparable to high level commands. By design high level operations are intended to be more abstract than low level operations. In one example a simple write to disk may be performed at a higher level of abstraction by calling a standard library function such as fprintf . The standard library function thereafter provides the necessary low level operations to complete the disk write operation. Thus one or the other or both of high level disk operations and low level disk operations will need to be translated into a new form so that they can be usefully compared.

In one example high level disk operations are reduced to a series of call traces. Call traces and call graph clustering are described in the paper Malware Classification based on Call Graph Clustering by Joris Kinable and Orestis Kostakis published Aug. 27 2010. This paper is available as of the date of this application at http arxiv.org abs 1008.4365.

Simultaneously low level disk operations are reconstructed into equivalent call traces. Thus the deconstructed call traces of the high level operation may be compared to the reconstructed call traces of the low level operation to determine whether the call traces match.

If the call traces do not match then it may be inferred that the low level disk operation is not doing what the high level operation appears to be doing. This behavior is highly characteristic of malware and an object behaving in this way may be flagged.

It is recognized herein that there is not necessarily a simple one to one correlation between disk events and a file system operation or stated differently there is no clear sequence of events that always corresponds to an example operation such as write to file. When raw bytes are intercepted on their way to the disk the result is in fact a slice of what appears or will appear on the disk itself. To determine what operation happened a cross view detection engine may use the following information 

The intercepted data e.g. what data or metadata are being written to disk in that single transaction .

By way of example in the Windows new technology file system NTFS the main data structure is the Master File Table MFT . There is one entry in the MFT for every file on the disk and the MFT entry contains metadata describing that file for example its name and a list of all the sectors on the disk in which its contents are found .

When performing low level disk analysis the cross view detection engine does not intercept for example a specific event that correlates cleanly to create a file called newfile.txt or delete a file called newfile.txt. Rather the cross view detection engine may simply intercept a data block that has the format of an MFT entry or that resides on a sector known to contain MFT entries . The cross view detection engine may then parse the metadata to determine if there have been any changes since the metadata was last encountered.

Similarly to intercept a file write operation the cross view detection engine cannot simply identify an event that corresponds to Write abc to file newfile.txt. Rather the bus will simply send the raw bytes abc to a disk sector known to belong to the file newfile.txt 

In that context some non limiting examples of correlations between call traces and low level operations are provided below.

The intercepted MFT indicates that the file is called newfile.txt and has its contents stored on disk blocks 123000 to 123400

In other words a file was deleted and another created very quickly and the newer file took the just vacated MFT entry slot.

The semantic reconstruction of operations from raw data is file system specific that is these heuristics only apply to the Windows NTFS file system but may not necessarily apply to other file systems.

A cross view detection engine will now be described with more particular reference to the attached FIGURES.

Each computing device may include an appropriate operating system such as Microsoft Windows Linux Android Mac OSX Apple iOS Unix or similar. Some of the foregoing may be more often used on one type of device than another. For example desktop computer which in some cases may also be an engineering workstation may be more likely to use one of Microsoft Windows Linux Unix or Mac OSX. Laptop computer which is usually a portable off the shelf device with fewer customization options may be more likely to run Microsoft Windows or Mac OSX. Mobile device may be more likely to run Android or iOS. However these examples are not intended to be limiting.

Computing devices may be communicatively coupled to one another and to other network resources via network . Network may be any suitable network or combination of networks including for example a local area network a wide area network a wireless network a cellular network or the Internet by way of nonlimiting example. In this illustration network is shown as a single network for simplicity but in some embodiments network may include a large number of networks such as one or more enterprise intranets connected to the Internet.

Also connected to network are one or more servers an application repository and human actors connecting through various devices including for example an attacker and a developer . Servers may be configured to provide suitable network services including certain services disclosed in one or more examples of the present Specification. In one embodiment one or more security administrators administer servers and at least a part of network .

It may be a goal of users to successfully operate their respective computing devices without interference from attacker and developer . In one example attacker is a malware author whose goal or purpose is to cause malicious harm or mischief. The malicious harm or mischief may take the form of installing root kits or other malware on computing devices to tamper with the system installing spyware or adware to collect personal and commercial data defacing websites operating a botnet such as a spam server or simply to annoy and harass users . Thus one aim of attacker may be to install his malware on one or more computing devices . As used throughout this Specification malicious software malware includes any virus trojan zombie rootkit backdoor worm spyware adware ransomware dialer payload malicious browser helper object cookie logger or similar designed to take a potentially unwanted action including by way of non limiting example data destruction covert data collection browser hijacking network proxy or redirection covert tracking data logging keylogging excessive or deliberate barriers to removal contact harvesting and unauthorized self propagation.

Servers may be operated by a suitable enterprise to provide security updates and services including anti malware services. Servers may also provide substantive services such as routing networking enterprise data services and enterprise applications. In one example servers are configured to distribute and enforce enterprise computing and security policies. These policies may be administered by security administrator according to written enterprise policies. Security administrator may also be responsible for administering and configuring servers and all or a portion of network .

Developer may also operate on network . Developer may not have malicious intent but may develop software that poses a security risk. For example a well known and often exploited security flaw is the so called buffer overrun in which a malicious user such as attacker is able to enter an overlong string into an input form and thus gain the ability to execute arbitrary instructions or operate with elevated privileges on a computing device . Buffer overruns may be the result for example of poor input validation or incomplete garbage collection and in many cases arise in nonobvious contexts. Thus although not malicious himself developer may provide an attack vector for attacker . Applications developed by developer may also cause inherent problems such as crashes data loss or other undesirable behavior. Developer may host software himself or may upload his software to an application repository . Because software from developer may be desirable itself it may be beneficial for developer to occasionally provide updates or patches that repair vulnerabilities as they become known.

Application repository may represent a Windows or Apple app store a Unix like repository or ports collection or other network service providing users the ability to interactively or automatically download and install applications on computing devices . Developer and attacker may both provide software via application repository . If application repository has security measures in place that make it difficult for attacker to distribute overtly malicious software attacker may instead stealthily insert vulnerabilities into apparently beneficial applications.

In some cases one or more users may belong to an enterprise. The enterprise may provide policy directives that restrict the types of applications that can be installed for example from application repository . Thus application repository may include software that is not negligently developed and is not malware but that is nevertheless against policy. For example some enterprises restrict installation of entertainment software like media players and games. Thus even a secure media player or game may be unsuitable for an enterprise computer. Security administrator may be responsible for distributing a computing policy consistent with such restrictions.

In another example user may be a parent of young children and wish to protect the children from undesirable content such as pornography adware spyware age inappropriate content advocacy for certain political religious or social movements or forums for discussing illegal or dangerous activities by way of non limiting example. In this case the parent may perform some or all of the duties of security administrator .

Collectively any object that is a candidate for being one of the foregoing types of content may be referred to as potentially unwanted content PUC . The potentially aspect of PUC means that when the object is marked as PUC it is not necessarily blacklisted. Rather it is a candidate for being an object that should not be allowed to reside or work on a computing device . Thus it is a goal of users and security administrator to configure and operate computing devices so as to usefully analyze PUC and make intelligent decisions about how to respond to a PUC object. This may include an agent on computing device such as cross view detection engine of which may communicate with servers for additional intelligence. Servers may provide network based services including server engine of that are configured to enforce policies and otherwise assist computing devices in properly classifying and acting on PUC.

Client device includes a processor connected to a memory having stored therein executable instructions for providing an operating system and cross view detection engine . Other components of client device include a storage network interface and peripheral interface .

In an example processor is communicatively coupled to memory via memory bus which may be for example a direct memory access DMA bus by way of example though other memory architectures are possible including ones in which memory communicates with processor via system bus or some other bus. Processor may be communicatively coupled to other devices via a system bus . As used throughout this Specification a bus includes any wired or wireless interconnection line network connection bundle single bus multiple buses crossbar network single stage network multistage network or other conduction medium operable to carry data signals or power between parts of a computing device or between computing devices. It should be noted that these uses are disclosed by way of non limiting example only and that some embodiments may omit one or more of the foregoing buses while others may employ additional or different buses.

In various examples a processor may include any combination of hardware software or firmware providing programmable logic including by way of non limiting example a microprocessor digital signal processor field programmable gate array programmable logic array application specific integrated circuit or virtual machine processor.

Processor may be connected to memory in a DMA configuration via DMA bus . To simplify this disclosure memory is disclosed as a single logical block but in a physical embodiment may include one or more blocks of any suitable volatile or non volatile memory technology or technologies including for example DDR RAM SRAM DRAM cache L1 or L2 memory on chip memory registers flash ROM optical media virtual memory regions magnetic or tape memory or similar. In certain embodiments memory may comprise a relatively low latency volatile main memory while storage may comprise a relatively higher latency non volatile memory. However memory and storage need not be physically separate devices and in some examples may represent simply a logical separation of function. It should also be noted that although DMA is disclosed by way of non limiting example DMA is not the only protocol consistent with this Specification and that other memory architectures are available.

Storage may be any species of memory or may be a separate device such as a hard drive solid state drive external storage redundant array of independent disks RAID network attached storage optical storage tape drive backup system cloud storage or any combination of the foregoing. Storage may be or may include therein a database or databases or data stored in other configurations and may include a stored copy of operational software such as operating system and software portions of cross view detection engine . Many other configurations are also possible and are intended to be encompassed within the broad scope of this Specification.

Network interface may be provided to communicatively couple client device to a wired or wireless network. A network as used throughout this Specification may include any communicative platform operable to exchange data or information within or between computing devices including by way of non limiting example an ad hoc local network an internet architecture providing computing devices with the ability to electronically interact a plain old telephone system POTS which computing devices could use to perform transactions in which they may be assisted by human operators or in which they may manually key data into a telephone or other suitable electronic equipment any packet data network PDN offering a communications interface or exchange between any two nodes in a system or any local area network LAN metropolitan area network MAN wide area network WAN wireless local area network WLAN virtual private network VPN intranet or any other appropriate architecture or system that facilitates communications in a network or telephonic environment.

Cross view detection engine in one example is a utility or program that carries out a method such as method of or other methods according to this Specification. Cross view detection engine may be in various embodiments embodied in hardware software firmware or some combination thereof. For example in some cases cross view detection engine may include a special integrated circuit designed to carry out a method or a part thereof and may also include software instructions operable to instruct a processor to perform the method. In some cases cross view detection engine may run as a daemon process. A daemon may include any program or series of executable instructions whether implemented in hardware software firmware or any combination thereof that runs as a background process a terminate and stay resident program a service system extension control panel bootup procedure BIOS subroutine or any similar program that operates without direct user interaction. It should also be noted that cross view detection engine is provided by way of non limiting example only and that other hardware and software including interactive or user mode software may also be provided in conjunction with in addition to or instead of cross view detection engine to perform methods according to this Specification.

In one example cross view detection engine includes executable instructions stored on a non transitory medium operable to perform antimalware operations. At an appropriate time such as upon booting client device or upon a command from operating system or a user processor may retrieve a copy of cross view detection engine or software portions thereof from storage and load it into memory . Processor may then iteratively execute the instructions of cross view detection engine .

Cross view detection engine and antivirus engine may combine to provide standard antivirus services. Cross view detection engine includes a system level interface and a low level interface .

Low level interface may be provided for example in firmware or in extremely low level software so that it may in some cases operate below the abstraction level of operating system . System level interface may operate above the abstraction level of operating system and may have elevated system privileges. This means that although system level interface does not have the unfettered access of low level interface it may have higher system privileges than user space application programs. This enables system level interface to insert hooks into operating system so as to intercept disk operations for purposes of comparison. In certain embodiments system level interface may be provided at a virtualization level or at a hypervisor level.

Peripheral interface may be configured to interface with any auxiliary device that connects to client device but that is not necessarily a part of the core architecture of client device . A peripheral may be operable to provide extended functionality to client device and may or may not be wholly dependent on client device . In some cases a peripheral may be a computing device in its own right. Peripherals may include input and output devices such as displays terminals printers keyboards mice modems network controllers sensors transducers actuators controllers data acquisition buses cameras microphones speakers or external storage by way of non limiting example.

Server includes a processor connected to a memory having stored therein executable instructions for providing an operating system and server engine . Other components of server include a storage network interface and peripheral interface .

In an example processor is communicatively coupled to memory via memory bus which may be for example a direct memory access DMA bus. Processor may be communicatively coupled to other devices via a system bus .

Processor may be connected to memory in a DMA configuration via DMA bus . To simplify this disclosure memory is disclosed as a single logical block but in a physical embodiment may include one or more blocks of any suitable volatile or non volatile memory technology or technologies as described in connection with memory of . In certain embodiments memory may comprise a relatively low latency volatile main memory while storage may comprise a relatively higher latency non volatile memory. However memory and storage need not be physically separate devices as further described in connection with

Storage may be any species of memory or may be a separate device as described in connection with storage of . Storage may be or may include therein a database or databases or data stored in other configurations and may include a stored copy of operational software such as operating system and software portions of server engine . Many other configurations are also possible and are intended to be encompassed within the broad scope of this Specification.

Server engine in one example is a utility or program that carries out methods according to this Specification including providing server side anti malware services and updates for computing devices . Server engine may also perform deep analysis of suspect objects to provide a higher confidence of whether the object is malicious. Server engine may be in various embodiments embodied in hardware software firmware or some combination thereof. For example in some cases server engine may include a special integrated circuit designed to carry out a method or a part thereof and may also include software instructions operable to instruct a processor to perform the method. In some cases server engine may run as a daemon process as described above. It should also be noted that server engine is provided by way of non limiting example only and that other hardware and software including interactive or user mode software may also be provided in conjunction with in addition to or instead of server engine to perform methods according to this Specification.

In one example server engine includes executable instructions stored on a non transitory medium operable to perform methods according to this Specification. At an appropriate time such as upon booting server or upon a command from operating system or a user processor may retrieve a copy of server engine or software portions thereof from storage and load it into memory . Processor may then iteratively execute the instructions of server engine .

Peripheral interface may be configured to interface with any auxiliary device that connects to server but that is not necessarily a part of the core architecture of server . A peripheral may be operable to provide extended functionality to server and may or may not be wholly dependent on server . In some cases a peripheral may be a computing device in its own right. Peripherals may include by way of non limiting examples any of the devices discussed in connection with peripheral interface of .

Firmware sits just above hardware on an abstraction level and just below hardware on a privilege level. Firmware may for example provide a small number of direct commands which can be translated into electrical signals for use with hardware .

Monitoring of low level disk operations may in one example occur at either hardware level or at firmware level . One method may be to monitor an ATAPI SCSI or SATA bus for information such as sector number operation type read or write and the data being read or written.

Malware and cross view detection engine both include a low level driver to directly manipulate and or monitor firmware . Cross view detection engine provides low level driver . Malware provides low level driver . In one example malware uses low level driver to directly manipulate disk operations on hardware via a firmware . These operations may not be visible at operating system level . However cross view detection engine uses low level driver to observe these interactions.

At the next level of abstraction is operating system . Operating system may provide a variety of drivers interfaces and services that enable higher level programs to perform hardware operations. One useful function of operating system is to provide abstraction via drivers so that a single object such as an executable process can issue identical commands to perform useful work on a variety of hardware platforms. For example hardware may be a hard disk drive provided by a manufacturer. Because operating system abstracts disk operations provided to hardware an end user need not know or care about which specific hard drive from which specific manufacturer will be used at hardware level .

At the next level of abstraction is file system driver . File system driver provides a low level interface via operating system organizing storing and retrieving files. Popular file system drivers include Windows NTFS ext3 or ext4 on Linux Apple hierarchical file system HFS and various UNIX file systems such as UFS BSDFS and ZFS.

Malware may provide a high level pseudo driver that interfaces with file system driver . The purpose of malware pseudo driver is to issue dummy commands to file system driver to create the appearance of performing legitimate file operations. However low level driver blocks these commands so that they are not actually executed on the disk hardware . Rather while those dummy commands are being issued low level driver is performing the task actually required by malware . Note that interception of calls at the file system driver level is provided as an example only. In other cases these operations may occur at other levels of abstraction including at a hypervisor or virtual machine level.

Cross view detection engine also includes a high level driver . It should be noted that the designation of driver as high level is in relation to low level driver not necessarily in relation to other levels of abstraction such as user space applications which operate at an even higher level of abstraction and with lower levels of privilege. The purpose of high level driver is to observe the behavior of high level pseudo driver so that operations ostensibly performed by high level pseudo driver can be compared to operations actually carried out at firmware level .

At the next level of abstraction is application programming interface . Application programming interface provides various standard methods so that user space applications can perform file operations without the necessity of being concerned about specific implementation details of those operations. For example application programming interface may provide an fprintf function which a user space application can use to write to disk without needing to be aware about the implementation details.

At the next level of abstraction is antivirus engine . Antivirus engine may provide standard anti malware or antivirus operations such as detection mitigation and remediation of malware objects. Antivirus engine is provided in addition to cross view detection engine so that they can cooperatively work to increase the security of computing device . It should be noted however that in certain embodiments antivirus engine is optional.

At the highest level of abstraction in this example and conversely at the lowest level of privilege are user space applications . User space applications may have permission only to write to certain files or folders provided by file system driver or only according to certain permissions granted to user space applications .

In one example method starts with two parallel paths. High level driver may use the path of block while low level driver may use the path of block .

In block high level driver performs dynamic real time analysis of system level call traces. This may include intercepting disk operations at a useful level such as at file system driver level and analyzing those.

In block cross view detection engine extracts call traces from high level operations detected in block . This results in block in extracted call traces.

In the parallel path of block low level driver intercepts disk access information from standard disk protocols such as those provided by firmware .

In block cross view detection engine reconstructs system level call traces from the low level access operations. This results in block in reconstructed call traces.

In block cross view detection engine compares reconstructed call traces to deconstructed call traces .

In decision block cross view detection engine determines whether the reconstruction call traces match the deconstructed call traces .

In block if reconstructing call traces match deconstructed call traces then operations may be passed to standard antivirus engine . Antivirus engine may then perform standard antivirus operations such as looking for other examples of malware behavior.

As used throughout this Specification a reconstructed call trace is a call trace that has been translated from a lower level of abstraction into a higher level of abstraction. A deconstructed call trace is a call trace that has been translated from a higher level of abstraction into a lower level of abstraction. In one example a reconstructed call trace and deconstructed call trace are constructed to a similar level of abstraction so that they can be usefully compared.

Returning to decision block if reconstructed call traces do not match deconstructed call traces then the object performing the disk access may be marked either as malware or at least as suspicious. Objects marked as malware may be blacklisted while objects listed as suspicious may be subject to additional analysis including in some examples reporting the object to server so that server may use server engine to perform greater or more in depth analysis of the object and to report back to computing device whether the object ought to be blocked.

The foregoing outlines features of several embodiments so that those skilled in the art may better understand the aspects of the present disclosure. Those skilled in the art should appreciate that they may readily use the present disclosure as a basis for designing or modifying other processes and structures for carrying out the same purposes and or achieving the same advantages of the embodiments introduced herein. Those skilled in the art should also realize that such equivalent constructions do not depart from the spirit and scope of the present disclosure and that they may make various changes substitutions and alterations herein without departing from the spirit and scope of the present disclosure.

The particular embodiments of the present disclosure may readily include a system on chip SOC central processing unit CPU package. An SOC represents an integrated circuit IC that integrates components of a computer or other electronic system into a single chip. It may contain digital analog mixed signal and radio frequency functions all of which may be provided on a single chip substrate. Other embodiments may include a multi chip module MCM with a plurality of chips located within a single electronic package and configured to interact closely with each other through the electronic package. In various other embodiments the digital signal processing functionalities may be implemented in one or more silicon cores in Application Specific Integrated Circuits ASICs Field Programmable Gate Arrays FPGAs and other semiconductor chips.

In example implementations at least some portions of the processing activities outlined herein may also be implemented in software. In some embodiments one or more of these features may be implemented in hardware provided external to the elements of the disclosed figures or consolidated in any appropriate manner to achieve the intended functionality. The various components may include software or reciprocating software that can coordinate in order to achieve the operations as outlined herein. In still other embodiments these elements may include any suitable algorithms hardware software components modules interfaces or objects that facilitate the operations thereof.

Additionally some of the components associated with described microprocessors may be removed or otherwise consolidated. In a general sense the arrangements depicted in the figures may be more logical in their representations whereas a physical architecture may include various permutations combinations and or hybrids of these elements. It is imperative to note that countless possible design configurations can be used to achieve the operational objectives outlined herein. Accordingly the associated infrastructure has a myriad of substitute arrangements design choices device possibilities hardware configurations software implementations equipment options etc.

Any suitably configured processor component can execute any type of instructions associated with the data to achieve the operations detailed herein. Any processor disclosed herein could transform an element or an article for example data from one state or thing to another state or thing. In another example some activities outlined herein may be implemented with fixed logic or programmable logic for example software and or computer instructions executed by a processor and the elements identified herein could be some type of a programmable processor programmable digital logic for example a field programmable gate array FPGA an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM an ASIC that includes digital logic software code electronic instructions flash memory optical disks CD ROMs DVD ROMs magnetic or optical cards other types of machine readable mediums suitable for storing electronic instructions or any suitable combination thereof. In operation processors may store information in any suitable type of non transitory storage medium for example random access memory RAM read only memory ROM field programmable gate array FPGA erasable programmable read only memory EPROM electrically erasable programmable ROM EEPROM etc. software hardware or in any other suitable component device element or object where appropriate and based on particular needs. Further the information being tracked sent received or stored in a processor could be provided in any database register table cache queue control list or storage structure based on particular needs and implementations all of which could be referenced in any suitable timeframe. Any of the memory items discussed herein should be construed as being encompassed within the broad term memory. Similarly any of the potential processing elements modules and machines described herein should be construed as being encompassed within the broad term microprocessor or processor. Furthermore in various embodiments the processors memories network cards buses storage devices related peripherals and other hardware elements described herein may be realized by a processor memory and other related devices configured by software or firmware to emulate or virtualize the functions of those hardware elements.

Computer program logic implementing all or part of the functionality described herein is embodied in various forms including but in no way limited to a source code form a computer executable form and various intermediate forms for example forms generated by an assembler compiler linker or locator . In an example source code includes a series of computer program instructions implemented in various programming languages such as an object code an assembly language or a high level language such as OpenCL Fortran C C JAVA or HTML for use with various operating systems or operating environments. The source code may define and use various data structures and communication messages. The source code may be in a computer executable form e.g. via an interpreter or the source code may be converted e.g. via a translator assembler or compiler into a computer executable form.

In the discussions of the embodiments above the capacitors buffers graphics elements interconnect boards clocks DDRs camera sensors dividers inductors resistors amplifiers switches digital core transistors and or other components can readily be replaced substituted or otherwise modified in order to accommodate particular circuitry needs. Moreover it should be noted that the use of complementary electronic devices hardware non transitory software etc. offers an equally viable option for implementing the teachings of the present disclosure.

In one example embodiment any number of electrical circuits of the FIGURES may be implemented on a board of an associated electronic device. The board can be a general circuit board that can hold various components of the internal electronic system of the electronic device and further provide connectors for other peripherals. More specifically the board can provide the electrical connections by which the other components of the system can communicate electrically. Any suitable processors inclusive of digital signal processors microprocessors supporting chipsets etc. memory elements etc. can be suitably coupled to the board based on particular configuration needs processing demands computer designs etc. Other components such as external storage additional sensors controllers for audio video display and peripheral devices may be attached to the board as plug in cards via cables or integrated into the board itself. In another example embodiment the electrical circuits of the FIGURES may be implemented as stand alone modules e.g. a device with associated components and circuitry configured to perform a specific application or function or implemented as plug in modules into application specific hardware of electronic devices.

Note that with the numerous examples provided herein interaction may be described in terms of two three four or more electrical components. However this has been done for purposes of clarity and example only. It should be appreciated that the system can be consolidated in any suitable manner. Along similar design alternatives any of the illustrated components modules and elements of the FIGURES may be combined in various possible configurations all of which are clearly within the broad scope of this Specification. In certain cases it may be easier to describe one or more of the functionalities of a given set of flows by only referencing a limited number of electrical elements. It should be appreciated that the electrical circuits of the FIGURES and its teachings are readily scalable and can accommodate a large number of components as well as more complicated sophisticated arrangements and configurations. Accordingly the examples provided should not limit the scope or inhibit the broad teachings of the electrical circuits as potentially applied to a myriad of other architectures.

Numerous other changes substitutions variations alterations and modifications may be ascertained to one skilled in the art and it is intended that the present disclosure encompass all such changes substitutions variations alterations and modifications as falling within the scope of the appended claims. In order to assist the United States Patent and Trademark Office USPTO and additionally any readers of any patent issued on this application in interpreting the claims appended hereto Applicant wishes to note that the Applicant a does not intend any of the appended claims to invoke paragraph six 6 of 35 U.S.C. section 112 as it exists on the date of the filing hereof unless the words means for or steps for are specifically used in the particular claims and b does not intend by any statement in the Specification to limit this disclosure in any way that is not otherwise reflected in the appended claims.

There is disclosed in an example 1 a computing apparatus comprising a memory and a crossview detection engine operable for observing a first operation performed by an executable object on the memory at a first abstraction level observing a substantially simultaneous second operation performed by the executable object on the memory at a second abstraction level making a determination that the first operation does not substantially match the second operation and acting on the determination.

There is disclosed in an example 2 the computing apparatus of example 1 wherein the first abstraction level is a file system driver level.

There is disclosed in an example 3 the computing apparatus of example 1 wherein the second abstraction level is a firmware level.

There is disclosed in an example 4 the computing apparatus of example 1 wherein the second abstraction level is a lower abstraction level than the first abstraction level.

There is disclosed in an example 5 the computing apparatus of example 1 wherein the second operation is a write operation.

There is disclosed in an example 6 the computing apparatus of example 1 wherein acting on the determination comprises designating the executable object as malware.

There is disclosed in an example 7 the computing apparatus of example 1 wherein acting on the determination comprises designating the executable object as suspicious and reporting the executable object to a server.

There is disclosed in an example 8 the computing apparatus of example 1 wherein making a determination that the first operation does not substantially match the second operation comprises reconstructing one or more call traces from the second operation.

There is disclosed in an example 9 the computing apparatus of example 1 wherein making a determination that the first operation does not substantially match the second operation comprises deconstructing one or more call traces from the first operation.

There is disclosed in an example 10 the computing apparatus of example 1 wherein making a determination that the first operation does not substantially match the second operation comprises reconstructing one or more call traces from the second operation deconstructing one or more call traces from the first operation and comparing the reconstructed call traces to the deconstructed call traces.

There is disclosed in an example 11 the computing apparatus of example 1 wherein observing the first operation performed by the executable object on the memory at the first abstraction level comprises performing dynamic analysis of system level call tracing.

There is disclosed in an example 12 the computing apparatus of example 11 wherein observing the first operation performed by the executable object on the memory at the first abstraction level further comprises real time analysis of call traces.

There is disclosed in an example 13 the computing apparatus of example 1 wherein observing the substantially simultaneous second operation performed by the executable object on the memory at a second abstraction level comprises intercepting disk access information from disk protocols.

There is disclosed in an example 14 one or more computer readable mediums having stored thereon executable instructions for providing a cross view detection engine operable for observing a first operation performed by an executable object on a memory at a first abstraction level observing a substantially simultaneous second operation performed by the executable object on the memory at a second abstraction level making a determination that the first operation does not substantially match the second operation and acting on the determination.

There is disclosed in an example 15 the one or more computer readable mediums of example 14 wherein the first abstraction level is a file system driver level.

There is disclosed in an example 16 the one or more computer readable mediums of example 14 wherein the second abstraction level is a firmware level.

There is disclosed in an example 17 the one or more computer readable mediums of example 14 wherein the second abstraction level is a lower abstraction level than the first abstraction level.

There is disclosed in an example 18 the one or more computer readable mediums of example 14 wherein the second operation is a write operation.

There is disclosed in an example 19 the one or more computer readable mediums of example 14 wherein acting on the determination comprises designating the executable object as malware.

There is disclosed in an example 20 the one or more computer readable mediums of example 14 wherein acting on the determination comprises designating the executable object as suspicious and reporting the executable object to a server.

There is disclosed in an example 21 the one or more computer readable mediums of example 14 wherein making a determination that the first operation does not substantially match the second operation comprises reconstructing one or more call traces from the second operation deconstructing one or more call traces from the first operation and comparing the reconstructed call traces to the deconstructed call traces.

There is disclosed in an example 22 the one or more computer readable mediums of example 14 wherein observing the first operation performed by the executable object on the memory at the first abstraction level comprises performing real time dynamic analysis of system level call tracing.

There is disclosed in an example 23 the one or more computer readable mediums of example 14 wherein observing the substantially simultaneous second operation performed by the executable object on the memory at a second abstraction level comprises intercepting disk access information from disk protocols.

There is disclosed in an example 24 a computer implemented method of providing a cross view detection engine comprising observing a first operation performed by an executable object on the memory at a first abstraction level observing a substantially simultaneous second operation performed by the executable object on the memory at a second abstraction level making a determination that the first operation does not substantially match the second operation and acting on the determination.

There is disclosed in an example 25 the method of example 24 wherein making a determination that the first operation does not substantially match the second operation comprises reconstructing one or more call traces from the second operation deconstructing one or more call traces from the first operation and comparing the reconstructed call traces to the deconstructed call traces.

There is disclosed in an example 26 a method comprising the performing the instructions disclosed in any of examples 14 23.

There is disclosed in example 27 an apparatus comprising means for performing the method of example 26.

There is disclosed in example 28 the apparatus of example 27 wherein the apparatus comprises a processor and memory.

There is disclosed in example 29 the apparatus of example 28 wherein the apparatus further comprises a computer readable medium having stored thereon software instructions for performing the method of example 26.

