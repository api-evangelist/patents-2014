---

title: System and method for matching synthetically generated inner classes and methods
abstract: A system and method for transforming name synthesized classes in response to dynamic class updates to existing classes, featuring the ability to provide replacement synthetic names for reloaded name synthesized classes. According to a preferred embodiment, the name synthesized classes are anonymous classes. The method stores and tracks the synthetic names for each name synthesized class as they are loaded or reloaded, intercepting the loading of the classes before being defined in a virtual machine. Then, the method maps the synthetic name of the name synthesized classes for each dynamic class update to replacement synthetic names of previously loaded name synthesized classes. In addition, the concepts of the invention are applicable to other types of name synthesized classes, such as local classes, bridge methods and lambda expressions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09411617&OS=09411617&RS=09411617
owner: ZeroTurnaround AS
number: 09411617
owner_city: Tartu
owner_country: EE
publication_date: 20141002
---
This application claims the benefit under 35 USC 119 e of U.S. Provisional Application No. 61 886 362 filed on Oct. 3 2013 which is incorporated herein by reference in its entirety.

A platform is a combination of hardware architecture and or software that enables software to run on user devices such as desktop computers mobile phones and tablets. Software platforms are typically a combination of software libraries and other executables that present well defined Application Programming Interfaces API . Software developers are increasingly utilizing modern software platforms to enable the creation of platform independent applications. Modern software platforms typically include a programming language the compiled output of which executes within the context of machine dependent programs known as virtual machines VM .

Java is a registered trademark of Oracle Corporation. Oracle associates the Java trademark with its eponymous computer programming language Java Virtual Machine JVM and related infrastructure and tools. .NET is a registered trademark of Microsoft Corporation. For its .NET framework Microsoft provides its C programming language .NET Common Language Runtime and related infrastructure and tools. The .NET Common Language Runtime is the Virtual Machine component of Microsoft s NET framework.

A VM is a software program or library that permits an isolated processing environment to exist on a computer system. VMs hide or abstract the details of the underlying computer system from the software that executes within each VM. To create platform independent applications software developers use platform tools to compile the programming language source code into the software executable that runs on the VMs also known as bytecode. Bytecode is typically a set of binary files that include platform neutral instructions for implementing application behavior. The VMs interpret the bytecode and execute corresponding native instructions on the target computer system associated with the bytecode. Examples of software platforms that enable the creation of computer system independent applications include the Java and .NET platforms.

The Java programming language and runtime package support the tenets of object oriented programming which includes the principles of inheritance polymorphism and data hiding. Java organizes programming objects into conceptual classes and saves the compiled bytecode for its classes into data files also known as class files. Typically the Java compiler generates one class file for each class defined in a source file and the name of the class file corresponds to the defined class name within the source file.

In the case of the Java programming language the Java compiler converts the source code for each Java class definition into its associated bytecode. For example the Java compiler accepts a source file named MyClass.java with source code that includes the class definition for named class MyClass converts the source code to bytecode and stores the bytecode in class file MyClass.class .

However instead of defining all classes in separate files software developers can also define one or more classes within another class. The outer class that includes the definitions of other classes is referred to as the enclosing class and the classes defined within the enclosing class are referred to as nested or inner classes.

Developers typically define inner classes to limit the scope of their behaviors to be within the same enclosing class and to ensure high cohesion between classes which share a well defined responsibility. In Java there are 4 types of inner classes static member classes member classes local classes and anonymous classes.

When a member of a class is declared as static in Java by prefacing the member with the static keyword only one copy of the data is maintained for all objects of that class. Of the 4 types of inner classes member classes and static member classes refer to classes that are declared within the body of an enclosing class and are therefore named members of the enclosing class. Static member classes and member classes exhibit similar naming conventions and are therefore referred to as member classes henceforth.

Local classes and anonymous classes are classes that are defined within a method of an enclosing class and therefore have scope that is local only to the method in which they are defined. Local classes have a defined name and anonymous classes have no name. As a result local and anonymous classes are often referred to as named non member classes and unnamed non member classes respectively. Multiple same named local classes can be declared within the same outer class as long as the scope of the local classes differs.

In contrast to member classes local classes and anonymous classes share a common naming scheme that includes synthetically generated parts such as variables in their class names. The java compiler includes the synthetically generated parts in the class names so that their class names are unique. This allows the proper bytecode for each local and anonymous class to be linked and executed at run time.

In general classes having synthetically generated names are defined as any class name identified at run time that differs from its originally defined class name in source code if such source code exists. With respect to Java synthetically generated names are associated with class names for local classes anonymous classes generated classes and lambda classes in examples. Lambda classes are also known as lambda expressions. An example of a generated class is a bridge method. As a convenient shorthand classes having synthetically generated names are also referred to as name synthesized classes.

Of the inner classes only member classes are fully named meaning that their original class names are not modified. Although member classes are defined within an enclosing class the compiler generates a separate class file for each member class that includes the bytecode for each member class. The name for each member class file is the name of the member class appended to the enclosing class name. Using Java as an example source file Outer.java provides a definition for class Outer. The class definition for class Outer then includes a class definition for a member class named Inside. The Java compiler generates class files Outer.class and Outer Inside.class which include the bytecode associated with the definitions of classes Outer and Inside respectively.

Anonymous classes in contrast enable developers to declare and instantiate a class at the same time. Though they are classes they do not have a class name in their source files. Anonymous classes allow developers to declare an inner class within the source code of an enclosing class without naming the class. Anonymous classes are typically utilized when developers need to construct only one locally scoped instance of a class in an application.

Unlike local and member classes an anonymous class definition is an expression. The expression associated with an anonymous class includes the new operator and is therefore similar to a constructor call. Because an anonymous class definition is an expression it is terminated with a semicolon. An anonymous class is a subclass of a named class or declared interface where the anonymous class overrides some or the entire set of behaviors of the named superclass or interface.

As with member classes the compiler generates individual class files that include the bytecode for each anonymous class. However because anonymous classes have no name the compiler synthetically generates a class file name for each anonymous class. Specifically when naming each anonymous class the Java compiler typically creates a name that includes the declared name of the enclosing class as a prefix followed by a character and followed by a generated numerical value suffix.

During compilation the compiler performs top down traversal of the source code for each enclosing class. For each anonymous class that the compiler encounters during compilation the compiler monotonically increases the generated numerical value. A compiler performing compilation upon an enclosing class named Enclosing for example would typically generate class file name Enclosing 1.class for the first anonymous class encountered within class Enclosing Enclosing 2.class for the second anonymous class encountered etc. This provides each anonymous class with a uniquely named class file.

Though local classes are named classes like member classes local classes can include synthetic parts in the compiled class file name. For example when two same named local classes are declared within the same enclosing class but with different scope e.g. within two different methods the Java compiler typically creates a name that includes the declared name of the enclosing class as a prefix followed by a character followed by a generated numerical value and followed by the specifically declared local class name.

Software developers change the behavior of an application by making changes to the classes that define the behavior of the application. Java provides a limited ability to change the behavior of running applications without having to stop and restart the applications. This is accomplished via run time class reloading. Run time class reloading provides the ability to update the definitions of currently loaded classes of an application running on a computer system with redefined versions of the classes in response to a dynamic class update to the existing classes.

The currently loaded classes are associated with versions of the classes that were loaded by a class loader of a JVM during creation of the application. For this reason the class files that are currently loaded in a running instance of an application are also known as existing classes. Because the dynamic class update loads redefined versions of the existing classes at run time the redefined versions of the classes are also known as reloaded classes.

Java supports run time class reloading via its HotSwap feature. Current HotSwap implementations are built into stock versions of major JVMs. Using HotSwap a developer can create a new definition for a class currently loaded in a running instance of an application and apply this new definition of the class without having to stop and restart the application instance to incorporate the new class definition. The new class definition is also known as a class redefinition.

However HotSwap s run time class redefinition capability is limited. It does not support many different ways that classes can be redefined. Specifically HotSwap only supports redefinitions of method bodies of existing classes. In examples HotSwap does not support changes to constructors of existing classes and changes to the superclass hierarchy of existing classes. In addition HotSwap often experiences run time execution errors when existing classes include inner classes such as anonymous classes and the reloaded classes include changes that modify the contents or execution order of the anonymous classes.

The HotSpot VM has provided a limited ability to redefine classes at runtime since JDK 1.4. This functionality is largely based on the work of Mikhail Dmitriev from Safe Class and Data Evolution in Large and Long Lived Java Applications PhD thesis University of Glasgow 2001. More recent run time class redefinition proposals include Dynamic code evolution for Java Thomas W rthinger Proceedings of the 8th International Conference on the Principles and Practice of Programming in Java PPPJ 2010 Vienna Austria Sep. 15 17 2010. The Dynamic Code Evolution VM DCEVM allows arbitrary changes to class definitions. In addition a publication by Allan Raundahl Gregersen Extending NetBeans with Dynamic Update of Active Modules PhD thesis University of Southern Denmark 2010 discusses dynamic update of code modules using the NetBeans development platform. NetBeans is a registered trademark of Oracle Inc.

Currently the most widespread run time class reloading system in use is JRebel an application level system that enables runtime reloading of classes by utilizing bytecode re writing at class load time. JRebel is a registered trademark of ZeroTurnaround USA Inc.

For run time reloading of member classes though the contents of an originally loaded class and a redefined class may change a Java class loader always loads the correct class file from the list of class files in an application. This is because for member classes the class file name created by the compiler is eponymous with its declared class name in the Java source code.

Fingerprint algorithms are primarily used to generate unique fixed length output data that acts as a shortened reference to the original data. This is useful when the original data is too cumbersome to use in its original format. The fixed length output data also referred to as a fingerprint is a unique identifier that provides for such capabilities as searching and matching of the original data that would have been difficult or impossible using the format of the original data. A typical example of a fingerprint algorithm is a hash function.

Current state of the art dynamic class reloading mechanisms like JRebel and DCEVM provide the ability to change the code within an existing class and to add new classes. However even these systems do not adequately handle changes to anonymous classes and other name synthesized classes even in simple scenarios. One such scenario is when two different but type compatible anonymous classes swap positions in the class file between the originally loaded class file and in the redefined class file after run time reloading. If the code before the class reload operation had included a reference to an object of the first anonymous class the JVM would instead execute the code declared in the second anonymous class after performing the class reloading.

Moreover current state of the art class reloading systems will not properly handle changes to the ordered set of anonymous classes for currently running objects. Examples include when redefined versions of the anonymous classes include changes to one or more of the named super types of the anonymous classes and when a class redefinition includes a new anonymous class. Such changes will likely cause unexpected behavior and errors for running applications.

The present invention relates to the ability to dynamically redefine classes in a running Java application. More particularly the present invention enables correct runtime behavior when an existing set of classes in a running application include name synthesized classes such as anonymous classes and the definitions of the anonymous classes are changed by a class reloading event that includes redefined versions of the anonymous classes in a dynamic update.

During a dynamic update because the definitions of existing classes are reloaded with new redefined versions of the existing classes the new definitions of the existing classes are also known as reloaded classes. In a similar fashion reloaded versions of name synthesized classes of existing classes are also known as reloaded name synthesized classes.

Examples of problems that can occur when dynamically updating anonymous classes include when the compile time declaration order of anonymous classes changes after a class reloading such as when a class redefinition includes a new anonymous class inserted between two existing anonymous class definitions or when there are changes to the definitions of the anonymous classes themselves.

In addition the invention provides the ability to reload changes to other name synthesized classes and generated classes such as same named local classes bridge methods synthetic classes generated classes and lambda expressions classes. In the case of Lambda classes the compiler typically generates synthetic methods for each Lambda expression where a suffix based on source file position is utilized to provide uniqueness in bytecode.

The ability to reload changes to anonymous classes and other name synthesized classes and generated classes at runtime provides significant advantages over present approaches to dynamic class redefinition. Moreover an increasing number of non Java programming languages have begun to produce software that runs on the Java Virtual Machine. Noteworthy examples include JRuby JPython Groovy and Scala. The concepts detailed in this invention can be likewise applied to other such languages that support generation of synthetic runtime artifacts and run time class reloading.

In general according to one aspect the invention features a method for transforming name synthesized classes of existing classes of an application running on a computer system in response to dynamic class updates to the existing classes. In response to a run time event that reloads the name synthesized classes of the existing classes with reloaded name synthesized classes the method compares unique identifiers for each of the reloaded name synthesized classes with entries in a data structure that represents the unique identifiers for previously loaded name synthesized classes wherein each of the reloaded name synthesized classes has a synthetic name. In response to finding that a unique identifier for a reloaded name synthesized class matches an entry in the data structure the method replaces occurrences of its synthetic name within the bytecode of the reloaded name synthesized class with a replacement synthetic name.

In one implementation the entries in the data structure include the synthetic names for the reloaded name synthesized classes and the replacement synthetic names. Additionally intercepting loading of the classes during each dynamic class update enables creation of the data structure utilized for transforming the name synthesized classes.

Preferably the method indexes the data structure entries by the names of enclosing classes for each of the name synthesized classes. Typically each replacement synthetic name is associated with a version of the name synthesized classes that was loaded during a prior dynamic class update or original class loading to the existing classes.

The method stores metadata associated with each of the name synthesized classes loaded during the dynamic class updates to identify different versions for the name synthesized classes. Preferably the method stores super class names field names method names constructors nested inner classes and names of implemented interfaces if any for each of the name synthesized classes loaded during the dynamic class updates.

The method stores unique identifiers associated with each of the name synthesized classes loaded during the dynamic class updates to identify bytecode of the name synthesized classes and calculates the unique identifiers for each of the name synthesized classes by creating a fingerprint based on the bytecode for each of the name synthesized classes.

In a preferred embodiment the method determines each replacement synthetic name by comparing the unique identifiers for each of the reloaded name synthesized classes during the run time reloading event with the unique identifiers for the name synthesized classes previously loaded. Additionally the method uses the synthetic name of the name synthesized class of a matched unique identifier from the name synthesized classes previously loaded as the replacement synthetic name.

In other examples the method updates values of the unique identifiers for each of the reloaded name synthesized classes during the run time event that reloads the name synthesized classes in response to identifying bridge methods generated by a compiler in each enclosing class of the reloaded name synthesized classes. The method preferably ensures that enclosing classes for each of the name synthesized classes are loaded prior to loading the name synthesized classes.

In yet another example the method provides the ability to transform lambda expressions implemented by a source compiler as the name synthesized classes. Preferably the method accepts redefined name synthesized classes during the dynamic class updates to the existing classes and accepts redefined enclosing classes of the name synthesized classes during the dynamic class updates to the existing classes.

The transforming of the reloaded name synthesized classes provided by the method enables the existing classes to invoke originally loaded versions of the name synthesized classes. The method preferably leaves bytecode unchanged for classes other than the name synthesized classes during the dynamic class updates to existing classes.

Preferably the method executes within a virtual machine the virtual machine running on the computer system.

In general according to another aspect the invention features a method for transforming synthetically generated code of classes in response to dynamic class updates to classes of an application running on a computer system. In response to a run time event that reloads the classes the method compares synthetic names for each of the reloaded classes with entries in a data structure. And in response to finding that the synthetic names for each reloaded class matches an entry in the data structure the method replaces occurrences of the synthetic name in each reloaded class with a replacement synthetic name.

Preferably the synthetically generated code is associated with anonymous classes and additionally is associated with bridge methods and lambda expressions in other examples. The method replaces the occurrences of the synthetic name in each reloaded class with the replacement synthetic name from the matched data structure entry to transform the classes.

In general according to yet another aspect the invention features a system for transforming name synthesized classes of existing classes of an application running on a computer system in response to dynamic class updates to the existing classes. The system includes a class interceptor that intercepts the loading of dynamically updated class definitions of the existing classes by a class loader. The dynamically updated class definitions of the existing classes include reloaded name synthesized classes.

The class interceptor compares unique identifiers for each of the reloaded name synthesized classes with entries in a data structure that represents the unique identifiers for the existing name synthesized classes in response to a run time event that causes the class loader to reload the name synthesized classes. The class interceptor then replaces occurrences of synthetic names in the reloaded name synthesized classes with replacement synthetic names.

The above and other features of the invention including various novel details of construction and combinations of parts and other advantages will now be more particularly described with reference to the accompanying drawings and pointed out in the claims. It will be understood that the particular method and device embodying the invention are shown by way of illustration and not as a limitation of the invention. The principles and features of this invention may be employed in various and numerous embodiments without departing from the scope of the invention.

Each application instance preferably runs within a virtual machine of the computer system . Computer systems include such devices as a mobile device tablet computer or workstation. In one example the computer systems includes one or more processors and a memory configured to store instructions executable by the processor.

In a preferred embodiment the virtual machine is a Java virtual machine JVM . While an increasing number of programming languages other than Java can execute within a JVM the figures of this section focus on features and concepts of the Java programming language.

In the preferred embodiment class interceptor intercepts the loading and reloading of all class files before a class loader can define the bytecode for the class files into the virtual machine . For the class loading of the initial version of anonymous class the class interceptor initially stores metadata for the anonymous class and its enclosing class and then defines the original bytecode for the anonymous class into the virtual machine .

For the class reloading of redefined anonymous class the class interceptor also initially stores metadata for the reloaded anonymous class and the reloaded version of its enclosing class referred to as reloaded enclosing class . Then using the metadata stored for the anonymous class and the reloaded anonymous class the class interceptor transforms the reloaded bytecode for redefined anonymous class into transformed bytecode associated with a transformed anonymous class . After transformation the original enclosing class is now referred to as a transformed enclosing class because it includes references to transformed anonymous classes .

The transformation provided by the class interceptor addresses run time behavioral issues associated with current approaches to dynamic class updates to existing classes when the dynamic class updates include changes to name synthesized classes such as anonymous classes. Details for the storing of the metadata and the utility of the metadata in transforming the reloaded anonymous classes is provided in the description that accompanies and later figures hereinafter.

The class loader interface accepts all class files for the application during each class loading or reloading event. During each class loading or reloading event a parser accepts the class files and parses their contents. If the parser determines that the current class is an anonymous class the parser first loads the enclosing class that includes the anonymous class . If the current class is not an anonymous class the parser allows the current class and its original bytecode to continue its execution flow path labeled A to virtual machine .

Execution flow paths B and C in contrast are associated with loading and or reloading anonymous classes . If the set of anonymous classes remains unchanged during a reloading event as compared to the set of previously loaded anonymous classes the reloaded bytecode for each anonymous class is associated with execution flow path B. When a reloading event changes the set of anonymous classes the transformed bytecode of each transformed anonymous class is associated with execution flow path C.

In other implementations the execution paths A B and C can include additional class interceptors that perform additional operations on a per class file basis before writing the definitions for the classes into the VM .

During each class loading and reloading event the parser registers each version of the anonymous classes in a map or inner class registry . The inner class registry maintains information that includes unique identifiers for each anonymous class and the names of the enclosing classes that include the anonymous classes . In one implementation the inner class registry maintains the most recent information about all anonymous classes . In another implementation the parser creates a separate entry in the inner class registry for each anonymous class encountered by the parser during each class loading and reloading event.

A preferred embodiment operates at the application level. However a VM level implementation can also be utilized to manipulate bytecode of anonymous classes. In particular a VM level approach would likely provide the ability to defer calculation of fingerprint information such as hash values that provide a unique identifier for the anonymous classes until the enclosing class has actually been recompiled and the reload event is attempted.

Each entry in the inner class registry preferably includes metadata such as the synthetic name or synthetic class name for each anonymous class the name of its enclosing class and the unique identifier associated with the contents of each anonymous class . In the preferred embodiment the parser instructs a fingerprint module to create the unique identifier as a fingerprint associated with the bytecode of each anonymous class and reloaded anonymous class .

Exemplary enclosing class Bike is included within an initial run time loading event . Enclosing class Bike and its anonymous classes are included within file storage system . The Java compiler generates synthetic names Bike 1 and Bike 2 for the anonymous classes . The java compiler creates the synthetic names in the order in which they appear are defined within enclosing class Bike . The parser instructs the fingerprint module to create unique identifiers and associated with the bytecode of anonymous classes Bike 1 and Bike 2 . The parser then creates two entries in the inner class registry for the anonymous classes labeled as Z.

Then a developer makes a change to enclosing class Bike redefining the class by simply swapping the declaration order of its two inner anonymous classes but leaving the code otherwise unchanged. This is the code for reloaded enclosing class and its reloaded redefined anonymous classes . The class interceptor intercepts all class files included within run time reloading event which includes reloaded enclosing class Bike and its reloaded anonymous classes .

Then the class interceptor compares the new set of metadata created for the reloaded anonymous classes in the reloading event also labeled as Z with the metadata associated with the anonymous classes in the inner class registry . If changes are detected the class interceptor updates the existing values in the inner class registry with the values associated with the reloaded anonymous classes .

Although the code for the anonymous classes and the code for the reloaded anonymous classes has not changed from the prior class loading event the generation of the synthetic names by the Java compiler for the run time reloading event will cause run time behavioral issues for current class reloading systems. This is because the Java compiler generates synthetic names Bike 1 and Bike 2 for the reloaded anonymous classes according to the swapped order in which the reloaded anonymous classes appear in reloaded enclosing class Bike .

However note that the unique identifier associated with synthetic name Bike 1 of the reloading event has the same value as the unique identifier associated with synthetic name Bike 2 of the loading event and that the unique identifier associated with synthetic name Bike 2 of the reloading event has the same value as the unique identifier associated with synthetic name Bike 1 of the loading event . By tagging each version of an anonymous class loaded during each dynamic loading event with a unique identifier associated with the bytecode of the anonymous class and storing its corresponding synthetically generated class name the class interceptor provides version tracking of all versions of anonymous classes loaded for an application .

The version tracking of anonymous classes by the class interceptor and its related components provides a clear benefit. It is the ability to relate the synthetic names of anonymous classes loaded during prior dynamic class updates to the synthetic names of reloaded anonymous classes that are reloaded during subsequent dynamic class updates. In one implementation the class interceptor stores these relationships in entries within a Map . Using this mechanism the class interceptor can resolve run time synthetic name conflicts associated with changes to the set of anonymous classes reloaded during subsequent dynamic class updates which current systems and methods cannot.

The class interceptor instructs the parser to parse all anonymous classes and reloaded anonymous classes associated with the dynamic class updates. The class interceptor then creates the entries in the inner class registry and determines if the unique identifier for each reloaded anonymous class for the current dynamic class update matches the unique identifier of an entry in the inner class registry . Upon finding a match the class interceptor creates an entry in the Map that relates the current name for the synthetic name of the currently reloaded anonymous class to the replacement name of prior loaded versions of each anonymous class .

In the example the class interceptor creates two entries in Map . One entry relates the current name Bike 2 for the first reloaded anonymous class declared in the reloaded enclosing class of the dynamic class update to the replacement name Bike 1 of the anonymous class for the initial run time loading event . The other entry relates the current name Bike 1 for the second reloaded anonymous class declared in reloaded enclosing class of the dynamic class update to the replacement name Bike 2 of the anonymous class for the initial run time loading event .

Finally just prior to defining each of the reloaded anonymous classes of the current dynamic class update into the virtual machine the class interceptor determines if the synthetic name for each reloaded anonymous class matches the current name field for an entry in the Map . If this is the case the class interceptor instructs the parser to parse the bytecode of the class file pointed to by the current name. Then the class interceptor replaces occurrences of the current name within the class file with the replacement name from the entry in the Map and uses this to transform the reloaded anonymous classes into transformed anonymous classes . The transformed anonymous class and its transformed bytecode continue its execution flow path labeled C to the virtual machine .

Preferably the class interceptor stores additional metadata associated with each anonymous class during the creation of the entries of the inner class registry . This metadata includes the superclass name for each anonymous class and any defined interfaces of the anonymous classes .

The class interceptor then determines if the code for a reloaded anonymous class and its relative position in its reloaded enclosing class for the current dynamic class update has not changed compared to the anonymous class of prior class loading events. If this is the case the class interceptor allows the reloaded bytecode of the current reloaded anonymous class to continue its execution flow path labeled B to virtual machine .

In some cases the class interceptor requires additional context specific information to determine the replacement synthetic names . In these instances such as determining the correct run time behavior for dynamic class updates that include bridge methods the class interceptor defers decisions to an analysis subsystem . More information for handling of bridge methods follows the discussion associated with included hereinafter. More details for the analysis subsystem follows the discussion associated with included hereinafter.

The class interceptor stores the metadata in a Map that persists through subsequent dynamic updates. This enables remapping of the synthetic names of the reloaded anonymous classes to replacement synthetic names of previously loaded anonymous classes for prior dynamic updates in step . Then in step in response to a run time class loading event that reloads the anonymous classes the class interceptor transforms the bytecode of the reloaded anonymous classes using the information in the Map .

In step the class interceptor determines if there are any classes remaining in the current dynamic class loading event transitioning to step if additional classes remain. If no classes remain the class interceptor transitions to step to write the definitions for the classes into the virtual machine .

If there are no more inner classes in step the method transitions to step to stop parsing the code for the current class. Otherwise the method transitions to step to identify the next inner class within the enclosing class .

Then according to step the method determines if the current inner class is an anonymous class . If the current inner class is not an anonymous class the method transitions back to step to determine the next inner class if there are any more inner classes. Otherwise the method transitions to step to find the class file associated with the current anonymous class and opens the associated class file with read access. Then in step the method parses the bytecode of the class file sanitizes occurrences of the synthetic name of the current anonymous class from the bytecode and calculates a fingerprint or unique identifier associated with the sanitized bytecode while taking bridge methods into account.

Then in step the method stores the synthetically generated name of the anonymous class being parsed and saves its super class name and the names of its implemented interfaces. Note that the super class name for an anonymous class and the names of its implemented interfaces are also known as super types. In step the method creates an entry in a temporary map wherein the entry includes the name of the enclosing class the synthetic name of the current anonymous class and the additional metadata associated with each anonymous class including the names of its super class and its implemented interfaces.

Upon completion of step the method has finished processing of the current anonymous class . As a result the method transitions back to step to find the next inner class to process.

In step the method determines if there is an entry in the inner class registry for the current class name. If there are no entries in the inner class registry such as when the inner class registry does not exist after the initial class loading the method in step saves all entries from the temporary map into the inner class registry with the enclosing class as a key and transitions to step to resume execution flow. Otherwise the current class name was found within an entry in the inner class registry which indicates that the current class is a reloaded anonymous class . The method transitions to step .

In step the method compares the unique identifier of each entry found from the current class name in the temporary map from step with the unique identifier of each entry in the inner class registry . In step the method determines if there is a match of the unique identifier . If there is no match the method adds the current name to the analysis subsystem for finding replacement names not solely based on fingerprint matching criteria in step . Then the method transitions to step . In step the method replaces the unique identifier stored within the inner class registry for the replacement synthetic name with the unique identifier for the current class name.

In step if there is a match between the unique identifier for the current name and the unique identifier for an entry in the inner class registry the method determines in step if the synthetic name for the current anonymous class and the synthetic name of the matched entry are the same. If the names are the same which indicates that the code of the reloaded anonymous class and the originally loaded anonymous class is the same the method transitions to step to resume execution flow. If the names are not the same the method transitions to step to store an entry in the Map with the name of the enclosing class as a key. The entries also include the synthetic name of the current class as a current name and the synthetic name of the matched entry in the inner class registry as a replacement name.

Upon completion of step the method transitions to step to replace the unique identifier stored within the inner class registry for the replacement synthetic name with the unique identifier for the current class name and then transitions to step to resume execution flow.

In step the method parses the bytecode of the anonymous class pointed to by the replacement synthetic name and replaces occurrences of its own class name with the replacement synthetic name . Then in step the method saves caches the resulting transformed bytecode for transforming the anonymous class and then transitions to step to resume execution flow.

In enclosing class Enclosing includes three anonymous classes and and local class Interact . The Java compiler accepts code for the anonymous classes and generates synthetic names Enclosing 1 for anonymous class Enclosing 2 for anonymous class and Enclosing 3 for anonymous class . The compiler also creates class file Interact.class in response to compiling local class Interact .

The synthetically generated names and for the first two reloaded anonymous classes and in reloaded enclosing class will be swapped as compared to the synthetic names and generated for the first two anonymous classes and of original enclosing class in . The Java compiler creates synthetic names Enclosing 1.class and Enclosing2.class . Incorrect run time system behavior will result when existing classes in the application attempt to reference objects using the definitions of the reloaded anonymous classes and . This is because the synthetic names and generated for the reloaded class definitions now point to different anonymous inner classes .

In a similar fashion lists Java code for reloaded enclosing class which also includes reloaded anonymous classes . In this example however reloading causes the definition for the last anonymous inner class defined in to appear as the first reloaded anonymous inner class of enclosing class in . In response to the dynamic update the Java compiler creates synthetic name Enclosing 1.class for reloaded anonymous class Enclosing 2.class for reloaded anonymous inner class and Enclosing 3.class for reloaded anonymous class . As a result the run time behavior of the application will be incorrect when other classes in the application reference objects that use the definitions of the reloaded anonymous classes and .

The synthetic names through and the synthetic names through do not point to the same code. As a result incorrect run time behavior will result when existing classes attempt to access code using the reloaded anonymous inner class definitions pointed to by the synthetic names through .

As in the example of the Java compiler creates synthetic names Enclosing 1.class for reloaded anonymous class Enclosing 2.class for reloaded anonymous class and Enclosing 3.class for reloaded anonymous inner class . However even if the reloaded anonymous classes of enclosing class were defined in the same order as the anonymous classes of original enclosing class run time behavior may still be incorrect when existing classes reference the code associated with reloaded anonymous inner class . This is because the synthetic name and the synthetic name would point to different code which is the code for anonymous class and reloaded anonymous inner class respectively.

In reloaded enclosing class from the example in is provided as input to method . In response with reference to for details of the reloaded enclosing class synthetic names through for reloaded anonymous classes and respectfully are transformed into transformed anonymous classes within transformed enclosing class by class interceptor via method .

Specifically using method associated with the preferred embodiment the class transformer applies replacement synthetic name Enclosing 2.class as the synthetic name associated with the first transformed anonymous class within transformed enclosing class . The replacement synthetic name Enclosing 2.class and synthetic name Enclosing 2.class point to the same originally loaded anonymous class . In a similar fashion the class transformer applies replacement synthetic name Enclosing 1.class as the synthetic name associated with the second transformed anonymous class within transformed enclosing class and applies replacement synthetic name Enclosing 3.class as the synthetic name associated with the third transformed anonymous class within transformed enclosing class .

In reloaded enclosing class from the example in is provided as input to method . In response with reference to for details of the reloaded enclosing class synthetic names through for reloaded anonymous inner classes and respectfully are transformed into transformed anonymous classes within transformed enclosing class .

Specifically using method associated with the preferred embodiment the class transformer applies replacement synthetic name Enclosing 3.class as the synthetic name associated with the first transformed anonymous inner class within transformed enclosing class . The replacement synthetic name Enclosing 3.class and synthetic name Enclosing 3.class point to the same originally loaded anonymous class . In a similar fashion the class transformer applies replacement synthetic name Enclosing 1.class as the synthetic name associated with the second transformed anonymous inner class within transformed enclosing class and applies replacement synthetic name Enclosing 2.class as the synthetic name associated with the third transformed anonymous class within transformed enclosing class .

In reloaded enclosing class from the example in is provided as input to method . In response with reference to for details of the reloaded enclosing class synthetic name for newly added anonymous class synthetic name for reloaded anonymous inner class and synthetic name for reloaded anonymous class are transformed into transformed anonymous inner classes within transformed enclosing class .

Specifically using method associated with the preferred embodiment the class transformer applies replacement synthetic name Enclosing 4.class as the synthetic name associated with the first transformed anonymous class within transformed enclosing class . Method initially determines that synthetic name Enclosing 1.class of reloaded enclosing class has the same synthetic name as a previously loaded anonymous inner class according to step .

However according to step the fingerprint unique identifier for the first transformed anonymous class which is the code for newly added anonymous inner class does not match the unique identifier associated with any previously loaded anonymous classes . As a result method traverses the path associated with step and utilizes the analysis subsystem to further examine such additional information as the super names of the current class to identify the code of the current class.

Using the super names of the current class method determines that the code for the current class is for newly added class . In response method in step creates a unique replacement synthetic name Enclosing 4.class associated with newly added class for the first transformed anonymous inner class in transformed enclosing class .

The class transformer applies replacement synthetic name Enclosing 1.class as the synthetic name associated with the second transformed anonymous class within transformed enclosing class and applies replacement synthetic name Enclosing 2.class as the synthetic name associated with the third transformed anonymous inner class within transformed enclosing class .

In reloaded enclosing class from the example in is provided as input to method . In response with reference to for details of the reloaded enclosing class synthetic name for reloaded anonymous class synthetic name for reloaded anonymous class and synthetic name for a redefined version of anonymous inner class labeled as are transformed into transformed anonymous classes within transformed enclosing class by class interceptor via method .

Specifically using method associated with the preferred embodiment the class transformer applies replacement synthetic name Enclosing 3.class as the synthetic name associated with the first transformed anonymous inner class within transformed enclosing class and applies replacement synthetic name Enclosing 1.class as the synthetic name associated with the second transformed anonymous class within transformed enclosing class .

For the third transformed anonymous inner class method initially determines that synthetic name Enclosing 3.class of reloaded enclosing class has the same synthetic name as a previously loaded anonymous class according to step .

However according to step the fingerprint unique identifier for the third transformed anonymous inner class which is the code for redefined anonymous class does not match the unique identifier associated with any previously loaded anonymous inner classes . This is because the fingerprint unique identifiers associated with original anonymous class and redefined anonymous inner class are different due to code modification .

As a result method traverses the path associated with step and utilizes the analysis subsystem to further examine such additional information as the super names of the current class to identify the code of the current class. In response in one implementation the analysis subsystem in step determines that redefined anonymous class and original anonymous inner class fulfills the criteria for a match. This is primarily because the super class is the same for the classes. Hence the class transformer applies replacement synthetic name Enclosing 2.class as the synthetic name associated with the third transformed anonymous class within transformed enclosing class .

It is important to stress that the computations provided by the analysis subsystem can be fairly simple like the calculations for the examples of . However the calculations can also be extremely complex where such criteria like the numeric distance between unmatched classes to their former versions may need to be taken into account before making any decisions about possible mappings. The implementation of the analysis subsystem will evolve with actual run time experience and will accordingly be fine tuned in response.

However there is a problem with this approach when developers redefine the contents of the anonymous inner classes in dynamic class updates using current class reloading methods. When the class interceptor calculates a fingerprint as the unique identifier for the anonymous classes it utilizes bytecode instructions which in this case will contain access 100 for the synthetic name A 1.class and access 200 for the synthetic name A 2.class .

For the example consider that the refactoring of the enclosing class by the developer simply swaps the placement of m and m . This reordering has the consequence that the unique identifier associated with the bytecode of the reloaded A 1 class will match exactly with that of the A 2 class . As a result current class reloading systems will remap those classes so that any existing client having a reference to an instance of the A 1 class will invoke method m after reloading which is incorrect.

One implementation resolves the false positive identifier match for the anonymous inner classes in the aforementioned example by additionally calculating fingerprints for bridge methods . As with the generation of fingerprints or unique identifiers associated with anonymous classes the method generates fingerprints for bridge methods associated with bytecode of their method bodies.

The method calculates the fingerprint or unique identifier of the bridge method during the parsing of each anonymous inner class in step . Specifically method performs the calculation when the parser encounters the bytecode of the instruction within the current class being parsed that invokes the bridge method . Method then utilizes the fingerprint or unique identifier of the bridge method instead of the unique identifier of the anonymous class .

While this invention has been particularly shown and described with references to preferred embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims.

