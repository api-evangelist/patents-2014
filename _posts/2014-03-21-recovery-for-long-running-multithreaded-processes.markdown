---

title: Recovery for long running multithreaded processes
abstract: In response to receiving a checkpoint request from a first task for a process executing in parallel with at least a second task for the process, checkpoint data from the first task is stored to establish a restart point for the first task, wherein the checkpoint data records a current state of the first task, and the checkpoint data from the first task is merged with previously received checkpoint data for the at least second task to create a checkpoint file. In response to restarting the process, the first task and the at least second task are restarted using the checkpoint data in the checkpoint file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09128881&OS=09128881&RS=09128881
owner: International Business Machines Corporation
number: 09128881
owner_city: Armonk
owner_country: US
publication_date: 20140321
---
Embodiments of the invention relate to recovery for long running multithreaded processes e.g. after a crash or suspension of the process .

A long running process such as a product migration or Extract Transform and Load ETL process may crash i.e. fail . When such a crash occurs the user typically starts the long running process again from the beginning of the process in a single threaded fashion.

Provided are a computer implemented method computer program product and system for recovery of a process. In response to receiving a checkpoint request from a first task for a process executing in parallel with at least a second task for the process checkpoint data from the first task to establish a restart point for the first task is stored wherein the checkpoint data records a current state of the first task and the checkpoint data from the first task is merged with previously received checkpoint data for the at least second task to create a checkpoint file. In response to restarting the process the first task and the at least second task are restarted using the checkpoint data in the checkpoint file.

The descriptions of the various embodiments of the present invention have been presented for purposes of illustration but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to best explain the principles of the embodiments the practical application or technical improvement over technologies found in the marketplace or to enable others of ordinary skill in the art to understand the embodiments disclosed herein.

A migration operation may be described as moving or copying data which may include instructions from a source system to a target system. A backup operation may be described as creating a backup image of an application s data on a source system. A restore operation may be described as taking a previously created backup image and using that backup image to reproduce the source system application s data on a target system. For example migration may be a process in which a backup is performed on a source system running an old version of an application e.g. Version 8.0 and the resulting backup image is restored to a target system running a newer version of the application e.g. Version 9.1 . The resulting restored data on the target system may then be manipulated to ensure that it conforms to what the newer version expects. Migration backup and restore operations as well as an ETL process may be long running processes. In certain embodiments the source system may be a first data store and the target system may be a second data store . In certain alternative embodiments the source system and the target system may be on a single data store .

If a crash or suspension of the process occurs at some point the MBR system allows the user to restart tasks for the long running process at restart points before the crash or suspension which may include a restart point at the beginning of the long running process . The long running process may have fired off multiple threads of execution and the MBR system restarts each of the multiple threads.

The MBR system records information about a current state of a task. For example a task might have 10 actions to perform and after each action the task does whatever is needed to commit the updates made by that action. The task then takes a checkpoint to establish a restart point to indicate that one action action x is finished and proceeds to the next action action x 1 . In certain embodiments the checkpoint data may be an integer holding the identifier of the action that just finished. Then if a crash occurs the MBR system loads the checkpoint data recreates the task e.g. via JAVA serialization JAVA is a registered trademark or common law mark of Oracle Corporation in the United States and or other countries and calls a restart operation on the task so that the task can continue processing where the task left off before the crash or suspension.

Thus the MBR system may not roll back any unfinished updates when a failure occurs. Instead the MBR system deals with multiple threads each taking individual checkpoints and having different restart points. This may be done by allowing each of the multiple threads to save a restart point which may include merging the restart points from each of the multiple threads into a single checkpoint file e.g. a single checkpoint image .

In certain embodiments the task save areas store the checkpoint data for tasks during processing. When a thread takes a checkpoint the thread is processing a task and the thread saves the checkpoint data for the task where saving the checkpoint is done by storing the checkpoint data in the task save area .

In certain embodiments the MBR system creates individual task objects for each task that is to be performed. A task object may be described as an internal representation of a task that will be run within the MBR system . In certain embodiments each task object consists of the code needed to import export backup or restore a portion of the information server environment.

In certain embodiments the tasks are executing in parallel. As each task executes the task is able to take one or more checkpoints to establish a restart point. As checkpoints are taken the checkpoints from multiple tasks may be merged into a process wide checkpoint file along with other process level information. The MBR system manages the checkpoint and recovery process.

In certain embodiments during a restart each task is recovered to the last checkpoint that task took and continues processing from that point. In certain embodiments the checkpoint file contains serialized task objects for each task that has been registered to run and that is running In certain embodiments the task objects contain the checkpoint data. Examples of checkpoint data are 

In block the MBR system checks for the existence of a checkpoint file e.g. on the file system . In block if a checkpoint file does not exist processing continues to block otherwise processing continues to block .

In block the MBR system creates a thread pool with threads and starts a new instance of each thread in the thread pool . In certain embodiments the number of threads created depends on external aspects of the computing device on which the process is running For example the number of Central Processing Units CPUs and the amount of memory may be taken into consideration in deciding how many threads to create. Once the threads are created the threads cooperate in selecting tasks that are available to be run from the entire set of defined tasks. In certain embodiments each thread executes the code for a single task at any one time. After a task has completed the thread may obtain another task to run. This continues until no more tasks are available to run.

In block the MBR system determines whether a checkpoint request has been received from a task. If so processing continues to block otherwise processing continues to block . In certain embodiments the task issues a checkpoint by calling a takeCheckPoint API provided by the MBR system .

In block the MBR system saves checkpoint data for the task that issued the checkpoint request to a task save area . In certain embodiments saving the checkpoint data triggers saving of the checkpoint file .

In block the MBR system merges checkpoint data received from the task with any previously received checkpoint data from the same and or other tasks into a checkpoint file . In certain embodiments the MBR system serializes the checkpoint data from multiple tasks into a single checkpoint file . Serializing data refers to taking an internal structure and converting that internal structure to a form that may be stored outside of the application e.g. to a file . From block processing continues to block .

In block the MBR system saves the checkpoint file i.e. writes the checkpoint file to the file system . In block the MBR system determines whether all tasks have completed processing. If so processing continues to block otherwise processing continues to block . If all tasks have completed in block the MBR system removes the checkpoint file . In block the MBR system exits.

When the MBR system starts up and determines that the checkpoint file exists block FIG. A then in block the MBR system determines that a restart operation is to be performed. A restart operation restarts each task from a last checkpoint for that task. In block the MBR system creates a thread pool and starts a new instance of each thread in the thread pool while populating each thread with serialized state data from the checkpoint file .

The MBR system allows for recovery for long running multi threaded processes. In certain embodiments the long running process may be a migration operation a backup operation a restore operation or an ETL process. In certain embodiments in the long running process a task may take a series of checkpoints. The checkpoint contains state information to resume the process at that checkpoint. The checkpoint may be saved as a serialized object that includes metadata.

In certain embodiments the user may resume operation of the long running process after a crash occurs using the checkpoints. In certain embodiments the checkpoints from the task may be merged together into a single checkpoint file. In certain embodiments during a restart each task is recovered to the last checkpoint taken and continues from that point on. In certain embodiments the long running process may fire off multiple threads of execution for the different tasks. In certain embodiments the act of saving and resuming checkpoints is thread safe. Saving and resuming checkpoints may be said to be thread safe if multiple threads attempt to save a checkpoint at the same time and they do not cause conflicts within the MBR system . In addition during restart multiple threads do not attempt to restore the previous state of the same task.

Long running processes may run up to a certain point fail and then be resumed after the problem causing the failure is resolved. The MBR system allows users to fix problems that cause the long running process to fail while resuming the execution as each problem is resolved.

Thus the MBR system for long running processes allows separate checkpoints for each of multiple threads of execution and merges the checkpoints into a single checkpoint file. The MBR system allows for better performance without sacrificing the ability to resume a long running process that has failed.

When recovering from a crash or a planned suspension the MBR system resumes the execution of a multi threaded long running process based on checkpoints taken by parallel tasks. The MBR system combines checkpoint data for multiple checkpoints from different tasks during task execution and loads the checkpoint data to resume tasks during recovery e.g. after a crash or suspension of the process .

In a relational database system the relational database system attempts to rollback transactions with the notion of a transaction log. As transactions are executed against a database the transactions are written to a log with multiple transactions in progress at any one time. If a crash occurs the relational database system uses the log to perform a rollback to get the database back to a consistent point. However a long running process e.g. a migration process may perform updates to the relational database data as well as non database data such as files. In such cases if a crash occurs the relational database system rolls back updates to the database itself but tasks for the long running process re do the work that the tasks were doing at the time of the crash. This may include creating changing and or deleting files. However the MBR system enables the tasks to be restarted so that the tasks can then recover to where the tasks left off to avoid redoing work . Moreover the MBR system enables multiple tasks running in parallel to each have a different recovery point.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk an application specific integrated circuit ASIC a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device solid state memory magnetic tape or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the embodiments of the invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational processing e.g. operations or steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The code implementing the described operations may further be implemented in hardware logic or circuitry e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc. The hardware logic may be coupled to a processor to perform operations.

Devices that are in communication with each other need not be in continuous communication with each other unless expressly specified otherwise. In addition devices that are in communication with each other may communicate directly or indirectly through one or more intermediaries.

A description of an embodiment with several components in communication with each other does not imply that all such components are required. On the contrary a variety of optional components are described to illustrate the wide variety of possible embodiments of the present invention.

Further although process steps method steps algorithms or the like may be described in a sequential order such processes methods and algorithms may be configured to work in alternate orders. In other words any sequence or order of steps that may be described does not necessarily indicate a requirement that the steps be performed in that order. The steps of processes described herein may be performed in any order practical. Further some steps may be performed simultaneously.

When a single device or article is described herein it will be readily apparent that more than one device article whether or not they cooperate may be used in place of a single device article. Similarly where more than one device or article is described herein whether or not they cooperate it will be readily apparent that a single device article may be used in place of the more than one device or article or a different number of devices articles may be used instead of the shown number of devices or programs. The functionality and or the features of a device may be alternatively embodied by one or more other devices which are not explicitly described as having such functionality features. Thus other embodiments of the present invention need not include the device itself.

The illustrated operations of the flow diagrams show certain events occurring in a certain order. In alternative embodiments certain operations may be performed in a different order modified or removed. Moreover operations may be added to the above described logic and still conform to the described embodiments. Further operations described herein may occur sequentially or certain operations may be processed in parallel. Yet further operations may be performed by a single processing unit or by distributed processing units.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof

The terms an embodiment embodiment embodiments the embodiment the embodiments one or more embodiments some embodiments and one embodiment mean one or more but not all embodiments of the present invention s unless expressly specified otherwise.

The terms including comprising having and variations thereof mean including but not limited to unless expressly specified otherwise.

The enumerated listing of items does not imply that any or all of the items are mutually exclusive unless expressly specified otherwise.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of embodiments of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiments were chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

Input Output I O devices including but not limited to keyboards displays pointing devices etc. may be coupled to the system either directly or through intervening I O controllers .

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters .

The computer architecture may be coupled to storage e.g. any type of storage device a non volatile storage area such as magnetic disk drives optical disk drives a tape drive etc. . The storage may comprise an internal storage device or an attached or network accessible storage. Computer programs in storage may be loaded into the memory elements and executed by a processor in a manner known in the art.

The computer architecture may include fewer components than illustrated additional components not illustrated herein or some combination of the components illustrated and additional components. The computer architecture may comprise any computing device known in the art such as a mainframe server personal computer workstation laptop handheld computer telephony device network appliance virtualization device storage controller etc.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The foregoing description of embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the embodiments to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the embodiments be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the embodiments. Since many embodiments may be made without departing from the spirit and scope of the invention the embodiments reside in the claims hereinafter appended or any subsequently filed claims and their equivalents.

