---

title: System and method of injecting states into message routing in a distributed computing environment
abstract: A system and method of operating resources within a distributed computing environment. The resources include a platform server and intermediate servers where each of the intermediate servers connects and maintains a persistent connection to the platform server a number of edge servers. The method includes injecting state identifier information into service requests from a given edge server to the intermediate server and transmitting the service request to the platform server. The method includes receiving a response message from the platform server where the message includes the state identifier. The method includes using the state identifier to route the message to the given edge server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09350791&OS=09350791&RS=09350791
owner: PTC Inc.
number: 09350791
owner_city: Needham
owner_country: US
publication_date: 20140321
---
This invention generally relates to operations of a distributing computing environment. More particularly in certain embodiments the invention relates to injecting state information into message being routing in a distributed computing environment.

The business of building a connected world also referred to as the Internet of Things is rapidly growing. Some industry analysts have estimated that the number of connected devices and systems in an industrial consumer government and business setting may rise from five billion devices to a trillion devices over the next ten years.

A given cluster of devices may include upwards of hundreds of thousands of devices or more. Persistence connectivity can be used to lower the CPU and memory usage for a given connection which reduces the cost of such connectivity and is particularly beneficial when there are such a vast number of connected devices. Persistence connectivity generally refers to a single connection between devices which once established is used to send and receive multiple requests responses between the devices.

In one type of distributed computing architecture one or more business logic servers referred to as a platform servers are employed to service data and information for hundreds of thousands or more computing devices. These servers may be designated for example based on a given geographic region. For example a platform server may service a group of devices in North America or the East Coast. The number of devices connecting to these servers typically exceeds the resource capacity of such servers. To this end intermediary servers may be employed to manage the connections between the computing devices and the platform servers. Because of the potential benefit in efficiency operation persistent connectivity may reduce the number of intermediary servers or platform servers necessary to provide data service to a given number of computing devices.

When operating a load balanced service maintaining information that must or should be kept across the multiple requests in a user s session is useful. This information is typically referred to as a session state. A common example of an application that uses session state is a Web browser that uses cookies. However a typical persistence connections between two network nodes use each other s network configuration. To this end multiplexing persistence connection may cause the state information to be lost.

In general overview an intermediary party provides a software library and computing architecture for building a federation of distributed computing systems to service data for a vast number of computing devices. To achieve connectivity to a large number of devices the federation generally includes multiple server nodes to share the workload. The server nodes can be logical virtual or physical.

In some implementations a platform server communicates to a given computing device across one or more intermediary servers over persistent connections. The platform routes data to and from data storage servers and various back end servers that provide services to the computing devices. To this end the intermediary servers multiplex messages sent from an persistent connections established with the edge servers to an persistent connection established with the platform server.

To maintain these persistent connections formed among the devices within the federation while allowing a given computing device to freely move within the system the edge and intermediary servers preferably operate using one or more non network addressable identifiers associated to a given computing device.

In some implementations messages sent across the persistent connections include a name identifier associated only with a given computing system. This feature beneficially allows the computing device to be serviced by the federation while being connected to any edge server within the federation. To this end the computing device does not need to have any knowledge of the device s own location or any networking or routing details about nodes within the federation. The computing devices merely has to register by providing its name and a corresponding security key in some implementations to a given edge server to which the device is automatically bound to a path within the federation.

In some implementations the intermediary servers may maintain and enforce authentication state for a given computing device within the federation. The intermediary servers may maintain the authentication state for a given session with a computing device once the credentials of the computing device is verified. In doing so the platform server distributes the management of the authentication session to the intermediary server while allowing the platform to still perform the authentication.

In some implementations the intermediary servers are stateless connection managers in that the intermediary server does not maintain state information of messages that it sends or receives. To this end data and information may be pipelined to independently operating intermediary servers which may thus share connectivity work load with various intermediary servers.

Applications for the systems and methods described herein are not limited to the aforementioned examples but may be deployed in any number of contexts as would be understood by one of ordinary skill in the art. Contents of the background are not to be considered as an admission of the contents as prior art.

In one aspect the present disclosure describes a method of message routing using a name based identifier in a distributed computing environment. The method may include providing a platform server a set of intermediary servers and a set of edge servers collectively defining a network where an end point device communicates to an edge server of the set of edge servers the set of edge servers communicates to the set of intermediary servers and the set of intermediary servers communicates to a platform server.

In some implementations the method may include binding at a platform server at a first instance the end point device to the platform server wherein the platform server binds at the first instance the end point device using a non addressable name value associated to the end point device. The binding at the first instance associates a first path across the network where the first path is defined between the end point device and the platform server across one or more intermediary servers and one or more edge servers.

In some implementations the method may include communicating at the platform server a first message to the end point device along the first path.

In some implementations the method may include rebinding at the platform server at a second instance the end point device to the platform server where the platform server binds at the second instance the end point device using the non addressable name value associated to the end point device. The non addressable name value may include a character string. The rebinding at the second instance associates a second path across the network where the second path is defined between the end point device and the platform server across one or more intermediary servers and one or more edge servers including a second intermediary server.

In some implementations the method may include communicating at the platform server a second message to the end point device along the second path. Each of the first path and the second path may include a connection handle to an established persistent connection. The established persistent connection may include a WebSocket connection. At least one of the first path and the second path may include at least two intermediary servers.

In some implementations the method may include receiving at the platform server at a given instance between the first and second instances a request to unbind the end point device from the platform server where the platform server unbinds the end point device based on the unbind request and where the unbinding dissociates the first path defined between the end point device and the platform server.

In some implementations the method may include binding at the platform server at the first instance a second end point device to the platform server where the platform server binds at the first instance the second end point device based on a second non addressable name value associated to the second end point device. The binding of the first end point device and the binding of the second end point device may be the result of a single bind request.

In one aspect the present disclosure describes a system including a processor and a memory the memory storing instruction that when executed by the processor cause the processor to bind at a first instance the end point device using a non addressable name value associated to the end point device. The binding at the first instance associates a first path across the network where the first path is defined between the end point device and the bound server across one or more intermediary servers and one or more edge servers.

In some implementations the instructions when executed further cause the processor to communicate a first message to the end point device along the first path.

In some implementations the instructions when executed further cause the processor to rebind at a second instance using the non addressable name value associated to the end point device. The non addressable name value may include a character string. The rebinding at the second instance associates a second path across the network where the second path is defined between the end point device and the bound server across one or more intermediary servers and one or more edge servers.

In some implementations the instructions when executed further cause the processor to communicate a second message to the end point device along the second path. Each of the first path and the second path may include a connection handle to an established persistent connection. The established persistent connection may include a WebSocket connection. At least one of the first path and the second path may include at least two intermediary servers.

In some implementations the instructions when executed further cause the processor to receive a request to unbind the end point device from the bound server based on the unbind request where the unbinding dissociates the first path defined between the end point device and the bound server.

In one aspect the present disclosure describes a non transitory computer readable medium having instructions stored thereon where the instructions when executed by a processor cause the processor to bind at a first instance the end point device using a non addressable name value associated to the end point device. The binding at the first instance associates a first path across the network where the first path is defined between the end point device and the bound server across one or more intermediary servers and one or more edge servers.

In some implementations the instructions when executed further cause the processor to communicate a first message to the end point device along the first path.

In some implementations the instructions when executed further cause the processor to rebind at a second instance using the non addressable name value associated to the end point device. The non addressable name value may include a character string. The rebinding at the second instance associates a second path across the network where the second path is defined between the end point device and the bound server across one or more intermediary servers and one or more edge servers.

In some implementations the instructions when executed further cause the processor to communicate a second message to the end point device along the second path. Each of the first path and the second path may include a connection handle to an established persistent connection. The established persistent connection may include a WebSocket connection. At least one of the first path and the second path may include at least two intermediary servers.

In some implementations the instructions when executed further cause the processor to receive a request to unbind the end point device from the bound server based on the unbind request where the unbinding dissociates the first path defined between the end point device and the bound server.

In one aspect the present disclosure describes a method of routing messages in a distributed computing environment between a platform server and an end point device. The method may include providing a platform server and one or more intermediate servers where each of the intermediate servers connects and maintains a persistent connection to the platform server and where the intermediate servers communicate and maintain a number of persistent connections with a number of edge servers. The intermediate server may not maintain state information associated with message content embedded within the given message.

In some implementations the method may include receiving by a port at a given intermediate server a service request from a given edge server of the edge servers over a first persistent connection.

In some implementations the method may include inserting by the processor at the intermediate server a given state identifier to the service request where the given state identifier is associated to a connection identity of the first persistent connection and where the association is stored in memory at the intermediate server.

In some implementations the method may include transmitting at the intermediate server the service request to the platform server over a second persistent connection.

In some implementations the method may include receiving at the intermediate server a response message over the second persistent connection the response message having been generated by the platform server in response to the service request where the response message includes the given state identifier.

In some implementations the method may include retrieving at the intermediate server the connection identity of the first persistent connection using the given state identifier where the given state identifier is the same state identifier transmitted within the service request. The given state identifier may be inserted into a header portion of the service request.

In some implementations the method may include routing at the intermediate server the response message to a selected connection of the persistent connections with the edge servers where the selected connection is based on the retrieved connection identity. The persistent connections may be Web Socket connections.

In some implementations the intermediate server may maintain in the memory a second state identifier associated with an authentication exchange having been conducted between the computing device connected to the given edge server and the platform server. The second state identifier may be associated with a name value associated with that of the computing device. In such implementation the method may include comparing using the processor at the intermediate server a device identifier located within the service request to the name value. If there is a match the intermediate server may inject the second state identifier into the service request where the device identifier is associated with an identity of a given computing device operatively communicating with the given edge server. If the comparison is not a match the intermediate server may send an unbind request to the given edge server where the unbind request causes the device identifier to be removed from a binding list of one or more device identifiers stored at the edge server. The second state identifier may be associated to the connection identity of the first persistent connection and where the association is stored in memory at the intermediate server.

In one aspect the present disclosure describes a system namely an intermediate server including a processor and a memory the memory storing instruction that when executed by the processor cause the processor to receive by a port a service request from a given edge server over a first persistent connection.

In some implementations the instructions when executed further cause the processor to insert a given state identifier to the service request where the given state identifier is associated to a connection identity of the first persistent connection and where the association is stored in memory at the intermediate server.

In some implementations the instructions when executed further cause the processor to transmit the service request to the platform server over a second persistent connection.

In some implementations the instructions when executed further cause the processor to receive a response message over the second persistent connection the response message having been generated by the platform server in response to the service request where the response message includes the given state identifier.

In some implementations the instructions when executed further cause the processor to retrieve at the intermediate server the connection identity of the first persistent connection using the given state identifier where the given state identifier is the same state identifier transmitted within the service request. The given state identifier may be inserted into a header portion of the service request.

In some implementations the instructions when executed further cause the processor to route the response message to a selected connection of the persistent connections with the edge servers where the selected connection is based on the retrieved connection identity. The persistent connections may be Web Socket connections.

In some implementations the intermediate server may maintain in the memory a second state identifier associated with an authentication exchange having been conducted between the computing device connected to the given edge server and the platform server. The second state identifier may be associated with a name value associated with that of the computing device. In such implementation the intermediate server may compare by the processor a device identifier located within the service request to the name value. If there is a match the intermediate server may inject the second state identifier into the service request where the device identifier is associated with an identity of a given computing device operatively communicating with the given edge server. If the comparison is not a match the intermediate server may send an unbind request to the given edge server where the unbind request causes the device identifier to be removed from a binding list of one or more device identifiers stored at the edge server. The second state identifier may be associated to the connection identity of the first persistent connection and where the association is stored in memory at the intermediate server.

In one aspect the present disclosure describes a non transitory computer readable medium having instructions stored thereon where the instructions when executed by a processor cause the processor to receive by a port a service request from a given edge server over a first persistent connection.

In some implementations the instructions when executed further cause the processor to insert a given state identifier to the service request where the given state identifier is associated to a connection identity of the first persistent connection and where the association is stored in memory at the intermediate server.

In some implementations the instructions when executed further cause the processor to transmit the service request to the platform server over a second persistent connection.

In some implementations the instructions when executed further cause the processor to receive a response message over the second persistent connection the response message having been generated by the platform server in response to the service request where the response message includes the given state identifier.

In some implementations the instructions when executed further cause the processor to retrieve at the intermediate server the connection identity of the first persistent connection using the given state identifier where the given state identifier is the same state identifier transmitted within the service request. The given state identifier may be inserted into a header portion of the service request.

In some implementations the instructions when executed further cause the processor to route the response message to a selected connection of the persistent connections with the edge servers where the selected connection is based on the retrieved connection identity. The persistent connections may be Web Socket connections.

In some implementations the intermediate server may maintain in the memory a second state identifier associated with an authentication exchange having been conducted between the computing device connected to the given edge server and the platform server. The second state identifier may be associated with a name value associated with that of the computing device. In such implementation the intermediate server may compare by the processor a device identifier located within the service request to the name value. If there is a match the intermediate server may inject the second state identifier into the service request where the device identifier is associated with an identity of a given computing device operatively communicating with the given edge server. If the comparison is not a match the intermediate server may send an unbind request to the given edge server where the unbind request causes the device identifier to be removed from a binding list of one or more device identifiers stored at the edge server. The second state identifier may be associated to the connection identity of the first persistent connection and where the association is stored in memory at the intermediate server.

In one aspect the present disclosure describes a method of routing message between a platform server and a plurality of end point device via a connection server in a distributed computing environment. The method may include providing a platform server a set of intermediary servers and a set of edge servers collectively defining a network where an end point device communicates to an edge server of the set of edge servers the set of edge servers communicates to the set of intermediary servers and the set of intermediary servers communicates to a platform server.

In some implementations the method may include receiving by a port at the platform server a first data message from a first end point device over a first persistent connection where the first data message has been routed through a first intermediate server over a second persistent connection.

In some implementations the method may include receiving by the port at the platform server a second data message from a second end point device over a third persistent connection wherein the second data message has been routed through a second intermediate server over a fourth persistent connection. The persistent connections may include WebSocket.

In some implementations the method may include servicing by a processor at the platform server the first data message and the second data message where each of the first intermediate server and second intermediate server manages connectivity between the end point devices and the platform servers. Each of the first intermediate server and second intermediate server may manage authentication sessions between the end point devices and the platform servers. The platform server may service the first data message and the second data message by routing the messages to an back office server selected from a group consisting of a persistence server a database server a customer relationship management CRM server an enterprise resource planning ERP server an operation support system OSS server a business support system BSS server and a data warehouse.

In one aspect the present disclosure describes a system including a processor and a memory the memory storing instruction that when executed by the processor cause the processor to receive by a port a first data message from a first end point device over a first persistent connection where the first data message has been routed through a first intermediate server over a second persistent connection.

In some implementations the instructions when executed further cause the processor to receive by the port a second data message from a second end point device over a third persistent connection wherein the second data message has been routed through a second intermediate server over a fourth persistent connection. The persistent connections may include WebSocket.

In some implementations the instructions when executed further cause the processor to service the first data message and the second data message where each of the first intermediate server and second intermediate server manages connectivity between the end point devices and the platform servers. Each of the first intermediate server and second intermediate server may manage authentication sessions between the end point devices and the platform servers. The platform server may service the first data message and the second data message by routing the messages to an back office server selected from a group consisting of a persistence server a database server a customer relationship management CRM server an enterprise resource planning ERP server an operation support system OSS server a business support system BSS server and a data warehouse.

In one aspect the present disclosure describes a non transitory computer readable medium having instructions stored thereon where the instructions when executed by a processor cause the processor to receive by a port a first data message from a first end point device over a first persistent connection where the first data message has been routed through a first intermediate server over a second persistent connection.

In some implementations the instructions when executed further cause the processor to receive by the port a second data message from a second end point device over a third persistent connection wherein the second data message has been routed through a second intermediate server over a fourth persistent connection. The persistent connections may include WebSocket.

In some implementations the instructions when executed further cause the processor to service the first data message and the second data message where each of the first intermediate server and second intermediate server manages connectivity between the end point devices and the platform servers. Each of the first intermediate server and second intermediate server may manage authentication sessions between the end point devices and the platform servers. The platform server may service the first data message and the second data message by routing the messages to an back office server selected from a group consisting of a persistence server a database server a customer relationship management CRM server an enterprise resource planning ERP server an operation support system OSS server a business support system BSS server and a data warehouse.

The features and advantages of the present disclosure will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements.

In some implementations the computing device is a sensor or a machinery at an industrial complex a computer or an office equipment at a business or government office a point of sale machine at a market place or a vending machine a construction equipment or a vehicle a power generation or distribution equipment a power substation or transmission equipment a building meter a server a networking or routing equipment a smart appliance an exercise machine a medical device or a prosthesis device a medical diagnostic device or a hospital equipment a commercial vehicle or a transport container a motor vehicle or an electric bicycle a cellphone a laptop a tablet an electronic reader or a clothing electronic tag.

An edge server in some implementations is an electronic device that has communication ports to interface to the endpoint device. The edge server may be for example but not limited to a gateway device a network server a single board computer a supervisory control and data acquisition system SCADA or a programmable logic controller PLC The edge server may communicate to the endpoint device by industrial commercial computing and military physical connection standards. These standards may include for example but not limited to Modbus RS 232 RS 422 RS 485 Serial ATA SCSI FireWire IEEE 1394 Ethernet Universal Serial Bus SONET Synchronous Optical Networking MIL STD 1553 IC Inter Integrated Circuit CAN bus controller area network ARINC 739 Avionics Digital Video Bus BACnet LonWorks. The standards may also include health medical communication standards such as CEN ISO IEEE 11073. The examples are merely for illustrative purposes. To this end other types of standards may also be employed.

To serve data and information for sets of computing devices one or more edge servers may communicate to an intermediary server referred to as a connection server or an API server over a first persistent connection . The connection server in turn communicates to the platform server over a second persistent connection . In essence the connection server form a persistent path between the platform server and a given edge server across the first persistent connection and the second persistent connection .

Collectively the platform servers the connection servers and the edge servers form a federation of distributed computing systems. In some implementations the platform servers are business logic servers that maintain connectivity to a given computing device . In such instances the platform server may communicate to various back office servers that provide service functions such as searching storing and managing among others for the data and information of the computing device . To this end the platform server may merely serve to route data to and from various applications and systems with the computing devices .

In some implementations the platform server may manage the authentication process of the computing devices .

In some implementations the platform server routes data to and from the various back office applications and systems. For example when data is received from a specific computing device the platform server may route the data to another database server. In other embodiments a third party application may request the data to be sent by the platform server.

Back office servers may include for example third party products for CRM ERP customer relationship management and or enterprise resource planning data analytics Big Data Store such as Hadoop Data Warehouses and various distributed file systems identity management billing provisioning and providing Web service. Examples of such back office systems may include SAP Enterprise Resource Planning ERP Salesforce Customer Relationship Management CRM Operations Support System OSS and Business Support Systems BSS Components.

Various data storage and applications may communicate with the platform server . In some implementations this communication may be by way of Web Services Java Database Connectivity JDBC or native APIs.

In some implementations the communication exchange between the connection servers and the edge servers occurs across a network infrastructure such as the Internet a Wide area network or a third party network . In turn one or more connection servers communicate to the platform server . The platform server the connection servers and the edge servers collectively forms a distributed computing system. In some implementations a given connection server communicates to a set of edge servers through a set of network security equipment . The security equipment secures the connection server and platform server from the open network infrastructure . It also secures the groups of edge servers and computing devices from the same. The network security equipment may include for example a firewall or Network Address Translation NAT protocol.

The platform server runs a server client application using an API protocol library that manages the communication over the channel . The edge server runs a server client application that runs the same communication API protocol library . To this end messages being communicated inbound and outbound between the platform server and the edge servers are for the most part symmetrical in that these messages share the same message structure.

In some implementations the API protocol library is a binary Dynamic REST API. Examples of methods of communicating using the binary Dynamic REST APIs are described in co pending and concurrently filed U.S. patent application titled SYSTEM AND METHOD OF USING BINARY DYNAMIC REST MESSAGES filed Mar. 21 2014 naming inventors Rick Bullotta John Canosa Bob DeRemer and Mike Mahoney and having Ser. No. 14 222 100. This application is incorporated by reference in their entirety.

This symmetry is intended to reduce the complexity of operation of the connection server as the connection server can generally service each communicated message in the same manner without much regard to the source or target.

In some implementations the communication API protocol generates each message with metadata relating to the connection. The connection server may use the connection metadata to preserve state information at both the edge server and the platform server . To this end the state information for a given edge server and a given platform server is communicated within each message allowing the servers to be stateless. In some implementations the connection metadata merely may include a message identifier authentication state information and routing information associated with a given persistent connection.

In some implementations the header may include a session identification number referred to as a SessionId . The session identification number is preferably associated to both a given name identifier of an end point device and a connection handle of a persistent connection. The association may be used by the connection server to determine a binding path of a given computing device . The connection server may use the session identification number to manage authentication session state on behalf of the platform server .

In some implementations the connection server may generate the session identification number during an authentication process associated with a given computing device . During the process the connection stores the session identification number and the communication handle from which the message was received. In some implementations the session identification number is preferably a 32 digit long binary number with the most significant digit MSB first though it can be of various data length and endian.

In some implementations the header may include an endpoint identification number referred to as an EndPointId that is associated to a given persistent connection . The connection server can subsequently retrieve the connection handle using the endpoint identification number . The endpoint identification number is preferably a 32 digit long binary number with the most significant digit MSB first. The connection server may use the endpoint identification number to preserve routing state information lost due to the multiplexing of the persistent connection.

The header may include other information fields to improve the operational efficiency of the messaging protocol. In some implementations the header may include a request identification number referred to as a RequestId that is associated to a given message. The request identification number may be randomly generated or incrementally generated to be unique for a given persistent communication channel . The request identification number may be employed to determine whether a service request has been fulfilled. In some implementations the request identification number is preferably a 24 digit long binary number with the most significant digit MSB first though it can be of various data length and endian.

In some implementations the header may include a message type field referred to as a Method code . The message field may include codes to allow for the quick identification of the type of message being received. For simple messages such as an acknowledgement or error message the message type field may constitute the message. For request messages the message type field may include a code corresponding to a type of request. In some implementations the request type message may be based on an HTTP framework.

In some implementations the header may include a multi part message field referred to as Multipart . This field may be used to identify whether the message is a part of a group of message having the same request identification number . The header identification number is preferably a 8 bit number.

In an aspect of an embodiment of the invention the connection server injects routing state information to an inbound message being sent to the platform server . The inventors have found that injecting state information over a stateless connection improves performance of the connection over typical stateful connections.

In having the routing state information embedded within each message the connection server can complete a roundtrip message transfer in some implementations using merely a lookup of the connection handle associated with the routing state identifier.

In another aspect of an embodiment of the invention the connection server injects the authentication state information to an inbound message being sent to the platform server . In having the session state embedded within the message the connection server takes over the managing of the authentication session thus freeing resources for the platform server preferably to manage more devices.

The method in some implementations begins with a computing device referred to as endpoint device D registering with an edge server referred to as edge server E step . In some implementations the registration may be a handshake or some automated process of negotiation to establish communication between the endpoint device D and the edge server E . The edge server E is an electronic device that has communication ports to interface to the endpoint device D.

The edge server E which is executing a client side application using the API protocol library prepares step an authentication request message in accordance for example with the request message structure as described in relation to . The request message may include a RequestId R shown as R corresponding to the request identification number as described in relation to . The edge server E then sends step the authentication request message to the connection server over a first persistent connection established between the edge server E and the connection server A .

The body of the message in some implementations may include an authentication message shown as . The authentication message may include an authentication name and a corresponding authentication password. In some implementations the authentication name may be the name identifier of the edge server E . The name identifier may be random or descriptive. The name identifier may have some reference to the owner and type of device. For example an electrocardiogram device no. 123 owned by the John Doe Medical Institute may have a descriptive name identifier of JohnDMedInt EKG Dev 123. 

In some implementations the authentication name and the corresponding security code may be in an UTF8 data type string Unicode Standard 8 bits . The string may be of any length and may be preceded in the message by a length value corresponding to the string length in the UTF8 format. The corresponding security code may for example be a password such as GoodPassWord123 . Of course various values and length may be employed. In other implementations the authentication message may be a security key which can be an encrypted data string generated using a token associated with a name identifier of the edge server E . Various conventional authentication techniques may be employed.

In some implementations the edge server E may require a second set of authentication credentials in addition to the authentication name and corresponding authentication password used in the authentication message. The second set of authentication credentials may be specific to the edge server E to prevent a non authenticated computing devices from binding with it and may be employed.

Still referring to upon receiving the authentication request message in some implementations the connection server A injects step SessionId S shown in as s and EndpointId e shown as e into the received message to produce message . The connection server A then sends step the message to the platform server referred to as the platform server P over a second persistent connection established between the connection server A and the platform server P . The EndpointId e may correspond to the endpoint identification number as described in relation to that is associated to the first persistent connection. The SessionId s may correspond to the session identification number as also described in relation to that is associated to a given persistent connection and the name identifier belonging to the endpoint device D .

In some implementations the received message has a NULL or EMPTY value in the header fields and . To this end the SessionId s and the EndpointId e can merely replace the values there. In other implementations the received message is concatenated with the SessionId s and the EndpointId e . Of course various methods of injecting data into a data stream may be employed.

Upon receiving the message the platform server P processes step the authentication request message. In some implementations the platform server P authenticates the credentials of the endpoint device D using an authentication registry that it maintains. In some implementations the platform server P may route the message to a back office authentication server not shown to perform the authentication.

The platform server P then prepares a return message step . The return message may be related to the authentication process for example pass or not passed or it may be merely be an acknowledgement of receipt of the message for example success receipt or receipt error . To this end the return message may be a status code as described in relation to .

In some implementations the platform server prepares the return message to include the RequestId R the SessionId s and the EndpointId e as received in the request message . In essence the platform server P merely employs the metadata information of the received message to produce a return message which may be an indicia of acknowledgement or success. The platform server P then sends the message step to the connection server over the second persistent connection.

Upon receiving the message in some implementations the connection server A may use the EndPointId e to identify the connection to forward the message step to the Edge Server E . To this end no additional processing may be necessary to be performed at the connection server A . In some implementations the EndPointId e may be indexed to the connection handle associated with the persistent connection. The index may have been stored at the connection server A within a hash table.

To this end preserving state information for a roundtrip routing through a multiplexed persistent connection paradigm may collectively employ a single hash table lookup of an identifier associated with a given persistent connection a single write function to inject in the identifier into a message header and a single read of the message header to retrieve the communication handle to the same persistent connection.

Referring still to in some implementations subsequent to an authentication exchange the edge server E initiates a binding process. The binding process binds a path between the end point device D and the platform server P . At each node along the path the binding process associates a connection handle of a persistent connection that points to the end point device.

The binding process is synergistic with the usage of routing metadata. Routing metadata may allow for messages from the platform server to be quickly and efficiently returned to the end point device.

In some implementations the edge server E prepares a binding message and sends the message step to the connection server A across the first persistent connection. The edge server E generates a requestId R . In some implementations the request message may include a BIND request code as described in relation to and as shown as B in message . The payload of the request message may include the name identifier of the endpoint device D .

Upon receiving the bind request message in some implementations the connection server A injects step SessionId S shown in as s and EndpointId e shown as e into the received message to produce message

Additionally the connection server A determines that the received message is a bind request. To this end it adds the name identifier located within the payload to its binding registry. In the registry the name identifier may be associated with a connection handle of the first persistent connection. For example the name identifier is used as an index value in a hash table having the connection handle.

The connection server A then sends step the bind request message to the platform server P over a second persistent connection.

Upon receiving the message in some implementations the platform server P processes the bind request step . For example it may add the name identifier to its binding registry.

In some implementations the platform server P prepares a success message step . The platform server P sends the success message step to the connection server A over the second persistent connection. Upon receiving the message the connection server A may use the EndPointId e to identify the connection. The connection server A forwards the message step to the edge server E .

In some implementations the edge server E may send a message to the endpoint device D to acknowledge a successful registration process.

The method in some implementations begins with the platform server P preparing a request message step for the edge server E .

The platform server P sends the request message to the connection server A over the second persistent connection using a connection handle determined from its binding registry.

Upon receiving the message in some implementations the connection server D determines that the message is an outbound message from the platform server P . This determination may be based on the connection handle of the second persistent connection or it may be based on the presence of a session identification number within the message . The connection server D may inject an EndpointId e associated with the received connection handle for the second persistent connection step . The connection server D may identify the appropriate persistent connection for the message using the name identifier in the message and a corresponding connection handle stored in its binding registry. The connection server D then forwards the message to the appropriate edge server E using the identified handle.

Upon receiving the message in some implementations the edge server E sends back a success acknowledge message step to the connection server A over the same persistent connection namely the first persistent connection. The edge server E uses the requested data in the message s payload step and removes the data service request from its queue. The edge server E may generate a success message step and sends to the connection server A across the first persistent connection.

The connection server A receives the message and relays the message to the platform server P over the second persistent connection using the endPointId e . Upon receiving the acknowledgment message in some implementations the platform server P removes the request message from its queue.

Upon receiving a message step the connection server determines whether an endpoint identification number is present in the message step as described in relation to . In some implementations the endpoint identification number is located in a fixed field within the message header . In other implementations the connection server may parse the message for the information. If an endpointId is in the message then the connection server may route the message using the endpointId as described in relation to .

If the endpointId is NULL or empty the connection server may inject an identification number associated with a connection handle associated to the channel that the id was received.

If the message type is an authentication message step the connection server may inject the session identification number into the message step as described in relation to . The connection server may bind the endpointId the sessionId and the connection step as described in relation to and forward the message to the platform server step .

If the message type is a bind or unbind message step the connection server may bind the name identifier located in the message to its binding registry or remove the name identifier in the message from its binding registry step and forward the message to the platform server step .

If the message type is a request message step the connection server may merely forward the request message to the platform server step .

The connection server may then check the request message to determine whether the sessionId is present step . If present the message may be routed to the respective edge server using its binding registry to determine the appropriate connection handle. If not present the connection server may retrieve the SessionId using the nameId in the message step inject the SessionId into the message step and forward the message to the platform server step .

The method initiates with a given computing device namely the end point device being registered as described in relation to with edge server . The edge server sends a bind request to a connection server over persistent connection . The bind request may include a name identifier of the end point device in the binding list. The connection server forwards the bind request to the platform server over persistent connection . The connection server also associates the end point device with the persistent connection and stores the association in its binding registry. The association may be based on the connection handle of the persistent connection. The binding registry may be a data table or a hash table. The platform server associates the end point device with persistent connection and stores the association in its binding registry. To this end when sending a request message to end point device the platform server retrieves the persistent connection associated to the end point device

Subsequent to binding if the end point device moves to another edge server namely edge server the end point device would de register with the edge server . The edge server would send an unbind request to the primary server through the bounded path . The unbind request would remove the end point device from the binding registry of the connection server and the platform server . The end point device would then register with the edge server and repeat the same binding process.

In some implementations the network may include one or more persistent servers . The persistence servers can share the load from data being sent to the platform server shown as routing servers . The persistence servers may employ specific types of persistence objects such as Streams and DataTable. Examples of Streams and DataTable are described in U.S. patent application Ser. No. 13 678 885 titled METHODS FOR DYNAMICALLY GENERATING APPLICATION INTERFACE FOR MODELED ENTITY AND DEVICES THEREOF filed Nov. 16 2012. The application is incorporated by reference herein in its entirety.

In some implementations the network may include one or more back office servers such as CRM ERP including various servers as described in relation to .

In some implementations the network may include one or more Big Data and Data Store . Such servers may communicate to the platform server using Web protocols such as Java Database Connectivity JDBC or native APIs. In some implementations the platform server may process an event to route the data to the appropriate database when data is received from a given computing device . Alternatively a third party application may initiate an event.

In some implementations a port at a given intermediate server receives a service request from a given edge server over a first persistent connection step . The processor at the intermediate server inserts a session identifier to the service request step . The session identifier is associated to a connection identity of the first persistent connection. The association is stored in memory at the intermediate server. The intermediate server is preferably stateless in that it does not retain state information associated with a given request message. In such implementations the intermediate server preferably does not maintain knowledge of whether a similar request message has been previously sent and which of a sequence of message action this message belongs thereto. Put another way it forgets a given message after having received and forwarded it along.

Such stateless paradigm may reduce the workload of the intermediate server as it can thus be configured to operate with a fewer set of instructions and with lower memory usage requirements. To this end with less resource being required for a given connection a given intermediate server can service more numbers of computing devices as compared to a comparable hardware system that operates the additional overhead work of maintaining such message state information. In some implementations the given session identifier is injected into a header portion such as the header of each request message.

The intermediate server may maintain in the memory a second state identifier associated with an authentication session of a computing device . The second state identifier may be associated with a name value associated with the computing device . The second state identifier may also be associated to the connection identity of the first persistent connection. The association may be stored in the local memory of the intermediate server . In some implementations the intermediate server may maintain the association in a hash table. The table may use name value to index the second state identifier and a network handle created when the persistent connection was established.

In some implementations the name value is preferably a non network based addressable identifier. Rather than a network addressable identifiers which can be for example a uniform resource identifier URI or an Internet Protocol IP address the name value can be a number sequence or a character string.

In some implementations the intermediate server transmits the service request to the platform server over a second persistent connection step .

In some implementations the intermediate server receives a response message over the second persistent connection . The response message may have been generated by the platform server in response to the service request and may include the session identifier step .

In some implementations the intermediate server retrieves the connection identity of the first persistent connection using the session identifier step . The session identifier is the same session identifier transmitted within the service request.

In some implementations the intermediate server routes the response message to a selected connection among the numbers of persistent connections established with the edge servers step . The selected connection may be based on the retrieved connection identity.

In some implementations the platform server binds at a first time instance the end point device to the platform server step . The binding at the first instance may associate with a first path across the network. The first path may be defined between the end point device and the platform server across one or more intermediary servers and one or more edge servers.

In some implementations the platform server communicates a first message to the end point device along the first path step .

In some implementations the platform server rebinds at a second instance the end point device to the platform server step . This may occur after the end point device has moved to an edge server different from the first path.

In some implementations the platform server communicates a second message to the end point device along the second path step . To this end the end point device can move among different geographic locations without regard to its own knowledge of its location. Rather the network may discover a path for message to flow to and from the platform server without any knowledge on the part of the end point device .

In some implementations the platform server receives a second data message from a second end point device over a third persistent connection step . The second data message has been routed through a second intermediate server over a fourth persistent connection

Each of the first intermediate server and second intermediate server may manage both the authentication sessions and the connectivity between the end point devices and the platform servers .

In some implementations the platform server services the first data message and the second data message step . The platform server may service the first data message and the second data message by routing the messages to a back office server. As described in relation to the back office server may include for example a persistence server a database server a customer relationship management CRM server an enterprise resource planning ERP server an operation support system OSS server a business support system BSS server or a data warehouse.

The computing device may include a processor a memory a storage device a high speed interface connecting to the memory and multiple high speed expansion ports and a low speed interface connecting to a low speed expansion port and the storage device . Each of the processor the memory the storage device the high speed interface the high speed expansion ports and the low speed interface are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as a display coupled to the high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information within the computing device . In some implementations the memory is a volatile memory unit or units. In some implementations the memory is a non volatile memory unit or units. The memory may also be another form of computer readable medium such as a magnetic or optical disk.

The storage device is capable of providing mass storage for the computing device . In some implementations the storage device may be or contain a computer readable medium such as a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or various solid state memory device or an array of devices including devices in a storage area network or various configurations. Instructions can be stored in an information carrier. The instructions when executed by one or more processing devices for example processor perform one or more methods such as those described above. The instructions can also be stored by one or more storage devices such as computer or machine readable mediums for example the memory the storage device or memory on the processor .

The high speed interface manages bandwidth intensive operations for the computing device while the low speed interface manages lower bandwidth intensive operations. Such allocation of functions is an example only. In some implementations the high speed interface is coupled to the memory the display e.g. through a graphics processor or accelerator and to the high speed expansion ports which may accept various expansion cards not shown . In the implementations the low speed interface is coupled to the storage device and the low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers. In addition it may be implemented in a personal computer such as a laptop computer . It may also be implemented as part of a rack server system . Alternatively components from the computing device may be combined with other components in a mobile device not shown such as a mobile computing device . Each of such devices may contain one or more of the computing device and the mobile computing device and an entire system may be made up of multiple computing devices communicating with each other.

The mobile computing device may include a processor a memory an input output device such as a display a communication interface and a transceiver among other components. The mobile computing device may also be provided with a storage device such as a micro drive or other device to provide additional storage. Each of the processor the memory the display the communication interface and the transceiver are interconnected using various buses and several of the components may be mounted on a common motherboard or in other manners as appropriate.

The processor can execute instructions within the mobile computing device including instructions stored in the memory . The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor may provide for example for coordination of the other components of the mobile computing device such as control of user interfaces applications run by the mobile computing device and wireless communication by the mobile computing device .

The processor may communicate with a user through a control interface and a display interface coupled to the display . The display may be for example a TFT Thin Film Transistor Liquid Crystal Display display or an OLED Organic Light Emitting Diode display or other appropriate display technology. The display interface may comprise appropriate circuitry for driving the display to present graphical and other information to a user. The control interface may receive commands from a user and convert them for submission to the processor . In addition an external interface may provide communication with the processor so as to enable near area communication of the mobile computing device with other devices. The external interface may provide for example for wired communication in some implementations or for wireless communication in other implementations and multiple interfaces may also be used.

The memory stores information within the mobile computing device . The memory can be implemented as one or more of a computer readable medium or media a volatile memory unit or units or a non volatile memory unit or units. An expansion memory may also be provided and connected to the mobile computing device through an expansion interface which may include for example a SIMM Single In Line Memory Module card interface. The expansion memory may provide extra storage space for the mobile computing device or may also store applications or other information for the mobile computing device . Specifically the expansion memory may include instructions to carry out or supplement the processes described above and may include secure information also. Thus for example the expansion memory may be provide as a security module for the mobile computing device and may be programmed with instructions that permit secure use of the mobile computing device . In addition secure applications may be provided via the SIMM cards along with additional information such as placing identifying information on the SIMM card in a non hackable manner.

The memory may include for example flash memory and or NVRAM memory non volatile random access memory as discussed below. In some implementations instructions are stored in an information carrier. that the instructions when executed by one or more processing devices for example processor perform one or more methods such as those described above. The instructions can also be stored by one or more storage devices such as one or more computer or machine readable mediums for example the memory the expansion memory or memory on the processor . In some implementations the instructions can be received in a propagated signal for example over the transceiver or the external interface .

The mobile computing device may communicate wirelessly through the communication interface which may include digital signal processing circuitry where necessary. The communication interface may provide for communications under various modes or protocols such as GSM voice calls Global System for Mobile communications SMS Short Message Service EMS Enhanced Messaging Service or MMS messaging Multimedia Messaging Service CDMA code division multiple access TDMA time division multiple access PDC Personal Digital Cellular WCDMA Wideband Code Division Multiple Access CDMA2000 or GPRS General Packet Radio Service among others. Such communication may occur for example through the transceiver using a radio frequency. In addition short range communication may occur such as using a Bluetooth Wi Fi or other such transceiver not shown . In addition a GPS Global Positioning System receiver module may provide additional navigation and location related wireless data to the mobile computing device which may be used as appropriate by applications running on the mobile computing device .

The mobile computing device may also communicate audibly using an audio codec which may receive spoken information from a user and convert it to usable digital information. The audio codec may likewise generate audible sound for a user such as through a speaker e.g. in a handset of the mobile computing device . Such sound may include sound from voice telephone calls may include recorded sound e.g. voice messages music files etc. and may also include sound generated by applications operating on the mobile computing device .

The mobile computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a cellular telephone . It may also be implemented as part of a smart phone personal digital assistant or other similar mobile device.

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementations in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium and computer readable medium refer to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

To provide for interaction with a user the systems and techniques described here can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The systems and techniques described here can be implemented in a computing system that may include a back end component e.g. as a data server or that may include a middleware component e.g. an application server or that may include a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementations of the systems and techniques described here or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network . Examples of communication networks include a local area network LAN a wide area network WAN and the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

In view of the structure functions and apparatus of the systems and methods described here in some implementations a system and method for injecting state and routing information into a communication exchange between a platform server and an end point device over a stateless persistent connection are provided. Having described certain implementations of methods and apparatus for supporting injection of the state and routing information into the communication exchange it will now become apparent to one of skill in the art that other implementations incorporating the concepts of the disclosure may be used.

Moreover in view of the structure functions and apparatus of the systems and methods described here in some implementations a system and method for communication over a set of persistent connections between two network nodes and an intermediary node are provided. Having described certain implementations of methods and apparatus for supporting communication over the persistent connection it will now become apparent to one of skill in the art that other implementations incorporating the concepts of the disclosure may be used.

Moreover in view of the structure functions and apparatus of the systems and methods described here in some implementations a system and method for communication over a set of persistent connections between two network nodes and an intermediary node are provided. Having described certain implementations of methods and apparatus for supporting communication over the persistent connection it will now become apparent to one of skill in the art that other implementations incorporating the concepts of the disclosure may be used.

Therefore the disclosure should not be limited to certain implementations but rather should be limited only by the spirit and scope of the following claims.

