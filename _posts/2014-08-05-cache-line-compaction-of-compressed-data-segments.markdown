---

title: Cache line compaction of compressed data segments
abstract: Methods, devices, and non-transitory process-readable storage media for compacting data within cache lines of a cache. An aspect method may include identifying, by a processor of the computing device, a base address (e.g., a physical or virtual cache address) for a first data segment, identifying a data size (e.g., based on a compression ratio) for the first data segment, obtaining a base offset based on the identified data size and the base address of the first data segment, and calculating an offset address by offsetting the base address with the obtained base offset, wherein the calculated offset address is associated with a second data segment. In some aspects, the method may include identifying a parity value for the first data segment based on the base address and obtaining the base offset by performing a lookup on a stored table using the identified data size and identified parity value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09361228&OS=09361228&RS=09361228
owner: QUALCOMM Incorporated
number: 09361228
owner_city: San Diego
owner_country: US
publication_date: 20140805
---
Lossless compression techniques may compress data segments of configurable sizes to smaller sizes. For example a lossless compression algorithm may utilize different compression ratios e.g. 4 1 4 2 4 3 4 4 to compress 256 Byte data segments into compressed data segments of various sizes e.g. 64 Bytes 128 Bytes 192 Bytes 256 Bytes . Conventional techniques may process a data segment or data block to reduce the data segment to a fraction of its original size helping to reduce the amount of bandwidth and resources consumed during data reads writes between memory units.

Such compressed data may be stored in cache lines of a cache e.g. an L3 cache . Typically compressed forms of data segments or compressed data segments are stored within cache lines corresponding to the physical addresses of the uncompressed forms of the data segments or source data segments . Each cache line may have a set size e.g. 128 Bytes or capacity that must be filled with any load operation regardless of the size of the required data. For example when loading a 64 Byte or 192 Byte segment into 128 Byte B cache lines a computing device may be required to read and store in the cache line an additional potentially unneeded 64 Bytes to completely fill the 128 Bytes of the cache line s . Therefore when compressed data to be loaded into a cache line or multiple cache lines is not the same size as source data segments or the cache lines there may be holes in the physical address space that do not contain useful data. This undesirable loading of unneeded unusable data is referred to as overfetching and may cause suboptimal resource and bandwidth usage between memory units e.g. Double Data Rate DDR random access memory RAM etc. and caches. For example holes can use up partial cache lines both increasing requested memory bandwidth and wasting space in the cache that causes unevenness in resource use in computing devices. As compression schemes e.g. Burrows Wheeler transforms etc. may result in many compressed data segments that are smaller than cache lines significant overfetching may occur causing great inefficiency and increased workload that may diminish the benefits of using compression techniques. Further compressed block sizes may be less than optimal DDR minimum access length MAL causing worse performance.

Various aspects provide methods devices and non transitory process readable storage media for compacting data within cache lines of a cache of a computing device. An aspect method may identifying a base address for a first data segment identifying a data size for the first data segment obtaining a base offset based on the identified data size and the base address of the first data segment and calculating an offset address by offsetting the base address with the obtained base offset in which the calculated offset address may be associated with a second data segment.

In some aspects obtaining the base offset based on the identified data size and the base address of the first data segment may be performed by one of the processor of the computing device executing software or a dedicated circuit coupled to the processor of the computing device and calculating the offset address by offsetting the base address with the obtained base offset may be performed by one of the processor of the computing device executing software or the dedicated circuit coupled to the processor of the computing device.

In some aspects the base address may be a physical address or a virtual address. In some aspects the identified data size may be identified based on a compression ratio associated with the first data segment. In some aspects the compression ratio may be one of a 4 1 compression ratio a 4 2 compression ratio a 4 3 compression ratio or a 4 4 compression ratio.

In some aspects obtaining the base offset based on the identified compression ratio and the base address of the first data segment may include identifying a parity value for the first data segment based on the base address and obtaining the base offset using the identified compression ratio and the identified parity value.

In some aspects obtaining the base offset using the identified compression ratio and the identified parity value may include obtaining the base offset by performing a lookup on a stored table using the identified compression ratio and the identified parity value. In some aspects the parity value indicates whether a bit in the base address of the first data segment may be odd or even. In some aspects the parity value may be based on two bits in the base address of the first data segment.

In some aspects obtaining the base offset based on the identified data size and the base address of the first data segment may include obtaining a first base offset and a second base offset and a first data size and a second data size for the first data segment and calculating the offset address by offsetting the base address with the obtained base offset may include calculating a first offset address for the first data size and a second offset address for the second data size.

In some aspects the method may further include storing the first data segment at the calculated offset address which may include reading the first data segment at the base address as uncompressed data compressing the first data segment at the identified data size and storing the compressed first data segment at the calculated offset address.

In some aspects calculating the offset address by offsetting the base address with the obtained base offset may be accomplished after the first data segment has been compressed. In some aspects the method may further include reading the first data segment at the calculated offset address.

In some aspects the method may further include determining whether the second data segment has a correct compression ratio to be contiguous with the first data segment and reading the first data segment at the calculated offset address may include prefetching the second data segment with the first data segment in response to determining the second data segment has the correct compression ratio. In some aspects the method may further include decompressing the read first data segment.

Various aspects may include a computing device configured with processor executable instructions to perform operations of the methods described above. Various aspects may include a computing device having means for performing functions of the operations of the methods described above. Various aspects may include non transitory processor readable media on which are stored processor executable instructions configured to cause a processor of a computing device to perform operations of the methods described above.

The various aspects will be described in detail with reference to the accompanying drawings. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts. References made to particular examples and implementations are for illustrative purposes and are not intended to limit the scope of the invention or the claims.

The word exemplary is used herein to mean serving as an example instance or illustration. Any implementation described herein as exemplary is not necessarily to be construed as preferred or advantageous over other implementations.

Various aspects include methods that may be implemented in computing devices to improve the compactness of compressed data segments in cache memory by compacting data segments within a cache so that the data segments overlap on cache lines. By overlapping data on cache lines small compressed data segments may share cache lines enabling more efficient memory accesses and less frequent unneeded overfetching.

The term computing device is used herein to refer to any one or all of cellular telephones smartphones web pads tablet computers Internet enabled cellular telephones WiFi enabled electronic devices personal data assistants PDA s laptop computers desktop computers or personal computers servers and similar electronic devices equipped with at least a processor. Computing devices may utilize various architectures to enable the performance of software instructions via their processor s and may include one or more memory units such as random access memory units e.g. DDR RAM etc. and cache units e.g. L2 cache L3 cache etc. .

The term source data segment is used herein to refer to an uncompressed data segment that may be stored in a memory or cache unit of a computing device. In various aspects a source data segment may be 256 Bytes in size. Further a source data segment may be associated with an exclusive range of the physical address space that may be stored in a cache the exclusive range being the same size as the source data segment e.g. the size of an uncompressed tile or data block . For example an exclusive range of a source data segment may be 256 Bytes. Source data segments may be stored in more than one cache line and thus their exclusive ranges may extend to cover or partially cover multiple cache lines. The term base address is used herein to refer to a physical address or a virtual address that represents the start of a source data segment s exclusive range in the cache. The term offset address is used herein to refer to a physical address or a virtual address that is an offset of a base address physical or virtual .

The term compressed data segment is used herein to refer to a data segment that has been reduced in size by a computing device executing a conventional data compression algorithm. Compressed data segments may be smaller in size e.g. Bytes than their respective source data segments. For example a compressed data segment may be 64 Bytes whereas its corresponding source data segment may be 256 Bytes.

Compression techniques are often used to improve performance of computing devices by reducing the amount of data that is transferred between memory units and cache units. However regardless of their smaller size compressed data segments may still be associated with and aligned to particular addresses e.g. physical addresses of the cache often causing suboptimal use of cache lines. For example when using 128 Byte cache lines and compressing 256 Byte data segments to 64 Byte i.e. using a 4 1 compression ratio or 192 Byte i.e. using a 4 3 compression ratio compressed data segments 64 Bytes of the cache line may be wasted due to overfetch. With compressed data segments of a minimum compression size e.g. 64 Bytes that is smaller than cache line size e.g. 128 Bytes data loads to the cache via conventional techniques include wasted data that increases bandwidth and makes compression worse. For example compressed data segments of size 64 Bytes and 192 Bytes may comprise a significant portion of cache transactions for some workloads e.g. user interface UI workloads and thus may lead to inefficient use of the cache space as well as unnecessary overfetching. In many cases conventional techniques for placing compressed data within cache lines such as during scenarios involving compression on UI workloads may be especially inefficient when handling data segments compressed with 4 1 or 4 3 compression ratios.

The computing device configured to perform various conventional compression algorithms may be capable of compressing the source data segments with different compression ratios such as a 4 1 compression ratio e.g. compressing a 256 Byte data segment to a 64 Byte data segment a 4 2 compression ratio e.g. compressing a 256 Byte data segment to a 128 Byte data segment a 4 3 compression ratio e.g. compressing a 256 Byte data segment to a 192 Byte data segment and a 4 4 compression ratio e.g. compressing a 256 Byte data segment to a 256 Byte data segment or no compression .

For example a second line of the diagram illustrates a first compression of the source data segments . In particular the first source data segment may be compressed by the computing device to a first compressed data segment that is 192 Bytes in size i.e. using a 4 3 compression ratio . The first compressed data segment may remain in alignment with the first source data segment i.e. the beginning of the first compressed data segment may be stored with no offset in the first cache line . In the second line regarding the second source data segment the computing device may use a 4 4 compression ratio or not be compressed and thus the second source data segment may still be 256 Bytes in size. Source data segments may be selectively compressed such as when a compression algorithm used by the computing device is not configured to be capable of compressing a particular data segment or the computing device is otherwise configured to not choose to compress a data segment.

The first compressed data segment may still correspond or be aligned with the first cache line and the second cache line however due to its smaller size i.e. less than the original 256 Bytes the first compressed data segment may only utilize part or half of the second cache line . In other words the 192 Byte first compressed data segment may cause the 128 Byte first cache line to be fully used and the 128 Byte second cache line to only be half used. As a result of the half use of the second cache line a first 64 Byte overfetch data segment of unused data referred to in as OF may also be present in the second cache line . For example the first overfetch section may be loaded in the second cache line when reading the first compressed data segment in from DDR or other memory.

As another example a third line of the diagram illustrates a second compression of the source data segments . In particular the first source data segment may be compressed by the computing device to a second compressed data segment that is 64 Bytes in size i.e. using a 4 1 compression ratio . The second compressed data segment may remain in alignment with the first source data segment i.e. the beginning of the second compressed data segment may be stored with no offset in the first cache line . The second compressed data segment may not utilize the second cache line and thus the second cache line may be filled with two 64 Byte unused data segments e.g. invalid null or otherwise unused data segments . Alternatively the second cache line may be filled with one 128 Byte invalid data segment. Due to the 64 Byte second compressed data segment only filling half the 128 Byte first cache line a second 64 Byte overfetch data segment of overfetch unused data may also be present in the first cache line

Similar to the second compressed data segment in the third line the second source data segment may be compressed by the computing device to a third compressed data segment that is 64 Bytes in size i.e. using a 4 1 compression ratio . The third compressed data segment may remain in alignment with the second source data segment i.e. the beginning of the third compressed data segment may be stored with no offset in the third cache line . The third compressed data segment may not utilize the fourth cache line and thus the fourth cache line may be filled with two 64 Byte unused data segments or alternatively one 128 Byte unused data segment . However due to the 64 Byte third compressed data segment only filling half the 128 Byte third cache line a third 64 Byte overfetch data segment of overfetch unused data may also be present in the third cache line

As another example a fourth line of the diagram illustrates a third compression of the source data segments . In particular the first source data segment may be compressed by the computing device to a fourth compressed data segment that is 128 Bytes in size i.e. using a 4 2 compression ratio . The fourth compressed data segment may remain in alignment with the first source data segment i.e. the beginning of the fourth compressed data segment may be stored with no offset in the first cache line . The fourth compressed data segment may not utilize the second cache line and thus the second cache line may be filled with a 128 Byte unused data segment or alternatively two 64 Byte unused data segments .

The second source data segment may be compressed by the computing device to a fifth compressed data segment that is 192 Bytes in size i.e. using a 4 3 compression ratio . The fifth compressed data segment may remain in alignment with the second source data segment i.e. the beginning of the fifth compressed data segment may be stored with no offset in the third cache line . The fifth compressed data segment may only partially utilize the fourth cache line and thus the fourth cache line may be filled with a fourth 64 Byte overfetch data segment .

To improve upon the inefficient placement of compressed data segments of conventional techniques illustrated in various aspects include methods devices and non transitory process readable storage media for compacting data segments within a cache so that the data segments overlap on cache lines. In other words a data segment may be placed within an address range e.g. physical address range of a cache typically associated with other another data segment instead of within its own normal address range resulting in a more efficient use of cache lines i.e. fewer cache lines are required to store the same amount of data . With such overlapping small compressed data segments may share cache lines enabling more efficient memory accesses e.g. DDR MAL and less frequent unneeded overfetching.

In various aspects a computing device may be configured to perform cache line compacting operations that shift or offset the placement of a data segment into an exclusive range or address space of the cache typically associated with another data segment. For example the computing device may shift two contiguous exclusive ranges so that they extend into each half of a single cache line. To achieve such compaction the computing device may identify a base offset to be applied to the base address of a first data segment or data block in order to store the first data segment within a cache line e.g. within a physical address typically associated with a second data segment. A base offset may be determined by the computing device based on at least a data size of the data segment. Such a data size may be identified based on a compression ratio of the data segment i.e. a ratio of an uncompressed size to a compressed size . For example a base offset for a data segment may be a first amount in Bytes from a base address when the data segment is compressed at a first compression ratio e.g. 4 4 and a second amount when the data segment is compressed at a second compression ratio e.g. 4 1 . Such compression ratios may be identified by the computing device based on the various compression algorithms utilized by the computing device to compress the data segments.

In addition to data sizes e.g. compression ratios base offsets may be determined by the computing device based on base addresses themselves. For example a data segment compressed at a certain compression level e.g. 4 1 may have a first offset e.g. 64 Bytes when a certain bit e.g. bit of its base address is odd i.e. a 1 and a second offset e.g. 256 Bytes when the certain bit is even i.e. a 0 . In some aspects the value of a bit of a base address may change with each 256 Bytes in base addresses. For example for a first address in a cache the bit may be a 0 value but for a second address 256 Bytes apart from the first address the bit value may be a 1 value.

In some aspects base offsets for compressed data segments may be less than a 4 KB page size. Thus the computing device may perform aspect compaction operations or techniques for any virtual address or physical address of various memory or cache units.

In some aspects the computing device may perform a look up on a predefined data table using a compression ratio and information about the base address e.g. physical address in cache of a data segment to identify a corresponding base offset. However instead of utilizing predetermined data tables in some aspects the computing device may identify offset values for compacting data segments within the cache using logic software circuits and other functionalities. For example the computing device may identify offset values and calculate offset addresses via the processor of the computing device executing software e.g. operations to access a stored data table etc. and or via a dedicated circuit coupled to the processor of the computing device.

In some aspects the computing device may shift all exclusive ranges by half a cache line equal to the smallest compression size from the base addresses. In this way compressed data segments that do not fill a cache line can be offset into the cache line that is shared with the exclusive range of another source data segment enabling opportunistic use of a whole cache line i.e. consecutive compressions can be mapped to the shared cache line .

Aspect techniques may be utilized by the computing device to compact data segments independently of other data segments within a buffer. For example regardless of the compression ratio used for a neighboring data segment a particular data segment may be offset within cache lines based only on its own compression ratio and base address. In other words in order to compact a data segment the computing device may not be required to be aware of the compression ratios and or offsets of other data segments.

The following is an example application of an aspect method by a computing device. The computing device may be configured to perform a read from a memory unit e.g. DDR to retrieve an uncompressed data segment i.e. a source data segment . The uncompressed retrieved data segment may typically be associated with a base address e.g. a physical address in a cache. The computing device may evaluate the retrieved data segment to identify the level of compression or ratio that may be applied via a compression algorithm. The identified compression ratio may be the maximum that is possible for the data segment in order to maximize cache space usage. The computing device may compress the data segment at that compression ratio. Based on the compression ratio and the base address the uncompressed data segment is associated with the computing device may identify an offset within the cache to store the compressed data segment such as an offset 64 Bytes from the base address. The computing device may then load the compressed data segment in the offset address.

The various aspects may be beneficial in reducing unnecessary bandwidth use related to overfetching in various types of computing devices for which improvements in power and or memory bandwidth e.g. DDR usage is desirable. For example aspect operations may be utilized by mobile devices e.g. smartphones that utilize system on chips. Further the various aspects may be beneficial by enabling prefetching for use in an L3 cache or other similar memory or storage unit to improve performance of computing devices. In particular a data segment and an adjacent data segment or neighboring segment stored in a shared cache line may be fetched at the same time thereby reducing reads. For example the computing device may retrieve a first compressed data segment of a 64 Byte size along with an adjacent second compressed data segment of the 64 Byte size.

The aspect cache line compaction operations described herein may be performed by the computing device to reduce overfetch for various workloads including UI workloads. The aspect operations may be particularly beneficial in reducing overfetch for workloads that include data segments compressed at 4 1 and 4 3 compression ratios that occur in contiguous blocks as well as data segments compressed at 4 1 or 4 2 compression ratios.

Conventional techniques include operations for configuring caches to support compressed and non compressed lines as well as operations for determining whether to compress data. For example conventional techniques may include methods for compressing two non compressed lines that are adjacent into a single element due merely to the typical effect of compression operations e.g. adjacent lines sequential in physical address space may be compressed to fit in one line due to a compression operation .

Unlike conventional techniques the various aspects do not simply address compression or storing compressed data in caches. Instead the aspect techniques provide functionalities that may be used to change such conventional compression techniques so that conventionally compressed data may be better positioned within cache lines. In other words the aspect techniques may be utilized by computing devices in a processing phase after compressing data such that post compression outputs i.e. already compressed data segments that conventionally would be placed in different cache lines are packed into the cache in a more efficient manner. For example a computing device performing aspect operations may take two different compressed data segments that would have been loaded into two different partially used cache lines and store the two compressed data segments into a single cache line by using offset shifting. In other words the aspects feature shifting already compressed data segments within the address space e.g. physical address space of a cache changing the base address of compressed data segments to improve cache usage.

For simplicity the descriptions of various aspects may refer to operations that compact compressed data segments within caches. However the various aspect operations may be applied by a computing device to compact any type of data e.g. compressed or uncompressed within any storage unit or architecture e.g. SRAM caches etc. . In other words the various aspects are not intended to be limited to use with data compression schemes. For example a computing device may perform aspect methods described herein to improve compaction of any data set that includes data segments of variable length or any data set with holes e.g. unused data segments in a buffer. Although base addresses may be referred to as physical addresses herein it should be appreciated that in some aspects base addresses may be virtual addresses.

In various aspects the computing device may utilize cache lines and thus data associated or stored within the cache lines that are contiguous i.e. neighboring storage . However in some aspects the computing device may be configured to store access data segments within non contiguous addresses within a cache. In other words aspect techniques may enable the compaction of data segments stored in cache lines that may or may not be in different places in memory.

For simplicity computing devices performing various aspect methods may be referred to as identifying or otherwise using compression ratios associated with data segments in order to calculate offset addresses. However it should be appreciated that computing devices performing such aspects may identify or otherwise use any form of indication of the data size of such data segments in order to compact the data segments according to various aspects. In other words the various aspects may be used to perform compaction on data segments that may or may not be compressed. Computing devices performing various aspect techniques may be capable of identifying data sizes of data segments based on various compression ratios and data size distributions and therefore compression ratios examples referred to in the descriptions of various aspects are not intended to limit the scope of the claims to 4 1 4 2 4 3 4 4 compression ratios.

The cache lines may be associated with physical addresses that may increase from left to right i.e. the physical address of the first cache line is a number less than the number associated with the physical address of the second cache line etc. . In some aspects the physical addresses of the cache lines may be represented by at least 8 bits. shows indications of the eighth and seventh bits of the associated physical addresses of the various cache lines . For example the eighth bit or bit of the first cache line may be a 0 value and the seventh bit or bit of the first cache line may be a 0 value the eighth bit or bit of the second cache line may be a 0 value and the seventh bit or bit of the second cache line may be a 1 value the eighth bit or bit of the third cache line may be a 1 value and the seventh bit or bit of the third cache line may be a 0 value etc.

A first line of the diagram illustrates default placements of uncompressed source data segments within 256 Byte segment boundaries when stored in the cache according to typical techniques. In other words source data segments may be stored within their base addresses at 256 Byte intervals. In particular a first source data segment referred to as A in may be placed with no offset within the first cache line and the second cache line . A second source data segment referred to as B in may be placed with no offset within the third cache line and the fourth cache line . A third source data segment referred to as C in may be placed with no offset within the fifth cache line and the sixth cache line . A fourth source data segment referred to as D in may be placed with no offset within the seventh cache line and the eighth cache line .

Lines of the diagram illustrate offset placements of compressed forms of the source data segments that overlap the base addresses in accordance with aspect techniques. In some aspects the base offsets used by the computing device to place the various compressed data segments as described below may be based on look ups performed on a predefined data table such as described below with reference to .

A second line of the diagram illustrates a simple offset placement of 256 Byte compressed data segments within a 64 Byte base offset from their respective base addresses. Such a mapping may require that an additional 64 Bytes be allocated at the end of all compressed data buffers using this aspect. A first compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device with a 64 Byte offset to be within half of the first cache line the entire second cache line and half of the third cache line . The first compressed data segment may overlap into the third cache line by a 64 Byte overlap . A second compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device with a 64 Byte offset to be within half of the third cache line the entire fourth cache line and half of the fifth cache line . The second compressed data segment may overlap into the fifth cache line by a 64 Byte overlap . A third compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device with a 64 Byte offset to be within half of the fifth cache line the entire sixth cache line and half of the seventh cache line . The third compressed data segment may overlap into the seventh cache line by a 64 Byte overlap . A fourth compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device with a 64 Byte offset to be within half of the seventh cache line the entire eighth cache line and half of another cache line not shown . The fourth compressed data segment may cross the interleave and may overlap into the another cache line not shown by a 64 Byte overlap . The compressed data segments may be compressed by the computing device at a 4 4 compression ratio or alternatively not compressed but only shifted via base offsets.

A third line of the diagram illustrates offset placement of 64 Byte data segments compressed at a 4 1 compression ratio by the computing device. In particular a first 64 Byte compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 256 Byte offset to be within half of the third cache line . A second 64 Byte compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 64 Byte offset to be within the other half of the third cache line . In other words the first and second 64 Byte compressed data segments may share the third cache line despite that cache line being typically associated with only the second source data segment i.e. B . Due to the 256 Byte and 64 Byte offset placements of the first and second 64 Byte compressed data segments respectively the first cache line second cache line and fourth cache line may include unused data . In other words the computing device may not have been required to fetch any data for these cache lines . Such unused cache lines i.e. the cache lines associated with unused data may be free for the cache to allocate to other requests.

Also referring to the third line of the diagram a third 64 Byte compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device at a 256 Byte offset to be within half of the seventh cache line . A 192 Byte compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a 64 Byte offset within the other half of the seventh cache line and the entire eighth cache line . The 192 Byte compressed data segment may have been compressed by the computing device at a 4 3 compression ratio. The third 64 Byte compressed data segment and the 192 Byte compressed data segment may share the seventh cache line despite that cache line being typically associated with only the fourth source data segment i.e. D . Due to the 256 Byte and 64 Byte offset placements of the third 64 Byte compressed data segment and 192 Byte compressed data segment respectively the fifth cache line and the sixth cache line may include unused data .

A fourth line of the diagram illustrates offset placement of 128 Byte data segments compressed at a 4 2 compression ratio by the computing device. In particular a first 128 Byte compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 128 Byte offset to be within the second cache line . A second 128 Byte compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 128 Byte offset to be within the fourth cache line . In this way the first and second 128 Byte compressed data segments may still be stored within their typical segment boundaries but may be offset such that the first cache line and the third cache line include unused data . In other words due to the 128 Byte offsets the computing device may not have been required to fetch any data for these cache lines .

Also referring to the fourth line of the diagram a third 128 Byte compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device at a 128 Byte offset within the sixth cache line . A 64 Byte compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a 64 Byte offset to be within the seventh cache line . In this way the third 128 Byte compressed data segment and the 64 Byte compressed data segment may still be stored within their typical segment boundaries but may be offset such that the fifth cache line and the eighth cache line include unused data . However due to the 64 Byte compressed data segment not completely filling the seventh cache line and the third 128 Byte compressed data segment not being offset into the fourth segment boundary the seventh cache line may be half filled with overfetch data .

A fifth line of the diagram illustrates offset placement of 192 Byte data segments compressed at a 4 3 compression ratio by the computing device. In particular a first 192 Byte compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 128 Byte offset to be within the second cache line and half of the third cache line . A second 192 Byte compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 64 Byte offset to be within half of the third cache line and the fourth cache line . In this way the first and second 192 Byte compressed data segments may be offset to share the third cache line enabling the first cache line to include unused data . In other words due to the 192 Byte offsets the computing device may not have been required to fetch any data for the first cache line .

Also referring to the fifth line of the diagram a 64 Byte compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device at a 256 Byte offset to be within the seventh cache line . A 256 Byte compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a 64 Byte offset to be within half the seventh cache line the full eighth cache line and half of another cache line not shown . In this way the fifth and sixth cache lines may include unused data . However the 256 Byte compressed data segment may cross the interleave and thus the computing device may be required to use separate transactions.

A sixth line of the diagram illustrates offset placement of 256 Byte data segments compressed at a 4 4 compression ratio by the computing device. In particular a first 256 Byte compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 64 Byte offset to be within half of the first cache line the entire second cache line and half of the third cache line . A second 256 Byte compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 64 Byte offset to be within half of the third cache line the entire fourth cache line and half of the fifth cache line . Further a third 256 Byte compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device at a 64 Byte offset to be within half of the fifth cache line the full sixth cache line and half of the seventh cache line . A 64 Byte compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a 64 Byte offset to be within half the seventh cache line . In this way the eighth cache line may include unused data . However due to the first 256 Byte compressed data segment not completely filling the first cache line the first cache line may be half filled with overfetch data .

In some aspects the computing device may split data segments into separate transactions across boundaries in order to mitigate when the data segments are mapped to cross the interleave and or page boundaries. For example and as described below in when the computing device places 256 Byte compressed data segments e.g. segments compressed with a compression ratio over an interleave and or page boundaries two separate transactions may be required.

For example in response to performing a lookup on the data table for a data segment that is compressed at a 4 1 compression rate and has a base address with an even value bit the computing device may identify a 256 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 1 compression rate and has a base address with an odd value bit the computing device may identify a 64 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 2 compression rate and has a base address with an even or an odd value bit the computing device may identify a 128 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 3 compression rate and has a base address with an even value bit the computing device may identify a 128 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 3 compression rate and has a base address with an odd value bit the computing device may identify a 64 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 4 compression rate and has a base address with an even or an odd value bit the computing device may identify a 64 Byte base offset.

The pseudo code referred to as Pseudo code A in may represent a function called getNewAddress oddOrEven that may require a Base Address input parameter and a Compression Ratio input parameter related to a particular data segment. In some aspects the Base Address may be a binary representation of a physical address or a virtual address. The function shown in the pseudo code may include instructions for the computing device to perform a shift right operation on the Base Address input parameter in order to move a bit of the data segment s base address to the rightmost bit for storage in a Shift variable the shift right operation indicated in as 8 . The function shown in the pseudo code may include instructions for performing a bitwise AND operation or in on the bit of the address i.e. the Shift variable and a 1 value e.g. . . . 000000001 that may generate a value stored in a Parity variable. In other words the value in the Parity variable may be 0 when the Shift variable is 0 and the Parity variable value may be 1 when the Shift variable is 1.

The function shown in the pseudo code may also include instructions for the computing device to use the Compression Ratio input parameter and the calculated Parity variable to perform a lookup operation on a predefined table such as described in . The retrieved value from the lookup may be stored in an Offset variable. In some aspects the lookup operation may be an operation to access information in a two dimensional 2D array stored within memory of the computing device. Finally the function shown in the pseudo code may include an instruction for the computing device to add the Base Address and the Offset variables to generate an offset address e.g. a new offset physical address that may be returned for use by the computing device to place the data segment.

In some aspects the computing device may be configured with simplified logic circuits software instructions and or routines to generate new addresses instead of utilizing a table lookup operation as indicated with the pseudo code .

For example in the function may utilize a Base Address input parameter with a value of . . . 100000000 and a Compression Ratio input parameter with a value of 4 4 . In response to performing a shift right operation on the Base Address input parameter the computing device may generate a value of . . . 000000010 in order to move the bit of the data segment s base address e.g. physical address to the rightmost bit for storage in a Shift variable. The function may include instructions for performing a bitwise AND operation on the Shift variable and a 1 value or . . . 000000001 that may generate a value stored in a Parity variable. For example when the Shift variable has a value of . . . 000000010 the bitwise AND operation may produce a Parity variable value of . . . 000000000 or simply 0 . With the exemplary Parity variable value of 0 and the exemplary value of the Compression Ratio 4 4 the results of a lookup on the predefined table described in may return an Offset variable value of 64 Bytes. The function may then return a new offset address for the data segment that is the combination of the Offset variable value e.g. 64 Bytes and the Base Address e.g. . . . 100000000 .

In some aspects a computing device may be configured to place data segments with offsets in cache lines in such a way that page boundaries or interleaves are not crossed. In other words the computing device may map 64 Byte data segments outside of a 512 Byte section or two 256 Byte sections such that the data segments wrap around to the beginning of the 512 Byte section to avoid crossing page boundaries. To illustrate such aspects shows offset placements of data segments that are compressed with various compression ratios according to another aspect cache line compaction technique that utilizes such a wrap around. The diagram of is similar to the diagram described above with reference to except that the aspect offset placements illustrated in may not allow data segments to be placed in the cache such that they cross either page or interleave boundaries greater than 512 Bytes. The aspect offset placements illustrated in may also result in more even cache bank usage for data segment placements. However compared to the aspect offset placements illustrated in the alternative aspect illustrated in may on average result in half of the data segments compressed at a 4 4 compression ratio to be split into two transactions. In other words non contiguous requests to place data segments compressed at a 4 4 compression ratio may result in more split requests than the aspect technique illustrated in . The aspect technique illustrated by may be beneficial in reducing most overfetch especially when used with L3 caches. Further simple prefetching may be enabled with or without L3 caches. In various aspects the 4 4 compression ratio may be the least probable compression ratio and so splitting data segments into two transactions may be a corner case.

As illustrated in cache lines may be associated with physical addresses that may increase from left to right i.e. the physical address of the first cache line is a number less than the number associated with the physical address of the second cache line etc. . In some aspects the physical addresses of the cache lines may be represented by at least 9 bits. shows indications of the ninth eighth and seventh bits of the associated physical addresses of the various cache lines . For example the ninth bit or bit of the first cache line may be a 0 value the eighth bit or bit of the first cache line may be a 0 value and the seventh bit or bit of the first cache line may be a 0 value and the ninth bit or bit of the fifth cache line may be a 1 value the eighth bit or bit of the fifth cache line may be a 0 value and the seventh bit or bit of the fifth cache line may be a 0 value.

As described above with reference to a first line of the diagram illustrates default placements of source data segments within the 256 Byte segment boundaries when stored in the cache according to typical techniques. A first source data segment referred to as A in may be placed by the computing device with no offset to be within the first cache line and the second line . A second source data segment referred to as B in may be placed by the computing device with no offset to be within the third cache line and the fourth cache line . A third source data segment referred to as C in may be placed by the computing device with no offset to be within the fifth cache line and the sixth cache line . A fourth source data segment referred to as D in may be placed by the computing device with no offset to be within the seventh cache line and the eighth cache line .

However lines of the diagram illustrate offset placements of compressed forms of the source data segments that overlap the base addresses in accordance with aspect operations performed by the computing device. In some aspects the base offsets used by the computing device to place the various compressed data segments may be based on look ups performed on a predefined data table such as described in below.

A second line of the diagram illustrates an offset placement of 256 Byte compressed data segments . A first compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 64 Byte offset to be within half of the first cache line the entire second cache line and half of the third cache line . The first compressed data segment may overlap into the third cache line by a 64 Byte overlap. A second compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 64 Byte offset to be within half of the third cache line and the entire fourth cache line . However to avoid crossing interleaves the computing device may be configured to store the 256 Byte second compressed data segment in two separate sections. Thus the remainder of the 256 Byte second compressed data segment referred to as B Rem in may be placed by the computing device within the first half of the first cache line . A third compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device with no offset to be within the fifth cache line and half of the sixth cache line . Similar to the second compressed data segment the third compressed data segment may be split into two sections in order to avoid crossing the interleave. Thus the remainder of the third compressed data segment may be placed in half of the eighth cache line . A fourth compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a negative 64 Byte offset to be within half of the sixth cache line the entire seventh cache line and half of the eighth cache line .

A third line of the diagram illustrates offset placement of 64 Byte data segments compressed at a 4 1 compression ratio by the computing device. In particular a first 64 Byte compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 256 Byte offset to be within half of the third cache line . A second 64 Byte compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 64 Byte offset to be within the other half of the third cache line . In other words the first and second 64 Byte compressed data segments may share the third cache line despite that cache line being typically associated with only the second source data segment i.e. B . Due to the 256 Byte and 64 Byte offset placements of the first and second 64 Byte compressed data segments respectively the first cache line second cache line and fourth cache line may include unused data . In other words the computing device may not have been required to fetch any data for these cache lines . Such unused cache lines i.e. the cache lines associated with unused data may be free for the cache to allocate to other requests.

Also referring to the third line of the diagram a third 64 Byte compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device at a 128 Byte offset to be within half of the sixth cache line . A 192 Byte compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a negative 64 Byte offset to be within the other half of the sixth cache line and the entire seventh cache line . The 192 Byte compressed data segment may have been compressed by the computing device at a 4 3 compression ratio. Due to the 128 Byte and negative 64 Byte offset placements of the third 64 Byte compressed data segment and 192 Byte compressed data segment respectively the fifth cache line and the eighth cache line may include unused data .

A fourth line of the diagram illustrates offset placement of 128 Byte data segments compressed at a 4 2 compression ratio by the computing device. In particular a first 128 Byte compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 128 Byte offset to be within the second cache line . A second 128 Byte compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 128 Byte offset to be within the fourth cache line . In this way the first and second 128 Byte compressed data segments may still be stored within their typical segment boundaries but may be offset such that the first cache line and the third cache line include unused data . In other words due to the 128 Byte offsets the computing device may not have been required to fetch any data for these cache lines .

Also referring to the fourth line of the diagram a third 128 Byte compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device within the fifth cache line with no offset. A 64 Byte compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a negative 64 Byte offset to be within half of the sixth cache line . In this way the third 128 Byte compressed data segment and the 64 Byte compressed data segment may still be offset such that the seventh cache line and the eighth cache line include unused data . However due to the 64 Byte compressed data segment not completely filling the sixth cache line the sixth cache line may be half filled with overfetch data .

A fifth line of the diagram illustrates offset placement of 192 Byte data segments compressed at a 4 3 compression ratio by the computing device. In particular a first 192 Byte compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 128 Byte offset to be within the second cache line and half of the third cache line . A second 192 Byte compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 64 Byte offset to be within half of the third cache line and the fourth cache line . In this way the first and second 192 Byte compressed data segments may be offset to share the third cache line enabling the first cache line to include unused data . In other words due to the 192 Byte offsets the computing device may not have been required to fetch any data for the first cache line .

Also referring to the fifth line of the diagram a 64 Byte compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device at a 128 Byte offset to be within half of the sixth cache line . A 256 Byte compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a negative 64 Byte offset to be within half the sixth cache line the full seventh cache line and half of the eighth cache line . In this way the fifth cache line may include unused data . However overfetch data may be within half of the eighth cache line .

A sixth line of the diagram illustrates offset placement of 256 Byte data segments compressed at a 4 4 compression ratio by the computing device. In particular a first 256 Byte compressed data segment corresponding to the first source data segment i.e. A may be placed by the computing device at a 64 Byte offset to be within half of the first cache line the entire second cache line and half of the third cache line . A second 256 Byte compressed data segment corresponding to the second source data segment i.e. B may be placed by the computing device at a 64 Byte offset to be within half of the third cache line and the entire fourth cache line . However the computing device may be configured to store the second 256 Byte compressed data segment in two separate sections. Thus the remainder of the second 256 Byte compressed data segment referred to as B Rem in may be placed by the computing device within the first half of the first cache line . A third compressed data segment corresponding to the third source data segment i.e. C may be placed by the computing device with no offset to be within the fifth cache line and half of the sixth cache line . Similar to the second compressed data segment the third compressed data segment may be split into two sections in order to avoid crossing the interleave. Thus the remainder of the third compressed data segment may be placed in half of the eighth cache line . A 64 Byte compressed data segment corresponding to the fourth source data segment i.e. D may be placed by the computing device at a negative 64 Byte offset to be within half of the sixth cache line . However overfetch data may be within half of the eighth cache line .

Such a data table may be similar to the data table described above with reference to except the base address parity information of may be an indication of the values of the bit and the bit for the data segment s base address e.g. 0 or 1 for the two bits . In other words lookups performed on the data table may require a two bit value and a compression ratio in order for the computing device to identify a base offset value to apply to a base address e.g. a physical address of a data segment. Another difference between the data table and the data table described in is that the data table may store more than one base offset value for certain compression ratios e.g. 4 4 compression ratio and two bit values associated with data segment addresses e.g. physical addresses . In particular when segments are required to be split into two transaction to avoid crossing page boundaries or interleaves the data table may include a first base offset value for a first transaction and a second base offset value for a second transaction. In such cases the data table may indicate the size of each transaction that is associated with each of the base offset values. In some aspects the computing device may use other combinations of bits to perform lookups wherein such combinations may be based on the hashing of stored data.

For example in response to performing a lookup on the data table for a data segment that is compressed at a 4 1 compression rate and has a base address with a 0 value for its bit and a 0 value for its bit the computing device may identify a 256 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 1 compression rate and has a base address with a 0 value for its bit and a 1 value for its bit the computing device may identify a 64 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 1 compression rate and has a base address with a 1 value for its bit and a 0 value for its bit the computing device may identify a 128 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 1 compression rate and has a base address with a 1 value for its bit and a 1 value for its bit the computing device may identify a negative 64 Byte base offset.

As another example in response to performing a lookup on the data table for a data segment that is compressed at a 4 2 compression rate and has a base address with a 0 value for its bit and a 0 value for its bit the computing device may identify a 128 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 2 compression rate and has a base address with a 0 value for its bit and a 1 value for its bit the computing device may identify a 128 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 2 compression rate and has a base address with a 1 value for its bit and a 0 value for its bit the computing device may identify a 0 Byte base offset i.e. no base offset . In response to performing a lookup on the data table for a data segment that is compressed at a 4 2 compression rate and has a base address with a 1 value for its bit and a 1 value for its bit the computing device may identify a 0 Byte base offset i.e. no base offset .

As another example in response to performing a lookup on the data table for a data segment that is compressed at a 4 3 compression rate and has a base address with a 0 value for its bit and a 0 value for its bit the computing device may identify a 128 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 3 compression rate and has a base address with a 0 value for its bit and a 1 value for its bit the computing device may identify a 64 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 3 compression rate and has a base address with a 1 value for its bit and a 0 value for its bit the computing device may identify a 0 Byte base offset i.e. no base offset . In response to performing a lookup on the data table for a data segment that is compressed at a 4 3 compression rate and has a base address with a 1 value for its bit and a 1 value for its bit the computing device may identify a negative 64 Byte base offset.

As another example in response to performing a lookup on the data table for a data segment that is compressed at a 4 4 compression rate and has a base address with a 0 value for its bit and a 0 value for its bit the computing device may identify a 64 Byte base offset. In response to performing a lookup on the data table for a data segment that is compressed at a 4 4 compression rate and has a base address with a 0 value for its bit and a 1 value for its bit the computing device may identify a negative 256 Byte base offset for a first transaction that is 64 Bytes in size and a 64 Byte base offset for a second transaction that is 192 Bytes in size. In response to performing a lookup on the data table for a data segment that is compressed at a 4 4 compression rate and has a base address with a 1 value for its bit and a 0 value for its bit the computing device may identify a 0 Byte base offset for a first transaction that is 192 Bytes in size and a 448 Byte base offset for a second transaction that is 64 Bytes in size. In response to performing a lookup on the data table for a data segment that is compressed at a 4 4 compression rate and has a base address with a 1 value for its bit and a 1 value for its bit the computing device may identify a negative 64 Byte base offset.

The pseudo code referred to as Pseudo code B in may represent a function called getNewAddress bit that may require a Base Address input parameter and a Compression Ratio input parameter related to a particular data segment. In some aspects the Base Address may be a binary representation of a physical address. The operational content of the function may include instructions for the computing device to perform a first shift right operation on the Base Address input parameter in order to move a bit of the data segment s base address to the rightmost bit for storage in a Shift variable. Such a shift may also move the bit of the Base Address to the second rightmost bit in the Shift variable. The function may include instructions for performing a bitwise AND operation or in on the shifted address i.e. the Shift variable and a 1 value for the two rightmost bits e.g. . . . 011 that may generate a value stored in a Parity variable. In other words the bitwise AND operation may zero out any other bits in the shifted address i.e. Shift variable so that the shifted address may be used as a parity value for performing lookups.

The function illustrated by the pseudo code may also include instructions for the computing device to use the Compression Ratio input parameter and the calculated Parity variable to perform lookup operations on a predefined table such as described with reference to . However as there are two possible cases that may require more than one base offset value to be returned from a table lookup the function may include evaluate whether the Compression Ratio is equal to 4 4 or whether the value of the Parity variable indicates the bit and bit are the same i.e. . . . 00 or . . . 11 . If the computing device determines that either the Compression Ratio is equal to 4 4 or the value of the Parity variable indicates the bit and bit are the same i.e. . . . 00 or . . . 11 the computing device may perform a lookup operation using the Compression Ratio and Parity to retrieve a single offset value to be stored in the Offset variable. Such a single offset value may be combined with the Base Address and returned for use in offset placement.

However if the computing device determines that the Compression Ratio is equal to 4 4 and the value of the Parity variable indicates the bit and bit are not the same i.e. . . . or . . . the computing device may perform a lookup operation using the Compression Ratio and Parity to retrieve two offset values to be stored in the Offset array variable. Each of the two offset values may be combined with the Base Address individually to generate new addresses for two transactions for a data segment. In various aspects the sizes of the two transactions may be returned as well as the offset values. In some aspects another call or function may be utilized to separately calculate and or return sizes and offset values for such transactions.

In some aspects the computing device may be configured with simplified logic circuits software instructions and or routines to generate new addresses instead of utilizing a table lookup as indicated with the pseudo code .

For example in the function may utilize a Base Address input parameter with a value of . . . 100000000 and a Compression Ratio input parameter with a value of 4 4 . In response to performing a shift right operation on the Base Address input parameter the computing device may generate a value of . . . 000000010 in order to move the bit of the data segment s base address e.g. physical address to the rightmost bit for storage in a Shift variable. The function may include instructions for performing a bitwise AND operation on the Shift variable and a . . . 11 value that may generate a value stored in a Parity variable. For example when the Shift variable has a value of . . . 000000010 the bitwise AND operation may produce a Parity variable value of . . . 000000010 .

As the example Compression Ratio is 4 4 and the example Parity variable value is not equal to . . . 00 or . . . 11 the computing device may not perform operations that retrieve a single base offset value from a lookup table. Instead the computing device may perform instructions to perform a lookup that returns two base offset values. In particular with the exemplary Parity variable value of . . . 000000010 and the exemplary value of 4 4 for the Compression Ratio the results of a lookup operation on the predefined table described in may return a first base offset value of 0 Bytes and a second base offset value of 448 Bytes. In some aspects the results of the lookup may also include the sizes of the transactions associated with the base offset values. The function may then return two new base offset addresses for two transactions for the data segment a first address that is the combination of the 0 Bytes and the Base Address e.g. . . . 100000000 0 Bytes and a second address that is the combination of the 448 Bytes and the Base Address e.g. . . . 100000000 448 Bytes .

In block the processor of the computing device may identify a base address e.g. a base physical address or a base virtual address for a data segment. As described above such a base address may be a cache line or cache address that the data segment is typically associated. For example the base address may be an address of a first cache line in which the data segment or source data segment is stored when in an uncompressed state. The base address may be the initial starting address for the data segment but it may not indicate the number of cache lines or cache space the data segment may require to be stored. In some aspects the base address may be the starting address of a requested block in memory that may be represented by allocated lines in the cache but generally may not be as the cache may allocate for compressed versions.

In block the processor of the computing device may identify a data size e.g. based on a compression ratio for the data segment. For example an identified data size may be based on a compression ratio of the data segment as identified by the computing device performing a read operation to another data buffer to obtain the compression ratio. In various aspects dependent upon the type of compression algorithms the computing device is configured to utilize there may be a plurality of available compression ratios for the data segment. For example when the computing device is configured to utilize a compression algorithm the data segment may be compressed at a 4 1 compression ratio a 4 2 compression ratio or a 2 1 compression ratio a 4 3 compression ratio and or a 4 4 compression ratio or a 1 1 compression ratio . The identified data size for the data segment may be based on the compression ratio that results in the greatest possible reduction of the size of the data segment or maximum compression . In various aspects the identified data size or compression size may be different for different types of data data structures and or contexts. For example the computing device may identify a first data size for a first compression ratio for a first data segment of a first data type but a second data size for a second compression ratio for a second data segment of a second data type.

In block the processor of the computing device may obtain a base offset based on the identified data size and the base address of the data segment. The base offset may be a number of bytes such as 64 Bytes 128 Bytes 192 Bytes and or 256 Bytes. In some aspects the base offset may be a negative number of Bytes such as negative 64 Bytes. In some aspects the size of a base offset may be a multiple of the size of half a cache line of a cache in the computing device. In some aspects the computing device may perform a lookup on a data table as described above with reference to or and retrieve a base offset value. In some aspects the computing device may utilize an equation routine circuitry and or software module to determine the base offset. illustrates specific aspect operations for obtaining a base offset.

In block the processor of the computing device may calculate an offset address by offsetting the base address with the obtained base offset. For example the computing device may combine the obtained base offset e.g. a number of bytes with the base address to calculate a new address e.g. a new physical address that occurs before or after the base address in a cache. Such a calculation may result in an offset address that is larger than the base address when the obtained base offset is a positive value and an offset address that is smaller than the base address when the obtained base offset is a negative value. In optional block the processor of the computing device may store the data segment at the calculated offset address. In other words the calculated offset address may be used to populate a cache. For example the computing device may read the data segment from a memory e.g. DDR and load the data segment within one or more cache lines starting at the offset address. In some aspects the computing device may read the data segment as a compressed data segment from compressed memory. In optional block the processor of the computing device may read the data segment at the calculated offset address. In other words the calculated offset address may be used to retrieve or find data segments previously stored within cache lines. For example the computing device may use the calculated offset address to retrieve a data segment from the cache for use in an operation of an application etc. Further the reading of the operations in optional block may be of a specified size such as the data size determined above. In optional block the processor of the computing device may decompress the read data segment. In some aspects the decompressed data segment may be stored locally such as within its associated base address.

In some aspects the data segment may not be in the cache and may need to be fetched from memory and inserted into the cache. In some aspects there may be no cache and prefetching may be benefitted by the various aspect techniques.

The operations in blocks may be the same as described above with reference to . In block the processor of the computing device may identify parity value s for the data segment based on the base address. In some aspects the computing device may evaluate a bit in the base address to identify a parity value that indicates whether the bit is an even value i.e. 0 or an odd value i.e. 1 . Use of such a parity value is illustrated in . In some aspects in order to identify the parity value the computing device may perform a shift right operation to a binary representation of the base address to make a bit a rightmost bit and apply a bitwise AND operation to a . . . 001 binary value and the binary result of the shift right operation to identify the parity value. In some aspects the computing device may evaluate a bit and a bit of the base address to identify whether the two bits match predefined combinations that may be used as indices in a data table or 2D array e.g. 00 01 10 11 . Use of such parity values is illustrated in . In some aspects in order to identify the parity values the computing device may perform a shift right operation to a binary representation of the base address to make a bit a rightmost bit and apply a bitwise AND operation to a . . . 011 binary value and the binary result of the shift right operation to identify the parity values e.g. zero out all values in the binary result of the shift right operation except the 8 bit and 9 bit of the binary representation of the base address .

In block the processor of the computing device may obtain a base offset by performing a lookup on a stored table using the identified data size e.g. a size based on an identified compression ratio and the identified parity value s . For example the computing device may use a representation or code of an identified compression ratio e.g. 4 1 etc. and the parity value s as indices on a data table or 2D array as illustrated in . In some aspects the obtained offset may include a first offset for a first transaction and a second offset for a second transaction as described above. For example to avoid allowing the offset data segment to cross an interleave or page boundary the data segment may be split into two transactions that are associated with a first offset e.g. 0 Bytes and a second offset e.g. 448 Bytes from the base address. The computing device may continue with the operations in block to calculate the offset address. In some aspects when the obtained base offset includes two offsets the computing device may calculate two offset addresses for placing split segments into the cache.

In determination block the processor of the computing device may determine whether a next data segment or second data segment has a correct compression ratio to be contiguous with the data segment or first data segment that was read with the operations in block . For example when the computing device is configured to perform optional prefetching with a larger read request size the computing device may retrieve or read the next data block or compressed data block next to the data segment for which the operations of blocks were performed to size and identify within the cache. Such a determination may be based on logic testing routines or a circuit that is configured to determine whether the data block next to the read data segment has the correct compression level to be contiguous with the read data segment. In other words the computing device may determine whether the next data segment is compressed to a size such that the read of the data segment may include the next data segment as well. In response to determining that the next data segment has the correct compression ratio to be contiguous i.e. determination block Yes the processor of the computing device may prefetch the next data segment with the read of the other data segment in block . In response to determining that the next data segment does not have the correct compression ratio to be contiguous i.e. determination block No the processor of the computing device may end the method .

The operations in blocks may be the same as described above with reference to . In block the processor of the computing device may identify a compression ratio for the data segment such as an optimal compression ratio e.g. 4 1 4 2 4 3 4 4 etc. to which the data segment may be compressed. The operations in block may be similar to those described above with reference to block of . In block the processor of the computing device may read the data segment as uncompressed data at the base address such as by reading the data segment from the cache. In block the processor of the computing device may compress the data segment at the identified compression ratio. For example based on the maximum identified compression ratio available for the data segment e.g. 4 1 4 2 4 3 4 4 etc. the computing device may execute a compression algorithm or routine to cause the data segment to be reduced in size. As described above the computing device may obtain the base offset in block and calculate the offset address in block . In block the processor of the computing device may store the compressed data segment at the calculated offset address.

Various forms of computing devices e.g. personal computers smartphones laptop computers etc. may be used to implement the various aspects. Such computing devices typically include the components illustrated in which illustrates an example computing device . In various aspects the computing device may include a processor coupled to a touch screen controller and an internal memory . The processor may be one or more multicore ICs designated for general or specific processing tasks. The internal memory may be volatile or non volatile memory and may also be secure and or encrypted memory or unsecure and or unencrypted memory or any combination thereof. The touch screen controller and the processor may also be coupled to a touch screen panel such as a resistive sensing touch screen capacitive sensing touch screen infrared sensing touch screen etc. In some aspects the computing device may have one or more radio signal transceivers e.g. Peanut Bluetooth Zigbee Wi Fi RF radio and antennae for sending and receiving coupled to each other and or to the processor . The transceivers and antennae may be used with the above mentioned circuitry to implement the various wireless transmission protocol stacks and interfaces. In some aspects the computing device may include a cellular network wireless modem chip that enables communication via a cellular network and is coupled to the processor. The computing device may include a peripheral device connection interface coupled to the processor . The peripheral device connection interface may be singularly configured to accept one type of connection or multiply configured to accept various types of physical and communication connections common or proprietary such as USB FireWire Thunderbolt or PCIe. The peripheral device connection interface may also be coupled to a similarly configured peripheral device connection port not shown . The computing device may also include speakers for providing audio outputs. The computing device may also include a housing constructed of a plastic metal or a combination of materials for containing all or some of the components discussed herein. The computing device may include a power source coupled to the processor such as a disposable or rechargeable battery. The rechargeable battery may also be coupled to the peripheral device connection port to receive a charging current from a source external to the computing device .

The processor may be any programmable microprocessor microcomputer or multiple processor chip or chips that can be configured by software instructions e.g. applications to perform a variety of functions including the functions of the various aspects described above. In the various devices multiple processors may be provided such as one processor dedicated to wireless communication functions and one processor dedicated to running other applications. Typically software applications may be stored in the internal memory before they are accessed and loaded into the processor . The processor may include internal memory sufficient to store the application software instructions. In many devices the internal memory may be a volatile or nonvolatile memory such as flash memory or a mixture of both. For the purposes of this description a general reference to memory refers to memory accessible by the processor including internal memory or removable memory plugged into the various devices and memory within the processor .

The foregoing method descriptions and the process flow diagrams are provided merely as illustrative examples and are not intended to require or imply that the steps of the various aspects must be performed in the order presented. As will be appreciated by one of skill in the art the order of steps in the foregoing aspects may be performed in any order. Words such as thereafter then next etc. are not intended to limit the order of the steps these words are simply used to guide the reader through the description of the methods. Further any reference to claim elements in the singular for example using the articles a an or the is not to be construed as limiting the element to the singular.

The various illustrative logical blocks modules circuits and algorithm steps described in connection with the aspects disclosed herein may be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules circuits and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.

The hardware used to implement the various illustrative logics logical blocks modules and circuits described in connection with the aspects disclosed herein may be implemented or performed with a general purpose processor a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any conventional processor controller microcontroller or state machine. A processor may also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration. Alternatively some steps or methods may be performed by circuitry that is specific to a given function.

In one or more exemplary aspects the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored on or transmitted over as one or more instructions or code on a non transitory processor readable computer readable or server readable medium or a non transitory processor readable storage medium. The steps of a method or algorithm disclosed herein may be embodied in a processor executable software module or processor executable instructions which may reside on a non transitory computer readable storage medium a non transitory server readable storage medium and or a non transitory processor readable storage medium. For example such instructions may be stored processor executable software instructions. Tangible non transitory computer readable storage media may be any available media that may be accessed by a computer. By way of example and not limitation such non transitory computer readable media may comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that may be used to store desired program code in the form of instructions or data structures and that may be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of non transitory computer readable media. Additionally the operations of a method or algorithm may reside as one or any combination or set of codes and or instructions on a tangible non transitory processor readable storage medium and or computer readable medium which may be incorporated into a computer program product.

The preceding description of the disclosed aspects is provided to enable any person skilled in the art to make or use the present invention. Various modifications to these aspects will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other aspects without departing from the spirit or scope of the invention. Thus the present invention is not intended to be limited to the aspects shown herein but is to be accorded the widest scope consistent with the following claims and the principles and novel features disclosed herein.

