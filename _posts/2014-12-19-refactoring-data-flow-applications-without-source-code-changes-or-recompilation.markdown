---

title: Refactoring data flow applications without source code changes or recompilation
abstract: Systems and methods may provide refactoring data flow applications without source code changes or recompilation. An apparatus may create a map file that describes how an original graph structure and node properties are mapped to a new structure and set of properties. A runtime system aware of the mapping may transform a graph that is constructed by the data flow application into the new structure at runtime.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09529587&OS=09529587&RS=09529587
owner: Intel Corporation
number: 09529587
owner_city: Santa Clara
owner_country: US
publication_date: 20141219
---
Embodiments generally relate to data flow programming. More particularly embodiments relate to refactoring the structure of a data flow graph application without making source code changes.

Data flow programming may involve developing an application that is constructed as computational nodes that execute user or predefined functions. These nodes may be connected by edges that represent the communication channels between the computations. As messages arrive at a node the node may apply its function and then may forward the result of the function to other nodes that may be connected to it by its out going edges. If all data dependencies are expressed using edges the parallelism in the application may become simple to infer and a runtime system may use the parallelism to exploit the computational resources available on a platform whether they may be cores in a multiprocessor or systems in a cluster.

When developing a data flow application developers may make decisions about the structure of the flow graph. For example the developers may choose what code should be encapsulated in each node and what dependencies may be expressed as edges. In distributed memory implementations decisions may be made about placement on devices or data transfers across memory domains. Additional properties may also be able to be set on the nodes and edges. There may be many ways to express the same algorithm as a data flow graph. The choice of graph structure placement and node properties may impact the resulting performance and scalability of the parallel execution and therefore iterative tuning of the graph structure may be needed to obtain optimal performance.

In a computing system to support refactoring according to an embodiment is described wherein a data flow interface may be used to obtain a data flow graph application. A first outliner controller may engage a runtime system and a graph library see . The runtime system and the graph library together may execute and profile an original flow graph see . The original flow graph may be profiled to obtain knowledge about its structure and behavior. Additionally an originator controller may be used to create a map file based on one or more refactoring inputs see wherein the map file may be created automatically or in response to a user refactoring input at runtime. The map file may describe how the original flow graph structure and node properties may be mapped to a new structure and set of properties. A runtime system that may be aware of the map file may transform the original flow graph that is constructed by the data flow graph application into the new structure at runtime see . A mapping process may allow developers to decrease development time by enabling them to iteratively tune the data flow graph application without editing and rebuilding the source code before each experiment. The originator controller may receive the refactoring inputs via a graphical user interface see .

The refactoring inputs may include but are not limited to situations where a set of independent nodes are aggregated into a single node to reduce the overhead of spawning and scheduling independent tasks a buffering node is replaced with a different buffering node type e.g. a queue node may be replaced with an unordered buffer node or a buffer node with a priority queue node an allowed concurrency for a function node or multifunction node is changed as when a parallel node that may consume excessive memory per instance may be changed from unlimited concurrency to serial concurrency a limit for a limiter node e.g. a node that limits the number of items that can pass through it is increased or decreased and in a prototype implementation of a distributed version of a flow graph that is currently under development distributor nodes may be placed where communication may be allowed between devices. The node terminologies used herein are to facilitate discussion only and may vary depending on the flow graph API application programming interface being used. At runtime the runtime system may be used to assist with inserting the aforementioned nodes without changing the source code or compiled executables associated with the data flow graph application.

A second outliner controller may be used to re profile the data flow graph application wherein the source code and one or more compiled executables associated with the data flow graph application may not be modified during the re profiling process. More particularly the map file and a refactoring graph library may be used by the second outliner controller in the re profile action to obtain a refactored flow graph. The refactoring graph library may be used to interpret the map file and follow directions given by the map file during execution of the refactored flow graph. Thus the changes afforded by the second outliner controller may be applied at runtime to evaluate efficacy. If performance improves after a change is applied as evidenced by the refactored flow graph a developer may decide to hard code the changes update the source code and recompile or may choose to allow the runtime system to continue to apply refactoring techniques using refactoring inputs at runtime.

In this example a data flow graph application with an associated source code may be profiled at block using a runtime system and a graph library. An original flow graph may be executed and profiled using the runtime system and the graph library see . A map file may be created at block based on receiving one or more refactoring inputs at block . The map file may describe how the original graph structure and node properties are to be mapped to a new structure and set of properties. A runtime system that is aware of the mapping language may transform the graph that is constructed by the data flow graph application into a new structure at runtime. The refactoring inputs may be created one or more of automatically or in response to a user refactoring input at runtime via a graphical user interface. A refactoring graph library may interpret the map file in context to a user s desired application. The refactoring graph library may be used when the data flow graph application is re profiled. The data flow graph application may be re profiled at block using the map file and the refactoring graph library to obtain a refactored flow graph. The source code and one or more compiled executables associated with the data flow graph application may not be modified. A developer may decide to hard code by changing the source code and recompile or allow the runtime system to continue to apply refactoring at runtime.

In a non transitory storage medium with a set of instructions to enable a computing system to refactor a data flow graph application is described. The set of instructions may instruct a runtime system to profile the data flow graph application using a graph library at runtime . An original flow graph may be created as a result of the aforementioned profiling of the data flow graph application. The original flow graph may be subjected to refactoring inputs that may change original graph structure and node type aggregation etc. and may create a map file . The refactoring inputs may be implemented automatically or manually via a graphical user interface . When the map file is created it may generate a refactoring graph library . The map file and the refactoring graph library may be used to obtain a re profiled the data flow graph application and may create a refactored flow graph without modifying source code and compiled executables that may be associated with the data flow graph application . The map file may describe how a structure of the original flow graph is related to a structure of the refactored flow graph . Therefore iterative tuning of the data flow graph application structure may be obtained before a developer decides to hard code and modify the source code and the compiled executables associated with the data flow graph application.

The processor core is shown including execution logic having a set of execution units through N. Some embodiments may include a number of execution units dedicated to specific functions or sets of functions. Other embodiments may include only one execution unit or one execution unit that can perform a particular function. The illustrated execution logic performs the operations specified by code instructions.

After completion of execution of the operations specified by the code instructions back end logic retires the instructions of the code . In one embodiment the processor core allows out of order execution but requires in order retirement of instructions. Retirement logic may take a variety of forms as known to those of skill in the art e.g. re order buffers or the like . In this manner the processor core is transformed during execution of the code at least in terms of the output generated by the decoder the hardware registers and tables utilized by the register renaming logic and any registers not shown modified by the execution logic .

Although not illustrated in a processing element may include other elements on chip with the processor core . For example a processing element may include memory control logic along with the processor core . The processing element may include I O control logic and or may include I O control logic integrated with memory control logic. The processing element may also include one or more caches.

Referring now to shown is a block diagram of a computing system example in accordance with an embodiment. Shown in is a multiprocessor system that includes a first processing element and a second processing element . While two processing elements and are shown it is to be understood that an embodiment of the system may also include only one such processing element.

The system is illustrated as a point to point interconnect system wherein the first processing element and the second processing element are coupled via a point to point interconnect . It should be understood that any or all of the interconnects illustrated in may be implemented as a multi drop bus rather than point to point interconnect.

As shown in each of processing elements and may be multicore processors including first and second processor cores i.e. processor cores and and processor cores and . Such cores may be configured to execute instruction code in a manner similar to that discussed above in connection with .

Each processing element may include at least one shared cache . The shared cache may store data e.g. instructions that are utilized by one or more components of the processor such as the cores and respectively. For example the shared cache may locally cache data stored in a memory for faster access by components of the processor. In one or more embodiments the shared cache may include one or more mid level caches such as level 2 L2 level 3 L3 level 4 L4 or other levels of cache a last level cache LLC and or combinations thereof.

While shown with only two processing elements it is to be understood that the scope of the embodiments are not so limited. In other embodiments one or more additional processing elements may be present in a given processor. Alternatively one or more of processing elements may be an element other than a processor such as an accelerator or a field programmable gate array. For example additional processing element s may include additional processors s that are the same as a first processor additional processor s that are heterogeneous or asymmetric to processor a first processor accelerators such as e.g. graphics accelerators or digital signal processing DSP units field programmable gate arrays or any other processing element. There can be a variety of differences between the processing elements in terms of a spectrum of metrics of merit including architectural micro architectural thermal power consumption characteristics and the like. These differences may effectively manifest themselves as asymmetry and heterogeneity amongst the processing elements . For at least one embodiment the various processing elements may reside in the same die package.

The first processing element may further include memory controller logic MC and point to point P P interfaces and . Similarly the second processing element may include a MC and P P interfaces and . As shown in MC s and couple the processors to respective memories namely a memory and a memory which may be portions of main memory locally attached to the respective processors. While the MC and is illustrated as integrated into the processing elements for alternative embodiments the MC logic may be discrete logic outside the processing elements rather than integrated therein.

The first processing element and the second processing element may be coupled to an I O subsystem via P P interconnects respectively. As shown in the I O subsystem includes P P interfaces and . Furthermore I O subsystem includes an interface to couple I O subsystem with a high performance graphics engine . In one embodiment bus may be used to couple the graphics engine to the I O subsystem . Alternately a point to point interconnect may couple these components.

In turn I O subsystem may be coupled to a first bus via an interface . In one embodiment the first bus may be a Peripheral Component Interconnect PCI bus or a bus such as a PCI Express bus or another third generation I O interconnect bus although the scope of the embodiments are not so limited.

As shown in various I O devices e.g. cameras sensors may be coupled to the first bus along with a bus bridge which may couple the first bus to a second bus . In one embodiment the second bus may be a low pin count LPC bus. Various devices may be coupled to the second bus including for example a keyboard mouse communication device s and a data storage unit such as a disk drive or other mass storage device which may include code in one embodiment. The illustrated code may implement the method already discussed and may be similar to the code already discussed. Further an audio I O may be coupled to second bus and a battery may supply power to the computing system .

Note that other embodiments are contemplated. For example instead of the point to point architecture of a system may implement a multi drop bus or another such communication topology. Also the elements of may alternatively be partitioned using more or fewer integrated chips than shown in .

Example 1 may include a system to support refactoring comprising a data flow interface to obtain a data flow graph application a first outliner controller to profile the data flow graph application associated with source code using a runtime system and a graph library to obtain an original flow graph an originator controller to create a map file based on one or more refactoring inputs and a second outliner controller to re profile the data flow graph application using the map file and a refactoring graph library to obtain a refactored flow graph.

Example 2 may include the system of Example 1 wherein the data flow graph is re profiled without modifying the source code and one or more compiled executables associated with the data flow application.

Example 3 may include the system of Example 1 wherein the map file is created one or more of automatically or in response to a user refactoring input at runtime.

Example 4 may include the system of Example 1 wherein the originator controller is to use the refactoring graph library to interpret directions given by the map file.

Example 5 may include the system of Example 1 wherein the originator controller is to receive the refactoring inputs via a graphical user interface.

Example 6 may include the system of any one of Examples 1 to 5 wherein the map file is to describe how a structure of the original flow graph is related to a structure of the refactored flow graph and wherein the refactoring inputs are to include one or more of a node aggregation input a buffering node placement input a concurrency input a node limit input or a distributer node placement input.

Example 7 may include an apparatus to refactor a data flow graph application comprising a first outliner to profile a data flow graph application associated with source code using a runtime system and a graph library to obtain an original flow graph an originator to create a map file based on one or more refactoring inputs and a second outliner to re profile the data flow graph application using the map file and a refactoring graph library to obtain a refactored flow graph.

Example 8 may include the apparatus of Example 7 wherein the data flow graph may be re profiled without modifying the source code and one or more compiled executables associated with the data flow application.

Example 9 may include the apparatus of Example 7 wherein the map file may be created one or more of automatically or in response to a user refactoring input at runtime.

Example 10 may include the apparatus of Example 7 wherein the originator may use the refactoring graph library to interpret directions given by the map file.

Example 11 may include the apparatus of Example 7 wherein the originator may receive the refactoring inputs via a graphical user interface.

Example 12 may include the apparatus of any one of Examples 7 to 11 wherein the map file may describe how a structure of the original flow graph may be related to a structure of the refactored flow graph and wherein the refactoring inputs may include one or more of a node aggregation input a buffering node placement input a concurrency input a node limit input or a distributer node placement input.

Example 13 may include a method to refactor data flow graph applications comprising profiling a data flow graph application associated with source code using a runtime system and a graph library to obtain an original flow graph creating a map file based on one or more refactoring inputs and re profiling the data flow graph application using the map file and a refactoring graph library to obtain a refactored flow graph.

Example 14 may include the method of Example 13 wherein the data flow graph application may be re profiled without modifying the source code and one or more compiled executables associated with the data flow graph application.

Example 15 may include the method of Example 13 wherein the runtime system may create the map file one or more of automatically or in response to a user refactoring input at runtime.

Example 16 may include the method of Example 13 wherein creating the map file may include using the refactoring graph library to interpret directions given by the map file.

Example 17 may include the method of Example 13 further including receiving the refactoring inputs via a graphical user interface.

Example 18 may include the method of any one of Examples 13 to 17 wherein the map file may describe how a structure of the original flow graph may be related to a structure of the refactored flow graph and wherein the refactoring inputs may include one or more of a node aggregation input a buffering node placement input a concurrency input a node limit input or a distributer node placement input.

Example 19 may include at least one non transitory computer readable storage medium comprising a set of instructions which when executed by a computing system may cause the computing system to profile a data flow graph application associated with source code using a runtime system and a graph library to obtain an original flow graph create a map file based on one or more refactoring inputs and re profile the data flow graph application using the map file and a refactoring graph library to obtain a refactored flow graph.

Example 20 may include the at least one non transitory computer readable storage medium of Example 19 wherein the data flow graph application is to be re profiled without modifying the source code and one or more compiled executables associated with the data flow graph application.

Example 21 may include the at least one non transitory computer readable storage medium of Example 19 wherein the runtime system is to create the map file one or more of automatically or in response to a user refactoring input at runtime.

Example 22 may include the at least one non transitory computer readable storage medium of Example 19 wherein the instructions when executed may cause the computing system to use the refactoring graph library to interpret directions given by the map file.

Example 23 may include the at least one non transitory computer readable storage medium of Example 19 wherein the instructions when executed may cause the computing system to receive the refactoring inputs via a graphical user interface.

Example 24 may include the at least one non transitory computer readable storage medium of any one of Examples 19 to 23 wherein the map file is to describe how a structure of the original flow graph may be related to a structure of the refactored flow graph and wherein the refactoring inputs are to include one or more of a node aggregation input a buffering node placement input a concurrency input a node limit input or a distributer node placement input.

Example 25 may include an apparatus to refactor a data flow graph application comprising means for performing the method of any one of Examples 13 to 18 in any combination or sub combination thereof.

Embodiments are applicable for use with all types of semiconductor integrated circuit IC chips. Examples of these IC chips include but are not limited to processors controllers chipset components programmable logic arrays memory chips network chips systems on chips SoCs SSD NAND controller ASICs and the like. In addition in some of the drawings signal conductor lines are represented with lines. Some may be different to indicate more constituent signal paths have a number label to indicate a number of constituent signal paths and or have arrows at one or more ends to indicate primary information flow direction. This however should not be construed in a limiting manner. Rather such added detail may be used in connection with one or more exemplary embodiments to facilitate easier understanding of a circuit. Any represented signal lines whether or not having additional information may actually comprise one or more signals that may travel in multiple directions and may be implemented with any suitable type of signal scheme e.g. digital or analog lines implemented with differential pairs optical fiber lines and or single ended lines.

Example sizes models values ranges may have been given although embodiments are not limited to the same. As manufacturing techniques e.g. photolithography mature over time it is expected that devices of smaller size could be manufactured. In addition well known power ground connections to IC chips and other components may or may not be shown within the figures for simplicity of illustration and discussion and so as not to obscure certain aspects of the embodiments. Further arrangements may be shown in block diagram form in order to avoid obscuring embodiments and also in view of the fact that specifics with respect to implementation of such block diagram arrangements are highly dependent upon the platform within which the embodiment is to be implemented i.e. such specifics should be well within purview of one skilled in the art. Where specific details e.g. circuits are set forth in order to describe example embodiments it should be apparent to one skilled in the art that embodiments can be practiced without or with variation of these specific details. The description is thus to be regarded as illustrative instead of limiting.

The term coupled may be used herein to refer to any type of relationship direct or indirect between the components in question and may apply to electrical mechanical fluid optical electromagnetic electromechanical or other connections. In addition the terms first second etc. may be used herein only to facilitate discussion and carry no particular temporal or chronological significance unless otherwise indicated.

As used in this application and in the claims a list of items joined by the term one or more of may mean any combination of the listed terms. For example the phrases one or more of A B or C may mean A B C A and B A and C B and C or A B and C.

Those skilled in the art will appreciate from the foregoing description that the broad techniques of the embodiments can be implemented in a variety of forms. Therefore while the embodiments have been described in connection with particular examples thereof the true scope of the embodiments should not be so limited since other modifications will become apparent to the skilled practitioner upon a study of the drawings specification and the following claims.

