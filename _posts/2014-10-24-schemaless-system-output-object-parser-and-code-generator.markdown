---

title: Schema-less system output object parser and code generator
abstract: A schema-less system output object parser and code generation process analyzes an instance of a response object from a system, such as a storage array, having components of multiple different types, formats and communications protocols, and automatically generates middleware Java source code to translate and communicate requests and responses between the different components and client applications. Output response objects responding to application requests are annotated and parsed, and data structures are created and initialized with keys and key value variables to generate source code to handle live data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09424003&OS=09424003&RS=09424003
owner: EMC Corporation
number: 09424003
owner_city: Hopkinton
owner_country: US
publication_date: 20141024
---
This invention relates generally to middleware tools and processes for computer systems for communicating between disparate applications and systems that utilize different languages and or communications protocols and more particularly to schema less middleware methods and apparatus that automatically parse and generate code to translate and communicate commands and responses between such applications and systems without the necessity of creating individualized logic for each different type of system and application.

Large enterprises typically employ multiple different computer hardware and software platforms comprising different types of computer systems and applications that must interface and communicate with each other. Generally these systems and applications employ different languages and communication protocols and interfacing the systems and applications requires a great deal of custom middleware that must be individualized for each different system and each different application. Creating and maintaining this middleware is a resource intensive operation. Every upgrade or new release of software by manufacturers of such systems and applications generally requires an upgrade or rewrite of corresponding middleware. This may require rewriting a large number of lines of middleware code for example several thousand lines of code which can require significant periods of time and resources. For instance an enterprise may have a distributed storage system comprising a plurality of different types and versions of storage arrays to which its employees and or customers must interface using multiple different types and versions of client applications. Middleware individualized for interfacing each different storage array and or application must be provided and maintained. Every time a change is made in a storage array or a new or changed application is introduced new or changed middleware is required. In addition to the effort required for updating the middleware to accommodate the changes generating or rewriting large amounts of middleware code inevitably introduces programming bugs. Finding and correcting these often requires significant effort.

It is desirable to provide tools and processes for automatically generating and updating middleware code that interfaces disparate computer systems and applications to accommodate changes in such computer systems and applications and it is to these ends that the present invention is directed.

The invention is particularly well adapted to automatically generating middleware software code for interfacing and communicating between multiple disparate storage arrays and client applications and will be described in that context. It will be appreciated however that this is illustrative of only one utility of the invention and that the invention may be employed for generating other types of interfaces and software code for use with other kinds of systems and applications.

As will be described in more detail the invention affords a computer implemented process for creating a language and protocol independent schema less middleware method and system referred to herein as Polyglot that automatically converts commands requests to systems from applications parses response objects from the systems and generates source code to translate and communicate real live commands and responses between different applications and systems without the necessity of creating individualized middleware logic for handling each different system and application. As such the invention obviates the need for developing and maintaining large amounts of customized middleware code that is individualized to particular applications and systems. It reduces the effort required to write middleware from what historically may have taken days or weeks into a matter of hours. Moreover it significantly increases reliability speed and stability by allowing solutions to reach the market quicker and to perform more reliably. Consequently the invention affords the ability to quickly add an update support for a manufacturer s platforms which is often critical and directly affects the number of licenses for the platforms which the manufacturer is able to sell.

As will further be described in more detail the Polyglot method and system of the invention comprises a tool that employs a domain specific language DSL and a Java code generator. It unifies application program interface API consumption rather than the APIs themselves which allows developers to focus on solution specific code instead of writing testing and fixing error prone array output processing code. The invention differs from other tools which require a specific type of data description or schema in order to generate source code by requiring neither a schema nor a formal data exchange format in order to generate source code. Rather it requires only a system output response object to a request or command in order to generate source code. It creates annotated output format AOF files comprising a response object output from a storage array or other system that is annotated in accordance with the invention. The AOF file is processed by the Polyglot tool to generate code describing system objects relationships and parsing behavior. Polyglot DSL defines a set of keywords for annotating captured response objects as well as support for regular expressions and provides custom data types such as Boolean for TRUE FALSE yes no Double Percent Date etc. even for formats such as JSON Java Serial Object Notation for which different tools are available. The invention allows one to provide extensive annotations to handle various response implementations which is especially advantageous for systems that provide a pseudo RESTful API with large data sets having embedded values keyed to a very few keys. More details and advantages of the invention will become apparent from the following description.

As shown in and as will be described in more detail below Polyglot may generate data structures parse the raw array response objects at using a predefined grammar or dialect determined by the attributes of the response object and map the parsed response objects to the data structures at to create the code for the middleware to convert automatically the response object from the storage array format to a format that is appropriate to the client application. Moreover if the storage array comprises multiple different types classes and versions of storage systems and supplies response objects in multiple different formats as is typically the case Polyglot will generate code that will automatically and transparently to the user convert each of the various response objects to an appropriate client application format as will be described more fully below. As such the invention avoids the necessity of creating individualized middleware code to handle multiple different storage array and client application formats. The significance of this aspect of the invention may be appreciated by considering a conventional individualized process required to handle each different response object format from a system such as a storage array as illustrated in .

Referring to the raw array output corresponding to a particular system or component query is captured at . At algorithms are derived and defined to parse generic keys values and relationships from the raw array output. Next at other algorithms are defined to parse specific keys values and relationships from the raw array output. At one or more data structures are defined to represent the components implied by the raw array output. At algorithms are defined to initialize the data structures with the specific keys and values for the array output and at other algorithms are defined to relate the defined data structures to one another. Finally at new code specific to the particular raw array output is incorporated into the middleware to handle that output. These prior art steps typically must all be performed manually for each storage array.

Handling responses from command outputs on an array requires code to perform line by line processing. Generating this code can be a tedious and error prone endeavor due to variations in the command outputs on different arrays having different operating environments and depending upon a customer s environment and the features that are installed. Lines of the array output may contain for example inconsistent keys and values and frequently be without a description of the data or schema.

Unlike the prior art process illustrated in the Polyglot method and system afford a tool that allows interpretation of the output from many different storage arrays or systems. It is schema less in that it does not require a particular schema or formal data exchange format but instead employs a capture annotate and deploy approach where the output response from a storage array or other system is captured the output response is annotated and saved as an AOF file and Java code is generated and deployed to the middleware as a system plug in for instance. This generated code provides both the domain model classes and parsers needed to interpret live data from the storage array or system and the code is easily managed and integrated with an existing build configuration and source code.

Next at the AOF file may be parsed line by line to build an intermediate model comprising a hierarchical data structure. At the intermediate model data structure may be traversed to build a code model. At the code model may be incorporated into the middleware to compile the code. These steps will be described in more detail in connection with . The code will be utilized by the middleware with real live data to provide response objects to the client application request objects.

As shown in capture step may capture a response object from the storage array or other system responding to a request object as from a client or other application that was formatted and transported to the storage array or system from the middleware. The response object may have a JSON format for example and it may be transported using a RESTful protocol on HTTP as indicated at . Depending upon the request object sent to the storage array the response object may include key value pairs child response objects and keys multi value collections among others. Assuming for example that the request object requested the storage array to provide all information on disks the response object would comprise a hierarchical file structure containing multiple keys and value pairs and multiple parent child relationships.

As an example a snippet of JSON code corresponding to a portion of a possible raw response object to such a request object is illustrated at below the diagrammatic illustration of the response object . As shown the response object may include key fields such as a date field updated and a corresponding data value indicating when the file was updated . The response may also have content fields including for example names resource information id size operationalStatus and whether it needsReplacement etc. with their corresponding key values.

Under the annotate step of an annotated snippet of an AOF file corresponding to a single response object instance of the JSON snippet of the raw array response object is illustrated. As shown the actual key values in the raw response object snippet have been replaced in the annotated snippet of the AOF file with pre defined DSL keywords comprising key value variables. For instance the actual value of the date for the updated key in the raw response object has been replaced with the DSL key value variable Date . Likewise key values corresponding to keys such as name id etc. that have strings as values have been replaced with the DSL keyword variable String to indicate that the key value of the corresponding key is a string. Similarly other key values have been replaced with DSL key word variables such as Long Integer Boolean etc. When the AOF file is compiled at to generate code the compiled code will include the DSL key value variables as shown in the snippet of compiled Java code for the AOF file shown in . Accordingly when the compiled code is executed on the real live data for each instance of disk in the response object the corresponding actual key values for each disk instance will be substituted for the key value variables in the response objects returned to the middleware. Thus the compiled code comprises generic source code that is incorporated into the middleware and it is applicable to any disk in the storage array. The middleware will return a response object to an application request for disk information with the appropriate information for all disks in the storage array. The code and the data structures in an intermediate model to be described can handle multiple instances of response object outputs without the necessity of regenerating the code for each different output and or output protocol as will be described in connection with . For large storage arrays comprising thousands of disks and enterprises having multiple different applications this saves thousands of lines of code individualized for a particular type of disk and greatly reduces the burden of maintaining the code to accommodate changes and upgrades.

Response objects from the storage arrays having the appropriate formats for the storage arrays and the request objects will be returned to the middleware instances and with the response objects will be formatted in accordance with a client application defined format and returned to the client application . Each middleware instance may be appropriate to a particular type or class of storage array. Each middleware instance also will be aware of which storage array it is communicating with because it must first be authenticated with that array. Accordingly when the middleware receives a client application request the middleware instances format that request according to the classes of storage arrays that are present and communicates the formatted requests to the corresponding storage arrays. Each middleware instance may have libraries which are used to format the requests for the appropriate protocols.

Generally client applications may be similar and may have similar protocols. Many middleware instances may communicate with a number of different client applications using for example a code layer between each middleware instance and the client application. In some embodiments different interface code may be generated for different client applications and may be stored in the middleware instances and used as required.

The middleware instances may contain Java code a domain model and output parsers to process the response objects in the storage arrays and provide AOF files and associated dialects to the Polyglot generated code . The Polyglot code may comprise a JSON parser an SMIS parser and a CLI parser among others as are appropriate for the different protocols of the response objects from the storage arrays. Since the different storage arrays may have different protocols the middleware instances have to deal with all of the different protocols. The Polyglot code serves as a translator of all of the response objects incoming to the middleware instances from the storage arrays to translate the incoming protocols to Java code. Accordingly the middleware is advantageously not required to handle all the various protocols from the storage arrays but only the translated Java code. This is a significant advantage of the invention in that it facilitates handling storage arrays or other systems having many different types of protocols even proprietary protocols without the necessity of writing code for different middleware instances. Rather the invention enables the middleware to communicate directly with a proprietary storage array as if it had a native Java or other language e.g. C Python etc. library.

Referring to the figure an AOF file and a dialect may be input to a parser . Each line of annotated output from the parser is read at and a parse tree is built at . Upon traversing the parse tree if a root node is encountered a class may be created and stored in the intermediate model. If a key value pair is encountered a corresponding field may be added to an existing class or to an existing parse table in the intermediate model. This means that each line of the file will be read for key word variables such as Date String etc. and separated out so that rules may be applied to each line. The parse tree may be traversed at and each node of the tree may be examined at to determine whether the node is an index node a root node or a basic key value pair. If the node represents a basic key value pair at a key value pair is created at . Otherwise the process returns to the examine node step after creating the key value pair at . The process then determines at whether a parse table exists. If a parse table already exists the key value pair may be added to the parse table at . Otherwise if at a parse table does not exist one may be created at and the key value pair added to the parse table at . At a determination may be made as to whether that node was the last node. If not the process returns to the traversed parse tree step at and examines another node at .

If the node examined at is a root node a root class may be created at and added to an intermediate model at . The intermediate model comprises a data structure that will hold the parsed lines of the input AOF file. If instead the node examined at is an index node an index may be created at and at a determination may be made as to whether an index table exists. If not an index table is created at and added to the intermediate model . Otherwise if an index table already exists the index data may be added to the existing index table at and the process loops back at to repeat and examine the next node of the parse tree. Once the last node of the parse tree has been examined the process proceeds to the step of generating a code model at . This step will be described below in connection with .

If the next input line has children the process proceeds to step do process children which analyzes the input line and generates as appropriate type classes at key classes at and indices classes at . For instance for a parent disk class a disk type class will be created at and at the keys of the disk will be stored in the keys class for mapping the keys to values. Similarly a disk class may have indices for multiple disks. At keys to value fields are generated and at indices to value fields are generated. For instance a disk may have a type class and the keys would be the enumeration of the types of disk classes and possibly disk indices for specific disks. If a disk has a serial number for example the disk class may generate a function get serial number for the disk. There will be a key value variable for serial number inside of disk that the process will inspect to obtain the key and return the value. There may be a collection class that will be determined by the disk class. From step the process may proceed to step generate get of members which generates collection members and maps the operational status key value fields and indices for example for a particular disk to the collection members. This step may also obtain multiple values for a particular collection as well as the children for particular type classes.

If at step the input line is an array of value variables the process may proceed to step do array of values to get the class at and map the value variables to the class if it exists. If the class exists the process proceeds to step . Otherwise it returns to the next input line at . Following step the process proceeds to step at which collection members are generated. This step generates the code for multi value fields.

The generate parse method steps shown at illustrate parsing of the output from the storage arrays. Every type class may have a function called parse that accepts a subset of the output. There may be multiple disks for example corresponding to the subset of the response object. A new disk object would be initialized for a disk. At step the parse method divides the output from the array by indexed lines so that they correspond to a particular disk. This takes the output response from the array and initializes the data structure for the particular disk. The process matches parse keys to lines at to new objects at to parse objects at and to parse key values at . It parses each input line and determines whether keys in that line correspond to a particular mapping and stores the values. These parse steps add content to the parse method. At the generate parse observers step operates to obtain multiple values for a collection. It provides information for key events that may occur. Next the method returns to to get the next line and repeats the process. If there is an array of values for instance it takes the next one and repeats. If there are no additional lines the process finishes at .

At each input line there is a context. It is known whether the line is an object of a child or is within a disk class for example. As the process proceeds it generates code that can be applied to raw output from the storage arrays. Since the raw output is annotated it is known how the raw output will look. It is therefore known how to handle the live output from the storage array so that the appropriate code may be generated. The generated code is code that did not exist previously and it can be reused and regenerated many times as the response objects change. Essentially the code defines specific instances of types that may occur in a real system and serves as a dictionary that indicates how to analyze and translate different operations.

A significant aspect of the invention is that it generates generic source code for all the various fields of the response object such as for disks for instance and provides relevant data structures and the code that is required to initialize data structures to handle live data. The code and the data structures can handle multiple instances of response object outputs without the necessity of regenerating the code for each different output and or output protocol. Moreover the invention easily handles variations as the system output response object changes. Accordingly the invention eliminates the need for generating specific code to handle specific instances of system output and avoids the necessity of maintaining multiple different variations of such specific code. Thus the invention substantially eliminates and reduces the resources and effort previously required to provide individualized middleware to handle different systems and applications.

While the foregoing has been with reference to particular embodiments of the invention it will be appreciated by those skilled in the art that changes may be made to these embodiments without departing from the spirit and principles of the invention as defined by the appended claims.

