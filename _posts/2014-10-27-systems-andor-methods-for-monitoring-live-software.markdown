---

title: Systems and/or methods for monitoring live software
abstract: Certain example embodiments described herein relate to techniques for observing an internal state of a software application executing in a runtime environment. For instance, certain example embodiments include traversing a structure of multiple live data objects in the executing software application; generating a graph of shadow data objects based on the traversing, with each shadow data object of the graph corresponding to a live data object of the executing software application; and providing access to the generated shadow graph via a user interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465723&OS=09465723&RS=09465723
owner: Software AG USA, Inc.
number: 09465723
owner_city: Reston
owner_country: US
publication_date: 20141027
---
Certain example embodiments described herein relate to techniques for computer software processing. More particularly certain example embodiments relate to techniques for monitoring the state of live software.

Any running computer program e.g. software system at any point in time can be represented as a directed graph of Abstract Data Types ADT and the connections between them. As is known an Abstract Data Type is a complex data type that includes both data and references to other instances of abstract data types. During the runtime of a computer program it is often helpful to be able to examine the state of the various ADTs and the relationships between them for various purposes such as monitoring debugging and performance analysis. Exposing this information to an entity outside of the system itself perhaps through a network or Graphical User Interface GUI or within the system itself as a feedback mechanism may be useful.

For production software systems there are two conventional approaches to monitoring executing software. Full debugging versions of software can be run at the cost of significant performance degradation as well as sometimes arbitrary changes in behavior. Alternatively custom monitoring specific to the computer program under inspection can be written. This is understandably an inconsistent approach e.g. due to code added to the program and time consuming process.

Many popular modern computer programming languages such as JAVA PERL C PYTHON etc. are interpreted languages meaning that they run within a well defined runtime environment. One of the advantages of interpreted languages is that the runtime environments they run in provide support for the examination of code while the program is running e.g. through a concept referred to as reflection or introspection . Embodiments disclosed herein use capabilities such as reflection and introspection to implement novel techniques for monitoring the live structure of running programs.

An example embodiment provides a system for observing an internal state of a software application executing in a runtime environment. The system comprises processing resources including memory and at least one processor. The processing resources are configured to perform operations comprising traversing a structure of a plurality of live data objects in the software application executing in the runtime environment and generating a graph of shadow data objects based on the traversing each shadow data object of the graph corresponding to a live data object of the executing software application. The operations also include providing access to the generated shadow graph via a user interface.

In certain example embodiments the at least one processor is further configured to perform the generating including forming each shadow object to include metadata associated with and a pointer to a respective corresponding live data object.

The metadata may include aspects of naming of the corresponding live data object and or identification of aspects of packaging of the corresponding live data object.

Each shadow data object in the graph may include a marking identifying whether the shadow object is exposable to the user interface. The providing access may include providing access to attributes of only shadow data objects marked as being exposable to the user interface.

Certain example embodiments include performing the traversing by operations including accessing attributes of a live data object of the plurality of live data objects and determining based on the accessed attributes whether all connections to child live data objects of the live data object are traversable. The operations may also include based on the determining a if all connections are traversable traversing one or more child data objects of the live data object and b if not all connections are traversable traversing only child data objects of the live data object marked by a specific one of said attributes as being traversable.

Performing the generating may include adding to the graph shadow data objects corresponding to a particular live data object only when the particular data object has been traversed.

Certain example embodiments include performing the providing access by operations including accessing a shadow data object in the graph and determining based on a pre specified listing of non exposable objects or an attribute of the shadow data object whether the shadow data object is exposable. The operations for performing the providing access may also include displaying aspects of the shadow data object on the user interface only if the shadow data object is based on the determining exposable.

According to certain embodiments the processing resources may be configured to control the system to perform operations comprising updating the generated graph when a change occurs in the plurality of live data objects in real time.

In certain example embodiments the updating includes performing the traversing and the generating at predetermined time intervals.

According to certain example embodiments the at least one processor is further configured to control the system to perform operations comprising receiving a query via the user interface the query being associated with a shadow data object in the graph accessing by following a pointer in the shadow data object a corresponding live data object and outputting information regarding attributes of the accessed live data object via the user interface.

The at least one processor may be further configured to control the system to perform operations comprising causing aspects of a portion of the graph to be displayed via the user interface. The query may be associated with at least some of the displayed aspects.

An example method embodiment provides for observing an internal state of a software application executing in a runtime environment using at least one processor. The example method comprises traversing a structure of a plurality of live data objects in the software application executing in the runtime environment generating a graph of shadow data objects based on the traversing each shadow data object of the graph corresponding to a live data object of the executing software application and providing access to the generated shadow graph via a user interface.

The generating a graph of shadow data objects may include forming each shadow object to include metadata associated with and a pointer to a respective corresponding live data object.

Each shadow data object in the graph may include a marking identifying whether or not the shadow object is exposable to the user interface and the providing access may include providing access to attributes of only shadow data objects marked as being exposable to the user interface.

The traversing a structure of a plurality of live data objects may include accessing attributes of a live data object of the plurality of live data objects and determining based on the accessed attributes whether or not all connections to child live data objects of the live data object are traversable. The traversing a structure of a plurality of live data objects may also include based on the determining a if all connections are traversable traversing one or more child data objects of the live data object and b if not all connections are traversable traversing only child data objects of the live data object marked by a specific one of said attributes as being traversable.

The providing access may include accessing a shadow data object in the graph and determining based on a pre specified listing of non exposable objects or an attribute of the shadow data object whether or not the shadow data object is exposable. The traversing a structure of a plurality of live data objects may also include displaying aspects of the shadow data object on the user interface only if the shadow data object is based on the determining exposable.

Another example embodiment provides a non transitory computer readable storage medium having stored thereon computer program instructions that when executed by a processor of computer cause the computer to perform operations comprising traversing a structure of a plurality of live data objects in a software application executing in a runtime environment generating a graph of shadow data objects based on the traversing each shadow data object of the graph corresponding to a live data object of the executing software application and providing access to the generated shadow graph via a user interface in enabling observation of an internal state of the software application executing in the runtime environment.

In certain example non transitory computer readable medium embodiments generating a graph of shadow data objects may include forming each shadow object to include metadata associated with and a pointer to a respective corresponding live data object.

In certain example non transitory computer readable medium embodiments each shadow data object in the graph may include a marking identifying whether the shadow object is exposable to the user interface and wherein the providing access includes providing access to attributes of only shadow data objects marked as being exposable to the user interface.

These aspects features and example embodiments may be used separately and or applied in various combinations to achieve yet further embodiments of this invention.

Certain example embodiments relate to techniques that provide for monitoring the structure and state of a live running program in a way that adds little or no overhead to the runtime environment. A live running program also interchangeably live program running program executing program executing software is a program that is currently being executed by one or more processors of a computer system. The state of a live program includes the state of its objects and the interrelationships between those objects. Certain example embodiments may apply to any environment in which live running software programs are monitored. Certain example embodiments may be particularly beneficial in managed runtime environments executing program code written in interpreted programming languages. It will be appreciated however that embodiments are not limited to such programming languages and or runtime environments.

Embodiments overcome numerous disadvantages of conventional debugging and or introspection techniques and provide for satisfying requirements for monitoring a running software program without significantly adding to its overhead providing the user with a view that can be customized according to the user s specific monitoring needs satisfying requirements for preventing the exposure of certain portions of the executing program and or data structures and for dynamically updating the user s view of the running program as the execution continues.

Certain example embodiments can have broad utility across all kinds of complex processing systems such as for example in health and status monitoring performance analysis speed of development completeness of the solution etc.

As noted above some runtime environments provide introspection and or reflection capabilities. These introspection and or reflection runtime capabilities are used in embodiments to expose the live structure of a running program and also the state of each of the ADTs within the program through a separate shadow graph. This enables deep inspection of a running system while having little or no impact on runtime performance. Furthermore the amount of the full structure exposed could be controlled in certain example embodiments at the source code level by allowing support for explicit and implicit tree definition and by allowing the marking of certain structures as uninteresting or invisible.

Conventional techniques for monitoring live software include software debuggers and the JAVA language s built in JAVA Management Extensions JMX . JMX has been ported to a variety of other languages in order to take advantages of its wealth of client applications e.g. PyMX for PYTHON NetMX for C .NET etc. .

Software debuggers of course allow the entirety of a running program to be examined although often only if the program in question in stopped. Moreover software debuggers impose a heavy cost in terms of runtime performance and can sometimes cause behavioral changes in the execution of a program. In addition many debuggers are often suited for use only by users with a high level of understanding as to how the inspected program is designed and implemented. One of the most sophisticated debugging environments is JAVA Platform Debugger Architecture by ORACLE which defines components within the runtime environment the communications protocol to clients and the debugger front end which must be implemented.

As alluded to above JMX is a JAVA language specification that has been co opted for various other languages. It specifies the communications protocol used to interrogate and manipulate the JMX MBeans software objects inside the client object . In the program MBeans are defined at compile time and instantiated at runtime. MBeans publish a set of attributes which are both readable and optionally writeable as well as an optional set of operations. The MBeans are generally defined as an interface with simple value data types numbers strings etc. accessible via naming convention or more complicated configuration . MBeans do not provide the means to traverse connections between data structures and indeed are separate constructs that may not have a one to one correspondence with live data structures.

Unfortunately many types of conventional debugging are particularly ill suited to examining a running production system as debugging live software systems oftentimes incurs heavy penalties. First there is significant cost to execution time when running in the debugger. Second debuggers provide no way to remove portions of the running program from examination which can be an issue in an environment with security concerns. Third a debugger is not intended for live production usage but rather for discovering problems in the running of program code. Indeed much of debugging is more concerned with program instruction execution than state examination. These issues combine to remove debugging from many serious discussions of examining live software systems.

Furthermore although JMX MBeans in many aspects provides an adequate technique for monitoring some aspects in a live software system there nonetheless are several limitations to JMX MBeans. One limitation is that respective MBeans must be crafted for each collection of data that needs to be published.

For example consider a software data structure such as Class Vehicle Integer numberOfWheels Integer numberOfDoors String color Integer getNumberOfWheels . . . Integer getNumberOfDoors . . . String getColor . By publishing an object with known method conventions getXXX in this example an object named Vehicle would be published with three attributes available for reading. If corresponding setXXX methods are defined in the class updating of status is also supported in JMX MBeans.

This is a useful approach to publishing the status of specific objects but it has many limitations such as for example limited scale limited types of relations that can be monitored providing only for publishing static structures etc. With respect to the JMX limitations in scale if a running system contains thousands of instances of the Vehicle objects it is not possible to publish them all. In general JMX is best suited for global health and status objects that report general state within the system. Additionally since JMX MBeans are designed primarily to read status of objects they are not well suited to traversing connections between software objects.

JMX also depends on registering JMX MBean objects with a runtime environment server and is not amenable to rapid changes. With respect to the limited number of relations JMX does not provide support for traversing relationships between objects. For example if the Vehicle class also had an Owner field which in turn contained Name and Address objects JMX would allow one to retrieve those objects if and only if they were available directly at the Vehicle level.

Further complex data types are hard to publish as attributes because the client side generally needs access to the same compiled classes in order to preset those classes on the client. This is also problematic because for more complicated objects where shipping the entire representation of a large complex object is not feasible. Moreover JMX MBeans are primarily static and the JMX specification does not provide for publishing a hierarchy of structures.

As noted above however certain example embodiments provide techniques for monitoring live software programs while overcoming the above described and or other weaknesses of the conventional techniques discussed above. In certain example embodiments a shadow graph representing the state of live objects objects in the live software and relationships between live objects is constructed and an interface is provided for accessing the shadow graph or portions thereof for obtaining information regarding the live objects. The shadow graph may be formed as a tree data structure.

Certain example embodiments identify a set of one or more root objects of the live software. Once these root objects are identified each object e.g. ADT is traversed in order to construct the shadow graph. is an example live object graph . Live object graph is rooted at object and includes a complex object . Complex object includes a plurality of objects. illustrates the shadow graph corresponding to the live object graph of and the relationship between the objects represented as nodes in each graph. The shadow graph includes a plurality of shadow objects with each shadow object corresponding to a live object that has been traversed in the live object graph. Each dotted line arrow such as dotted line arrow indicates that a shadow object e.g. at the tail end of the dotted line arrow is determined based on a corresponding live object e.g. at the head end of the dotted line arrow .

In certain example embodiments each instance object of an ADT may be traversed in one of two ways. If only some but not all of the connections are explicitly marked as traversable or connected then only those connections that are explicitly marked are followed e.g. traversed to objects referenced by them. If no connections in the ADT are marked as traversable or connected then all object references to other ADTs will be followed. As this traversal takes place because live software object graphs often include cyclic aspects some technique e.g. a parallel graph may be utilized to handle cases such as recursion.

Additionally certain example embodiments may provide for excluding certain objects and or object relationships from being exposed for monitoring. For example certain objects may have been marked as irrelevant or may have been found either by data type or instance in a list of pre specified blacklisted objects. The construction of the shadow graph is such that no corresponding shadow object is added for live objects specifically marked as excluded from monitoring. In this manner the programmer can exercise control over the subset of the complete graph e.g. representation of the complete live software program that is exposed. The capability to mask the exposure of excessively numerous but not uninteresting portions of the object graph or protected and or sensitive parts of the data may be provided e.g. one might keep social security numbers and or other Personal Identification information from being exposed by the graph . In live node the final live object in the live object graph represents an example node that is marked as irrelevant. Consequently as shown in no shadow node corresponding to live node is added in the shadow graph .

The shadow graph produced by the traversal is a graph comprising metadata information such as packaging information naming etc. for objects in the live object graph. Each object in the shadow graph may also include a pointer to a corresponding live object. The shadow graph can then be used for lightweight navigation of the live object graph without actually touching the live objects. The term touching e.g. programmatically accessing is used herein to indicate that it is not necessary to access live objects in the live object graph during traversal of the shadow graph and or shadow objects in a manner that leads to the access to the live objects in memory being restricted in any way to other components. For example access to the live objects to other components may be restricted when a particular live object or part thereof is locked for read and or write by other components due to being accessed by the traversing program component through a corresponding shadow object.

When the initial traversal of the live object graph is done it still remains subject to mutations. Several approaches are available to track mutations in the live object tree. First the shadow tree could just be recalculated based on a timed interval. Such timed recalculation might prove expensive or if the subset of the live objects was of reasonable size might be reasonable. Alternatively as mutations to the live graph happen modifications to the shadow graph could be made as well through calls such as for example connect and disconnect calls.

Once the shadow graph is created it can be used to answer a variety of questions. For example any node in the shadow graph can be used to query its corresponding live object for state information. Using the earlier Vehicle example any Vehicle object could be interrogated for the number of wheels or doors or the name of the color. In certain example embodiments any primitive data type that is available for reflection introspection in the implementing language could be easily inspected.

Second in certain example embodiments relationships between complex objects e.g. ADTs can be examined. For example by examining the state of an object and then choosing to descend into its children a process that is in some aspects like debugging could occur for a live running production system. This is different from the JMX design where JMX is designed to move copies of objects across a network barrier and reconstitutes them for inspection. In certain example embodiments the capability is provided to move around the graph in place.

Certain example embodiments may be implemented in a software environment with a minimal amount of reflection introspection capabilities. An environment that provides a a mechanism to enumerate some combination of methods and or variables for each ADT and b a mechanism to invoke methods on an object arbitrarily in a single threaded use case or to simply read data values within ADTs may be used in certain example embodiments. For instance in JAVA the Reflection Package provides a rich set of features to manipulate Object Class Method and Field objects. Other managed runtime languages such as C RUBY and PYTHON provide similar capabilities.

In unmanaged environments such as C or C certain example embodiments may add to objects explicit support to simulate reflection behavior. Such support for example could be implemented as a support library of functions.

Although many of the described embodiments use JAVA conventions for convenience the teachings herein can be extended as needed for other languages and or environments.

The traversal to build the shadow graph involves initially notating and traversing a root object. is a sample computer program code structure for initializing the shadow graph.

As represented in the computer program code structure the main entry point of the program creates a main object as is the normal case for an object oriented program. This main object is then marked as a root by the call to the registerShadow method. Then program execution proceeds as normal.

The shadow graph generation itself can be implemented for example in one of several ways e.g. through complete traversal through lazy traversal etc. In order to perform a complete traversal for example the registerShadow call shown in code structure can be made on a pre allocated shadowGraph object e.g. shadowGraph object might be allocated globally might be passed in etc .

Program code structure represents a depth first traversal of all connected objects in the live object graph. A supporting structure is implied by the seenBefore . . . construct which determines whether the particular object being traversed has been previously encountered. The check whether an object has been previously encountered helps ensure that any single object is traversed only once during the traversal of the entire live object graph. The check can be implemented in a variety of ways depending on the language and runtime environment. In certain example embodiments the live objects themselves e.g. an attribute of each object may represent seen flags to be stored directly or a table of previously seen objects can be kept.

Next the program code structure includes a shouldBeVisible next construct that determines for each object being traversed whether it can be exposed e.g. made visible to a user e.g. a user who is monitoring the live state of the corresponding computer program . The check for the visibility of objects is an opportunity for specific objects to be blacklisted by type or instance. For example in JAVA an annotation could be used to mark classes as irrelevant. In this case the traversal would stop at this object and any below it that are reached by traversing its connections . Certain example embodiments may enable the visibility to be allowed or disallowed at other levels of granularity than at the object level. For example certain example embodiments may allow for certain connections of an object to be marked as not visible e.g. irrelevant . Some other embodiments may enable groups of objects to be marked as not visible. For example many modern languages have some sort of packaging structure e.g. packages in JAVA modules in PYTHON etc. and certain example embodiments may enable the marking of certain packages as blacklisted for visibility.

Returning to the program code structure assuming a specific live object should be visible the next step may be to create and record a shadow object also referred to as shadow node corresponding to the live object. This shadow object may record a pointer to the live object as well as various metadata. The amount and type of metadata can be specific to the language and or the runtime environment in use but may include aspects such as timestamp object size depth at which the object was found etc. The shadow object would then be recorded in the shadowGraph repository as a node connected to the rest of the shadow graph.

After the shadow object is created the live object may be tested for traversability as for example represented by the isTraversible . . . construct in program code listing . For every method and attribute the object contains some or all may be marked as non traversable. In certain example embodiments this marking may be performed via explicit method calls e.g. in C C Annotations e.g. JAVA C or other language specific methods. In each case the idea is to be able mark traversability at the class instance method and field level so that fine grain control over the graph construction is achieved in the source code directly. If some subset of all connected children objects is traversable those children are pushed into the stack.

Note that there are a multitude of ways traversability could be captured such as for example a only explicitly marked child objects may be traversed b all unmarked objects may be traversed c only child objects of a certain type may be traversed d only fields of a certain scope are traversable and e only methods confirming of a certain naming convention are traversable. Certain example embodiments may employ one or more techniques that are different to those listed above.

After determining the next object to be traversed as for example represented in the while . . . construct in program code structure the process continues until there are no more objects to process.

After entering process at step an empty stack is initialized. Initializing the stack may include populating the stack with a root object. A root object may be identified by analyzing the code. Any known technique for identifying a root object may be used in this operation. A root object represents the root in a live software graph of objects that are of interest to the user. In certain example embodiments multiple roots objects may be identified in the same running program.

After the stack is initialized steps are then performed until the stack is determined to be empty. In brief steps perform the traversal of the live graph and the generation of the corresponding shadow graph.

At step the stack is checked to see if it is empty. An empty stack indicates that the live graph has been completely traversed from the starting root object. If the stack is found to be empty a complete shadow graph has been formed and process may be ended.

At step it is determined whether the popped object has been already visited during the traversal e.g. seenBefore . . . construct in code structure . The determination may be based on an attribute value of the popped object or a separately maintained list of already visited objects.

If the popped object is determined to have been already visited then the popped object is discarded e.g. ignored or not further considered for adding a corresponding object to the shadow graph and process returns to step . If at step it is determined that the popped object has not been visited before then process proceeds to step .

At step a determination is made as to whether the popped object is allowed to be visible e.g. shouldBeVisible . . . construct in code structure . The determination of visibility may be based on one or more attributes of the popped object or on a separately maintained list e.g. a blacklist of objects types of objects and or groups of objects that are not to be exposed to users.

If it is determined at step that the popped object is not allowed to be visible then the popped object is discarded e.g. ignored or not further considered for adding a corresponding object to the shadow graph and process returns to step . If at step it is determined that the popped object can be visible then process proceeds to step .

At step a shadow object corresponding to the popped node is added to the shadow graph. As noted above the shadow object may include metadata with respect to selected aspects of the popped object. The shadow object may also include a pointer to the popped object in the live object graph. Any suitable known technique for adding a nodes to a graph may be used for adding the shadow object to the shadow graph.

After the shadow object is added a determination is made as to whether the popped object should be traversed. In the case that the popped node has no child connections process returns to step . The determination of whether to traverse the popped object may be based on one or more attributes of the popped object. For example in certain example embodiments if the popped object has selectively marked certain of the connections e.g. child objects as being traversable then the popped node can be traversed and only the connections so marked will be traversed. If one or more child connections exist but none are specifically marked for traversal all the child connections may be traversed. If the popped node is traversable then at step child object s are extracted and at step the extracted child object s is are added to the stack. After step process proceeds to step .

The above description of process represents the generation of a shadow graph corresponding to one root node. Multiple shadow graphs corresponding to respective root nodes may be constructed in certain example embodiments e.g. depending on the live runtime environment being monitored. It should be noted that process may be performed in certain example embodiments with one or more operations in addition to or in place of steps and that one or more of steps may be performed in an order that is different from that shown in .

The shadow graph object itself is the entry point for walking and interrogating the live object graph. In certain example embodiments at a minimum the shadow graph object provides methods functions such as for example a getRootNode for returning the root shadow node of the live object tree b getParentNode for returning the parent shadow node or null if no parent exists e.g. root c getChildrenOf node for returning a set of children traversable from the specified node or an empty set if the node is not traversable d getAttributesOf node for returning a set of NodeAttribute objects which may for example contain the name of the attribute and such useful metadata such as whether it came from a field or method the attributes type etc. e getAttributeValue node nodeAttribute for returning the value of a specific attribute in the live object and or the like. The returning the value of attribute in the live object may be performed in a number of ways e.g. depending on the platform. For example the NodeAttribtue objects might themselves provide access.

As noted above instead of the depth first traversal illustrated in a lazy traversal may be performed to generate the shadow graph. illustrate a lazy traversal. In the lazy traversal case the shadow graph itself functions as the stack. For example upon each call to getChildrenOf in the shadow graph object processing corresponding to the inside of the while loop in code structure would be executed if needed. Thus getChildrenOf may include for example a program code structure shown in .

In code structure the getChildrenOf method uses a supporting data structure to map nodes to child objects. This implementation may be lighter than the depth first traversal shown in in terms of computation cost initially by deferring the tree construction until the data is requested at the added expense of having to do the traversal when requested.

At step a determination is made as to whether the node being currently processed has children that have already been identified and added to the repository. If the children are already in the repository e.g. haveChildrenAlready returns true in code structure then those children are returned at step e.g. childRepository.get in code structure and process is exited. If a determination is made at step that the children are not already in the repository process proceeds to step .

At step a determination is made as to whether the node being currently processed is traversable e.g. isTraversable in code structure . If the node does not have children then at step no children are returned and process is exited. If there is at least one child node process proceeds to step where child object s is are extracted e.g. extractChildObjects in code structure . At step the child object s is are added to the repository and the child objects are returned at step before exiting the process.

It should be noted that process may be performed in some embodiments with one or more operations in addition to or in place of steps and that one or more of steps may be performed in an order that is different from that shown in .

In certain example embodiments a variation of process may not use the supporting data structure to save children at all and perform every interrogation live. This technique may have additional computational overhead compared to process but has an advantage of being lighter on memory.

In yet other embodiments a mix of two or more of processes and or variants thereof may be performed. Depending on the system under inspection any of these three tree building methods could be optimal depending on the size rate of change complexity of the live object graph etc.

Certain example embodiments include user interfaces e.g. client frontends through which the information regarding the live software programs are presented to one or more users interactively. Once the shadow tree is constructed there are many ways by which the information can be usefully exposed to a user such as for example by logging to a file system exposing through an in process user interface being made available through a network protocol like REST which is an HTTP based approach to providing simple remote access to systems etc.

The GUI initially upon invocation may display the root assuming a single root for this case of the shadow graph. No parent is displayed for the root. It would however display the current root object e.g. in the form of an object representing a toolbox . The displayed root object would also have a user interface object for choosing to navigate to children such as a pulldown e.g. with the choices expanded for clarity here .

A method such as program code structure shown in may be used for updating the user interface. Program code structure can be called in relation to each object displayed on the user interface and populates a user interface with attributes and child objects of the current node.

A method such as program code structure shown in may be used to fetch the root and its information. Basically program code can be used for obtaining the root object of the shadow graph and for updating the user interface with the obtained root object.

Next suppose the user wanted to further inspect a HandTool object not shown in reachable from the root Toolbox object e.g. in . By selecting a Hammer HandTool object for example in a displayed portion not shown of the shadow graph the pseudocode structure shown in may be executed.

The display may enable data entry via any means such as for example by keyboard mouse touchscreen etc. Pulldown menus and or the like may be used to make the data entry process easier and more accurate.

In it can be seen that the HandTool has some primitive inspectable types such as a name and a sizeInPounds. Being able to walk an object graph in the manner described above and inspect live data with little overhead while keeping the construction of the graph under control at a programmatic level as provided for by certain example embodiments can be of great benefit.

In this regard there are many real world usages for a system that allows for the exposure of deep information in a running system with minimal overhead. In one example application in a communications system such as a cell phone switching system a purpose built user interface could use certain example embodiments described herein to monitor the contents of the in progress call tables under load. Such monitoring could be very useful for debugging a resource leak that only evidenced under real world load where an actual debugger would be too intrusive and would probably need recompilation of the process. And because of the dynamic nature of such a system the call tables could be drilled into by traversal to expose interrogate and enable analysis of the really important data without disrupting the system.

Many systems and or applications that cannot afford downtime for debugging or extensive overhead because of performance constraints also may be good candidates for the example techniques set forth herein. For instance any real time high performance system that evidences a software bug that only shows up under load could be a good candidate.

Certain example embodiments can also operate as a dynamic statistics portal. For instance consider a customer call center application. A monitoring system could be implemented that uses the shadow graph to monitor the call rates in aggregate until a certain condition is met such as the call rate passing a certain threshold. Above the threshold the monitoring system could escalate by sending an email or text messages that the system is experiencing load. Further it could reach into the call records to ascertain the types of calls being fielded and automatically categorize them and email or text message them to the on call staff. It will be appreciated that there is tiny overhead until the anomalous condition is noted then the warning software can reach deep into the system and examine call records in a focused manner providing useful information without disruptive overhead.

Although certain example embodiments have been described in connection with JAVA and like languages it will be appreciated that these languages are merely examples may or may not necessarily correspond to a programming language that is used or is to be used in a real system or all embodiments of this invention. Instead it will be appreciated that the example techniques described herein are not dependent on any specific programming language and or runtime environment.

A description of certain terms is provided below for aiding in the understanding of how certain example embodiments may operate. However it is to be understood that the following descriptions are provided by way of example for explanatory purposes and should not be construed as being limiting on the claims unless expressly noted.

It will be appreciated that as used herein the terms system subsystem service programmed logic circuitry and the like may be implemented as any suitable combination of software hardware firmware and or the like. It also will be appreciated that the storage locations herein may be any suitable combination of disk drive devices memory locations solid state drives CD ROMs DVDs tape backups storage area network SAN systems and or any other appropriate tangible computer readable storage medium. It also will be appreciated that the techniques described herein may be accomplished by having a processor e.g. central processing unit CPU or specialized processor execute instructions that may be tangibly stored on a computer readable storage medium. In this regard the system under test may be performed e.g. executed from binary code or interpreted from a higher level language in connection with a computer system including at least one processor and a memory and the program code structures disclosed herein may be executed on the same computer systems and or different computer systems that are operably connected to and able to gather information from those computer systems. Cloud based storage and or execution also is included.

While the invention has been described in connection with what is presently considered to be the most practical and preferred embodiment it is to be understood that the invention is not to be limited to the disclosed embodiment but on the contrary is intended to cover various modifications and equivalent arrangements included within the spirit and scope of the appended claims.

