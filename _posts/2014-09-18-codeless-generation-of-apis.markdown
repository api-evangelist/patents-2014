---

title: Codeless generation of APIs
abstract: Some embodiments provide method of generating application programming interfaces (APIs) in a codeless manner. The method generates a schema description of a data storage with which an API-accessible object may have to exchange data (e.g., from which the object may have to read data and/or to which the object may have to write data) to process an API request during the execution of an application. Based on the generated schema description, the method constructs one or more data graphs, with each data graph representing one set of relationships between different sets of fields in the data storage. After generating the data graphs, the method generates a large number of possible API permutations by using the generated data graphs. The method presents the generated sample APIs so that a developer can select and customize one or more APIs while developing an application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09513941&OS=09513941&RS=09513941
owner: International Business Machines Corporation
number: 09513941
owner_city: Armonk
owner_country: US
publication_date: 20140918
---
This application claims benefit to U.S. Provisional Patent Application 62 051 924 filed Sep. 17 2014 which is incorporated herein by reference.

With the proliferation of mobile devices and applications that run on mobile devices the need for servers that can process application programming interface API requests from the mobile devices and their applications has never been greater. Traditional servers provide APIs that in order to be generated and used require a lot of code writing by the application developers. In other words currently an application developer should first get familiarized with the server that the developer wishes to interact with to send data to and or receive data from . The developer then has to write numerous lines of code in a particular programming language for the framework installed on the server to be able to execute and generate the desired APIs. Moreover the developer should be familiarized with the database with which the developer s application exchanges data and use the exact syntax required by the database in the program to be able to make this data exchange.

Some embodiments of the invention provide a novel method of generating application programming interfaces APIs in a codeless manner. The method of some embodiments receives the identity of a data storage e.g. of a relational database . The method then identifies the storage schema e.g. the relational database schema of the identified data storage and generates a description of the identified storage schema. For instance in some embodiments where the storage schema is a relational database the generated schema description is in form of several JavaScript Object Notation JSON models with each model representing a table in the relational database. In some embodiments the method receives a set of access credentials with the identity of the data storage uses the credential to identify the portion of the data storage that is accessible with the received credential set and then generates a schema description for the identified data storage portion.

Based on the generated schema description the method constructs one or more data graphs with each data graph representing one set of relationships between different sets of fields in the data storage. For example in some embodiments that specify one JSON based model to represent one table in a relational database RDB the method constructs one data graph for each particular JSON based model i.e. for each particular RDB table in order to specify the relationships between the particular model i.e. the particular RDB table and other JSON based models i.e. other RDB tables that are related to the particular model.

In some embodiments a first JSON based model is related to a second JSON based model when the first model s associated RDB table has a foreign key that references the RDB table that is associated with the second model. Also by virtue of the second model the first model can be indirectly related to a third JSON based model when the second JSON based model s RDB table has a foreign key that references the RDB table of the third model. In this manner one JSON based model can be indirectly related to any number of other JSON based models through its direct or indirect relations with other JSON based models. In some embodiments each particular JSON based model s data graph is a directed acyclic graph DAG with a root node that represents the JSON based model one or more child nodes that represent each JSON based model that is directly related to the particular model and one or more level of additional nodes that represent models that are related to the particular model through one or more levels of indirect relationships.

After generating the data graphs to represent the different sets of relationships between the different sets of fields in the data storage the method generates a large number of possible API permutations by using the generated data graphs. For instance in some embodiments that generate one data graph for each particular JSON based model that represents a particular RDB table the method generates one set of sample APIs for each node in the graph. The set of APIs for the root node represents a set of calls to a JS object that is instantiated from the JSON based model. For each call the JS object may have to exchange data by first analyzing the RDB table associated with the root node of the model s generated data graph.

Accordingly an API that is generated for a root node represents a call that may need to be processed by the node s associated JS object accessing the RDB table that is associated with the root node. Similarly an API for each particular non root node represents a call that needs to be processed by accessing RDB table associated with the particular non root node as well as accessing the RDB table of each node that is before the particular non root node and is directly or indirectly connected to the particular non root node in the DAG. In some embodiments the set of APIs for all nodes is the same. For instance in some embodiments each node s set of APIs includes create read update and delete CRUD APIs. In other embodiments different nodes have different sets of generated APIs.

After generating the large number of possible API permutations the method publishes the generated APIs so that a developer can select and customize the APIs individually. In some embodiments the method publishes the APIs through a software development kit user interface and a web browser so that the developer can scroll through the published APIs to identify one or more APIs to add to an application that is being developed. The developer can also customize the APIs that are selected through the provided user interface and web browser. Each selected and customized API will allow the application to pull data from the data storage that was initially identified. In some embodiments the method publishes the APIs by using nonproprietary web services such as the REST Representational State Transfer web services.

Once the developer selects and customizes an API that is presented with the other sample APIs the method completes the API description and stores a representation of this API in the application that is being developed. In some embodiments the completion of the API description entails completing a class description of an object for processing the API request at runtime. In some embodiments the class description is defined in terms of JSON based model which includes a JSON file that describes the properties of the JSON based model and a JavaScript JS file that describes the behavior of the JSON based model. When the application is executed the JSON based model is instantiated into a JS object based on the model s behavioral description in the JS file and its property description in the JSON file. When API requests are directed to such an instantiated JS object the JS object can exchange data e.g. read write update or delete data with its associated data storage in order to formulate a response to the API request.

The preceding Summary is intended to serve as a brief introduction to some embodiments of the invention. It is not meant to be an introduction or overview of all inventive subject matter disclosed in this document. The Detailed Description that follows and the Drawings that are referred to in the Detailed Description will further describe the embodiments described in the Summary as well as other embodiments. Accordingly to understand all the embodiments described by this document a full review of the Summary Detailed Description and the Drawings is needed. Moreover the claimed subject matters are not to be limited by the illustrative details in the Summary Detailed Description and the Drawings but rather are to be defined by the appended claims because the claimed subject matters can be embodied in other specific forms without departing from the spirit of the subject matters.

In the following detailed description of the invention numerous details examples and embodiments of the invention are set forth and described. However it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.

Some embodiments of the invention provide a novel method of generating application programming interfaces APIs in a codeless manner. The method of some embodiments generates a schema description of a data storage e.g. a relational database with which an API accessible object may have to exchange data e.g. from which the object may have to read data and or to which the object may have to write data to process an API request during the execution of an application. Based on the generated schema description the method constructs one or more data graphs with each data graph representing one set of relationships between different sets of fields in the data storage. After generating the data graphs the method generates a large number of possible API permutations by using the generated data graphs.

After generating the large number of possible API permutations the method presents the generated sample APIs so that a developer can select and customize one or more APIs while developing an application. Each selected API will allow the application to exchange data with the data storage. Once the developer selects and customizes a presented sample API the method completes a description of the object for processing the selected API and stores this description as part of the application that is being developed. When the application is being executed the object is instantiated to process API requests by exchanging data e.g. reading writing posting and or deleting data with the data storage in order to formulate a response to the API request.

As shown the process initially receives at the identity of a data storage e.g. of a relational database . At the process may also receive a set of credentials e.g. login credentials such as username and password for accessing the identified data storage. The process then identifies at the storage schema e.g. the relational database schema of the identified data storage. When the process receives a set of access credentials at the process at uses the provided credential set to identify the portion of the data storage that is accessible with the credential set.

Based on the storage schema identified at the process generates at a schema description for the data storage or for the portion of the data storage that is accessible with the provided credential set. As further described below some embodiments define one or more JSON based models to describe the identified data storage schema. For instance when the data storage is a relational database the process of some embodiments defines a JSON based model for each RDB table that is in the identified storage schema. In some embodiments a JSON based model includes a JSON file that describes one set of data tuples in the identified storage schema e.g. the columns of an RDB table . More descriptions and examples of JSON files and their attributes are discussed and illustrated in the concurrently filed U.S. patent application Ser. No. 14 490 640 entitled Method of Defining JavaScript Objects .

Based on the generated schema description the process constructs at one or more data graphs with each data graph representing one set of relationships between different sets of fields in the data storage. After generating the data graphs the process generates at a large number of possible API permutations by using the generated data graphs. For instance in some embodiments the data graph is a directed acyclic node graph with each node representing one set of fields in the data storage and a connection between a pair of nodes representing relationships between two related sets of fields.

In some of these embodiments the process generates at one set of sample APIs for each node in the graph. The set of APIs for the graph s root node represents a call to the data storage just for one or more fields in the set of data fields for which the graph was constructed. The set of APIs for each particular non root node represents a call that needs to be processed by accessing multiple sets of data storage fields including the set of fields that is associated with the particular non root node as well as the set of fields that are associated with each node that is before the particular non root node e.g the parent and grandparents of the particular non root node in DAG and is directly or indirectly connected to the particular non root node. In some embodiments the set of APIs for all nodes is the same. For instance in some embodiments each node s set of APIs includes create read update and delete CRUD APIs. In other embodiments different nodes have different sets of generated APIs.

After generating the large number of possible API permutations the process publishes at the generated APIs so that a developer can select and customize the APIs individually. In some embodiments the process publishes the APIs through the SDK s user interface and a web browser so that the developer can scroll through the presented APIs to identify one or more APIs to add to an application that is being developed. Each selected API will allow the application to pull data from the data storage identified at . In some embodiments the process publishes the APIs by using nonproprietary web services such as the REST Representational State Transfer web services.

Once the developer selects and customizes an API that is presented with the rest of the sample APIs the process completes at the API description and stores a representation of this API in the application that is being developed. In some embodiments the completion of the API description entails completing a class description of an object for processing the API request at runtime. In some embodiments the class description is defined in terms of JSON based model which includes a JSON file that describes the properties of the JSON object and a JavaScript JS file that describes the behavior of the JS object. When the application is being executed the JSON based model is instantiated into a JS object based on the model s behavioral description in the JS file and its property description in the JSON file. When API requests are directed to such an instantiated JS object the JS object can exchange data e.g. read write post or delete data with its associated data storage in order to formulate a response to the API request.

The SDK UI is the UI through which the SDK receives user input and provides SDK output to the user. The schema analyzer identifies the schema of a relational database that is identified by a developer. In some embodiments the schema analyzer receives the identity of the relational database along with a set of access credentials for accessing the relational database. For instance the schema analyzer receives a database discovery request through a command line API that provides 1 the credentials of a developer that requested the database discovery and 2 the specification of the requested database. Alternatively or conjunctively the analyzer of some embodiments provides a Graphical User Interface GUI with a set of tools to receive the discovery request and the developer s credentials.

The schema analyzer uses the credential set to identify the portion of the data storage that is accessible with the received credential set and then generates one or more JSON based models to provide the description of the identified schema. The schema analyzer of some embodiments retrieves a set of database fields e.g. a table s columns metadata of the data storage and automatically or based on user inputs maps these fields to a set of JSON files.

In some embodiments each generated JSON based model corresponds to a table in the relational database and each JSON based model includes a JSON file that describes the model s corresponding RDB table. In some embodiments each JSON file includes one or more properties that correspond to one or more columns of the file s associated RDB table. From the generated JSON based models data graph builder constructs one or more data graphs with each data graph corresponding to one generated JSON based model and representing the direct and indirect relationships between that model s RDB table and other tables in the RDB. Specifically in some embodiments the graph builder constructs one data graph for each particular JSON based model i.e. for each particular RDB table in order to specify the relationships between the particular model i.e. the particular RDB table and other JSON based models i.e. other RDB tables that are related to the particular model.

In some embodiments a first JSON based model is related to a second JSON based model when the first model s associated RDB table has a foreign key that references the RDB table that is associated with the second model. Also by virtue of the second model the first model can be indirectly related to a third JSON based model when the second JSON based model s RDB table has a foreign key that references the RDB table of the third model. In this manner one JSON based model can be indirectly related to any number of other JSON based models through its direct or indirect relations with other JSON based models. In some embodiments each particular JSON based model s data graph is a directed acyclic graph DAG with a root node that represents the JSON based model one or more child nodes that represent each JSON based model that is directly related to the particular model and one or more level of additional nodes that represent models that are related to the particular model through one or more levels of indirect relationships.

As shown the Cities table includes references to the Offices and Locations tables and the Office table includes references to the Cities and Locations tables and and the Locations table includes references to the Units table . For each of these tables the data graph builder generates a DAG node graph.

In the Cities graph the Cities root node has two child nodes and that correspond to the Offices and Locations tables and while the Locations node has a Units child node that corresponds to the Units table . Similarly in the Offices graph the Offices root node has two child nodes and that correspond to the Cities and Locations tables and while the Locations node has a Units child node that corresponds to the Units table .

After the graph builder generates the data graphs to represent the different sets of relationships between the different tables of the relational database the sample API generator generates a large number of possible API permutations by using the generated data graphs. For instance in some embodiments that generate one node graph for each particular JSON based model that represents a particular RDB table the API generator produces one set of sample APIs for each node in the graph. The set of APIs for the root node represents a set of APIs call to a JS object that is instantiated from the JSON based model. For each call the JS object may have to exchange data with the database by first analyzing the RDB table associated with the root node of the model s generated data graph.

More specifically an API call that is generated for a root node is a call that may need to be processed by the node s associated JS object by accessing the RDB table that is associated with the root node. An API call for each particular non root node represents a call that needs to be processed by accessing RDB table associated with the particular non root node as well as accessing the RDB table of each node that is before the particular non root node e.g. the parents grandparents etc. of the particular non root node in DAG and is directly or indirectly connected to the particular non root node. In some embodiments an API call for each non root node is an aggregated API call in that processing this call requires access to two or more database objects e.g. RDB tables .

In some embodiments the set of APIs for all nodes is the same. For instance in some embodiments each node s set of APIs includes create read update and delete CRUD APIs. Using this approach the sample API generator would generate sixteen APIs i.e. sets of CRUD APIs for the four nodes of the data graph and generate sixteen APIs i.e. sets of CRUD APIs for the for nodes of the data graph . In other embodiments different nodes have different sets of generated APIs. In some embodiments the format of each set of APIs for the four tables is as follows in some embodiments 

After the API sample generator produces the large number of possible API permutations the API publisher publishes the generated APIs so that a developer can select and customize the APIs individually. In some embodiments the publisher makes the APIs available through the SDK user interface . In some embodiments the available APIs can be accessed by a developer through a web browser not shown that allows the developer to scroll through the presented APIs to identify one or more APIs to add to an application that is being developed. Each selected API will allow the application to exchange data with the relational database that was used to generate the API. In some embodiments the publisher publishes the APIs by using nonproprietary web services such as the REST Representational State Transfer web services.

As mentioned above each sample API corresponds to a JSON based model which includes a JSON file with one or more properties that correspond to one or more fields of the file s associated RDB table. Accordingly in some embodiments the model builder of the SDK allows the developer to customize a selected sample API by specifying or adjusting one or more JSON file properties corresponding to one or more fields of the corresponding RDB table in the selected API. To specify and or adjust one or more JS file properties the SDK UI that is presented in a browser window provides a set of controls e.g. drop down windows or contextual pop up windows that can be provided for a presented API for displaying the properties e.g. the database field or keys of a database table that is identified in a sample presented API request. With such a set of controls the developer can narrow the specified API request to account for one or more properties of one or more tables that have to be accessed to process the API request. For example for the Get API request that relies on Cities and Offices tables the API request can be customized to state 

Once the developer selects and customizes an API that is presented with the other sample APIs the model builder completes the API description and stores a representation of this API in the application that is being developed. In some embodiments the completion of the API description entails completing a class description of a JS object for processing the API request at runtime. As mentioned above the SDK defines the class description in terms of JSON based model which includes a JSON file that describes the properties of the JSON object and a JavaScript JS file that describes the behavior of the JS object. Accordingly in these embodiments the model builder completes the class description by completing the JS file and JSON file descriptions based on the developer s customization of the selected API.

When the application is being executed the JSON based model is instantiated into a JS object based on the model s behavioral description in the JS file and its property description in the JSON file. When API requests are directed to such an instantiated JS object the JS object can exchange data e.g. read write post or delete data with its associated data storage in order to formulate a response to the API request.

In the example illustrated in the sample API generator generates a set of APIs for each node in a data graph. However in some embodiments this might not be the case. For instance in some embodiments one node connects to one or more grandchild nodes through a child node. These connections are referred to below as pass through connections. For such pass through connections the API generator skips the generation of a set of APIs for the child node as it is simply a pass through node. Instead the API generator generates sets of APIs for each grandchild node that refers to the grandchild node s associated table and its grandparent node s associated table.

To illustrate this illustrate an example of generating a data graph that includes a pass through node. illustrates four tables in a relational database. These tables are a locations table an inventory table a monitors table and a computers table with the latter two tables and being child tables of the inventory table . In this example the locations table has pass through relationships with the monitors table and the computers table that pass through the inventory table . In some embodiments each pass through relationship is defined in terms of hasManyThrough relationship value that in the JSON file of the locations table defines the relationship between the locations table and the inventory table.

Some embodiments forego adding a node to a data graph for a pass through table. illustrates one such approach. As shown this approach generates a three node graph the nodes corresponding to the locations monitors and computers tables and . When the graph builder uses this approach the API generator generates a set of APIs for each node in the data graph.

Some embodiments provide a Graphical User Interface GUI with a set of tools to 1 receive a set of credentials from an application e.g. mobile application developer along with a data storage schema discovery request and 2 present a set of APIs e.g. REST APIs to the developer to select from and customize. The selected and customized APIs as discussed above can be later incorporated in the developer s application so that the application s user would be able to interact with the data storage through a set of API calls generated by the application. illustrates one such GUI. More specifically illustrates how a user requests for a database schema discovery by interacting with the GUI in four different operational stages .

In the first stage a user e.g. application developer has initiated a database discovery request by selecting the data source control e.g. through a mouse or trackball a stylus keyboard a finger gesture e.g. placing pointing tapping one or more fingers near a near touch sensitive screen etc. . This stage also shows that upon selection of the UI control a new credentials window is opened to receive a set of credentials for the user. As described before some embodiments identify which portion of the data storage is accessible to a particular user based on the credentials received from the particular user. In these embodiments depending on the received credentials a user can be denied to access a database or can be authorized to access only a portion of the database e.g. access a limited number of tables and views in a relational database . This stage also shows that beside the user s credentials the name of the database and other information about the database must be given to the application. Some embodiments as stated before use the information to provide a description for the database schema to the user. After entering all the required information the user can select the accept control to receive this database schema description.

The second stage illustrates that the application after receiving the credentials of the user and the information about the database is showing a description of the authorized portion of the database. This is illustrated by data source window that contains a list of data objects e.g. a set of authorized tables views etc. for the user to select. As shown in the stage the user has selected the People table from the list of data objects by selecting its corresponding UI item . As mentioned before a user can select any UI control or UI item by a mouse or trackball clicking on a button of the mouse or trackball while the pointer is over the UI item a stylus keyboard a finger gesture e.g. placing pointing tapping one or more fingers near a near touch sensitive screen etc. Although in the illustrated example the user has selected only one table i.e. People table as mentioned before the user can select any number of tables e.g. all of the tables in the list at this stage. After selecting the desired table s the user selects the Discovery control to complete the selection of the tables and to receive a set of attributes for each selected table.

In the third stage the GUI presents a set of attributes of the selected table People to the user. As illustrated in this stage the set of attributes is presented in the table window . The window includes a column that represents the name of the fields of the table a column that represents the data type for each corresponding field and a set of UI controls where each UI control is for selecting its corresponding field placed in the same row as the UI control in the table. Additionally the user can select UI control in order to select all the fields at once instead of selecting each field one by one. As shown in this example the user has selected all the fields in the table People. 

As described above when the user finishes selecting the set of attributes in the table e.g. by selecting the accept control the method of some embodiments automatically generates a JSON based model for each table that the user has selected. In some embodiments each JSON based model includes a JSON file that describes one set of data tuples in the corresponding selected table. For instance in the illustrated example the method generates a JSON based model for People table. In some embodiments the name of the model is the same as the name of the table e.g. People in this example . The generated JSON based model also has a JSON file with a set of properties that corresponds to the set of fields selected by the user e.g. Name Gender Address etc. .

Additionally and as described above some embodiments generate and publish a set of APIs for each generated model so that a developer can select and customize the APIs individually. In some embodiments the APIs are REST APIs that are published through nonproprietary web services such as REST web services so that the developer can scroll through the published APIs to select and customize one or more of the published APIs and to add the selected and customized APIs to an application that is being developed. The fourth stage illustrates a web browser that publishes such generated APIs for a user to select and customize. Since in the illustrated example only one model is generated the set of published APIs relates to that model. The set of published APIs shown in stage includes four different API calls that all when processed access the table People in the database and interact with the table by writing reading updating or deleting data to and from the table.

The figure also illustrates that there are four common REST API calls i.e. POST PUT GET and DELETE in the set of API calls that are for exchanging data with a table People through a JSON based model with the same name . The figure also shows that there are other API s in the set of APIs that include additional attributes and or filters. In the demonstrated example the key id is one such attribute. Also in this example additional filters include exists FindOne update and count. Each of these filters help the developer to narrow down the operation further based on the characteristic of the individual filter.

In the codeless API discovery examples above the API discovery tool is used to generate sample APIs for exchanging data with a relational database. However one of ordinary skill will realize that API discovery methodology of some embodiments can be used to generate sample APIs that exchange data with other backend data storages. Moreover in some embodiments this methodology can be used 1 to generate different models that map to different storages 2 to store these models in the system memory and then 3 to generate additional models that interlink the different models that may connect to different storages by running the API discovery methodology to identify possible API permutations for the models that reside in the system memory.

Moreover the models described in some of the above mentioned embodiments are created through a database discovery schema. In some embodiments a JSON based model can be created through other means e.g. APIs received from the command line etc. . Different methods of creating JSON files and models are further described in the concurrently filed U.S. patent application Ser. No. 14 490 640 entitled Method of Defining JavaScript Objects .

Many of the above described features and applications are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium also referred to as computer readable medium . When these instructions are executed by one or more processing unit s e.g. one or more processors cores of processors or other processing units they cause the processing unit s to perform the actions indicated in the instructions. Examples of computer readable media include but are not limited to CD ROMs flash drives RAM chips hard drives EPROMs etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.

In this specification the term software is meant to include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments the software programs when installed to operate on one or more electronic systems define one or more specific machine implementations that execute and perform the operations of the software programs.

The bus collectively represents all system peripheral and chipset buses that communicatively connect the numerous internal devices of the electronic system . For instance the bus communicatively connects the processing unit s with the read only memory the system memory and the permanent storage device .

From these various memory units the processing unit s retrieve instructions to execute and data to process in order to execute the processes of the invention. The processing unit s may be a single processor or a multi core processor in different embodiments.

The read only memory ROM stores static data and instructions that are needed by the processing unit s and other modules of the electronic system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instructions and data even when the electronic system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device .

Other embodiments use a removable storage device such as a floppy disk flash drive etc. as the permanent storage device. Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments the invention s processes are stored in the system memory the permanent storage device and or the read only memory . From these various memory units the processing unit s retrieve instructions to execute and data to process in order to execute the processes of some embodiments.

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the electronic system. The input devices include alphanumeric keyboards and pointing devices also called cursor control devices . The output devices display images generated by the electronic system. The output devices include printers and display devices such as cathode ray tubes CRT or liquid crystal displays LCD . Some embodiments include devices such as a touchscreen that function as both input and output devices.

Finally as shown in bus also couples electronic system to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the Internet. Any or all components of electronic system may be used in conjunction with the invention.

Some embodiments include electronic components such as microprocessors storage and memory that store computer program instructions in a machine readable or computer readable medium alternatively referred to as computer readable storage media machine readable media or machine readable storage media . Some examples of such computer readable media include RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives read only and recordable Blu Ray discs ultra density optical discs any other optical or magnetic media and floppy disks. The computer readable media may store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations. Examples of computer programs or computer code include machine code such as is produced by a compiler and files including higher level code that are executed by a computer an electronic component or a microprocessor using an interpreter.

While the above discussion primarily refers to microprocessor or multi core processors that execute software some embodiments are performed by one or more integrated circuits such as application specific integrated circuits ASICs or field programmable gate arrays FPGAs . In some embodiments such integrated circuits execute instructions that are stored on the circuit itself.

As used in this specification the terms computer server processor and memory all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification the terms display or displaying means displaying on an electronic device. As used in this specification the terms computer readable medium computer readable media and machine readable medium are entirely restricted to tangible physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals wired download signals and any other ephemeral or transitory signals.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. For instance a number of the figures conceptually illustrate processes. The specific operations of these processes may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. Therefore one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details but rather is to be defined by the appended claims.

