---

title: Systems and methods for generating message sequence diagrams from graphical programs
abstract: A system and method automatically generating one or more message view windows or panes based on an analysis of the execution behavior of a model, such as a computer-generated, executable graphical model. A model analyzer examines execution instructions including schedules generated for the model and the sending and receiving of messages by model components or elements. An auto diagram builder generates the one or more message view windows that includes graphical affordances representing at least some of the messages. The messages may be presented in the one or more message view windows in the order of the occurrence of the messages during execution of the model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09547423&OS=09547423&RS=09547423
owner: The MathWorks, Inc.
number: 09547423
owner_city: Natick
owner_country: US
publication_date: 20141014
---
This application is a continuation in part of U.S. patent application Ser. No. 14 150 282 filed Jan. 8 2014 which claims the benefit of U.S. Provisional Patent Application Ser. No. 61 830 839 filed Jun. 4 2013 and is a continuation in part of U.S. patent application Ser. No. 13 117 859 filed May 27 2011 which claims the benefit of U.S. Provisional Application Ser. No. 61 349 401 filed May 28 2010 which applications are hereby incorporated by reference in their entireties.

The Unified Modeling Language UML is a standard visual modeling language used to specify and or document new or existing business processes or software systems. The UML standard defines many different types of diagrams including Class Diagrams Object Diagrams State Machine Diagrams and Interaction Diagrams. Examples of Interaction Diagrams include Sequence Diagrams Communication Diagrams and Timing Diagrams which provide different views of the interaction among objects or entities of a process or system. A Sequence Diagram typically illustrates message interchange between objects or entities of a business process or software system. A Timing Diagram typically illustrates the timing or duration of messages or conditions in the system or process. A developer or other user may create UML diagrams using a variety of existing software tools such as the Systems Modeling Language SysML from the Object Management Group OMG and IBM Rational Rose from IBM among others.

Tools such as modeling environments also exist for creating computer generated models such as graphical behavioral models that represent dynamic systems. A model may include a plurality of graphical objects such as blocks or icons. A model may be executed to simulate the operation or behavior of the system being modeled. For example the model may be executed by evaluating the model at a plurality of simulation or execution time steps beginning at a start time and ending at a stop time. In a single rate model all of the objects may execute during each time step except for objects configured for conditional execution where the condition is not met. In a multi rate model objects execute at different rates relative to each other and thus in a given time step only a portion of the blocks may execute. Some of the graphical objects of the model may generate and or process signals. A signal may refer to a time varying quantity having one or more values for example at all points in time during model execution. In addition some objects of the model may generate and or process messages that may have payloads that include one or more values. Payloads may be fixed and may persist for a determined time interval during a simulation time. A message may be generated at a particular point in time during model execution e.g. by a source message based block and may only exist for a limited time interval during which the message may be read by another message based block such as an intermediary block or a sink block.

To execute a model a scheduling order may be created that specifies an order of execution of at least some of the objects or components that make up a model. In addition one or more execution tasks may be implemented or defined and the objects of the model may be assigned to the one or more tasks for execution. Priorities may be assigned to the tasks and a higher priority task may preempt and or block execution of a lower priority task.

The present invention relates to systems and methods for automatically generating and presenting one or more message views based on an analysis of a model such as a computer generated executable graphical model. In an embodiment a system may include a modeling environment having a user interface engine a model editor and a simulation engine. The simulation engine may include one or more schedulers such as a static scheduler which may apply a scheduling algorithm such as the Rate Monotonic Scheduling RMS algorithm and a dynamic scheduler that may for example use an event calendar to establish a schedule. The simulation engine also may include one or more solvers. The modeling environment may support the creation of a model having dynamic i.e. time based objects and state based objects among other objects and at least some of the time based and state based objects may be further configured to send and or receive messages. The modeling environment also may include or be in communication with a diagramming tool. The diagramming tool may include a plurality of components such as a model analyzer a filtering unit an auto diagram builder and a user interface UI engine.

The model analyzer may be configured to examine a model created in the modeling environment and determine when particular execution activities such as the occurrence of events the execution of objects or blocks the sending and receiving of messages the changes in signal values the changes in states occur during execution of the model. The auto diagram builder may be configured to receive information concerning the model s execution behavior and to automatically generate one or more message views for the model. The filtering unit may receive inputs such as user inputs specifying selected model elements such as objects signals messages queues communication elements etc. to be included in the message view. For example a user may designate one or more signals functions state based blocks time based blocks and messages to be included in the message view generated by the auto diagram builder. The diagramming tool may be configured to provide the message view to an output device such as a display or a printer. A user may review the message view to observe and thus better understand the execution behavior of the model.

The message view may be dynamically generated and updated during execution of the model. Alternatively information needed to generate the message view may be logged or otherwise saved during model execution and the message view may be generated following model execution for example in a post mortem analysis.

A first message view which may also be referred to as a message sequence diagram created by the auto diagram builder may include a plurality of visual elements including lifelines and message arrows. The lifelines which may be vertically oriented on the first message sequence diagram may represent selected message based objects of the model such as message source and or message sink objects. The arrows which may extend between the lifelines may represent selected messages such as synchronous and asynchronous messages that are sent and received by the objects illustrated by the lifelines. As the model executes the first message sequence diagram may scroll e.g. upward and the temporal relationship among events or other interactions or activities may be shown on a dynamic e.g. scrolling diagram.

The auto diagram builder may include execution timing information on the message sequence diagram. For example the auto diagram builder may include a plurality of epoch elements in the diagram where each epoch element represents an execution time increment or instant defined during execution of the model. In an embodiment the epochs may correspond to simulation steps and or sample times determined by the simulation engine. For example a model may execute over a simulation time that starts at a simulation start time and ends at a simulation end time. States and outputs defined by model objects and other values may be computed at successive points in time between the start and end times. These points in time may be referred to as simulation steps or time steps and their size may be fixed or variable as determined by a particular solver used by the simulation engine. In another embodiment epochs may correspond to time periods specified by a user and may be hierarchically organized e.g. into major and minor epochs and the periods and organization of epochs may be changed during execution of visualization. In a state based modeling environment such as the Stateflow system when a state diagram executes it may respond to an event that may occur in its context. An event may be a sample time hit. In response to this event one or more transitions may be possible. In a normal step which may also be referred to as a micro step only one such transition may be executed. In a superstep which may also be referred to as a macro step multiple such transitions may be executed. A superstep may complete when the state diagram which may be referred to as a state chart reaches a new stable configuration e.g. no more transitions from active states exist. Also during execution of a state chart new events may be generated locally instead of in the state chart context. The corresponding chart activity may take place in a local step. In an embodiment epochs may correspond to one or more of these various steps e.g. micro step superstep and local step. The type of step to which an epoch corresponds may be user specified. Additionally or alternatively the multiple types of epochs may be indicated e.g. explicitly in a message sequence diagram. The epoch elements may be illustrated by horizontally arranged bands or regions overlaid on the first message sequence diagram. The first message sequence diagram may thus illustrate the particular time instants in which selected messages are sent and received by selected message based objects of the model.

The simulation engine may implement or define a single task or multiple tasks or processes for executing various portions of the model. A task may be scheduled and a task may have an execution list that includes a set of blocks. The model compiler may assign priorities to the tasks and may assign graphical objects or other model elements such as blocks to a particular task for execution. For example an object associated with a higher sample rate than another object or task may be assigned to a task having a higher priority than another task to which objects having a lower sample rate are assigned. A higher priority task may preempt execution of a lower priority task. In addition the simulation engine may implement a blocking or non blocking execution paradigm. Blocking refers to the process of placing a task on hold because the task is waiting for something e.g. input data a resource a reply to a function call a return from a function call etc. The assignment of priorities and the use of blocking or non blocking schemes may depend on the scheduling algorithm being used by the simulation engine. Other scheduling algorithms besides RMS include Earliest Deadline First Static Cyclic Scheduling and Deadline Monotonic Scheduling.

The simulation engine may be configured to simulate a multitask environment. In addition the simulation engine may be configured to simulate the contention for access to shared resources such a processor resource a memory resource a communication resource etc. by objects of the model or by tasks.

To execute message based blocks the simulation engine may allocate queues such as input and or output queues for the message based blocks and the queues may be used to temporarily store the values of messages received and or to be sent by the message based blocks.

The model analyzer may detect the allocation of such queues and the auto diagram builder may include queue elements in the first message sequence diagram. A queue element may include a vertically arranged queue lifeline that is disposed adjacent to the lifeline for the respective message based block. To the extent messages are sent from an output queue of a source block and received in an input queue of a sink block message arrows of the message sequence diagram may extend between the respective queue lifelines. In an embodiment a graphical affordance such as a queue depth bar may be provided on at least some of the queue lifelines that indicate the number of messages in the queue represented by the respective queue lifeline. For example a queue depth bar may have a width that indicates the number of messages in the respective queue. The queue depth bar may be widened when an additional message is added to the queue and narrowed when a message is removed from the queue.

The queue depth bar also may be configured to indicate if the depth of the queue has been exceeded. For example a queue may have a depth of five if a sixth message is sent to the queue the color of the queue depth bar may be changed by the auto diagram builder e.g. from green to red or some other indication may be provided.

In an embodiment a user may modify a message sequence diagram. For example the user may change the execution of a selected task from a first epoch to a second epoch e.g. by dragging and dropping the task execution bar from a first epoch element to a second epoch element. The user also may change when a selected message is sent and or received by editing the corresponding arrow again using drag and drop techniques. Other changes may be made to a message sequence diagram. The user initiated changes may be captured by the UI engine of the diagramming tool. The diagramming tool may notify the simulation engine of the changes detected in the message sequence diagram. The simulation engine including the model compiler and the schedulers may generate new execution instructions for the model that conform to the user modified message sequence diagram. For example the schedulers may reschedule the execution order of one or more objects of the model in order to comply with the changes made to the message sequence diagram. In an embodiment the simulation engine may be configured to create new execution constraints for example based changes in the order of one or more messages. The simulation engine may then attempt to generate an execution schedule that satisfies these new constraints. If such a schedule cannot be generated a warning or error message may be issued and presented e.g. on a display. In addition the user may designate at least some changes as preferential and the simulation engine may create preferential constraints. If a schedule cannot be generated that satisfies one or more of the preferential constraints the preferential constraints that cannot be satisfied may be removed and a schedule generated. In addition to creating new constraints or alternatively the simulation engine may be configured to modify other execution information such as sample time e.g. period and offset in order to generate a new schedule that implements the user s changes.

The modeling environment may further include a diagramming tool . The diagramming tool may include a model execution analyzer a filtering unit an automatic auto diagram builder and a user interface UI engine . As described herein the model execution analyzer may be configured to examine the execution instructions generated by the simulation engine for a specified model. The filtering unit may be configured to search the execution instructions for particular elements of the model. The auto diagram builder may be configured to generate one or more message sequence diagrams utilizing the information obtained by the model execution analyzer as filtered by the filtering unit . The UI engine may be configured to generate one or more user interfaces that include the one or more message sequence diagrams and to receive edits thereto.

The modeling environment may include other components such as a code generator a target language compiler and a differencing engine . The code generator may be configured to generate computer programming code such as source and or object code from a model. The target language compiler may be configured to compile source code such as source code generated by the code generator into an executable form such as one or more object code files or binaries for execution by target platform or target hardware such as a central processing unit CPU an embedded processor a microprocessor a microcontroller a Field Programmable Gate Array FPGA an Application Specific Integrated Circuit ASIC a Graphics Processing Unit GPU etc. of a data processing device. The differencing engine may be configured to analyze two models identify the differences between them and generate a report that sets forth the identified differences.

Suitable code generators for use with the present invention include but are not limited to the Simulink Coder the Embedded Coder and the Simulink HDL Coder products from The MathWorks Inc. of Natick Mass. and the TargetLink product from dSpace GmbH of Paderborn Germany. Suitable target language compilers include C and C language compilers. Nonetheless other code generation systems and other compilers may be used. Suitable differencing engines include the version compare utility in the Simulink Report Generator tool and the SimDiff tool from Ensoft Corp. of Ames Iowa.

In an embodiment the diagramming tool may be implemented through one or more software modules or libraries containing program instructions pertaining to the methods described herein. The software modules may be stored in one or more memories such as a main memory a persistent memory and or on computer readable media of a workstation or other data processing machine or device and executed by one or more processing elements. Other computer readable media may also be used to store and execute these program instructions such as non transitory computer readable media such as optical magnetic or magneto optical media. In another embodiment the diagramming tool may comprise registers and combinational logic implemented in hardware and configured and arranged to produce sequential logic circuits. In alternative embodiments various combinations of software and hardware including firmware may be utilized to implement the described methods.

In other embodiments the diagramming tool or one or more components thereof may be separate from the modeling environment . In such cases the diagramming tool may be in communication with the modeling environment e.g. through local procedure calls LPCs remote procedure calls RPCs or one or more Application Programming Interfaces APIs .

In an embodiment the modeling environment is a high level modeling environment. Suitable high level modeling environments include the MATLAB and Simulink technical computing environments from The MathWorks Inc. as well as the Simscape physical modeling system and the Stateflow charting tool also from The MathWorks Inc. the MapleSim physical modeling and simulation tool from Waterloo Maple Inc. of Waterloo Ontario Canada the LabVIEW programming system and the NI MatrixX model based design product both from National Instruments Corp. of Austin Tex. the Visual Engineering Environment VEE product from Agilent Technologies Inc. of Santa Clara Calif. the System Studio model based signal processing algorithm design and analysis tool from Synopsys Inc. of Mountain View Calif. the SPW signal processing algorithm tool from Synopsis a Unified Modeling Language UML system a Systems Modeling Language SysML system the System Generator system from Xilinx Inc. of San Jose Calif. and the graphical modeling systems described in U.S. Pat. No. 7 324 931 for Conversion of Model Components Into References and U.S. Pat. No. 7 991 598 for Method and System for Modeling a Mechanical System which are hereby incorporated by reference in their entireties among others. Models created in the high level modeling environment may contain less implementation detail and thus operate at a higher level than certain programming languages such as the C C C and SystemC programming languages.

Those skilled in the art will understand that the MATLAB technical computing environment is a math oriented textual programming environment for digital signal processing DSP design among other uses. The Simulink technical computing environment is a model based design environment for modeling and simulating dynamic and other systems among other uses. The MATLAB and Simulink tools provide a number of high level features that facilitate algorithm development and exploration and support model based design. Exemplary high level features include dynamic typing array based operations noncausal equation processing data type inferencing sample time inferencing and execution order inferencing among others.

In another embodiment a lower level programming language such as the C C and C programming languages among others may be used to create one or more models.

Models constructed by the modeling environment may include textual models graphical models and combinations of graphical and textual models. A given model may simulate e.g. approximate the operation of a system. Exemplary systems include physical systems such as weather systems financial markets plants controllers etc. A model may be executed in order to simulate the system being modeled and the execution of a model may be referred to as simulating the model.

The diagramming tool may receive an indication such as a command to generate one or more message sequence diagrams for a model as indicated at block . The diagramming tool also may receive an indication of one or more model elements to be included in the one or more message sequence diagrams to be generated as indicated at block . In an embodiment the user interface engine may be configured to present one or more model editor windows on a display. The model editor windows may include a plurality of graphical elements such as menu bars tool bars and a canvas for displaying a graphical model. A user may select one or more elements of a model presented on the model canvas. Alternatively or additionally a parameter or property may be defined for at least some of the graphical objects used in models. The setting of the parameter may determine whether the respective object is to be included in a message sequence diagram. To set the parameter the user may select the respective object and the UI engine may present a graphical affordance such as a dialog or pane through which the value of the parameter may be set by the user.

The simulation engine may generate execution instructions for the model as indicated at block . The generation of execution instructions and the simulation of a model may involve several phases such as a compilation phase a link phase and a simulation phase. Model execution may involve processing input data and generating output data. In an embodiment execution of the model may be carried out over a time span e.g. a simulation time which may be user specified or machine specified. The simulation time is a logical execution time and may begin at a simulation start time and end at a simulation end time. At successive points in time between the simulation start and end times which points in time may be called simulation time steps states inputs and outputs of objects of the model may be computed. The sizes of the time steps may be fixed or may vary and are determined by the particular solver used in the execution of the model. Execution instructions may be generated for the entire simulation time.

A compile stage may mark the start of execution of the model and may involve preparing data structures and evaluating parameters configuring and propagating block characteristics determining block connectivity and performing block reduction and block insertion. The preparation of data structures and the evaluation of parameters may result in the creation and initialization of one or more data structures for use in the compile stage. For the blocks of the model a method may force the block to evaluate all of its parameters. This method may be called for the blocks in the model. If there are any unresolved parameters execution and or compilation errors may be thrown. During the configuration and propagation of block and port signal characteristics the compiled attributes such as data dimensions data types complexity sample modes and sample time of each block and or port signal may be setup on the basis of the corresponding behaviors and the attributes of blocks and or port signal that are connected to the given block and or port signal which connections may be graphically represented on the model through lines arrows or other connectors. The attribute setup may be performed through a process during which block behaviors ripple through the model from one block to the next following signal state physical message or other connectivity.

This process is referred to as inferencing an implementation of which is propagation. In the case of a block that has explicitly specified its block or port behaviors propagation helps ensure that the attributes of the block or port are compatible with the attributes of the blocks or ports connected to it. If not a warning or an error may be issued. Secondly in many cases blocks or ports are implemented to be compatible with a wide range of attributes. Such blocks or ports may adapt their behavior in accordance with the attributes of the blocks or ports connected to them. The exact implementation of the block may be chosen on the basis of the model in which the block finds itself. Included within this step may be other aspects such as validating that all rate transitions yield deterministic results and that the appropriate rate transition blocks and or delay blocks are being used. The compilation step also may determine actual block connectivity. For example virtual blocks may play no semantic role in the execution of a model. In this step the virtual blocks may be optimized away e.g. removed and the remaining non virtual blocks may be reconnected to each other appropriately. This compiled version of the design model with actual block connections may be used from this point forward in the execution process. The way in which blocks are interconnected in the model does not necessarily define the order in which the equations e.g. included in methods corresponding to the individual blocks will be solved executed . These equations may include outputs equations derivatives equations and update equations.

Block sample times may also be determined during the compilation stage. A block s sample time may be set explicitly e.g. by setting a SampleTime parameter of the block or it may be determined in an implicit manner based on the block s type or its context within the model. The SampleTime parameter may be a vector T T where Tis the sampling period and Tis the initial time offset.

The selected solver may determine the size of the simulation time steps for the simulation of the model and these simulation time steps may be selected to correspond with the sample times of the blocks of the model. When a simulation time step matches the sample time for a block a sample time hit occurs and the block is scheduled for execution during that simulation step.

The schedulers may generate execution lists for the blocks of the model. In particular the schedulers may generate a block sorted order list and a method execution list. The schedulers may utilize one or more algorithms for generating the block sorted order and method execution lists. For example the static scheduler may use the Rate Monotonic Scheduling RMS Earliest Deadline First Scheduling Static Cyclic Scheduling or Deadline Monotonic Scheduling. The dynamic scheduler may use an event calendar to schedule future events such as timeouts and alarms.

In the link stage memory may be allocated and initialized for storing run time information for blocks of the model.

Following the model compilation and link stages code may or may not be generated for the model. If code is generated the model may be executed through an accelerated execution mode in which the model or portions of it is translated into either software modules or hardware descriptions which is broadly referred to herein as code. If this stage is performed then the stages that follow use the generated code during the execution of the design model. If code is not generated the model may execute in an interpretive mode in which the compiled and linked version of the model may be directly utilized to execute the model over the simulation time. The model may not be executed when code is generated for the model. Instead of executing the model within the modeling environment the generated code may be compiled and deployed on a target device such as a controller test hardware etc.

Generated code may be stored in memory e.g. persistent memory such as a hard drive or flash memory. The user interface engine may provide or support a Code Generation button in a GUI that may be selected by the user or the user interface engine may receive a code generation command entered by the user e.g. in the GUI or the CLI. The code generation command also may be invoked programmatically for example when a particular event occurs. In response to the code generation command being activated the code generator may generate code for the model.

In an embodiment the generated code may be textual code such as textual source code that may be compiled and executed on a target machine or device. The generated code may conform to one or more programming languages such as Ada Basic C C C SystemC FORTRAN VHDL Verilog embedded MATLAB a vendor or target specific HDL code such as Xilinx FPGA libraries assembly code etc. For example one or more code generation files such as header main make and other source files may be generated for the design model. The target language compiler may compile the generated code for execution by target hardware such as a microprocessor a Digital Signal Processor DSP a Field Programmable Gate Array FPGA etc.

The model execution analyzer may analyze the execution instructions generated for the model as indicated at block . For example the model execution analyzer may access the execution instructions generated by the simulation engine to determine the execution order of one or more objects of the model the identity of tasks executing particular objects of the model the priority of particular tasks and or objects of the model the existence of queues e.g. for buffering messages and the logical execution times at which messages are generated added to queues removed from queues and consumed. The model execution analyzer may obtain further information regarding the execution of the model.

The auto diagram builder may generate one or more message sequence diagrams as indicated at block and the one or more message sequence diagrams may be presented e.g. on a display as indicated at block . In an embodiment the one or more message sequence diagrams may be presented as the model is executed. In another embodiment the one or more message sequence diagrams may be generated for viewing after model execution.

Furthermore the sender block may be configured such that when event e occurs the sender block places the current value of the counter block on its output queue qOut generates a message having the current value of the counter block as its payload and increments the counter block . Messages generated by the sender block are received at the input queue qIn of the receiver block as indicated by a first arrow . The receiver block may be configured such that when event e occurs the receiver block determines whether there is a message on its input queue qIn . If so the receiver block retrieves the message places the value of the message at its output queue qOut and generates a message with the value. If there is no message on the receiver block s input queue qIn the receiver block generates a message with a payload of . Messages generated by the receiver block are received at the input queue sIn of the sink block as indicated by a second arrow . The sink block may be configured such that when event e occurs the sink block retrieves the messages on its input queue sIn and displays the message values e.g. on a console.

A user may be interested in observing the execution of the model . The user may enter a command to generate one or more message sequence diagrams for the model . The user may designate that information concerning the sender receiver and sink blocks is to be included in the one or more message sequence diagrams.

The model execution analyzer may examine the execution instructions including the execution schedules generated for the model by the simulation engine . If the model has not yet been executed the diagramming tool may direct the simulation engine to execute the model thereby generating execution instructions. The filtering unit may direct the model execution analyzer to analyze the execution instructions for the occurrence of elements of the model such as blocks queues connections etc. that were identified as being of interest to the user e.g. the sender receiver and sink blocks . The filtering unit also may direct the model execution analyzer to examine one or more logical execution time periods that are of interest to the user.

The model compiler may establish a single task e.g. the PollingSystemPeriodic task to execute the functions defined by all three blocks and . In addition the static scheduler may be used and may schedule the order of the events e e and e such that event e is processed before event e which is processed before event e.

The auto diagram builder may be configured to utilize a plurality of different graphical affordances in the first diagram to illustrate the interactions among the selected entities of the model . For example the auto diagram builder may include a first type of graphical affordance to represent the selected entities i.e. the sender receiver and sink blocks . The first type of graphical affordance may be a lifeline. In particular the auto diagram builder may include a first lifeline for the sender block a second lifeline for the receiver block and a third lifeline for the sink block . The lifelines may be dashed lines that are parallel to each other and may extend vertically in the diagram . The lifelines may include headers such as headers that contain information identifying the respective entities such as their names e.g. sender receiver and sink .

The auto diagram builder may use a second type of graphical affordance to represent interactions between the entities. For example the auto diagram builder may represent the occurrence of message send and receive interactions among the entities during execution of the model using one or more symbols or other graphical images or effects such as connectors which may be solid line arrows where the arrows extend between the lifelines thereby visually linking the lifelines. An arrow may identify the lifelines of the sending and receiving blocks. For example the tail of an arrow may be located on the lifeline of the entity sending the message while the head of the arrow may be located on the lifeline of the entity receiving the message. As mentioned the auto diagram builder may arrange the arrows on the diagram in an order that illustrates the execution order of the interactions as determined by the simulation engine . For example the auto diagram builder may place the arrow for a first interaction above a second arrow for a second interaction where the first interaction occurs before the second interaction whether the interactions occur in the same time step or in different time steps.

As mentioned the schedulers of the model compiler generate an execution schedule for the model over the simulation time. The message based blocks are configured to execute at particular sample times. Accordingly the blocks may be message based blocks that may be scheduled for execution at each simulation time step that corresponds to a sample time hit for a respective one of the blocks .

All three blocks may be scheduled for execution in a first simulation time step which may correspond to sample time . The sender block reads the value of the counter block e.g. and generates a first message with this value as its payload. The message is received at the receiver block which generates a second message with this value as its payload. The second message is received at the sink block which displays the value from the message e.g. on the console.

On the first diagram a first arrow extending from the sender s lifeline to the receiver s lifeline represents the first message. A second arrow extending from the receiver s lifeline to the sinks lifeline represents the second message. In an embodiment the auto diagram builder may provide information concerning the payload of messages illustrated in the first diagram . For example the auto diagram builder may include a payload data box adjacent to e.g. above the arrow and may present the value of the message s payload in the data box. A first data box may be associated with the first arrow indicating that the payload of the first message is 0. A second data box may be associated with the second arrow indicating that the payload of the second message is also 0. Execution of the sink block does not involve the generation or sending of any messages. Accordingly no arrows are shown from the sink s lifeline .

As mentioned the receiver block executes at each sample time e.g. sample times etc. the sender block executes at every other sample time e.g. sample times etc. and the sink block executes every fourth sample time e.g. sample times etc. Accordingly at the simulation time step for sample time only the receiver block is scheduled for execution. The receiver block again generates a message. However because there is no new data on the receivers input queue qIn the receiver block transmits a message whose payload is 1. This message is represented on the diagram as a third arrow having third data box

In an embodiment the auto diagram builder positions the arrows representing messages to indicate when during execution of the model the message is both sent and received. The first and second messages are both sent and received during the first simulation step which corresponds to sample time because all three blocks execute at this sample time. Accordingly the auto diagram builder may draw the first and second arrows horizontally on the diagram .

However while the third message as represented by the third arrow is sent by the receiver block during the simulation time corresponding to sample time this third message is not received by the sink block until the simulation time corresponding to sample time which is the next time after sample time that the sink block is scheduled to execute. Accordingly while the tail of the third arrow is placed on the receiver s lifeline at a location indicating that it is the next message to be sent after the second message the head of the third arrow is placed on the sink s lifeline at a much lower point e.g. a point representing the simulation time step for sample time . The slope of an arrow in the first diagram may thus represent a delay between a logical execution time at which a message is sent and a logical execution time at which the message is received.

At the simulation time for sample time both the sender block and the receiver block are scheduled for execution. The sender block again reads the value of the counter block which is now 1 and generates a message with that value as its payload. This message is illustrated in the diagram by a fourth arrow with a data box illustrating that the payload of this message is 1. The receiver block receives the message and generates its own message with the value from the received message e.g. 1. The message generated by the receiver block is illustrated in the diagram by a fifth arrow with a data box . Because the message represented by the fifth arrow is not received by the sink block until the sink block next executes the fifth arrow like the third arrow is also sloped indicating the time delay.

At the simulation time for sample time only the receiver block is scheduled for execution. The receiver block generates a message but because no new data was received by the receiver block the receiver block uses the value of 1 for the payload of this message. This message is illustrated in the diagram by a sixth arrow with a data box . The sixth arrow is also displayed in a sloping manner indicating that it is not received by the sink block until a later logical execution time.

At the simulation time for sample time all three blocks are once again scheduled for execution. The sender block reads the value of the counter block i.e. and generates a message with this value as its payload. This message is represented in the diagram by a seventh arrow with a data box . The receiver block receives the message from the sender block and generates its own message using the value from the received message i.e. 2. The message generated by the receiver block is illustrated by an eighth arrow with a data box

Even though the eighth arrow represents a message that is sent and received during the same simulation time step e.g. sample time the eighth arrow is sloped indicating that the sink block receives the message at a logical time that is after it was sent by the receiver block . This is due to the fact that after the receiver block sends this message it is not processed by the sink block until after the sink block has processed the other messages represented by arrows and .

The auto diagram builder may also be configured to utilize one or more graphical affordances to represent logical execution time of the program on a message sequence diagram. For example the auto diagram builder may be configured to include a plurality of horizontal regions on a message sequence diagram where each region corresponds to a particular logical execution time instant. The horizontal regions may be referred to as epochs. In an embodiment an epoch may correspond to a simulation time step during which an activity involving at least one of the selected entities occurs. The auto diagram builder may include boundaries such as lines separating adjacent epochs and may include information regarding the logical execution time instant of the epochs.

Included in the second diagram is a first epoch for the simulation time step corresponding to sample time . The first epoch may include a data box that contains information regarding the particular logical execution time instant of the first epoch e.g. the simulation time step that corresponds to sample time . A boundary line may mark the end of the first epoch and the start of a second epoch . The second epoch may include a data box that contains information regarding its logical execution time instant e.g. the simulation time step that corresponds to sample time and a boundary that separates the second epoch from a third epoch . The third epoch includes a data box that contains information regarding its logical execution time instant e.g. the simulation time step that corresponds to sample time and a boundary line that separates the third epoch from a fourth epoch . The fourth epoch includes a data box that contains information regarding its logical execution time instant e.g. the simulation time step that corresponds to sample time and a boundary line that separates the fourth epoch from a fifth epoch . The fifth epoch includes a data box that contains information regarding its logical execution time instant e.g. the simulation time step that corresponds to sample time .

In addition to illustrating epochs on a message sequence diagram the auto diagram builder may also be configured to include one or more graphical affordances that represent the task used to execute the blocks . For example the auto diagram builder may overlay a task activation bar onto a lifeline to indicate when a task is executing the block represented by that lifeline.

As mentioned the model compiler may be directed to implement or define a single task to execute the sender receiver and sink blocks . The model compiler may define a task called PollingSystemPeriodic .

During the first epoch a first task activation bar may indicate that the task i.e. the PollingSystemPeriodic task first executes the sender block . The length of the task activation bar may provide an indication of the length of the physical execution time that the task spends executing the sender block . Upon completion of the sender block the task switches to executing the receiver block as indicated by a second task activation bar . Upon completion of execution of the receiver block the task executes the sink block as indicated by a third task activation bar . A task activation bar may include a header portion and information identifying the event that triggered execution of a block by the task such as the event s name may be included in the header portion. For example the event that triggers execution of the sender block is called e the event that triggers execution of the receiver block is e and the event that triggers execution of the sink block is e.

As the PollingSystemPeriodic task can only execute one of the blocks at any given point in time there is no overlap among the task activation bars .

During the second epoch which corresponds to the simulation time step for sample time the task only executes the receiver block as indicated by fourth task activation bar . During the third epoch which corresponds to the simulation time step for sample time the task executes the sender block and the receiver block as indicated by fifth and sixth task activation bars . During the fourth epoch which corresponds to the simulation time step for sample time the task only executes the receiver block as indicated by seventh task activation bar . During the fifth epoch which corresponds to the simulation time step for sample time the task executes all three blocks as indicated by eighth ninth and tenth task activation bars .

The message sequence diagram provides the user with an indication of which activities occur in a given logical execution time instant i.e. an epoch and the relative order of those activities in that time instant. For example with reference to the first epoch it can be observed that the task executes the sender block before executing the receiver block and that the task executes the receiver block before executing the sink block . The diagram also may provide an indication of the event that triggers the execution of a block of interest. To conserve display space the auto diagram builder may be configured to size epochs based on the number of activities such as messages or portions thereof being displayed in the epochs. An epoch that presents many messages or portions thereof may appear larger than an epoch that presents only a few messages.

The subsystems and of the Traffic Light System subsystem may be configured to generate and receive messages during execution of the graphical model by the modeling environment . They may also be configured to compute and read one or more signals. Messages defined within the subsystem may be represented in the subsystem through one or more designated graphical affordances such as double line arrows while other graphical affordances such as single line arrows may represent signals defined within the graphical model . For example one or more components of the Junction Controller subsystem may generate six types of messages as indicated by message arrows that may be received by the Traffic Light Assembly subsystems and which in turn may generate four types of messages as indicated by message arrows that may be received by the Junction Controller subsystem .

In an embodiment the user interface engine of the modeling environment may be configured to present a graphical object such as a Message Viewer block on the display with a graphical model. In response to the selection of the Message Viewer block the diagramming tool may be configured to open one or more Message View windows or panes on the display of the data processing system. It should be understood that in addition to or instead of the Message Viewer block a command button may be added to a command ribbon or button bar or to a menu bar of the desktop for opening a Message View window. A Message Viewer block type may be included in one or more palettes of block types. A user may select the Message Viewer block type from the palette and add an instance of the block to a graphical model.

The simulation engine may be configured to execute the graphical model or a portion thereof for example in response to a user command or programmatically. The model may be executed over an execution or simulation time such as 0 to 10 seconds which may be specified for the model e.g. through user input or programmatically. During execution components or other elements of the model may generate one or more messages that persist for execution time intervals that are something less than the model s entire or full execution or simulation time. Messages also may have fixed payloads e.g. payloads whose values do not vary over time. The messages may be received by other model components or elements and their payloads may be processed by those other components or elements. The sending and receiving of messages may be specified graphically textually or a combination of graphically and textually.

The diagramming tool may monitor and or trace the occurrence of messages within the graphical model as it executes and may generate a visual representation of the model s message behavior. This visual representation may be presented in one or more Message View windows or panes that may be included on the display of the data processing device. In an embodiment the diagramming tool may be configured to present a dynamic and or animated view of the model s message behavior in the Message View window by representing the messages and other model components with graphical elements such as window gadgets widgets . The diagramming tool may be further configured to present the graphical elements representing the messages in an order that is the same as or at least closely matches the order of the occurrence of the messages during execution of the graphical model e.g. relative to the execution time of the graphical model . For example when messages occur at different sample times time steps simulation times etc. the diagramming tool may maintain the temporal order of the messages on the Message View windows. The temporal order may be in terms of a logical time. In addition a state diagram for example may define a plurality of state transitions among a plurality of states where one transition triggers another which triggers another and so on and each state may issue a message. Nonetheless all of the state transitions and thus all of the messages may be considered to occur at the same logical time for example in the same sample time time step simulation time etc. When the state diagram is executed the transitions and the messages may occur at different times in a physical sense. The diagramming tool may maintain the execution order of the transitions and or messages occurring at the same logical time. The diagramming tool may thus present a display of messages in the Message Viewer windows that maintains an order such as a temporal order and or an execution order of the messages.

It should be understood that the auto diagram builder may be configured to omit or hide one or more time bands from the Message View window . For example the auto diagram builder may be configured to display time bands during which messages of interest occur and to hide or otherwise not display other time bands. A user may select or designate messages of interest and the auto diagram builder may identify the occurrence of the messages of interest show the time bands during which such messages of interest occur and hide or otherwise not display other time bands e.g. time bands during which other messages which are not the messages of interest are occurring. In an embodiment a user may also designate one or more payload values of interest and the auto diagram builder may be configured to determine when messages whose payloads match the designate value of interest occur and present those matching messages on one or more Message Viewer windows. It should be understood that the user may designate a value using various relationship operators such as equal to less than greater than etc.

The auto diagram builder may be configured to include additional graphical affordances or widgets to represent the occurrence of messages. In an embodiment the auto diagram builder may represent messages with single line arrows extending between the lifelines and in which the tail of an arrow is placed at the lifeline of the component that sent the respective message and the head of the arrow is placed at the lifeline of the component that received the respective message. As illustrated by arrows whose tails are placed at the Junction Controller lifeline the Junction Controller component generates and sends an Initialize Init message with a payload of 1 that is received by the Traffic Light Assembly component an Init message with a payload of 2 that is received by the Traffic Light Assembly component a StartCycle message with a payload of 1 received by the Traffic Light Assembly component and a StartCycle message with a payload of 1 received by the Traffic Light Assembly component .

The auto diagram builder may be configured to include further graphical affordances or widgets that indicate whether messages are being generated and or received by sub components of the components represented by the lifelines and . For example the auto diagram builder may use bar elements such as bar elements overlaid on the lifelines and to indicate that messages are generated and or received by sub components of the components represented by the lifelines and .

In an embodiment the auto diagram builder may be configured to present additional information regarding a model component or entity that sent or received a message. This additional information may be presented in response to user interaction with the Message View window . For example in response to a user operating a mouse device to hover a cursor over a bar element the auto diagram builder may be configured to cause a pop up window to be presented on the Message View window where the popup window provides additional information. For example if a user hovers the cursor over the bar element the auto diagram builder may cause a pop up window to be presented that includes a first entry identifying the name of the component i.e. the Command Processor component that generated the respective message a second entry indicating the model execution start time i.e. 10.00 s for the Command Processor component and a third entry indicating the model execution end time i.e. 10.00 s for the Command Processor component .

The auto diagram builder may be further configured to present additional information for a message in the Message View window besides message name payload value and execution time of occurrence. The additional information may be presented in response to user interaction with the Message View window . For example in response to a user hovering a cursor over an arrow that represent a message the auto diagram builder may be configured to cause a pop up window to be presented providing the additional information.

The auto diagram builder may be further configured to alter the granularity of model execution time as presented on Message View window . For example the auto diagram builder may alter the granularity of one or more of the time bands in response to user interaction with the Message View window .

It should be understood that the additional information may be presented in response to other user actions besides a mouse hover such as selecting a command button entering a textual command at a Command Line Interface CLI using a drop down or pull down menu etc. It should also be understood that the auto diagram builder may be configured to include the additional information on the Message View window without the need for a user command or input.

In an embodiment the auto diagram builder may be configured to organize lifelines according to the model hierarchy of the graphical model and to expand and collapse lifelines presented on the Message View window for example in response to user input or interaction. That is a lifeline representing a parent component may be replaced with lifelines representing the child components of the parent component. Alternatively the lifelines representing the child components may be shown in addition to the lifeline for the parent component . In an embodiment the user interface engine may be configured to include one or more graphical affordances or widgets in the Message View window through which a user can cause lifelines to be expanded or collapsed according to the model hierarchy. Referring to one or more command buttons may be associated with the lifeline headers that if selected cause lifelines to be expanded or collapsed. For example Traffic Light System header may include a button or icon that can be toggled between a sign and a minus sign to expand or collapse lifelines for the parent child hierarchy of the traffic light system component . When the button is in the form of a sign selection of the button causes headers and lifelines to be presented in the Message View window for all or at least some of the child components and elements that form the parent traffic light system component . In particular additional headers and lifelines may be provided for those components that send and or receive messages during execution of the graphical model . When the button is in the form of a sign selection of the button may cause headers and lifelines for the components of the traffic light system component to be collapsed into a single lifeline for the traffic light system component . The traffic light assembly header junction controller header and traffic light assembly header may similarly include respective expand collapse buttons . In response to selection of the expand collapse button for the traffic light assembly header for example the user interface engine may be configured to replace lifeline with lifelines for the components of the traffic light assembly component that send and receive messages and or to maintain the lifeline and add lifelines for these child components.

When a lifeline is collapsed the auto diagram builder may be configured to provide information regarding messages sent to or received from the collapsed lifeline. For example auto diagram builder may annotate an arrow with a name or other identity of the child component sending or receiving the respective message. In another embodiment this information may be presented when the user hovers the cursor over the respective arrow or selects an arrow or it may be presented in a manner determined by an option setting.

The auto diagram builder also may be configured to include one or more graphical affordances or widgets that may be operated e.g. by a user to remove or return a header and lifeline from or to the Message View window . For example the headers may themselves be implemented as buttons. In response to the selection of a header e.g. through user input such as single or double mouse or touchpad clicks combination mouse keyboard entries finger swipes screen taps etc. the auto diagram builder may be configured to remove the selected header and lifeline from the Message View window . For example in the version of the Message View window presented in the Traffic Light Assembly header and lifeline which appear in have been removed and replaced with button . In response to the selection of the button the auto diagram builder may be configured to return the Traffic Light Assembly header and lifeline to the Message View window .

In an embodiment the user interface engine may be configured to move headers and lifelines around in the Message View window for example in response to user interaction. More specifically the user interface engine may configure headers and lifelines for drag and drop operations. That is using a mouse device to control a cursor a user may select a lifeline and or header drag the selected lifeline and header to a new position on the Message View window and drop the selected lifeline and header at the new position.

By re arranging the headers and lifelines a user may unclutter the Message View window . For example before rearranging the headers and lifelines as represented in many message arrows extend across several lifelines. After rearranging the headers and lifelines as represented in these message arrows no longer extend across as many lifelines which makes the information presented in the Message View window namely the model s message behavior easier to read.

The auto diagram builder may be configured to store in a memory the occurrence of at least some of the messages for the model. This data may then be used in future display operations. In addition the auto diagram builder may be configured to organize the storing of messages by model component such as specific subsystems sub models etc. Accordingly future display operations can be generated for the messages associated with one or more particular components of the model.

In an embodiment the auto diagram builder may be configured to hide and or collapse one or more time bands.

In an embodiment the diagramming tool may be configured to identify model execution time periods during which no messages are sent or received and may omit such time periods from presentation in a Message View window. For example with reference to the Message View window of the diagramming tool may determine that during execution of the model no messages are sent or received during model execution times 21 26 s and 33 36 s. As illustrated the diagramming tool may include one or more time bands for model execution time periods 17 20 s 27 32 s and 37 42 s but omit time bands for 21 26 s and 33 36 s to conserve display area. In an embodiment the diagramming tool may be configured to present the omitted time bands for example in response to user input. The diagramming tool also may be configured to include one or more graphical affordances such as narrow bands or rows for the omitted time bands. Whether to include or omit time bands in a Message View window may be user settable for example through an option setting.

Suppose a user is not interested in seeing one or more time bands for example because there is little or no important messaging activity or behavior taking place during those time bands. In an embodiment the user interface engine may be configured to hide and show one or more time bands for example in response to user interaction with the Message View window . In an embodiment one or more show hide command buttons may be associated with at least some of the time bands presented in the Message View window . For example a first show hide command button may be associated with the second time band . Another show hide command button may be associated with the fourth time band . The show hide command buttons may include a sign to indicate that information may be hidden or collapsed from view. In response to a user selecting the show hide command buttons the diagramming tool may be configured to hide the respective time bands.

It should be understood that other user inputs may be used to hide or show time bands. For example the diagramming tool may be configured to hide a time band in response to a user double clicking the time band e.g. with a mouse or touch pad. Similarly the diagramming tool may be configured to show a hidden time band in response to a user double clicking a button or other graphical affordance associated with the hidden time band.

In an embodiment the user interface engine may be configured to replace the hidden time bands with graphical affordances such as narrow horizontal rows and to indicate hidden time bands. In an embodiment the diagramming tool may endow the rows with information regarding the message activity that occurred during the hidden time bands. For example abbreviated or summary information such as total number of messages sent and or received and or message names or types may be presented on or in the area of the hidden time bands. The rows and may be smaller in displayed area than the time bands that they replace thereby making display area available for e.g. information presented in other time bands. The user interface engine may change the icon associated with the show hide buttons and from a sign to a sign to indicate that hidden or collapsed information e.g. time bands may be shown or expanded. In response to the user selecting the show hide buttons and with the time bands hidden the user interface engine may be configured to show the previously hidden time bands on the Message View window .

The graphical model may be executed and the model execution analyzer may monitor the creation of messages and their exchange among components and other elements of the model. In addition the auto diagram builder may be configured to create one or more Message View windows that provide a visual representation of at least a portion of the model s message behavior. In an embodiment the visual representation may present the messages in a temporal order that matches or at least closely resembles the temporal order that the messages were sent and received in terms of the model s execution time.

The auto diagram builder may be configured to provide one or more graphical affordances on the Message View window to represent at least some of the messages sent and received during execution of the graphical model . In an embodiment the auto diagram builder may represent the occurrence of messages with arrows that extend between lifelines. The tail portion of an arrow may be located at the lifeline of the component that generated or sourced the message and at a point corresponding to the execution time at which the message was sent while the head of the arrow may be located at the lifeline s of the component s that received the message and at a point corresponding to the execution time at which the message was received. With reference to a first arrow may represent a Car Command carCmd type of message having a payload of Stop that is generated by the controller state chart and received by the elevator plant component . A second arrow may represent a floor clear floorClr type of message having a payload of 1 that is generated by the controller state chart and received by the elevator plant component . A third arrow may represent a car clear carClr type of message having a payload of 1 that is generated by the controller state chart and received by the elevator plant component .

In an embodiment to the extent a lifeline represents a component having one or more states the auto diagram builder may be configured to include one or more graphical affordances on the Message View window that indicate when the one or more states are entered and or exited during execution of the graphical model. In another embodiment lifelines may be presented for one or more states. The graphical affordances used to indicate state entry and exit events may be presented in temporal order with respect to the sending and receiving of messages. For example the auto diagram builder may add one or more shapes or other widgets that include the name of the state being entered or exited. In an embodiment the auto diagram builder may use a first shape similar to an upper half of a flowchart terminator symbol to indicate a state being entered and a second shape similar to a lower half of a flowchart terminator symbol to indicate a state being exited.

With reference to a first state exit symbol may be disposed on the lifeline for the controller state chart to indicate when in terms of model execution time the moving state is exited. A first state entry symbol may be disposed on the lifeline to indicate when the stopping state is entered. A second state exit symbol indicates when the stopping state is exited while a second state entry symbol indicates when the stopped state is entered. Arrows having tails that join a lifeline between state entry and exit symbols such as arrows and indicate messages being sent while a state is active e.g. the stopping state. By evaluating the state entry and exit symbols displayed on a lifeline a user can understand which states are active at particular execution intervals or times and the messages that are sent or received while those states are active. It should be understood that other graphical indicators may be used. For example the segment of a lifeline that corresponds to the state being active could be colored differently than other segments of the lifeline the line could have a different style etc.

A user may expand the lifelines of a component such as the lifeline which represents the controller state chart to obtain more detailed information regarding the hierarchy of states within the controller state chart when those states are active and the messages being exchanged. A user may also collapse the details of behavior while in one state. For example in response to user input the auto diagram builder may be configured to collapse state entry and state exit symbols together so that the symbols appear adjacent to each other in the Message View window. The details of state behavior between the state entry and state exit which may not be of interest to the user may thus be hidden from view. For example the arrows may be omitted or otherwise not shown on the Message Viewer window.

To the extent a graphical model or portion thereof such as a state chart includes one or more functions such as function defined in a text based programming language or development environment having dynamic typing that supports array based functionality such as the MATLAB environment functions defined in a state transition diagramming language supporting hierarchy even broadcast and AND OR state decomposition such as the Stateflow modeling environment or other functions the auto diagram builder may be configured to include one or more headers and lifelines for these functions. For example to the extent the controller state chart includes one or more Stateflow functions that may be called and may return results or other data or information the auto diagram builder may include the header and the lifeline to represent the Stateflow functions. In addition the auto diagram builder may be configured to include graphical affordances on the Message View window that represent calls to the one or more functions represented by the Stateflow functions header and the lifeline . With reference to a first arrow may represent a function call e.g. requestsForFloor to the Stateflow functions and a second arrow may represent the function return e.g. true requestsForFloor. The first arrow may have a tail located at or near the lifeline s associated with the component s or other model element s that issued the function call while the second arrow may have a head located at or near the lifeline s associated with the component s or other model element s that received the function return.

In an embodiment the user interface engine may be configured to include one or more Message View windows in a desktop environment model editor or other Graphical User Interface GUI created by the user interface engine .

In an embodiment the user interface engine may be configured to include a Message View window within or as part of the model editor window . For example the Message View window and the model canvas may be vertically arranged e.g. side by side horizontally arranged e.g. one over the other or arranged in some other configuration. In an embodiment the modeling environment may be configured to match the components of the graphical program presented on the model canvas with the components whose lifelines are presented in the Message View window . In a first embodiment selection of the graphical program or portion thereof may control which headers and lifelines are presented in the Message View window . In a second embodiment selection of headers and lifelines in the Message View window may control which graphical model or portion thereof is presented on the model canvas .

In addition the diagramming tool may be configured to operate the Message View window in a live or dynamic mode during execution of the graphical model . More specifically the simulation engine may be configured to execute e.g. run a graphical model opened on the model canvas . During execution model input values may be received and processed and model output values may be computed. In addition one or more states may be entered and exited during execution of the graphical model. Furthermore one or more components may generate and send messages and the messages may be received queued and or processed by other model components. The diagramming tool may be configured to operate the Message View window to provide a visual indication of at least some of the messages being generated and sent the components that generate and send the messages the components that receive the messages and the state of the components as the messages are sent or received. In the live or dynamic mode the diagramming tool may be configured to scroll the lifelines presented in the Message View window automatically e.g. in an upward direction so that new space e.g. toward the bottom of the Message View window may be made available for presenting new messages.

The diagramming tool may be configured to represent a message on a Message View window even though there is no lifeline for the component that either sent or received the message. The diagramming tool may cause the arrows representing such messages to start or end at one or more particular locations on the Message View window. For example the diagramming tool may configure the Message View window with a first area and a second area disposed along the left and right side edges of the Message View window respectively. The first and second areas and may be referred to as gutters. For a message that is sent by a component represented by a lifeline but received by a component that is not represented by a lifeline within the current view the head of the respective arrow such as arrows and may be located at the first or second areas and . For messages that are sent by a component that is not represented by a lifeline in the current view but is received by a component that is represented by a lifeline in the current view such as arrows and the tail of the respective arrow may be located at the first or second areas and . In an embodiment the first and second areas and are oriented in a similar manner as the lifelines e.g. vertically to maintain the same illustration of arrows as between the lifelines .

By hovering a cursor over such arrows and the diagramming tool may cause one or more pop up windows not shown to be presented on the Message View window that provides additional information about the respective message such as the name or identity of the component that sent or received the message which is not represented by a lifeline.

As the graphical model executes the user interface engine may animate one or more portions of the model. For example the user interface engine may use one or more graphical affordances to indicate when a particular component or element of the model as presented on the model canvas is executing and or active. For example the user interface engine may highlight a block or state of a graphical model when it is executing or active. With reference to the Crossing state may be highlighted or the color of its border may be changed or bolded to indicate that at this point in the model execution the controller component is currently in the Crossing state . In other words the diagramming tool and the user interface engine may cooperate to provide an animation mode for the execution of the graphical model as presented on the model canvas and a live or dynamic mode for the Message View window . In the live or dynamic mode arrows representing messages pop up on the Message View window when those messages occur during execution of the model. By observing the model editor window and in particular the model canvas which may illustrate the execution of a model in an animated fashion and the Message View window which may illustrate the model s messaging behavior a user may obtain a better understanding of the model s operation.

The auto diagram builder may be configured to present an animated version of the Message View window during execution of the model. In this case arrows may be presented on the Message View window even though the messages that correspond to those arrows have not yet occurred during the current execution of the model. The arrows may be arranged within the Message View window based on a prior execution of the model or an analysis of the model. As the message occurs during a current execution of the model a graphical affordance or widget may be used to mark the respective arrow which is already present on the Message View window. For example when the message corresponding to a given arrow occurs during model execution the auto diagram builder may be configured to display the given arrow in bold in a new color with a shadow blinking etc. Animation of arrows on the Message View window may be presented serially e.g. bolding one arrow at a time or the animation may be batched. For example if a first message triggers the occurrence of a second message the arrows for both message may be bolded at the same time e.g. to improve the display of the animation.

In another embodiment the auto diagram builder may be configured to display graphical affordances on the model canvas as an animated version of message exchange.

In an embodiment the simulation engine may be configured to pause or step the execution of the graphical model for example in response to a user selecting the Backward step button the Forward step button or a Pause button. The diagramming tool may be similarly configured to pause or step the Message View window with the pausing or stepping of the graphical model in response to the selection of the Backward step button the Forward step button or a Pause button. The diagramming tool may be configured to step or pause the Message View window in sync with the stepping or pausing of the model execution.

The modeling environment may further include one or more debugging tools. The debugging tool may be configured to insert a breakpoint into the execution of a model in response to a user marking a breakpoint at a desired location in the Message View window. For example a user may select a point along a lifeline and insert a breakpoint at that selected point. The auto diagram builder may be configured to present a particular graphical affordance or widget on the lifeline to indicate the addition of a breakpoint. The breakpoint may be used to indicate that execution of the model should halt when a message to a particular lifeline is sent when a message from a particular lifeline is sent or when a message from one particular lifeline to another particular lifeline is sent. After inserting a breakpoint a user may step backwards through the execution of the model then re run the model stopping at the specified breakpoint. For example the simulation engine may be configured to pause and backstep a model. In addition a user may re run a model following the insertion of a breakpoint. The subsequent execution of the model may need to be identical to the prior execution of the model when the breakpoint was inserted or determined to match that prior execution.

Model execution may then be resumed until some specified occurrence such as the next breakpoint is encountered execution associated with a current or designated lifeline completes execution associated with a new or next lifeline is activated etc. Furthermore a call stack listing all messages may be presented and a selection may be made of a particular message from the call stack. Execution may proceed until the selected message occurs such that the selected message operates as a breakpoint.

In an embodiment the message view window presents a trace of at least some of the messages sent and received during execution of a graphical model in the temporal order that the messages were sent and received. To the extent the trace extends across a model execution time that is larger than the display area assigned to the message view window one or more vertical scroll bars may be provided. A user may operate the one or more vertical scroll bars to navigate to different model execution time periods of the message trace. In addition to the extent message view window includes more lifelines than can be shown in the display area assigned to the message view window one or more horizontal scroll bars may be provided. A user may operate the one or more horizontal scroll bars to bring one or more lifelines into view on the message view window. In addition a zoom in zoom out feature may be provided.

The main memory which may be a Random Access Memory RAM may store a plurality of program libraries or modules such as an operating system and one or more application programs that interface to the operating system such as the modeling environment .

The removable medium drive may accept and read a computer readable medium such as a CD DVD floppy disk solid state drive tape flash memory or other non transitory medium. The removable medium drive may also write to the computer readable medium .

Suitable computer systems include personal computers PCs workstations servers laptops tablets palm computers smart phones electronic readers and other portable computing devices etc. Nonetheless those skilled in the art will understand that the computer system of is intended for illustrative purposes only and that the present invention may be used with other computer systems data processing systems or computational devices. The present invention may also be used in a networked e.g. client server computer architecture or a public and or private cloud computing arrangement. For example the modeling environment application may be hosted on a server and accessed by a remote client through an application hosting system such as the Remote Desktop Connection tool from Microsoft Corp.

Suitable operating systems include the Windows series of operating systems from Microsoft Corp. of Redmond Wash. the Android and Chrome OS operating systems from Google Inc. of Mountain View Calif. the Linux operating system the MAC OS series of operating systems from Apple Inc. of Cupertino Calif. and the UNIX series of operating systems among others. The operating system may provide services or functions for other modules such as allocating memory organizing data according to a file system prioritizing requests etc. The operating system may run on a virtual machine which may be provided by the data processing system .

As indicated above a user or developer such as an engineer scientist programmer etc. may utilize one or more input devices such as the keyboard the mouse and the display to operate the modeling environment and construct one or more graphical skeleton components and or one or more models that include one or more graphical skeleton components. As discussed the graphical models may be computational and may have executable semantics. In particular the models may be executable. In particular the model may provide one or more of time based event based state based frequency based control flow based and dataflow based execution semantics. The execution of a model may simulate operation of the system that is being designed or evaluated. The term graphical model moreover is intended to include graphical program.

The foregoing description of embodiments is intended to provide illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example while a series of acts has been described above with respect to the order of the acts may be modified in other implementations. Further non dependent acts may be performed in parallel.

In addition while particular examples of graphical affordances have been described and shown it should be understood that other graphical affordances may be used. For example other connectors such as lines boxes bars etc. may be used instead of or in addition to the arrows. Similarly other icons or widgets may be used. In addition various combinations of features may be combined in one or more of the message sequence diagrams of the invention.

Also the term user as used herein is intended to be broadly interpreted to include for example a computing device e.g. a workstation or a user of a computing device unless otherwise stated.

It will be apparent that one or more embodiments described herein may be implemented in many different forms of software and hardware. Software code and or specialized hardware used to implement embodiments described herein is not limiting of the invention. Thus the operation and behavior of embodiments were described without reference to the specific software code and or specialized hardware it being understood that one would be able to design software and or hardware to implement the embodiments based on the description herein.

Further certain embodiments of the invention may be implemented as logic that performs one or more functions. This logic may be hardware based software based or a combination of hardware based and software based. The logic may be stored in one or more tangible computer readable storage media and may include computer executable instructions that may be executed by processing logic such as processing logic . The computer executable instructions may include instructions that implement one or more embodiments of the invention. The tangible computer readable storage media may be volatile or non volatile and may include for example flash memories dynamic memories removable disks and non removable disks.

No element act or instruction used herein should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

