---

title: Low level object version tracking using non-volatile memory write generations
abstract: A method for retrieving versioned data in a non-volatile memory is provided. The method includes: (1) receiving a read request for a data object, (2) in response to the request, determining, via an object table, whether one or more versions of the data object exist in memory, (3) in accordance with a determination that one or more versions exist in memory, obtaining, via the object table, a respective location where each of the one or more versions of the data object are stored, and (4) reading at least one of the one or more versions of the data object from the respective location into volatile memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09183236&OS=09183236&RS=09183236
owner: SANDISK ENTERPRISE IP LLC
number: 09183236
owner_city: Milpitas
owner_country: US
publication_date: 20140428
---
The present application is a continuation of U.S. patent application Ser. No. 13 084 464 filed Apr. 11 2011 which is incorporated herein by reference in its entirety.

The present application is related to U.S. patent application Ser. No. 12 276 540 filed on Nov. 24 2008 now U.S. Pat. No. 8 229 945 which is incorporated herein by reference in its entirety.

The disclosure herein relates to object version tracking using non volatile memory write generations.

The term versioning is applied to the creation and management of multiple releases of an object such as a document where all releases have the same general features but are improved upgraded or customized. Commonly the term is used for digital documents such as application source codes operating systems software packages and management of data art resources such as blueprints or electronic models and other projects.

Data versioning is performed for a number of purposes including increased concurrency for applications requiring concurrency control providing snapshot isolation for consistent data reads and for the creation of backup snapshots to help recovery from hardware and software errors. Versioning involves retaining pre update data values after data have been updated. For example in case an error occurs and the results of a calculation are incorrect restoring the pre update data values could be very helpful. Versioning can be done incrementally on every update of each document i.e. transactional versioning or done globally at certain times i.e. check pointing with snapshots .

Using version control one can keep track of different versions of electronic information for example in collaborative data sharing and editing among users of systems that employ different versions of a document. Version control systems are typically stand alone applications. With the spread of use of non volatile memories such as flash memories there is a need for techniques that enable transactional versioning at the data element level versioning for global snapshots and other methods of version control in flash memories.

Approaches for data versioning in a non volatile memory are disclosed. In the following description numerous specific details are set forth such as examples of specific components circuits and processes to provide a thorough understanding of the present disclosure. Also in the following description and for purposes of explanation specific nomenclature is set forth to provide a thorough understanding of the present embodiments. However it will be apparent to one skilled in the art that these specific details may not be required to practice the present embodiments. In other instances well known components are shown in block diagram form to avoid obscuring the present disclosure.

A method in accordance with present embodiments includes creating an object key associated with a data object. An index into an object table is generated using the object key. A version number is stored in conjunction with the data object stored in non volatile memory. The object key and the location information of the data object in the non volatile memory are stored in an object linked list. A record associated with the data object is created in an object table. The record includes an index a reference to the object linked list and the version number. The index is generated based on the object key.

Embodiments described provide approaches for data versioning which uses flash memory controller write operations to create new data versions. Previous data versions are tracked using lists stored in non volatile memory such as in flash memory or another non volatile memory. Approaches for obtaining correct versions and for recovering storage from unreferenced versions are presented.

In an embodiment object table may include multiple records each including an object table index a reference to an object linked list and a version number . Object table index is generated based on an object key which uniquely identifies data object . First object key is hashed using well know algorithms to produce a syndrome e.g. a 32 bit syndrome . Then a portion of the syndrome is masked to produce object table index which is an index into the object table . The reference to the object linked list in object table points to a linked object list which includes entries such as object key and location information . Location information includes a flash location or a list of flash locations depending on the data object identified by object key i.e. data object being a single page object or a multiple page object multi page objects occupy more than one flash pages and use full pages except for the last page .

Once the location of data object has been determined the appropriate PCI Express commands are issued to read the corresponding flash page or portion of a flash page into flash card based non volatile NV DRAM and from there to CPU memory.

Hardware platform includes one or more solid state devices SSDs and one or more parallel SSD controller s . As broadly used herein SSD s may be implemented using any type of solid state device although examples discussed herein shall be explained in the context of SSD s being implemented using flash memory and SSD controller being a flash memory controller. Each SSD in SSD s contains a write cache . In an embodiment hardware platform may include one or more hard disk drives HDDs and one or more HDD controller s . In an embodiment each HDD controller in HDD controller s may include a NV DRAM . In an embodiment NV DRAM may store one or more of fill pages and one or more active fill pages both described in more detail below for SSD .

NV DRAM may be constructed using a DRAM which includes a battery so that if the power to the DRAM is disrupted the battery will supply power to the DRAM thereby ensuring that the data stored thereon may be persistently stored at least until the battery runs out . Hardware platform also includes network controller PCIe HUB one or more processors and dynamic random access memory DRAM .

As a data object write operation occurs data object is written to the next unused sequential location in the fill page . If data object in the fill page is rewritten before the page is committed to flash memory then it is generally written a second time since doing otherwise poses a risk to the previous copy if the system crashes during the write operation. The data object location is then updated in the object table of . Once fill page is full the commit of fill page to flash memory is started as soon as possible. A new page from NV DRAM is taken from the free list to replace the fill page which is being committed as the current fill page and is associated with a new flash page based on the well known wear leveling information. Once the commit is completed the committed NV DRAM page is placed on the free list. Each page of flash memory e.g. flash page has a small amount of extra flash memory which is typically bytes per page. Extra flash memory is used by flash memory controller to record 1 the current wear counter for the page 2 the timestamp of the write 3 the identity of the owning shard and 4 the flash location associated with the new page that replaces this page as the current fill page which forms a forward chain for recovery . Data objects are written to flash memory as key data pairs together with the key length and data length. Zero length data objects are allowed and a special value is written as the data length for data objects is deleted in a delete operation. This is useful for recovery purposes alternatively one could keep a log of erased data objects .

Flash memory controller of is configured to associate version numbers with data objects in storage blocks. Flash memory controller is also configured to maintain a list of all data objects associated with a particular version number. Zero or more data objects may be associated with a particular version number. A particular data object may at any time have one or more version numbers associated with it. In an embodiment the version number associated with a data object is determined by the application issuing the put operation. By default the current version number CVN associated with the container is assigned to a data object when it is written but an application can use explicit version numbers as well. Additional version numbers such as a next version number NVN and a minimum active version number MVN are also unique to each container. NVN is always greater than CVN and MVM is always less than or equal to CVN . All three version numbers increase monotonically.

Further there is a per shard linked list of all objects with the same version number with a head for each version number between the MVN and CVN inclusive. Similarly the version number used in a get operation is determined by the application making the request with the default being the CVN . When the object table and the associated object linked list of is scanned a match only occurs if all three of the following conditions are met 1 Object key matches directly or via the syndrome key algorithm described above 2 Object version number of in object table is less than or equal to the version number specified in the get request and 3 Object version number in object table is not in a dead version list. The dead version list includes a list of version numbers which are no longer valid.

Still referring to in some embodiments applications use version number in put get calls to achieve versioning or snapshotting. For example on a snapshot request by a snapshot application flash memory controller of increments CVN . If the CVN NVN then NVN is also incremented. Next the original un incremented CVN is returned to the snapshot application as a snapshot version number SVN . Other non snapshotted applications will use CVN for all put operations. Snapshotted versions may not perform put operations. When a data object is written it is tagged with CVN . If a SVN is active known from the container metadata then older versions of data object are not released when a new version is written. The new entry in object table is added to the per shard linked list of objects with the same version number.

In an embodiment the snapshot application uses SVN when performing get operations. Since looking up object table is conditioned on the version number a snapshotted lookup of a data object will not see any data object written after the snapshot is taken. When the application is finished with the snapshot it performs a call to a sharing data fabric SDF to terminate the snapshot. SDF garbage collector then walks the per shard linked list for each version number between the MVN and the CVN or between the MVN and the version number of the oldest active snapshot and releases the duplicate objects with lower version numbers. Finally the MVN is updated. SDF is a middleware layer that includes interface for communications between high level programs and lower level hardware controllers and their software and firmware programs. SDF is accessible by high level application programs using an application programming interface API . Communication between various nodes that may have stored various versions of a data object is performed by SDF threads. Below versioning with commit is discussed.

In some embodiments on a version request SDF increments NVN and returns the original un incremented NVN to the application as a versioned version number VVN . Other non snapshotted applications will use CVN for all put get operations. When a data object is written by the versioned application the new entry in object table is added to the per shard linked list of data objects with the same version number as always . Data object is also marked as uncommitted. Any non versioned application uses CVN when performing get operations. Since the object table lookup is conditioned on the version number a non versioned application lookup of a data object will not see any data object written by the versioned application. If a copy of data object is written by a non versioned application then the versioned application will see that copy when it performs a get operation. If both the versioned and the non versioned application write data object then the non versioned copy will be lost on commit. Locks must be used if this is not the desired behavior.

In an embodiment when the application commits CVN it will be updated to the VVN . A special commit record will be written to flash with the just committed version number. This is used during reboot to re mark the flash objects previously labeled as uncommitted. The SDF garbage collector eventually cleans up any duplicate copies of data objects with version numbers between the old CVN and the VVN . Once this is complete the special commit record can also be removed by the garbage collector. The techniques herein also support versioning when an abort occurs as discussed below.

With continued reference to in an embodiment on versioning with abort everything proceeds as above until the point of commit. At that point an abort situation is assumed. In this situation CVN remains unchanged as does the NVN . VVN is added to the list of dead versions and a special abort record is written to flash memory with the aborted version number i.e. CVN . The record will be used on reboot to discard any remaining data objects with that version number. The SDF garbage collector walks the VVN object chain releasing VVN data objects. These dead data object versions are also in flash memory and must be erased so that the flash pages of associated with the dead objects are scheduled for immediate coalescing. The SDF garbage collector eventually rewrites the flash pages with the dead objects omitting the dead objects themselves. This is a background task. Once it is complete the dead version can be removed from the dead version table and the special abort record can be deleted from flash by the garbage collector. Note that the garbage collection can be slow therefore data consistency does not depend on its completion.

Versioning collisions may occur when multiple transactions each create a version of the same container and then attempt to use data objects in conflicting ways. Note that there are never collisions between versions and snapshots since the snapshots are read only by definition. There are several types of collisions such as write write collisions when both versions attempt to write the same data object write read collisions when one version writes a data object which the other version attempts to read and finally read write collisions when a data object is read by one version and later written by the other version . The initial version of SDF will not attempt to detect collisions. Collision avoidance if desired is the responsibility of the application. Another embodiment discussed below addresses split versioning which occurs when a single thread uses different version numbers to achieve different consistency levels.

Read uncommitted read committed and read reproducible isolation operations well known in the art of database management are supported directly by the SDF fabric. The version number used by an application for get operations need not be the same as the version number used by put operations. Applications may also use explicit version numbers either for gets or puts. However the version must be either explicitly locked or released by the application. It is expected that most applications will use a SDF supplied library routine which specifies a database consistency level. The library routine will then be responsible for managing the explicit version numbers. Read committed operations always use the version number of the most recently committed version which can change during a transaction . Read uncommitted operations always use the highest numbered non aborted version number. Normal non versioned SDF get operations are treated as read committed. Read reproducible operations are somewhat different in that the application or library routine must lock the reproducible version with an application programming interface API call. This returns the version number of the most recently committed version and remains static for the duration of the transaction. The application or library routine must release the version when the transaction completes. Example API and library routines used in some embodiments are shown below.

Computer system may be coupled to a display such as a cathode ray tube CRT a LCD monitor and a television set for displaying information to a user. An input device including alphanumeric and other keys is coupled to computer system for communicating information and command selections to processor . Other non limiting illustrative examples of input device include a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . While only one input device is depicted in embodiments of the invention may include any number of input devices coupled to computer system .

Present embodiments are related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement embodiments of the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable storage medium as used herein refers to any medium that participates in storing instructions which may be provided to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory .

Non limiting illustrative examples of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM or any other optical medium a RAM a PROM and EPROM a FLASH EPROM or any other memory chip or cartridge or any other medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a network link to computer system .

Communication interface provides a two way data communication coupling to a network link that is connected to network . For example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information. Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through a local network to a host computer or to data equipment operated by an Internet Service Provider ISP .

Computer system can send messages and receive data including program code through the network s network link and communication interface . For example a server might transmit a requested code for an application program through the Internet a local ISP a local network and subsequently to communication interface . The received code may be executed by processor as it is received and or stored in storage device or other nonvolatile storage for later execution.

One or more embodiments described herein provide that methods techniques and actions performed by a computing device are performed programmatically or as a computer implemented method. Programmatically means through the use of code or computer executable instructions. A programmatically performed step may or may not be automatic.

One or more embodiments described herein may be implemented using programmatic modules or components. A programmatic module or component may include a program a subroutine a portion of a program or a software component or a hardware component capable of performing one or more stated tasks or functions. As used herein a module or component can exist on a hardware component independently of other modules or components. Alternatively a module or component can be a shared element or process of other modules programs or machines.

While the present embodiments have been described with reference to specific embodiments thereof it will be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. For example features or aspects of any of the embodiments may be applied at least where practicable in combination with any other of the embodiments or in place of counterpart features or aspects thereof. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

