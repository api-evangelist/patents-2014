---

title: Modeling distributed systems
abstract: A modeling system including a data processing device in communication with a non-transitory memory storing a model modeling interactions of resources of a distributed system. The data processing device executes instructions that cause the data processing device to implement a system monitor that monitors interactions of the resources of the distributed system and builds the model. The system monitor detects a state change of a first resource of the distributed system and identifies an entity causing the state change of the first resource. The system monitor determines whether a second resource of the distributed system changes state within a threshold period of time after the first resource changed state. The system monitor updates the model to indicate a relationship between the first resource, the second resource and the identified entity, in response to the first resource and the second resource changing state within the threshold time period.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09525599&OS=09525599&RS=09525599
owner: Google Inc.
number: 09525599
owner_city: Mountain View
owner_country: US
publication_date: 20140624
---
A distributed system may include many interconnected hardware and software resources. Due to the vast number of resources in a distributed system some distributed systems are very complex and difficult to understand. In large distributed systems some resources may affect the operation of other resources. As the size of a distributed system increases it becomes increasingly difficult to ascertain the effect of a particular resource on other resources in the distributed system. There is a need for a modeling system that models a distributed system and promotes or facilitates understanding the interactions between resources in the distributed system.

One aspect of the disclosure provides a modeling system. The modeling system includes a non transitory memory and a data processing device in communication with the non transitory memory. The memory stores a model modeling interactions of resources of a distributed system. The data processing device executes instructions that cause the data processing device to implement a system monitor. The system monitor monitors interactions of the resources of the distributed system and builds the model. The system monitor detects a state change of a first resource of the distributed system and identifies an entity causing the state change of the first resource. Moreover the system monitor determines whether a second resource of the distributed system changes state within a threshold period of time after the first resource changed state. Finally the system monitor updates the model to indicate a relationship between the first resource the second resource and the identified entity in response to the first resource and the second resource changing state within the threshold time period. At least one of the first resource and the second resource includes a hardware resource of the distributed system in communication with the data processing device.

In some implementations the entity causing the state change in the first resource includes a software resource associated with the first and second resources. In other implementations the entity causing the state change in the first resource includes a hardware resource. In yet other implementations the entity causing the state change in the first resource includes an event affecting a measurable characteristic of the first resource. In some examples the event includes a power surge affecting an amount of power delivered to the first resource. In other examples the event includes an increased processing demand affecting the number of processing jobs the first resource executes.

In some implementations the system monitor receives data from the first resource or the second resource indicating the relationship between the first resource and the second resource. The system monitor updates the model to indicate the relationship between the first resource and the second resource. In some examples the first resource or the second resource may push the data to the system monitor. In other examples the system monitor may fetch the data from the first resource or the second resource.

In some implementations the system monitor receives data indicating the entity causing the state change of the first resource. The system monitor may receive the data from one or more databases. The system monitor may fetch the data from the databases or a database manager may push the data to the system monitor.

In some implementations the system monitor receives a request from a requestor in communication with the data processing device to determine an impact of a first software service on a second software service. The system monitor determines a first set of resources of the distributed system associated with the first software service. Moreover the system monitor determines a second set of resources of the distributed system associated with the second software service. Additionally the system monitor retrieves relationships between the first set of resources and the second set of resources from the model. Finally the system monitor sends the retrieved relationships to the requestor. Advantageously the system monitor facilitates determining the impact of a first software service on a second software service. In some implementations the system monitor may provide a list of alternative resources that the first software service may use to reduce the impact of the first software service on the second software service.

In some implementations the system monitor validates relationships stored in the model. The system monitor retrieves a relationship from the model. The relationship may include the first resource the second resource and the entity linking the first resource with the second resource. The system monitor varies a property of the entity to trigger a state change of the first resource. The system monitor determines whether the state of the second resource changes within a threshold period of time. Finally the system monitor validates the relationship in response to the second resource changing state within the threshold period of time. In some implementations the system monitor purges the relationship when the second resource does not change state with the threshold period of time. Advantageously the system monitor facilitates in maintaining the accuracy of the model by validating the relationships in the model and purging relationships that may be inaccurate.

In some implementations the entity causing the state change of the first resource may include one of a power surge a power drop a current surge a current drop a voltage surge a voltage drop a change in temperature a change in processing demand or a change in memory demand. In other implementations the entity causing the state change of the first resource may include one of a runtime error a change in processing demand a change in memory demand a change in a number of virtual machines a change in a number of application threads or a change in a number of users using the software application.

Another aspect of the disclosure provides a distributed system including hardware resources software resources residing in one or more of the hardware resources and a non transitory memory residing in one or more of the hardware resources. The non transitory memory stores a model modeling relationships among the hardware resources and the software resources. The distributed system further includes a model interface implemented on one or more of the hardware resources. The model interface when executed on the one or more hardware resources causes the one or more hardware resources to generate a representation of the model. In response to a request for a representation of at least a portion of the model the model interface retrieves relationships affecting the organization from the model. The request originates from a requestor of an organization having several software applications and the request being associated with one of the software applications. After retrieving the relationships the model interface categorizes each resource in the retrieved relationships as one of an organization resource an infrastructure resource an application resource or a metadata resource. The model interface categorizes a resource as an organization resource when the resource affects all of the software applications of the organization. The model interface categorizes a resource as an infrastructure resource when the resource affects some of the software applications of the organization but not all software applications of the organization. The model interface categorizes a resource as an application resource when the resource affects only the software application of the organization associated with the request. The model interface categorizes a resource as a metadata resource when the resource is available to the software application and the software application can use the resource to store metadata related to other resources. Finally the model interface generates a representation of the retrieved and categorized relationships.

In some implementations the model interface displays a graphical representation of the retrieved and categorized relationships as a directed graph. Moreover the model interface displays indicia indicating the organization resources the infrastructure resources the application resources and the metadata resources. In some examples the indicia include separate colors for each category of resources.

In some implementations the distributed system may include a system monitor that is implemented on one or more of the hardware resources. The system monitor when executed on the one or more hardware resources causes the one or more hardware resources to build the model. The system monitor detects a state change of a first resource of the distributed system and identifies an entity causing the state change of the first resource. Moreover the system monitor determines whether a second resource of the distributed system changes state within a threshold period of time after the first resource changed state. Finally the system monitor updates the model to indicate a relationship between the first resource the second resource and the identified entity in response to the first resource and the second resource changing state within the threshold time period. At least one of the first resource and the second resource includes a hardware resource of the distributed system in communication with the data processing device.

In some implementations the entity causing the state change includes a hardware resource. In some implementations the system monitor receives data from the first resource or the second resource indicating the relationship between the first resource and the second resource. Moreover the system monitor updates the model to indicate the relationship between the first resource and the second resource. In other implementations the system monitor receives data indicating the entity causing the change in state of the first resource.

In some implementations the system monitor receives a request from a requestor in communication with the data processing device to determine an impact of a first software service on a second software service. The system monitor determines a first set of resources of the distributed system associated with the first software service. Moreover the system monitor determines a second set of resources of the distributed system associated with the second software service. Additionally the system monitor retrieves relationships between the first set of resources and the second set of resources from the model. Finally the system monitor sends the retrieved relationships to the requestor. Advantageously the system monitor facilitates determining the impact of a first software service on a second software service. In some implementations the system monitor may provide a list of alternative resources that the first software service may use to reduce the impact of the first software service on the second software service.

In some implementations the system monitor validates relationships stored in the model. The system monitor retrieves a relationship from the model. The relationship may include the first resource the second resource and the entity linking the first resource with the second resource. The system monitor varies a property of the entity to trigger a state change of the first resource. The system monitor determines whether the state of the second resource changes within a threshold period of time. Finally the system monitor validates the relationship in response to the second resource changing state within the threshold period of time. In some implementations the system monitor purges the relationship when the second resource does not change state with the threshold period of time. Advantageously the system monitor facilitates in maintaining the accuracy of the model by validating the relationships in the model and purging relationships that may be inaccurate or obsolete.

In some implementations the first resource includes a software application. Moreover the entity causing the state change of the first resource includes one of a runtime error a change in processing demand a change in memory demand a change in a number of virtual machines a change in a number of application threads or a change in a number of users using the software application.

Yet another aspect of the disclosure provides a method for updating a model of a distributed system. The method includes detecting using a data processing device a state change of a first resource of a distributed system. The method further includes identifying using the data processing device an entity causing the state change of the first resource. Moreover the method includes determining using the data processing device whether a second resource of the distributed system changes state within a threshold period of time after the first resource changed state. Finally the method includes updating a model stored in non transitory memory in communication with the data processing device to indicate a relationship between the first resource the second resource and the identified entity in response to the first resource and the second resource changing state within the threshold time period. In the method at least one of the first resource and the second resource includes a hardware resource of the distributed system in communication with the data processing device.

In some implementations identifying the entity includes identifying a software resource associated with the first resource and the second resource. In some examples identifying the entity includes identifying a software application executing on a data processing device. In other examples identifying an entity includes identifying an application programming interface stored in the memory. In yet other examples identifying an entity includes identifying a library stored in the memory.

In some implementations identifying the entity includes identifying a hardware resource connected to the first resource and the second resource. In some examples identifying the hardware resource includes identifying a data processing device connected to the first resource via a network.

In some implementations identifying the entity includes identifying an event causing the change in state of the first resource. In other implementations identifying the entity includes receiving via a receiver in communication with the data processing device data indicating the entity causing the change in state of the first resource.

In some implementations the method further includes receiving data from the first resource or the second resource indicating the relationship between the first resource and the second resource. Moreover the method includes updating the model to indicate the relationship between the first resource and the second resource.

In some implementations the method includes receiving a request to determine an impact of a first software service on a second software service. The method further includes determining a first set of resources of the distributed system associated with the first software service. Moreover the method includes determining a second set of resources of the distributed system associated with the second software service. Additionally the method includes retrieving relationships between the first set of resources and the second set of resources from the model. Finally the method includes sending the retrieved relationships in response to the request.

In some implementations the method validates relationships stored in the model. The method for validating relationships includes retrieving a relationship from the model. The relationship may include the first resource the second resource and the entity linking the first resource with the second resource. The method further includes varying a property of the entity to change the first state of the first hardware resource. Moreover determining whether the state of the second resource within the threshold time period. Finally the method includes validating the relationship in response to the second resource changing state within the threshold time period. In some implementations the method includes purging a relationship when the second resource does not change state within the threshold time period.

In some implementations the method includes generating a representation of the model. The method includes receiving a request to return a representation of at least a portion of the model the request originating from a requestor of an organization the organization having several software applications and the request being associated with one of the software applications. The method further includes retrieving relationships affecting the organization from the model. Moreover the method includes categorizing each resource in the retrieved relationships as one of an organization resource an infrastructure resource an application resource or a metadata resource. The method includes categorizing the resource as an organization resource when the resource affects all of the software applications of the organization. Moreover the method includes categorizing the resource as an infrastructure resource when the resource affects some of the software applications of the organization. Additionally the method includes categorizing the resource as an application resource when the resource affects only the software application associated with the request. Finally categorizing the resource as a metadata resource when the resource is available to the software application and the software application can use the resource to store metadata related to other resources. The method concludes by generating a representation of the retrieved and categorized relationships.

In some implementations the method includes displaying a graphical representation of the retrieved and categorized relationships as a directed graph on a display in communication with the data processing device. Moreover the method includes displaying indicia indicating the organization resources the infrastructure resources the application resources and the metadata resources.

In some implementations the distributed system includes resources . The resources may include hardware resources and software resources . The hardware resources may include data processing devices also referred to as computing devices or non transitory memory . The software resources may include software applications software services application programming interfaces APIs or the like. The software resources may reside in the hardware resources . For example the software resources may be stored in the memory or the hardware resources e.g. the computing devices may be executing the software resources

A software application i.e. a software resource may refer to computer software that causes a computing device to perform a task. In some examples a software application may be referred to as an application an app or a program. Example applications include but are not limited to system diagnostic applications system management applications system maintenance applications word processing applications spreadsheet applications messaging applications media streaming applications social networking applications and gaming applications.

The non transitory memory may be physical devices used to store programs e.g. sequences of instructions or data e.g. program state information on a temporary or permanent basis for use by a computing device . The non transitory memory may be volatile and or non volatile addressable semiconductor memory. Examples of non volatile memory include but are not limited to flash memory and read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM e.g. typically used for firmware such as boot programs . Examples of volatile memory include but are not limited to random access memory RAM dynamic random access memory DRAM static random access memory SRAM phase change memory PCM as well as disks or tapes.

Although in the example of the modeling system is shown as being separate from the distributed system in other implementations the modeling system may be a part of the distributed system . In other words the modeling system may be implemented using the resources of the distributed system .

The data processing device may include a graphical user interface GUI a system monitor a resource manager and a timer . The non transitory memory may store a model of the distributed system . The model may store relationships between the resources of the distributed system . The user may access the model via the GUI when the GUI is displayed on the user computer . The system monitor may update the model by modifying existing relationships in the model adding new relationships to the model or purging existing relationships in the model . The system may include one or more sensors in communication with the data processing device for determining state changes of resources of the distributed system . In some examples the system includes a power monitor that monitors a power consumption of a resource and an ammeter that monitors a current draw of a resource . Other sensors are possible as well.

In some implementations to help users manage their applications the system monitor auto detects dependencies within the distributed system and configures deployment pipelines for applications to handle those dependencies sets default system health alerts for developers and or compares similar code of applications and offers suggestions for code optimizations that can be used in multiple components. The system monitor may base its actions on relationships between resources such as virtual machines modules projects etc. and customer primitives such as users teams communities etc. The system monitor may analyze relationships and distances between objects e.g. resources as well as usage patterns and use that information to build heuristics and make intelligent suggestions.

The VM layer includes one or more virtual machines . Each virtual machine may include one or more virtual central processing units vCPUs virtual processor hereinafter . In the example shown a first virtual machine includes a first set of one or more virtual processors and a second virtual machine includes a second set of one or more virtual processors . While the second set is shown as only including one virtual processor any number of virtual processors are possible. Each virtual processor may emulate a physical processor . The first virtual processors emulates a first set of one or more physical processors and the second virtual processor emulates a second set of one or more physical processors . The application layer includes applications that may execute in the virtual machine s .

An example of a measurable characteristic of the first hardware resource is an amount of power consumed by the first hardware resource . The system monitor may detect a state change of the first hardware resource when a change in the amount of power consumed by the first hardware resource exceeds a threshold power change percentage e.g. 50 . In some implementations using the power monitor the system monitor detects a state change of the first hardware resource when the first hardware resource experiences a power spike or a power drop. Additionally or alternatively the system monitor may detect a state change when the first hardware resource experiences a power loss.

In some implementations the system monitor detects a state change of the first hardware resource when a change in the amount of current being drawn by the first hardware resource exceeds a threshold current change percentage e.g. 100 . The distributed system may include an ammeter measuring a current drawn by the first hardware resource . The distributed system may send the measured current to the modeling system via the network .

Another example of a measureable characteristic of the first hardware resource is a processing load of the first hardware resource . The system monitor may determine the processing load of the first hardware resource by determining a percentage of time that the first hardware resource is busy executing instructions during a time period. Alternatively the system monitor may determine the processing load of the first hardware resource by determining a percentage of time that the first hardware resource is idle during a time period i.e. not executing instructions . The system monitor may detect a state change of the first hardware resource when a change in the processing load exceeds a threshold processing change e.g. 80 . Alternatively or additionally the system monitor may detect a state change when the first hardware resource halts the execution of instructions.

Yet another example of a measureable characteristic of the first hardware resource is a memory load of the first hardware resource . The system monitor may determine the memory load of the first hardware resource by determining a percentage of memory of the first hardware resource storing data. The system monitor may detect a state change of the first hardware resource when a change in the memory load exceeds a threshold memory change e.g. 50 . Alternatively or additionally the system monitor may detect a state change when the memory load exceeds a threshold memory load e.g. 99 .

Another example of a measureable characteristic of the first hardware resource is a temperature of the first hardware resource . The distributed system may include a thermometer to measure the temperature of the first hardware resource . The distributed system may periodically send temperature measurements of the first hardware resource to the modeling system . The system monitor may detect a state change when a change in temperature exceeds a threshold temperature change. Alternatively or additionally the system monitor may detect a state change when the temperature exceeds a threshold temperature limit.

Another example of a measureable characteristic of the first hardware resource is a noise level of the first hardware resource . The distributed system may include a noise sensor to measure an amount of noise the first hardware resource produces. The distributed system may periodically send noise measurements of the first hardware resource to the modeling system . The system monitor may detect a state change when a change in noise exceeds a threshold noise change. Alternatively or additionally the system monitor may detect a state change when the noise exceeds a threshold noise limit.

In some implementations the distributed system may include other sensors for detecting any malfunctions in the first hardware resource . The distributed system may send sensor measurements from the sensors to the modeling system . The system monitor may detect a state change in response to the sensor measurements deviating from threshold sensor measurements.

An example of a measureable characteristic of the first software resource is an amount of processing resources the first software resource uses. The system monitor may determine the amount of processing resources the first software resource uses by determining a number of hardware resources executing instructions related to the first software resource . The system monitor may detect a state change in the first software resource when a change in the amount of processing resources exceeds a threshold processing power change e.g. 1000 . As an example if the number of hardware resources executing instructions related to the first software resource increases by a factor of ten within a very short period of time then the system monitor may detect a state change in the first software resource

In some implementations the system monitor may detect a state change of the first software resource based on a change in the number of virtual machines executing instructions related to the first software resource . The system monitor detects a state change of the first software resource when the change in the number of virtual machines executing the first software resource exceeds a threshold virtual machine change e.g. 1000 . As an example if the number of virtual machines executing instructions related to the first software resource increases by a factor of ten within a very short period of time then the system monitor may detect a state change in the first software resource

Referring also to the system monitor may detect a state change of the first software resource based on a change in the number of application threads associated with the first software resource . The system monitor detects a state change of the first software resource when the change in the number of application threads exceeds a threshold application thread change e.g. 1000 . As an example if the number of application threads associated with the first software resource increases by a factor of ten within a very short period of time then the system monitor may detect a state change in the first software resource

In the example shown in a first application having application threads executes in a first virtual machine and a second application having application threads executes in a second virtual machine . In some implementations the application threads are separable or divisible chunks of the application that can be executed on different virtual processors . The application may identify the application threads or alternatively the virtual machine executing the application may identify the application threads in the application . The application may identify the application threads by separating the application threads with a marker. Additionally or alternatively the application may specify the number of application threads for example as metadata. By segregating the application into separately executable application threads the application can be executed using multiple virtual processors .

In the example shown the first application may require more virtual processors than the second application . Accordingly the first virtual machine executing the first application with more application threads includes a first set of three virtual processors whereas the second virtual machine executing the second application with fewer application threads includes a second set of only a single virtual processor . The first virtual machine allocates the application threads of the first application to each of the virtual processors in the first virtual machine . Since the first set of virtual processors emulates the corresponding first set of physical processors once the first virtual machine allocates the first application threads to the associated virtual processors the first set of physical processors execute the allocated application threads

In some implementations the number of application threads may vary while the virtual machine executes the application . In some scenarios the number of application threads may increase. The number of application threads may increase for a variety of reasons for example more users may start using the application the application may be receiving more data from the user or the application may be performing a task that requires more application threads . If the number of application threads increases and the number of virtual processors remains constant then the existing virtual processors handle the additional application threads . The system monitor may detect the increased load of application threads on the virtual processors and cause allocation of additional virtual processors to handle the increased load of application threads .

In some implementations the system monitor detects a state change of the first software resource based on a change in an amount of memory that the first software resource uses. If the change in memory usage exceeds a threshold memory change e.g. 1000 then the system monitor may detect a state change of the first software resource . In some implementations the system monitor detects a state change of the first software resource in response to an error in executing instructions related to the first software resource for example a run time error. The system monitor may detect a state change of the first software resource if the first software resource crashes or stops executing. In some implementations the system monitor detects a state change when a number of users using the first software resources increases beyond a threshold number of users e.g. more than 100 million users .

Referring again to in some implementations the resource manager e.g. executing on a hardware resource monitors activities of software resources . The resource manager may for example monitor the amount of memory being used by a software resource and or the amount of processing resources being used by a software resource . Moreover the resource manager may monitor the number of virtual machines executing a software resource . The resource manager communicates any changes in the activities of software resources to the system monitor .

Referring again to at the system monitor identifies an entity causing the state change of the first resource . In some implementations the system monitor identifies the entity as the measurable characteristic that triggered the state change. For example if a change in the amount of power that the first hardware resource consumes triggered the state change then the system monitor may identify power as the entity causing the state change. Similarly if a change in the temperature of the first hardware resource triggered the state change then the system monitor may identify temperature as the entity causing the state change.

In some implementations the system monitor identifies the entity as a resource interacting with the first resource immediately before the state change. The system monitor may identify the entity as a software resource executing on the first hardware resource immediately before the state change. In additional examples the system monitor identifies the entity as a software resource storing data in the first hardware resource immediately before the state change.

At the system monitor determines whether a second resource of the distributed system changes state. The system monitor may detect a state change of the second resource in the same way the system monitor detects state changes of the first resource . In some implementations the system monitor identifies a second resource that has experienced a similar type of state change as the first resource . For example if the first resource changed state due to a power surge then the system monitor identifies a second resource that changed states due to a power surge. Similarly if the first resource changed states due to a sudden increase in the number of virtual machines then the system monitor identifies a second resource that changed states due to an increase in the number of virtual machines . In other implementations the type of state change of the first resource and the second resource may be different.

At the system monitor determines whether the state changes of the first resource and the second resource occurred within a threshold time. The system monitor may use the timer to record a first time at which the state change of the first resource occurred and a second time at which the state change of the second resource occurred. The system monitor may determine a difference between the first time and the second time. The system monitor may then compare the difference with the threshold time. In some implementations if the difference is less than the threshold time then the system monitor determines that there is a relationship between the first resource and the second resource . The system monitor may further determine that the relationship between the first resource and the second resource is caused by the entity triggering the state changes.

At the system monitor updates the model stored in the memory to indicate the relationship between the first resource the second resource and the entity triggering the state changes. The system monitor may update the model by adding a new record in the model to indicate the relationship.

At the system monitor determines a first set of resources of the distributed system that are associated with the first software service . In some implementations the system monitor may determine a list of hardware resources and a list of software resources that are used by the first software service . At the system monitor determines a second set of resources of the distributed system associated with the second software service . In some implementations the system monitor may provide a list of hardware resources and software resources that execute instructions related to the second software service

At the system monitor retrieves relationships between the first set of resources and the second set of resources from the model . At the system monitor sends the retrieved relationships to the requestor via the transceiver . By sending the relationships between the first set and the second set the system monitor notifies the requestor the ways in which the first software service may impact the second software service . If the system monitor determines that there are no relationships between the first set and the second set then the system monitor may notify the requestor that the first software service does not impact the second software service

In some implementations the system monitor may identify alternative resources that are available to the first software service and that would eliminate or reduce the impact on the second software service . Advantageously the requestor may migrate the first software service to the alternative resources so that the first software service does not impact the second software service . In other implementations the system monitor may provide a list of alternative resources that the first software service may use to reduce the impact of the first software service on the second software service

At the system monitor varies a property of the linking entity to trigger a state change of the first resource . For example if the linking entity is power surge then the system monitor causes a power surge to trigger a state change of the first resource . In other examples if the linking entity is processing load then the system monitor may increase the processing load of the first resource to trigger a state change of the first resource . The system monitor may increase the processing load of the first resource by assigning computationally intensive processing jobs to the first resource

At the system monitor determines whether the state of the second resource changes within a threshold period of time after the first resource changes state. If the second resource changes state within the threshold period of time then at the system monitor validates the relationship. If the second resource does not change state within the threshold period of time then the system monitor may purge the relationship at .

As the distributed system changes over time some relationships in the model may change as well. For example as the number of hardware resources increases in the distributed system the impact of a current spike may be dampened because there are more hardware resources to withstand the current spike. Due to the dynamic nature of relationships it is beneficial to verify the relationships from time to time and update the model as needed. Advantageously by validating and purging the relationships in the model the system monitor keeps the model updated.

The distributed system may include multiple layers of redundancy where data is replicated and or encoded and stored in multiple data centers. Data centers not shown house computer systems and their associated components such as telecommunications and storage systems. Data centers usually include backup power supplies redundant communications connections environmental controls to maintain a constant temperature and security devices. Data centers may be large industrial scale operations that use a great amount of electricity e.g. as much as a small town . Data centers may be located in different geographical locations e.g. different cities different countries and different continents . In some examples the data centers or portions thereof requires maintenance e.g. due to a power outage or disconnecting a portion of the storage system for replacing parts or a system failure or a combination thereof . The data stored in these data centers and in particular the distributed system may be unavailable to users clients during the maintenance period resulting in the impairment or halt of a user s operations. Therefore it is desirable to provide a distributed system capable of efficiently using the storage resources of the hardware resources during maintenance and or certain data center hardware software failures without moving the data in advance of such a maintenance or failure. The system may adjust a load of the available resources and jobs of the adjusted load may be executed in a predefined order such as high availability jobs before the low availability jobs.

In some implementations the distributed system is single sided eliminating the need for any server jobs for responding to remote procedure calls RPC from clients to store or retrieve data on their corresponding hardware resources and may rely on specialized hardware to process remote requests instead. Single sided refers to the method by which most of the request processing on the hardware resources may be done in hardware rather than by software executed on physical processors of the hardware resources . Rather than having a physical processor of a hardware resource e.g. a server execute a server process that exports access of the corresponding storage resource e.g. non transitory memory to client processes executing on the clients the clients may directly access the storage resource through a network interface controller NIC of the hardware resource . In other words a client process executing on a client may directly interface with one or more storage resources without requiring execution of a routine of any server processes executing on the physical processors .

This single sided distributed storage architecture offers relatively high throughput and low latency since clients can access the storage resources without interfacing with the physical processors of the hardware resources . This has the effect of decoupling the requirements for storage and CPU cycles that typical two sided distributed systems carry. The single sided distributed system can utilize remote storage resources regardless of whether there are spare CPU cycles on that hardware resource furthermore since single sided operations do not contend for server physical processor resources a single sided system can serve cache requests with very predictable low latency even when hardware resources are running at high CPU utilization. Thus the single sided distributed system allows higher utilization of both cluster storage and physical processor resources than traditional two sided systems while delivering predictable low latency.

In some implementations the distributed system includes a storage logic portion e.g. encoding system a data control portion and a data storage portion. The storage logic portion may include a transaction application programming interface API e.g. a single sided transactional system client library that is responsible for accessing the underlying data for example via RPC or single sided operations. The data control portion may manage allocation and access to storage resources with tasks such as allocating storage resources registering storage resources with the corresponding network interface controller setting up connections between the client s and the hardware resources handling errors in case of machine failures etc. The data storage portion may include the loosely coupled hardware resources

The distributed system may store data in dynamic random access memory DRAM and serve the data from the remote hardware resource via remote direct memory access RDMA capable network interface controllers . A network interface controller also known as a network interface card network adapter or LAN adapter may be a computer hardware component that connects a physical processor to the network . Both the hardware resources and the clients may each have a network interface controller for network communications. A host process executing on the physical processor of the hardware resource registers a set of remote direct memory accessible regions of the memory with the network interface controller . The host process may register the remote direct memory accessible regions of the memory with a permission of read only or read write. The network interface controller of the hardware resource creates a client key for each registered memory region 

The single sided operations performed by the network interface controllers may be limited to simple reads writes and compare and swap operations none of which may be sophisticated enough to act as a drop in replacement for the software logic implemented by a traditional cache server job to carry out cache requests and manage cache policies. The transaction API translates commands such as look up or insert data commands into sequences of primitive network interface controller operations. The transaction API interfaces with the data control and data storage portions of the distributed system .

The distributed system may include a co located software process to register memory for remote access with the network interface controllers and set up connections with client processes . Once the connections are set up client processes can access the registered memory via engines in the hardware of the network interface controllers without any involvement from software on the local physical processors of the corresponding local hardware resources

In the example of the distributed system includes a first hardware resource and a second hardware resource . The first hardware resource includes a first physical processor a first memory and a first NIC . Similarly the second hardware resource includes a second physical processor a second memory and a second NIC . The distributed system may include a remote hardware resource . The remote hardware resource may be located at a different location that the first hardware resource and the second hardware resource e.g. in a different city state country or continent . The remote hardware resource includes a remote physical processor a remote memory and a remote NIC

The second memory stores a model . The model stores relationships between the resources of the distributed system . The second physical processor implements a system monitor that manages the model . The system monitor can update the model by modifying existing relationships stored in the model purging existing relationships stored in the model or adding new relationships to the model . The first processor implements a model interface . The model interface can access the model even though the model interface and the model are in different hardware resources . Further the model interface may access the model directly through the NIC without communicating with the second physical processor . Advantageously the model interface can access the model even when the second physical processor may be unavailable or busy. The clients can access the model through the model interface .

The system monitor can detect state changes in resources including hardware resources and software resources stored in the remote memory . The system monitor may detect state changes of the software resources via the remote NIC without communicating with the remote physical processor . Advantageously the system monitor can detect state changes of the software resources even when the remote physical processor is unavailable or busy. In the example of the distributed system is configured to maintain and update the model . In other words unlike the example system depicted in the modeling system is a part of the distributed system .

In the example of the model interface categorizes the resources into four categories organization resources infrastructure resources application resources and metadata resources . Other categories are also contemplated for example package resources virtual machine resources overflow resources etc.

An organization may have several software applications. Some resources may be available to all the software applications of the organization. The model interface may categorize resources that are available to and or utilized by all software applications of the organization as organization resources . Some resources may be available to some of the software applications but not all of the software applications. The model interface may categorize resources that are available to and or utilized by some software applications but not all software applications as infrastructure resources . Some resources may be available to and or utilized by a single software application and not by other software applications. The model interface may categorize resources that are used by and or utilized by a single software application and not by other software applications as application resources . Some resources may be available to a software application for the software application to store metadata related to other resources . The model interface may categorize resources that are available to a software application for storing metadata as metadata resources . In some examples a metadata resource may include an overflow resource that may be available to a software application but the software application may not be using. The model interface may categorize resources that are available to a software application but not being used by the software application as overflow resources.

In the example of organization resources include users . The model interface categorizes the users as organization resources because the users can access all resources within the organization. The users are members of a developer group . The model interface categorizes the developer group as an organization resource because the developers in the developer group can develop applications for the organization. The developer group is a member of the organization . The organization owns applications .

In the example of there are three applications a first application a second application and a third application . The first application and the second application use a database . The model interfaced categorizes the database as an infrastructure resource and not an organization resource because the database is used by some applications i.e. the first application and the second application but not by all applications i.e. not by the third application . The second application manages virtual machines . The model interface categorizes the virtual machines as application resources because the virtual machines are only used by a single application the second application

The virtual machines execute an image . The image may be an image of an operating system for example Ubuntu. The image includes an image folder . The image may include a package e.g. a mail package that is used to send e mail . The model interface categorizes the image the image folder and the package as application resources because only the second application has access to the image the image folder and the package .

The package has access to a buffer overrun resource . The model interface categorizes the buffer overrun resource as a metadata resource because the package does not routinely use the buffer overrun resource but the buffer overrun resource is available to the package in case of a buffer overrun event. The buffer overrun resource may include an overflow folder . Further the buffer overrun resource can store metadata related to the package . For example the buffer overrun resource may store information indicating that the package has a security leak and the security leak is causing a buffer overrun.

In the example of the model interface displays the representation of the model as a directed graph in which the model interface displays the resources as nodes of a directed graph. The model interface further displays directed arrows extending between the nodes. In other implementations the model interface may display the representation as a Venn diagram in which the metadata resources may be included inside the application resources the application resources may be included inside the infrastructure resources and the infrastructure resources may be included inside the organization resources

At the model interface retrieves relationships effecting the organization from the model . The model interface may retrieve the relationships from the model using RDMA through the second NIC so that the model interface does not have to interact with the second physical processor . At the model interface categorizes the resources in the relationships.

At the model interface determines whether a particular resource affects all the software applications of the organization. If the resource affects all the software applications of the organization then the model interface categorizes the resource as an organization resource

At the model interface determines whether the resource affects some software applications but not all software applications in the organization. At the model interface categorizes the resource as an infrastructure resource when the resource effects some but not all of the applications. For example the database that affects the first application and the second application but not the third application

At the model interface determines whether the resource affects only the software application e.g. the second application associated with the request. At the model interface categorizes the resource as an application resource when the resource effects only the software application associated with the request. For example the virtual machines that affect only the second application and not the first application and the third application

At the model interface determines whether the resource is available to a software application but is not currently being used by the software application. At the model interface categorizes the resource as a metadata resource in response to the resource being available to the software application associated with the request for storing metadata information related to other resources . For example the buffer overrun resource that is available to the software application to store metadata information related to the package . Additionally or alternatively the model interface may categorize the resource as an overflow resource in response to the resource being available to the software application associated with the request but the software application not currently using the resource. For example the buffer overrun resource that is available to the package and the second application but the second application may not be using the buffer overrun resource at the time of the request. At the model interface generates the representation of the model for example the representation depicted in .

The model interface may include indicia for indicating the different categories of resources . In some implementations the model interface uses different colors to indicate the different categories of resources . For example the model interface may display the organization resources in blue the infrastructure resources in green the application resources in black and the metadata resources in red. In some examples the model interface may use different backgrounds different fonts or different shapes to indicate the different categories of resources. In some implementations the model interface may categorize the resource into other categories. For example the model interface may categorize some resources as package resources when only one package uses the resource. In other examples the model interface may categorize some resources as virtual machine resources when only one virtual machine uses the resource. Other categories are also contemplated.

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium and computer readable medium refer to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Moreover subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter affecting a machine readable propagated signal or a combination of one or more of them. The terms data processing apparatus computing device and computing processor encompass all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also known as an application program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user one or more aspects of the disclosure can be implemented on a computer having a display device e.g. a CRT cathode ray tube LCD liquid crystal display monitor or touch screen for displaying information to the user and optionally a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

One or more aspects of the disclosure can be implemented in a computing system that includes a backend component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a frontend component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such backend middleware or frontend components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN an inter network e.g. the Internet and peer to peer networks e.g. ad hoc peer to peer networks .

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. In some implementations a server transmits data e.g. an HTML page to a client device e.g. for purposes of displaying data to and receiving user input from a user interacting with the client device . Data generated at the client device e.g. a result of the user interaction can be received from the client device at the server.

While this specification contains many specifics these should not be construed as limitations on the scope of the disclosure or of what may be claimed but rather as descriptions of features specific to particular implementations of the disclosure. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub combination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a sub combination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multi tasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly other implementations are within the scope of the following claims.

