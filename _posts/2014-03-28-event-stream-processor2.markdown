---

title: Event stream processor
abstract: In an example embodiment, a method for performing event stream processing is provided. An event stream is received, the event stream comprising a real time indication of one or more events occurring. Then it is determined that the event stream is identified in a streaming publish service inside a database. The event stream may then be inserted directly into one or more database tables in the database based on the determining.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09558225&OS=09558225&RS=09558225
owner: SYBASE, INC.
number: 09558225
owner_city: Dublin
owner_country: US
publication_date: 20140328
---
This application claims priority to U.S. Provisional Application No. 61 916 522 filed Dec. 16 2013 which is hereby incorporated herein by reference in its entirety.

This document generally relates to systems and methods for use with event streams. More specifically this document relates to methods and systems for event stream processing.

Event stream processing ESP is a set of technologies designed to assist the construction of event driven information systems. ESP technologies may include event visualization event databases event driven middleware and event processing languages or complex event processing CEP . ESP deals with the task of processing multiple streams of event data with the goal of identifying the meaningful events within those streams. ESP enables applications such as algorithmic trading in financial services radio frequency identification RFID event processing applications fraud detection process monitoring and location based services in mobile devices. ESP is generally limited to analyzing limited amounts of data specifically current ESP solutions are limited to analyzing the event streams in real time e.g. the events happening right now and events stored for limited windows e.g. events that have happened in the last minute .

The description that follows includes illustrative systems methods techniques instruction sequences and computing machine program products that embody illustrative embodiments. In the following description for purposes of explanation numerous specific details are set forth in order to provide an understanding of various embodiments of the inventive subject matter. It will be evident however to those skilled in the art that embodiments of the inventive subject matter may be practiced without these specific details. In general well known instruction instances protocols structures and techniques have not been shown in detail.

In an example embodiment a number of solutions are provided that allow ESP to be more fully integrated with and or communicate with a database. This allows for ESP systems to perform complex analysis on data drawn from not only real time event data and windows but also from stored database information.

The ESP engine may also communicate with an internal database A. In an example embodiment the internal database A includes a streaming publish subscription service to perform complex analysis on data drawn from stored database information. The streaming publish subscription service is described in greater detail below in conjunction with . While this database A is labeled as internal it is possible that the database A resides on separate hardware than the ESP engine . The distinction between an internal database A and external database A C is that the internal database A may be more natively supported for communication purposes with the ESP engine . In an example embodiment the internal database A and ESP engine are both designed by the same software provider whereas the external databases A C are designed by other software providers. The communication between the ESP engine and the internal database A may be performed via one or more output adapters . It should be noted that in some example embodiments the output adapters may not be necessary . Additionally the ESP engine may communicate with for example operational applications B spreadsheets or visualization applications C and reporting business intelligence BI tools D.

In an example embodiment the internal database A is an in memory database. An in memory database is a database management system that primarily relies on main memory for computer data storage. It is contrasted with database management systems that employ a disk storage mechanism.

Also depicted is a studio used to perform modeling by accessing the in memory database management system . In an example embodiment integration of ESP functionality e.g. ADD into the internal database occurs through studio . The studio can allow complex analysis to be performed on data drawn from not only real time event data and windows but also from stored database information.

The in memory database management system may comprise a number of different components including index server XS engine statistics server preprocessor server and name server . These components may operate on a single computing device or may be spread among multiple computing devices e.g. separate servers .

The index server contains the actual data and the engines for processing the data. It also coordinates and uses all the other servers.

The XS engine allows clients to connect to the database system using web protocols such as Hypertext Transfer Protocol HTTP .

The statistics server collects information about status performance and resource consumption from all the other server components. The statistics server can be accessed from the studio to obtain the status of various alert monitors.

The preprocessor server is used for analyzing text data and extracting the information on which the text search capabilities are based.

The name server holds information about the database topology. This is used in a distributed system with instances of the database on different hosts. The name server knows where the components are running and which data is located on which server.

The client requests can be analyzed and executed by a set of components summarized as request processing and execution control . The SQL processor checks the syntax and semantics of the client SQL statements and generates a logical execution plan. Multidimensional expressions MDX is a language for querying and manipulating multidimensional data stored in OLAP cubes. As such an MDX engine is provided to allow for the parsing and executing of MDX commands. A planning engine allows applications e.g. financial planning applications to execute basic planning operations in the database layer. One such operation is to create a new version of a dataset as a copy of an existing dataset while applying filters and transformations.

A calc engine implements the various SQL script and planning operations. The calc engine creates a logical execution plan for calculation models derived from SQL script MDX planning and domain specific models. This logical execution plan may include for example breaking up a model into operations that can be processed in parallel.

Each SQL statement may be processed in the context of a transaction. New sessions are implicitly assigned to a new transaction. The transaction manager coordinates database transactions controls transactional isolation and keeps track of running and closed transactions. When a transaction is committed or rolled back the transaction manager informs the involved engines about this event so they can execute needed actions. The transaction manager also cooperates with a persistence layer to achieve atomic and durable transactions.

An authorization manager is invoked by other database system components to check whether the user has the specified privileges to execute the requested operations. The database system allows for the granting of privileges to users or roles. A privilege grants the right to perform a specified operation on a specified object.

The persistence layer ensures that the database is restored to the most recent committed state after a restart and that transactions are either completely executed or completely undone. To achieve this goal in an efficient way the persistence layer uses a combination of write ahead logs shadow paging and save points. The persistence layer also offers a page management interface for writing and reading data to a separate disk storage and also contains a logger that manages the transaction log. Log entries can be written implicitly by the persistence layer when data is written via the persistence interface or explicitly by using a log interface.

L infrastructure includes a number of components to aid in the running of L procedures including L runtime system mode L compiler and L runtime User mode .

As described briefly earlier in an example embodiment aspects of an ESP engine are integrated into an internal database such as an in memory database. Integrating these aspects of an ESP engine into the internal database allows the user to seamlessly develop applications that contain traditional database as well as streaming capabilities.

In an example embodiment the internal database provides a streaming publish service. This service allows continuous publishing of events directly into database tables in the internal database. This service may be optimized for high insert performance by buffering incoming data into multiple batches to avoid the overhead of single inserts and inserting batches in parallel against multiple table partitions. The user can configure the batch size to trade off insert performance and insert latency. The ESP engine may then utilize the publish service of the internal database to publish output streams directly into the internal database.

In another example embodiment the internal database may also provide a streaming subscription service . The service allows an ESP engine to subscribe to multiple different types of events. For example the ESP engine may subscribe to two different types of events. The first type of event can be table content. The content of any table in storage can be streamed out to the subscribing ESP engine. Any new data added to the table can also be streamed out as well. Table content can also optionally be filtered. The second type of event can be table content changes. The changes to a table can be streamed out to a subscribing ESP engine. Each event may contain the new table record as well as a field indicating whether the change was an insert update or delete.

The ESP engine can then use the streaming subscription service to offer an additional input stream into the ESP engine for the table content and or table content changes.

As described earlier traditional ESP functionality allows for event data to be analyzed in the form of both real time streams and windows. Traditional ESP functionality also includes the ability to join streams and windows. In an example embodiment through data integration the ESP can also allow joining streams and windows with database tables. This allows for the possibility of including persisted data in real time continuous queries.

ESP may access the table data during joins as needed and fetch table data in real time. Alternatively table data may be cached based on user configuration.

Furthermore traditional ESP functionality supports ad hoc SQL queries into windows where the window content at the time of the query behaves like a database table. In an example embodiment with data integration the user can submit ad hoc SQL queries into the database that not only contain tables but also ESP windows using a single SQL command.

In an example embodiment to support seamless development of applications with streaming and persisted data a single tool is provided that offers traditional streaming features such as creation of streaming models debugging of streaming data flows playback etc. as well as traditional persisted data features such as a SQL command interface a query plan visualizer etc.

In addition a central mechanism may be provided to configure connectivity into the internal database. That connectivity is then used both for database tooling functionality as well as for streaming events from the ESP engine into the internal database.

In an example embodiment a central explorer may be provided to list all available tables in the internal database. In order to publish events from an ESP engine into an internal database table the user can directly drag a table from the explorer onto an ESP model.

Changes to the event schema e.g. structure of an event for streams windows that publish into a table can be propagated automatically into the matching database schema. Correspondingly changes to a database schema can be propagated automatically into the matching event schema.

Artifacts of a traditional database application such as tables procedures etc. can be packaged together with a streaming project streaming model plus deployment configuration in a development package. The development package thus allows one step deployment of applications that leverage both streaming and persisted data.

In another example embodiment in order to support seamless monitoring and administration of applications with streaming and persisted data a single tool may be provided that offers traditional streaming features monitor streams start stop streaming projects etc. as well as traditional persisted data features monitor SQL query execution times submit SQL query etc. . The entry point in the tool may be a diagram presenting the data flow through streams windows into one or multiple databases. The user can review overall monitoring tasks e.g. project throughput and perform overall administration tasks e.g. stop streaming project from this overview diagram. For more specific tasks such as queue depths of a specific stream size of a table etc. the user can drill down into the participating components.

In an example embodiment integration of ESP functionality e.g. streaming publication subscription into the internal database occurs through a studio program such as studio of . The studio may be modified to allow such ESP functionality. is a screen capture illustrating a studio interface in accordance with an example embodiment. In the studio interface a database diagram may be provided where the data flow between input streams A B C and databases A B C may be presented.

In an example embodiment each selectable item in the visual editor may be a candidate for a tabbed user interface UI property page. In an example embodiment there are four different types of tabs that can appear. The first is called a General Tab and contains the most common properties that can be edited for the selected element. Another tab is a Read Only tab that shows only read only text fields for the location and stereotype of the element. A Comment tab may contain a single text field used to add a comment to the associated element. An Expression tab may then be used by certain elements described below and contains a single text field used to edit an expression block of the selected element.

When an element is selected the tabbed properties window may display a header containing an icon and a name label for the selected element as well as the tabs associated with the element. is a screen capture illustrating a tabbed property sheet for a window shape in accordance with an example embodiment.

As described above in an example embodiment a new element in ESP is provided that will allow users to establish a reference to an in memory database table in an ESP model. Users will be able to use this reference to provide user input to define join conditions with regular ESP windows and streams.

The reference may be an ESP element similar to what streams windows are. This new reference element then can be used to receive user input that defines selects a database service the name of the table from which information should be retrieved the schema of the information in the reference table and optionally specify a primary key for the reference table. The reference can be enabled for example based on user input to attempt reconnection to the database when a connection is lost during data flow. The system can receive user input that specifies the number of times to retry and how long to wait between retry attempts.

When a customer such as a user wishes to enrich streaming data with information from a database they may need information about the table in the database from which the information will be retrieved. The customer may define a new reference in their project to represent this database table. The reference can be dropped into the project from the studio palette. After dropping down the reference the user may add a service entry that represents the database in which this table is stored. Once the service entry is specified the user can select from a list of the tables in the database. Once an individual table is specified the user will have the opportunity to select individual columns in the table that will be represented in the schema of the reference. The studio may also be able to detect the primary key on the database table if it exists and provide the primary key to the user. The primary key of a reference matches the primary key on the underlying database table. If the user does not wish to use the studio the reference can be created by editing ESP directly.

Once the reference is defined the customer can use it in joins to produce either a stream or a window. Typical use cases for these joins would involve data lookup and enrichment. The reference may only be used in joins and cannot be selected from directly by derived elements.

Users will be able to create a reference in their modules but the syntax inside a module will only allow the user to specify the schema and primary key information. Any reference created inside a module will need to be bound to a concrete reference at module load time. This will work similarly to the way stores are bound in modules today.

Upon startup of the project the reference would validate that the schema provided by the user for the reference is valid. In order for a schema to be valid the column names in the schema should match columns in the source database table and the types should be compatible. If the user specifies a primary key for the reference it too can be validated to make sure it matches the primary key of the underlying source. If the primary key of the underlying source cannot be determined or does not match what was specified then it can be flagged as an error. If the reference could not connect to the database at startup the specified table did not exist or the schema was incompatible the user could see an error message in the log and the project may stop.

For each record that arrives to the join the reference can query the database specified to retrieve appropriate records to match the join condition. If the database connection goes down and retries if any fail the join need not process the row. If the bad records behavior is activated the record triggering the join can be written to a file and to the error stream similarly to what happens today with windows and bad records.

As described above this feature may necessitate the definition of a new ESP object called a reference and call for changes to the existing syntax for creating and loading modules. In an example embodiment ESP syntax will be added that allows the user to define a reference in their project. The syntax of the reference object can be different between the main project and a module.

Note that in a Reference Table the schema clause may not be optional and might not be deduced like in derived windows streams. When defining a concrete instance of a reference in a project not inside a module the column names in the reference s schema should match the database column names exactly. When the schema is defined in a module they need not match the names to which the reference will be bound at module load time. The data types and order of the schema between the reference in the module and the reference to which it is bound should match i.e. same number of columns and same datatypes . The primary keys of the reference in the module should refer to the same columns that make up the primary key in the reference to which it is bound.

The PRIMARY KEY clause is optional and the lack of a primary key clause means the reference does not contain a primary key i.e. will not be able to produce a join window . A database table without a primary key will affect the types of joins this reference table can participate in.

In an example a customer table exists in an external database. The table in the database called customerTable includes a customer ID and the customer s full name address and other details. The primary key of the database table is the customerID column. The user wishes to process streaming orders from customers who are identified in the source stream by their customer ID and join it with the customer information to produce an output stream. The output stream will contain the order ID along with the customer s full name and address that was pulled from the database table when the order came through.

When creating a new module the user may be instructed to list all of the references created in that module in the CREATE MODULE statement. In order to allow this a new optional clause called REFERENCES may be added.

The new REFERENCES clause is optional but should be specified if there are any references in the module. If there are no references in the module the clause may not be specified. The name of every reference defined in the module should be listed in the comma delimited list of the clause.

The REFERENCES clause may be added to the load module statement. This clause should not be specified if there are no references in the module being loaded. If there are references in the module being loaded the clause should be present and contain a comma delimited list of bindings between references in the module to references in the parent module or project . There should be a binding specified for every reference in the module. The reference to which each reference in the module is bound should be compatible. A reference may be bound to a reference in the project if the schema and primary key are compatible. A compatible schema means that the number order and type of the data types in the schema are identical. The names do not need to match. The primary key is compatible if the primary key on the reference in the module may point to the same columns as the primary key in the reference to which it is bound.

A REFERENCE may be query able from SPLASH code similar to the way windows can be queried. Users may need to retrieve an iterator over the REFERENCE and then iterate over the rows.

The reference provides the ability to join an ESP window or stream with data from a database system table or view . When defining the schema for the reference in ESP the user may match the column names in the schema to the column names in the database. If the names do not match an error may be output to the logs at runtime and the project will not run.

In an example embodiment a reference is not joined directly with another reference. In a multi table join multiple references can be involved as long as they are not directly joined.

When using a reference that doesn t have a primary key in a join in some example embodiments there can be at most one streaming element stream window or delta stream with a keep clause in the join.

In an example embodiment there may be some restrictions that will be enforced by the compiler when defining a join that involves a reference. These are described in Table 3 below 

In an example embodiment an additional property can be added to references known as sourceschema. This property can be set via the reference tabbed property page. The studio can provide the ability to discover sourceschemas at a given service using the database adapter API. If the sourceschema property is set then during table discovery the studio can pass the sourceschema value in order to return discovered tables at the specific schema. is a screen capture illustrating a user interface in accordance with another example embodiment. As can be seen the sourceschema property may be set via the reference tabbed property page .

Certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code embodied 1 on a non transitory machine readable medium or 2 in a transmission signal or hardware implemented modules. A hardware implemented module is a tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. a standalone client or server computer system or one or more processors may be configured by software e.g. an application or application portion as a hardware implemented module that operates to perform certain operations as described herein.

In various embodiments a hardware implemented module may be implemented mechanically or electronically. For example a hardware implemented module may comprise dedicated circuitry or logic that is permanently configured e.g. as a special purpose processor such as a field programmable gate array FPGA or an application specific integrated circuit ASIC to perform certain operations. A hardware implemented module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware implemented module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

Accordingly the term hardware implemented module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily or transitorily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein. Considering embodiments in which hardware implemented modules are temporarily configured e.g. programmed each of the hardware implemented modules need not be configured or instantiated at any one instance in time. For example where the hardware implemented modules comprise a general purpose processor configured using software the general purpose processor may be configured as respective different hardware implemented modules at different times. Software may accordingly configure a processor for example to constitute a particular hardware implemented module at one instance of time and to constitute a different hardware implemented module at a different instance of time.

Hardware implemented modules can provide information to and receive information from other hardware implemented modules. Accordingly the described hardware implemented modules may be regarded as being communicatively coupled. Where multiple of such hardware implemented modules exist contemporaneously communications may be achieved through signal transmission e.g. over appropriate circuits and buses that connect the hardware implemented modules . In embodiments in which multiple hardware implemented modules are configured or instantiated at different times communications between such hardware implemented modules may be achieved for example through the storage and retrieval of information in memory structures to which the multiple hardware implemented modules have access. For example one hardware implemented module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware implemented module may then at a later time access the memory device to retrieve and process the stored output. Hardware implemented modules may also initiate communications with input or output devices and can operate on a resource e.g. a collection of information .

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments comprise processor implemented modules.

Similarly the methods described herein may be at least partially processor implemented. For example at least some of the operations of a method may be performed by one or more processors or processor implemented modules. The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the processor or processors may be located in a single location e.g. within a home environment an office environment or as a server farm while in other embodiments the processors may be distributed across a number of locations.

The one or more processors may also operate to support performance of the relevant operations in a cloud computing environment or as a software as a service SaaS . For example at least some of the operations may be performed by a group of computers as examples of machines including processors these operations being accessible via a network e.g. the Internet and via one or more appropriate interfaces e.g. application program interfaces APIs . 

Example embodiments may be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Example embodiments may be implemented using a computer program product e.g. a computer program tangibly embodied in an information carrier e.g. in a machine readable medium for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers.

A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

In example embodiments operations may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method operations can also be performed by and apparatus of example embodiments may be implemented as special purpose logic circuitry e.g. a field programmable gate array FPGA or an application specific integrated circuit ASIC .

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. In embodiments deploying a programmable computing system it will be appreciated that that both hardware and software architectures merit consideration. Specifically it will be appreciated that the choice of whether to implement certain functionality in permanently configured hardware e.g. an ASIC in temporarily configured hardware e.g. a combination of software and a programmable processor or a combination of permanently and temporarily configured hardware may be a design choice. Below are set out hardware e.g. machine and software architectures that may be deployed in various example embodiments.

The example computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes an alphanumeric input device e.g. a keyboard or a touch sensitive display screen a user interface UI navigation or cursor control device e.g. a mouse a disk drive unit a signal generation device e.g. a speaker and a network interface device .

The disk drive unit includes a machine readable or computer readable medium on which is stored one or more sets of data structures and instructions e.g. software embodying or utilized by any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable or computer readable media .

While the machine readable or computer readable medium is shown in an example embodiment to be a single medium the term machine readable medium may include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more instructions or data structures. The terms machine readable medium and computer readable medium shall also be taken to include any tangible medium that is capable of storing encoding or carrying instructions for execution by the machine and that causes the machine to perform any one or more of the methodologies of the present disclosure or that is capable of storing encoding or carrying data structures utilized by or associated with such instructions . The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media. Specific examples of machine readable media include non volatile memory including by way of example semiconductor memory devices e.g. erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks.

The instructions may further be transmitted or received over a communications network using a transmission medium. The instructions may be transmitted using the network interface device and any one of a number of well known transfer protocols e.g. HTTP . Examples of communication networks include a local area network LAN a wide area network WAN the Internet mobile telephone networks plain old telephone POTS networks and wireless data networks e.g. WiFi and WiMax networks . The term transmission medium shall be taken to include any intangible medium that is capable of storing encoding or carrying instructions for execution by the machine and includes digital or analog communications signals or other intangible media to facilitate communication of such software.

Although an embodiment has been described with reference to specific example embodiments it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the disclosure. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense. The accompanying drawings that form a part hereof show by way of illustration and not of limitation specific embodiments in which the subject matter may be practiced. The embodiments illustrated are described in sufficient detail to enable those skilled in the art to practice the teachings disclosed herein. Other embodiments may be utilized and derived therefrom such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. This Detailed Description therefore is not to be taken in a limiting sense and the scope of various embodiments is defined only by the appended claims along with the full range of equivalents to which such claims are entitled.

Such embodiments of the inventive subject matter may be referred to herein individually and or collectively by the term invention merely for convenience and without intending to voluntarily limit the scope of this application to any single invention or inventive concept if more than one is in fact disclosed. Thus although specific embodiments have been illustrated and described herein it should be appreciated that any arrangement calculated to achieve the same purpose may be substituted for the specific embodiments shown. This disclosure is intended to cover any and all adaptations or variations of various embodiments. Combinations of the above embodiments and other embodiments not specifically described herein will be apparent to those of skill in the art upon reviewing the above description.

