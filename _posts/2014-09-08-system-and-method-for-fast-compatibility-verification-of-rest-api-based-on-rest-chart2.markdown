---

title: System and method for fast compatibility verification of REST API based on REST Chart
abstract: Various disclosed embodiments include methods and systems for determining whether representational state transfer (REST) application programming interfaces (APIs) are compatible. A method is performed by a processing system that includes a processor. The method comprises obtaining a first REST Chart describing a first version of a REST API and obtaining a second REST Chart describing a second version of a REST API. The method comprises determining whether the first version and the second version are compatible using the first REST Chart and the second REST Chart by determining whether a compatible path exists between the first REST Chart and the second REST Chart.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09654334&OS=09654334&RS=09654334
owner: FUTUREWEI TECHNOLOGIES, INC.
number: 09654334
owner_city: Plano
owner_country: US
publication_date: 20140908
---
This application claims priority under 35 USC 119 e to U.S. Provisional Application Ser. No. 61 874 971 filed on Sep. 6 2013 and U.S. Provisional Application Ser. No. 61 875 506 filed on Sep. 9 2013 each of which is incorporated herein by reference.

The present disclosure relates generally to Representational State Transfer REST Application Programming Interface API .

One advantage of REST API is that it promotes independent evolution of clients and servers in a loosely coupled fashion. However as the REST APIs are evolving with various versions and their new versions often contain significant changes maintaining backward compatibility of REST APIs has been difficult and has become a problem in REST API applications.

Prior approaches for determining backward compatibility of REST APIs are mostly manual. Once a server publishes a new REST API version client developers have to read the manual and mentally figure out if any existing client code can be reused with the new REST API. Although the developers can run some automated test suites to determine which parts of the client still work and which parts fail the tests cannot tell why some tests failed and how to change the client code to make the client work with the new API when some API messages are still recognizable but re factored.

According to one embodiment there is provided a method for determining whether representational state transfer REST application programming interfaces APIs are compatible. The method is performed by a processing system that includes a processor. The method comprises obtaining a first REST Chart describing a first version of a REST API and obtaining a second REST Chart describing a second version of a REST API. The method comprises determining whether the first version and the second version are compatible using the first REST Chart and the second REST Chart by determining whether a compatible path exists between the first REST Chart and the second REST Chart.

In another embodiment there is provided an apparatus for determining whether representational state transfer REST application programming interfaces APIs are compatible. The apparatus comprises a processor and memory coupled to the processor comprising instructions that when executed by the processor cause the processor to obtain a first REST Chart describing a first version of a REST API obtain a second REST Chart describing a second version of a REST API and determine whether the first version and the second version are compatible using the first REST Chart and the second REST Chart by determining whether a compatible path exists between the first REST Chart and the second REST Chart.

In this example the communication system includes electronic devices ED radio access networks RANs a core network a public switched telephone network PSTN the Internet and other networks . While certain numbers of these components or elements are shown in any number of these components or elements may be included in the system .

The EDs are configured to operate and or communicate in the system . For example the EDs are configured to transmit and or receive via wireless or wired communication channels. Each ED represents any suitable end user device and may include such devices or may be referred to as a user equipment device UE wireless transmit receive unit WTRU mobile station fixed or mobile subscriber unit cellular telephone personal digital assistant PDA smartphone laptop computer touchpad wireless sensor or consumer electronics device all which include and incorporate a browser application.

The RANs here include base stations respectively. Each base station is configured to wirelessly interface with one or more of the EDs to enable access to the core network the PSTN the Internet and or the other networks . For example the base stations may include or be one or more of several well known devices such as a base transceiver station BTS a Node B NodeB an evolved NodeB eNodeB a Home NodeB a Home eNodeB a site controller an access point AP or a wireless router. EDs are configured to interface and communicate with the internet and may access the core network the PSTN and or the other networks .

In the embodiment shown in the base station forms part of the RAN which may include other base stations elements and or devices. Also the base station forms part of the RAN which may include other base stations elements and or devices. Each base station operates to transmit and or receive wireless signals within a particular geographic region or area sometimes referred to as a cell. In some embodiments multiple input multiple output MIMO technology may be employed having multiple transceivers for each cell.

The base stations communicate with one or more of the EDs over one or more air interfaces using wireless communication links. The air interfaces may utilize any suitable radio access technology.

It is contemplated that the system may use multiple channel access functionality including such schemes as described above. In particular embodiments the base stations and EDs implement LTE LTE A and or LTE B. Of course other multiple access schemes and wireless protocols may be utilized.

The RANs are in communication with the core network to provide the EDs with voice data application Voice over Internet Protocol VoIP or other services. Understandably the RANs and or the core network may be in direct or indirect communication with one or more other RANs not shown . The core network may also serve as a gateway access for other networks such as PSTN Internet and other networks . In addition some or all of the EDs may include functionality for communicating with different wireless networks over different wireless links using different wireless technologies and or protocols. Instead of wireless communication or in addition thereto the EDs may communicate via wired communication channels to a service provider or switch not shown and to the internet .

Although illustrates one example of a communication system various changes may be made to . For example the communication system could include any number of EDs base stations networks or other components in any suitable configuration.

As shown in the ED includes at least one processing unit . The processing unit implements various processing operations of the ED . For example the processing unit could perform signal coding data processing power control input output processing or any other functionality enabling the ED to operate in the system . The processing unit also supports the methods and teachings described in more detail above. Each processing unit includes any suitable processing or computing device configured to perform one or more operations. Each processing unit could for example include a microprocessor microcontroller digital signal processor field programmable gate array or application specific integrated circuit.

The ED also includes at least one transceiver . The transceiver is configured to modulate data or other content for transmission by at least one antenna or NIC Network Interface Controller . The transceiver is also configured to demodulate data or other content received by the at least one antenna . Each transceiver includes any suitable structure for generating signals for wireless or wired transmission and or processing signals received wirelessly or by wire. Each antenna includes any suitable structure for transmitting and or receiving wireless or wired signals. One or multiple transceivers could be used in the ED and one or multiple antennas could be used in the ED . Although shown as a single functional unit a transceiver could also be implemented using at least one transmitter and at least one separate receiver.

The ED further includes one or more input output devices or interfaces such as a wired interface to the internet . The input output devices facilitate interaction with a user or other devices network communications in the network. Each input output device includes any suitable structure for providing information to or receiving providing information from a user such as a speaker microphone keypad keyboard display or touch screen including network interface communications.

In addition the ED includes at least one memory . The memory stores instructions and data used generated or collected by the ED . For example the memory could store software or firmware instructions executed by the processing unit s and data used to reduce or eliminate interference in incoming signals. Each memory includes any suitable volatile and or non volatile storage and retrieval device s . Any suitable type of memory may be used such as random access memory RAM read only memory ROM hard disk optical disc subscriber identity module SIM card memory stick secure digital SD memory card and the like.

As shown in the base station includes at least one processing unit at least one transmitter at least one receiver one or more antennas one or more network interfaces and at least one memory . The processing unit implements various processing operations of the base station such as signal coding data processing power control input output processing or any other functionality. The processing unit can also support the methods and teachings described in more detail above. Each processing unit includes any suitable processing or computing device configured to perform one or more operations. Each processing unit could for example include a microprocessor microcontroller digital signal processor field programmable gate array or application specific integrated circuit.

Each transmitter includes any suitable structure for generating signals for wireless or wired transmission to one or more EDs or other devices. Each receiver includes any suitable structure for processing signals received wirelessly or by wire from one or more EDs or other devices. Although shown as separate components at least one transmitter and at least one receiver could be combined into a transceiver. Each antenna includes any suitable structure for transmitting and or receiving wireless or wired signals. While a common antenna is shown here as being coupled to both the transmitter and the receiver one or more antennas could be coupled to the transmitter s and one or more separate antennas could be coupled to the receiver s . Each memory includes any suitable volatile and or non volatile storage and retrieval device s .

Additional details regarding EDs and base station are known to those of skill in the art. As such these details are omitted here for clarity.

The present disclosure describes an automated process to test if two versions of REST APIs are compatible based on a REST Chart model. The described process takes two REST Charts C1 and C2 each REST Chart describing a different version of a REST API and uses the process described herein to determine whether the two different REST APIs are compatible. If the two REST API versions are compatible the process produces the compatible paths in C2 that can be reached by a client of C1. In addition the process identifies the relations between C1 and C2 that warrant the compatible paths.

The REST Chart model treats a REST API as a set of type representations connected by transitions. Each transition specifies the possible interactions with the resource referenced by a hyperlink in a type representation. The REST Chart model uses a special kind of Colored Petri Net to define these type representations and transitions. In particular a type representation becomes a Petri Net place that can have Petri Net tokens denoting resource representations of that type color . A transition has two input places and several output places response and faults and one of the input places contains a hyperlink to the resource. A hypermedia constraint is enforced by the Petri Net transition rules as follows 1 a transition can be fired if and only if all its input places have the right kind of tokens 2 after a transition fires its output place will have the right kind of tokens.

To illustrate assume a REST API for a banking application asking a user agent to login with user name and password in order to access account information. To represent this logic in hypermedia the login type representation contains a hyperlink to which a user agent can submit the credential data and receive the account information. This REST API may be represented as a Petri Net with three places type representations and one transition connecting the three places as illustrated in . As illustrated the three places comprise a login place a credential place and an account place .

The Petri Net indicates that the user agent can transfer its representational state from the login place to the account place aided by the credential place . To make the transfer the user agent first puts a token x1 in the login place and a token x2 in the credential place it obtains a login document with a hyperlink x1 and created valid credential data x2 . Then the user agent fires the transition by submitting the credential to a resource at the hyperlink. If the credential is successful the account resource representation is obtained from the response. As a result the transition causes the third token x3 the account document to occur in the account place .

The effect of this interaction on Petri Net can be modeled by a time delay for the transition. When firing a transition a user agent uses a client connector to interact with the origin server. A uniform interface may be implemented by the client connector. The interface comprises input and output parameters. In each interaction the input and output parameters contain 1 control data e.g. HTTP verbs and status 2 optional metadata about the resource representation e.g. HTTP headers and 3 an optional resource representation. In addition a user agent also needs to know the transfer protocol e.g. HTTP in order to call the right client connector. This data comprises the interaction instructions for firing the transitions.

To force a user agent to start from an initial URI a Petri Net can be marked with one token in the initial place. This marking is also the initial representational state of the user agent. As the user agent fires the enabled transitions based on its selection of hyperlinks it creates more tokens resource representations in different places. These markings represent different representational states of the user agent. In typical situations the user agent reaches the goal state when a token e.g. confirmation of a money transfer occurs in the desired place. The enabled transitions can fire sequentially or concurrently depending on the search strategy of the user agent.

This Petri Net based approach to REST thus achieves the following goals within one model 1 its topology defines the transition relations between hypermedia representations of a REST API 2 its token markings define the representational state space of any user agent that uses the REST API and 3 its transitions define the possible interactions data formats and protocols between the user agent and the resources.

In a particular implementation using the REST Chart model the backward compatibility problem can be formulated as follows given a version of REST API described by a REST Chart C1 a special client program P that can reach all places of C1 from the initial place and a new version of the API described by a REST Chart C2 determine how many places in C1 are reachable in C2 by P.

P has the ability to carry out the interaction e.g. deference URI or submit form required by the C1 transition.

The present disclosure assumes each place Pi in REST Chart C can be represented as a tree of elements based on a few primitive types as defined by XML Schema and its tree serialization. Further detail on such XML Schema is published by the World Wide Web Consortium W3C and further detail on such tree serialization can be found in Automatic Message Flow Analyses for Web Services Based on WSDL Proceedings of 2007 IEEE International Conference on Web Services ICWS 2007 page 880 887 Salt Lake City July 2007 Li Li Wu Chu the teachings of which are incorporated herein by reference in their entirety.

For example if a place represents a read only document the URI would represent the service provided by each link. If a place represents an input form the URI would represent a field name. In any case rij provides sufficient information for P to interact with the places e.g. to follow a link or fill a form .

In other words when a client P sees Pj in C2 it understands how to interact with it based on its prior knowledge of Pi in C1. This relation can be extended to partial coverage where part of a place covers part of another place denoted by cover Pi parti Pj partj .

It is assumed that there is a function place find chart condition whose algorithm is not defined herein that can find places in a REST Chart that satisfy the given condition defined based on the above place type and cover relation.

1. OR place a REST client needs to understand ANY relational URI in the place. As an illustrative example an OR place may be a web page having multiple links that a user can choose between 

2. AND place a REST client must understand ALL relational URIs in the place. As an illustrative example an AND place may be an online form with multiple sections that need to be filled in e.g. name address etc. .

The present disclosure assumes that all URIs in an OR place are context free such that their meanings remain the same when they occur in different places of a REST Chart and in different versions of REST Charts. REST APIs that satisfy this condition promote separation of identification from representation such that the REST APIs can reuse the relational URIs to facilitate backward compatibility.

On the contrary the URIs in an AND place are assumed to be context sensitive and cannot be separately understood by P. In other words two different AND places P1 and P2 may use the same relation to mean different things. However if a client P understood all relations in P1 it can understand P2 if the relations of P2 is a subset of the relations in P1. In other words if P understands P1 and cover P1 P2 is true then P understands P2. This restriction prevents client P from pretending to understand P2 by mixing relations from some unrelated places in C1.

The present disclosure describes a process to simulate a client program P that tries to visit all places of C2 by only knowing places of C1. The process begins at the initial place of REST Chart C2 and tries to fire as many of its transitions as possible while the transition firings are sanctioned by REST Chart C1.

The following function starts at the initial place of C2 and calls a recursive function to visit all C2 s places 

Now turning to there is illustrated a system depicting sanctioning the firing of a C2 transition by C1 places. The system includes a first REST Chart C1 and a second REST Chart C2 . The configuration of C2 is illustrated in after initialization. C2 includes a first Pnext place an incoming place P2 a Tnext transition that receives the first Pnext place and the P2 place and a second Pnext place . As illustrated a token is in the first Pnext place 0 token in the P2 place and a determination is made whether the Tnext transition can fire.

To determine whether the Tnext transition can fire a determination of the type of the first Pnext place is performed. If the type of the first Pnext place is OR it means the client P has to follow an rij link in the first Pnext place . Because P only understands C1 a determination is made whether rij occurs in a place in C1 . For example a determination may be made whether rij occurs in a first place in C1. If so then an attempt is made to fire the Tnext transition as described in further detail below. If the type of the first Pnext place is AND it means the client P has to know all the relations e.g. form fields in the first Pnext place . Because P only understands C1 a determination is made whether Pnext is covered by a place in C1. If so then an attempt is made to fire the Tnext transition as described in further detail below.

To try to fire the Tnext transition a determination is made whether P2 the second incoming place is also covered by C1 for the same reason. For example a determination may be made whether a similar message as associated with P2 occurs in a second place in C1. If so a token is inserted in P2 and the Tnext transition is fired e.g. because both conditions input to the Tnext transition have been met . Thereafter the process moves to the outgoing place of Tnext e.g. the second Pnext place and the process is repeated until no more transitions can fire in C2 . As will be appreciated the first Pnext place may be associated with a message from a server in a network and the place P2 may be associated with a message that a client in the network is supposed to send to the server. Examples of pseudo code of the steps described above is provided below as two recursive functions as follows 

The functions described above collect sequences of places of C2 sanctioned by C1 as sequences of tuples. For two REST Charts of N and M places the time complexity of the process is O N M because for each place of C2 the process checks at most N places of C1 .

As an illustrative example and based on a REST API migration analysis portions of the REST Charts for REST API v1.0 and v2.0 are depicted in for side by side comparison. API v2.0 re factors the REST API in two ways 

1. The path to port type is changed between the versions in v1.0 the path is tenant type networks type network type ports type port type attachment type whereas in v2.0 the path is shortened to tenant type ports type port type attachment type .

2. The path to attachment type is changed between the versions in v1.0 attachment type has its own representation whereas in v2.0 it is contained within the port type e.g. port type attachment type .

If C1 is the v1.0 and C2 is the v2.0 the sanction relations are shown as the dotted arrows from C2 places to C1 places in . The trace of the sanction path C1 C2 process that identifies these sanction relations is outlined in the table illustrated in . For example entries in column are associated with the message being examined e.g. path of for REST API v2.0 tenant type ports type and port type . Entries in column are associated with the message in C1 that covers e.g. is similar to the message in C2. Entries in column are associated with the transition being examined. Entries in column e.g. tuples are associated with mapping between the C2 and C1 messages e.g. the dashed arrows in . The tuples show the representations places of C2 that also occur in C1 such that they can be understood by C1 clients. Entries in column are associated with the next message to be examined. For example using the path as an illustrative example if the current Pnext message is P tenant type the next Pnext message is P ports type. The null message in the column indicates that no more transitions can fire in C2.

In some embodiments some or all of the functions or processes of the one or more of the devices are implemented or supported by a computer program that is formed from computer readable program code and that is embodied in a computer readable medium. The phrase computer readable program code includes any type of computer code including source code object code and executable code. The phrase computer readable medium includes any type of medium capable of being accessed by a computer such as read only memory ROM random access memory RAM a hard disk drive a compact disc CD a digital video disc DVD or any other type of memory.

It may be advantageous to set forth definitions of certain words and phrases used throughout this patent document. The terms include and comprise as well as derivatives thereof mean inclusion without limitation. The term or is inclusive meaning and or. The phrases associated with and associated therewith as well as derivatives thereof mean to include be included within interconnect with contain be contained within connect to or with couple to or with be communicable with cooperate with interleave juxtapose be proximate to be bound to or with have have a property of or the like.

While this disclosure has described certain embodiments and generally associated methods alterations and permutations of these embodiments and methods will be apparent to those skilled in the art. Accordingly the above description of example embodiments does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure as defined by the following claims.

