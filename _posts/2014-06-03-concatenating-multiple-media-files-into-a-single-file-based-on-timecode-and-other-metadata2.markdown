---

title: Concatenating multiple media files into a single file based on timecode and other metadata
abstract: A method and system concatenate multiple media files into a single, continuous media file. The method includes receiving a group of media files and metadata about the group over a network connection. The method also includes in response to receiving the group of media files, determining an order of the media files in the group based at least partially on the metadata. The method includes concatenating the group of media files into a concatenated file based on the determined order. The concatenated file may be transferred to a client device over a network connection. The concatenated file may be transcoded into a file format determined based on the user device before transferring the concatenated file to the user device. The order of the media files in the group may be determined based on a timecode for each of the media files, which is included within the metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626372&OS=09626372&RS=09626372
owner: Latakoo, Inc.
number: 09626372
owner_city: Austin
owner_country: US
publication_date: 20140603
---
This application claims priority under 35 U.S.C. 119 e to U.S. Provisional Patent Application No. 61 830 569 filed Jun. 3 2013 and entitled METHOD TO CONCATENATE MULTIPLE MEDIA FILES INTO A SINGLE FILE BASED ON TIMECODE AND OTHER METADATA This application also claims priority to and is a continuation in part of U.S. patent application Ser. No. 13 598 444 filed on Aug. 29 2012 and entitled COMPRESSING TRANSCODING SENDING AND RETRIEVING VIDEO AND AUDIO FILES IN A SERVER BASED SYSTEM AND RELATED SYSTEMS AND METHODS which claims priority to U.S. Provisional Patent Application No. 61 528 504 filed Aug. 29 2011 entitled COMPRESSING TRANSCODING SENDING AND RETRIEVING VIDEO AND AUDIO FILES IN A SERVER BASED SYSTEM AND RELATED SYSTEMS AND METHODS. The above identified patent documents are hereby incorporated by reference in their entireties.

The present disclosure relates generally to media files. More specifically the present disclosure relates joining multiple media files into a single file.

Although video data is an important part of digital life transmitting video data remains an arduous process. Video files are often very large and the size of video files can make transfer over the Internet a lengthy process. Moreover video transfer systems can use a large number of encoder decoder programs codecs and associated formats. Video transfer systems may also use a similarly large number of wrapper formats that encapsulate video data and associated metadata further limiting video compatibility. Therefore even when a lengthy Internet transfer process is complete it is not certain that a recipient has the ability to view the video.

Video files on web servers are typically stored in a single common format. This is usually an acceptable situation when users only want to play video. However in certain situations a recipient may want to edit received videos. Unfortunately video editing software often must perform time consuming conversion processes on popular web video formats resulting in poor user experiences.

In addition digital media files often are measured in terms of file size such as megabytes and gigabytes. However to a non technical user this may be difficult to understand. This is also inconsistent with other units of measurement used in handling video files. For example while watching a video a user s progress is measured in terms of hours minutes and seconds.

There are many services on the Internet for sharing digital media. For example users may share rich text audio video and interactive content. However users often have the burden to publish such digital media files. Additionally such services often are web based and do not allow for access from different kinds of devices software and interfaces.

In the professional realm recorded media often is stored as multiple related files rather than a single contiguous file. For example professional digital video cameras often create multiple video files instead of a single contiguous file when shooting footage.

This disclosure provides methods and systems for compressing and sending computer readable media such as digital video and audio files through a server based system. This disclosure also provides methods and systems for transcoding computer readable media upon download from a web application. This disclosure further provides methods and systems for depleting account credit based on a length of a computer readable medium. In addition this disclosure provides methods and systems for server side support for buying and selling computer readable media.

Various embodiments of the present disclosure provide methods and systems for compressing and sending computer readable media. In one embodiment a method includes sending a computer program for compressing and sending media files to a client computer. The computer program includes program code for identifying information about a media file in response to receiving a request to send a media file. The computer program also includes program code for determining whether the media file is compressible based on the identified information identifying a compression algorithm based on the identified information and compressing the media file using the compression algorithm. The computer program further includes program code for sending the compressed media file to one or more server computers. The method further includes receiving the compressed media file sent from the client computer.

Various embodiments of the present disclosure provide methods and systems for transcoding computer readable media upon download. In one embodiment a method includes sending a request from a client to receive a media file from a server. The method also includes receiving a selection of a file format for the media file to be received. The method further includes receiving the media file in an initial format. Additionally the method includes transcoding the media file from an initial file type to the selected file type.

Various embodiments of the present disclosure provide methods and systems for depleting account credit based on a length of a computer readable medium. In one embodiment a method includes receiving at a server a media file from a client. The method also includes identifying a length of content stored in the media file. Additionally the method includes depleting account credit based on the length of the media file.

Various embodiments of the present disclosure provide methods and systems for buying and selling computer readable media. In one embodiment a method includes providing a marketplace associated with a plurality of sortable media items. The method also includes receiving a request to purchase a media item. The method further includes depleting an account associated with a purchaser of the media item. Additionally the method includes crediting an account associated with a seller of the media item.

In additional embodiments the present disclosure provides a system and method to join multiple media files into a single file where the files may be related media pieces such as are often created by professional digital video cameras. The method may be used to join media files at the point of upload download or when a single joined media file is required. The media file may then be transcoded into another media file format and or transferred to a third party as required.

In various embodiments metadata is retrieved from individual media files by the application and or computing device responsible for uploading the individual files. This metadata may include but is not limited to the starting time of the media footage timecode and the numeric order in which the files were placed in the application. When the media is uploaded via the Internet video services Application Programming Interface this metadata is sent alongside it. Once all media files have been retrieved the service and or computing device arranges the media files in order based on their timecode if the timecode is available and the order in which they were placed in the application. The application and or computing device then re encodes the separate media files as one continuous file and makes this available for uploading downloading and or transfer.

Other technical features may be readily apparent to one skilled in the art from the following figures descriptions and claims.

Various embodiments of the present disclosure recognize that sending media over the Internet can be complicated and timely. Accordingly embodiments of the present disclosure allow users to simplify the process of sending media while reducing the amount of time needed to send the media. For example in various embodiments all a user needs to do is specify a location of a file for the media file to be sent automatically. Embodiments of the present disclosure perform all the work of identifying proper compression techniques compressing uploading sending and transcoding media files in a media transfer environment. For example embodiments of the present disclosure enable a one click service for sending media.

Various embodiments of the present disclosure recognize that recorded media is often stored as multiple related files rather than a single contiguous file. For example professional digital video cameras often create multiple video files instead of a single continuous file when shooting footage. Various embodiments of the present disclosure also recognize that while professional media editing software often allows users to easily stitch these files into a single concatenated piece of footage Internet media services currently do not offer this support. Various embodiments of the present disclosure recognize that as a result users of these services must transfer and download the media pieces individually these can often number in the hundreds.

In this example server computers connect to the network along with a storage unit . In addition client computers connect to the network . The client computers may be for example personal computers network computers or mobile computing devices. In the server computers could provide information such as boot files operating system images and applications to client computers . The client computers are clients to the server computers in this example. The system may include additional server computers client computers or other devices.

Program code in the system may be stored on a computer recordable storage medium and downloaded to a computer system or other device for use. For example program code may be stored on a computer recordable storage medium on the server computers and downloaded to the client computers over the network for use by the client computers .

In some embodiments a web application may be used to perform functions related to compressing transcoding receiving and sending media files. A web application is an application that may be accessed over a network such as the network to perform functions for a client computer such as client computers .

In the server computers may be web servers running program code for the web application which is accessible by the client computers . A browser or other application on each client computer can access the web application to perform functions related to compressing transcoding receiving and sending video files. These video files can be located on the client computers or stored remotely on the server computers or storage unit .

In some embodiments a client application of the web application may be downloaded and installed on the client computers . This client application can perform functions on the client computer for compressing transcoding receiving and sending video files at the client computer. The client application or a client portion of the web application communicates with a server application or a server portion of the web application.

The system may be implemented using a number of different types of networks such as an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the different embodiments described below. Each of the computing devices includes any suitable structure for performing the described functions. Each computing device could for example include one or more processing units one or more memory units storing data and instructions used by the processing unit s and one or more interfaces for communicating over the network .

Embodiments of the present disclosure enable compressing and sending of video and audio files in a server based system. In various embodiments of the present disclosure the client is configured to compress and send video files. The client accesses a web application over a network connection to send video and audio files. For example the client may download a computer program such as client application to compress and send video files.

When a user desires to send a video or audio file the client can obtain the user s account credentials. For example the client may prompt the user to enter the account credentials such as username and password . The client may also retrieve the account credentials from other sources such as from a configuration file or a network administration policy.

When the user is authenticated to the server the server may supply further information relating to the method of file upload. For example if the upload is to be performed via a File Transfer Protocol FTP connection the server might return the name of the upload server and a username and password to instantiate the connection. Another upload might be via a series of hypertext transfer protocol HTTP requests in which case the server might return a string of characters to use to verify the authenticity of later requests.

When the user is authenticated to the server a file processor in the client identifies locations of video or audio files to be sent. For example the client may generate a window that is displayed to the user. illustrates an example window that may be displayed to a user for identifying files to be sent in accordance with various embodiments of the present disclosure. A user may drag and drop files into this window. In other examples the client may receive a file path specifying a location of a file an input over a command line or a selection of a file via a dialog box.

Once one or more file locations have been provided the client can wait to receive a command to begin compressing and uploading the file s . For example illustrates a screen shot of a window having a file location provided which is awaiting a user command to compress and upload the file in accordance with various embodiments of the present disclosure.

Once compression and uploading are commenced the file processor examines each file to determine whether the media file is compatible with the compression process. For example the file processor can compare each file s format with a list of file formats supported by the server . The file processor may discard or flag files that are not compatible. The client may also present the user with feedback to alert the user that a file has been discarded or flagged.

In particular embodiments the following formats are examples of container formats that may be compatible with the server Advanced Systems Format .ASF .WMV Matroska .MKV MPEG program stream .MPG .MPEG MPEG transport stream .TS .M2T MPEG 4 Part 14 .MP4 QuickTime .MOV 3GP 0.3gp 3gpp and Flash Video .FLV . Examples of supported video codecs could include the following codecs APPLE DV DVCPro Avid DV Avid DV100 Avid Meridien Blackmagic 10 bit and 8 bit HDV Mode 3 DVCPRO 35 DVCPRO 50 DVCPRO HD MPEG 4 Part 3 MICROSOFT DV MPEG2 HDV1 MJPEG H.263 H.264 VP3 VP6 On2 WVC1 Windows Media Video 9 WVC1 Windows Media Video 9 HD Huffyuv Sorenson 3 Sorenson Spark SONY YUV Theora and Raw RGB uncompressed. Examples of supported audio codecs could include the following codecs Advanced Audio Coding AAC AC 3 MP3 Pulse code modulation PCM Vorbis and Windows Media Audio WMA .

The file processor can retrieve configuration options for the compression of the video or audio files. The configuration options may be preset in the client application upon download or selected by a user of the client in advance or during the compression and sending of the media files. The configuration options may relate to the individual file format or all files to be compressed. For example the configuration options may include options such as a maximum or minimum compression size of the file a selection of how quickly a user request the compression and transfer processes to occur i.e. based on file size and bandwidth availability resolution image or video quality compression algorithm file format and or any other settings or options for compressing and sending the media file.

The file processor passes the location of a file and the compression configuration options to an encoder . The encoder encodes the media file in a format for upload. For example the encoder may compress the media file into a smaller size for increased transferability of the media file. In some embodiments the encoder may be downloaded from the server to the client . The encoder may include a compression library or program code that is incorporated into the client application . The client can monitor the compression for progress and any error messages and alert the user appropriately. For example illustrates an example window showing the progress of a file being compressed by the client application . The file may be compressed according to any suitable format.

An uploader such as a network card and or software for uploading files in the client then begins to upload the file to the server using an appropriate method. For example the uploader may transfer the file using FTP or HTTP requests. The uploader also monitors the upload progress. When the file has finished uploading the uploader reports the completion to the user. The uploader may also send a further request to the server. For example the uploader may request to receive confirmation that the file was received intact. illustrates an example window showing that a file has been uploaded. Thus a user simply needs to drag and drop a media file into a window for the client to compress and upload the media file. In this manner the media transfer system can enable a one click service for transferring media files.

In these examples the uploader uploads compressed files from the client to a receiver such as a network card and or software for receiving uploaded files on the server . The compressed files may be stored in a media storage e.g. on the server computer or the storage unit in . Once uploaded the compressed files may be retrieved from a transmitter such as a network card and or software for downloading files via a network e.g. the network . For example a user desiring to access a compressed file may access the compressed file via any computer connected to the network . As a particular example files uploaded from the client computer may be accessed by the client computers and .

In various embodiments the client may simultaneously compress and upload portions of the media file to decrease a total time required to upload the media file. For example based on computing resources such as processor speed and memory size and speed and the compression algorithm the compression and or encoding of the media file may take a considerable amount of time. During this compression time the computer resources are constrained and network resources such as available bandwidth may not be constrained. As a result compressed portions of the media file may be uploaded while other portions of the media file are still being compressed. The parallelization in the use and performance of tasks by the computing resources and the network resources can result in a significant decrease in the total time needed to compress and send the media file.

In this illustrative embodiment the client includes a segmenter . The segmenter monitors the output of the encoder and creates segments from the portions of the media file that have been compressed. The lengths of these segments may have equal lengths but may also have dynamic lengths depending on factors including settings from the client instructions from the server and the output from the encoder . The uploader monitors the new segments as they are created and begins uploading the segments of the media file as soon as they are ready.

On the server the segments of the media file are managed by a segment processor . For example in some embodiments the segment processor may join and or concatenate segments together as a single file that is ready for viewing or download. The segment processor may also store the segments separately without initially joining the segments. Upon receipt of a request to view or download the media file the segment processor may piece the segments together such as at run time using a script. For example the segment processor may piece the segments together upon download or allow only a portion of a complete media file to be downloaded. In other examples the segment processor may stream the separate segments as a complete media file. For example in the example of video the web browser or client application at the client may view the video as a contiguous compatible video file.

While only one server and client are depicted in any number of different servers and clients may exist in media transfer system . For example the client may obtain the client application from one server and send the compressed media file to a different server. In other examples one server may receive the uploaded media files another server may store the media files and yet another server may be used for the media file to be sent or downloaded.

The process begins by determining whether the client application has obtained account credentials of a user step . If account credentials have not been obtained the process obtains the account credentials step . In step the client application may request the account credentials from the user or retrieve the account credentials from a file or other source. When account credentials have been obtained the process supplies the credentials to the server step . The process determines whether the account credentials are valid step . If the process determines that the account credentials are not valid the process returns to step and attempts to obtain valid account credentials.

If the account credentials are valid the process waits for location s of video or audio file s and a start command step . In step a user may specify a location of one or more files to be compressed and uploaded. Thereafter the process determines whether valid locations of video or audio files have been supplied step . If valid locations of video or audio files have not been supplied the process returns to step and continues to wait for valid locations of video or audio files and the start command. If valid locations of video or audio files have been supplied the process obtains a next item in the list of files step . The process determines whether the file obtained is able to be compressed step . In step the process may compare the file type with a list of compatible file types. If the file cannot be compressed the process proceeds to step discussed below. If the file can be compressed the process compresses the file step .

The process determines whether additional files to be compressed are present step . If additional files to be compressed are present the process returns to step and obtains a next item in the list of files. If additional files to be compressed are not present the process determines whether there are compressed files to upload step . If there are no compressed files to upload the process returns to step and continues to wait for locations of video or audio files and a start command. If there are compressed files to upload the process obtains a next item in the list of compressed files step and uploads the file to a server step .

The process determines whether the file was successfully uploaded step . If the file was not successfully uploaded the process returns an error message step . If the file was successfully uploaded the process returns a success message step . The process returns to step and determines whether there are additional compressed files to upload. If there are no additional files to upload the process may terminate. The process may also terminate when a user closes the program.

The process begins by receiving a request to send a media file step . For example in step the process may launch the client application and provide a window such as that illustrated in for a user to select a media file to send. The request may be received by dragging and dropping a media file into the window or specifying a file path for the media file.

The process then identifies information about the media file step . For example in step the process may identify a location of the media file on the client computer a file format of the media file a resolution of the media file a type of the media file e.g. a video clip a fast moving sports video a slower moving landscape video a picture or an audio file and selected configuration options of how to compress the media file. Thereafter the process determines whether the media file is compressible step . For example in step the process may determine whether the file type of the media file is in a format that is supported by the encoder . If the process determines that the media file is not compressible the process sends the media file without compression step with the process terminating thereafter. Alternatively in step the process may return an error message that the compression and sending of the file is not possible.

Returning to step if the process determines that the media file is compressible the process identifies a compression algorithm to use in compressing the media file step . For example in step the process may identify the compression algorithm based on a file format of the media file a size of the media file a type of content included in the media file and or selected configuration options for compression size quality and or upload download time estimates. The process then compresses the media file step . For example in step the process may compress the media file using the selected compression algorithm. Thereafter the process determines whether to compress and send simultaneously step . For example in step the option to compress and send simultaneously may be selected as a default or may be selected from one of the configuration options . If the process determines not to compress and send simultaneously the process waits for the compression to complete and sends the compressed file to the server step with the process terminating thereafter.

Returning to step if the process determines to compress and send simultaneously the process segments compressed portions of the media file into compressed segments step . For example in step the process may monitor the compressed portions of the media file to segment the compressed portions into separately uploadable segments. The length of these segments may be static or dynamic. The process segments the compressed portions of the media file while other portions of the media file are being compressed. The process then sends the compressed segments to one or more server computers step with the process terminating thereafter. For example in step the process may send the compressed segments while portions of the media file are still being compressed.

This disclosure also provides systems and methods for transcoding files on download from a web application. In some embodiments this functionality utilizes Uniform Resource Identifiers URIs . URIs are strings of characters used to identify the location of a resource on the Internet. The string includes a URI scheme identifying the type of URI followed by a colon and some scheme specific information. The scheme specific information is typically the file path location of the resource. For example in a World Wide Web URI the URI scheme is http followed by a colon and the location of the described web page.

In these embodiments the client can perform functions for transcoding files on download from a web application. For example when the client application is installed on a client computer the client application can register as a helper application with a web browser on the client computer. A helper application is an application referenced by a browser to assist in handling different file formats that may be encountered. The client application can register in a variety of ways. For example the client application may change a browser s internal configuration or change an operating system registry. The client application also establishes a unique URI scheme name for each possible file download format. The effect is to associate the client application with these scheme names so that the browser launches the client application when a file is downloaded by the browser.

When the user attempts to access a URI where the protocol component corresponds to a previously established URI scheme name the client application is automatically loaded by the web browser. The client application then determines the location of the requested file by changing the scheme name portion of the URI to a pre selected one that is widely supported. For example the client application may change the URI scheme to HTTP.

In this way the client application ensures that the URI refers to a valid location. By examining the file name extension of the file the client application determines whether the file is in a supported input format. Additionally the URI may include information for example to pass user session information to the video tool or to identify the link for the purpose of site usage analytics.

If the URI refers to a valid location and the file is in a supported input format the client application downloads the file from the URI location. The transcoder in the client also transcodes the file into the video or audio format associated with the protocol name. The client application may further report incremental progress to the user in a visible or audible manner. The transcoded file can be saved in a location established by the configuration of the client application . The location may be set as a default value or be chosen by the user. The location may also be selected by a policy or administrator. The client application may provide a notification to the user and the file may be opened by the client in response to user input.

As a specific example for a video that might be downloaded using standard HTTP the URI may be http followed by latakoo.com video 1877 download . The client application may modify this URI scheme to download the same video in a format selected for editing in a particular editing program. For instance a URI scheme selected for the FINAL CUT PRO video editing software may be latakoofcp latakoo.com video 1877 download transcode 1311214392 5711a21d8749ef5d91087b3181e656a2 sampleRGB 2.mp4 In these embodiments the URI can be augmented with session information and further descriptive information in order to identify the kind of download for the purpose of site analytics.

The process begins by a browser launching a helper application step . In step a user may have clicked on a link for a video or audio file in a certain format. The helper application may be registered with the browser to be launched when links with the certain format are selected. The process retrieves a passed URI and configuration options step . In step the URI and configuration options may include the identification of the file format and URI scheme. The process determines whether the URI scheme is supported by the application step . If the URI scheme is not supported the process may return an error message step and terminate.

If the URI scheme is supported the process sets an output file format to one that corresponds to the URI scheme step . The process changes the URI scheme to a pre set standard step . The process determines whether the URI points to a valid location step . If the URI does not point to a valid location the process returns to step and may return an error message. If the URI points to a valid location the process begins to download the file step . The process determines whether the file downloaded successfully step . If the file did not download successfully the process returns to step and may return an error message.

If the file downloaded successfully the process begins to transcode the file to the set output file format step . In step the output file format may for example be selected by the user or specified in the client application. The process determines whether the file was transcoded successfully step . If the file was not transcoded successfully the process returns to step and may return an error message. If the file was transcoded successfully the process saves the file in a selected location step . The process optionally displays a notification of success step and terminates.

This disclosure further provides systems and methods for depleting account credit based on a length of a digital media file. In some embodiments user account information is stored by a central service such as a server computer or the server . The user account information can include information about a user s credentials files uploaded by the user and an amount of credit the user has for uploading files.

As shown in the server includes a reporting application . The reporting application has the ability to report the length of a media file. For example in the case of video files the reporting application may include an encoder decoder or compressor decompressor codec library or application. The reporting application may also be a component of the server computers or be installed on a separate computer. The reporting application is triggered to check the length of a file in response to an action. For example the reporting application may check the length of a media file when the media file has been uploaded. The length can represent the time duration of the media file when played in some units of time such as minutes and seconds .

The reporting application also retrieves user information. The retrieval may be through submission of authentication credentials. In other embodiments the retrieval may be through locally saved user session information a reference to session information via a browser cookie a unique authentication string for use with a remote application programming interface API or other programmatic methods of determining a logged on user. The user information includes a credit value measured in units of time.

In some embodiments the credit value may have other components. For example a credit may be specific to different formats for videos such as when videos of higher quality like high definition or HD videos require more credits. Thus the credit value may have different units of time for high definition videos and standard definition videos.

The reporting application determines whether a media file is in a format that can be read by the reporting application . If the reporting application cannot read a file the reporting application can halt execution and return an error message. If the media file is readable the reporting application analyzes the media file in order to determine its length and stores a value for the length of the media file.

The reporting application then returns the value for the length and a unique identifier that represents the user to the server . If the reporting application is an integrated portion of the server the reporting application may launch an internal function to report the information. If the reporting application is located remotely the reporting application may launch an API call over a communication channel. The reporting application may also report additional information. For example the reporting application may report details about when a media file is uploaded and a sound or video quality of the media file.

The server application checks the validity of the user account information. If the user account information is invalid the server returns an error message. The server also checks the information about the length and details of the media file. The server application retrieves the credit value for the user s account and modifies the credit value based on the information about the length and details of the media file. For example the server application may subtract the length of the uploaded file in terms of units of time from the user s credit value. In other embodiments the server may use the file format the storage size of the file or any other details about the media file to determine the amount to subtract from the user s credit value. The server may report the new credit value to the client . The server may also alert the user visually or by email.

The process begins by identifying that a file length check was triggered step . In step the file length check may be triggered by a user uploading a file. The process retrieves user account information step and an input file step . The process examines the input file step and determines whether the file is in a readable format step . If the file is not in a readable format the process returns an error message step and terminates.

If the file is in a readable format the process analyzes the input file step . In step the process analyzes the input file to determine a length of the file. The process may also identify other details about the file such as a file format or quality of the file. The process stores the length of the file and an identifier for the file in metadata step . The process retrieves a user identifier and metadata step . The process determines whether the user identifier is valid step . If the user identifier is not valid the process returns to step and returns an error message. If the user identifier is valid the process determines whether the metadata is valid step . If the metadata is not valid the process returns to step and returns an error message. If the metadata is valid the process retrieves user credit information step . The process processes the user credit information based on the metadata step . The process saves updated user credit information step and terminates.

The flowcharts and block diagrams in the figures above illustrate architectures functionalities and operations of possible implementations of systems methods and computer program products according to various illustrative embodiments of this disclosure. In this regard each element in a flowchart or block diagram may represent a module segment function and or at least a portion of an operation or step. For example one or more blocks may be implemented as program code in hardware or a combination of program code and hardware. In some alternative implementations the function or functions noted in a block or group of blocks may occur out of the order noted in the figures. For example in some cases two blocks shown in succession may be executed substantially concurrently or the blocks may sometimes be executed in a reverse order depending on the functionality involved. Also other blocks may be added in addition to the illustrated blocks in a flowchart or block diagram.

Finally embodiments of the present disclosure enable server side support for buying and selling digital media files. In various embodiments the client application may connect to a marketplace for buying and selling digital media files. For example client application can connect to marketplace via an Application Programming Interface API . Client application may be a standalone software application a plug in to an existing application a web application and or any other type of software that can make use of API services. Communication between client application and marketplace can use any common machine readable format. For example client application may use extensible markup language XML or JavaScript object notation JSON .

Client application also manages a user account. The user account may contain a credit value. The credit value may be measured in currency or another metric such as media file length. The user accounts may be set up by an interface provided in client application or via a human readable interface such as over the web. Users can also add account credits and payment information via one or more interfaces.

In some embodiments client application establishes an authenticated connection with marketplace using the API. For example client application can establish the connection via tokenized authentication. As a particular example client application may use the OAuth authentication protocol or any suitable established authentication protocol. Client application may access marketplace as an anonymous public user. However authentication may be required for a user to participate in buying or selling activities.

Once a connection is established client application may query marketplace for available media items. Client application may query in a number of ways. For example client application may query media items filtered or ordered by date files filtered by arbitrary metadata such as title tagging format rating price or creator details inherent to the media file such as volume level overall color values length or aspect ratio and or combinations thereof. The query may also limit the number of results returned and provide an offset. For example the query may request the first 50 items or 50 items skipping the first 50. The query may also request items that the current user has previously purchased.

Marketplace responds to a query by returning details about media items that match both the request and details relating to the user s account. The response may also include overall totals for the request. Thus client application can efficiently make further requests. For example client application may request to paginate between screens of media items. Marketplace may restrict certain types of media items to certain users or user groups. If the user account for client application is not within the group of users marketplace may not return or include these types of media items in a response.

Marketplace can provide various details about media items. These details may include for example a Universally Unique Identifier UUID that refers to the item descriptive information thumbnails locations of preview media such as a streaming preview of video pricing information and available metadata. In an example where the user has purchased the media item the details may include the full URI for client application to download or view the complete media item.

In an example where a user has not already purchased an item client application may request to purchase the item. Purchasing may not be available for public users. Client application can send a request to purchase the item and the request may include the item s UUID. Marketplace identifies whether the user account has enough credit to purchase the item. Marketplace may identify credit amounts by attempting to obtain payment using the payment details from the user account. Marketplace may also check an account credit value. If the user account has enough credit marketplace flags the media item as having been purchased for the user account. Marketplace sends a success response to client application . An account of an original owner of the media item may be credited a previously agreed amount. If the payment was not successful marketplace returns a failure response with details about why the request was unsuccessful.

A user of client application may also place a media item for sale in marketplace . In this example client application can attempt to upload the media item using an Internet file transfer method. For example client application may use FTP a file transfer over HTTP or any other method for uploading files via the Internet. Once client application has uploaded the file to marketplace client application receives a UUID for the media item. Client application also sends details about the item. For example the details may include the UUID identifiers used by client application pricing information and metadata that could be used to search for the media item. Marketplace checks whether the authenticated user of client application has the right to place an item for sale. If the authenticated user has the right marketplace adds the item to marketplace and returns a success message. If not marketplace returns a failure response with details about why the request was unsuccessful.

A user may request to edit information about an item previously added to the marketplace. Client application sends an authenticated request to edit a media item with the UUID of the item and any changed information. Marketplace checks to ensure whether the authenticated user has permission to edit the media item. If the user has permission marketplace edits the item and returns a success message. If the user does not have permission marketplace returns a failure message with details about why the request was unsuccessful.

A user may also request to remove a media item from marketplace . Client application sends an authenticated request to remove a media item. The request includes the UUID of the item. Marketplace checks to ensure whether the authenticated user has permission to remove the media item. If the user has permission marketplace flags the media item as removed from marketplace and returns a success message. If the user does not have permission marketplace returns a failure message with details about why the request was unsuccessful. If removed marketplace may no longer return the removed item in queries to marketplace except to users who have previously bought the now removed item.

The method begins with the client identifying media files being added to an uploader step . For example in this illustrative embodiment a computing device and or application responsible for uploading media files e.g. the uploader and or the client in can allow a user to include files to be uploaded to a server as discussed above.

The client identifies the files being marked as related step . For example the application may have an interface to allow a user to input that the one or more of the files to be uploaded are related to each other as a group of media files to be concatenated together upon upload e.g. as illustrated by the screen capture of the application in . In some embodiments the application may be a stand alone software utility e.g. a client application . In other embodiments the application may be a publicly accessible website e.g. a web based application .

The client then begins upload of the media files step . In some embodiments the file transfers upload may begin on user input. In other embodiments file transfers may begin as soon as files are selected. Other embodiments may include other methodologies for beginning uploads. The client initiates the transfer of an individual file by sending a message containing details about the file to the server via for example an Application Programming Interface.

The client sends the media file s themselves to the server using a file transfer protocol. In one embodiment the file may be split into segments which are sent via the HyperText Transfer Protocol. In another embodiment the file may be sent via a custom method built on the User Datagram Protocol. In other embodiments the client may use other file transfer methodologies. In some embodiments the metadata that was extracted previously is transferred with the file using the same protocol.

The client also sends data about the file grout to the server step and notifies the server of the upload step . For example in some embodiments the client may send metadata about the media files that was extracted previously as part of this message. In some embodiments details about the group of related files to be concatenated are sent as part of this message.

In some embodiments the client may provide an interface for the user to choose a name to call the overall group of related uploaded media files for example as illustrated in discussed below. In these embodiments this name may be used to generate the filename of the final concatenated media file. In other embodiments the filename may be generated algorithmically or from other sources including for example without limitation previously saved user preferences.

In some embodiments the client may provide an interface for the user and may select whether the individual file segments should be stitched together based on different criteria. For example the segments may be concatenated and or otherwise stitched together in an order based on the order the files are placed in the window for the media uploader by a specific timecode that is stored with the media file during production e.g. such as a creation time or a last modified time filename and or any other specified or determinable criteria.

In some embodiments the client may send details about the group of related files to be concatenated via for example an Application Programming Interface to the server before or after the files are transferred. Any and all of this name ordering and or detailed information may be included with and or in the data sent to the server as part of step .

The client uploads the file s step . Once file transfer is complete the client may complete the transfer by sending a further message to the server notifying the server that the upload is complete step . In some embodiments this message may also contain the metadata that was extracted previously. In some embodiments details about the group of related files to be concatenated are sent to the server as part of this message.

The client and or the server determine whether another file or group of related files are present to be uploaded step and if so the client selects the next file group to upload step and the method returns to step .

Once the applicable file transfers are completed the client notifies the server that the group upload is complete step and the server retrieves the contents of all uploaded files in the sequence. In some embodiments all files are retrieved while in others the files may be retrieved as they are required. For example the client may upload the files to the server directly or to an intermediate server for retrieval by the server .

Once files are gathered the server concatenates and encodes the files step . For example the server may concatenate and encode the files in a way that is compatible with their existing formatting. In some embodiments this concatenation encoding method may be determined via a database of formats cross referenced with methodologies. In other embodiments this may have been supplied as metadata by the uploading application. In other embodiments the server may use third party software or alternative algorithms to perform this step.

The server stores the concatenated file step . The server checks for errors present in the final concatenated media file. In some embodiments the final concatenated media file may be stored alongside the separate individual files e.g. the pieces of the final concatenated media file . In other embodiments the separate individual files may be deleted upon completion of the creation of the final concatenated media file. In other embodiments the server may store or transfer both the media file pieces and the final concatenated file in a manner that is appropriate to the system and user context.

Upon request the server transfers the concatenated file to a user device step as discussed above. In some embodiments the server may transcode the final concatenated file to a further file format according to user requirements. For example the file may be more easily concatenated to Format A but Format B may be more useful to the user. In this case the file can be concatenated to Format A and then transcoded into Format B before being sent to the user. In these embodiments the file format used while concatenating the file may be different or the same as the file format the file s was were uploaded. Similarly the file format the final concatenated file is transcoded to file may be different or the same as the file format the file s was were uploaded.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of various possible implementations of systems methods and computer program products according to various illustrative embodiments. In this regard each block in the flowchart or block diagrams may represent a module segment function and or a portion of an operation or step. For example one or more of the blocks may be implemented as program code in hardware or a combination of the program code and hardware. In some embodiments the function or functions noted in the block may occur out of the order noted in the figures. For example in some cases two blocks shown in succession may operate substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved and the output of the query optimizer for example. Also other blocks may be added in addition to the illustrated blocks in a flowchart or block diagrams.

The processor processes instructions for software that may be loaded into the memory . The processor may include a number of processors a multi processor core or some other type of processor depending on the particular implementation. Further the processor may be implemented using a number of heterogeneous processor systems in which a main processor is present with secondary processors on a single chip. As another example the processor may be a symmetric multi processor system containing multiple processors of the same type.

The memory and the persistent storage are examples of storage devices . A storage device is any piece of hardware capable of storing information such as data program code and or other suitable information on a temporary or a permanent basis. The memory in the embodiments above may be for example a random access memory or any other suitable volatile or non volatile storage device. The persistent storage may contain one or more components or devices. For example the persistent storage may be a hard drive a flash memory an optical disk a rewritable magnetic tape or any other type of persistent storage device. The media used by the persistent storage also may be removable such as when a removable hard drive is used as the persistent storage .

The communications unit provides for communications with other computer systems or devices. As an example the communications unit could include a network interface card or a wireless transceiver. The communications unit may be implemented in the uploader receiver and transmitter in . The communications unit may provide communications through physical or wireless communications links.

The input output unit allows for input and output of data using other devices that may be connected to the computer system . For example the input output unit may provide a connection for user input through a keyboard a mouse or other suitable input device. The input output unit may also send output to a display printer or other suitable output device. The display provides a mechanism to visually present information to a user.

Program code for an operating system applications or other programs may be located in the storage devices which are in communication with the processor through the bus system . In some embodiments the program code is in a functional form on the persistent storage . These instructions may be loaded into the memory for processing by the processor . The processes of the different embodiments may be performed by the processor using computer implemented instructions which may be located in the memory .

In some embodiments various functions described above are implemented or supported by a computer program product that is formed from computer readable program code and that is embodied in a computer readable medium. Program code for the computer program product may be located in a functional form on a computer readable storage device that could be selectively removable and may be loaded onto or transferred to the computing system for processing by the processor . In some embodiments the program code may also be downloaded over a network to the persistent storage from another device or computer system for use within the computing system . For instance program code stored in a computer readable storage medium in a server computer system may be downloaded over a network from the server to the computing system . The computer system providing the program code may be a server computer a client computer or some other device capable of storing and transmitting program code.

It may be advantageous to set forth definitions of certain words and phrases used throughout this patent document. The terms include and comprise as well as derivatives thereof mean inclusion without limitation. The term or is inclusive meaning and or. The phrases associated with and associated therewith as well as derivatives thereof may mean to include be included within interconnect with contain be contained within connect to or with couple to or with be communicable with cooperate with interleave juxtapose be proximate to be bound to or with have have a property of have a relationship to or with or the like. The phrase at least one of when used with a list of items means that different combinations of one or more of the listed items may be used and only one item in the list may be needed. For example at least one of item A item B and item C may include without limitation item A or item A and item B.

While this disclosure has described certain embodiments and generally associated methods alterations and permutations of these embodiments and methods will be apparent to those skilled in the art. Accordingly the above description of example embodiments does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure as defined by the following claims.

