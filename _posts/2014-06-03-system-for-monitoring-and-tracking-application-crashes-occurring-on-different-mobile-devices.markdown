---

title: System for monitoring and tracking application crashes occurring on different mobile devices
abstract: Some embodiments provide a system that allows application developers to track and monitor crashes that are occurring with their applications on various mobile devices. In some embodiments, the system includes an application programing interface (API) server that receives crash reports with raw crash data from the mobile devices and facilitates in assigning each crash report to one of several different crash processing servers. The crash processing server of some embodiments receives the raw crash data and translates obscure data in the raw crash data into a human or developer readable form.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09436533&OS=09436533&RS=09436533
owner: APTELIGENT, INC.
number: 09436533
owner_city: San Francisco
owner_country: US
publication_date: 20140603
---
This application claims the benefit of U.S. Provisional Patent Application 62 005 951 entitled System for Monitoring and Tracking Application Crashes Occurring on Different Mobile Devices filed May 30 2014. U.S. Provisional Patent Application 62 005 951 is incorporated herein by reference.

The mobile device industry has been growing for a number of years. The growth in the industry has led to a proliferation of many different types of mobile devices from various different vendors. With the growth there is an increasing demand for quality applications. Many application developers rely on user feedback to determine if there are any issues e.g. crash issues with their applications. Such user feedback may be valuable but it may not provide the developers with real time data relating to an application crash. The user feedback may also not provide e.g. at least in real time and with minimum effort if the same crash is an isolated case or is occurring across a number of mobile devices.

Some embodiments provide a system that allows application developers to track and monitor crashes that are occurring with their applications on various mobile devices. In some embodiments the system includes an application programing interface API server that receives crash logs from the mobile devices and facilitates in assigning each crash log to one of several different crash processing servers. The crash processing server of some embodiments receives the raw crash data in a crash log and translates obscure data in the raw crash data into a human or developer readable form in order to present a crash report to an application developer. As an example the crash processor may symbolicate or de obfuscate the raw crash data and generate a translated version of the raw crash data.

In some embodiments the API server facilitates in assigning each crash log to one of several different crash processors by adding the crash log to a task queue. The task queue of some embodiments is implemented by a message queue bus. The message queue bus of some embodiments is a software component of the system that distributes each crash log to an available crash processor. The message queue bus may distribute the work in sequence to the next available crash processor following a round robin dispatching scheme. In some embodiments the message queue bus assigns the crash reports to different crash processors following the competing consumers design pattern.

The crash processor of some embodiments generates a hash code using the crash log. In some embodiments the hash code is used to determine a total occurrence of the same crash as the one specified in the crash log. In generating the hash code the crash processor may use all code line items in the stack trace. This is because typically the information leading up to a crash can be just as important as identifying a particular method call invocation e.g. a first code line item that resulted in the crash. The crash processor of some embodiments generates the hash code by using one or more additional pieces of crash metadata specified in the crash log such as the reason for the crash.

In some embodiments the system includes at least two tiers of crash processors. In some embodiments a first tier crash processor performs a first level symbolication operation on a crash log to provide one or more symbol names for methods that are mobile OS specific and a second tier crash processor performs a second level symbolication operation on the crash log to provide one or more symbol names for methods that are application specific. The first tier crash processor may perform the first level symbolication operation using a custom map file. In some embodiments the custom map file provides mapping for a set of symbol names for a set of OS specific methods that are redacted. In some embodiments the second tier crash processor performs the second level symbolication operation only if an application symbol map is accessible in a storage.

The preceding Summary is intended to serve as a brief introduction to some embodiments as described herein. It is not meant to be an introduction or overview of all subject matter disclosed in this document. The Detailed Description that follows and the Drawings that are referred to in the Detailed Description will further describe the embodiments described in the Summary as well as other embodiments. Accordingly to understand all the embodiments described by this document a full review of the Summary Detailed Description and the Drawings is needed. Moreover the claimed subject matters are not to be limited by the illustrative details in the Summary Detailed Description and the Drawings but rather are to be defined by the appended claims because the claimed subject matters can be embodied in other specific forms without departing from the spirit of the subject matters.

In the following detailed description of the invention numerous details examples and embodiments of the invention are set forth and described. However it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.

Embodiments described herein provide a system that allows application developers to track and monitor crashes that are occurring with their applications on various mobile devices. In some embodiments the system includes an application programing interface API server that receives crash logs from the mobile devices and facilitates in assigning each crash log to one of several different crash processing servers. The crash processing server of some embodiments receives the raw crash data in a crash log and translates obscure data in the raw crash data into a human or developer readable form in order to present a crash report to an application developer. As an example the crash processor may symbolicate or de obfuscate the raw crash data and generate a translated version of the raw crash data.

For some embodiments of the inventions conceptually illustrates a system for tracking and monitoring application crashes occurring on different mobile devices. Specifically this figure shows the system receiving crash reports from several mobile devices processing each crash report and presenting one or more different reports e.g. crash reports to an application developer. As shown the system includes an API server a message queue bus storage a web portal and several tiers of crash processing engines and . In addition each mobile device includes an application with a crash monitor .

In the example of the mobile device can be any mobile device that runs a mobile operating system OS . Examples of different types of mobile devices include a smart phone a tablet a smart watch a phablet etc. Examples of different types of mobile OSs include iOS by Apple Inc. Android OS by Google Inc. Windows Phone etc. In some embodiments the system processes crashes that occur on other types of electronic devices such as a digital media player appliance a game system a smart television TV a smart appliance desktop computer laptop etc.

In some embodiments the application can be a native application a carrier based application or a third party application. The crash monitor of some embodiments runs on the mobile device to detect and report application crashes. For instance when a crash occur the crash monitor may detect that the crash has occurred and save data relating to the crash in order to send a crash report to the API server. In some embodiments a crash is an unhandled exception. Different from a handled exception an unhandled exception is an error in an execution thread that the application could not could not catch and handle. Typically when a crash occurs the application dies or closes because it could not catch and handle the crash.

In some embodiments the crash monitor is a tool provided by a mobile application performance management mAPM solution provider that runs in conjunction with the application to detect and report crashes. In some embodiments the crash monitor saves a crash log each time the application crashes. The crash log is then sent to the API server so that the crash log can be processed by one or more crash processors. The crash log may include a stack trace of code. Typically such a stack trace shows a sequence of method calls that were made by the application leading up to the crash. The crash log may also include other data such as information regarding a thread that crashed a type of exception a reason for the crash etc.

The API server of some embodiments receives crash reports from various mobile devices and initiates the distribution of the processing of each crash report to one or more crash processors and . In some embodiments when a crash report is received from the mobile device the API server enqueues the crash report as a task in a task queue. The task is then retrieved from the task queue and assigned to an available crash processor. The crash processor may process a stack trace of code and if necessary enqueue another task e.g. in the task queue if the stack trace require further processing by another crash processor .

In some embodiments the task queue is implemented by the message queue bus . The message queue bus is a software component of the system that distributes the processing of the crash reports to different crash processors and . The message queue bus may distribute the work in sequence to the next available crash processor following a round robin dispatching scheme. Alternatively the message queue bus may distribute the work using some other dispatching scheme. In some embodiments the message queue bus assigns the crash reports to different crash processors following the competing consumers design pattern. If the design pattern is followed the competing consumers are the tiers of crash processors and that are competing for tasks that are stored with the message queue bus. The message queue bus of some embodiments is implemented using an open sources messaging system such as RabbitMQ . In some embodiments the message queue bus is implemented on the API server . Alternatively the message queue bus may be provided in a separate message queue bus server.

As shown in the system of some embodiments can include several tiers of crash processors and . Each tier can include one more crash processors. The number of crash processors in each tier can change depending on the load. For instance the system can be scaled by adding new crash processors or de scaled by removing existing crash processors. In some embodiments each crash processor is a software component that runs on a particular server. Each crash processor may run on a separate server from each other crash processor in some embodiments.

In some embodiments the first tier crash processor receives a crash report from the message queue bus and processes the crash report. In some embodiments the crash processor reads the crash report to write data relating to the crash to storage . For instance the crash processor may read the crash report to extract raw crash data and crash metadata. The crash processor of some embodiments translates raw crash data into a more human or developer readable form and stores a translated version of the raw crash data in storage. In generating the translated version the crash processor of some embodiments use a map e.g. a custom OS symbol file to translate obscure memory addresses into symbol names e.g. method names . In some embodiments the first tier crash processor symbolicates a stack trace by replacing memory addresses with symbol names of methods that are not specific to the application. In other words the first tier crash processor may replace memory addresses for methods of one or more different available libraries or APIs that were used to code the application.

When a crash log is received the first tier crash processor of some embodiments identifies the crash specified in the crash log. In some embodiment the crash is identified to provide an application developer with statistics regarding the crash. For instance the system may provide a total occurrence of the same crash. The total occurrence can be across all mobile devices across different versions of the same mobile OS across one version of the same OS etc. In some embodiments the first tier crash processor uses one or more lines in a stack trace of code to classify the crash. As an example the crash processor may generate a hash code based on all code line items in the stack trace. The crash processor may also use other data e.g. the reason for the crash in the stack trace to generate the hash code.

The first tier crash processor of some embodiments determines whether the crash data should be processed by one of the second tier crash processors. If so the first tier crash processor may pass the crash data to the second tier crash processor. In some embodiments the first tier crash processor provides the crash data to the second tier crash processor using a task queue. The task queue may be the same one managed by the message queue bus. For instance when it is determined that the crash data should be processed by a second tier crash processor the first tier crash process may enqueue a new task with the message queue bus . The message queue bus then assigns the task to an available second tier crash processor .

In some embodiments the second tier crash processor performs a mapping operation that is similar to the one performed by the first tier crash processor . However the second tier crash processor may use a different map e.g. an application symbol file to translate obscure memory addresses into symbol names e.g. function names method names and store the translated version in storage . In some embodiments the second tier crash processor performs a translation by reading an obfuscation map to de obfuscate the obfuscated code in a stack trace.

The storage stores crash data e.g. raw crash data processed crash data crash metadata . To simplify the description only one storage is shown in . However the crash data may be stored in a number of storages e.g. databases . In addition the data may be stored at different locations e.g. at different data centers . The data may also be accessed using standard Structured Query Language SQL using a NoSQL mechanism or using some other data access protocol.

The web portal provides one or more different crash reports to a web portal client . Based on the crash data in storage the web portal of some embodiments generates a real time global view of application diagnostics and crashes across different mobile device platforms e.g. iOS Android Windows Phone etc. . The web portal may format and or translates the crash data in some manner to present it to developers. For example the captured data may be presented in statistical and or in graphical format. Such a format allows developers to easily track e.g. in real time crashes that are occurring on one or more of their applications across different types of mobile devices mobile OSs application versions etc. This is important because the developers do not have to wait for user feedback. Instead they can access one or more of the different reports and prioritize their work in order to address the application crashes.

In some embodiments the web portal generates different views with trends associated with the monitored applications. Trending represents tracking captured data over some period of time to detect and diagnose changes in the application s performance. The trends can be over different types of data. For instance the API server of some embodiments allows developers to track real time and historical performance across device OS versions etc. The API server may allow developers to view trends by device OS and carrier. For developers such trends can be important from a business perspective as well as a technical perspective. From a business perspective the trends allow the developers to know which device e.g. make and or model OS e.g. version and or carrier is the most popular. From a technical perspective the trends allow the developers to know which device OS and or carrier is the most problematic across the developer s user base.

The web portal client is used to download crash reports and present them to an application developer. In some embodiments the web portal client can also be used to upload a map e.g. application symbol file to store in storage . The second tier crash processor may use such a map to symbolicate or de obfuscate a stack trace and store the processed version in storage . In the example of the web portal client is a standard web browser that accesses the web portal . The web portal delivers web pages to the clients. The web portal might send to the client one or more pages with crash reports device trends OS trends carrier trends etc. In some embodiment the crash data can be accessed via a stand alone application or any other distributed software application or service. For instance instead of a thin client the system may provider a thick client application to access the crash data in storage .

While many of the features of the system have been described as being performed by one component e.g. the API server the message queue bus etc. one of ordinary skill in the art will recognize that the functions of such components and other components described herein might be split up into multiple sub components. Similarly functions described as being performed by multiple different components a first tier crash processor and a second tier crash processor might be performed by a single component a combined first and second tier crash processor in some embodiments.

Many examples of operations of the crash monitoring system are described below. Specifically Section I describes examples operations performed by the system to detect and report crashes. This is followed by Section II which describes how the system of some embodiments distributes crash logs to different crash processors. Section III then describes example operations of several different crash processors. Next Section IV then describes an example data structure used to implement some embodiments of the invention. Section V then describes an example crash report. Finally Section VI describes electronic systems for implementing some embodiments of the invention.

In some embodiments the crash monitor operates in conjunction with an application to detect and report application crashes to an API server. illustrates an example of detecting an application crash and reporting the crash to the API server. Specifically conceptually shows an example user interaction with a mobile device that causes an application to crash. This followed by which illustrates the same mobile device from the perspective of a crash monitor.

Three operational stages of the mobile device are shown in . The first stage shows the mobile device showing a home screen page on the device s touch screen display. The home screen page includes a number of icons several of which are arranged along the bottom of the screen e.g. in a dock . Each icon can be selected to open a corresponding application. Here the user taps the user s finger over an icon associated with the application. The gesture causes the application to be opened as illustrated in the second stage .

The second stage conceptually shows the application being directed to make a method call. In particular the user interacts with the application by tapping the user s finger over a selectable item . The third stage illustrates the mobile device after making the user s selection of the selectable item . This stage shows that the function call resulted in the application crashing for some reason.

As shown in the application executes on the mobile device . In this example the crash monitor is part of an application performance monitor . In addition to the crash monitor the application performance monitor includes a mobile state data collector and output agent .

In some embodiments the mobile device state data collector aggregates state data relating to the mobile device. The mobile state data is sent along with a crash log to the API server in some embodiments. The mobile state data provides context regarding the crash. In other words the mobile state data identifies the state of the mobile device when the crash occurred. In some embodiments the mobile device updates the aggregated data each time there is a change in the state of the mobile device. Examples of different mobile state data include carrier info e.g. the name or identity of the wireless carrier that is servicing the mobile device geo location information e.g. latitude longitude network connectivity information e.g. whether the device was on Wi Fi cellular or not connected etc.

The output agent is responsible for sending each crash report to the API server. The output agent may send the report immediately upon detecting a crash or may send the data when triggered. For instance the data may be sent on a periodic basis. The frequency of this period may be set by the API server. If the application closes due to the crash the output agent may send the crash report when the application is reopened.

Having described several example components the operations of the mobile device will now be described in terms of the four stages that are illustrated in . The first stage illustrates the mobile device state data collector gathering the latest mobile state data and storing it in storage . The mobile device state data collector may initially gather the data when the application is opened and may continue updating the data while the application is opened. For instance if network connectivity changes the mobile device state data collector may be informed of the change and update the state data in the storage. In this manner when a crash log is captured the crash log is associated with the latest state that is stored in the storage.

The second stage illustrates the crash monitor detecting a crash. This stage corresponds to a point in time after the user has initiated the function call by tapping the user s finger over the selectable item in the second stage of . The third stage shows the crash monitor storing data relating to the crash in storage . Particularly the crash monitor has detected the crash captured a crash log and stored the crash log in the storage .

The fourth stage shows the output agent sending a crash report to the API server. In sending the output agent may retrieve the crash data from the storage which includes the crash log and the mobile state data and send the crash data in a message to the API server. The output agent may interface with one or more other components to encrypt the data prior to sending the data to the API server.

As mentioned above the system includes an application programing interface API server that receives crash reports with raw crash data from the mobile devices and facilitates in assigning each crash report to one of several different crash processors. Several examples of distributing crash reports will now be described by reference .

The system of some embodiments uses a task queue to distribute the processing of crash tasks amongst a number of crash processors. provides an illustrates example of the API server communicating with the message queue bus to add a crash report as a task in a task queue . In this example the API server includes 1 a task generator for generating a task from a crash report and 2 a queuing module for enqueuing the task with the message queue bus .

Three operational stages of the system are shown in this figure. The first stage shows the mobile device sending the crash report to the API server . The second stage shows the system after the API server has received the crash report. In particular the report is received by the task generator . The task generator of some embodiments formats the report in a particular format. For instance the task generator may generate a new task message and add the contents of the crash report to the body of the message.

The third stage shows the system after generating the new task. Specifically the queuing module sends the task to the message queue bus . The message queue bus receives the new task and then adds it the task queue . Here the task queue includes a number of other tasks that require processing. Thus the message queue bus adds the new task to the end of the task queue.

In the previous example the API server communicates with the message bus queue to add a new task to the task queue . illustrates an example of the message queue bus distributing tasks in the task queue . In this example the system includes several different sets or groups of first tier crash processors . Each set can include one or more crash processors and can be scaled or descaled as necessary depending on load.

In some embodiments the system provides different crash processors for different types of mobile OSs. In some embodiments the system provides multiple different crash processors for the same mobile OS. For instance the system might provide different crash processors for different versions of the same mobile OS. As another example the system might provide different crash processors for the same mobile OS because the applications can be programmed using different libraries or programing languages. In the example of the sets of crash processors include 1 an iOS set that handles crash reports from applications running on the iOS platform 2 an Android Java set that handles crash report from Android applications programmed at least partially in Java and 3 an Android Native Development Kit NDK set that handles crash reports from Android applications programmed using the NDK. The NDK provides a tool set that a developer can use to code application using one or more different native code languages e.g. C C etc. .

As shown in the task queue includes a number of different tasks for the different sets of first tier crash processors . The message queue bus manages the task queue by distributing each task amongst the one or more crash processors in the set of crash processors or . For each set the message queue bus of some embodiments distribute the work in sequence to the next available crash processor following a round robin dispatching scheme.

In some embodiments the message queue bus assigns the crash reports to different crash processors following the competing consumers design pattern. The competing consumers are the one or more crash processors in a set of crash processors. In the example of the message queue bus assign the first task which is an iOS task to the first available crash processor in the iOS set . The message queue bus then assign the second task which is also an iOS task to the next available crash processor in the iOS set . After assigning the second task the message queue bus then assigns the third task which is an Android Java task to an available crash processor in the Android Java set . The message queue bus then assigns the fourth task to an available crash processor in the Android NDK set . The fourth task was not assigned to the crash processor because it was busy processing another task.

In some embodiments the message queue bus supports failover by maintaining each task until the task has been completed by a crash processor. By maintaining the task the message queue bus prevents the task being lost when a crash processer e.g. a crash processing server suddenly fails or dies for some reason without completing the task. To prevent a task from being lost the message queue bus of some embodiments assigns the task to a crash processor but maintains the task in the task queue . When the task has been processed the crash processor of some embodiments sends a message e.g. acknowledgment message to the message queue bus that indicates the completion of the task. Upon receiving the message the message queue bus may then delete the task from the task queue.

The preceding section described distributing the processing of tasks amongst several crash processors. Several examples operations of different crash processors will now be described by reference to .

In some embodiments a first tier crash processor 1 receives a crash report from the message queue bus 2 translates raw crash data into a more human or developer readable form and 3 stores the translated version in storage. In some embodiments the translation entails generating a version of the raw crash data with obscure information e.g. memory addresses replaced by method or function names. The first tier crash processor may only provide names that are not application specific. This means that the first level processor will provide names for methods or functions that are in different available libraries or application programming interfaces API that were used to code the application. However the first tier crash processor of some embodiments does not provide symbol names of methods e.g. in other APIs or other libraries that are written by the application developer.

The operation of begins when the first tier crash processor receives the crash log . The crash log includes various information relating to the crash. The crash log includes the exception type a reason for the exception and information regarding the thread that crashed. The crash log also shows a stack trace that lists a sequence of method calls that were made by the application leading up to the crash. The sequence is shown in reverse order starting with the first line item that represents the method call that resulted in the application crash proceeding with the next line item that represents a previous method call made in the same thread and so forth.

The crash log shows a stack trace for an application written in Objective C. Here each line item includes a stack line number a name of a library associated with the method call the address of the code that is being executed the starting address of the binary where the code is being executed and the offset within the binary. Different from the crash log the OS specific map includes various memory addresses and their corresponding symbol names.

In some embodiments the OS specific map is a custom map that includes symbol names of different methods that are redacted in APIs used to program the application. For instance in the example of the OS specific map includes two different numbers e.g. addresses for the same method i.e. method . There are several reasons why the OS specific map includes the names of methods that are redacted. First for certain higher versions of a particular mobile OS e.g. iOS the particular mobile OS generates a stack trace has different numbers e.g. memory addresses for methods that are redacted. This means that a stack trace from a lower version of the same mobile OS will not list the same numbers for the same methods. Without the names of the redacted methods a translation of a stack trace of the higher version mobile OS may result in the stack trace listing a redacted method not by symbol name but by a label e.g. redacted label . Accordingly the OS specific custom map provides the means to identify the symbol names for different redacted methods.

Another reason why the system of some embodiments uses a custom map is to identify a total occurrence of the same crash. For instance the same crash may be occurring in different versions of the same mobile OS. By using the custom map the first tier crash processor generates a translated version of the stack trace that is version free. In other words the system translates stack traces to generate versions of the stack traces that are all at the same level. This allows the stack traces to be compared with one another e.g. to identify the total occurrences of different crashes . For instance the crash processor of some embodiments generates a hash code based on the version free stack trace. The hash code is then used to determine how many other times the same crash occurred across a number of mobile devices. An example of generating a hash code based on a stack trace will be described below by reference to .

Referring to the first tier crash processor receives the OS specific map and the crash log and generates a processed crash log . In generating the mapping engine has read the OS specific map and replaced several binary memory addresses in the stack trace with symbol names. The mapping engine has also replaced the offset information with code line numbers.

As method above the first tier crash processor of some embodiments generates a hash code from a crash log in order to identity or classify the error in the crash log. In some embodiments the hash code is used provide a total number of occurrences of the same crash in one or more mobile devices. provides an illustrative example of generating a hash code from a crash log. In this example the first tier crash processor includes a hash function for generating a hash code based on a crash log .

In some embodiments the first tier crash processor generates a hash code using one or more code line items in a stack trace. The first tier crash processor may use all line items in the stack trace. This is because typically the information leading up to a crash may be just as important as identifying a particular method call invocation e.g. a first code line item that resulted in the crash. For instance two stack traces can have the same function crash an application. However the path to get to the function may be different. The developer may care that the stack traces show two different code paths that lead to the application crashing and may wish to have the two crashes identified as different crashes. Thus if only the first line item is hashed the system may be e.g. inadvertently hiding different types crashes. In some embodiments the crash processor generates a hash code by adding all the line items into one long string and uses the string as input to the hash function .

In conjunction with the stack trace line items or instead of them the first tier crash processor of some embodiments generates a hash using other information. In some embodiments the system uses crash metadata in the crash log or the stack trace to generate the hash code. For instance in the example the crash processor generates the hash code by taking into account the reason for the exception. Here the crash processor may take into account the exception type rather than the reason or take into account both the reason and the exception type when generating the has code.

As mentioned above the first tier crash processor of some embodiments determines whether the crash data should be processed by one of the second tier crash processors. In some embodiments the second tier crash processor performs an application specific mapping operation on a code stack trace to provide symbol names for different application methods. Alternatively the second tier crash processor performs a different translation to de obfuscate code in a code stack trace. In some embodiments the second tier processing is only performed when a particular map e.g. a symbol mapping file or an obfuscation mapping file is available.

Three operational stages of the system are shown in this figure. The first stage shows the crash processor reading a piece of metadata from a crash report. The piece of metadata is the application identifier ID . However the crash processor may use a different piece of metadata such as OS version number.

The second stage shows the crash processor determining if the symbol file for an application is stored in storage . In particular the crash processor queries the storage using the application ID. The third stage illustrates the crash processor after determining that the symbol file is stored in storage based on the query. In particular the crash processor communicates with the message queue bus to add a new task to the task queue.

As shown the mapping engine has read the symbol map and performed a symbolication operation on a crash log . The crash log shows a reason for the fault e.g. a segmentation violation a fault address and several lines of un readable debug code. The raw crash log may contain other data. The processed crash log shows that the mapping engine has replaced the un readable debug code with stack frame data. In the processed crash log the mapping engine has also provided various method names line numbers and source code file information e.g. source code location information .

In some embodiments a crash processor performs a different translation to de obfuscate code in a code stack trace. As an example the application s release code may be processed with a particular tool to obfuscate the code in order to prevent reverse engineering and or to shrink the size of the application file s . For instance the application developer may have processed the application using ProGuard. Proguard is a Java class file shrinker optimizer obfuscator and pre verifier. Proguard detects and removes unused classes fields methods and attributes. Proguard also optimizes bytecode and removes unused instructions. Proguard also renames the remaining classes fields and methods using short meaningless names.

In some embodiments the crash processor first tier or second tier uses a ProGuard map file to provide symbol names for the classes fields and methods. Similar to the symbol map file the ProGuard map file may be uploaded to the system by an application developer. illustrates an example of a second tier crash processor that uses such a map to de obfuscate a crash log . This example is similar to the previous two examples. However the second tier processor processes stack traces from Android applications that are at least partially coded using Java. Also the figure includes a de obfuscation engine that reads a ProGuard map to process the crash log .

As shown the de obfuscation engine has read the ProGuard map and performed a de obfuscation operation on a raw crash log . The raw crash log shows a reason for or cause of the crash and several lines of codes that are obfuscated. The processed crash log shows that de obfuscation engine has de obfuscated the raw cash log by providing method names and other code information e.g. method parameter information using the ProGuard map .

Having described example operations of several crash processors an example process will now be described. conceptually illustrates a process that some embodiments implement to store data relating to an application crash. In some embodiments the process is performed by one or more crash processors.

The process begins at when it receives a crash report. The process then stores at crash metadata from the crash report in storage. Examples of crash metadata include an application identifier and mobile state data e.g. network connectivity information carrier information location information etc. . Additional examples of crash metadata will be described below by reference to .

As shown in the process stores at raw crash data from the crash report in storage. The process then performs a first translation at on the raw crash data. In some embodiments the translation entails generating a symbolicated version of a stack trace by replacing memory addresses with symbol names. In some embodiments the process also replaces offset information associated with the memory addresses with code line numbers. In some embodiments the process uses a symbol map e.g. an OS specific map file to identify symbol names. The process of some embodiments identifies a particular symbol map based on the crash metadata. As an example the process may identify a particular symbol map for a particular mobile OS using an application ID or some other piece of crash metadata such as OS version. After performing the translation operation the process stores at a translated version of the raw crash data in storage.

In some embodiments the first level translation is performed for crash logs of applications associated with a particular mobile OS. For instance in some embodiments the process only performs the first level translation for stack traces of iOS applications. That is the process does not perform the first level translation for stack traces of Android applications e.g. Android Java applications Android NDK applications . The first level translation may be performed to place a stack trace in a mobile OS version free format in order to generate a hash code.

At the process generates a hash code based on the crash data. In some embodiments the hash code is used to provide a total count or an estimated total count of the occurrence of a particular crash. In some embodiments prior to hashing the process performs one or more operations on some or all stack traces to bring them up to a level where they can be compared with one another. For instance the process might generate a version of the stack trace having method names for method that have been redacted.

At the process determines whether to perform a second level translation on the crash data. In some embodiments the process makes this determination based on whether a map e.g. a symbol map file a ProGuard map file is available for an application. If the second level translation cannot be performed or is not required the process ends. Otherwise the process performs at a second level translation on the crash data. The process then stores at another translated version of the crash data. The process then ends.

Some embodiments perform variations on the process . The specific operations of the process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Further the process could be implemented using several sub processes or as part of a larger macro process.

In some embodiments the metadata includes mobile state data. An example of storing mobile state data is described above by reference to . In some embodiments the mobile state data can include any one or more of the following carrier info e.g. the name or identity of the wireless carrier that is servicing the mobile device geo location information e.g. latitude longitude network connectivity information e.g. whether the device was on Wi Fi cellular or not connected mobile network code MNC mobile country code MCC roaming time battery level memory usage up time whether the device is compromised e.g. jailbroken or rooted .

In some embodiments the metadata includes breadcrumb data. In some embodiments the application performance monitor includes a breadcrumb data collector to aggregate breadcrumb data. The breadcrumb detection is a special feature a company or app developer can implement which allows them to specify a series of events that occurred before the crash occurred. The breadcrumb data collector is customizable by the developer. For instance the developer might want to know what chain of events e.g. Pressed Login View Account Variable 0 led to the crash in the application. Thus the developer can specify a list of items e.g. changes to the application such as an end user navigated to a different application tab the end user when to a screen to get a list of songs etc. .

When there is a crash the breadcrumbs are then sent with the crash report or as part of the crash report. In this manner the developer can have an understanding of the series of one or more events that occurred prior to crash. In some embodiments developers can specify what breadcrumbs they would like to track through the performance monitor tool or kit SDK . For instance the developers can leave breadcrumbs through a SDK call Service monitor leave Breadcrumb hello world . This is an example of a user defined breadcrumb. In some embodiments the system includes a service monitor captures network breadcrumbs. In some embodiments the network breadcrumbs are logged automatically when any network call happens. In some embodiments the network breadcrumbs are logged automatically but do not show up on error reports unless specified by a developer. Alternatively the network breadcrumbs may only be logged after the developer instructs the service monitor to log network breadcrumbs.

In some embodiments the service monitor is used to track only a set number of network breadcrumbs. The service monitor may only log the last several connections and not all connection. For instance the service monitor may be used to log the last ten network connections. In some embodiments the number of network breadcrumbs the service monitor logs can be customized based on user input. That is the performance monitor tools of some embodiments may allow a user to specify e.g. through the performance monitor tool or kit the maximum number of breadcrumbs to track. In some embodiments the breadcrumb data collector only retains the last several number of network breadcrumbs in a e.g. circular buffer or queue.

In some embodiments the crash data includes exception type e.g. that identifies the type of exception and the reason for the exception e.g. the cause of the exception . The crash data of some embodiments includes information regarding a crashed thread. In some embodiments the system stores each code line item to storage. This is shown in as the data structure includes several line items. For each line the data structure can include one or more of the following 1 a stack line item number 2 the name of the library or API 3 a memory address 4 name of function and 5 a line number within the code that is associated with the function.

In some embodiments the system stores multiple versions of a crash log. For instance the system might store the raw crash data in the crash log. The system might perform one level of translation to generate and store a translated version. The system might perform another level of translation to generate and store another translated version. One or ordinary skill in the art will also recognize that the data structure shown in is just one of many different ways to store data. For instance instead of one data structure the system might use multiple data structures to store the data. In addition the data structure shows example data fields. For instance different embodiments may have additional fields or even fewer fields.

As mentioned above the web portal of some embodiments provides one or more different crash reports to a web portal client. illustrates an example of a crash report generated by the web portal. The generated report is presented on a client device upon user input e.g. by a developer to view real time data . As mentioned above the client machine may be running a thin client or thick client in some embodiments.

As shown the report includes many of the crash data described above by reference to . Specifically the report shows a reported timestamp the name or type of exception the reason for the exception the app version number the stack track with each line of code leading up to the crash.

The report also shows statistical information based on the generated hash code. The report includes the total number of occurrences of the same crash. The report also includes a graph that shows the number of occurrences of the same crash over a particular time period. Although the figure shows a line graph the report may present other types of graphs e.g. a line graph pie chart etc. or other types of graphical representation e.g. media presentation or animation of the captured data. The report also filters the occurrences to different users or mobile devices to provide the total number of affected user. The report also provides the last occurrence of the same crash whether the crash has been resolved etc. Furthermore the report includes a first field that indicates whether a symbol map e.g. dSym file has been uploaded by the developer and a second field that indicates whether the crash log has been symbolicated.

Many of the above described features and applications are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium also referred to as computer readable medium . When these instructions are executed by one or more computational or processing unit s e.g. one or more processors cores of processors or other processing units they cause the processing unit s to perform the actions indicated in the instructions. Examples of computer readable media include but are not limited to CD ROMs flash drives random access memory RAM chips hard drives erasable programmable read only memories EPROMs electrically erasable programmable read only memories EEPROMs etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.

In this specification the term software is meant to include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments the software programs when installed to operate on one or more electronic systems define one or more specific machine implementations that execute and perform the operations of the software programs.

The crash monitor of some embodiments operates on mobile devices. The applications of some embodiments operate on mobile devices. is an example of an architecture of such a mobile computing device. Examples of mobile computing devices include smartphones tablets laptops etc. As shown the mobile computing device includes one or more processing units a memory interface and a peripherals interface .

The peripherals interface is coupled to various sensors and subsystems including a camera subsystem a wireless communication subsystem s an audio subsystem an I O subsystem etc. The peripherals interface enables communication between the processing units and various peripherals. For example an orientation sensor e.g. a gyroscope and an acceleration sensor e.g. an accelerometer is coupled to the peripherals interface to facilitate orientation and acceleration functions.

The camera subsystem is coupled to one or more optical sensors e.g. a charged coupled device CCD optical sensor a complementary metal oxide semiconductor CMOS optical sensor etc. . The camera subsystem coupled with the optical sensors facilitates camera functions such as image and or video data capturing. The wireless communication subsystem serves to facilitate communication functions. In some embodiments the wireless communication subsystem includes radio frequency receivers and transmitters and optical receivers and transmitters not shown in . These receivers and transmitters of some embodiments are implemented to operate over one or more communication networks such as a GSM network a Wi Fi network a Bluetooth network etc. The audio subsystem is coupled to a speaker to output audio e.g. to output different sound effects associated with different image operations . Additionally the audio subsystem is coupled to a microphone to facilitate voice enabled functions such as voice recognition digital recording etc.

The I O subsystem involves the transfer between input output peripheral devices such as a display a touch screen etc. and the data bus of the processing units through the peripherals interface . The I O subsystem includes a touch screen controller and other input controllers to facilitate the transfer between input output peripheral devices and the data bus of the processing units . As shown the touch screen controller is coupled to a touch screen . The touch screen controller detects contact and movement on the touch screen using any of multiple touch sensitivity technologies. The other input controllers are coupled to other input control devices such as one or more buttons. Some embodiments include a near touch sensitive screen and a corresponding controller that can detect near touch interactions instead of or in addition to touch interactions.

The memory interface is coupled to memory . In some embodiments the memory includes volatile memory e.g. high speed random access memory non volatile memory e.g. flash memory a combination of volatile and non volatile memory and or any other type of memory. As illustrated in the memory stores an operating system OS . The OS includes instructions for handling basic system services and for performing hardware dependent tasks.

The memory may include communication instructions to facilitate communicating with one or more additional devices graphical user interface instructions to facilitate graphic user interface processing input processing instructions to facilitate input related e.g. touch input processes and functions. The memory may also include other instructions such as instructions to update different types of mobile device state e.g. location information carrier information network connectivity information etc. . The instructions described above are merely exemplary and the memory includes additional and or other instructions in some embodiments. For instance the memory for a smartphone may include phone instructions to facilitate phone related processes and functions. The above identified instructions need not be implemented as separate software programs or modules. Various functions of the mobile computing device can be implemented in hardware and or in software including in one or more signal processing and or application specific integrated circuits.

While the components illustrated in are shown as separate components one of ordinary skill in the art will recognize that two or more components may be integrated into one or more integrated circuits. In addition two or more components may be coupled together by one or more communication buses or signal lines. Also while many of the functions have been described as being performed by one component one of ordinary skill in the art will realize that the functions described with respect to may be split into two or more integrated circuits.

The bus collectively represents all system peripheral and chipset buses that communicatively connect the numerous internal devices of the electronic system . For instance the bus communicatively connects the processing unit s with the read only memory the GPU the system memory and the permanent storage device .

From these various memory units the processing unit s retrieves instructions to execute and data to process in order to execute the processes of the invention. The processing unit s may be a single processor or a multi core processor in different embodiments.

The read only memory ROM stores static data and instructions that are needed by the processing unit s and other modules of the electronic system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instructions and data even when the electronic system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device .

Other embodiments use a removable storage device such as a floppy disk flash memory device etc. and its corresponding drive as the permanent storage device. Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments the invention s processes are stored in the system memory the permanent storage device and or the read only memory . From these various memory units the processing unit s retrieves instructions to execute and data to process in order to execute the processes of some embodiments.

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the electronic system. The input devices include alphanumeric keyboards and pointing devices also called cursor control devices cameras e.g. webcams microphones or similar devices for receiving voice commands etc. The output devices display images generated by the electronic system or otherwise output data. The output devices include printers and display devices such as cathode ray tubes CRT or liquid crystal displays LCD as well as speakers or similar audio output devices. Some embodiments include devices such as a touchscreen that function as both input and output devices.

Finally as shown in bus also couples electronic system to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the Internet. Any or all components of electronic system may be used in conjunction with the invention.

Some embodiments include electronic components such as microprocessors storage and memory that store computer program instructions in a machine readable or computer readable medium alternatively referred to as computer readable storage media machine readable media or machine readable storage media . Some examples of such computer readable media include RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives read only and recordable Blu Ray discs ultra density optical discs any other optical or magnetic media and floppy disks. The computer readable media may store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations. Examples of computer programs or computer code include machine code such as is produced by a compiler and files including higher level code that are executed by a computer an electronic component or a microprocessor using an interpreter.

While the above discussion primarily refers to microprocessor or multi core processors that execute software some embodiments are performed by one or more integrated circuits such as application specific integrated circuits ASICs or field programmable gate arrays FPGAs . In some embodiments such integrated circuits execute instructions that are stored on the circuit itself. In addition some embodiments execute software stored in programmable logic devices PLDs ROM or RAM devices.

As used in this specification and any claims of this application the terms computer server processor and memory all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification the terms display or displaying means displaying on an electronic device. As used in this specification and any claims of this application the terms computer readable medium computer readable media and machine readable medium are entirely restricted to tangible physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals wired download signals and any other ephemeral signals.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. Also while many of the features of the service monitor have been described as being performed by one component or module e.g. the output agent the mobile device state data collector etc. one of ordinary skill in the art will recognize that the functions of such components described herein might be split up into multiple sub components. Similarly functions described as being performed by multiple different components might be performed by a single component in some embodiments. Further while many of the features of the service monitor have been described as being performed by one module one of ordinary skill in the art will recognize that the functions of such components described herein might be split up into multiple components. Similarly functions described as being performed by multiple different components might be performed by a single component in some embodiments. In addition conceptually illustrates a process. The specific operations of the process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process.

