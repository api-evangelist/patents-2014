---

title: Web of trust management in a distributed system
abstract: A web of trust is used to validate states of a distributed system. The distributed system operates based at least in part on a domain trust. A root of trust issues the domain trust issues a domain trust. Domain trusts are updatable in accordance with rules of previous domain trusts so that a version of a domain trust is verifiable by verifying a chain of previous domain trust versions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09397835&OS=09397835&RS=09397835
owner: Amazon Technologies, Inc.
number: 09397835
owner_city: Seattle
owner_country: US
publication_date: 20140521
---
The security of computing resources and associated data is of high importance in many contexts. As an example organizations often utilize networks of computing devices to provide a robust set of services to their users. Networks often span multiple geographic boundaries and often connect with other networks. An organization for example may support its operations using both internal networks of computing resources and computing resources managed by others. Computers of the organization for instance may communicate with computers of other organizations to access and or provide data while using services of another organization. In many instances organizations configure and operate remote networks using hardware managed by other organizations thereby reducing infrastructure costs and achieving other advantages. With such configurations of computing resources ensuring that access to the resources and the data they hold is secure can be challenging.

In some instances data security is enhanced by a fleet of devices that share cryptographic material e.g. a common set of cryptographic keys . However as the complexity of such systems increases the complexity of maintaining the cryptographic material secure increases accordingly. Further as generally an issue in distributed systems some nodes in a distributed system may have updated information that other nodes have yet to receive as generally propagation techniques take time to reach all nodes in a system. In some distributed systems some nodes may communicate with other nodes on an intermittent basis which can result in many updates being propagated to other nodes before the intermittently connected nodes receive updates. As a result ensuring the integrity of updates propagated throughout a distributed system can present numerous challenges whose difficulty of addressing increases with the complexity of the systems.

In the following description various embodiments will be described. For purposes of explanation specific configurations and details are set forth in order to provide a thorough understanding of the embodiments. However it will also be apparent to one skilled in the art that the embodiments may be practiced without the specific details. Furthermore well known features may be omitted or simplified in order not to obscure the embodiment being described.

Techniques described and suggested herein relate to the secure update of information throughout a distributed system. In an embodiment a distributed system comprises multiple nodes each of which plays a role in the distributed system and some of which play redundant roles in the distributed system. In some examples the distributed system includes a plurality of security modules which may be for example hardware security modules HSMs or other cryptographic devices that securely store and use cryptographic material such as described in more detail below. The security modules may operate services whereby the security modules are operable to perform cryptographic operations on request where requests to the security modules may identify e.g. provide data and specify the cryptographic operation s to perform and in some embodiments parameters for the cryptographic operations to perform such as a mode of a cryptographic algorithm to utilize. Multiple security modules may share the same cryptographic information for the purpose of availability durability and scalability.

The distributed system may also include devices that consume services provided by the security modules. These devices which may be referred to as consumer devices may generate and transmit requests to the security modules thereby causing the security modules to fulfill the requests. As an example a consumer device may generate and transmit a request to encrypt plaintext provided in the request using a cryptographic key identified in the request or otherwise determinable by the security module . The plaintext may be another cryptographic key utilized by the consumer device to perform its own operations although other data is included within the scope of the present disclosure. Similarly a consumer device may generate and transmit a request to a security module to decrypt ciphertext e.g. an encrypted plaintext which may be an encrypted cryptographic key using a cryptographic key identified in the request or otherwise determinable by the security module . Generally the consumer devices may submit requests to the security modules to perform cryptographic operations using cryptographic material securely stored within the cryptographic modules.

The distributed system may also include other nodes that have other roles. For example in some embodiments the distributed system has a plurality of operator devices referred to simply as operators which may be devices operated by human or other administrators of the distributed system. The operators may be responsible for administrative maintenance of the distributed system such as making updates and other changes to the system. In various embodiments as discussed in more detail below many actions performable by the operators require compliance with a set of quorum rules. Another component of a distributed system may include a coordinator module which may be a device responsible for automated administration of various management tasks with the distributed system such as cryptographic key rotation among the security modules and orchestrating updates to the distributed system in accordance with rules and requirements for such updates.

In various embodiments strict security protocols are followed to ensure the security of data handled by the distributed system. For example cryptographic material is required to be rotated i.e. old cryptographic materials is retired and replaced with new cryptographic material with sufficient frequency to avoid enablement of cryptographic attacks that utilize large enough numbers of ciphertexts to determine cryptographic keys. As another example components of the distributed system are configured to operate with a consistent set of parameters about the system to prevent security breaches. For instance a cryptographic domain simply referred to as a domain may be defined by a set of cryptographic keys a set of security modules a set of operators and a set of quorum rules defining conditions for the operators to be able to modify the cryptographic domain and possibly other information in various embodiments. Each security module of a cryptographic domain may be configured with a currently installed domain such that for example the security modules cryptographically verifies compliance with the quorum rules of the currently installed domain before installing anew domain. In this manner the likelihood of an isolated security breach causing a significant effect on the security of data is greatly reduced. As an illustrative example unauthorized access to an operator device would not by itself provide the ability to update a cryptographic domain when quorum rules require authorization by multiple operators. Possible modifications to a cryptographic domain include but are not limited to additions and or subtractions of members of the cryptographic domain additions and or subtractions of operators from the cryptographic domain and or additions and or subtractions of quorum rules of the cryptographic domain. Possible modifications also include modifications to existing elements e.g. members operators and or quorum rules such as modifications that replace a public key of an operator or member with another public key for the operator.

In various embodiments operational components of the distributed system e.g. operators security modules and consumers devices are configured to perform certain operations only upon validation of certain information. As an example as noted a security module may require cryptographic proof that a new version of a domain for installation has been authorized in accordance with a set of quorum rules effective for the current domain where current is from the perspective of the security module since as noted another security module may at a given time have another version of the domain installed . As another example a consumer of a service operated by a security module that sends a request to the security module may not rely on a response from the security module unless a level of trust has been established for the security module which may include cryptographic confirmation that the security module operates in accordance with a valid version of a cryptographic domain. In some embodiments a domain is partially defined by a domain trust which may be a structured collection of information that specifies the operators members e.g. security modules and quorum rules for a domain. Each version of a domain trust may also specify a number or other identifier for the version.

In an embodiment an operational component of the distributed system is configured with the ability to update from one version of a domain to a later version of the domain where the later version of the domain is not the immediately subsequent version of the domain e.g. if the current version of the domain is version N versions are sequenced by increasing integer values and the later version is greater than N 1 . To do this in a secure manner an operational component may perform one or more operations to verify authenticity of the later version domain trust. In some embodiments for some or all operational components of the distributed system it is sufficient to verify that a digital signature of the later version domain trust was generated using a private cryptographic key corresponding to a member e.g. security module identified as a member of the current domain trust. If such a digital signature is not present for example because the domain trust was digitally signed by a member of the later version domain trust that is not present in the current domain trust verification of the later version domain trust may nevertheless be successful. For instance in some embodiments the operational component is configured to use the current version of the domain trust to verify the immediately next version of the domain trust use the latest verified version of the domain trust to verify the immediately next version relative to the latest verified version and so on.

In some embodiments each verified version can be used to verify the immediately next version until one or more criteria for accepting the purported latest version are satisfied. In some embodiments later versions may be sequentially verified until a version is verified that identifies the member of the domain that digitally signed the purported latest version of the domain trust and the digital signature of the domain trust is valid . In other embodiments subsequent versions of the domain trust are sequentially verified until the version immediately preceding the purported latest version is both verified by an earlier version and used to verify the purported latest version. The one or more criteria may be context dependent. For example whether versions of the domain trust need to be verified all the way to the purported latest version may depend on a number of versions between the current version and the purported latest version so that for instance smaller jumps between versions are allowable but larger jumps require verification all the way from the current version to the purported latest version. Other variations are also considered as being within the scope of the present disclosure.

When a later version of a domain trust is verified by an operational component of the distributed system the operational component may operate in accordance with the later version. For example a caller to a security module may accept responses generated by security modules identified in the later version. An operational component may also use the later version of the domain trust to verify whether to install another subsequent version of the domain trust and or the domain . Generally the operational component may operate in accordance with the parameters set by the verified later version of the domain trust.

As illustrated in the domain trust reliant system may receive a copy of a later version of the domain trust which in this example is a domain trust with version N K where K as N may also be a positive integer. As discussed if K is equal to 1 or generally if the received domain trust is an immediate subsequent version of the domain trust version N. The domain trust reliant system may utilize the domain trust version N to verify whether to accept e.g. install the received domain trust . For example the domain trust reliant system may verify digital signatures of the domain trust version N K to determine whether the domain trust version N K has been authorized in accordance with quorum rules of the current domain trust version N .

However as noted K may be an integer that is greater than 1 and as a result the received domain trust may not be an immediately subsequent version to the domain trust version N that the domain trust reliant system currently has installed. To determine whether to accept the domain trust version N K the domain trust reliant system may sequentially verify domain trust versions between version N and N K starting by verifying domain trust version N 1. To do this the domain trust reliant system may obtain the immediate successor to the latest verified domain trust version which if the latest verified version is version N would be version N 1 in embodiments where versions are enumerated with integers and use the latest verified version to verify its immediate successor. Upon successful verification of an immediate successor version the immediate successor version would become the latest verified version. The domain trust reliant system may use the latest verified version to verify an immediate successor version.

This process of using a latest verified version to verify an immediate successor updating the latest verified version as it is verified may repeat until one or more criteria for acceptance of the domain trust version N K are satisfied. In other words successive domain trusts are successively verified where each non latest domain trust is used to verify e.g. cryptographically a next domain trust thereby creating a chain of domain trusts. Such criteria may be such as described above. For example a generator of a digital signature of the domain trust version N K appearing as a member in a latest verified version of the domain trust may be sufficient in some embodiments. In other embodiments the domain trust reliant system verifies immediate successor versions using the latest verified version until the domain trust version N K is an immediate successor to a latest verified version and is successfully verified. As illustrated in the domain trust reliant system may obtain the domain trust versions from a data storage location which in is illustrated as a bucket in reference to a common term used in reference to logical data containers that is identifiers with which data objects are associable to be considered as being in the logical data container. It should be noted that the data storage location may vary in accordance with various embodiments. In some examples the data storage location is hosted in a data storage service that is separate from the domain trust reliant system . Although the data storage location may be in other areas such as in local data storage and or in one or more network accessible data storage devices on an intranet in which the domain trust reliant system is located. Generally the domain trust reliant system may obtain domain trust versions in any suitable manner. Further while illustrates a process where the domain trust reliant system sequentially obtains domain trust versions as they are being verified other variations are also considered as being within the scope of the present disclosure. For example the domain trust reliant system may obtain multiple i.e. some or all domain trust versions in a batch.

The environment may also include a security module coordinator also referred to as a coordinator module which may be a computer system configured to orchestrate administrative processes for the environment . For example the security module coordinator may be configured with executable code that causes the security module coordinator to coordinate cryptographic key rotation among the security modules . The security module coordinator may also perform other administrative operations such as scheduling and orchestrating the update of cryptographic domains and or domain trusts. Example operations and manners for performing operations are described in U.S. patent application Ser. No. 13 916 915 filed Jun. 13 2013 and titled Device Coordination which is incorporated herein by reference. Other operations including operations performed in connection with establishing and maintaining secure sessions are described in U.S. patent application Ser. No. 13 916 964 filed Jun. 13 2013 and titled Session Negotiations which is incorporated herein by reference. In some embodiments for example a group of operators may authorize and update to a domain and or domain trust. The information being updated may be digitally signed by a quorum of the operators i.e. by one or more individual operators who collectively or individually if only one form a quorum where a quorum is defined in accordance with a set of quorum rules of a cryptographic domain installed on a set of the security modules which may be the security modules identified in the current domain.

An operator may provide the authorized update to the security module coordinator which may perform one or more work flows to ensure that the update is installed on an appropriate set of security modules such as a set of security modules identified in the update if the update is to a cryptographic domain. In this manner the operators need only be concerned with obtaining proper authorization and the security module coordinator handles the propagation of updates throughout the environment as appropriate and according to particular updates being made. As discussed above cryptographic domains may define various parameters in which a distributed system may operate. A cryptographic domain may be defined by a domain token.

Returning to the domain token includes one or more domain token fingerprints. A domain token fingerprint may be a hash of a previous domain token version. In an embodiment a domain token includes a hash for each previous version of the domain token . Although in other embodiments the number of domain token fingerprints may be limited. In an embodiment the domain token also includes a set of encrypted domain keys. A domain key may be a key usable for cryptographic operations in accordance with a cryptographic domain defined by the domain token . In an embodiment the domain token includes an encrypted domain key for a current domain token as well as encrypted domain keys for one or more prior versions of the domain token which may be some or all of the previous versions of the domain token . In an embodiment the domain keys are encrypted so as to be decryptable by security modules identified in the domain token . The manner in which the domain keys are encrypted may vary in accordance with various embodiments and generally domain keys may be encrypted in any suitable manner such that security modules can decrypt and utilize the encrypted domain keys. In some embodiments a current domain key is encrypted multiple times each time using a different public key of a different security module of the domain defined by the domain token . As discussed below the domain token may include such public keys although they may be accessed from outside of the domain token. In some embodiments prior version domain keys are encrypted under the current domain key. In this manner a security module may utilize a private key corresponding to the public key that was used to encrypt the current domain key to decrypt the current domain key and if necessary utilize the current domain key to encrypt one or more prior versions of the encrypted domain key. Other ways of encrypting the domain keys are also considered as being within the scope of the present disclosure. For example one or more domain keys whether current or prior may be encrypted using a secret e.g. cryptographic key shared among the security modules which may be a prior version of the domain key or another shared secret. If a new security module is added to the domain a Diffie Hellman key exchange or other secure transfer may be used to enable the added security module to obtain the cryptographic key for decrypting the new domain key from another security module. Generally any way by which encrypted domain keys are encrypted so as to be decryptable by security modules are considered as being within the scope of the present disclosure.

As illustrated in the domain token may also include domain token version information which may be information identifying a version of the domain token . The domain token may be identified using versions that correspond to positive integers such as described above in connection with domain trusts. In an embodiment the domain token also includes a domain trust . The domain trust may include information defining operational components of the domain defined by the domain token rules by which the domain trust can be changed and version information such as described above. In this particular example the domain trust identifies a set of operators in association with operator public keys. Each operator for example may be assigned a public private key pair where the operators securely maintain the private key of the key pair. The domain trust also identifies a set of members in association with the set of member public keys. A member may refer to for example security modules and or other operational components of a domain by the domain token .

The domain trust may also include information defining or otherwise specifying e.g. by reference to information outside of the domain token a set of quorum rules which is a set of one or more rules defining conditions on how the domain trust may be updated by operators identified in the domain trust . A quorum rule for example may specify that authorization by a minimum number of operators is required before changing the domain trust that is updating the domain trust to a newer version. Quorum rules may also be more complex. For example different operators may have different statuses and quorum rules may define complex conditions whereby for instance authorization by a minimum number of a certain status of operator is required and authorization by a different number of operators of a different status is required for changing the domain trust. Various conditions may also be formed through Boolean operators such as AND or OR. Generally in various embodiments any way by which conditions are encodable may be encoded as quorum rules in the domain trust .

As noted domain trust information may identify a current version of the domain trust where in some embodiments the domain trust version is updated sequentially using integer values although other ways of identifying versions are also considered as being within the scope of the present disclosure . Various types of information may be provided with the domain token for the purpose of data security. For example an embodiment of the domain token includes a digital signature generated by a security module that generated the domain token . Similarly the domain trust itself may have a digital signature generated by the security module that generated the domain trust . It should be understood that if stated that the domain trust includes the digital signature only a portion e.g. all of the domain trust except for the digital signature and or possibly some metadata which may identify the security module that generated the digital signature to enable verification of the digital signature using an appropriate public key of the domain trust would be digitally signed. It should be noted that the security module that generated the domain trust may be a different security module or the same security module as that which generated the domain token . Generally for example the domain token may be updated at a frequency that is different than a frequency at which the domain trust is updated. For example as a result of key rotation requirements the domain token may be updated more frequently than the domain trust which may be a more stable set of information which changes less frequently. The signature of the domain token may be generated in various ways in accordance with various embodiments. For example a security module may generate a digital signature using a private key of a public private key pair so as to be verifiable using a public key which may be provided in the domain token . Other information such as information identifying a component of the domain that generated the signature may also be included although such information is not illustrated in the figure.

As illustrated by the lock icon in the domain token may also be encrypted. The domain token may be encrypted so as to be decryptable by the security modules identified in the domain token . In some embodiments for example the domain token is encrypted using a secret shared among the security modules identified in the domain token . As another example the domain token may include the information described above repeated for each security module identified in the domain token. Each redundant copy however may be encrypted using a different public key of a different security module so that a security module may select a copy of the information encrypted under its public key and use its corresponding private key to decrypt the domain token. As yet another example the domain token may be encrypted using a cryptographic key and a copy of the cryptographic key may be encrypted under each public key of each security module identified in the domain token e.g. in the domain trust . The encrypted copies of the cryptographic key may be passed with the domain token as part of the domain token or separate therefrom. If part of the domain token it would be understood that only a portion of the domain token would be encrypted. Similarly a digital signature may be generated using only a portion of the domain token so that the domain token can be said to include the digital signature. Generally any way by which the domain token may be encrypted so as to be decryptable by security modules identified in the domain defined by the domain token is considered as being within the scope of the present disclosure.

Variations of the domain token and or domain trust are considered as being within the scope of the present disclosure. For example if the domain trust is an initial domain trust for a cryptographic domain the domain trust may not identify a set of members. A quorum identified in the initial domain trust may be required to authorize the addition of one or more members security module s . Such additions may be made by an operator quorum authorized command to a security module to add the one or more members which may result in the security module generating a new domain token with an updated domain trust that lists the added one or more members. In some embodiments operators are required to verify a state of a security module being added by cryptographically verifying a remote attestation generated by a security module to be added where the remote attestation may be generated by a trusted platform module TPM or other cryptographic module of the security module. The remote attestation may include one or more cryptographic hashes of application code operating system code and or firmware of the security module. In this manner an operator can prevent adding security modules whose code is in an unauthorized state. In some embodiments update of a domain trust requires verification of a remote attestation by a quorum of operators before the security module can be added to a domain trust i.e. specified in a version of a domain trust .

The cryptographic module which may be a trusted platform module TPM may include a memory subsystem including a main random access memory RAM for storage of instructions and data during program execution and a read only memory ROM in which fixed cryptographic information may be stored such as a hardware secret stored securely within the cryptographic module so as to be non exportable i.e. inaccessible through any call to the cryptographic module . The cryptographic module in some embodiments operates wholly or partly in compliance with Trusted Computing Group s TPM Main Specification level 2 Version 1.2 Revision 116 TPM Main Specification level 2 Version 1.2 Revision 103 and or ISO IEC 11889 which are incorporated herein by reference. The cryptographic module may also store cryptographic keys in RAM and or processor registers for temporary cryptographic processing. The cryptographic information stored in memory may be used in combination with cryptographic information obtained via a network interface. The one or more cryptographic processors may be used to perform cryptographic operations such as described above in the device and may include a random number generator SHA 2 or other hash generator and an encryption decryption signature engine.

As noted above in various embodiments of the present disclosure cryptographic modules including TPMs and security modules may be configured with hardware secrets that are securely stored within hardware. In some embodiments the cryptographic module is implemented as or may contain a physically unclonable function PUF which is a function implemented in physical hardware to use one or more hardware secrets that are based at least in part on physical characteristics of the PUF. As a result any attempt to obtain a hardware secret may require physical intrusion into the PUF and physical intrusion may alter the physical characteristics of the PUF thereby destroying the hardware secret. Example PUFs that may be used include PUFs using explicitly introduced randomness optical PUFs coating PUFs PUFs using intrinsic randomness delay PUFs static random access memory SRAM PUFs butterfly PUFs bistable ring PUFs magnetic PUFs metal resistance PUFs and or other devices whose physical characteristics encode information usable as or for a hardware secret.

Once the new version of the domain trust has been generated one or more digital signatures of the new domain trust version may be obtained where the signatures are obtained to be in compliance with quorum rules of a current domain trust. Obtaining the digital signatures may include digitally signing the new domain trust version and or transmitting the new domain trust version to other operators to be digitally signed. Each operator that signs the new version of the domain trust may do so using a private key of a public private key pair corresponding to the operator although other ways of generating digital signatures are also considered as being within the scope of the present disclosure. In some embodiments each operator of a set of operators sufficient to comply with quorum rules of a current domain trust digitally signs the new version of the domain trust. In other examples more complicated ways of obtaining the digital signatures may be used. For example a first operator may digitally sign the domain trust and the combination of the domain trust with the digital signature generated by the first operator may be digitally signed by a second operator to generate a digital signature of both the domain trust and the first digital signature. That set of information may be digitally signed by another operator and so on. Generally any way by which digital signatures of operators in compliance with quorum rules may be obtained or considered as being within the scope of the present disclosure. Generally cryptographic proof of compliance with current quorum rules may be made in any manner by which a security module or other device would be able to verify the cryptographic proof when its operation is reliant thereon.

In an embodiment when a sufficient set of digital signatures has been obtained to be in compliance with quorum rules of a current domain trust the process may include transmitting the domain trust with the one or more digital signatures to a security module. The security module may be selected as a security module within the current domain. Further the domain trust with one or more digital signatures may be transmitted directly to the security module or through another entity such as through a security module coordinator also referred to as a coordinator module such as described above and in more detail below. The security module that receives the domain trust that was transmitted may use the new domain trust version to generate a new domain token with the new domain trust. The security module for example may replace the current domain trust with a new domain trust and a current domain token encrypt and digital sign the new domain token. This may increment a version of both the domain token and the domain trust while changes to the domain trust outside of the domain trust may cause an increment only to the domain trust and not to the domain token. It should be noted that the domain token may be encrypted then digitally signed or digitally signed and then encrypted. In other words the digital signature may be generated based at least in part on the domain token in plain text form and or the domain token in cyphertext form.

Accordingly when the security module has generated the new domain token the process may include obtaining the new domain token with the new domain trust from the security module that generated the new domain token. Transmission of the domain trust to the security module may be performed directly or indirectly i.e. through another component of a distributed system. Obtaining the new domain token may be performed by receiving the new domain directly from the security module that generated the new domain token or indirectly such as through a security module coordinator. In an embodiment the process includes validating the new domain token that was obtained . Validating the new domain token may include for example verifying a digital signature of the new domain token that was generated by the security module that generated the new domain token. Validating the new domain token may be performed for example by using a public key of a public private key pair corresponding to the security module that generated the new domain token to verify the digital signature of the new domain token. On a condition that the new domain token has been successfully validated the process may include installing the new domain token in one or more security modules defined in the domain token. Installing the new domain token may be performed in any suitable manner such as by transmitting the new domain token to the one or more security modules and or by transmitting the new domain token to a security module coordinator that will perform a process of propagating the new domain token to the security modules.

Numerous variations of the process are considered as being within the scope of the present disclosure. For example as noted the contents of a domain trust may vary depending on whether the domain trust is an initial domain trust or an intermediate version domain trust. Further security modules may be configured such that when an initial domain trust is generated a command to issue the domain trust e.g. make active requires authorization by a quorum of operators as defined by the domain trust. Further before a command to issue a domain trust is issued an operator may be required to verify a remote attestation of the security module s executable code generated by a cryptographic module e.g. TPM of the security module to which the command is to be issued. The operator may avoid issuing a command to a security module that does not provide a valid remote attestation either by not providing an attestation or by providing an invalid one thereby preventing a situation where a compromised security module issues a domain token with unauthorized information e.g. a domain key that is also stored by an unauthorized computer system . Other variations are also considered as being within the scope of the present disclosure.

If it is determined that the quorum rules are not satisfied the request may be denied . Denying the request may include transmitting a response to the request that indicates the denial. The request may be denied in other ways such as simply by performing no action and or by providing a reason for the denial. Other variations are also considered as being within the scope of the present disclosure. If it is determined that the quorum rules are satisfied the process may include generating a new domain token. The new domain token may include information such as described above including a new version of the domain trust i.e. the version of the domain trust included in the request or in alternate embodiments a new domain token generated by the system performing the process that generated the new domain token in accordance with parameters e.g. members operators and or quorum rules specified in the request . Further generating the new domain token may include encrypting and digitally signing the new domain token such as described above. In an embodiment once the new domain token has been generated a system performing the process provides a response to the request with the new domain token. A receiver of the response to the request may then cause the new domain token to be propagated to security modules identified in a cryptographic domain defined by the new domain token such as described above.

As noted above domain trusts may be used in various ways in accordance with various embodiments. In some embodiments at least some communication between nodes of the distributed system is required to be secure. In some embodiments sessions are established in order to enable secure communication between nodes of the distributed system. shows an illustrative example of a process for determining a session key which may be used to encrypt communications for a session. The process may be performed by any suitable system such as by a caller of a security module coordinator and or generally any device configured to securely communicate with a security module. In an embodiment the process includes detecting a need to establish a session with a security module. In some embodiments expiration of a previous session may trigger detection of the need to establish the session with the security module. In other embodiments operation of a system performing the process may detect the need to establish the session with the security module as a result of detecting a need to cause the security module to perform one or more cryptographic operations. As an example a security module service consumer which may perform the process may have itself received a request whose fulfillment requires one or more cryptographic operations performed by a security module. As a result of receiving the request the consumer may detect whether it has an existing session and if not detect a need to establish a session with the security module. Generally the need to establish the session may be detected in various ways in accordance with various embodiments.

Upon detecting a need to establish a session with the security module the process may include performing a secure key exchange such as a Diffie Hellman key exchange operations of which are discussed below. In particular the process may include transmitting an ephemeral public key to the security module. Communications between the system performing the process and a security module and or information contained in the communications e.g. cryptographic keys may be digitally signed using private keys of the respective signing systems to enable validation of the communications and information contained therein although the details of the digital signatures and their verification are omitted from the figure for the purpose of avoiding obfuscation. The ephemeral public key may correspond to a private key generated and maintained securely by the system performing the process . As a result of transmission of the ephemeral public key the security module may generate or otherwise obtain an ephemeral public key which it may transmit to the system performing the process . Accordingly the process may include receiving an ephemeral public key of the security module.

It should be noted that in various embodiments a system performing the process may lack the ability to select a specific security module. For example security modules may from the perspective of a system performing the process be situated in a distributed system behind a load balancer configured to distribute requests among multiple security modules. Accordingly in some embodiments a system performing the process verifies that it is able to trust a security module that responded to its transmission of the digitally signed ephemeral public key. In an embodiment as illustrated in the system performing the process verifies the ability to trust the security module by determining whether the security module is in a current domain trust where a current domain trust is a latest version of a domain trust verified by the system performing the process . It should be noted however that such verification may occur in embodiments when the security module is not behind a load balancer.

If it is determined that the security module is not in a domain trust various operations may be performed in accordance with various embodiments. For example a process of which the process is a sub process may simply fail. However in other embodiments as illustrated in an ephemeral public key may be transmitted to another security module. The other security module may be selected explicitly or in some embodiments not explicitly. For example in embodiments where a security module sits behind a load balancer from the perspective of a system performing the process the ephemeral public key may be repeatedly retransmitted until a security module in the current domain trust responds with an ephemeral public key of that security module. The load balancer may use probabilistic round robin and or other techniques for distributing the transmitted ephemeral public key. Once it is determined that the security module that responded with an ephemeral public key of that security module the process may include determining a session key. The session key may be determined using techniques of a Diffie Hellmann ephemeral key exchange that is using the received ephemeral key and its own private key. Generally the process may be adapted to use any secure key exchange in order to determine a session key that may be used to establish secure communications with a security module.

As discussed various security measures may be implemented to ensure a high level of security and generally to ensure that unauthorized domain trusts are not installed. shows an illustrative example of the process for updating a domain trust in accordance with an embodiment. The process may be performed by any suitable system and generally such as by any system that utilizes a domain trust such as an operator device security module a consumer of a security module coordinator and or generally any device in a distributed system that utilizes domain trusts. As illustrated in the process includes receiving a new domain trust digitally signed by a security module. In some embodiments the domain trust is received in a domain token although in some embodiments domain trusts may be transferred and or generally utilized separately. The new domain trust may be received in a variety of contexts. For example communications between nodes of a distributed system may identify domain trusts used by the respective nodes. The communications may include the domain trust or differences in identified domain trusts may trigger obtaining a domain trust from another system. Generally the new domain trust may be received in any suitable manner.

As illustrated in the process includes determining whether the security module that digitally signed the new domain trust is in the current domain trust. If it is determined that the security module that digitally signed the new domain trust is in the current domain trust the process may include updating to the new domain trust. If however it is determined that the security module that digitally signed the new domain trust is not in the current domain trust the process may include obtaining a set of domain trusts subsequent to the current domain trust. In some embodiments the domain trusts are stored in a database or other data storage system in a location in a distributed system accessible to nodes that may require use of domain trusts. In some examples domain trusts are stored in a separate data storage service and obtaining the domain trust may be performed by submitting one or more application programming interface API calls to the data storage service to retrieve the domain trusts. Generally any way by which the domain trusts may be retrieved may be used.

As illustrated in the process includes validating the next subsequent version of the domain trust where the next subsequent version may be the immediately subsequent version in a series of domain trusts. A determination may be made whether the security module that digitally signed the new domain trust is in the validated domain trust version. If it is determined that the security module is in the validated version of the domain trust the process may include updating to the new domain trust such as described above. If however it is determined that the security module is not in the validated version of the domain trust the process may include determining whether there are any additional subsequent versions. If it is determined that there are no additional subsequent versions the process may include setting the domain trust to the highest validated domain trust version. Thus a system performing a process may operate in accordance with the set domain trust. For example if a system that performed the process received a result of a cryptographic operation e.g. a ciphertext a plaintext of digital signature generated by a security module absent from the highest validated domain trust version the system may reject the received result of the cryptographic operation and perhaps attempt to obtain a result from another security module that is specified in the highest validated domain trust version . As another example in some embodiments a system that has performed the process may replace information corresponding to a previous domain trust version with information corresponding to the highest validated domain trust version. In some examples such a system utilizes a configuration file or other collection of configuration information and as a result of updating to a newer version of a domain trust ceases using the previous version of the domain trust. In this manner if the newer version of the domain trust results in removal of a member operator of a cryptographic domain the system may be operable to reject results of cryptographic operations and or other information from such members operators that have been removed from the cryptographic domain.

If it is determined that there are additional subsequent versions the process may include validating the next subsequent version of the domain trust and determining whether the security module is in that validated version such as described above. As illustrated in this portion of the process may repeat until it is determined that a security module is in a validated version of the domain trust. In this manner a chain of domain trusts where each domain trust is used to verify another domain trust is formed. Except for an initial domain trust in the chain which may be verified another way such as described above is verifiable by starting with a trusted e.g. cryptographically verified domain trust and verifying successive domain trusts until criteria for trusting a domain trust are satisfied. At this point the process may include updating two of the new domain trusts by setting the new domain trust as the current domain trust.

Numerous variations are considered as being within the scope of the present disclosure. For example illustrates a process by which subsequent versions of a domain trust are accessed and then processed sequentially. The process may be modified so that the domain trusts are validated sequentially and also accessed sequentially as needed. As noted above in other embodiments the process may be adapted such that each immediate subsequent version must be validated until reaching the new domain trust that was received . In this manner there is greater security that the security module that digitally signs the new domain trust is actually in a version of that new domain trust that immediately precedes the received new domain trust. Further as another example of a variation of the process considered as being within the scope of the present disclosure the process as illustrated shows a process by which a system performing the process updates to a later version of the domain trust as long as it is able to validate that later version of the domain trust and regardless of whether it ultimately updates the new domain trust that was received . In other embodiments however such an update may not occur and a system performing the process may simply remain with the current domain trust unless it is able to validate the new domain trust that was perceived .

Other variations are also considered as being within the scope of the present disclosure. For example the above description focuses on domain trusts and domain tokens for the purpose of illustration. However the techniques described above may be adapted for use in other contexts. For example the techniques described above may be adapted for use generally with configuration information and information in general utilized by multiple nodes in a distributed system where the configuration or other information is not necessarily information that defines a cryptographic domain. In particular the techniques described above may be used to enable a node in a distributed system to validate updated information and as a result of successful validation operate in accordance with the updated information.

As discussed above various embodiments of the present disclosure are directed to providing cryptography services. Cryptography services may be provided by a cryptography service system such as described above. accordingly shows an illustrative example of a cryptography service in accordance with various embodiments. As illustrated in and as discussed above the cryptography service is logically comprised of a frontend system and a backend system. Both the frontend system and the backend system may be implemented by one or more computer systems configured to perform operations described herein. For example as illustrated in the frontend system of the cryptography service implements a request API and a policy configuration API. The request API in an embodiment is an API configured for requesting cryptographic and other operations to be performed by the cryptography service. Thus requests may be made to the frontend system via the request API in order for such cryptographic operations to be performed by the cryptography service.

A CreateKey KeyID request in an embodiment causes the cryptography service to create a key identified by the KeyID identified in the request. Upon receipt of a request the cryptography service may generate a key and associate the key with the KeyID. It should be known that KeyID s may be but are not necessarily unique identifiers. For instance a KeyID may identify a family of keys. For example in some embodiments key rotation is performed. Key rotation may involve replacing keys with other keys to prevent collection of enough decrypted data to allow practical cracking of a cipher used. If performed at the direction of an entity different from the cryptography service use of the CreateKey KeyID request may cause the cryptography service to create a new key to replace an old key identified by the KeyID. The old key may remain identified by the KeyID but may for instance be only used for decryption of data that has already been encrypted using the old key and not for future encryption. As another example in some embodiments users of the cryptography service provide their own key identifiers and there is a possibility that two different customers may provide the same identifier. In such instances the identifier may not uniquely identify a key or even uniquely identify a family of keys. Various measures may be in place to address this. For example an identity or other information associated with a user of the cryptography service may be used to identify the proper key or family of keys. In still other embodiments the cryptographic service may assign a KeyID randomly sequentially or using any other method.

It should be noted that when a KeyID does not uniquely identify a key various systems may be in place to enable proper functionality. For example in various embodiments a family of keys identified by a KeyID is finite. If a decryption operation using a key identified by a KeyID is requested additional data e.g. a time stamp of when the encryption was performed may enable determining the proper key to use. In some embodiments ciphertexts may include information indicating a key version. In some embodiments all possible keys are used to provide different decryptions of the data. Since there are a finite number of keys the proper decryption may be selected from those provided. In some embodiments decryption with a key is performed in a manner that enables the cryptographic service to detect that the ciphertext was not generated based at least in part on the key such as by using authenticated encryption. Other variations are also considered as being within the scope of the present disclosure.

An Encrypt KeyID Data AAD request may be used to cause the cryptography service to encrypt the specified data using a key identified by the KeyID. Additional Authenticated Data AAD may be used for various purposes and may be data that is not necessarily encrypted but that is authenticated e.g. by an electronic signature a message authentication code or generally a keyed hash value included with the AAD. In some embodiments the ciphertext is generated including at least a portion of the AAD. In some other embodiments the AAD is provided separately during decryption. In some other embodiments the AAD is generated at decryption time based at least in part on the request and or other metadata such that decryption will only succeed when the metadata passes. In some embodiments policy may constrain whether a cryptographic operation can be performed with respect to particular AAD. Processing of Encrypt KeyID Data AAD requests may require by programming logic and or policy enforced by the cryptography service both that the AAD contain particular values and that the AAD be authentic e.g. not modified since original transmission . Similarly a Decrypt KeyID Ciphertext AAD request may be used to cause the cryptography service to decrypt the specified ciphertext using a key identified by the KeyID. The AAD in the Decrypt KeyID Ciphertext AAD request may be used such as described above. For instance processing of the Decrypt KeyID Ciphertext AAD may require by programming logic and or policy enforced by the cryptography service both that the AAD contain particular values and that the AAD be authentic e.g. not modified since original transmission .

The Shred KeyID in an embodiment may be used to cause the cryptography service to electronically shred a key or family of keys identified by the specified KeyID. Electronic shredding may include making the key no longer accessible. For example use of the Shred KeyID request may cause the cryptography system to command one or more hardware devices to perform a SecureErase operation on one or more keys identified by the specified KeyID. Generally the key s identified by the KeyID may be electronically shredded in any suitable manner such as by overwriting data encoding the key with other data e.g. a series of zeroes or ones or a random string . If the key s are stored encrypted under a key the key used to encrypt the keys may be electronically shredded thereby causing a loss of access to the key s . In some embodiments the shred operation may cause decrypt operations indicating the shredded KeyID to fail at some determined point in the future. Other manners of securely and permanently destroying any possible access to the key s may be used.

The ReKey Ciphertext OldKeyID NewKeyID request in an embodiment may be used to cause the cryptography service to encrypt ciphertext under a different key. When the cryptography service receives a ReKey Ciphertext OldKeyID NewKeyID request it may use a key identified by the OldKeyID to decrypt the specified ciphertext and then use a key identified by the NewKeyID to encrypt the decrypted ciphertext. If a key identified by the NewKeyID does not yet exist the cryptography service may generate a key to use and associate the generated key with the specified NewKeyID such as described in connection the Create KeyID request described above. In some embodiments the ReKey operation may be operable to cause data to be transferrable between isolated instances of a cryptography service. In some embodiments a policy might permit a rekey operation to be performed on a ciphertext but might not permit the same requestor to directly decrypt the ciphertext. In some embodiments ReKey might support rekeying a ciphertext from a key identified by a first KeyID within a first account to a key identified by a KeyID within a second account.

Similarly the frontend system may implement a policy configuration API which in an embodiment enables users to submit requests for configuring policies for the performance of cryptographic operations and for other policy related operations. Policies may be associated with keys groups of keys accounts users and other logical entities in various embodiments. Example policies which may be configured via the policy configuration API are provided below. In an embodiment the cryptography service policy configuration API includes the following requests 

In an embodiment the SetKeyPolicy KeyID Policy request may be used to cause the cryptography service to store a policy on the key or family of keys identified by the KeyID. A policy may be information that is determinative of whether a requested cryptographic operation can be performed in a particular context. The policy may be encoded in a declarative access control policy language such as eXtensinble Access Control Markup Language XACML Enterprise Privacy Authorization Language EPAL Amazon Web Services Access Policy Language Microsoft SecPol or any suitable way of encoding one or more conditions that must be satisfied for a cryptographic operation to be performed. Policies may define what operations can be performed when the operations can be performed which entities can make authorized requests for operations to be performed which information is required for a particular request to be authorized and the like. In addition policies may be defined and or enforced using access control lists privileges associated with users and or operation bitmasks in addition to or instead of the examples given above. Example policies appear below.

In some embodiments the cryptographic service may support a suspend operation e.g. using a Suspend KeyID Public Key API call. A suspend operation enables the customer of the cryptographic service to deny the operator of the cryptographic service use of or access to a key. This can be useful to customers concerned about covert lawful orders or other circumstances in which the operator of the cryptographic service might be compelled to perform some operation using a key. It may also be useful to customers that wish to lock particular data and render it inaccessible online. In some embodiments a suspend operation might include receiving a public key from a customer and encrypting the key specified by a given KeyID with the received public key and shredding the key specified by the KeyID such that the provider is not able to access the suspended key unless the private key associated with the public key is provided e.g. using a Reinstate KeyID Private Key API call that both specifies the KeyID and includes the private key. In some other embodiments a suspend operation might involve encrypting a key associated with a specified KeyID using another key managed by the cryptographic service including without limitation one created for the purpose of the instant suspend operation. The ciphertext produced by this operation can be provided to the customer and not retained within the cryptographic service. The original key identified by the KeyID can then be shredded. The cryptographic service may be operable to receive the provided ciphertext and re import the suspended key. In some embodiments the ciphertext may be generated in a manner that will prevent the cryptographic service from returning a decrypted version to the customer.

As illustrated in the cryptography service includes a backend system that itself comprises various components in some embodiments. For example the backend system in this example includes a request processing system unit which may be a subsystem of the cryptography service that is configured to perform operations in accordance with requests received through either the request API or the policy configuration API . For example the request processing component may receive requests received via the request API and the policy configuration API determines whether such requests are authentic and are therefore fulfillable and may fulfill the requests. Fulfilling the request may include for example performing and or having performed cryptographic operations. The request processing unit may be configured to interact with an authentication interface which enables the request processing unit to determine whether requests are authentic. The authentication interface may be configured to interact with an authentication service such as described above. For example when a request is received by the request processing unit the request processing unit may utilize the authentication interface to interact with an authentication service which may if applicable provide authentication proof that may be used in order to cause a performance of cryptographic operations.

The backend system of the cryptography service also in this illustrative example includes a plurality of a security modules cryptography modules a policy enforcement module and a coordinator module . One or more of the security modules may be hardware security modules although in various embodiments a security module may be any suitable computer device configured according to have capabilities described herein. Each security module in an embodiment stores a plurality of keys associated with KeyIDs. Each security module may be configured to securely store the keys so as to not be accessible by other components of the cryptography service and or other components of other systems. In an embodiment some or all of the security modules are compliant with at least one security standard. For example in some embodiments the security modules are each validated as compliant with a Federal Information Processing Standard FIPS outlined in FIPS Publication 140 1 and or 140 2 such as one or more security levels outlined in FIPS Publication 140 2. In addition in some embodiments each security module is certified under the Cryptographic Module Validation Program CMVP . A security module may be implemented as a hardware security module HSM or another security module having some or all capabilities of an HSM. In some embodiments a validated module is used to bootstrap operations. In some embodiments customers can configure some keys that are stored in and operated on only by validated modules and other keys that are operated on by software. In some embodiments the performance or cost associated with these various options may differ.

The security modules may be configured to perform cryptographic operations in accordance with instructions provided by the request processing unit. For example the request processing unit may provide ciphertext and a KeyID to an appropriate security module with instructions to the security module to use a key associated with the KeyID to decrypt the ciphertext and provide in response the plaintext. In an embodiment the backend system of the cryptography service securely stores a plurality of keys forming a key space. Each of the security modules may store all keys in the key space however variations are considered as being within the scope of the present disclosure. For example each of the security modules may store a subspace of the key space. Subspaces of the key space stored by security modules may overlap so that the keys are redundantly stored throughout the security modules. In some embodiments certain keys may be stored only in specified geographic regions. In some embodiments certain keys may be accessible only to operators having a particular certification or clearance level. In some embodiments certain keys may be stored in and used only with a module operated by a particular third party provider under contract with the provider of data storage services. In some embodiments constructive control of security modules may require that lawful orders seeking to compel use of keys other than as authorized by the customer to involve either additional entities being compelled or additional jurisdictions compelling action. In some embodiments customers may be offered independent options for the jurisdiction in which their ciphertexts are stored and their keys are stored. In some embodiments security modules storing keys may be configured to provide audit information to the owner of the keys and the security modules may be configured such that the generation and providing of audit information not suppressible by the customer. In some embodiments the security modules may be configured to independently validate a signature generated by the customer such that the provider e.g. hosting the security modules is not able to perform operations under keys stored by the security modules. In addition some security models may store all of the key space and some security modules may store subspaces of the key space. Other variations are also considered as being the scope of the present disclosure. In instances where different security modules store different subspaces of the key space the request processing unit may be configured such as with a relational table or other mechanism to determine which security module to instruct to perform cryptographic operations in accordance with various requests.

In an embodiment the policy enforcement module is configured to obtain information from a request processing unit and determine based at least in part on that information whether the request received through the API may be performed. For example when a request to perform cryptographic operation is received through the request API the request processing unit may interact with the policy enforcement module to determine whether fulfillment of the request is authorized according to any applicable policy such as policy applicable to a specified KeyID in the request and or other policies such as policy associated with the requestor. If the policy enforcement module allows fulfillment of the request the request processing unit may accordingly instruct an appropriate security module to perform cryptographic operations in accordance with fulfilling the request.

As with all figures described herein numerous variations are considered as being within the scope of the present disclosure. For example shows the policy enforcement module separate from security modules. However each security module may include a policy enforcement module in addition to or instead of the policy enforcement module illustrated as separate. Thus each security module may be independently configured to enforce policy. In addition as another example each security module may include a policy enforcement module which enforces policies different from policies enforced by a separate policy enforcement module. Numerous other variations are considered as being within the scope of the present disclosure.

The illustrative environment includes at least one application server and a data store . It should be understood that there can be several application servers layers or other elements processes or components which may be chained or otherwise configured which can interact to perform tasks such as obtaining data from an appropriate data store. Servers as used herein may be implemented in various ways such as hardware devices or virtual computer systems. In some contexts servers may refer to a programming module being executed on a computer system. As used herein unless otherwise stated or clear from context the term data store refers to any device or combination of devices capable of storing accessing and retrieving data which may include any combination and number of data servers databases data storage devices and data storage media in any standard distributed virtual or clustered environment. The application server can include any appropriate hardware software and firmware for integrating with the data store as needed to execute aspects of one or more applications for the client device handling some or all of the data access and business logic for an application. The application server may provide access control services in cooperation with the data store and is able to generate content including but not limited to text graphics audio video and or other content usable to be provided to the user which may be served to the user by the web server in the form of HyperText Markup Language HTML Extensible Markup Language XML JavaScript Cascading Style Sheets CSS or another appropriate client side structured language. Content transferred to a client device may be processed by the client device to provide the content in one or more forms including but not limited to forms that are perceptible to the user audibly visually and or through other senses including touch taste and or smell. The handling of all requests and responses as well as the delivery of content between the client device and the application server can be handled by the web server using PHP Hypertext Preprocessor PHP Python Ruby Perl Java HTML XML or another appropriate server side structured language in this example. It should be understood that the web and application servers are not required and are merely example components as structured code discussed herein can be executed on any appropriate device or host machine as discussed elsewhere herein. Further operations described herein as being performed by a single device may unless otherwise clear from context be performed collectively by multiple devices which may form a distributed and or virtual system.

The data store can include several separate data tables databases data documents dynamic data storage schemes and or other data storage mechanisms and media for storing data relating to a particular aspect of the present disclosure. For example the data store illustrated may include mechanisms for storing production data and user information which can be used to serve content for the production side. The data store also is shown to include a mechanism for storing log data which can be used for reporting analysis or other such purposes. It should be understood that there can be many other aspects that may need to be stored in the data store such as page image information and access rights information which can be stored in any of the above listed mechanisms as appropriate or in additional mechanisms in the data store . The data store is operable through logic associated therewith to receive instructions from the application server and obtain update or otherwise process data in response thereto. The application server may provide static dynamic or a combination of static and dynamic data in response to the received instructions. Dynamic data such as data used in web logs blogs shopping applications news services and other such applications may be generated by server side structured languages as described herein or may be provided by a content management system CMS operating on or under the control of the application server. In one example a user through a device operated by the user might submit a search request for a certain type of item. In this case the data store might access the user information to verify the identity of the user and can access the catalog detail information to obtain information about items of that type. The information then can be returned to the user such as in a results listing on a web page that the user is able to view via a browser on the user device . Information for a particular item of interest can be viewed in a dedicated page or window of the browser. It should be noted however that embodiments of the present disclosure are not necessarily limited to the context of web pages but may be more generally applicable to processing requests in general where the requests are not necessarily requests for content.

Each server typically will include an operating system that provides executable program instructions for the general administration and operation of that server and typically will include a computer readable storage medium e.g. a hard disk random access memory read only memory etc. storing instructions that when executed by a processor of the server allow the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

The environment in one embodiment is a distributed and or virtual computing environment utilizing several computer systems and components that are interconnected via communication links using one or more computer networks or direct connections. However it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in . Thus the depiction of the system in should be taken as being illustrative in nature and not limiting to the scope of the disclosure.

The various embodiments further can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop laptop or tablet computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network. These devices also can include virtual devices such as virtual machines hypervisors and other virtual devices capable of communicating via a network.

Various embodiments of the present disclosure utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as Transmission Control Protocol Internet Protocol TCP IP User Datagram Protocol UDP protocols operating in various layers of the Open System Interconnection OSI model File Transfer Protocol FTP Universal Plug and Play UpnP Network File System NFS Common Internet File System CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network a satellite network and any combination thereof.

In embodiments utilizing a web server the web server can run any of a variety of server or mid tier applications including Hypertext Transfer Protocol HTTP servers FTP servers Common Gateway Interface CGI servers data servers Java servers Apache servers and business application servers. The server s also may be capable of executing programs or scripts in response to requests from user devices such as by executing one or more web applications that may be implemented as one or more scripts or programs written in any programming language such as Java C C or C or any scripting language such as Ruby PHP Perl Python or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM as well as open source servers such as MySQL Postgres SQLite MongoDB and any other server capable of storing retrieving and accessing structured or unstructured data. Database servers may include table based servers document based servers unstructured servers relational servers non relational servers or combinations of these and or other database servers.

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU or processor at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology Compact Disc Read Only Memory CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

Other variations are within the spirit of the present disclosure. Thus while the disclosed techniques are susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific form or forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention as defined in the appended claims.

The use of the terms a and an and the and similar referents in the context of describing the disclosed embodiments especially in the context of the following claims are to be construed to cover both the singular and the plural unless otherwise indicated herein or clearly contradicted by context. The terms comprising having including and containing are to be construed as open ended terms i.e. meaning including but not limited to unless otherwise noted. The term connected when unmodified and referring to physical connections is to be construed as partly or wholly contained within attached to or joined together even if there is something intervening. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range unless otherwise indicated herein and each separate value is incorporated into the specification as if it were individually recited herein. The use of the term set e.g. a set of items or subset unless otherwise noted or contradicted by context is to be construed as a nonempty collection comprising one or more members. Further unless otherwise noted or contradicted by context the term subset of a corresponding set does not necessarily denote a proper subset of the corresponding set but the subset and the corresponding set may be equal.

Conjunctive language such as phrases of the form at least one of A B and C or at least one of A B and C unless specifically stated otherwise or otherwise clearly contradicted by context is otherwise understood with the context as used in general to present that an item term etc. may be either A or B or C or any nonempty subset of the set of A and B and C. For instance in the illustrative example of a set having three members the conjunctive phrases at least one of A B and C and at least one of A B and C refer to any of the following sets A B C A B A C B C A B C. Thus such conjunctive language is not generally intended to imply that certain embodiments require at least one of A at least one of B and at least one of C each to be present.

Operations of processes described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. Processes described herein or variations and or combinations thereof may be performed under the control of one or more computer systems configured with executable instructions and may be implemented as code e.g. executable instructions one or more computer programs or one or more applications executing collectively on one or more processors by hardware or combinations thereof. The code may be stored on a computer readable storage medium for example in the form of a computer program comprising a plurality of instructions executable by one or more processors. The computer readable storage medium may be non transitory.

The use of any and all examples or exemplary language e.g. such as provided herein is intended merely to better illuminate embodiments of the invention and does not pose a limitation on the scope of the invention unless otherwise claimed. No language in the specification should be construed as indicating any non claimed element as essential to the practice of the invention.

Embodiments of this disclosure are described herein including the best mode known to the inventors for carrying out the invention. Variations of those embodiments may become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventors expect skilled artisans to employ such variations as appropriate and the inventors intend for embodiments of the present disclosure to be practiced otherwise than as specifically described herein. Accordingly the scope of the present disclosure includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover any combination of the above described elements in all possible variations thereof is encompassed by the scope of the present disclosure unless otherwise indicated herein or otherwise clearly contradicted by context.

All references including publications patent applications and patents cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.

