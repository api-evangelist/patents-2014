---

title: Peer-to-peer identity management interfaces and methods
abstract: Peer-to-peer (P2P) application programming interfaces (APIs) that allow an application to create, import, export, manage, enumerate, and delete P2P identities are presented. Further, the management of group identity information is provided. APIs abstract away from low level credential and cryptographic functions required to create and manage P2P identities. This management includes retrieval and setting of a friendly name, generation of a cryptographic public/private key pair, retrieval of security information in the form of an XML fragment, and creation of a new name based on an existing identity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09021106&OS=09021106&RS=09021106
owner: Microsoft Technology Licensing, LLC
number: 09021106
owner_city: Redmond
owner_country: US
publication_date: 20140604
---
This application is a continuation of and priority is claimed to pending U.S. patent application Ser. No. 13 180 406 filed Jul. 11 2011 which is a continuation of issued U.S. patent application Ser. No. 12 559 841 filed Sep. 15 2009 which is a continuation of issued U.S. patent application Ser. No. 10 309 864 filed Dec. 4 2002 and entitled Peer to Peer Identity Management Interfaces and Methods which are hereby expressly incorporated by reference herein.

Peer to peer communication and in fact all types of communication depend on the possibility of establishing valid connections between selected entities. These entities may be peers e.g. users or machines or groups formed within a peer to peer network. However entities may have one or several addresses that may vary because the entities move in the network because the topology changes because an address lease cannot be renewed because the group function or purpose has changed etc. A classic architectural solution to this addressing problem is thus to assign to each entity a stable name and to resolve this name to a current address when a connection is needed. This name to address translation must be very robust and it must also allow for easy and fast updates.

To increase the likelihood that an entity s address may be found by those seeking to connect to it many peer to peer protocols allow entities to publish their individual or group address es through various mechanisms. Some protocols also allow a client to acquire knowledge of other entities addresses through the processing of requests from others in the network. Indeed it is this acquisition of address knowledge that enables successful operation of these peer to peer networks. That is the better the information about other peers and groups in the network the greater the likelihood that a search for a particular resource will converge.

However without a simple and robust mechanism that allows a user to easily establish and manage this single or these various identities that are to be used in the P2P network users will be unable to take advantage of the benefits of the such networks. That is the creation of P2P identities requires that numerous individual pieces of information be created and associated together in a consistent and logical fashion. This creation and association includes the creation of a friendly name the selection and generation of a public private key pair the creation of an identity certificate IDC in coordination with the key pair the association the IDC into the P2P infrastructure the association of that with the name resolution protocol identities etc. Each of these tasks alone are complex and it is unlikely that the casual user would be able to properly create and or associate this information in a manner that would ensure fruitful participation in the P2P network.

Even if a user were able to properly create and associate the required information to form a P2P identity that would allow for successful resolution and participation in the P2P network such participation would be constrained to a single physical location. While this may not seem to be a problem the nature of mobile computing today and of the mobility of users renders such constraints undesirable. This problem is particularly troublesome as a user desires to maintain his or her on line persona regardless of where the user is physically located or onto which computing device the user is logged.

Within the public P2P cloud there may also exist private groups of peers who have associated with one another for a given purpose. Membership in such groups is typically governed by some form of group certificate that is associated with a particular P2P identity. Communications within the group is typically limited to user identities who can present the proper credentials. Therefore it is important for a user identity to be able to properly associate with the group certificate. However since there is no limitation on how many groups a particular P2P identity may belong it become critical to manage not only the various identities that a user may use in the P2P cloud but also the group membership certificates associated with each of the appropriate identities. Currently however no such identity management exists.

The various embodiments disclosed in this application involve a new and improved system and method for identity management in a peer to peer P2P network. More specifically various embodiments are directed to a new and improved P2P application programming interface API and method that allows a user to create import export manage enumerate and delete P2P identities that may be resolved in a P2P network. Further various embodiments are directed to a new and improved P2P application programming interface API and method that allows management of group and identity information.

In one embodiment an API and method are presented that abstracts away from the low level credential and cryptographic functions that are required to be performed to create and manage a P2P identity. A group of related APIs are provided to create delete manage enumerate import and export P2P identities. The management of the P2P identities preferably includes the retrieval and setting of a chosen friendly name the generation of a cryptographic public private key pair the retrieval of security information in the form of an XML fragment and the creation of a new name based on an existing identity. Since the P2P environment also allows for the existence of multiple separate groups of peers within the P2P cloud various embodiments also allow for the enumeration of all groups associated with a given identity for each identity existing for the user.

In one embodiment application programming interfaces are provided that create peer identities that retrieve friendly names of identities that set friendly names of identities that get cryptographic key information for an identity that delete peer identities that export peer identity information that import peer identity information that enumerates peer identities that enumerates groups associated with peer identities that retrieves XML fragments containing security information for an identity and that creates peer names based on existing names of identities. Each of these interfaces utilize various parameters that are passed in from an application program that uses these interfaces to manage a peer identity. The interfaces return a value that indicates the success or failure of the function. For failures the interfaces provide an indication as to the problem resulting in the failure.

While the various embodiments will be described in connection with certain embodiment features there is no intent to limit the claimed subject matter to those embodiments. On the contrary the intent is to cover all alternatives modifications and equivalents as included within the spirit and scope of the various embodiments as defined by the appended claims.

Turning to the drawings wherein like reference numerals refer to like elements the various embodiments are illustrated as being implemented in a suitable computing environment. Although not required the various embodiments will be described in the general context of computer executable instructions such as program modules being executed by a personal computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the various embodiments may be practiced with other computer system configurations including hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The various embodiments may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The various embodiments are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The various embodiments may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The various embodiments may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an example system for implementing the various embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Associate VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers hereto illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

In the description that follows the various embodiments will be described with reference to acts and symbolic representations of operations that are performed by one or more computer unless indicated otherwise. As such it will be understood that such acts and operations which are at times referred to as being computer executed include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However while the various embodiments are being described in the foregoing context it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.

As introduced above the success of a peer to peer P2P protocol depends on the protocol s ability to establish valid connections between selected entities. Likewise the formation of groups in such a P2P network relies on this ability. Because a particular user may connect to the network in various ways at various locations having different addresses one approach is to assign a unique identity to the user or the group and then resolve that identity to a particular address or addresses through the protocol. Such a peer to peer name resolution protocol PNRP to which the identity management system and method of the described embodiments finds particular applicability although by which the various embodiments are not limited is described in co pending application Ser. No. 09 942 164 entitled Peer To Peer Name Resolution Protocol PNRP And Multilevel Cache For Use Therewith filed on Aug. 29 2001 in co pending application Ser. No. 10 122 863 entitled Multi Level Cache Architecture and Cache Management Method for Peer To Peer Name Resolution Protocol filed Apr. 15 2002 and in co pending application Ser. No. 09 955 923 entitled Peer To Peer Group Management and Method For Maintaining Peer To Peer Graphs filed on Sep. 19 2001 the teachings and disclosure of which are hereby incorporated in their entireties by reference thereto.

However one skilled in the art will recognize from the following teachings that the P2P identity management interfaces and methods of the various embodiments are not limited to the particular peer to peer protocol of these co pending applications but may be applied to other resolution protocols with equal force. Likewise co pending application Ser. No. 09 956 260 entitled Peer To Peer Name Resolution Protocol PNRP Security Infrastructure And Method filed on Sep. 19 2001 describes an underlying security infrastructure that ensures that the identities of the various entities within the network are valid without unnecessary burdening the network with excess traffic. In the P2P grouping environment co pending application Ser. No. 09 955 924 entitled Peer To Peer Name Resolution Protocol PNRP Group Security Infrastructure and Method filed on Sep. 19 2001 describes the underlying security infrastructure used for such groups. The teachings and disclosure of these applications are also incorporated in their entireties by reference thereto. However while the interfaces and methods of the various embodiments find particular applicability to and interaction with such PNRP one skilled in the art will recognize that the various embodiments are not limited thereby but have applicability to any P2P system or protocol that desires to provide identity management functions.

As discussed in the above incorporated co pending application describing the PNRP and to provide some useful background establishing peering relations between individual peers is an expensive process in existing peer to peer networks. In the PNRP however each node accumulates a routing table that contains a list of references to other nodes in the network. For each node entry address information which may include a node identification address the key of the node and the distance between the key of this node and the key of the local node are obtained. Each time the local node learns about a remote node it checks whether the node is already known and if not whether to enter an entry in the routing table. Each entry has an ideal cache level determined by its distance from the cache owner. New entries may only be added to the cache level corresponding to their distance or to the lowest level if the entry s ideal cache level has not been breached yet.

For communication between individual peers in PNRP when a node receives a query it searches for the entry in its routing table whose key best matches the target excluding the nodes that have already been visited. The query is then forwarded directly to the node that advertised the entry. If there is no adequate entry the request is sent back to the node from which the request was received this node will try another entry in its own routing table. The request is successful if it reaches the entry whose key matches the target. It is unsuccessful if the target is not reached in the maximum number of steps or if the node from which the request was received tries all possible neighbors and receives a negative response. In the case of successful requests the response is relayed by all intermediate hops. It carries the address of the node that held the target key and this entry can be inserted in the routing tables of the intermediate nodes.

To allow this protocol to operate properly with valid information the underlying security infrastructure described in the above identified application utilizes an underlying trust model. In this model it is assumed that private public key encoding is trusted. That is it is trusted that for one public key there is one and only one private key that can be used to perform the reverse cryptographic operation. Also private public key unique generation is trusted. That is the algorithm for generating private public keys is trusted to produce unique key pairings every time it is run.

It is instructive to note that in view of this trust model the PNRP security infrastructure computes the entity s identity ID as a 128 bit hash of the public key of a self generated RSA key pair. The public key used to generate the ID can also be the public key of one of the X.509 certificates that an entity owns. Other methods of unique ID generation may be used as appropriate provided that they are able to scale to the desired network size while still ensuring global uniqueness of the ID. In one embodiment of the PNRP security infrastructure the uniqueness of the identity is ensured by the algorithm that generates the asymmetric key pairs. As indicated above an entity may also be a group. Therefore the group identity may also be formulated in this way.

As with many successful P2P protocols entities both individual peers as well as groups can be published for easy discovery. To provide security and integrity to the P2P protocol however each identity preferably includes an attached identity certificate. The keeper of the ID s private key uses the certificate to attach additional information to the ID such as the friendly name etc. In one or more embodiments each node generates its own pair of private public keys although such may be provided by a trusted supplier. The public key is then included as part of the node identifier. Likewise a group creator generates group public and private keys. Only the node that created the pair of keys has the private key with which it can prove that it is the creator of the identity. In this way identity theft may be discovered and is therefore deterred.

As also discussed in this above identified application peer identification certificates provide integrity and validity to a peer s identity in the P2P network. These ID certificates are of the form Version ID Validity Algorithms P K. As used in this certificate representation Version is the certificate version ID is the peer name to be published represents information to be associated with the ID Validity represents the period of validity expressed in a pair of From To dates expressed as Universal Date Time aka GMT Algorithms refers to the algorithms used for generating the key pairs and for signing and Pis the public key of the certificate issuer. If the certificate issuer is the same as the ID owner then this can be left blank. In such a case it is assumed that P P. The term Kis the private key pair of P. If the certificate issuer is the ID owner then this is K the private key of the ID owner.

In the P2P group context a group membership certificate of similar structure wherein the comprises the Peer name that is certified as the member of the group and a certificate Serial Number. Such a group membership certificate is of the structure Version ID Peer ID Serial Number Validity Algorithms P P K. As used therein ID is the Group ID Peer ID is the Peer name that is certified as a member of the group Serial Number is the certificate serial number per issuer. PNRP allows every issuer to keep its own numbering scheme. In one or more embodiments certificate serial numbers are globally unique GUID unless the computer does not have a network card. The Validity refers to the period of validity expressed in a pair of From To dates Pis the public key from which the ID was derived and Pis the public key of the certificate issuer. If the certificate issuer is the same as the ID owner then this field can be left blank and it will be assumed that P P. Kis the private key pair of P. If the certificate issuer is the ID owner then this is K the private key pair of the ID owner.

This group membership certificate may be used to verify that the specified Peer ID is a member of the group with the specified group ID. This information is signed with the private key of the issuer K. Depending on the group security policy selected any group member or only a smaller set called group owners can be certificate issuers. In all cases however to verify that the issuer is certified to issue such certificates a chain of group membership certificates has to exist that leads to a certificate signed with the group private key.

Having now provided one P2P environment to which the identity management system and method of the various embodiments finds particular applicability attention is now directed to . This illustrates an example P2P framework in which the various embodiments may exist although it is not limited for use with only such frameworks. Indeed the identity management system and methods of the various embodiments may be used with various frameworks which need or desire a coordinated logical set of interfaces that allow complete management of P2P identities. Of course one skilled in the art will recognize that various application programs can utilize the APIs of the various embodiments to provide a rich user interface and a set of functions that allow management of the various user identities that may be desired in the P2P environment.

As illustrated in this the underlying P2P graphing interfaces utilize a data store that contains all of the information needed in the P2P framework . A description of one embodiment of these graphing interfaces is contained in co pending application Ser. No. 10 309 865 entitled Peer To Peer Graphing Interfaces and Methods filed on even date herewith the teachings and disclosure of which are hereby incorporated in their entireties by reference thereto. The information in the data store is also utilized by a P2P graph security management interface that provides the security necessary for productive participation in a P2P graph. Some form of P2P name to address resolution must also typically be provided to allow the P2P system to function. As discussed above one such system is the PNRP system described in the above identified co pending applications. The identity interfaces of various embodiments are also included in this framework as will be discussed more fully below. Finally in this example framework a set of grouping interfaces are provided to allow proper participation in P2P groups.

Turning now specifically to the identity management interfaces provided by the system and methods of the various embodiments this group of APIs is exposed to the application writers in order to create enumerate and manipulate peer identities. Identities exposed in this API may be provided as input parameters to the grouping and discovery APIs.

A first function of the interface of the various embodiments is a peer identity create function. This function creates a new peer identity and returns its name. The name of the identity is passed in the subsequent calls to identify this newly created identity. If the function fails to create an identity the name of the identity returned is NULL.

The parameters of this function are a classifier a friendly name the cryptographic key provider and the location to which the identity should be returned. The classifier can be NULL but is otherwise appended to the published identity name to make it more user friendly. The friendly name may be chosen by the user for this identity. While it is recommended the friendly name does not have to be unique. If the user does not specify a friendly the function uses the P2P name of the identity as its friendly name. The cryptographic key provider is actually preferably a handle to the container where the key pair exists. If this parameter is NULL then a new public private key pair is generated for this identity. This key pair and the classifier are used to generate peer name of the new identity. Once identity is created it automatically gets persisted on the disk to the location indicated by this parameter. This identity name should be used in subsequent calls to the API.

The return values for this interface include an indication of success or of a particular error encountered. These error messages include an indication that the handle to the key specified is not valid that the identity already exists that the disk volume does not have enough space to accommodate information for the new identity that there is not enough memory to perform the operation that one of the parameters is invalid or that the keys do not exist in the specified container.

The API of the various embodiments also provides functionality to retrieve and set the friendly name for use by a user in the establishment or management of a peer identity. The parameters for the get friendly name function are by way of input the identity name for which the friendly name is desired and by way of output a pointer to the location where the friendly name of the identity should be returned. The set friendly name function or interface modifies the currently friendly name associated with the identity. The parameters for the set friendly name function are the identity name for which the friendly name is to be set and a string containing the new friendly name of the peer identity. This new friendly name can be NULL or an empty string in which case the old friendly name is deleted and the new friendly name will be the peer name of the identity as discussed above. In one or more embodiments the string is a Unicode string to allow for global compatibility.

The return values for these interfaces include an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation that one of the parameters is invalid or that the identity with the specified name cannot be found.

The interface of the various embodiments also provides a get cryptographic key function. This function returns a handle to the private public key pair which is associated with the identity. Caller is responsible for freeing a reference to the container when the caller no longer needs the key. The parameters for this function are the identity name for the peer identity for which the key pair is desired and a pointer to the location where a handle to the key container should be returned. The return values for this interface includes an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation that one of the parameters is invalid or that the identity with the specified name cannot be found.

The interface of the various embodiments also provides functionality to delete peer identities as well. Preferably this function permanently deletes the identity including all certificates private keys and group information associated with the identity. The return values for this interface includes an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation that one of the parameters is invalid or that the identity with the specified name cannot be found.

The management API of the various embodiments also preferably includes export functionality once the peer identity has been created. This function exports an identity to a data structure and encrypts it with a supplied password. Flags can specify different export options such as exporting all groups exporting only groups owned by the identity exporting only groups not owned by the identity exporting just specified groups exporting only identity information without associated group information or exporting all the keys along with the appropriate certificates to which they are attached. Options flags also specify whether to export private keys.

The parameters of this export function are the name of the peer identity to be exported the password to be used to encrypt identity information including identity private key if it is specified for export the export option flags the count of elements in the list of groups in the export list if the export specified groups flag is set an array of group names to be exported and a pointer to the location where the exported data will be placed. The return values for this interface includes an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation that one of the export flags specified is not valid that one of the parameters is invalid or that the identity or group with the specified name cannot be found.

A complementary function in the management of peer identities is the peer identity import function. This function imports identity information in the form of the encrypted data structure discussed above with respect to the export function. Different import options can be specified by setting various parameter flags. Such flags allow for the importation of all groups associated with the identity the importation of only groups owned by the identity the importation of only groups not owned by the identity the importation of only specified groups the importation of only identity information without associated group information the importation of the private keys associated with the identity that information should be overwritten only by newer information during the importation that information should always be overwritten or that information should never be overwritten.

The parameters for this function are a pointer to the data structure that contains the information being imported the password to be used to decrypt the identity information including the identity private key if it is specified for import any combination of the export flags discussed above and a pointer to the location where the name of the imported identity is returned. If this parameter is NULL the name of the identity is not returned. The return values for this interface includes an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation that one of the parameters is invalid that the imported data is not properly formatted or corrupted so it cannot be imported or that the identity export do not overwrite flag is specified and the identity being imported already exists.

The system of the various embodiments also provides the ability to enumerate all of the peer identities. This function creates an enumeration handle that can be used to enumerate through all the identities belonging to the particular user. The parameter for this function is a pointer to the location where the handle to the enumeration object is returned. Enumeration object should be used in the subsequent call to enumerate through the identities. The return values for this interface includes an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation or that one of the parameters is invalid.

Also available is a function to enumerate the groups associated with the peer identities. This function creates an enumeration handle that can be used to enumerate through all the groups associated with a particular identity. The parameters for this function are the name of the identity for which groups will be enumerated and a pointer to the location where the handle to the enumeration object is returned. The enumeration object should be used in the subsequent calls to enumerate through the groups belonging to the specified identity. The return values for this interface includes an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation that one of the parameters is invalid or that the identity with the specified name cannot be found.

The interface of the various embodiments also provides a function that retrieves the security information for the identity in the form of an XML fragment. In order for the identity to join a group it needs to export information about itself and pass it to the existing group member who would be able to issue an invitation. In essence all necessary information about the identity is encapsulated in the identity certificate IDC . In order to adhere to modern data exchange standards this binary structure will be encoded and presented as an XML fragment. This XML fragment will be generated by this function.

Applications are preferably not allowed to add tags within the peer identity information tag or modify this XML fragment in any way. Applications are allowed to incorporate this XML fragment into other XML documents but they are obligated to strip out all their XML before passing this into the API that creates an XML group invitation. This XML fragment should be used when invitation to join the group is issued to this identity. If an application incorporates this fragment into the larger XML document it should strip out surrounding XML and then parse this structure into the peer group create invitation. Applications are not allowed to modify the fragment itself.

The parameters for this function are the peer name of the identity for which information is retrieved and a pointer to the location where the Unicode string containing the XML fragment with the information about the identity is returned. The return values for this interface include an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation that one of the parameters is invalid if the XML identity information is NULL or that the handle to the identity is invalid.

Finally the interface of the various embodiments provides a function that creates a new peer name based on the existing name of the identity and supplied classifier. Creation of the identity name does not imply creation of the identity itself. The parameters for this function are the name of the identity that should be taken as a basis for the new peer name a string containing a new classifier that needs to be appended to the existing name of the identity and a pointer to the location where the new peer name will be returned. The return values for this interface include an indication of success or of a particular error encountered. These error messages include an indication that there is not enough memory to perform the operation that one of the parameters is invalid or that the identity with the specified name cannot be found.

In one embodiment of the interfaces and methods that is particularly well suited for the Microsoft Windows XP operating system the APIs may be as follows 

The foregoing description of various embodiments has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the scope of the claimed subject matter to the precise embodiments disclosed. Numerous modifications or variations are possible in light of the above teachings. The embodiments discussed were chosen and described to provide the best illustration of the principles of the various embodiments and their practical application to thereby enable one of ordinary skill in the art to utilize the various embodiments and with various modifications as are suited to the particular use contemplated. All such modifications and variations are within the scope of the claimed subject matter as determined by the appended claims when interpreted in accordance with the breadth to which they are fairly legally and equitably entitled.

