---

title: Odata offline cache for mobile device
abstract: A server system may include a request handler and a storage. The request handler may receive at least one request from a program on a user side. The storage may include a first cache and a second cache, storing data in format directly compatible to the program. The first cache stores only data matching to a server. If the at least one request corresponds to a change to the data from the program, then the second cache stores the at least one request and the request handler sends the at least one request to the server for updating the change.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09531830&OS=09531830&RS=09531830
owner: SAP SE
number: 09531830
owner_city: Walldorf
owner_country: DE
publication_date: 20140721
---
The present invention relates generally to transferring data between data sources. More particularly the present invention relates to systems and methods for providing consistent data interactivity for mobile devices during online mode and offline mode.

As data protocols advance and develop interoperability needs to be supported for all major software vendors and manufacturers. As business or consumer applications are developed for increasingly mobile use many applications follow the online application operation pattern where applications work only in an online or connected environment with backend data services such as the SAP Netweaver Gateway . This means that once the end user enters a no connectivity zone there may be a delay in information exchange sync with the network and the operation of the application may be difficult to continue.

Also during this offline time if the user s application is closed or killed the updates changes to the user s data may be lost as he was not able to successfully post the updates changes to the backend data service. Even in a pure online case the business data reads through the network may encounter some lag time and updates changes to the data may also have to wait for the backend acknowledgements.

Thus there remains a need for a simple way to handle data operations for both offline and online modes.

Considering data consumption models data solutions may need to follow the online request response pattern in an offline mode such that the response pattern is transparent indifferent to the application developer as seamless online offline behavior. That is the developer may expect to write a single piece of code without additional coding to handle for both online and offline modes.

According to an embodiment the mobile client device may include a request handler and a storage offline stack . The request handler may receive at least one request from a program application on a user side. The storage offline stack may include a first cache persistence and a second cache cache storing data in format directly compatible to the program application . The first cache persistence stores only data matching to a server on the backend. If the at least one request corresponds to a change to the data from the program application then the second cache cache stores the at least one request and the request handler sends the at least one request to the server for updating the change via connection .

The client device may further include miscellaneous service programs and a parser . The server may further include a backend database DB .

The first cache receives updates to the data from the server. The second cache stores and queues the at least one request when the mobile device is offline and the request handler sends the at least one request to the server when the mobile device is online. The first cache receives incremental updates to the data from the server when the mobile device is online. The second cache receives delta incremental updates from the server and updates the data in the first cache . The format of the data may be an internet data format. The at least one request is an internet request with a hyperlink and is the same regardless of whether the mobile device is online or offline.

The mobile device may monitor the condition of the connection to determine when to perform read download updates of data on the mobile device and or when to send update requests upload to the server . Generally for example both of these may be performed in the background whenever the connection indicates the mobile device is connected online with the server . However the mobile device may determine to delay communication in favor of other higher priority communications.

The mobile client device may be online or offline not connected for unpredictable time periods . That is the mobile client device may be connected to the server system intermittently. As such the mobile client device may need to optimize communication of data to ensure communication data integrity and reduce data corruption even in case of intermittent communication disconnections.

According to an embodiment the server communicates with the mobile client device via a wired wireless etc. link.

The data stored in the offline stack of the mobile device may be based on a model e.g. object or hierarchical model that is in a format directly usable by application without additional processing conversion. A parser may parse and or filter data available in the offline stack .

The network may be an internal network an external network or a plurality of different interconnected networks which may include the Internet.

The client device may include for example a mobile device e.g. mobile phone or a smart phone a personal computer a tablet a terminal device or a personal digital assistant PDA . The client device may include an input device e.g. a touch screen a touch pad a mouse or a keyboard to receive commands from the user. In one embodiment the client device may be a terminal that displays information provided by the server . The server may cause the client devices to execute applications and display information on the client devices in response to commands issued at the client device .

The data provider in the server may be a data warehouse. The data warehouse may perform data cleaning integration transformation and refreshing. The data in the data warehouse may expose data via the Open Data Protocol OData . In general OData is a Web protocol for requesting and updating data stored at the data provider in the server . OData is operated by applying and building upon Web technologies such as Hypertext Transfer Protocol HTTP Atom Publishing Protocol AtomPub and JavaScript Object Notation JSON to provide access to information from a variety of applications services and stores. OData may be used to expose and access information from a variety of sources including but not limited to relational databases file systems content management systems and traditional Web sites.

An efficient internet style storage pattern referred to herein as OData Offline Cache may follow a storage pattern where the business data is not stored into the traditional DB relational structure. Instead the data is stored as structured binary large objects BLOBs for each OData Request uniform resource locator URL . These BLOBs contain structured or parsed Data in the form of OData parsed objects which can be directly consumed by application programs even in an offline scenario. Storage of data in this format also saves parse times unlike a pure online scenario where the data is first received in raw feeds of JavaScript Object Notation json or xml format and then parsed for application programs. Such a cache may not follow a traditional relational paradigm but rather may follow an Internet style or paradigm yielding among other things quick access incrementally simpler operation etc. Under this approach the processing operations for offline data is removed or reduced yielding among other things quick access operations involving data in its native format structure etc.

Unlike the traditional DB model where updates inserts deletes are directly replicated to local DB the updates to data are actually managed in a separate queue with a different cache second cache and the update requests are fired sent to the backend server whenever there is network connectivity.

A first cache may maintain each server record as to replicate the behavior of the server such that a user is working directly with a copy of the server data as if the client device is online . The server records are maintained in a different cache first cache from the local cache second cache for the updates inserts deletes. The first cache is thus maintained in the same sync state as the backend data. The first cache may be incrementally refreshed after a successful backend update operations with the latest state preferably with support of delta handling. Invalidation of old data may not be necessary but may be supported as required.

Incremental refresh read from the server may occur as requested by the application if the application requests for data content not previously stored in the first cache . Or if data changed in the backend server that correspond to the data in the first cache . Such data changes may occur as result of an update request from application or from other devices connected to the server .

This allows for dynamic construction population management etc. of the storage offline stack in support of the client device for both online and offline mode.

Under this approach server state condition etc. never touched by client updates. Server state data is always maintained and only refreshed by requesting the backend server for changes. The client local updates may be managed differently using a separate cache second cache reliably. The first cache may be updated through for example refresh operation read requested by client from server . Server state condition etc. is thus always authoritative.

According to an embodiment the process may begin with the application requesting service at to the request handler .

At the request handler may receive requested data for example in internet data format response from backend server via connection .

At the application may send the requested data in internet data format to the parser to parse filter convert.

At as the delta changes match the data in the backend server the cache updates data in persistence cache with the delta changes.

At the cache may load data from persistence cache . This may occur as often as needed and or in the background as required by the application .

At the parser may read parsed response from the local version in the cache and or from the server version in persistence cache . The local version may include locally changed data that are not yet updated to the backend server or to the persistence cache . The different versions of the data may be differentiated by the parser .

According to an embodiment the process may begin with the application requesting to create updates at to the parser .

At the request handler may load persist the queued requests to from the persistence cache such that statuses of queued requests are maintained.

At the application may persist updates of the data to the cache without affecting the original server version of the data.

At the cache may persist the updates of the data to the persistence cache without affecting the original server version of the data.

Subsequent to the updates of the data to the server the client device may perform an incremental update read of the data from the server as illustrated in .

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

Aspects of the above may be implemented by software firmware hardware or any combination thereof. illustrates an example computer system in which the above or portions thereof may be implemented as computer readable code. Various embodiments of the above are described in terms of this example computer system . The client device and the server may each be a computer system .

Computer system includes one or more processors such as processor . Processor can be a special purpose processor or a general purpose processor. Processor is connected to a communication infrastructure for example a bus or a network .

Computer system also includes a main memory preferably Random Access Memory RAM containing possibly inter alia computer software and or data .

Computer system may also include a secondary memory . Secondary memory may include for example a hard disk drive a removable storage drive a memory stick etc. A removable storage drive may comprise a floppy disk drive a magnetic tape drive an optical disk drive a flash memory or the like. A removable storage drive reads from and or writes to a removable storage unit in a well known manner. A removable storage unit may comprise a floppy disk magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated by persons skilled in the relevant art s removable storage unit includes a computer usable storage medium having stored therein possibly inter alia computer software and or data .

In alternative implementations secondary memory may include other similar means for allowing computer programs or other instructions to be loaded into computer system . Such means may include for example a removable storage unit and an interface . Examples of such means may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an Erasable Programmable Read Only Memory EPROM or Programmable Read Only Memory PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to computer system .

Computer system may also include an input interface and a range of input devices such as possibly inter alia a keyboard a mouse etc.

Computer system may also include an output interface and a range of output devices such as possibly inter alia a display one or more speakers etc.

Computer system may also include a communications interface . Communications interface allows software and or data to be transferred between computer system and external devices. Communications interface may include a modem a network interface such as an Ethernet card a communications port a Personal Computer Memory Card International Association PCMCIA slot and card or the like. Software and or data transferred via communications interface are in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communications interface . These signals are provided to communications interface via a communications path . Communications path carries signals and may be implemented using wire or cable fiber optics a phone line a cellular phone link a Radio Frequency RF link or other communications channels.

As used in this document the terms computer program medium computer usable medium and computer readable medium generally refer to media such as removable storage unit removable storage unit and a hard disk installed in hard disk drive . Signals carried over communications path can also embody the logic described herein. Computer program medium and computer usable medium can also refer to memories such as main memory and secondary memory which can be memory semiconductors e.g. Dynamic Random Access Memory DRAM elements etc. . These computer program products are means for providing software to computer system .

Computer programs also called computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed enable computer system to implement the present invention as discussed herein. In particular the computer programs when executed enable processor to implement the processes of aspects of the above. Accordingly such computer programs represent controllers of the computer system . Where the invention is implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive interface hard drive or communications interface .

The invention is also directed to computer program products comprising software stored on any computer useable medium. Such software when executed in one or more data processing devices causes data processing device s to operate as described herein. Embodiments of the invention employ any computer useable or readable medium known now or in the future. Examples of computer useable mediums include but are not limited to primary storage devices e.g. any type of random access memory secondary storage devices e.g. hard drives floppy disks Compact Disc Read Only Memory CD ROM disks Zip disks tapes magnetic storage devices optical storage devices Microelectromechanical Systems MEMS nanotechnological storage device etc. and communication mediums e.g. wired and wireless communications networks local area networks wide area networks intranets etc. .

It is important to note that the particulars of such as for example the specific components that are presented the component arrangement that is depicted etc. are illustrative only and it will be readily apparent to one of ordinary skill in the relevant art that numerous alternatives including inter alia other or different components alternative arrangements etc. are easily possible.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the disclosure may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the disclosure may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data provider may be an information resource. Data provider may include sources of data that enable data storage and retrieval. Data provider may include databases such as relational transactional hierarchical multi dimensional e.g. Online Analytic Processing OLAP object oriented databases and the like. Further data provider may include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. Enterprise resource planning system and the like. These data providers can include associated data foundations semantic layers management systems security systems and so on.

A semantic layer is an abstraction overlying one or more data sources. It removes the need for a user to master the various subtleties of existing query languages when writing queries. The provided abstraction includes metadata description of the data sources. The metadata can include terms meaningful for a user in place of the logical or physical descriptions used by the data source. For example common business terms in place of table and column names. These terms can be localized and or domain specific. The semantic layer may include logic associated with the underlying data allowing it to automatically formulate queries for execution against the underlying data sources. The logic includes connection to structure for and aspects of the data sources. Some semantic layers can be published so that it can be shared by many clients and users. Some semantic layers implement security at a granularity corresponding to the underlying data sources structure or at the semantic layer. The specific forms of semantic layers includes data model objects that describe the underlying data source and define dimensions attributes and measures with the underlying data. The objects can represent relationships between dimension members and can provide calculations associated with the underlying data.

It is appreciated that the disclosure is not limited to the described embodiments and that any number of scenarios and embodiments in which conflicting appointments exist may be resolved.

Although the disclosure has been described with reference to several exemplary embodiments it is understood that the words that have been used are words of description and illustration rather than words of limitation. Changes may be made within the purview of the appended claims as presently stated and as amended without departing from the scope and spirit of the disclosure in its aspects. Although the disclosure has been described with reference to particular means materials and embodiments the disclosure is not intended to be limited to the particulars disclosed rather the disclosure extends to all functionally equivalent structures methods and uses such as are within the scope of the appended claims.

While the computer readable medium may be described as a single medium the term computer readable medium includes a single medium or multiple media such as a centralized or distributed database and or associated caches and servers that store one or more sets of instructions. The term computer readable medium shall also include any medium that is capable of storing encoding or carrying a set of instructions for execution by a processor or that cause a computer system to perform any one or more of the embodiments disclosed herein.

The computer readable medium may comprise a non transitory computer readable medium or media and or comprise a transitory computer readable medium or media. In a particular non limiting exemplary embodiment the computer readable medium may include a solid state memory such as a memory card or other package that houses one or more non volatile read only memories. Further the computer readable medium may be a random access memory or other volatile re writable memory. Additionally the computer readable medium may include a magneto optical or optical medium such as a disk or tapes or other storage device to capture carrier wave signals such as a signal communicated over a transmission medium. Accordingly the disclosure is considered to include any computer readable medium or other equivalents and successor media in which data or instructions may be stored.

Although the present application describes specific embodiments which may be implemented as code segments in computer readable media it is to be understood that dedicated hardware implementations such as application specific integrated circuits programmable logic arrays and other hardware devices may be constructed to implement one or more of the embodiments described herein. Applications that may include the various embodiments set forth herein may broadly include a variety of electronic and computer systems. Accordingly the present application may encompass software firmware and hardware implementations or combinations thereof.

The present specification describes components and functions that may be implemented in particular embodiments with reference to particular standards and protocols the disclosure is not limited to such standards and protocols. Such standards are periodically superseded by faster or more efficient equivalents having essentially the same functions. Accordingly replacement standards and protocols having the same or similar functions are considered equivalents thereof.

The illustrations of the embodiments described herein are intended to provide a general understanding of the various embodiments. The illustrations are not intended to serve as a complete description of all of the elements and features of apparatus and systems that utilize the structures or methods described herein. Many other embodiments may be apparent to those of skill in the art upon reviewing the disclosure. Other embodiments may be utilized and derived from the disclosure such that structural and logical substitutions and changes may be made without departing from the scope of the disclosure. Additionally the illustrations are merely representational and may not be drawn to scale. Certain proportions within the illustrations may be exaggerated while other proportions may be minimized. Accordingly the disclosure and the figures are to be regarded as illustrative rather than restrictive.

One or more embodiments of the disclosure may be referred to herein individually and or collectively by the term disclosure merely for convenience and without intending to voluntarily limit the scope of this application to any particular disclosure or inventive concept. Moreover although specific embodiments have been illustrated and described herein it should be appreciated that any subsequent arrangement designed to achieve the same or similar purpose may be substituted for the specific embodiments shown. This disclosure is intended to cover any and all subsequent adaptations or variations of various embodiments. Combinations of the above embodiments and other embodiments not specifically described herein will be apparent to those of skill in the art upon reviewing the description.

For simplicity of exposition the term database was employed in aspects of the above discussion. It will be readily apparent to one of ordinary skill in the art that in the context of the above discussion the scope of that term is not limited just to for example a database management system but rather encompasses inter alia any data source data model etc.

In addition in the foregoing Detailed Description various features may be grouped together or described in a single embodiment for the purpose of streamlining the disclosure. This disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather as the following claims reflect inventive subject matter may be directed to less than all of the features of any of the disclosed embodiments. Thus the following claims are incorporated into the Detailed Description with each claim standing on its own as defining separately claimed subject matter.

The above disclosed subject matter is to be considered illustrative and not restrictive and the appended claims are intended to cover all such modifications enhancements and other embodiments which fall within the true spirit and scope of the present disclosure. Thus to the maximum extent allowed by law the scope of the present disclosure is to be determined by the broadest permissible interpretation of the following claims and their equivalents and shall not be restricted or limited by the foregoing detailed description.

