---

title: Efficient delivery of image files
abstract: A method of delivering images by an edge server to a web browser is disclosed. It includes receiving through an interface a request for an image file. It includes detecting by a processor the image file as a non-interlaced image file. It includes converting by the processor the detected non-interlaced image file to a corresponding interlaced image file. It includes sending a first segment of the corresponding interlaced image file in response to the request for the image file and delaying delivery of a second segment of the corresponding interlaced image file until a subsequent request for the second segment of the corresponding interlaced image file is received.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507806&OS=09507806&RS=09507806
owner: Instart Logic, Inc.
number: 09507806
owner_city: Palo Alto
owner_country: US
publication_date: 20140430
---
Typically a web browser needs to completely download an entire image in a webpage before the resources e.g. a client server connection that are used to download or render the image can be used to download or render another image on the webpage. When a webpage contains many images there may be insufficient resources to download all the images on the webpage concurrently. As a result the startup wait time experienced by an end user in a browsing session may become unacceptably long on higher latency networks such as cellular 3G networks. Therefore improved techniques for delivering images on a webpage would be desirable.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

A webpage accessed by web browser may be described by different markup languages including Hypertext Markup Language HTML Extensible Markup Language XML and the like. The webpage may also be described by different scripting languages including JavaScript Object Notation JSON and the like. The webpage may be described by other custom languages as well. HTML is used hereinafter as an example of the various languages for describing webpages. Note that the examples of HTML are selected for illustration purposes only accordingly the present application is not limited to these specific examples.

The Document Object Model DOM is a standardized model supported by different web browsers e.g. Internet Explorer Firefox and Google Chrome to represent the various components of a webpage. The DOM is a cross platform and language independent convention for representing and interacting with objects in HTML documents as well as XHTML and XML documents. Objects in a DOM tree may be addressed and manipulated using methods on the objects. The public interface of a DOM is specified in its application programming interfaces APIs .

The DOM standard is specified in different levels. DOM core level 0 and level 1 are the core standards supported by all web browsers while DOM levels 2 and above are extensions to DOM core level 0 and level 1 which can be optionally supported by different web browsers. DOM core level 0 and level 1 define a minimal set of objects and interfaces for accessing and manipulating document objects. It provides a complete model for an entire HTML document including the means to change any portion of the document.

The DOM standard represents documents as a hierarchy of node objects called a DOM tree. Some types of nodes may have child nodes of various types while others are leaf nodes that cannot have any object below them in the document tree structure hierarchy.

With continued reference to when web browser renders webpage on a screen web browser parses the received HTML webpage file and builds a DOM tree to represent the various components of webpage in a local memory. For example when the image tag shown as in is parsed by web browser the image is represented as an image object and the image object is inserted into the DOM tree accordingly.

After the webpage file is parsed and the corresponding DOM tree is created the entire DOM tree can be traversed to retrieve any dependent resources e.g. images audio clips or videos indicated by any of the nodes in the DOM tree via a network. For example the image object corresponding to the image tag in webpage redirects web browser to fetch an image file from an uniform resource locator URL . Accordingly web browser sends a request via a network requesting the image resource to be downloaded. There are two ways a request may be issued statically in which case it is the browser which manipulates the DOM or dynamically in which case the DOM manipulation is done by Javascript. In response to the request the requested dependent resource is sent to web browser via a network.

For example if the nodes of the DOM tree include N different links and or URLs N separate GET requests e.g. N separate HTTP GET requests are sent via a network requesting the dependent resources to be sent to web browser . In response N separate responses e.g. N separate HTTP responses are sent to web browser delivering the dependent resources to web browser .

The round trip time or network response time for a GET request to arrive at an edge server and for its corresponding response to arrive at web browser is dependent on the latency of the network which is different for different types of networks. The network may be any combination of different types of public or private networks including intranets local area networks LANs wide area networks WANs radio access networks RANs Wi Fi networks the Internet and the like. Therefore the latency associated with the overall network may vary depending on the network type s of its constituents.

Some networks have relatively lower network latency. For example the network latency associated with WANs or Wi Fi networks is relatively low e.g. on the order of 10 milliseconds. Suppose the number of links and or URLs included in the DOM tree N is equal to twenty. The total network latency associated with receiving the dependent resources associated with the twenty links and or URLs from the edge server then is approximately 200 milliseconds. To improve network performance present day browsers have become more efficient in reusing connections to the same server such that typically less than 20 of the connections may be fresh connections.

Some networks have relatively higher network latency. For example the network latency associated with a 3generation mobile telecommunications 3G network is relatively high e.g. on the order of 100 milliseconds. In this instance the total network latency associated with receiving the dependent resources associated with the twenty links and or URLs from the edge server is then on the order of 2 seconds.

Since the network latency associated with different types of networks varies widely and web browser needs to receive the dependent resources associated with the links and URLs before web browser can complete the rendering of webpage the startup wait time experienced by the end user of the browsing session may be insignificant in low latency networks such as Wi Fi networks but unacceptably long for an end user in higher latency networks such as 3G networks. Therefore improved techniques for delivering information corresponding to a webpage would be desirable.

Virtualization of the DOM of web browser may be applicable to different types of optimization. In some embodiments using the virtualization engine optimized delivery of information over a network by segmentation and reprioritization of downloaded information can be achieved. For example using the virtualization engine the delivery of the information e.g. the order in which the information is delivered or the granularity of the information delivered and the actual content of the delivered information corresponding to any nodes of the DOM tree may be altered thereby speeding up the rendering of a webpage without compromising the end user s experience.

In some embodiments the virtualization of the DOM of web browser is transparent to web browser . In some embodiments the virtualization of the DOM of web browser is also transparent to the end users. The end users are not required to install any plugins. In some embodiments the virtualization of the DOM of web browser is also transparent to the content publishers without requiring the content publishers to change any program code. In some embodiments client may be injected into web browser based on standards based e.g. HTML or JavaScript procedures. For example after edge server receives a request from web browser requesting an HTML webpage file server may parse the HTML webpage file inject client into the HTML webpage file and then send the response back to web browser . In some embodiments client may be injected by adding JavaScript client code in the head section of the HTML webpage file. Client resides within the execution environment for the web browser and virtualizes the code running within the execution environment. In some embodiments client may be a piece of software that is running outside of the web browser. In some embodiments client may be integrated as part of the code of the web browser.

Virtualization of the DOM of web browser includes handling static and dynamic interactions with the DOM of web browser . Both types of interactions may be intercepted or virtualized by the virtualization engine.

Dynamic interactions with the DOM of web browser include interactions that are affected by JavaScripts which may include the use of Ajax. The DOM of web browser is virtualized by having client intercept and virtualize method API calls to create delete or update elements in the DOM. In some embodiments only DOM core level 1 APIs which are supported by all standardized web browsers are intercepted and virtualized. The DOM core level 1 APIs for manipulating the DOM tree are supplanted by the equivalent JavaScript interfaces of the virtualization engine.

Static interactions to the DOM of web browser include interactions corresponding to static HTML tags in an HTML webpage file e.g. the tag as shown in . An HTML tag redirects web browser to fetch a dependent resource e.g. an image file from an URL. Because the static GET request is not made via a JavaScript the static request is not intercepted by client . Instead the static request is sent by web browser in its native form and then routed over the network e.g. by means of DNS resolution to an edge server supporting virtualization.

In some embodiments edge server may discern whether a GET request is sent by web browser or client using a signature based scheme thus enabling edge server to handle the static case as mentioned above. For example if a GET request was sent by client the GET request would be stamped with a predetermined signature. Conversely if the GET request was sent directly from web browser as in the static case the GET request would not be stamped with the predetermined signature.

In some embodiments when a GET request is sent directly from web browser in a static case edge server may send dummy content in response causing web browser to create a dummy node in the DOM tree. At the same time edge server may also notify client e.g. by sending a JavaScript that a dummy node has just been created in the DOM tree thereby eliminating the need for client to poll the DOM tree for any new dummy nodes added to the DOM tree. Client being notified of the newly created dummy node in the DOM tree may dynamically update the dummy node with the actual content by issuing one or more JavaScript requests to edge server . In response to the one or more requests edge server sends one or more JavaScript updates which are then intercepted by client . Client may then populate the dummy node with the actual image content.

Using the virtualization engine optimized delivery of information over a network by segmentation and reprioritization of downloaded information can be achieved. Note that the delivery of different information to web browser may be determined by the type of the information. For example dependent resources such as images audio clips and videos may be delivered using different techniques that are optimized based on the type of resource. In some embodiments the virtualization engine may selectively alter or modify the delivery of only certain types of information e.g. images . For example images can be efficiently downloaded to web browser by the virtualization engine as will be described in greater detail below.

Some image types support non interlaced and interlaced formats. In a non interlaced image the lines are scanned sequentially from the top to the bottom of the image. In an interlaced image the image is encoded such that the order of the scanned lines is not sequential. The interlaced image file is divided into a series of passes. The first pass shows the image at a lower quality and the following passes gradually improve the image quality. Image types that support both non interlaced format and interlaced format include Graphics Interchange Format GIF and Portable Network Graphics PNG .

GIF is a bitmap image format that is widely used on the World Wide Web due to its wide support and portability. The GIF format supports up to 8 bits per pixel for each image allowing a single image to reference its own palette of up to 256 different colors chosen from the 24 bit RGB color space. The GIF format includes non animated GIF referred to as static GIF format and animated GIF format. An interlaced GIF image is divided from top to bottom into strips 8 pixels high and the rows of the image are presented in the following order 

The pixels within each line are not interlaced but presented consecutively from left to right. As with non interlaced images there is no break between the data for one line and the data for the next. The indicator that an image is interlaced is a bit set in the image s header block.

PNG is a raster graphics file format that supports lossless data compression. PNG supports palette based images with palettes of 24 bit RGB or 32 bit PRBA colors grayscale images with or without alpha channel and full color non palette based RGB A images with or without alpha channel . PNG offers an optional 2 dimensional 7 pass interlacing scheme the Adam7 algorithm. This is more sophisticated than GIF s 1 dimensional 4 pass scheme and allows a clearer low resolution image to be visible earlier in the transfer particularly if interpolation algorithms such as bicubic interpolation are used.

As described above rendering an image in an interlaced format e.g. the GIF interlaced format and the PNG interlaced format shows a reasonable preview of the image after a first pass of rendering with the image increasingly turning sharper after subsequent passes. A web browser can begin displaying an image encoded in an interlaced format as it is being downloaded from the network by rendering each successive pass of the image as it is downloaded and received. Doing so improves on the start up time experienced by the end user. Nonetheless upon a GET for an image the entirety of the image is downloaded. In some instances components of the webpage other than the image may have higher priority than the details of the encoded image contained in the subsequent passes and it would be advantageous to download these important components of the web page before the whole image. In some instances it is preferable to deploy the bandwidth used to download the whole image to instead download other more important components of the webpage. However such prioritization of webpage content is lost when the image is treated as a single binary content.

Therefore in some embodiments the startup wait time can be further reduced by first converting a non interlaced image on a webpage into an interlaced image and then dividing the interlaced image into a plurality of segments. For example the first segment includes the first one or more passes of the interlaced image and the subsequent segment s include the remaining pass es of the interlaced image. With the virtualization engine having control of both ends of the communication in a client and server system the first segment of the interlaced image can be requested by client and sent by edge server first and then the subsequent segment s including the subsequent pass es of the interlaced image can be requested by client and sent by server dynamically to refresh and sharpen the image on demand.

Since a webpage may include content retrieved by multiple GET requests by dividing each GET request into a plurality of GET requests the server transmit queue is reprioritized to transmit and web browser is reprioritized to render the higher priority components e.g. the first pass of an interlaced image of each of the GETs first. In particular if one original GET request corresponds to a huge image the impact of the huge image blocking all the other GET requests would be lessened. As a result the latency of seeing the images from the other GET requests is reduced.

However by reprioritizing the delivery of the images A B C and D using the virtualization engine the first segment of each of the four images A B C and D can be delivered to the web browser first such that the end user can at least view a degraded version of each image before any of the second segment of each image is delivered to the web browser thereby improving the end user s viewing experience. For example the resources for the two concurrent GET requests may be used to obtain the segments of the four images in the following order A1 B1 C1 D1 A2 B2 C2 and D2 where A1 D1 are the first segments and A2 D2 are the second segments of the images A B C and D. In this way the delivery of A1 B1 C1 and D1 are prioritized such that the end user could more quickly view at least a version of each of images A B C and D based on the renderings of A1 B1 C1 and D1. Any or all of A2 B2 C2 and D2 could be delivered at a later time depending on one or more factors such as end user actions e.g. if the end user does not navigate away from webpage .

With reference to at client sends a request to edge server requesting an image file to be downloaded. Note that the underlying communication protocol utilized between client and edge server can be any one of many protocols including proprietary protocols or standards based protocols such as HTTP. In some embodiments the request message sent by client may include different information including the URL of the image resource the dimensions of the image and the like. At edge server receives the image file request from client . At edge server determines whether the image file is stored in cache .

If the image file is found in cache then the image file is retrieved from cache at . If the image file is not found in cache e.g. because the image file is handled by edge server for the very first time then edge server may obtain the image file from an origin server at . At edge server detects the file type of the image file received from origin server . For example if the image file was a PNG image file then the first eight bytes of the image file would include a PNG file signature. Similarly if the image file was a GIF image file then the first three bytes of the header would include a GIF signature. Therefore the file type of the image file may be determined by detecting the various file type signatures.

At edge server converts the image file into a corresponding interlaced image file. In some embodiments edge server converts the image file into an interlaced image file without changing the file type of the image file. For example a non interlaced PNG file is converted into an interlaced PNG image file e.g. by using a tool such as optipng while a non interlaced GIF file is converted into an interlaced GIF image file. In some other embodiments edge server converts the image file into an interlaced image file of a different file type. For example a non interlaced PNG file may be converted into an interlaced GIF file. Since interlaced image files typically have larger file sizes than non interlaced image files edge server may further compress the interlaced image file using an optimizer e.g. pngcrush.

At edge server determines a split point for dividing the interlaced image file into two segments. A split point may be defined as the partitioning in percentages of the first and second segments in size with respect to the interlaced image file. For example a split point of 50 50 would have a first segment and a second segment that are each half the size of the interlaced image file.

The split point can be determined based on many factors. The split point may be limited by a minimum size of the first segment such that the first segment at least includes the header of the image file. For example if the header of the image file is equal to x number of bytes then the split point should divide the first segment and the second segment in such a way that the first segment is at least x bytes in length.

In some embodiments the split point may be determined such that the first segment includes a minimum number of passes of the interlaced image file to give an image that satisfies a minimum level of quality.

In some embodiments the split point may be tuned dynamically based on network load network bandwidth or other specifics of a user s connection. For example the size of the first segment may be only 10 of the total image on a high latency and low bandwidth connection while the size of the first segment may be 90 of the total image on a low latency and high bandwidth connection.

In some embodiments the split point may be determined by identifying a cluster of characterized images in an N dimensional space to which the image belongs. The image file is assigned a split point that is associated with the identified cluster of characterized images.

At edge server splits the interlaced image file into two segments. In this example the interlaced image file is divided into two segments only. However in other embodiments the interlaced image file may be divided into three or more segments and multiple split points are determined. At the interlaced image file is stored in cache . In some embodiments the split point value may be stored in cache as well. For example the split point value may be stored as metadata along with the corresponding interlaced image.

After edge server has either retrieved the interlaced image from cache at or has stored the interlaced image file in cache at edge server sends the first segment of the interlaced image to client at . When edge server sends the first segment of the interlaced image to client it may include additional information e.g. the split point value in the header portion of the message.

At client receives the first segment of the interlaced image. Client then uses the virtualization engine to update the DOM tree with the received image file and the initial image can be rendered on the screen. In particular client updates a DOM element associated with the original image file using the received first segment of the interlaced image file instead of the requested image file. The updating of the DOM element using the first segment of the corresponding interlaced image file instead of the original image file is kept transparent to web browser .

At the resources for downloading the image file can be made available for downloading other dependent resources associated with the webpage. For example the resources may be used to download other images associated with the webpage thereby improving the end user s overall experience.

At client sends a second request to edge server requesting the second segment of the image file to be downloaded. The sending of the second request to edge server is kept transparent to web browser by the virtualization engine. At if edge server receives the request from client requesting the second segment of the image file to be downloaded then edge server sends the second segment of the image file to client at .

At client receives the second segment of the image file. Client then uses the virtualization engine to refresh the image node in the DOM tree with the received image file and a sharper and higher quality image can be rendered on the screen. For example client concatenates the first and the second segments of the image file and converts the concatenated data to data URI Uniform Resource Identifier . The image source is then set with the data URI. Note that although the image source is updated the change is kept transparent to web browser by the virtualization engine of the DOM tree. The change is also kept transparent to the application code so no code change of the application is required. For example suppose that the original image associated with a webpage or an application is X.png and the DOM element source is updated to the data URI. As the virtualization engine acts as a middle layer between the DOM tree and the application the image file continues to appear to the application as X.png. As a result any application code e.g. the program statement if src X.png continues to function without any changes.

With reference to at to display a webpage e.g. webpage as shown in web browser sends an HTTP request message to edge server requesting the HTML webpage file corresponding to the webpage. After edge server locates the requested HTML webpage file edge server parses the HTML webpage file injects client into the HTML webpage file and then sends the HTML webpage file to web browser in an HTTP response message at . Client is then up and running.

At web browser parses the HTML webpage file and builds a DOM tree to represent the various components of webpage in a local memory. For example when the image tag shown as in is parsed by web browser the image is represented as an image object and the image object is inserted into the DOM tree accordingly.

After the DOM tree is created the DOM tree is traversed to retrieve any dependent resources indicated by any of the nodes in the DOM tree via a network. For example the image object corresponding to the static image tag in webpage redirects web browser to fetch an image file from an URL. At web browser sends a GET request in its native form to edge server . Since the GET request is sent directly from web browser the GET request is not stamped with any signature.

At edge server sends dummy content in response causing web browser to create a dummy node in the DOM tree. Edge server also notifies client that a dummy node corresponding to the image resource has just been created in the DOM tree. At client binds to the dummy node.

At client sends a request to edge server requesting a first segment of the image file to be downloaded. Note that the underlying communication protocol utilized between client and edge server can be any one of many protocols including proprietary protocols or standards based protocols such as HTTP. In some embodiments the request message sent by client may include different information including the URL of the dependent resource the dimensions of the image and the like. In some embodiments the request message may also include an indication of how the image should be segmented. For example the request message may specify a percentage e.g. 70 of the total size of the image to be downloaded. In some embodiments edge server determines a percentage of the total size of the image to be downloaded based on network conditions and the like.

At edge server sends the first segment of the interlaced image file to client . Client then uses method API calls to refresh the dummy node in the DOM tree with the received image file and the initial lower quality image can be rendered on the screen.

At client sends another request to edge server requesting the remaining portions of the image file to be downloaded. At edge server sends the remaining portions e.g. the remaining 30 of the interlaced image file to client . Client then uses method API calls to refresh the image node in the DOM tree with the received image file and a sharper and higher quality image can be rendered on the screen.

In some embodiments the refreshing of the image node can be reprioritized based on user actions user profiles the statistical behavior of many users in accessing CDN content or other network profiles.

In some embodiments the refreshing of the image node can be reprioritized based on user actions. During a browsing session a user may scroll to the bottom of a webpage before the webpage is loaded to completion. A user may also expand or minimize certain portions of the webpage. These and other user actions can be used to reprioritize the refreshing of the nodes in the DOM tree. For example if it is detected that the user has scrolled to the bottom of a webpage then client may delay or disable the refreshing of an image node corresponding to an image that is no longer in the display zone.

In some embodiments the refreshing of the image node can be reprioritized based on CDN content access statistics. For example statistics may indicate that very few users choose to look at images on the bottom left corner of the webpage. In this case client may delay or disable the refreshing of the image nodes corresponding to those images.

With reference to at to display a webpage e.g. webpage as shown in web browser sends an HTTP request message to edge server requesting the HTML webpage file corresponding to the webpage. After edge server locates the requested HTML webpage file edge server parses the HTML webpage file injects client into the HTML webpage file and then sends the HTML webpage file to web browser in an HTTP response message at . Client is then up and running.

At web browser parses the HTML webpage file and builds a DOM tree to represent the various components of webpage in a local memory. When the script tag as shown in is parsed by web browser a JavaScript is executed. If the JavaScript creates an image node then the corresponding DOM core level 1 method API call s are intercepted by client as part of the virtualization of the DOM enabling client to control the delivery of the content related to the node.

At client sends a request to edge server requesting a first segment of the image file to be downloaded. Note that the underlying communication protocol utilized between client and edge server can be any one of many protocols including proprietary protocols or standards based protocols such as HTTP. In some embodiments the request message sent by client may include different information including the URL of the image resource the height and width of the image and the like. In some embodiments the request message may also include an indication of how the image should be segmented. For example the request message may specify a percentage e.g. 70 of the total size of the image to be downloaded. In some embodiments edge server determines a percentage of the total size of the image to be downloaded based on network conditions and the like.

At edge server sends the first segment of the interlaced image file to client . Client then uses method API calls to refresh the image node in the DOM tree with the received image file and the initial lower quality image can be rendered on the screen.

At client determines whether there are any events indicating that refreshing of the image node should be delayed or disabled. For example the events checked by client may be any event related to user actions user profiles statistical behavior of many users in accessing CDN content or other network profiles as disclosed above.

If events are not detected then client sends another request to edge server requesting the remaining portions of the image file to be downloaded at . At edge server sends the remaining portions e.g. the remaining 30 of the image file to client . Client then uses method API calls to refresh the image node in the DOM tree with the received image file and a sharper and higher quality image can be rendered on the screen.

In some embodiments client may combine more than one GET requests into a single GET request before sending to edge server thereby reducing the overall round trip delays.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

