---

title: Patching improvement for executables in memory constrained devices
abstract: A processing device determines a memory layout for an executable comprising a plurality of functions and data, wherein the memory layout is determined based on one or more object files. The processing device updates the memory layout by inserting an unused memory region between a first function and a second function of the plurality of functions in the memory layout, wherein the first function and the second function have adjacent memory locations in the memory layout prior to insertion of the unused memory region. The processing device resolves references between the plurality of functions. The processing device then generates an executable comprising the plurality of functions and the data arranged in accordance with the memory layout, the executable having the resolved references.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268552&OS=09268552&RS=09268552
owner: Ayla Networks, Inc.
number: 09268552
owner_city: Sunnyvale
owner_country: US
publication_date: 20140617
---
This patent application claims the benefit under 35 U.S.C. 119 e of U.S. Provisional Application No. 61 836 546 filed Jun. 18 2013.

Many modern appliances consumer devices and other devices include embedded systems that are configured to perform one or more dedicated functions. Frequently developers of the embedded systems develop patches to update firmware for the embedded system to fix bugs and or add new functionality.

Updates to computer software and to firmware can be delivered as patches. A patch is not a complete piece of software or firmware. Instead a patch describes a set of changes that will turn one version of software or firmware into another. This process of taking an original piece of code and applying the patch is called patching. When source files change a common change is to add some new instructions in. The effect of this is that all the functions and data that are after the added instructions will have a different offset inside the executable file. Instructions that reference these memory locations e.g. a function call typically then have to be changed from original version for the patched version. As a result patches are frequently nearly the size of the original executable. For resource constrained devices such as embedded systems the extra memory capacity used by the patch can be restrictive and impair the ability to make patches on such devices.

Embodiments are directed to a system that generates and or performs software and firmware patches in a space efficient manner to methods of performing such patching and to the patches used to update versions of software and firmware. In one embodiment the patches are used to patch software or firmware of an embedded system or other resource constrained device. Alternatively the patches may be used on resource abundant devices such as desktop computers mobile phones tablet computers and so forth.

In one embodiment a processing device determines a memory layout for an executable having functions and data e.g. statically allocated data such as variables wherein the memory layout is determined based on one or more object files. The processing device updates the memory layout by inserting an unused memory region padding between a first function and a second function in the memory layout wherein the first function and the second function have adjacent memory locations in the memory layout prior to insertion of the unused memory region. The processing device resolves references between the functions and then generates an executable comprising the functions and the data arranged in accordance with the memory layout the executable having the resolved references.

Executables created in accordance with embodiments described herein enable functions and data to grow between versions of the executables without changing the memory locations of subsequent functions or data and without changing call instructions to such functions or data. This reduces the size of patches to such executables which in turn increases the amount of memory in a memory constrained device that can be consumed by the executable.

In one embodiment the client devices are devices having embedded systems . Examples of such client devices include electrical appliances such as refrigerators ovens washers driers dishwashers thermostats alarms air conditioners televisions radios receivers amplifiers and so forth. The devices may also include consumer devices such as digital watches music players game consoles digital cameras printers and so forth. Other examples of devices include stationary devices such as HVAC systems traffic lights factory controllers signs electronic billboards sprinkler systems and irrigation control systems as well as medical devices. Devices may also be any other type of device that includes an embedded system . Alternatively one or more client devices may not include an embedded system. Examples of such devices include notebook computers laptop computers tablet computers mobile phones game consoles smart televisions desktop computers server computers and other computing devices.

An embedded system is a class of computing device that is embedded into another device as one component of the device . The device typically also includes other hardware electrical and or mechanical components that may interface with the embedded system. Embedded systems are typically configured to handle a particular task or set of tasks for which the embedded systems may be optimized. Accordingly the embedded systems may have a minimal cost and size as compared to general computing devices.

The embedded system may include a communication module not shown that enables the embedded system and thus the device to connect to the LAN . The communication module may be configured to manage security manage sessions manage communications with external devices and so forth. In one embodiment the communication module is configured to communicate using Wi Fi . Alternatively the communication module may be configured to communicate using Bluetooth Zigbee Internet Protocol version 6 over Low power Wireless Area Networks 6LowPAN power line communication PLC Ethernet e.g. 10 Megabyte Mb 100 Mb and or 1 Gigabyte Gb Ethernet or other communication protocols. One example of an embedded system is described in greater detail below with reference to .

Referring back to the LAN may include a router switch bridge or other network device not shown that enables communication between multiple devices e.g. devices a computing device etc. connected to the LAN . The network device may provide wired connections to the LAN using for example Ethernet ports universal serial bus USB ports and or Firewire ports. The network device may additionally provide wireless connections to the LAN using for example a Wi Fi transceiver.

Some embedded systems may not support any of the communication types supported by the network device. For example device may support only Zigbee or only Bluetooth. To enable such devices to connect to the LAN the LAN may include a gateway device not shown connected to the network device via one of the connection types supported by the network device e.g. via Ethernet or Wi Fi . The gateway device may additionally support other communication protocols such as Zigbee PLC and or Bluetooth and may translate between supported communication protocols. Accordingly some devices may connect to the LAN through the gateway device.

The LAN is connected to a WAN . The LAN may include a router and or modem e.g. a cable modem a direct serial link DSL modem a Worldwide Interoperability for Microwave Access WiMAX modem an long term evolution LTE modem etc. that provides a connection to the WAN .

The WAN may include or connect to server computing device . The server computing device may include a physical machine and or a virtual machine hosted by a physical machine. The physical machine may be a rackmount server a desktop computer or other computing device. In one embodiment the server computing device includes a virtual machine managed and provided by a cloud provider system. Each virtual machine offered by a cloud service provider may be hosted on a physical machine configured as part of a cloud. Such physical machines are often located in a data center. The cloud provider system and cloud may be provided as an infrastructure as a service IaaS layer. One example of such a cloud is Amazon s Elastic Compute Cloud EC2 .

The server computing device hosts a WAN accessible service which may be a web based service and or a cloud service e.g. a web based service hosted in a cloud computing platform . The WAN accessible service may maintain a session e.g. via a transmission control protocol TCP connection or universal datagram protocol UDP traffic with one or more of the embedded systems or with client devices and or other computing devices such as computing device . Via a session with an embedded system WAN accessible service may issue commands to the embedded system send notifications to the embedded system and or receive status updates from the embedded system. The commands may be commands to change a state of one or more parameters of a device controllable by the embedded system. For example if the embedded system is embedded in a heater or thermostat then the commands may include commands to increase or decrease a temperature. In another example if the embedded system is embedded in a home automation system then the commands may include commands to turn on or off lights.

On occasion the WAN accessible service may send patches and or other updates to devices to update firmware and or software in the embedded system . The patches and or other updates may update firmware or software in a host memory or in a memory of a communication module of the embedded system . The available memory resources of both the host memory and the memory of the communication module may be limited. Accordingly the firmware and or software installed on one or more components of the embedded system may be generated to have padding between functions and or statically allocated data to minimize the size of patches and updates.

Referring to a memory of an embedded system is shown. The memory may be a memory of a communication module in the embedded system or a host memory. On embedded devices there rarely are files. Instead an executable program executable is usually placed inside Flash or other non volatile memory which is of fixed size. In some devices executables are executed directly from the non volatile memory such as Flash. In other embodiments executables are loaded from non volatile memory e.g. Flash into volatile memory e.g. random access memory RAM for execution. The volatile memory may have a size that is the same as or smaller than the non volatile memory.

As shown the memory has a memory area that is reserved for an executable. The memory area reserved for the executable includes a first portion that is occupied by an executable installed on the memory . The memory area also typically includes a second portion that is unused memory spare or free space . Accordingly new versions of the executable will have some room to grow to. The executable is typically mapped to be in one contiguous region. Similarly the unused memory free space is typically mapped to another contiguous region.

To patch traditionally generated executables the unused memory should be approximately the same size as or slightly smaller than the executable to enable a patch or update to temporarily be loaded into the memory . This is because it is common for the patch or update to be close to the size of the executable . Thus the unused memory is commonly about the size of the executable to accommodate such large patches and updates. Embodiments described herein enable the unused memory to be smaller than the executable and in some instances significantly smaller than the executable .

Referring back to in one embodiment server computing device includes a linker and a padding module . In another embodiment the padding module may be a component of linker .

Linker is a program that takes one or more input object files generated by a compiler and combines them into a single executable. Programs applications and other executables included in software and firmware are frequently capable of performing many different functions. It is common for some of these different functions to be from modules contained within different object files. The linker combines these different object files into a single unified executable.

To combine multiple object files into a single executable the linker identifies symbols associated with each object file. Each symbol identifies a particular function or field of data from an object file. The symbols may be used by functions to refer to other functions and or fields of data originally from the same or other object files.

The linker determines a memory layout for the executable by arranging all of the functions and data from the multiple object files into an address space. Each function and field of data may be assigned a memory location and a size e.g. beginning and ending memory offset by the linker . The linker additionally resolves references between the functions and the data. The data becomes statically allocated data once the location of the data is fixed in the executable.

Referring to an example executable contains two functions including function A and function B . A first version V. of the executable includes function A at offset 0x0000 and function B at offset 0x4000. Function A contains an instruction that will cause it to call function B . Because code has been compiled and linked an address of function B has been resolved when the first version of the executable was created and a reference to function B has been updated with the exact memory address 0x4000 of that function. Thus function A can successfully call function B .

A second version V. of the executable also includes function A and function B . However after fixes were made to function A from the first version of the executable function A grew larger in the second version of the executable . In particular new instructions were added to function A . By function A growing larger this caused the memory location offset of function B to change to offset 0x4010. Because function B is now at a different location the instruction inside function A that calls function B is now different. As a result a patch that can be applied to the first version of the executable to transform it into the second version of the executable includes code for the new instructions to be added to function A code for updating the call instruction in function A and code for updating the memory location of function B and any functions following function B increasing a size of the patch.

Note that for simplicity new instructions are shown at the end of function A . In practice the new instructions would most likely be elsewhere within function A e.g. not at the end .

Referring now to an example executable contains the same two functions as shown in including function A and function B . A first version V. of the executable includes function A at offset 0x0000 and function B at offset 0x4020. The memory layout for the first version of the executable has been modified from that shown in by adding padding reserved unused space between function A and function B .

In one embodiment functions and data belonging to an executable are placed more evenly e.g. approximately evenly over the memory region reserved for the executable. By adding padding between function A and function B they are provided room to grow from version to version without causing any functions to change offsets or calls to functions to change. Padding may also be placed between other functions such that some or all of the functions included in the executable may be grown without causing subsequent functions to be moved. Moreover padding may also be placed between fields or items of statically allocated data. Because of the added padding function B starts at offset 0x4020. Accordingly function A contains an instruction that will cause it to call function B at offset 0x4020.

A second version V. of the executable also includes function A and function B . After fixes were made to function A from the first version of the executable function A grew larger in the second version of the executable . In particular new instructions are added to function A as a result of a patch for the second version of the executable . However the new instructions are added into the padding allocated for function A and thus do not cause function B to be relocated. Accordingly function B remains at offset 0x4020 in the second version of the executable .

The instruction in function A to call function B does not change from the first version to the second version of the executable. As a result a patch that can be applied to the first version of the executable to transform it into the second version of the executable does not include code to update the function call in function A or the memory location of function B reducing a size of the patch. Additionally if either function A or function B were to have instructions removed between versions additional padding would be introduced also without changing the offset of function B or the instruction calling function B .

By reserving space padding for functions when the executable is first installed differences between versions of the executable will be smaller as a smaller number of instructions will change. This in turn makes a patch smaller. Accordingly an amount of space that is reserved to enable patches to be decompressed and installed into memory may be reduced significantly. For example in some traditional implementations the size of the executable is limited to about half the size of the memory to enable future patches. However embodiments described herein enable the executable to consume a majority e.g. up to 70 or more of the memory.

Referring back to the linker determines a memory layout for the executable and additionally resolves references between the functions and the statically allocated data in the executable. In one embodiment the padding module determines which functions and or items or fields of data to apply padding to as well as how much padding to apply to the functions and or data. How much padding to add between functions and data may depend on how much memory space is available and what kind of changes are expected to be made to the software or firmware. Padding module may apply one or multiple padding policies for allocating padding unused memory regions to functions and or data.

Numerous different padding policies may be used to allocate padding to functions and data. Padding policies may assign weightings to functions and data based on age e.g. such that newer functions and data are assigned higher weights due to an increased risk of future changes size e.g. such that higher weightings are assigned to larger functions and data revision history e.g. such that functions and data that have been recently changed or that have undergone frequent or numerous changes are assigned higher weightings source e.g. such that functions and data associated with stable libraries are assigned lower weightings and other parameters of the data or functions. In one embodiment a simple approach of applying an equal amount of padding to each function and or data field is applied. Other more complicated padding policies are also possible. In one embodiment different padding policies are applied for data than for functions.

For some functions small changes may be anticipated mostly due to bug fixes. The probability of a function needing bug fixes may depend on the size of the function. The bigger the function the more likely it is to need fixes. Accordingly the amount of padding that padding module allocates to a function may be based on a size of the function.

A significant amount of third party source code may be included in an executable in some instances. In many instances third party source is quite stable and undergoes only minimal or no changes. For example the library libc or another traditionally stable library may be used in an executable. Accordingly padding module may not add between functions coming from stable third party libraries in some embodiments. For example certain subsystems may be excluded from padding if these subsystems are identified by a pathname of the source file where a symbol is coming from e.g. if the pathname is to a source file of a stable library . This same padding policy may be followed for statically allocated data.

In one embodiment padding module applies a padding policy that adds 2 extra space between functions where the 2 is a percentage of the size of the function that is being padded. In one embodiment the amount of padding to add to a function may additionally be capped to 32 bytes e.g. 16 instructions with ARM thumb instruction set .

Each of the object files contains code for one or more functions and or data that will be statically allocated. The initial linker configuration file describes a target system memory layout and where in a target system memory functions and data should be placed. Usually the instructions in the initial linker configuration file are not specific as the exact location of a function doesn t normally matter that much. For example the initial linker configuration file may identify a memory region e.g. a starting and ending memory offset that is reserved for an executable in the target system but not identify where specific functions will be placed.

The linker takes in multiple object files and lays out the functions and data from these object files to their places in memory in accordance with the constraints imposed by the initial linker configuration file . The linker additionally resolves references between the functions and or statically allocated data in the object files .

The linker can create a map file containing information about symbols that were placed in the executable the symbols having been created for functions and statically allocated data e.g. global variables . The map file has information about the size of these symbols and their locations in memory. The linker additionally outputs an executable . However this executable is a temporary executable and is typically discarded.

In a second stage a new linker configuration file V. linker configuration file is created. To create the V. linker configuration file a padding module receives as an input map file the initial linker configuration file and a padding policy . The padding module determines one or more properties of the functions and or statically allocated data from the symbols in the map file . The padding module then applies the padding policy based on these determined properties to determine which symbols e.g. which functions and or statically allocated data to allocate padding to as well as how much padding to allocate. Note that the padding module may additionally receive additional inputs providing information such as a revision history of object files and or of specific functions and or data within the object files a source of the object files e.g. a path for the object files and or a source of the object files and so on. This additional data may be taken into consideration by the padding module in accordance with the padding policy .

Padding module generates new rules for placing and sizing symbols e.g. functions and or data based on the determined padding to be allocated. These rules are then inserted into the initial linker configuration file to create the new v. linker configuration file . In one embodiment padding module specifies specific offsets at which to place each of the functions and fields of statically allocated data. The specific placement may space functions apart to include the allocated padding.

In one embodiment padding module additionally rearranges one or more functions and or data for performance optimization. For example a first function which is called from a performance critical path might be placed close to a caller e.g. a second function that will call on the first function which can give performance benefits due to caching and or memory prefetching. Additionally such close placement of the function to be called to the caller can reduce a size of the instruction making the function call or the variable reference. Thus the new linker configuration file may specify locations for functions that cause them to be rearranged as compared to an original executable.

Note that in an alternative embodiment the padding module may be integrated into the linker . In such an embodiment rather than or in addition to generating map file as an output linker may perform the above described operations and generate v. linker configuration file as an output.

In a third stage an executable with padding is generated. The v. linker configuration file including the rules for placing and sizing symbols is provided as input to linker along with the object files . An output is a new v. executable that includes padding for one or more of the functions and or for the data. The final output is an executable where functions are spaced such that there is some room to grow. Accordingly this creates a version of executable against which relatively small patches can be created.

The v. linker configuration file may be stored. When a new version of software or firmware is being built this linker configuration file may be used as input along with new object files. The new version of software or firmware will have almost all the functions and variables in the same locations in memory and the patch between these versions will be small. In some cases functions and data can grow to be bigger than the space they were allocated e.g. may fill the provided padding . In such instances the memory locations of functions and or data may change and ne padding may or may not be inserted between functions.

If padding is to be added to new functions and or data the multi stage linking process continues to a second stage in which a new linker configuration file V. linker configuration file is created. To create the V. linker configuration file padding module or linker in some embodiments receives as an input map file the v. linker configuration file and a padding policy . The padding module determines one or more properties of the functions and or statically allocated data from the symbols in the map file . The padding module then applies the padding policy based on these determined properties to determine which new symbols e.g. which new functions and or statically allocated data to allocate padding to as well as how much padding to allocate. Padding module generates new rules for placing and sizing the new symbols e.g. new functions and or data based on the determined padding to be allocated. These rules are then inserted into the v. linker configuration file to create the new v. linker configuration file . In one embodiment the specific memory locations e.g. offset for each new function and or data field are added to the new v. linker configuration file.

In one embodiment the padding policy specifies that all preexisting functions and or data are to keep the same memory location that they had in the v. executable. This ensures that the padding module will not rearrange the functions and data between v. and v.. Accordingly the v. linker configuration file may specify the memory locations for all of the preexisting functions and or data which would correspond to the same memory locations for these functions and data in the v. executable. In some instances one or more functions or data may exceed the size of a previously allocated padding for those functions or data. In such an instance the memory locations for some functions and or data may change.

In a third stage a new executable with padding is generated. The v. linker configuration file including the rules e.g. specific instructions for placing and sizing the new symbols is provided as input to linker along with the new object files . An output is a new v. executable that includes padding for one or more of the new functions and or statically allocated data. The executable may also include additional instructions in the padding that had been reserved for various functions or data.

In one embodiment the software or firmware update is distributed as a patch. The device on which the original executable is installed and on which the patch will be installed may have a limited amount of memory e.g. Flash where the patch and the executable can be stored. The patch has a much smaller size as compared to traditional patches and so places a smaller memory resource burden on the memory. With smaller requirements on memory for storing the patch device manufacturers can include more improvements within a software or firmware update. Additionally less memory space may be reserved for patching as opposed to memory requirements of traditional patching practices. Developers can therefore include more software features in a product such as an embedded system that is resource constrained e.g. has minimal memory as the developer can allocate more of the memory e.g. more Flash space for the actual executable.

For simplicity of explanation the methods are depicted and described as a series of acts. However acts in accordance with this disclosure can occur in various orders and or concurrently and with other acts not presented and described herein. Furthermore not all illustrated acts may be performed to implement the methods in accordance with the disclosed subject matter. In addition those skilled in the art will understand and appreciate that the methods could alternatively be represented as a series of interrelated states via a state diagram or events.

At block processing logic determines weights for functions and or statically allocated data to be included in the executable. The weights may be determined based on properties of the functions and or data as well as one or more padding policies. For example weights may be based on a size of a function or data a revision history of a function or data a source of the function or data an age of the function or data a path associated with the function or data and so on. Higher weights may be determined for functions and data that have a higher likelihood of being modified in future versions of the executable.

At block processing logic determines unused memory regions padding for functions and or statically allocated data based on the weightings. In one embodiment processing logic allocates larger unused memory regions more padding to functions and data with higher weightings. This balances the extra memory consumed by the functions and data by adding padding verses the cost of modifying a function or data if there is insufficient padding to accommodate the modification. In one embodiment the operations of blocks and correspond to the second stage of .

At block processing logic updates the memory layout by allocating the determined unused memory to functions and or statically allocated data. In one embodiment processing logic generates a new linker configuration file that includes rules or instructions for the sizing and placement of functions and data.

At block processing logic resolves references between functions. At block processing logic generates an executable that includes padding between functions and or data e.g. includes unused memory regions allocated to one or more functions and or data . In one embodiment the operations of blocks correspond to the third stage of .

At block processing logic determines whether any new functions and or new statically allocated data has been added to the new executable that were not included in the previous version of the executable. Processing logic may also determine whether the padding unused memory region allocated to a function or data has been filled and exceeded in the new executable. This would likely cause existing functions to move and call instructions that call such functions to change. If new functions or data have been added or padding associated with a function or data has been exceeded the method continues to block . Otherwise the method proceeds to block .

At block processing logic determines weightings for the new and or existing functions and data. At block processing logic determines unused memory regions padding for functions and or data based on the weightings. In some embodiments weightings are determined only for new functions and data and for functions and data whose allocated padding has been exceeded. Alternatively weightings may be computed for all functions and data in the executable. In one embodiment a new linker configuration file is generated based on the determined unused memory regions to be allocated to functions and or data. In one embodiment the operations of block correspond to the second stage of .

At block processing logic updates a memory layout by allocating the determined unused memory regions to the functions and or data. At block processing logic resolves references between the functions and or data. At block processing logic generates a replacement new executable that includes padding unused memory regions allocated to the functions and or data. In one embodiment the operations of blocks correspond to the third stage of .

At block processing logic generates a patch from one of the new executables. If the answer at block was no then the patch may be generated from the new executable that has not added padding to new functions and or adjusted the padding for existing functions. If the answer at block was yes then the patch may be generated from the replacement new executable that includes padding for new functions and or data.

In one embodiment the device includes mechanical components electrical components and an embedded system . The electrical components and or mechanical components may include sensors programmable logic controllers PLCs switches motors valves actuators and so forth.

The embedded system may include a host processing device a host memory and or a communication module coupled to the host processing device . The embedded system may also include numerous other components that are not shown herein. Examples of such additional components may include light emitting diodes LEDs a power supply regulator fuses ports a user interface digital to analog D A converters analog to digital A D converters field programmable gate arrays FPGAs application specific integrated circuits ASICs and so on.

Host processing device may be a microcontroller or a digital signal processor DSP in one embodiment. Host processing device may alternatively or additionally include a programmable logic controller PLC a field programmable gate array FPGA or a complex programmable logic device CPLD . The host processing device may be configured to perform specific functions related to the operation and control of the device .

Host memory may include random access memory RAM read only memory ROM one time programmable OTP ROM Flash e.g. NOR Flash or other types of memory. Host memory may store an application programming interface API for the communication module . The API may enable the host processing device to send commands and or data to and receive commands and or data from communication module . Host memory may also include firmware and or software that includes an executable for the host processing device that configures the host processing device to perform one or more operations that are specific to device . For example host memory may include an executable that has been generated in accordance with embodiments of the present invention as described above. In some instances a patch generated in accordance with embodiments discussed herein is temporarily stored in host memory . The patch may be executed to update executable after which the patch may be deleted from host memory . Because the executable and patch have been created in accordance with embodiments described herein the size of the patch may be much smaller than traditional patches. Thus the executable may consume a larger portion of the host memory than may be permissible in other resource constrained devices.

In some embodiments the host memory may be integrated into the host processing device . For example microcontrollers typically include a processor core memory and programmable input output peripherals. Accordingly if the host processing device is a microcontroller then host memory may be a memory of host processing device .

Communication module may be an integrated circuit IC that is configured to be coupled to host processing device of embedded system . Communication module may be provided by a third party to a manufacturer of the device and may enable network capability and remote control capability to be easily added to the device . The communication module may include its own processing device a memory and or a network adapter . The processing device may be a microcontroller a DSP a PLC a microprocessor or programmable logic device such as an FPGA or a CPLD. The memory may include a non volatile memory e.g. RAM and or a volatile memory e.g. ROM Flash etc. . In one embodiment memory is integrated into processing device . Memory may store an executable for execution by the processing device such as an executable that has been generated in accordance with embodiments of the present invention as described above. Memory may also temporarily store a patch created in accordance with embodiments described herein.

Network adapter may be a wired network adapter e.g. an Ethernet adapter or a wireless network adapter e.g. a Wi Fi adapter or other wireless local area network WLAN adapter . Network adapter may also be configured to provide connection to a network or other devices using Zigbee PLC Bluetooth 6LowPAN or other communication protocols. Network adapter may receive notifications and other messages from a WAN accessible service and or remote control applications. Network adapter may additional send outgoing messages to the WAN accessible service and or to remote control applications.

The example computing device includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a secondary memory e.g. a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processors such as a microprocessor central processing unit or the like. More particularly the processing device may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processing device is configured to execute the processing logic instructions for performing the operations discussed herein.

The computing device may further include a network interface device . The computing device also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine readable storage medium or more specifically a computer readable storage medium on which is stored one or more sets of instructions embodying any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting computer readable storage media.

The computer readable storage medium may also be used to store a linker and or padding module that creates executables as described in embodiments and or a software library containing methods that call such a linker and or padding module . While the computer readable storage medium is shown in an example embodiment to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable storage medium shall also be taken to include any medium other than a carrier wave that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies described herein. The term computer readable storage medium shall accordingly be taken to include but not be limited to the non transitory media including solid state memories and optical and magnetic media.

The modules components and other features described herein can be implemented as discrete hardware components or integrated in the functionality of hardware components such as ASICS FPGAs DSPs or similar devices. In addition the modules can be implemented as firmware or functional circuitry within hardware devices. Further the modules can be implemented in any combination of hardware devices and software components or only in software.

Some portions of the detailed description have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as linking mapping determining updating resolving generating or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the discussed purposes or it may comprise a general purpose computer system selectively programmed by a computer program stored in the computer system. Such a computer program may be stored in a non transitory computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic disk storage media optical storage media flash memory devices or other type of machine accessible storage media.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. Although the present invention has been described with reference to specific example embodiments it will be recognized that the invention is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

