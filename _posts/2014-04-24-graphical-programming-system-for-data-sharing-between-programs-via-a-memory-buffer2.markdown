---

title: Graphical programming system for data sharing between programs via a memory buffer
abstract: A graphical program execution environment that facilitates communication between a producer program and a consumer program is disclosed. The producer program may store data in a memory block allocated by the producer program. A graphical program may communicate with the producer program to obtain a reference to the memory block. The graphical program may asynchronously pass the reference to the consumer program, e.g., may pass the reference without blocking or waiting while the consumer program accesses the data in the memory block. After the consumer program is finished accessing the data, the consumer program may asynchronously notify the graphical program execution environment to release the memory block. The graphical program execution environment may then notify the producer program that the block of memory is no longer in use so that the producer program can de-allocate or re-use the memory block.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626233&OS=09626233&RS=09626233
owner: NATIONAL INSTRUMENTS CORPORATION
number: 09626233
owner_city: Austin
owner_country: US
publication_date: 20140424
---
This application is a Continuation of U.S. application Ser. No. 13 460 437 titled Graphical Programming System enabling Data Sharing from a Producer to a Consumer via a Memory Buffer filed Apr. 30 2012 issued as U.S. Pat. No. 8 769 549 on Jul. 1 2014 whose inventors are J. Adam Kemp Neil S. Feiereisel and Brent C. Schwan which is hereby incorporated by reference in its entirety as though fully and completely set forth herein.

The present invention relates to the field of graphical programming and more particularly to a system and method for creating a graphical program and executing the graphical program in conjunction with a producer program and a consumer program where the graphical program enables the consumer program to receive and use data produced by the producer program.

Traditionally text based programming languages have been used by programmers in writing application programs. Many different text based programming languages exist including BASIC C C Visual C JAVA FORTRAN Pascal COBOL ADA APL etc. Increasingly computers are required to be used and programmed by those who are not highly trained in computer programming techniques. When traditional text based programming languages are used the user s programming skills and ability to interact with the computer system often become a limiting factor in the user s efficiency of creating a computer program.

Various programming models and paradigms that enable a user to create a program in a graphical manner without necessarily writing source code in a text based programming language have been developed. In particular graphical programming development environments enable a user to create a software program by including a plurality of nodes or icons in a block diagram and interconnecting the nodes or icons e.g. such that the interconnected plurality of nodes or icons visually indicates functionality of the resulting software program called a graphical program . The resulting interconnected nodes may visually indicate a function or process performed by the graphical program during its execution.

Various embodiments of a system and method for creating a graphical program and or executing the graphical program together with a producer program and a consumer program are described. The graphical program may facilitate data sharing between the producer program and the consumer program e.g. by enabling the consumer program to use external data produced by the producer program without requiring a separate copy of the data to be made before the consumer program can access the data.

For example the producer program may store data in a memory buffer or block allocated by the producer program. The graphical program may communicate with the producer program to obtain a reference to the memory buffer. In some embodiments this communication between the graphical program and the producer program may occur via a graphical program execution environment in which the graphical program executes. The graphical program may pass a reference to the memory block to the consumer program which enables the consumer program to access the data in the same memory block in which the producer program stored the data. Thus the graphical program may effectively serve as an intermediary between the producer program and the consumer program to enable the consumer program to use the data produced by the producer program without requiring the producer program and the consumer program to communicate directly with each other.

Furthermore the consumer program may access the data asynchronously with respect to the execution of the graphical program and the execution of the producer program. For example the graphical program may asynchronously pass the reference to the memory block to the consumer program and return without requiring the graphical program or the producer program to block or wait while the consumer program accesses the data in the memory block. After the consumer program is finished accessing the data the consumer program may asynchronously notify the graphical program execution environment to release the memory block. The graphical program execution environment may then notify the producer program that the block of memory is no longer in use so that the producer program can de allocate or re use the memory block.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

The following references are hereby incorporated by reference in their entirety as though fully and completely set forth herein 

U.S. application Ser. No. 13 460 437 titled Graphical Programming System enabling Data Sharing from a Producer to a Consumer via a Memory Buffer filed Apr. 30 2012.

U.S. Pat. No. 4 914 568 titled Graphical System for Modeling a Process and Associated Method issued on Apr. 3 1990.

U.S. Pat. No. 5 481 741 titled Method and Apparatus for Providing Attribute Nodes in a Graphical Data Flow Environment .

U.S. Pat. No. 6 219 628 titled System and Method for Configuring an Instrument to Perform Measurement Functions Utilizing Conversion of Graphical Programs into Hardware Implementations filed Aug. 18 1997.

U.S. Pat. No. 7 210 117 titled System and Method for Programmatically Generating a Graphical Program in Response to Program Information filed Dec. 20 2000.

U.S. Pat. No. 7 085 670 titled Reconfigurable measurement system utilizing a programmable hardware element and fixed hardware resources filed Oct. 29 2001.

Memory Medium Any of various types of memory devices or storage devices. The term memory medium is intended to include an installation medium e.g. a CD ROM floppy disks or tape device a computer system memory or random access memory such as DRAM DDR RAM SRAM EDO RAM Rambus RAM etc. a non volatile memory such as a Flash magnetic media e.g. a hard drive or optical storage registers or other similar types of memory elements etc. The memory medium may comprise other types of memory as well or combinations thereof. In addition the memory medium may be located in a first computer in which the programs are executed or may be located in a second different computer which connects to the first computer over a network such as the Internet. In the latter instance the second computer may provide program instructions to the first computer for execution. The term memory medium may include two or more memory mediums which may reside in different locations e.g. in different computers that are connected over a network.

Carrier Medium a memory medium as described above as well as a physical transmission medium such as a bus network and or other physical transmission medium that conveys signals such as electrical electromagnetic or digital signals.

Programmable Hardware Element includes various hardware devices comprising multiple programmable function blocks connected via a programmable interconnect. Examples include FPGAs Field Programmable Gate Arrays PLDs Programmable Logic Devices FPOAs Field Programmable Object Arrays and CPLDs Complex PLDs . The programmable function blocks may range from fine grained combinatorial logic or look up tables to coarse grained arithmetic logic units or processor cores . A programmable hardware element may also be referred to as reconfigurable logic .

Software Program the term software program is intended to have the full breadth of its ordinary meaning and includes any type of program instructions code script and or data or combinations thereof that may be stored in a memory medium and executed by a processor. Exemplary software programs include programs written in text based programming languages such as C C PASCAL FORTRAN COBOL JAVA assembly language etc. graphical programs programs written in graphical programming languages assembly language programs programs that have been compiled to machine language scripts and other types of executable software. A software program may comprise two or more software programs that interoperate in some manner. Note that various embodiments described herein may be implemented by a computer or software program. A software program may be stored as program instructions on a memory medium.

Hardware Configuration Program a program e.g. a netlist or bit file that can be used to program or configure a programmable hardware element.

Program the term program is intended to have the full breadth of its ordinary meaning The term program includes 1 a software program which may be stored in a memory and is executable by a processor or 2 a hardware configuration program useable for configuring a programmable hardware element.

Graphical Program A program comprising a plurality of interconnected nodes or icons wherein the plurality of interconnected nodes or icons visually indicate functionality of the program. The interconnected nodes or icons are graphical source code for the program. Graphical function nodes may also be referred to as blocks.

The following provides examples of various aspects of graphical programs. The following examples and discussion are not intended to limit the above definition of graphical program but rather provide examples of what the term graphical program encompasses 

The nodes in a graphical program may be connected in one or more of a data flow control flow and or execution flow format. The nodes may also be connected in a signal flow format which is a subset of data flow.

Exemplary graphical program development environments which may be used to create graphical programs include LabVIEW DasyLab DiaDem and Matrixx SystemBuild from National Instruments Simulink from the MathWorks VEE from Agilent WiT from Coreco Vision Program Manager from PPT Vision SoftWIRE from Measurement Computing Sanscript from Northwoods Software Khoros from Khoral Research SnapMaster from HEM Data VisSim from Visual Solutions ObjectBench by SES Scientific and Engineering Software and VisiDAQ from Advantech among others.

The term graphical program includes models or block diagrams created in graphical modeling environments wherein the model or block diagram comprises interconnected blocks i.e. nodes or icons that visually indicate operation of the model or block diagram exemplary graphical modeling environments include Simulink SystemBuild VisSim Hypersignal Block Diagram etc.

A graphical program may be represented in the memory of the computer system as data structures and or program instructions. The graphical program e.g. these data structures and or program instructions may be compiled or interpreted to produce machine language that accomplishes the desired method or process as shown in the graphical program.

Input data to a graphical program may be received from any of various sources such as from a device unit under test a process being measured or controlled another computer program a database or from a file. Also a user may input data to a graphical program or virtual instrument using a graphical user interface e.g. a front panel.

A graphical program may optionally have a GUI associated with the graphical program. In this case the plurality of interconnected blocks or nodes are often referred to as the block diagram portion of the graphical program.

Node In the context of a graphical program an element that may be included in a graphical program. The graphical program nodes or simply nodes in a graphical program may also be referred to as blocks. A node may have an associated icon that represents the node in the graphical program as well as underlying code and or data that implements functionality of the node. Exemplary nodes or blocks include function nodes sub program nodes terminal nodes structure nodes etc. Nodes may be connected together in a graphical program by connection icons or wires.

Data Flow Program A Software Program in which the program architecture is that of a directed graph specifying the flow of data through the program and thus functions execute whenever the necessary input data are available. Data flow programs can be contrasted with procedural programs which specify an execution flow of computations to be performed. As used herein data flow or data flow programs refer to dynamically scheduled data flow and or statically defined data flow .

Graphical Data Flow Program or Graphical Data Flow Diagram A Graphical Program which is also a Data Flow Program. A Graphical Data Flow Program comprises a plurality of interconnected nodes blocks wherein at least a subset of the connections among the nodes visually indicate that data produced by one node is used by another node. A LabVIEW VI is one example of a graphical data flow program. A Simulink block diagram is another example of a graphical data flow program.

Graphical User Interface this term is intended to have the full breadth of its ordinary meaning The term Graphical User Interface is often abbreviated to GUI . A GUI may comprise only one or more input GUI elements only one or more output GUI elements or both input and output GUI elements.

The following provides examples of various aspects of GUIs. The following examples and discussion are not intended to limit the ordinary meaning of GUI but rather provide examples of what the term graphical user interface encompasses 

A GUI may comprise a single window having one or more GUI Elements or may comprise a plurality of individual GUI Elements or individual windows each having one or more GUI Elements wherein the individual GUI Elements or windows may optionally be tiled together.

A GUI may be associated with a graphical program. In this instance various mechanisms may be used to connect GUI Elements in the GUI with nodes in the graphical program. For example when Input Controls and Output Indicators are created in the GUI corresponding nodes e.g. terminals may be automatically created in the graphical program or block diagram. Alternatively the user can place terminal nodes in the block diagram which may cause the display of corresponding GUI Elements front panel objects in the GUI either at edit time or later at run time. As another example the GUI may comprise GUI Elements embedded in the block diagram portion of the graphical program.

Front Panel A Graphical User Interface that includes input controls and output indicators and which enables a user to interactively control or manipulate the input being provided to a program and view output of the program while the program is executing.

A front panel is a type of GUI. A front panel may be associated with a graphical program as described above.

In an instrumentation application the front panel can be analogized to the front panel of an instrument. In an industrial automation application the front panel can be analogized to the MMI Man Machine Interface of a device. The user may adjust the controls on the front panel to affect the input and view the output on the respective indicators.

Graphical User Interface Element an element of a graphical user interface such as for providing input or displaying output. Exemplary graphical user interface elements comprise input controls and output indicators.

Input Control a graphical user interface element for providing user input to a program. An input control displays the value input by the user and is capable of being manipulated at the discretion of the user. Exemplary input controls comprise dials knobs sliders input text boxes etc.

Output Indicator a graphical user interface element for displaying output from a program. Exemplary output indicators include charts graphs gauges output text boxes numeric displays etc. An output indicator is sometimes referred to as an output control .

Computer System any of various types of computing or processing systems including a personal computer system PC mainframe computer system workstation network appliance Internet appliance personal digital assistant PDA television system grid computing system or other device or combinations of devices. In general the term computer system can be broadly defined to encompass any device or combination of devices having at least one processor that executes instructions from a memory medium.

Measurement Device includes instruments data acquisition devices smart sensors and any of various types of devices that are configured to acquire and or store data. A measurement device may also optionally be further configured to analyze or process the acquired or stored data. Examples of a measurement device include an instrument such as a traditional stand alone box instrument a computer based instrument instrument on a card or external instrument a data acquisition card a device external to a computer that operates similarly to a data acquisition card a smart sensor one or more DAQ or measurement cards or modules in a chassis an image acquisition device such as an image acquisition or machine vision card also called a video capture board or smart camera a motion control device a robot having machine vision and other similar types of devices. Exemplary stand alone instruments include oscilloscopes multimeters signal analyzers arbitrary waveform generators spectroscopes and similar measurement test or automation instruments.

A measurement device may be further configured to perform control functions e.g. in response to analysis of the acquired or stored data. For example the measurement device may send a control signal to an external system such as a motion control system or to a sensor in response to particular data. A measurement device may also be configured to perform automation functions i.e. may receive and analyze data and issue automation control signals in response.

Automatically refers to an action or operation performed by a computer system e.g. software executed by the computer system or device e.g. circuitry programmable hardware elements ASICs etc. without user input directly specifying or performing the action or operation. Thus the term automatically is in contrast to an operation being manually performed or specified by the user where the user provides input to directly perform the operation. An automatic procedure may be initiated by input provided by the user but the subsequent actions that are performed automatically are not specified by the user i.e. are not performed manually where the user specifies each action to perform. For example a user filling out an electronic form by selecting each field and providing input specifying information e.g. by typing information selecting check boxes radio selections etc. is filling out the form manually even though the computer system must update the form in response to the user actions. The form may be automatically filled out by the computer system where the computer system e.g. software executing on the computer system analyzes the fields of the form and fills in the form without any user input specifying the answers to the fields. As indicated above the user may invoke the automatic filling of the form but is not involved in the actual filling of the form e.g. the user is not manually specifying answers to fields but rather they are being automatically completed . The present specification provides various examples of operations being automatically performed in response to actions the user has taken.

Producer Program A software program or subroutine that stores data in a memory buffer in memory of a computer system. The producer program may be the original producer of the data or may store data in the memory buffer that was originally produced by another hardware or software entity. The producer program may be a standalone program or software application or may be part of another program.

Consumer Program A software program or subroutine that utilizes accesses or transfers data produced by another program e.g. by a producer program from a memory buffer. For example the consumer program may read the data from the memory buffer and analyze or process the data. As another example the consumer program may cause the data to be written from the memory buffer to a disk drive or other target storage location. As another example the consumer program may cause the data to be transferred from the memory buffer to a hardware device e.g. using DMA direct memory access techniques. The consumer program may be a standalone program or software application or may be part of another program.

Various embodiments of a system and method for creating a graphical program and executing the graphical program together with a producer program and or a consumer program are described herein. The graphical program may execute within a graphical program execution environment. The producer program and or consumer program may execute externally from the graphical program and graphical program execution environment. The graphical program may be configured to utilize a data structure referred to herein as an external data value reference EDVR which enables the graphical program to natively access an external memory buffer located in a region of memory that is external to the graphical program and the graphical program execution environment. The external memory buffer may be allocated by the producer program the consumer program or another program such as a memory manager program.

In various embodiments the producer program may produce and store any kind of data in the memory buffer e.g. depending on the particular software application being performed. As one example the producer program can be a device driver program that interfaces with a measurement device to acquire measurement data from a physical unit or system under test and store the measurement data in the memory buffer . In this example the measurement device itself may actually produce the measurement data and the device driver program may manage the measurement device and command the measurement device to transfer the measurement data into the memory buffer e.g. using DMA direct memory access techniques.

In some embodiments the graphical program may act as a consumer program that reads the data produced by the producer program from the memory buffer and or otherwise uses or accesses the data. The graphical program may use or access the data for any purpose e.g. depending on the particular software application being performed. For example the graphical program may read the data from the memory buffer and write it to disk or store it in a database may analyze the data may modify the data etc.

Since the memory buffer is located in a region of memory allocated by an external producer program with respect to the graphical program and the graphical program execution environment the memory buffer is also referred to herein as an external memory buffer e.g. external from the point of view of the graphical program . In some embodiments the producer program may execute in a different operating system process than the graphical program and graphical program execution environment . In other embodiments the producer program may execute in the same process as the graphical program and the graphical program execution environment but may still be external to them. For example the producer program may be loaded from a separate binary image and or may be installed on the computer system in a separate software installation. In some embodiments the producer program may also be developed by a different software developer or vendor than the developer vendor who created the graphical program .

The producer program may also be written in a different programming language than the graphical program and may use different kinds of internal data structures. The producer program may also allocate memory from the operating system independently of memory allocations done by the graphical program and graphical program execution environment or may request memory blocks from a separate heap manager or other memory manager which allocates memory from the operating system independently of the memory allocations done by the graphical program and graphical program execution environment . As a result some conventional programming techniques would not allow a graphical program to directly access the contents of an external memory buffer allocated by the producer program but would instead require a separate copy of the external memory buffer to be made before the data stored therein can be used by the graphical program. For example conventional programming techniques may require the data to be copied from the external memory buffer to another memory buffer which is internal to the graphical program execution environment before the data can be used by the graphical program.

One problem with requiring a separate copy of the data to be made before it can be used by the graphical program is that copying the data can substantially decrease the performance of the application. This is especially true when the graphical program needs to use a large amount of data produced by the producer program or needs to repeatedly use smaller blocks of data. For example consider the application mentioned above in which the producer program is a device driver program that stores measurement data acquired by a measurement device in a memory buffer. The producer program may perform a loop in which new data sets are acquired and stored in the buffer at a high rate of speed. The graphical program may execute a loop in parallel with the producer program to read and analyze the data sets. If each data set needs to be copied into a separate buffer accessible by the graphical program then the performance of the application may suffer considerably due to the time and processing resources required for the repeated copy operations.

The system and method described herein may overcome this problem by enabling the graphical program to natively access the data stored in an external memory buffer without requiring a separate copy of the data to be made. In the example of the graphical program may read the data directly from the external memory buffer located in the region of memory allocated by the producer program . This direct access is achieved through the use of an external data value reference EDVR which is a reference to the external memory buffer . The EDVR may be implemented as a data structure of which function nodes in the graphical program are aware and which the function nodes are configured to use or dereference in order to natively access the external memory buffer .

The graphical program may include one or more reference creation nodes configured to create the EDVR . More particularly when executed during the execution of the graphical program the reference creation node s may communicate with the producer program to cause the EDVR to be created. Although the memory buffer is owned or allocated by the producer program the EDVR that is used to reference the memory buffer is a data structure that needs to be accessible by the graphical program . Since the producer program is an external program from the graphical program and the graphical program execution environment the producer program may not have the knowledge or ability to create the EDVR which instead may need to be created internally to the graphical program execution environment . As illustrated in the graphical program execution environment may include an application programming interface API that includes functions for creating and managing external data value references shown as the EDVR API . The producer program may call the EDVR API to request the EDVR data structure to be created. In response to this request the graphical program execution environment may create the EDVR and return it to the producer program .

When the producer program receives the EDVR from the graphical program execution environment the producer program may modify the EDVR to cause the EDVR to reference the memory buffer e.g. by writing memory location information into the EDVR indicating where the memory buffer is stored in memory.

The producer program may then return the EDVR to the graphical program . The reference creation node in the graphical program which initiated the creation of the EDVR may receive the EDVR from the producer program and pass the EDVR to one or more other nodes in the graphical program . These one or more other nodes may receive the EDVR and use it to natively access the data stored in the external memory buffer e.g. by reading the data directly from the memory locations where the data was originally stored by the producer program . In this way the graphical program is enabled to act as a consumer program that natively accesses data produced and stored in memory by an external producer program without requiring a separate copy of the data to be made.

After the graphical program has read or otherwise used the data from the external memory buffer the graphical program may release the EDVR that references the external memory buffer . Releasing the EDVR may notify the producer program that the EDVR is no longer in use by the graphical program. The producer program may then de allocate or re use the memory buffer that was referenced by the EDVR . In some embodiments the graphical program may communicate directly with the producer program to release the EDVR . In other embodiments the graphical program may call the EDVR API of the graphical program execution environment to release the EDVR and the graphical program execution environment may in turn communicate with the producer program .

In another embodiment a graphical program may act as a producer program that stores data and executes concurrently with an external consumer program which accesses the data as illustrated in . The consumer program may execute externally from the graphical program and graphical program execution environment . In some embodiments the consumer program may also be written in a different programming language than the graphical program . The consumer program may also allocate memory from the operating system independently of memory allocations done by the graphical program and graphical program execution environment or may request memory blocks from a separate heap manager or other memory manager which allocates memory from the operating system independently of the memory allocations done by the graphical program and graphical program execution environment .

The graphical program may create an EDVR to reference an external memory buffer which is located within a region of memory allocated by the consumer program e.g. in order to store the data in the external memory buffer . The consumer program may then access the external memory buffer for various purposes. The use of the EDVR may enable the graphical program to natively access the external memory buffer in order to write the data directly into the external memory buffer allocated by the consumer program.

The graphical program may include one or more reference creation nodes configured to create the EDVR . More particularly when executed during the execution of the graphical program the reference creation node s may communicate with the consumer program to cause the EDVR to be created. The consumer program may call the EDVR API of the graphical program execution environment to request the EDVR data structure to be created. In response to this request the graphical program execution environment may create the EDVR and return it to the consumer program . When the consumer program receives the EDVR from the graphical program execution environment the consumer program may modify the EDVR to cause the EDVR to reference the memory buffer e.g. by writing memory location information into the EDVR indicating where the memory buffer is stored in memory.

The consumer program may then return the EDVR to the graphical program . The reference creation node in the graphical program which initiated the creation of the EDVR may receive the EDVR from the consumer program and pass the EDVR to one or more other nodes in the graphical program . These one or more other nodes may receive the EDVR and dereference it in order to write data directly into the external memory buffer .

After the graphical program has written the data into the external memory buffer the graphical program may release the EDVR that references the external memory buffer . Releasing the EDVR may notify the consumer program that the graphical program has finished using the EDVR . This may inform the consumer program that the memory buffer now contains the data written by the graphical program. The consumer program may then access the memory buffer to use the data for various purposes e.g. by writing the data to disk performing commands specified by the data etc.

The graphical program may be created by a user who interacts with a graphical program development environment to include various function nodes in a block diagram of the graphical program and wire them together so that the interconnected nodes visually indicate functionality of the graphical program. Each function node provided by the graphical program development environment may perform a specific function or operation when it is executed during the execution of the graphical program.

In some conventional graphical programming systems some function nodes are configured to read data from or write data to internal memory buffers e.g. memory buffers created by the graphical program and located within a region of memory allocated by the graphical program but are generally not able to read data from or write data to external memory buffers. Embodiments of the present system and method may extend the memory access capabilities of a graphical programming system so that the function nodes provided by the graphical programming system can natively access external memory buffers as well as internal memory buffers.

A user may configure a function node to access an internal memory buffer by configuring the function node to receive a data structure that references the internal memory buffer. According to some embodiments of the present system and method a function node which can receive a reference to an internal memory buffer may also be configured to receive an EDVR data structure that references an external memory buffer. Thus a given function node may be configured to operate on either an internal memory buffer or an external memory buffer depending on what kind of reference is passed to the function node. Thus embodiments of the present system and method provide native access to external memory buffers because through the use of an EDVR data structure the function nodes used in the graphical program can read data from and write data to an external memory buffer as if the external memory buffer were an internal memory buffer allocated by the graphical program itself. This native access to external memory buffers may be built in to the graphical program development environment so that the nodes which can receive references to and access internal memory buffers are in general also configured to be able to receive EDVRs and access external memory buffers.

From the standpoint of the user who creates the graphical program configuring the graphical program to access an external memory buffer may be as simple as configuring the graphical program to access an internal memory buffer. For example the user may simply include in the graphical program a particular function node that is executable to perform an operation that involves reading data from memory or writing data to memory. The user may then configure the function node to receive an EDVR that references the desired external memory buffer. The graphical program may then be executed. During the execution of the graphical program the function node may receive the EDVR and read data from or write data to the external memory buffer.

In other embodiments the graphical program may read the data from the memory buffer and use the data in various ways but may not modify the contents of the memory buffer . Thus the consumer program may access the original data stored by the producer program.

In yet other embodiments the graphical program may not read the data from or write any data to the memory buffer . Instead the graphical program may just create the EDVR and pass it to the consumer program which then uses the EDVR to access the data in the memory buffer .

It is noted that in the software architecture illustrated in the graphical program effectively serves as an intermediary between the producer program and the consumer program to enable the use of the producer program s data by the consumer program without requiring the producer program and the consumer program to communicate directly with each other or even to have any knowledge at all of each other.

In some embodiments the consumer program may be configured to call the EDVR API of the graphical program execution environment to release the EDVR when it is finished using the EDVR. In response the graphical program execution environment may in turn notify the producer program that the EDVR has been released by the consumer program so that the producer program can then de allocate or re use the memory buffer referenced by the EDVR.

In some embodiments the release of the EDVR may occur asynchronously with respect to the execution of the graphical program. For example the graphical program may pass the EDVR to the consumer program and then continue its execution without blocking or waiting for the consumer program to finish using the EDVR. When the consumer is finished using the EDVR the consumer program may asynchronously call the EDVR API of the graphical program execution environment to release the EDVR.

Thus the consumer program may be able to execute asynchronously with respect to the execution of the graphical program and the execution of the producer program. For example the producer program may execute a loop. In each iteration of the producer program s loop the producer program may generate a new data set and store it in a respective memory buffer. The graphical program may execute to create EDVRs that reference these memory buffers and may pass the EDVRs to the consumer program. The consumer program may also execute a loop. In each iteration of the consumer program loop the consumer program may receive a reference to a respective memory buffer and stream the data set to disk or use the data set in various other ways . The graphical program may pass the EDVRs to the consumer program without requiring the graphical program or the producer program to block or wait while the consumer program streams each data set to disk. The consumer program may asynchronously notify the graphical program execution environment when it is finished using each EDVR and the graphical program execution environment may then notify the producer program that the EDVR has been released so that the memory buffer it references can be de allocated or re used by the producer program.

In other embodiments the consumer program may not call the EDVR API of the graphical program execution environment to release the EDVR but may instead communicate with the graphical program to notify the graphical program that it is finished using the EDVR e.g. by invoking a node of the graphical program. The graphical program may then immediately invoke the EDVR API of the graphical program execution environment to release the EDVR or may perform further processing with the EDVR. For example when the first consumer program notifies the graphical program that it is finished using the EDVR the graphical program may then pass the EDVR to a second consumer program. The second consumer program may in turn access the memory buffer using the EDVR and may then either invoke the EDVR API to release the EDVR or notify the graphical program that it is finished using the EDVR.

In applications that use multiple consumer programs the consumer programs may execute either serially or concurrently. As an example of an application in which multiple consumer programs operate serially suppose that the producer program is a device driver program that communicates with a first hardware device to command the first hardware device to transfer data into a memory buffer using a DMA technique. The graphical program may create an EDVR referencing the memory buffer and pass the EDVR to a first consumer program. The first consumer program may read the data from the memory buffer produce modified data and replace the original data in the memory buffer with the modified data. The first consumer program may then notify the graphical program that it is finished using the EDVR. In response the graphical program may pass the EDVR to a second consumer program that modifies the data in the memory buffer again similarly as the first consumer program did. The second consumer program may then notify the graphical program that it is finished using the EDVR. In response the graphical program may pass the EDVR to a third consumer program. The third consumer program may be a device driver program for a second hardware device and may cause the data to be transferred from the memory buffer to the second hardware device using a DMA technique. The third consumer program may then either call the EDVR API of the graphical program execution environment to release the EDVR or notify the graphical program that it is finished using the EDVR. In the latter case the graphical program may possibly use the EDVR to access the memory buffer and may call the EDVR API to release the EDVR when it is finished using the EDVR.

If multiple consumer programs concurrently access the memory buffer concurrently the consumer programs may need to indicate that their access to the memory buffer will be read only so that the consumer programs have no effect on the data in the memory buffer or on the operation of each other.

In the embodiment illustrated in the external memory buffer is allocated by the producer program . In other embodiments the external memory buffer may be allocated by the consumer program . For example the graphical program may create an EDVR that references the external memory buffer allocated by the consumer program. The graphical program may then pass the EDVR to the producer program and the producer program may use the EDVR to write data into the memory buffer . The consumer program may then access the memory buffer to use the data to perform various functions.

In other embodiments the external memory buffer may be allocated by another program such as a memory manager program that is external to the producer program the consumer program and the graphical program . An external memory manager program may also be used to allocate the memory buffer in embodiments where the graphical program executes together with a producer program without the use of a separate consumer program similarly as in and in embodiments where the graphical program executes together with a consumer program without the use of a separate producer program similarly as in .

As mentioned above the graphical program may be created by a user who interacts with a graphical program development environment to include various function nodes in a block diagram of the graphical program and wire them together so that the interconnected nodes visually indicate functionality of the graphical program. For example the graphical program development environment may provide a graphical user interface which includes palettes or menus enabling the user to selecting particular nodes for inclusion in the graphical program. is a flowchart diagram illustrating one embodiment of a method for creating the graphical program in response to user input. The method may be implemented by the graphical program development environment software executing on a computer system.

As indicated in block a first one or more nodes may be displayed in a block diagram of the graphical program in response to user input. For example the user may drag and drop the first one or more nodes from a palette into the block diagram or may select the first one or more nodes from a menu. The first one or more nodes may be executable to create an EDVR data structure referencing an external memory buffer and thus are also referred to herein as a reference creation node s . As indicated in block in some embodiments the graphical program development environment may receive user input setting one or more properties of the first one or more nodes to configure the first one or more nodes to generate the EDVR. The one or more properties may specify information about the EDVR to be generated and or about the external memory buffer referenced by the EDVR. In some embodiments the first one or more nodes may call another program such as the producer program consumer program or a memory manager program in order to generate the EDVR. The other program may interact with the graphical program execution environment via the EDVR API to create the EDVR. The one or more properties may specify which program the first one or more nodes should call in order to generate the EDVR. In alternative embodiments the first one or more nodes may be inherently configured with information specifying the properties of the EDVR to be generated and no user input setting these properties may be required.

As indicated in block a second one or more nodes may also be displayed in the block diagram in response to user input. The second one or more nodes may be function nodes configured to perform any of various functions or algorithms that operate to access the external memory buffer referenced by the EDVR. As indicated in block the graphical program development environment may connect the first one or more nodes to the second one or more nodes in response to user input. For example the user may use a wiring tool provided by the graphical program development environment to wire together an output terminal of one of the first one or more nodes to an input terminal of one of the second one or more nodes. This may configure the second one or more nodes to receive the EDVR referencing the external memory buffer during the execution of the graphical program. The second one or more nodes may then execute to perform the particular function or algorithm they implement. In performing this function or algorithm the second one or more nodes may use the EDVR to natively access the external memory buffer e.g. to read data from or write data to the external memory buffer.

As indicated in block a third one or more nodes may also be displayed in the block diagram in response to user input. The third one or more nodes may be executable to release the EDVR data structure and thus are also referred to herein as a reference release node s . As indicated in block the graphical program development environment may connect the third one or more nodes to the second one or more nodes in response to user input. This may configure the third one or more nodes to receive the EDVR during the execution of the graphical program. The third one or more nodes may then execute to release the EDVR e.g. so that the external memory buffer it references can be de allocated or re used by the owner program.

In some embodiments a graphical user interface or front panel of the graphical program may also be displayed on the display device during execution of the graphical program. The graphical user interface may comprise any type of graphical user interface e.g. depending on the computing platform.

In various embodiments the graphical program may execute in conjunction with the producer program and or the consumer program to perform any kind of application. Examples of applications they may implement include performing test and or measurement functions controlling and or modeling instrumentation or industrial automation hardware modeling and simulation functions e.g. modeling or simulating a device or product being developed or tested etc. However it is noted that embodiments of the present invention can be used for a plethora of applications and is not limited to the above applications. In other words applications discussed in the present description are examples only and embodiments of the present invention may be used in any of various types of systems. Thus embodiments of the system and method of the present invention may be used in any of various types of applications including the control of other types of devices such as multimedia devices video devices audio devices telephony devices Internet devices etc. as well as general purpose software applications such as word processing spreadsheets network control network monitoring financial applications games etc.

The one or more instruments may include a GPIB instrument and associated GPIB interface card a data acquisition board inserted into or otherwise coupled with chassis with associated signal conditioning circuitry a VXI instrument a PXI instrument a video device or camera and associated image acquisition or machine vision card a motion control device and associated motion control interface card and or one or more computer based instrument cards among other types of devices. The computer system may couple to and operate with one or more of these instruments. The instruments may be coupled to the unit under test UUT or process or may be coupled to receive field signals typically generated by transducers. The system may be used in a data acquisition and control application in a test and measurement application an image processing or machine vision application a process control application a man machine interface application a simulation application or a hardware in the loop validation application among others.

The one or more devices may include a data acquisition board inserted into or otherwise coupled with chassis with associated signal conditioning circuitry a PXI instrument a video device and associated image acquisition card a motion control device and associated motion control interface card a fieldbus device and associated fieldbus interface card a PLC Programmable Logic Controller a serial instrument and associated serial interface card or a distributed data acquisition system such as the Fieldpoint system available from National Instruments Corp. among other types of devices.

The computer may include at least one central processing unit or CPU processor which is coupled to a processor or host bus . The CPU may be any of various types including an x86 processor e.g. a Pentium class a PowerPC processor a CPU from the SPARC family of RISC processors as well as others. One or more memory mediums typically including RAM and referred to as main memory may be coupled to the host bus by means of a memory controller . The main memory may store the graphical program the producer program the consumer program and the graphical program execution environment . The main memory may also store operating system software as well as other software for operation of the computer system.

The host bus may be coupled to an expansion or input output bus by means of a bus controller or bus bridge logic. The expansion bus may be the PCI Peripheral Component Interconnect expansion bus although other bus types can be used. The expansion bus includes slots for various devices such as described above. The computer further comprises a video display subsystem and hard drive coupled to the expansion bus . The computer may also comprise a GPIB card coupled to a GPIB bus and or an MXI device coupled to a VXI chassis .

As shown a device may also be connected to the computer. In some embodiments the device may include a processor and memory which may execute a real time operating system. The device may also or instead comprise a programmable hardware element. In some embodiments the computer system may be configured to deploy the graphical program to the device for execution of the graphical program on the device . The deployed graphical program may take the form of graphical program instructions or data structures that directly represents the graphical program. Alternatively the deployed graphical program may take the form of text code e.g. C code generated from the graphical program. As another example the deployed graphical program may take the form of compiled code generated from either the graphical program or from text code that in turn was generated from the graphical program.

As mentioned above in some embodiments the graphical program may enable a consumer program to use data produced by a producer program without requiring a separate copy of the data to be made before the consumer program can access the data. In various embodiments the graphical program the graphical program execution environment the producer program and the consumer program may interact with each other in various ways. is a diagram illustrating their interaction with each other according to one embodiment.

As indicated by the arrow the producer program may produce data and store the data in a memory buffer or may cause data produced by another software or hardware entity to be stored in the memory buffer . In some embodiments the memory buffer may be a block of memory within a memory region allocated by the producer program e.g. a region of memory from the main memory of the computer system . For example the region of memory may be allocated by the producer program from the operating system of the computer system in response to a request by the producer program.

In various embodiments the producer program may be any kind of program and may produce and store any kind of data in the memory buffer . As one example the producer program may be a device driver program that interacts with or controls a measurement device or instrument coupled to the computer system as illustrated in such as the motion control interface device image acquisition device or other measurement device. In this example the device driver program producer program may command the measurement device to transfer the measurement data to the memory buffer e.g. using DMA techniques. As another example the producer program may be associated with a technical data management framework that manages technical data such as measurement data acquired from a measurement device. For example the producer program may retrieve technical data from a database and store the technical data in the memory buffer .

The graphical program may enable the consumer program to use the data stored by the producer program in the memory buffer by passing an EDVR data structure that references the memory buffer to the consumer program . In various embodiments the EDVR may be created in various ways. According to some embodiments one or more of the nodes in the graphical program referred to as reference creation node s may be executable to communicate with the producer program to request the creation of the EDVR as indicated by the arrow in .

Although the memory buffer is owned by the producer program the EDVR that is used to reference the memory buffer is a data structure that needs to be accessible by the graphical program . Since the producer program is an external program from the graphical program and the graphical program execution environment the producer program may not have the knowledge or ability to create the EDVR which instead may need to be created internally to the graphical program execution environment . As shown in the graphical program execution environment may include an application programming interface API that includes functions for creating and managing external data value references illustrated as the EDVR API . As indicated by the arrow the producer program may call the EDVR API to request the EDVR data structure to be created. In response to this request the graphical program execution environment may create the EDVR and return it to the producer program as indicated by the arrow .

When the producer program receives the EDVR from the graphical program execution environment the producer program may then modify the EDVR to cause it to reference the memory buffer e.g. by writing location information into the EDVR indicating where the buffer or a portion of the buffer is stored in memory. The producer program then returns the EDVR to the graphical program as indicated by the arrow .

As indicated by the arrow the graphical program may then pass the EDVR to the consumer program . In some embodiments the consumer program may be represented in the block diagram of the graphical program as one or more consumer program nodes to which the reference creation node is wired where the wire visually indicates that the reference creation node is configured to pass the EDVR to the consumer program node s . Thus during the execution of the graphical program the reference creation node may execute to communicate with the producer program to cause the EDVR to be created and may then pass the EDVR along the wire to the consumer program node s that represent or encapsulate the consumer program .

The consumer program may then use the EDVR to access the memory buffer . The EDVR enables the consumer program to access the data directly from the memory buffer in which the data was originally stored by the producer program without requiring the data in the memory buffer to first be copied to another memory location. The consumer program may use the data in the memory buffer in any of various ways depending on the particular application. As one example the consumer program may cause the data from the memory buffer to be written to a disk drive or other target storage device coupled to the computer system . The target storage device may be directly coupled to the computer system e.g. via an I O bus or may be indirectly coupled to the computer system through a network. In some embodiments the consumer program may write the data into a data file according to a particular format. For example in one embodiment the data may be measurement data acquired from a measurement device and the data may be written according to a technical data format specialized for representing measurement data. As another example the consumer program may write the data into one or more tables of a database. In other embodiments the consumer program may use the data in other ways instead of or in addition to writing the data to a target storage location. For example the consumer program may analyze the data in various ways and display or log results of the analysis. As another example the consumer program may use the data to determine how to control a device or instrument coupled to the computer system e.g. to provide feedback for a process control application based on the data.

After the consumer program writes the data referenced by the EDVR to the target storage location or otherwise consumes the data referenced by the EDVR the consumer program may call the EDVR API of the graphical program execution environment to notify the graphical program execution environment that the consumer program is finished with the EDVR as indicated by the arrow . The graphical program execution environment may in turn communicate with the producer program as indicated by the arrow to notify the producer program that the EDVR is no longer in use and thus the producer program can now de allocate or re use the memory referenced by the EDVR. In some embodiments the producer program may register a callback function for the graphical program execution environment to call when the EDVR is no longer needed and the graphical program execution environment may call the callback function.

In some embodiments the producer program may treat the memory buffer as a circular FIFO first in first out buffer. For example the producer program may periodically produce new data values and store them in the next unused portion of the memory buffer wrapping back to the beginning of the buffer when the end is reached. In some embodiments the EDVR returned to the graphical program may be a reference to a particular section of the memory buffer rather than referencing the entire memory buffer . For example the graphical program may periodically communicate with the producer program to request a reference to the next n elements of the memory buffer where n is a positive integer. Upon each request the producer program may return an EDVR pointing to the next section of the memory buffer beyond the section that was last requested by the graphical program. Along with each EDVR the producer program may also return information indicating the number of elements in the section pointed to by the EDVR which may be the same as the number of elements requested by the graphical program or may be less if the end of the memory buffer is reached or if the requested number of elements is not available in the time frame specified by the requestor. Thus for example suppose that the graphical program first requests the first 10 elements of the memory buffer. The producer program may communicate with the graphical program execution environment to create a first EDVR data structure and may set the first EDVR to point to the beginning of the memory buffer and then return the first EDVR to the graphical program along with information indicating that the first EDVR points to a section containing 10 elements of the memory buffer. The graphical program may later request the next 10 elements of the memory buffer. The producer program may then communicate with the graphical program execution environment to create a second EDVR data structure and may set the second EDVR to point to the section of the memory buffer that starts at the 11th element and may then return the second EDVR to the graphical program along with information indicating that the second EDVR points to a section containing 10 elements of the memory buffer. The graphical program may pass each respective EDVR to the consumer program to enable the consumer program to consume the data pointed to by the respective EDVR. When the consumer program has finished consuming the data pointed to by each respective EDVR the consumer program may call the EDVR API of the graphical program execution environment to notify the graphical program execution environment that the consumer program is finished with the EDVR. The graphical program execution environment may in turn communicate with the producer program to notify the producer program that the EDVR is no longer in use and thus the producer program can now re use the section of memory referenced by the EDVR e.g. can write new data into that section of the memory buffer .

In some embodiments the graphical program may pass the EDVR s to the consumer program asynchronously e.g. without blocking or waiting for the consumer program to consume the data pointed to by each EDVR. Thus for example the producer program may execute a loop to produce respective data sets and store them in the memory buffer . The graphical program may execute a loop to request respective EDVRs referencing respective sections of the memory buffer from the producer program and to asynchronously pass the EDVRs to the consumer program without blocking Each time the consumer program receives a new EDVR from the graphical program the consumer program may schedule an operation to consume the data e.g. an operation to write the data to disk for example and may then immediately return control to the graphical program without waiting for the consumption operation to occur. The graphical program may thus loop back around and wait for the next data set to become available from the producer program. In the mean time the consumer program may consume the data referenced by each EDVR and then asynchronously notify the graphical program execution environment which in turn notifies the producer program that the EDVR can be released.

Thus various embodiments of the system and method described herein may enable a consumer program to share a memory buffer allocated by a producer program to asynchronously consume data produced by the producer program. Since the graphical program execution environment acts as an intermediary between the producer program and the consumer program these two programs may not communicate directly and may not even need to know about each other. Instead the producer program and the consumer program can utilize the EDVR API of the graphical program execution environment to implement the memory buffer sharing as described above.

In some embodiments the graphical program and the graphical program execution environment may act as an intermediate agent between the producer program and the consumer program where the graphical program itself does not access the memory buffer that stores the data produced by the producer program. The graphical program may obtain the EDVR that references the memory buffer and pass the EDVR to the consumer program. The graphical program execution environment may then notify the producer program when the EDVR has been released by the consumer program in response to the consumer program asynchronously notifying the graphical program execution environment that it has released the EDVR.

In other embodiments the graphical program itself may access the memory buffer. For example in addition to the consumer program reading the data from the memory buffer the graphical program may also read the data and use it to perform various operations. The graphical program may also modify the data in the memory buffer in some embodiments. For example in some embodiments after creating the EDVR that references the memory buffer the graphical program may use the EDVR to read the data from the memory buffer process the data to produce modified data and write the modified data to the memory buffer to replace the original data. The graphical program may then pass the EDVR to the consumer program which may use the EDVR to access the modified data in the memory buffer.

In some embodiments the graphical program execution environment may provide function blocks or sub program nodes which are pre configured to act as producer programs and consumer programs which share a memory buffer with each other. The user may be able to select these nodes and include them in a graphical program to easily implement various applications. is a flowchart diagram illustrating one embodiment of a method for creating a graphical program to implement an application in which a consumer program uses data produced by a producer program.

A user of the graphical program execution environment may utilize a block diagram editor to create the graphical program by arranging on a display a plurality of nodes or icons and then interconnecting the nodes to create the graphical program. The nodes may be interconnected in one or more of a data flow control flow or execution flow format. The graphical program may thus comprise a plurality of interconnected nodes or icons that visually indicates the functionality of the program. As one example the user may use the LabVIEW graphical programming development environment to create the graphical program.

As indicated in block in creating the graphical program the user may select a reference creation node and cause it to be displayed in the graphical program. The user may configure the reference creation node to obtain a reference to a section of external memory allocated by a producer program that operates externally from the graphical program and the graphical program execution environment. In some embodiments the reference creation node may be inherently associated with a particular producer program. In other embodiments the user may provide input to the graphical program execution environment selecting a particular producer program with which to associate the reference creation node. The user may also configure the reference creation node with other information such as a number of memory elements to request. illustrates one example of a graphical program including a reference creation node configured to acquire an EDVR referencing an external block of memory. The user can wire inputs to the reference creation node to specify a number of elements requested for the reference and a timeout value indicating how long to wait for the producer program to return the reference before timing out. In the example of the reference creation node may be associated with an external device driver program that stores measurement data acquired by a measurement device in memory of a host computer system.

As indicated in block of the user may also display a node representing a consumer program and configure the consumer program to receive the reference from the reference creation node. For example in the user has included the TDMS node in the graphical program which is a node provided by the graphical program execution environment with pre configured functionality for receiving data and writing the data to disk in a technical data format. The user has also wired the reference creation node to the TDMS node to indicate that the EDVR reference obtained by the reference creation node is passed as input to the TDMS node .

In some embodiments the node that receives the reference from the reference creation node may represent an external consumer program that executes externally from the graphical program and the graphical program execution environment. In other embodiments the consumer program may execute within the graphical program execution environment.

In response to the user assembling the graphical program data structures may be created and stored which represent the graphical program. As indicated in block of the user may then request the graphical program to be executed. The graphical program may execute under control of the graphical program execution environment . During the execution the reference creation node may obtain a reference to a section of memory allocated by the producer program and may pass the reference to the consumer program node e.g. the TDMS node in the example of . The TDMS node is pre configured with functionality to asynchronously write the data in the referenced external memory section to disk and then call the EDVR API of the graphical program execution environment to release the external memory section. Thus the user does not need to manually create program code to handle the details of releasing the memory since the TDMS node performs the memory release automatically. To create the application the user simply displays and connects the nodes as shown in . The user may also display a loop structure and position the reference creation node and TDMS node within the loop structure. This may cause the graphical program to perform a loop where in each iteration of the loop the reference creation node obtains a reference to a respective section of external memory containing data produced by the producer program and passes the reference to the TDMS node. Thus the TDMS node may asynchronously stream the data produced by the producer program to disk.

In some embodiments the graphical program may not show a separate producer node that represents the producer program. Instead the reference creation node may be inherently associated with a particular producer program. In other embodiments the graphical program may show a producer node and may connect it to the reference creation node to more explicitly show where the memory reference originates. In still other embodiments the graphical program may show a producer node that is wired directly to the consumer node without an intermediate reference creation node between. Wiring the producer node to the consumer node may configure the graphical program to pass a reference to external memory allocated by the producer program to the consumer program.

In various embodiments the graphical program execution environment may provide reference creation nodes or producer nodes for producing or obtaining references to various kinds of data created by any of various kinds of producer programs. Similarly the graphical program execution environment may provide various consumer nodes that are operable to invoke any of various kinds of consumer programs that utilize data in any of various ways. The user may be able to pair up any of the various producer programs with any of the various consumer programs by creating a graphical program according to the techniques described above in order to easily create an application in which a given consumer program consumes data stored in external memory allocated by a given producer program.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

