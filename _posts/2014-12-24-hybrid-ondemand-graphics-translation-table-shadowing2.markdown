---

title: Hybrid on-demand graphics translation table shadowing
abstract: In several embodiments, a graphics processor couples to a virtual machine monitor (VMM) to present a virtual graphics processor to one or more virtual machines. A mediator for the virtual graphics processor synchronously shadows modifications to a guest graphics translation table (GTT) of a virtual machine to a shadow GTT of the VMM using trap and emulate virtualization. If the mediator detects a frequency of modifications to the guest GTT that exceeds a threshold the mediator may then asynchronously shadow at least a portion of the guest GTT to the shadow GTT and rebuild the shadow GTT prior to submitting commands for the virtual graphics processor to the graphics processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619860&OS=09619860&RS=09619860
owner: Inte Corporation
number: 09619860
owner_city: Santa Clara
owner_country: US
publication_date: 20141224
---
This patent application is a U.S. National Phase Application under 35 U.S.C. 371 of International Application No. PCT CN2014 094804 filed Dec. 24 2014 entitled HYBRID ON DEMAND GRAPHICS TRANSLATION TABLE SHADOWING and the entire contents of which are incorporated herein by reference.

Embodiments generally relate to graphics virtualization environments. More particularly embodiments relate to the management of graphics translation tables.

Graphics virtualization may enable software executing within a virtual machine VM to control various events and have access to graphics hardware resources on a physical machine wherein a virtual machine monitor VMM may create and run the VMs on the physical machine. Accordingly the VM software may collectively be referred to as guest software and the VMM may be referred to as a host. Partitioning the graphics hardware resources between multiple VMs may present certain challenges with regard to efficiency and security. For example the host and the guest software in conventional graphics virtualization solutions may not have the same view e.g. size and layout of the graphics memory address space nor can the guest graphics memory address space be identical to the system memory address space in certain instances. Accordingly as guest commands e.g. rendering commands are issued by the guest software to the graphics hardware address remapping and or fixing e.g. finding the guest address in the command and replacing it with a host address from the guest view to the host view may be conducted. Hardware based address remapping and or fixing may involve tagging technology that adds complexity. Moreover software based address remapping and or fixing may involve VMM interception parsing and or conversion of each guest command which may cause additional overhead.

An embodiment of data processing system can include or be incorporated within a server based gaming platform a game console including a game and media console a mobile gaming console a handheld game console or an online game console. In some embodiments data processing system is a mobile phone smart phone tablet computing device or mobile Internet device. Data processing system can also include couple with or be integrated within a wearable device such as a smart watch wearable device smart eyewear device augmented reality device or virtual reality device. In some embodiments data processing system is a television or set top box device having one or more processors and a graphical interface generated by one or more graphics processors . In one embodiment the data processing system is a wireless router or access point for use as a home network gateway a home media server or an combination access point digital signage solution for public areas e.g. hospitals .

In some embodiments the one or more processors each include one or more processor cores to process instructions which when executed perform operations for system and user software. In some embodiments each of the one or more processor cores is configured to process a specific instruction set . In some embodiments instruction set may facilitate Complex Instruction Set Computing CISC Reduced Instruction Set Computing RISC or computing via a Very Long Instruction Word VLIW . Multiple processor cores may each process a different instruction set which may include instructions to facilitate the emulation of other instruction sets. Processor core may also include other processing devices such a Digital Signal Processor DSP .

In some embodiments the processor includes cache memory . Depending on the architecture the processor can have a single internal cache or multiple levels of internal cache. In some embodiments the cache memory is shared among various components of the processor . In some embodiments the processor also uses an external cache e.g. a Level 3 L3 cache or Last Level Cache LLC not shown which may be shared among processor cores using known cache coherency techniques. A register file is additionally included in processor which may include different types of registers for storing different types of data e.g. integer registers floating point registers status registers and an instruction pointer register . Some registers may be general purpose registers while other registers may be specific to the design of the processor .

In some embodiments processor is coupled to a processor bus to transmit data signals between processor and other components in system . System uses an exemplary hub system architecture including a memory controller hub and an input output I O controller hub . Memory controller hub facilitates communication between a memory device and other components of system while I O Controller Hub ICH provides connections to I O devices via a local I O bus.

Memory device can be a dynamic random access memory DRAM device a static random access memory SRAM device flash memory device or some other memory device having suitable performance to serve as process memory. Memory can store data and instructions for use when processor executes a process. Memory controller hub also couples with an optional external graphics processor which may communicate with the one or more graphics processors in processors to perform graphics and media operations.

In some embodiments ICH enables peripherals to connect to memory and processor via a high speed I O bus. The I O peripherals include an audio controller a firmware interface a wireless transceiver e.g. Wi Fi Bluetooth a data storage device e.g. hard disk drive flash memory etc. and a legacy I O controller for coupling legacy e.g. Personal System 2 PS 2 devices to the system. One or more Universal Serial Bus USB controllers connect input devices such as keyboard and mouse combinations. A network controller may also couple to ICH . In some embodiments a high performance network controller not shown couples to processor bus .

The internal cache units A N and shared cache units represent a cache memory hierarchy within the processor . The cache memory hierarchy may include at least one level of instruction and data cache within each core and one or more levels of shared mid level cache such as a Level 2 L2 Level 3 L3 Level 4 L4 or other levels of cache where the highest level of cache before external memory is classified as the LLC. In some embodiments cache coherency logic maintains coherency between the various cache units and A N.

In some embodiments processor may also include a set of one or more bus controller units and a system agent . The one or more bus controller units manage a set of peripheral buses such as one or more Peripheral Component Interconnect buses e.g. PCI PCI Express . System agent provides management functionality for the various processor components. In some embodiments system agent includes one or more integrated memory controllers to manage access to various external memory devices not shown .

In some embodiments one or more of the cores A N include support for simultaneous multi threading. In such embodiment the system agent includes components for coordinating and operating cores A N during multi threaded processing. System agent may additionally include a power control unit PCU which includes logic and components to regulate the power state of cores A N and graphics processor .

In some embodiments processor additionally includes graphics processor to execute graphics processing operations. In some embodiments the graphics processor couples with the set of shared cache units and the system agent unit including the one or more integrated memory controllers . In some embodiments a display controller is coupled with the graphics processor to drive graphics processor output to one or more coupled displays. In some embodiments display controller may be separate module coupled with the graphics processor via at least one interconnect or may be integrated within the graphics processor or system agent .

In some embodiments a ring based interconnect unit is used to couple the internal components of the processor . However an alternative interconnect unit may be used such as a point to point interconnect a switched interconnect or other techniques including techniques well known in the art. In some embodiments graphics processor couples with the ring interconnect via an I O link .

The exemplary I O link represents at least one of multiple varieties of I O interconnects including an on package I O interconnect which facilitates communication between various processor components and a high performance embedded memory module such as an eDRAM module. In some embodiments each of the cores N and graphics processor use embedded memory modules as a shared Last Level Cache.

In some embodiments cores A N are homogenous cores executing the same instruction set architecture. In another embodiment cores A N are heterogeneous in terms of instruction set architecture ISA where one or more of cores A N execute a first instruction set while at least one of the other cores executes a subset of the first instruction set or a different instruction set.

In some embodiments processor is a part of or implemented on one or more substrates using any of a number of process technologies for example Complementary metal oxide semiconductor CMOS Bipolar Junction Complementary metal oxide semiconductor BiCMOS or N type metal oxide semiconductor logic NMOS . Additionally processor can be implemented on one or more chips or as an SoC integrated circuit having the illustrated components in addition to other components.

In some embodiments graphics processor also includes a display controller to drive display output data to a display device . Display controller includes hardware for one or more overlay planes for the display and composition of multiple layers of video or user interface elements. In some embodiments graphics processor includes a video codec engine to encode decode or transcode media to from or between one or more media encoding formats including but not limited to Moving Picture Experts Group MPEG formats such as MPEG 2 Advanced Video Coding AVC formats such as H.264 MPEG 4 AVC as well as the Society of Motion Picture Television Engineers SMPTE 421M VC 1 and Joint Photographic Experts Group JPEG formats such as JPEG and Motion JPEG MJPEG formats.

In some embodiments graphics processor includes a block image transfer BLIT engine to perform two dimensional 2D rasterizer operations including for example bit boundary block transfers. However in one embodiment 2D graphics operations are performed using one or more components of the graphics processing engine GPE . In some embodiments graphics processing engine is a compute engine for performing graphics operations including three dimensional 3D graphics operations and media operations.

In some embodiments GPE includes a 3D pipeline for performing 3D operations such as rendering three dimensional images and scenes using processing functions that act upon 3D primitive shapes e.g. rectangle triangle etc. . The 3D pipeline includes programmable and fixed function elements that perform various tasks within the element and or spawn execution threads to a 3D Media subsystem . While 3D pipeline can be used to perform media operations an embodiment of GPE also includes a media pipeline that is specifically used to perform media operations such as video post processing and image enhancement.

In some embodiments media pipeline includes fixed function or programmable logic units to perform one or more specialized media operations such as video decode acceleration video de interlacing and video encode acceleration in place of or on behalf of video codec engine . In some embodiments media pipeline additionally includes a thread spawning unit to spawn threads for execution on 3D Media sub system . The spawned threads perform computations for the media operations on one or more graphics execution units included in 3D Media sub system .

In some embodiments 3D Media subsystem includes logic for executing threads spawned by 3D pipeline and media pipeline . In one embodiment the pipelines send thread execution requests to 3D Media subsystem which includes thread dispatch logic for arbitrating and dispatching the various requests to available thread execution resources. The execution resources include an array of graphics execution units to process the 3D and media threads. In some embodiments 3D Media subsystem includes one or more internal caches for thread instructions and data. In some embodiments the subsystem also includes shared memory including registers and addressable memory to share data between threads and to store output data.

In some embodiments GPE couples with a command streamer which provides a command stream to the GPE 3D and media pipelines . In some embodiments command streamer is coupled to memory which can be system memory or one or more of internal cache memory and shared cache memory. In some embodiments command streamer receives commands from the memory and sends the commands to 3D pipeline and or media pipeline . The 3D and media pipelines process the commands by performing operations via logic within the respective pipelines or by dispatching one or more execution threads to an execution unit array . In some embodiments execution unit array is scalable such that the array includes a variable number of execution units based on the target power and performance level of GPE .

In some embodiments a sampling engine couples with memory e.g. cache memory or system memory and execution unit array . In some embodiments sampling engine provides a memory access mechanism for execution unit array that allows execution array to read graphics and media data from memory. In some embodiments sampling engine includes logic to perform specialized image sampling operations for media.

In some embodiments the specialized media sampling logic in sampling engine includes a de noise de interlace module a motion estimation module and an image scaling and filtering module . In some embodiments de noise de interlace module includes logic to perform one or more of a de noise or a de interlace algorithm on decoded video data. The de interlace logic combines alternating fields of interlaced video content into a single fame of video. The de noise logic reduces or removes data noise from video and image data. In some embodiments the de noise logic and de interlace logic are motion adaptive and use spatial or temporal filtering based on the amount of motion detected in the video data. In some embodiments the de noise de interlace module includes dedicated motion detection logic e.g. within the motion estimation engine .

In some embodiments motion estimation engine provides hardware acceleration for video operations by performing video acceleration functions such as motion vector estimation and prediction on video data. The motion estimation engine determines motion vectors that describe the transformation of image data between successive video frames. In some embodiments a graphics processor media codec uses video motion estimation engine to perform operations on video at the macro block level that may otherwise be too computationally intensive to perform with a general purpose processor. In some embodiments motion estimation engine is generally available to graphics processor components to assist with video decode and processing functions that are sensitive or adaptive to the direction or magnitude of the motion within video data.

In some embodiments image scaling and filtering module performs image processing operations to enhance the visual quality of generated images and video. In some embodiments scaling and filtering module processes image and video data during the sampling operation before providing the data to execution unit array .

In some embodiments the GPE includes a data port which provides an additional mechanism for graphics subsystems to access memory. In some embodiments data port facilitates memory access for operations including render target writes constant buffer reads scratch memory space reads writes and media surface accesses. In some embodiments data port includes cache memory space to cache accesses to memory. The cache memory can be a single data cache or separated into multiple caches for the multiple subsystems that access memory via the data port e.g. a render buffer cache a constant buffer cache etc. . In some embodiments threads executing on an execution unit in execution unit array communicate with the data port by exchanging messages via a data distribution interconnect that couples each of the sub systems of GPE .

In some embodiments graphics processor includes a ring interconnect a pipeline front end a media engine and graphics cores A N. In some embodiments ring interconnect couples the graphics processor to other processing units including other graphics processors or one or more general purpose processor cores. In some embodiments the graphics processor is one of many processors integrated within a multi core processing system.

In some embodiments graphics processor receives batches of commands via ring interconnect . The incoming commands are interpreted by a command streamer in the pipeline front end . In some embodiments graphics processor includes scalable execution logic to perform 3D geometry processing and media processing via the graphics core s A N. For 3D geometry processing commands command streamer supplies commands to geometry pipeline . For at least some media processing commands command streamer supplies the commands to a video front end which couples with a media engine . In some embodiments media engine includes a Video Quality Engine VQE for video and image post processing and a multi format encode decode MFX engine to provide hardware accelerated media data encode and decode. In some embodiments geometry pipeline and media engine each generate execution threads for the thread execution resources provided by at least one graphics core A.

In some embodiments graphics processor includes scalable thread execution resources featuring modular cores A N sometimes referred to as core slices each having multiple sub cores A N A N sometimes referred to as core sub slices . In some embodiments graphics processor can have any number of graphics cores A through N. In some embodiments graphics processor includes a graphics core A having at least a first sub core A and a second core sub core A. In other embodiments the graphics processor is a low power processor with a single sub core e.g. A . In some embodiments graphics processor includes multiple graphics cores A N each including a set of first sub cores A N and a set of second sub cores A N. Each sub core in the set of first sub cores A N includes at least a first set of execution units A N and media texture samplers A N. Each sub core in the set of second sub cores A N includes at least a second set of execution units A N and samplers A N. In some embodiments each sub core A N A N shares a set of shared resources A N. In some embodiments the shared resources include shared cache memory and pixel operation logic. Other shared resources may also be included in the various embodiments of the graphics processor.

In some embodiments thread execution logic includes a pixel shader a thread dispatcher instruction cache a scalable execution unit array including a plurality of execution units A N a sampler a data cache and a data port . In one embodiment the included components are interconnected via an interconnect fabric that links to each of the components. In some embodiments thread execution logic includes one or more connections to memory such as system memory or cache memory through one or more of instruction cache data port sampler and execution unit array A N. In some embodiments each execution unit e.g. A is an individual vector processor capable of executing multiple simultaneous threads and processing multiple data elements in parallel for each thread. In some embodiments execution unit array A N includes any number individual execution units.

In some embodiments execution unit array A N is primarily used to execute shader programs. In some embodiments the execution units in array A N execute an instruction set that includes native support for many standard 3D graphics shader instructions such that shader programs from graphics libraries e.g. Direct 3D and OpenGL are executed with a minimal translation. The execution units support vertex and geometry processing e.g. vertex programs geometry programs vertex shaders pixel processing e.g. pixel shaders fragment shaders and general purpose processing e.g. compute and media shaders .

Each execution unit in execution unit array A N operates on arrays of data elements. The number of data elements is the execution size or the number of channels for the instruction. An execution channel is a logical unit of execution for data element access masking and flow control within instructions. The number of channels may be independent of the number of physical Arithmetic Logic Units ALUs or Floating Point Units FPUs for a particular graphics processor. In some embodiments execution units A N support integer and floating point data types.

The execution unit instruction set includes single instruction multiple data SIMD instructions. The various data elements can be stored as a packed data type in a register and the execution unit will process the various elements based on the data size of the elements. For example when operating on a 256 bit wide vector the 256 bits of the vector are stored in a register and the execution unit operates on the vector as four separate 64 bit packed data elements Quad Word QW size data elements eight separate 32 bit packed data elements Double Word DW size data elements sixteen separate 16 bit packed data elements Word W size data elements or thirty two separate 8 bit data elements byte B size data elements . However different vector widths and register sizes are possible.

One or more internal instruction caches e.g. are included in the thread execution logic to cache thread instructions for the execution units. In some embodiments one or more data caches e.g. are included to cache thread data during thread execution. In some embodiments sampler is included to provide texture sampling for 3D operations and media sampling for media operations. In some embodiments sampler includes specialized texture or media sampling functionality to process texture or media data during the sampling process before providing the sampled data to an execution unit.

During execution the graphics and media pipelines send thread initiation requests to thread execution logic via thread spawning and dispatch logic. In some embodiments thread execution logic includes a local thread dispatcher that arbitrates thread initiation requests from the graphics and media pipelines and instantiates the requested threads on one or more execution units A N. For example the geometry pipeline e.g. of dispatches vertex processing tessellation or geometry processing threads to thread execution logic . In some embodiments thread dispatcher can also process runtime thread spawning requests from the executing shader programs.

Once a group of geometric objects has been processed and rasterized into pixel data pixel shader is invoked to further compute output information and cause results to be written to output surfaces e.g. color buffers depth buffers stencil buffers etc. . In some embodiments pixel shader calculates the values of the various vertex attributes that are to be interpolated across the rasterized object. In some embodiments pixel shader then executes an API supplied pixel shader program. To execute the pixel shader program pixel shader dispatches threads to an execution unit e.g. A via thread dispatcher . In some embodiments pixel shader uses texture sampling logic in sampler to access texture data in texture maps stored in memory. Arithmetic operations on the texture data and the input geometry data compute pixel color data for each geometric fragment or discards one or more pixels from further processing.

In some embodiments the data port provides a memory access mechanism for the thread execution logic output processed data to memory for processing on a graphics processor output pipeline. In some embodiments the data port includes or couples to one or more cache memories e.g. data cache to cache data for memory access via the data port.

In some embodiments the graphics processor execution units natively support instructions in a 128 bit format . A 64 bit compacted instruction format is available for some instructions based on the selected instruction instruction options and number of operands. The native 128 bit format provides access to all instruction options while some options and operations are restricted in the 64 bit format . The native instructions available in the 64 bit format vary by embodiment. In some embodiments the instruction is compacted in part using a set of index values in an index field . The execution unit hardware references a set of compaction tables based on the index values and uses the compaction table outputs to reconstruct a native instruction in the 128 bit format .

For each format instruction opcode defines the operation that the execution unit is to perform. The execution units execute each instruction in parallel across the multiple data elements of each operand. For example in response to an add instruction the execution unit performs a simultaneous add operation across each color channel representing a texture element or picture element. By default the execution unit performs each instruction across all data channels of the operands. In some embodiments instruction control field enables control over certain execution options such as channels selection e.g. predication and data channel order e.g. swizzle . For 128 bit instructions an exec size field limits the number of data channels that will be executed in parallel. In some embodiments exec size field is not available for use in the 64 bit compact instruction format .

Some execution unit instructions have up to three operands including two source operands src src and one destination . In some embodiments the execution units support dual destination instructions where one of the destinations is implied. Data manipulation instructions can have a third source operand e.g. SRC where the instruction opcode determines the number of source operands. An instruction s last source operand can be an immediate e.g. hard coded value passed with the instruction.

In some embodiments the 128 bit instruction format includes an access address mode field which specifies an address mode and or an access mode for the instruction. In one embodiment the access mode to define a data access alignment for the instruction. Some embodiments support access modes including a 16 byte aligned access mode and a 1 byte aligned access mode where the byte alignment of the access mode determines the access alignment of the instruction operands. In one embodiment the address mode portion of the access address mode field determines whether the instruction is to use direct or indirect addressing.

In some embodiments instructions are grouped based on opcode bit fields to simplify Opcode decode . For an 8 bit opcode bits and allow the execution unit to determine the type of opcode. The precise opcode grouping shown is merely an example. In some embodiments a move and logic opcode group includes data movement and logic instructions e.g. move mov compare cmp . In some embodiments move and logic group shares the five most significant bits MSB where move mov instructions are in the form of 0000xxxxb e.g. 0x0x and logic instructions are in the form of 0001xxxxb e.g. 0x01 . A flow control instruction group e.g. call jump jmp includes instructions in the form of 0010xxxxb e.g. 0x20 . A miscellaneous instruction group includes a mix of instructions including synchronization instructions e.g. wait send in the form of 0011xxxxb e.g. 0x30 . A parallel math instruction group includes component wise arithmetic instructions e.g. add multiply mul in the form of 0100xxxxb e.g. 0x40 . The parallel math group performs the arithmetic operations in parallel across data channels. The vector math group includes arithmetic instructions e.g. dp4 in the form of 0101xxxxb e.g. 0x50 . The vector math group performs arithmetic such as dot product calculations on vector operands.

In some embodiments graphics processor includes a graphics pipeline a media pipeline a display engine thread execution logic and render engine . In some embodiments graphics processor is a graphics processor within a multi core processing system that includes one or more general purpose processing cores. The graphics processor is controlled by register writes to one or more control registers not shown or via commands issued to graphics processor via a ring interconnect . In some embodiments ring interconnect couples graphics processor to other processing components such as other graphics processors or general purpose processors. Commands from ring interconnect are interpreted by a command streamer which supplies instructions to individual components of graphics pipeline or media pipeline .

In some embodiments command streamer directs the operation of a vertex fetcher that reads vertex data from memory and executes vertex processing commands provided by command streamer . In some embodiments vertex fetcher provides vertex data to a vertex shader which performs coordinate space transformation and lighting operations to each vertex. In some embodiments vertex fetcher and vertex shader execute vertex processing instructions by dispatching execution threads to execution units A B via a thread dispatcher .

In some embodiments execution units A B are an array of vector processors having an instruction set for performing graphics and media operations. In some embodiments execution units A B have an attached L1 cache that is specific for each array or shared between the arrays. The cache can be configured as a data cache an instruction cache or a single cache that is partitioned to contain data and instructions in different partitions.

In some embodiments graphics pipeline includes tessellation components to perform hardware accelerated tessellation of 3D objects. In some embodiments a programmable hull shader configures the tessellation operations. A programmable domain shader provides back end evaluation of tessellation output. A tessellator operates at the direction of hull shader and contains special purpose logic to generate a set of detailed geometric objects based on a coarse geometric model that is provided as input to graphics pipeline . In some embodiments if tessellation is not used tessellation components can be bypassed.

In some embodiments complete geometric objects can be processed by a geometry shader via one or more threads dispatched to execution units A B or can proceed directly to the clipper . In some embodiments the geometry shader operates on entire geometric objects rather than vertices or patches of vertices as in previous stages of the graphics pipeline. If the tessellation is disabled the geometry shader receives input from the vertex shader . In some embodiments geometry shader is programmable by a geometry shader program to perform geometry tessellation if the tessellation units are disabled.

Before rasterization a clipper processes vertex data. The clipper may be a fixed function clipper or a programmable clipper having clipping and geometry shader functions. In some embodiments a rasterizer in the render output pipeline dispatches pixel shaders to convert the geometric objects into their per pixel representations. In some embodiments pixel shader logic is included in thread execution logic . In some embodiments an application can bypass the rasterizer and access un rasterized vertex data via a stream out unit .

The graphics processor has an interconnect bus interconnect fabric or some other interconnect mechanism that allows data and message passing amongst the major components of the processor. In some embodiments execution units A B and associated cache s texture and media sampler and texture sampler cache interconnect via a data port to perform memory access and communicate with render output pipeline components of the processor. In some embodiments sampler caches and execution units A B each have separate memory access paths.

In some embodiments render output pipeline contains a rasterizer and depth test component that converts vertex based objects into an associated pixel based representation. In some embodiments the rasterizer logic includes a windower masker unit to perform fixed function triangle and line rasterization. Associated render and depth buffer caches are also available in some embodiments. A pixel operations component performs pixel based operations on the data though in some instances pixel operations associated with 2D operations e.g. bit block image transfers with blending are performed by the 2D engine or substituted at display time by the display controller using overlay display planes. In some embodiments a shared L3 cache is available to all graphics components allowing the sharing of data without the use of main system memory.

In some embodiments graphics processor media pipeline includes a media engine and a video front end . In some embodiments video front end receives pipeline commands from the command streamer . In some embodiments media pipeline includes a separate command streamer. In some embodiments video front end processes media commands before sending the command to the media engine . In some embodiments media engine includes thread spawning functionality to spawn threads for dispatch to thread execution logic via thread dispatcher .

In some embodiments graphics processor includes a display engine . In some embodiments display engine is external to processor and couples with the graphics processor via the ring interconnect or some other interconnect bus or fabric. In some embodiments display engine includes a 2D engine and a display controller . In some embodiments display engine contains special purpose logic capable of operating independently of the 3D pipeline. In some embodiments display controller couples with a display device not shown which may be a system integrated display device as in a laptop computer or an external display device attached via a display device connector.

In some embodiments graphics pipeline and media pipeline are configurable to perform operations based on multiple graphics and media programming interfaces and are not specific to any one application programming interface API . In some embodiments driver software for the graphics processor translates API calls that are specific to a particular graphics or media library into commands that can be processed by the graphics processor. In some embodiments support is provided for the Open Graphics Library OpenGL and Open Computing Language OpenCL from the Khronos Group the Direct3D library from the Microsoft Corporation or support may be provided to both OpenGL and D3D. Support may also be provided for the Open Source Computer Vision Library OpenCV . A future API with a compatible 3D pipeline would also be supported if a mapping can be made from the pipeline of the future API to the pipeline of the graphics processor.

In some embodiments client specifies the client unit of the graphics device that processes the command data. In some embodiments a graphics processor command parser examines the client field of each command to condition the further processing of the command and route the command data to the appropriate client unit. In some embodiments the graphics processor client units include a memory interface unit a render unit a 2D unit a 3D unit and a media unit. Each client unit has a corresponding processing pipeline that processes the commands. Once the command is received by the client unit the client unit reads the opcode and if present sub opcode to determine the operation to perform. The client unit performs the command using information in data field . For some commands an explicit command size is expected to specify the size of the command. In some embodiments the command parser automatically determines the size of at least some of the commands based on the command opcode. In some embodiments commands are aligned via multiples of a double word.

The flow diagram in shows an exemplary command sequence . In some embodiments software or firmware of a data processing system that features an embodiment of a graphics processor uses a version of the command sequence shown to set up execute and terminate a set of graphics operations. A sample command sequence is shown and described for purposes of example only as embodiments are not limited to these specific commands or to this command sequence. Moreover the commands may be issued as batch of commands in a command sequence such that the graphics processor will process the sequence of commands in at least partially concurrence.

In some embodiments sample command sequence may begin with a pipeline flush command to cause any active graphics pipeline to complete the currently pending commands for the pipeline. In some embodiments the 3D pipeline and the media pipeline do not operate concurrently. The pipeline flush is performed to cause the active graphics pipeline to complete any pending commands. In response to a pipeline flush the command parser for the graphics processor will pause command processing until the active drawing engines complete pending operations and the relevant read caches are invalidated. Optionally any data in the render cache that is marked dirty can be flushed to memory. In some embodiments pipeline flush command can be used for pipeline synchronization or before placing the graphics processor into a low power state.

In some embodiments a pipeline select command is used when a command sequence requires the graphics processor to explicitly switch between pipelines. In some embodiments a pipeline select command is required only once within an execution context before issuing pipeline commands unless the context is to issue commands for both pipelines. In some embodiments a pipeline flush command is is required immediately before a pipeline switch via the pipeline select command .

In some embodiments a pipeline control command configures a graphics pipeline for operation and is used to program the 3D pipeline and the media pipeline . In some embodiments pipeline control command configures the pipeline state for the active pipeline. In one embodiment the pipeline control command is used for pipeline synchronization and to clear data from one or more cache memories within the active pipeline before processing a batch of commands.

In some embodiments return buffer state commands are used to configure a set of return buffers for the respective pipelines to write data. Some pipeline operations require the allocation selection or configuration of one or more return buffers into which the operations write intermediate data during processing. In some embodiments the graphics processor also uses one or more return buffers to store output data and to perform cross thread communication. In some embodiments the return buffer state includes selecting the size and number of return buffers to use for a set of pipeline operations.

The remaining commands in the command sequence differ based on the active pipeline for operations. Based on a pipeline determination the command sequence is tailored to the 3D pipeline beginning with the 3D pipeline state or the media pipeline beginning at the media pipeline state .

The commands for the 3D pipeline state include 3D state setting commands for vertex buffer state vertex element state constant color state depth buffer state and other state variables that are to be configured before 3D primitive commands are processed. The values of these commands are determined at least in part based the particular 3D API in use. In some embodiments 3D pipeline state commands are also able to selectively disable or bypass certain pipeline elements if those elements will not be used.

In some embodiments 3D primitive command is used to submit 3D primitives to be processed by the 3D pipeline. Commands and associated parameters that are passed to the graphics processor via the 3D primitive command are forwarded to the vertex fetch function in the graphics pipeline. The vertex fetch function uses the 3D primitive command data to generate vertex data structures. The vertex data structures are stored in one or more return buffers. In some embodiments 3D primitive command is used to perform vertex operations on 3D primitives via vertex shaders. To process vertex shaders 3D pipeline dispatches shader execution threads to graphics processor execution units.

In some embodiments 3D pipeline is triggered via an execute command or event. In some embodiments a register write triggers command execution. In some embodiments execution is triggered via a go or kick command in the command sequence. In one embodiment command execution is triggered using a pipeline synchronization command to flush the command sequence through the graphics pipeline. The 3D pipeline will perform geometry processing for the 3D primitives. Once operations are complete the resulting geometric objects are rasterized and the pixel engine colors the resulting pixels. Additional commands to control pixel shading and pixel back end operations may also be included for those operations.

In some embodiments sample command sequence follows the media pipeline path when performing media operations. In general the specific use and manner of programming for the media pipeline depends on the media or compute operations to be performed. Specific media decode operations may be offloaded to the media pipeline during media decode. In some embodiments the media pipeline can also be bypassed and media decode can be performed in whole or in part using resources provided by one or more general purpose processing cores. In one embodiment the media pipeline also includes elements for general purpose graphics processor unit GPGPU operations where the graphics processor is used to perform SIMD vector operations using computational shader programs that are not explicitly related to the rendering of graphics primitives.

In some embodiments media pipeline is configured in a similar manner as the 3D pipeline . A set of media pipeline state commands are dispatched or placed into in a command queue before the media object commands . In some embodiments media pipeline state commands include data to configure the media pipeline elements that will be used to process the media objects. This includes data to configure the video decode and video encode logic within the media pipeline such as encode or decode format. In some embodiments media pipeline state commands also support the use one or more pointers to indirect state elements that contain a batch of state settings.

In some embodiments media object commands supply pointers to media objects for processing by the media pipeline. The media objects include memory buffers containing video data to be processed. In some embodiments all media pipeline states must be valid before issuing a media object command . Once the pipeline state is configured and media object commands are queued the media pipeline is triggered via an execute command or an equivalent execute event e.g. register write . Output from media pipeline may then be post processed by operations provided by the 3D pipeline or the media pipeline . In some embodiments GPGPU operations are configured and executed in a similar manner as media operations.

In some embodiments 3D graphics application contains one or more shader programs including shader instructions . The shader language instructions may be in a high level shader language such as the High Level Shader Language HLSL or the OpenGL Shader Language GLSL . The application also includes executable instructions in a machine language suitable for execution by the general purpose processor core . The application also includes graphics objects defined by vertex data.

In some embodiments operating system is a Microsoft Windows operating system from the Microsoft Corporation a proprietary UNIX like operating system or an open source UNIX like operating system using a variant of the Linux kernel. When the Direct3D API is in use the operating system uses a front end shader compiler to compile any shader instructions in HLSL into a lower level shader language. The compilation may be a just in time JIT compilation or the application can perform shader pre compilation. In some embodiments high level shaders are compiled into low level shaders during the compilation of the 3D graphics application .

In some embodiments user mode graphics driver contains a back end shader compiler to convert the shader instructions into a hardware specific representation. When the OpenGL API is in use shader instructions in the GLSL high level language are passed to a user mode graphics driver for compilation. In some embodiments user mode graphics driver uses operating system kernel mode functions to communicate with a kernel mode graphics driver . In some embodiments kernel mode graphics driver communicates with graphics processor to dispatch commands and instructions.

In one embodiment the one or more system processors program the GPU using GPU specific commands such as those described in . In one embodiment a graphics driver programs commands into the command buffer stored in system memory . In one embodiment one or more processors inform the GPU when the commands are ready to be executed for example via processor specific methods such as the tail register of a rendering ring buffer and or the submission of an execution list. The render engine of the GPU then fetches and executes the commands in the command buffer . The fetch and execution may occur immediately after the processor notifies the GPU that commands in the rendering ring are ready or the fetch may occur at a later point based on GPU internal scheduling or management policy.

In one embodiment the GPU performs a single fetch of all pending commands and instructions uses the GTT for translation and stores the GTT data in an internal cache before beginning to execute the graphics commands. In one embodiment the GPU fetches and executes the instructions based on internal resource availability and may refer to the GTT multiple times for memory translation while processing graphics commands. In one embodiment the GPU rendering engine executes independently of any of the one or more processors and the processors and the GPU should avoid assumptions regarding the execution speed of any other counterpart. The availability of an execution result from either a processor or the GPU should not be assumed absent an explicit synchronization event between a processor and the GPU.

In one embodiment the render engine performs graphics operations based on the commands and outputs rendered data to a render target in memory which is ultimately written to the frame buffer in memory. In one embodiment the one or more processors may perform some operations in parallel with the GPU and output those results to the frame buffer . The display engine then fetches pixel data from the frame buffer and outputs the pixel data to a display.

In some embodiments system memory can be mapped into multiple virtual address spaces by GTT . In one embodiment a 2 GB global virtual address space is accessible from both the GPU and the one or more processors and is mapped through a global page table in the GTT . In one embodiment local graphics memory is supported for the render engine via multiple 2 GB local virtual address spaces.

Although illustrated as separate in one embodiment at least some of the entries in the page table directory of the per process GTT are included in the global GTT .

The embodiments described herein may be virtualized by a GPU virtualization system. The GPU virtualization enables a virtual GPU vGPU within a virtual machine to access the full functionality provided by GPU hardware. The virtual GPU may be presented to multiple guest virtual machines VMs . The guest VMs can access the full array of GPU features and use native GPU driver software to manage virtual graphics processors. The vGPU context is switched per quantum or event where a vGPU of each VM periodically becomes an owner guest. In one embodiment the context switch may happen per GPU rendering engine. The periodic switching allows multiple VMs to share a physical GPU in a manner that is transparent to the users.

In one embodiment the virtual GPU manages graphics memory mapping via guest and shadow graphics translation tables GTT which map graphics processor memory to system memory. Each VM has a guest GTT to translate from the graphics memory page number to the guest memory page number GPN . The shadow GTT entries are translated from the graphics memory page number to a host memory page number HPN . In one embodiment the shadow GTT is shared and maintains the translations for multiple VMs. In one embodiment each VM includes both per process and global GTTs. The GTT synchronization mechanisms described herein may be used to synchronize both global and per process GTTs.

In one embodiment the guest and shadow GTTs are synchronized via a hybrid shadow construction scheme HSCS which implements either a synchronous or asynchronous shadow GTT implementation based on guest GTT access heuristics. In one embodiment during synchronous operation the memory page of a guest GTT is write protected. Each update to the guest GTT causes a write protection trap that is handled by the mediator. A VM mediator handles the trap by performing the corresponding updates to both the shadow GTT and the guest GTT per policy. In one example the guest GTT may be updated with GPN and the shadow GTT may be updated with HPN. In synchronous operation the guest and shadow GTT are kept synchronized even when the guest is not the owner guest. In asynchronous operation the guest GTT is not write protected and the guest may freely update the GTT entries. When the guest VM becomes the owner guest of a certain rendering ring a processor can inform the GPU that commands are ready to execute e.g. through a tail register update . In one embodiment the VMM traps the notification and rebuilds the shadow GTT before submitting the commands. In one embodiment the guest GTT may be allowed to be out of synchronization e.g. operate asynchronously with the shadow GTT until commands are actually submitted to the physical GPU.

In one embodiment the operation of the mediator differs based on the use of a type one or type two hypervisor. For a type two hypervisor hooks may be placed into the driver code for the vGPU to make calls to access functions provided by the mediator . For a type one hypervisor software traps may be used to enable the mediator to provide functionality to the vGPU. It will be understood that where traps or the use of the trap and emulate model is described herein similar functionality may be provided using a type two hypervisor using software hooks in the driver code to access the vGPU mediator . Accordingly embodiments described herein are not limited to any particular type of hypervisor.

In one embodiment a mediated pass through is enabled in which guest VMs can directly access performance critical resources within the GPU without intervention from the VMM . In such embodiment performance critical operations from VMs e.g. render operations can be performed using a pass through call to the GPU . However privileged graphics operations from the VMs are handled using a trap and emulate model in which the VM access triggers a software trap that is routed to the mediator . The mediator can then emulate the trap and perform the corresponding operations on the GPU hardware. In one embodiment configured for a type one hypervisor the mediator emulates the trap via a hypervisor call to the vGPU VMM Module in the VMM which has privileged access to the GPU . In one embodiment configured for a type two hypervisor the mediator emulates the trap and operates the GPU hardware via native driver of host OS where the native drive operates in a privileged mode.

In one embodiment the vGPU context is switched per quantum where each VM periodically becomes an owner guest. This periodic switching allows multiple VMs to share a physical GPU in a manner that is transparent to users of the VM. For example the guest may prepare command buffers and program the virtual GPU s graphics state using when the VM is not the owner guest of GPU. The VMM may submit the prepared command buffers to the GPU when the VMs become the owner guest of vGPU. In one embodiment when a VM is the owner guest the VM commands in the command buffer are provided to a render engine in the GPU e.g. render engine of .

Each native graphics driver of the guest VM and service VM in a type one hypervisor can have a separate guest GTT which includes global and per process GTTs. The mediator using the vGPU device model driver shadows the guest GTTs to the shadow GTT either synchronously with each guest GTT modification or asynchronously before render commands are submitted. In a type two VMM the native graphics driver of host may manage a separate shadow GTT in addition.

Processes executing GPU workloads tend to allocate and free graphics memory in batches which reduces the impact of GTT modifications on the rendering process. Thus the trap and emulate overhead caused by keeping the guest GTT synchronous to the shadow GTT is generally limited. However performance issues may arise in cases where the guest frequently manipulates the GTT. For example some media transcoding benchmarks realize poor virtualization performance due to frequent swapping of graphics memory pages which introduces a large number of GTT modifications.

In one embodiment the mediator includes logic to determine that a guest is performing a number of contiguous GTT page modifications or is performing repeated modifications to the same GTT entry. In one embodiment the logic is to determine a number of GTT page table modifications that exceeds a defined threshold within a period e.g. 500 updates per second . The precise threshold may be dynamically determined in some embodiments. Based on this determination the mediator can remove the write protection on the guest GTT and transition into asynchronous operation in which the guest GTT will be out of synchronization from the shadow GTT until the guest VM commands are ready to be presented to the graphics hardware. In one embodiment the mediator then rebuilds and switches the shadow GTT when a VM becomes an owner guest In one embodiment the mediator rebuilds the shadow GTT to synchronize with the guest GTT when new vGPU commands are to be submitted to the physical GPU.

In one embodiment as shown at a mediator can be configured to detect blocks of GTT modifications at a number and frequency above a determined threshold. In response to the detection the mediator can transition to asynchronous shadow GTT operation. Asynchronous shadow GTT operation can begin at block when the mediator removes the write protection on the guest GTT and allows the GTT to go out of synch with the shadow GTT. For a period of time as shown at block the guest GTT will receive writes from the guest VM. When the guest vGPU is scheduled in e.g. the vGPU context is loaded to the physical GPU and or a new batch of guest vGPU commands are ready to be submitted to the GPU the shadow GTT is reconstructed as shown at . Once the shadow GTT is reconstructed using the guest GTT the guest VM commands can be submitted to the graphics processor as shown at .

As shown in an entire write enabled guest GTT e.g. global GTT or per process GTT of which has been allowed to go out of sync with the existing shadow GTT is used to create a fully reconstructed shadow GTT . In one embodiment the fully reconstructed shadow GTT is re created from scratch when new commands are submitted to the GPU. During the reconstruction each page directory entry or page table entry in the guest GTT is audited to ensure that it references memory that the guest VM is allowed to access.

As shown in a portion of a write enabled guest GTT e.g. global GTT or per process GTT of is used to create a hybrid shadow GTT which uses partial reconstruction where a portion of the shadow GTT pages are synchronized with guest GTT but another portion of shadow GTT are not. The selection of partial reconstruction or full reconstruction may be performed heuristically based on the number of GTT pages the guest modifies at any given time. For example if the number of modified pages of the guest GTT is below a threshold partial reconstruction may be performed in which the dirty bits e.g. modified status indicator bits of the page table entries or page directory entries of the guest GTT may be used to determine which page frame numbers have been modified by the guest VM and only synchronize the shadow GTT pages corresponding with modified guest GTT pages. The partially reconstructed shadow GTT can be created by copying or re using the existing shadow GTT as a base and updating only the GTT entries that are out of synchronization with the guest GTT.

Determining the modified guest pages may be performed using a number of different techniques in addition to using the guest page dirty bits. In one embodiment the modified GTT pages are determined via the guest fault address from a guest VM access to a write protection guest GTT page. In one embodiment the VMM may use a separate data structure e.g. link table hash table linear array to track the list of guest pages in the guest GTT that are allowed to be asynchronous with the shadow GTT and use the data structure to determine which of the modified guest GTT pages to synchronize to corresponding shadow GTT pages and or uses the additional dirty bit to narrow the list of pages to synchronize.

In another embodiment if the number of guest GTT pages allow to be out of synchronization with the shadow GTT is very large and guest GTT pages are not always modified at each time the shadow GTT is reconstructed the dirty bit of an upper level page table may be used to further narrow the process of identifying the GTT pages that are to be updated during the reconstruction of the shadow GTT. As illustrated GPN  and GPN n each have a page table dirty flag set for the page table or page directory entry of the write enabled GTT . Thus the exemplary partially reconstructed shadow GTT can be created by updating the existing shadow GTT with the page frame or page table data contained in the dirty page table entries 

At the mediator determines if all of the selected out of synch pages are to be reconstructed e.g. the entire shadow GTT if full reconstruction is enabled or all of the selected GTT pages if partial reconstruction is enabled . If only dirty pages are to be reconstructed at the mediator can copy or re use the existing selected shadow GTT pages and at block create a sub selection of the selected GTT pages based on the dirty bits in the page table or page directory entries of the guest GTT. If the shadow GTT is to be fully reconstructed a new shadow GTT is created at .

At the new or existing shadow GTT is reconstructed using the selected or sub selected portion of the shadow GTT which can be the entire GTT the previously selected specific GTT pages or the shadow GTT entries associated with the sub selected portion of the guest GTT based on the guest GTT dirty bits. In one embodiment the guest dirty bits are optionally cleared after reconstruction as shown at .

In one embodiment when beginning a transition to synchronous operation as shown at of the mediator determines whether to perform a full transition of the GTT at . If the entire global or per process GTT is to transition to synchronous mode the mediator can transition the entire GTT to synchronous mode at . In one embodiment the full transition triggers a full reconstruction of the associated shadow GTT when completing the transition to synchronous operation at .

In one embodiment a transition to synchronous mode can be performed for less than the entire GTT. For example if the mediator determines at that the transition to synchronous operations was triggered because the number of asynchronous GTT pages exceeds a page number threshold the mediator can select certain GTT pages to transition at . Alternatively as shown at a spontaneous page selection may be performed by the mediator logic for various reasons. For example in one embodiment the age of the asynchronous GTT pages are monitored to determine if the age of the pages exceeds an age threshold. If a certain number of pages are over the age threshold the mediator logic may select all or some of the older pages at to transition to synchronous operation at

The selection of GTT pages at may be performed based on a pre determined policy or based on a dynamic policy that may be modified at runtime. Exemplary logic for to selecting and transitioning individual GTT pages at is included in . At any cached versions of the GTT pages in hardware are flushed and those pages are transitioned to synchronous operation. The mediator may then complete the transition to synchronous operation at . In one embodiment transitioning a subset of GTT pages triggers a partial reconstruction of the associated shadow GTT.

The selection of GTT pages at of begins in one embodiment at of . Logic for to selecting and transitioning individual GTT pages includes initializing a page pointer at . The page pointer may be a register or memory address that is initialized to the top of a NULL terminated list of asynchronous GTT pages maintained by the mediator. An initial NULL check may be performed at before traversing the list where a NULL list causes the mediator to signal completion of the list at . If the list is not NULL for each element of the list the mediator may select a page in the list of asynchronous GTT pages at and determine if the page is a candidate to exit asynchronous mode at . In one embodiment the determination at is performed by analyzing metadata for the GTT page to determine a frequency of access for the page or the length of time in which the page has been in asynchronous mode or the number of VM schedule cycles since the page was last modified. In one embodiment if the page is frequently or recently accessed the mediator may determine that the page is not an exit candidate at . The mediator may then select the next page in the list at . Alternatively if the page is an exit candidate at the mediator may exit the selected page from the asynchronous mode and remove the page from the list of asynchronous pages at before selecting the next page in the list at . In one embodiment when the list is fully traversed the next page in the list selected at will be NULL. Accordingly the NULL list determination at will cause the mediator to signal completion of the list at . The mediator may then complete the transition to synchronous operation for the selected GTT at in .

In one embodiment a first VM guest GTT includes a set of guest page numbers including GPN A that are continuously synchronized with an associated set of host page numbers including HPN A such that GPN A and HPN A continuously points to the same page frame e.g. Page Frame A in system memory . In one embodiment the shared shadow GTT also includes a set of host page numbers including HPN B that are not synchronized e.g. asynchronous with their associated guest page numbers in a second VM guest GTT including GPN B . Accordingly in one embodiment HPN B and GPN B do not point to the same page frame e.g. Page Frame B in system memory until the guest VM e.g. vGPU rendering engine of the guest VM commands are submitted to the GPU.

Notwithstanding the mechanism in which guest GTT writes are emulated if the mediator detects frequent guest GTT modifications to a portion of the guest GTT at the mediator can configure asynchronous operation for the portion of the guest GTT at allowing the guest to write to the guest GTT without mediator emulation. In one embodiment as shown at the synchronization logic includes registers cache memory or data structures in system memory to track the portion of the guest GTT that is not write protected or is otherwise operating asynchronously from the shadow GTT. As shown at the synchronization logic reconstructs the relevant portion of the shadow GTT based on the tracked portion of the guest GTT that is asynchronous with the shadow GTT before submitting commands to the GPU hardware.

In one embodiment the at least a portion of the guest GTT may be allowed to be out of synch with its associated portion of the shadow GTT until hardware commands are submitted. However the GTT should be properly synchronized before commands are submitted to hardware or execution of the GPU commands may fail. Where the GPU hardware is configured to cache the GTT pages the GPU hardware may cache the relevant GTT pages in hardware while executing graphics commands.

In one embodiment as shown in and the modified status indicator bits e.g. dirty bits of the asynchronous portion of the guest GTT are used to determine the changed elements of the asynchronous portion of the guest GTT. In such embodiment only those guest GTT elements that have actually changed are used to reconstruct the portion of the shadow GTT allowing the existing shadow GTT to be used as a basis for construction of the new shadow GTT.

Various embodiments may be implemented using hardware elements software elements or a combination of both. Examples of hardware elements may include processors microprocessors circuits circuit elements e.g. transistors resistors capacitors inductors and so forth integrated circuits application specific integrated circuits ASIC programmable logic devices PLD digital signal processors DSP field programmable gate array FPGA logic gates registers semiconductor device chips microchips chip sets and so forth. Examples of software may include software components programs applications computer programs application programs system programs machine programs operating system software middleware firmware software modules routines subroutines functions methods procedures software interfaces application program interfaces API instruction sets computing code computer code code segments computer code segments words values symbols or any combination thereof. Determining whether an embodiment is implemented using hardware elements and or software elements may vary in accordance with any number of factors such as desired computational rate power levels heat tolerances processing cycle budget input data rates output data rates memory resources data bus speeds and other design or performance constraints.

One or more aspects of at least one embodiment may be implemented by representative instructions stored on a machine readable medium which represents various logic within the processor which when read by a machine causes the machine to fabricate logic to perform the techniques described herein. Such representations known as IP cores may be stored on a tangible machine readable medium and supplied to various customers or manufacturing facilities to load into the fabrication machines that actually make the logic or processor.

Embodiments are applicable for use with all types of semiconductor integrated circuit IC chips. Examples of these IC chips include but are not limited to processors controllers chipset components programmable logic arrays PLAs memory chips network chips and the like. In addition in some of the drawings signal conductor lines are represented with lines. Some may be different to indicate more constituent signal paths have a number label to indicate a number of constituent signal paths and or have arrows at one or more ends to indicate primary information flow direction. This however should not be construed in a limiting manner. Rather such added detail may be used in connection with one or more exemplary embodiments to facilitate easier understanding of a circuit. Any represented signal lines whether or not having additional information may actually comprise one or more signals that may travel in multiple directions and may be implemented with any suitable type of signal scheme e.g. digital or analog lines implemented with differential pairs optical fiber lines and or single ended lines.

Example sizes models values ranges may have been given although embodiments are not limited to the same. As manufacturing techniques e.g. photolithography mature over time it is expected that devices of smaller size may be manufactured. In addition well known power ground connections to IC chips and other components may or may not be shown within the figures for simplicity of illustration and discussion and so as not to obscure certain aspects of the embodiments. Further arrangements may be shown in block diagram form in order to avoid obscuring embodiments and also in view of the fact that specifics with respect to implementation of such block diagram arrangements are highly dependent upon the platform within which the embodiment is to be implemented i.e. such specifics should be well within purview of one skilled in the art. Where specific details e.g. circuits are set forth in order to describe example embodiments it should be apparent to one skilled in the art that embodiments can be practiced without or with variation of these specific details. The description is thus to be regarded as illustrative instead of limiting. Moreover aspects described in association with one embodiment may be combined with other embodiments described herein.

Some embodiments may be implemented for example using a machine or tangible computer readable medium or article which may store an instruction or a set of instructions that if executed by a machine may cause the machine to perform a method and or operations in accordance with the embodiments. Such a machine may include for example any suitable processing platform computing platform computing device processing device computing system processing system computer processor or the like and may be implemented using any suitable combination of hardware and or software.

Unless specifically stated otherwise it may be appreciated that terms such as processing computing calculating determining or the like refer to the action and or processes of a computer or computing system or similar electronic computing device that manipulates and or transforms data represented as physical quantities e.g. electronic within the computing system s registers and or memories into other data similarly represented as physical quantities within the computing system s memories registers or other such information storage transmission or display devices. The embodiments are not limited in this context.

The term coupled may be used herein to refer to any type of relationship direct or indirect between the components in question and may apply to electrical mechanical fluid optical electromagnetic electromechanical or other connections. In addition the terms first second etc. may be used herein only to facilitate discussion and carry no particular temporal or chronological significance unless otherwise indicated.

As used in this application and in the claims a list of items joined by the term one or more of may mean any combination of the listed terms. For example the phrases one or more of A B or C may mean A B C A and B A and C B and C or A B and C.

It will be understood that multiple types of hypervisors are described herein including hosted e.g. type two or bare metal e.g. type one hypervisors. The techniques described are not limited to any particular type form or model of hypervisor and can be applied to virtual GPUs enabled via type one type two or any form of hybrid hypervisor.

In embodiments described herein are systems methods and an apparatus to manage virtual machines. In one embodiment the apparatus includes a graphics processor coupled to a virtual machine monitor VMM to present a virtual graphics processor to a first virtual machine and a mediator for the virtual graphics processor to synchronously shadow modifications to a guest graphics translation table GTT of a first virtual machine to a shadow GTT of the VMM. The mediator may also be configured to detect a frequency of modifications to the first guest GTT exceeds a threshold and in response to the detection asynchronously shadow at least a portion of the first guest GTT to the shadow GTT. While the mediator may be configured in one embodiment to detect a frequency of modifications above a threshold the mediator may also be configured to detect a number of contiguous modifications above a threshold or a number of repeated modifications to the same region of the GTT.

One or more aspects of at least one embodiment may be implemented by representative data stored on a machine readable medium which represents various logic within the processor which when read by a machine causes the machine to fabricate logic to perform the techniques described herein. Such representations known as IP cores may be stored on a tangible machine readable medium tape and supplied to various customers or manufacturing facilities to load into the fabrication machines that actually make the logic or processor. For example IP cores such as the Mali family of graphics solutions developed by ARM Holdings Ltd. and Loongson IP cores developed the Institute of Computing Technology ICT of the Chinese Academy of Sciences may be licensed or sold to various customers or licensees such as Texas Instruments Qualcomm Apple or Samsung and implemented in processors produced by these customers or licensees.

The development of such IP codes includes the use of simulation software or hardware that may be used to model specific embodiments GPU hardware described herein. Data representing the IP core design may be provided to a fabrication facility where it can be fabricated by a 3party to functionality associated with the described embodiments.

Those skilled in the art will appreciate from the foregoing description that the broad techniques of the embodiments can be implemented in a variety of forms. Therefore while the embodiments have been described in connection with particular examples thereof the true scope of the embodiments should not be so limited since other modifications will become apparent to the skilled practitioner upon a study of the drawings specification and following claims.

