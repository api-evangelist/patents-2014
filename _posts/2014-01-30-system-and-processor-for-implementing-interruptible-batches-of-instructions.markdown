---

title: System and processor for implementing interruptible batches of instructions
abstract: A system, method, and computer program product are provided for scheduling interruptible hatches of instructions for execution by one or more functional units of a processor. The method includes the steps of receiving a batch of instructions that includes a plurality of instructions and dispatching at least one instruction from the batch of instructions to one or more functional units for execution. The method further includes the step of receiving an interrupt request that causes an interrupt routine to be dispatched to the one or more functional units prior to all instructions in the batch of instructions being dispatched to the one or more functional units. When the interrupt request is received, the method further includes the step of storing batch-level resources in a memory to resume execution of the batch of instructions once the interrupt routine has finished execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477480&OS=09477480&RS=09477480
owner: NVIDIA Corporation
number: 09477480
owner_city: Santa Clara
owner_country: US
publication_date: 20140130
---
The present invention relates to processor architectures and more particularly to processors capable of processing interruptible batches of instructions.

Many of the conventional multi threaded processors on the market today include hardware scheduling units that arbitrate issuing instructions to be executed among a plurality of active threads. The scheduling unit determines whether the next instruction for each thread has any dependencies that have not been resolved and among all threads having a next instruction with no unresolved dependencies selects one thread and issues the next instruction from the thread. Such arbitration is conducted one instruction at a time.

For power reasons it could be beneficial to resolve dependencies for multiple instructions at a time and then issue the multiple instructions in a batch. Such operation may be beneficial because the batch of instructions will typically be executed in a fewer number of clock cycles than if dependencies are resolved and instructions are issued one at a time. For example latency related to fetching operands from a memory may be resolved at the beginning of the batch instead of spreading out the latency throughout the execution of the batch. This may allow for more efficient power savings techniques or allow more efficient use of resources by other active threads. Additional power savings may be realized by reducing the frequency that the scheduler executes e.g. once per batch of instructions rather than once per instruction utilizing low power pipeline resources e.g. register file bypass temporary pipeline storage etc. and other such power saving techniques.

One issue with issuing batch instructions in this manner however is that the batch of instructions may be interrupted after the batch has been scheduled for execution but before each instruction in the batch has been issued and committed by the associated pipeline. Interrupt routines may be necessary to implement breakpoints in a debugger single stepping through instructions in a debugger floating point exceptions instruction replays memory addressing faults memory breakpoints tolerance of compiler bugs cache misses pre emption and other capabilities that require interruption of a batch of instructions. It will be appreciated that batches may be interrupted for reasons other than the service of interrupt routines for example batches may be interrupted to perform a memory access in response to a cache miss or to service a floating point exception. Resources reserved for the batch of instructions e.g. registers in a register file may be allocated to execute the interrupt routine. Conventional processor architectures are not configured to implement schedulers that are capable of issuing batches of instructions while also enabling those batches of instructions to be interrupted. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for scheduling interruptible hatches of instructions for execution by one or more functional units of a processor. The method includes the steps of receiving a batch of instructions that includes a plurality of instructions and dispatching at least one instruction from the batch of instructions to one or more functional units for execution. The method further includes the step of receiving an interrupt request that causes an interrupt routine to be dispatched to the one or more functional units prior to all instructions in the batch of instructions being dispatched to the one or more functional units. When the interrupt request is received the method further includes the step of storing batch level resources in a memory to resume execution of the batch of instructions once the interrupt routine has finished execution.

A processor includes a scheduler unit that is configured to enable batches of instructions to be interrupted by various interrupt routines and or pre empted by the execution of instructions from other threads. In the context of the present description a batch of instructions is a sequence of instructions for one or more threads that access particular batch level resources such as temporary registers or are associated with certain scheduling constraints such as instructions that take advantage of register file bypass signals. Bypass values are values that are generated by one functional unit for input into another functional unit without being intermediately stored in a register file. Temporary values may be special registers associated with a functional unit that hold temporary values for subsequent instructions. In one embodiment the scheduler unit allocates a particular portion of the register file i.e. a backing store to a batch of instructions for storage of the batch level resources when a batch is interrupted. The particular portion of the register file is not re allocated until the batch has finished execution. It will be appreciated that in other embodiments a different backing store may be used to store batch level resources than the register file.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 hit data buses or the like for high speed data transfer. In one embodiment the PPU comprises memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the 12 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

At least some of the threads may include one or more batches of instructions. Again a batch of instructions is a sequence of instructions for one or more threads that access particular batch level resources such as temporary registers or are associated with certain scheduling constraints such as instructions that take advantage of register file bypass signals. Power savings may be realized when certain groups of instructions are executed together. For example power savings may be realized when a group of arithmetic instructions is batched together by first loading operands for the instructions into the register file and then executing the arithmetic instructions only once all of the dependencies for the instructions have been resolved. Execution may be more efficient as the hatch of instructions is not repeatedly stalled during execution of some instructions while other instructions wait for dependencies to be resolved.

In operation the scheduler unit may tag a batch of instructions from a thread as ready to be issued after the scheduler unit has ensured that dependencies for each of the instructions in the batch of instructions have been resolved. When a program counter for a thread points to a first instruction in the batch of instructions the scheduler unit allocates a portion of the registers in the register file for the batch of instructions. The portion of the registers serves as a temporary storage for batch level resources associated with the batch of instructions.

After the scheduler unit allocates the portion of the registers to a batch of instructions the scheduler unit monitors the batch of instructions to ensure that any dependencies for the instructions have been resolved. Such dependencies may be e.g. resolved by having values loaded from the memory into the register file or by having values written into the register file by one or more of the functional units of the SM . Once the dependencies for the instructions have been resolved the batch of instructions is tagged as ready to be issued. The scheduler unit may then arbitrate between multiple threads selecting instructions from one or more batches of instructions that are ready to be issued to be dispatched to the functional units of the SM . In one embodiment the scheduler unit issues one instruction during each clock cycle selecting an instruction from the same batch of instructions or other batches of instructions during each successive clock cycle. In another embodiment the scheduler unit may be configured to issue two or more instructions from a given batch of instructions in successive clock cycles.

The batch of instructions may be interrupted by other routines during execution. When the batch of instructions is interrupted any batch level resources associated with the batch of instructions are stored in the portion of the registers allocated to the batch. For example some instructions in the batch of instructions may implement chained operations. In a chained operation the output of one functional unit may be connected to the input of another functional unit via the interconnect network . In conventional processors the intermediate output is not stored in the register file but instead is consumed immediately by the next functional unit. However when a batch of instructions implementing a chained operation is interrupted the next functional unit in the chained operation may be reserved for use by an instruction in the interrupt routine meaning the transitory intermediate output value is lost. In one embodiment in order to not lose transitory values when batches of instructions are interrupted all outputs of the functional units are mirrored and stored in the portion of the registers allocated to the corresponding batch of instructions even if the output from the functional unit is coupled to the input of another functional unit for immediate consumption. In one embodiment the output values may be stored in the portion of the registers and may also be provided to the inputs of another functional unit in a single clock cycle. In another embodiment the outputs of the functional units may also be stored out to a backing store such as memory .

In some use cases various interrupt points within the batch of instructions may be known before execution. For example breakpoints and single stepping capabilities of debuggers implemented by a compiler are known when the batch of instructions is compiled into a machine executable code for execution. In such cases the compiler may transcode batches of multiple instructions into multiple single instruction batches where any batch level resources generated by the instructions are stored in the portion of the registers allocated to the batch of instructions. This transcoding may reduce performance and or increase power consumption of these batches of instructions by requiring the batch level resources to be written to the register file rather than being used directly within the functional unit for subsequent instructions. However such reductions in performance may be inconsequential to a user due to specific use cases such as when running a debugger e.g. a developer does not care that subsequent instructions are stalled when single stepping through a program or implementing breakpoints within a program being simulated by the debugger .

In some embodiments when the scheduler unit begins executing a batch of instructions the scheduler unit does not allocate the portion of the registers to the batch of instructions. Instead the scheduler unit only allocates the portion of the registers when an interrupt occurs. As the scheduler unit dispatches one or more instructions from the batch of instructions to the functional units an interrupt may occur e.g. such as a floating point exception that causes the scheduler unit to prioritize execution of an interrupt routine over instructions from the batch of instructions. At this point the scheduler unit may allocate the portion of the registers in the register file for the batch of instructions. Batch level resources may be written to the portion of the registers associated with the batch of instructions being executed. In contrast to the previous embodiment in which the portion of the registers is allocated immediately before execution of the batch of instructions is commenced the scheduler unit is configured to allocate registers for temporary storage of the batch level resources in a just in time manner. In yet another embodiment the scheduler unit may not allocate storage for batch level resources in the register file because the resources in the register file may be required for executing the interrupt routine. In such cases the batch level resources may be stored in the memory by writing the batch level resources to the shared memory L1 cache . These batch level resources can then be loaded from the memory via the shared memory L1 cache back into the register file and then ultimately back into the special registers in one or more functional units for execution of the remainder of the instructions in the batch of instructions.

At step the scheduler unit receives an interrupt request. In one embodiment the scheduler unit receives the interrupt request directly and proceeds to dispatch instructions from a particular interrupt routine associated with the interrupt request to the one or more functional units. In another embodiment the interrupt request causes another unit within the PPU or a host processor to transmit one or more instructions included in the interrupt routine to the scheduler unit . The instructions associated with the interrupt routine may have a higher priority than the instructions associated with the first batch of instructions that causes the scheduler unit to select instructions from the interrupt routine for dispatch to the one or more functional units instead of instructions from the batch of instructions. At step the scheduler unit stores a first set of batch level resources in the allocated portion of the registers .

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

