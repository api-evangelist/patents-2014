---

title: Managing user informationâ€”background processing
abstract: Systems, methods, and computer-readable medium are provided for managing user information. For example, subscription information may be received from an application that identifies a data type associated with information of a user. The application may be launched as a background process at least in response to receipt of a portion of the information that corresponds to the data type. In some examples, the application may be relaunched as the background process at least until receipt of a confirmation that the application has processed the portion of the information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582642&OS=09582642&RS=09582642
owner: Apple Inc.
number: 09582642
owner_city: Curpertino
owner_country: US
publication_date: 20140929
---
The present application claims the benefit of U.S. Provisional Application No. 62 006 031 filed May 30 2014 entitled Managing User Information by Keen et al. Ref. No. P23418USP1 which is hereby incorporated by reference for all purposes. The present application is also related to Provisional Application Ser. No. 62 006 062 filed May 30 2014 entitled Wellness Aggregator by Kennedy et al. the entire contents of which is hereby incorporated by reference as if fully set forth herein under 35 U.S.C. 120. The present application is also related to Non Provisional application Ser. No. 14 499 449 filed on the same day herewith entitled Managing User Information Authorization Masking by Keen et al. Non Provisional application Ser. No. 14 499 512 filed on the same day herewith entitled Managing User Information Data Type Extension by Keen et al. and Non Provisional Application Serial No. 14 499 519 filed on the same day herewith entitled Managing User Information Source Prioritization by Keen et al. the entire contents of each are hereby incorporated by reference as if fully set forth herein under 35 U.S.C. 120.

People are becoming more and more aware of the importance of regular exercise for maintaining one s health. Additionally a plethora of electronic devices are now available that can track a person s physical activity throughout the day. Such devices can connect or otherwise communicate with other mobile devices for example to help track manage and or analyze data associated with the person s physical activity. However health and activity data continues to be considered extremely personal and often times confidential. As such developers and device manufacturers continue to identify challenges when providing applications and or devices for collecting and sharing a user s health information.

Embodiments of the present disclosure can provide systems methods and computer readable medium for managing user information e.g. personal information collected by one or more external devices . In some examples a data interchange may be managed that enables and or allows third party applications to provide user information to the data interchange and potentially retrieve user information provided by other third party applications. While managed the data interchange may be configured to provide access to particular data types of the user data based at least in part on authorization from the user associated with the data.

According to one embodiment a method may be executed by a computer system to at least maintain a secure storage configured to store health data corresponding to a plurality of data types. The method may also cause the computer system to receive from a third party application a subscription to at least one data type of the plurality of data types and a frequency associated with the subscription. The computer system may receive a portion of the health data corresponding to the at least one data type. The method may also cause the computer system to launch the third party application as a background process based at least in part on the frequency associated with the subscription and set a trigger to relaunch the third party application as the background process within a time period. In some examples the computer system may cancel the trigger to relaunch the third party application when confirmation that the third party application has processed the portion of the health data is received within the time period or relaunch the third party application as the background process when the confirmation is not received from the third party application within the time period.

In some cases the portion of the health data corresponding to the at least one data type may be received from an application associated with a data collection device. The frequency may be configured by the third party application. In some examples the frequency may identify an amount of time between receipt of the portion of the health data and launching the third party application as the background process. Additionally the third party application may be launched without a request from a data collection device or the third party application. The time period may be configured to be increased for each relaunching of the third party application and the increase may be exponential to a threshold amount of time.

According to another embodiment a system may be implemented as a computing device configured with a memory and a processor. The processor may be configured to execute instructions stored on the memory to configure the memory to receive subscription information from an application that identifies a data type associated with information of a user. The processor may also be configured to execute the instructions to launch the application as a background process at least in response to receipt of a portion of the information that corresponds to the data type and relaunch the application as the background process at least until receipt of a confirmation that the application has processed the portion of the information.

In some examples the application may be enabled to request the received portion of the information while running as the background process. The application may also be enabled to process the received portion of the information and return the confirmation that the application has processed the portion of the information while running as the background process. The subscription information may identify the data type and a frequency associated with the subscription and the frequency may identify an amount of time between the receipt of the portion of the information and launching the application as the background process. In some cases the processor may be further configured to execute the computer executable instructions to at least relaunch the application as the background process based at least in part on a time interval when the confirmation is not received within the time interval. The time interval may be increased after each relaunch of the application as the background process.

According to another embodiment a computer readable medium may include instructions that when executed configure a computer processor to store first data of a plurality of data types for a user. The instructions may further configure the processor to receive from a first application a subscription to at least one of the plurality of data types and or receive from a second application second data of the plurality of data types. The instructions may also configure the processor to launch the first application as a background process after a first time period when the subscription corresponds to the second data. The first application may also be relaunched as the background process after a second time period when no confirmation that the first application has processed the second data within the second time period is received.

In some examples the first application may be a third party application configured to process health information associated with the plurality of health data types. The second application may be configured to receive the second data from a data collection device configured to collect health information of the user. Additionally the first application may be launched and or relaunched as the background process without receipt of an instruction from the data collection device or the first application to launch or relaunch the first application. The first application may be configured to request the second data while launched or relaunched as the background process. The first time period may be configurable by the first application and the second time period may change by a configurable amount after each relaunch of the first application as the background process.

In the following description various examples will be described. For purposes of explanation specific configurations and details are set forth in order to provide a thorough understanding of the examples. However it will also be apparent to one skilled in the art that the examples may be practiced without the specific details. Furthermore well known features may be omitted or simplified in order not to obscure the example being described.

Examples of the present disclosure are directed to among other things managing personal information from external sources or other remote peripheral device of a user. In some examples the information collected by the data collection devices may be provided to a user device e.g. a mobile phone a tablet computer a laptop computer a wearable computing device etc. and or one or more first party or third party applications of the user device. In some examples a first party application may be one that is provided with the operating system O S of the user device is configured to operate natively with the user device provided by the developers of the O S for use with the user device and or trusted by the O S and or device. Alternatively a third party application may be one that is provided by a third party or entity other than the developer manufacturer of the user device and or it s O S. Additionally in some non limiting examples the information being collected and or managed may be health fitness and or activity information of the user e.g. blood glucose levels weight height calories burned heart rate etc. . The user information may be categorized or otherwise identified by one or more data types or categories . Weight number of steps walked number of calories burned heart rate etc. are each an example of a data type. Other data types e.g. outside of health information are also envisioned including but not limited to hours worked hourly rate miles per hour pages read per minute etc.

In some cases a first party application framework may be executed on a user device that is configured to receive store manage and or provide such user information to a service provider to third party applications to other first party applications and or to local storage of the user device. As part of the first party framework a first party process may be executed by processors of the user device. The first party process may include but is not limited to a daemon or other background process configured to communicate with the third party applications the O S of the user device and or electronic storage of the user device. In some instances first party process may be configured to manage a data interchange for sharing some user data with third party applications. In this way the first party process may enable third party applications to access user information that was initially provided by the third party application a first party application or other third party applications. However as noted health information of a user may be considered extremely personal and or confidential thus the user may be given the ability to protect or otherwise not share some of the heath information with some any or all of the third party applications even the ones that provided the health information to the first party process initially . As such each third party application may be instructed to request authorization for accessing particular or all data types from the data interchange.

In some examples when a third party application requests authorization to access one or more data types of a user s information the first party process may be configured to mask whether the user has granted the authorization request. In other words the third party application may not be able to identify whether the user has granted authorization or whether the user has not entered data for that data type. In some examples this masking may be implemented by providing the same response e.g. an empty or null result in either case. That is the first party process may instead indicate to the third party application that the authorization request was provided to the user and not indicate the user s response. Thus if the user has not provided a data entry for the weight data type the third party application may receive a null result when attempting to retrieve that data type. Similarly if the use has provided their weight but has not authorized access to the third party application when the user s weight is requested the first party process may also provide a null or empty result even though a data entry for that data type exists .

In other examples third party applications may be able to subscribe to certain data types and the first party process may be configured to automatically wake up the third party application e.g. in the background and ensure that the third party application is able to process the data. For example a third party application of the user may subscribe to a blood pressure data type and indicate an associated subscription frequency. Based at least in part on that frequency when a new blood pressure reading is received by the first party process the process may wake up the appropriate third party application background provided with the new data and provide it with the updated data. The process may then wait for confirmation that the third party application has processed the data. If the process does not receive the confirmation within a specified time the process may again launch the third party application provide the data and wait for confirmation. In this way the process can ensure that the third party application receives the data even if the user has not explicitly requested it.

In at least some aspects a plug in framework may be utilized to implement data types that are initially available for use by the first party process and or registered third party applications. Plug ins of the plug in framework may register new data types that adhere to different identifiers so they can store their own data in the database automatically. In some examples the plug ins may be implemented as code that can read application programming interface API method calls with identifiers and or strings associated with the data types. Further by utilizing an asset download a service provider may enable the addition of new data types not initially provided with the first party process e.g. on demand . As such the service provider may identify one or more data types not initially implemented within the first party framework that are being requested by users developers. The service provider may publish information about the new data type and or how to utilize it. Additionally the service provider may provide data to the user device for the first party process to interpret. Once interpreted and registered with the process the plug ins may be utilized to implement these new data types.

In other examples multiple different third party applications e.g. each in communication with a data collection device may provide user data to the first party process. For example a step counter may provide data to an associated third party application. This third party application may provide step information to the first party process. Additionally the user may utilize a second type of data collection device that also provides step information about the user to a different third party application. In this case the user may be enabled to provide priority information to the process such that the process is able to aggregate the step information from the two sources in a meaningful way. The data may be aggregated from a statistical perspective e.g. to determine the actual number of steps walked by the user and or the data may be aggregated to provide a user interface UI that helps the user visualize the number of steps they walked. In some cases the priority information may identify which data e.g. from which source to use when there are multiple data entries for the same point in time. In some examples the source with the highest priority may be rendered when there is overlap in cumulative data e.g. steps walked are cumulative because they can be summed to a total . In other examples discrete data may be collected and presented in a way that shows the multiple different data entries for each point in time. For example weight is an example of a discrete data type because one s weight would not be summed over the day to determine a total weight.

In some examples the first party process may be configured to manage e.g. store retrieve encrypt etc. user data via a database of the user device . As part of the first party application framework the database may be divided or otherwise logically separated into a plurality of classes of data stores. For example the user data may be stored in at least one of a class A data store a class B data store a class C data store and or a class D data store. In some examples the class A data store may be configured to store personally identifiable user information e.g. personal health fitness or activity data . In some examples this data is only available to the third party application when the user device is unlocked. By way of example only the user device may be unlocked when the user associated with the user device has correctly entered his or her user identifier ID and password e.g. when logging in and or unlocking the lock screen . In some aspects the class B data store may be configured to store journal type data. Journal data may include but is not limited to personally identifiable user information and or other metrics associated with use of one or more data collection devices and or the third party application . When the user device is locked the journal data of the class B data store may be inaccessible to the third party application . However in some examples data from a data collection device or an application e.g. the third party application may be read from or written to the class B data store by the first party process while the device is locked as long as the first party process is active. If however the first party process fails or otherwise becomes inactive in the process of reading or writing data to the class B data store the data may become permanently inaccessible and new data may not be written to the class B data store until the first party process and or a new session of the third party application have relaunched. In this way the data of the class B data store remains securely accessible because it is only accessible to the first party process while receiving data from a third party application during the active session and no other applications can read that data.

In some aspects the class C data store may be configured to store metadata associated with the management of the user health fitness and or activity data. This metadata in some cases may only be accessible after the first unlock of the user device . As such if the user device reboots based at least in part on a software issue or a loss of battery power this data may not be available until the user unlocks at least once. In some aspects this may prevent jailbreaking or other hacking techniques from accessing this data. The metadata stored in the class C data store may include subscription information access permission information and or safe metadata but may not in some examples identify or be directly associated with any health information e.g. the data stored in the class A data store . The class D data store may be configured to store free form e.g. unstructured information provided by the user. In some examples this may be health data however it may not be updatable and or linked to any third party applications e.g. the third party application or data collection devices. The class D data may always be available to the first party process and or the third party application . In some aspects the class D data may be pre filled using information from the third party application and or one or more other applications or processes. However the user may be able to enter additional data update the data include incorrect data or otherwise configure the information in the class D data store as they see fit. The class D data may be available on the lock screen of the user device without anyone e.g. the user logging in or otherwise unlocking the user device . In this way the lock screen or another accessible screen of the user device may be analogous to a medical ID bracelet. In some cases an emergency icon or other function on the lock screen may enable the presentation or rendering of the class D data upon request for anyone e.g. an emergency medical technician or the like to see. Further in some aspects the third party application may not have access to the class D data in part because it may be unstructured data that would be difficult for the third party application to process.

The database may be configured to store data of various different data types. For example the database may store data corresponding to data type A and or data type B . In some examples only certain data types may be accessed by certain applications. Thus some data types may be read only for certain applications inaccessible to other applications yet fully accessible to yet other applications. The database may be configured to store at least the following data types weight steps blood pressure heart rate tobacco glucose levels others described herein or the like. In one non limiting example the first party process may have read and write access to both data type A and data type B . However the third party application may only have write access to data type B . Additionally while the third party application may only be able to read data type A it may have both read and write access to data type B . Further in some examples the third party application may only be able to read data type B . However any of these examples may be updated changed or otherwise configured by the user and or by the first party process . As noted the metadata that identifies which application has which type of access to which data type may be stored in the class C data store of .

In some examples the networks may include any one or a combination of many different types of networks such as cable networks the Internet wireless networks cellular networks satellite networks other private and or public networks or any combination thereof. While the illustrated example represents the user device accessing the service provider computers via the networks the described techniques may equally apply in instances where the user device interacts with the service provider computers over a landline phone via a kiosk or in any other manner. It is also noted that the described techniques may apply in other client server arrangements as well as in non client server arrangements e.g. locally stored applications peer to peer configurations etc. .

As noted above the user device may be configured to manage a data interchange for reading and or writing user data to the database and for sharing that user data among one or more authorized third party applications. In some examples the data collection device may be configured to provide health fitness activity and or medical data of the user to a third or first party application or process . In turn this data may be shared aggregated and or accessed via the first party framework module that may be configured to implement the first party application framework of . The user device may be any type of computing device such as but not limited to a mobile phone a smartphone a personal digital assistant PDA a personal computer e.g. laptop or desktop a thin client device a tablet computer an electronic book e book reader a wearable device etc. In some examples the user device may be in communication with the service provider computers and or the data collection device via the networks or via other network connections.

In one illustrative configuration the user device may include at least one memory and one or more processing units or processor s . The processor s may be implemented as appropriate in hardware software e.g. computer executable instructions firmware etc. or combinations thereof. Computer executable instruction or firmware implementations of the processor s may include machine executable instructions written in any suitable programming language to perform the various functions described. The user device may also include geo location devices e.g. a global positioning system GPS device or the like for providing and or recording geographic location information associated with the user device .

The memory may store program instructions that are loadable and executable on the processor s as well as data generated during the execution of these programs. Depending on the configuration and type of user device the memory may be volatile e.g. random access memory RAM and or non volatile e.g. read only memory ROM flash memory etc. . The user device may also include additional removable storage and or non removable storage including but not limited to magnetic storage optical disks etc. The disk drives and their associated non transitory computer readable media may provide non volatile storage of computer readable instructions program modules data structures and other data for the computing devices. In some implementations the memory may include multiple different types of memory such as RAM static random access memory SRAM dynamic random access memory DRAM or ROM. While the volatile memory described herein may be referred to as RAM any volatile memory e.g. that does not maintain data stored therein once unplugged from a host and or power would be appropriate.

The memory and the additional storage both removable and non removable are all examples of non transitory computer readable storage media. For example non transitory computer readable storage media may include volatile or non volatile removable or non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. The memory and the additional storage are all examples of non transitory computer storage media. Additional types of computer storage media that may be present in the user device may include but are not limited to phase change RAM PRAM SRAM electrically erasable programmable read only memory EEPROM flash memory compact disc read only memory CD ROM digital video disc DVD magnetic cassettes or tape magnetic disk storage or any other medium that can be used to store the desired information and that can be accessed by the user device . Combinations of any of the above should also be included within the scope of non transitory computer readable media. Alternatively computer readable communication media may include computer readable instructions program modules or other data transmitted within a data signal such as a carrier wave or other transmission. However as used herein computer readable storage media does not include computer readable communication media.

The user device may also contain communications connection s that allow the user device to communicate with a data store e.g. the database or another computing device via the networks . The user device may also include I O device s such as a keyboard a mouse a pen a voice input device a touch input device a display speakers etc.

Turning to the contents of the memory in more detail the memory may include an operating system and or one or more application programs or services for implementing the features disclosed herein including an authorization module a background module an extension module and or an aggregation module . In some examples the authorization module may be configured to manage authorization requests from third party applications for access of user data stored in the database e.g. class A data of . The authorization module may also be configured to mask when a user denies authorization to a third party application for a particular data type. In this way the third party application may not be able to infer anything about the user based at least in part on the denial. The background module may be configured to launch and or relaunch third party applications in as background process. In some examples the background module may also be configured to verify that the third party application has finished processing the data it requested by continuing to relaunch the third party application in the background until notification is received that the third party application has completed processing. The extension module may be configured to handle registering new data types with the first party framework module in order to extend the functionality of the first party application framework of . Further the aggregation module may be configured to aggregate or otherwise combine and in some examples provide presentation for user data received from multiple different data sources.

The service provider computers may also be any type of computing device such as but not limited to a mobile phone a smartphone a PDA a personal computer a thin client device a tablet computer an e book reader a wearable device etc. In some examples the service provider computers may be in communication with the user device and or the data collection device via the networks or via other network connections.

In one illustrative configuration the service provider computers may also include at least one memory and one or more processing units or processor s . The processor s may be implemented as appropriate in hardware computer executable instructions firmware or combinations thereof. Computer executable instruction or firmware implementations of the processor s may include computer executable or machine executable instructions written in any suitable programming language to perform the various functions described.

The memory may store program instructions that are loadable and executable on the processor s as well as data generated during the execution of these programs. Depending on the configuration and type of service provider computer the memory may be volatile such as RAM and or non volatile such as ROM flash memory etc. . The service provider computer may also include additional removable storage and or non removable storage including but not limited to magnetic storage optical disks and or tape storage. The disk drives and their associated non transitory computer readable media may provide non volatile storage of computer readable instructions data structures program modules and other data for the computing devices. In some implementations the memory may include multiple different types of memory such as SRAM DRAM or ROM. While the volatile memory described herein may be referred to as RAM any volatile memory that would not maintain data stored therein once unplugged from a host and or power would be appropriate. The memory and the additional storage both removable and non removable are all examples of non transitory computer readable storage media.

The service provider computer may also contain communications connection s that allow the service provider computer to communicate with a data store e.g. the database of the user device or another database or another computing device via the networks . The service provider computer may also include I O device s .

Turning to the contents of the memory in more detail the memory may include an operating system and or one or more application programs or services for implementing the features disclosed herein including an asset upload module . In some examples the asset upload module may be configured to manage mobile assets and or prepare or otherwise generate information for enabling the user device and or the first party framework module to extend the data types originally configured within the first party application framework of . For example the asset upload module may be configured to identify one or more new data types and generate data to be provided to the user device for registering or otherwise effectuating the new data types.

In some examples the third party application may end here if they have already requested authorization for the particular data type. Additionally in some examples the request at may be for all data types as opposed to a particular data type. In other examples if the third party application has not yet requested authorization for one some or all of the data types the first party process may receive an authorization request . As noted above the authorization request may be a set of data types all the data types available e.g. to limit the number of these requests or a particular data type. Once received by the first party process the first party process may forward this request to the user of the user device e.g. via a UI provided to the user . At the first party process may receive a response from the user indicating whether the user has authorized access to that third party application . The answer may be different for each data type and or for each third party application. For example and as noted in each application may have different access restrictions for different data types. Independent of whether the user responds yes or no at to the data authorization request the first party process may provide a response to the first party process that indicates that the first party process has provided the data authorization request to the user. In some examples this response may be a simple ok done response or any other response that indicates that this step has been completed. However the response may not indicate whether the user has authorized the access or not. In this way the authorization grant or denial is masked to the third party application . Future requests for access to this particular data type e.g. one where access authorization was denied may receive an empty or null result . Additionally future requests for this data type may receive an empty or null result at when not data value exists even if the access authorization was granted. A similar flow for write requests is envisioned as well however when write access authorization is not granted the first party process may provide the last set of data that the third party application attempted to write. Thus the third party application may not be able to tell when read authorization requests are denied or when write authorization requests are denied.

In one non limiting example row may represent a scenario for the heart rate data type. In this example the user s heart rate may have been recorded as 78 beats per minute and the requesting application may have already provided an authorization request. Here the user has approved the authorization request as such the result provided to the requesting application will match the value 78. This will even be the case if the application requesting the data value was not the application that provided to the data value to the first party process . In another example row may represent a scenario for the glucose level data type. In this example the user s glucose levels may not have been recorded. Thus even though an authorization request has been sent and approved no data result is available as such an empty result is provided to the application. At row a similar scenario as shown in row is depicted but for the weight data type. Here the value in the data store is provided to the requesting application. At row the steps e.g. steps per minute data type shows a data value of 82. However since no authorization request has been submitted by the requesting application there would not have been an approval or a denial as such an error would be returned to the requesting application if they attempted to request that data type. Further row shows a tobacco data type that may indicate whether the user is a smoker and if so how many cigarettes or other quantifiable measure they smoke per day. In some examples a value of 5 may indicate that the user is a smoker and smokes five cigarettes per day while a value of 0 may indicate that the user is a non smoker. Here the data value indicates that the user is a smoker and the table indicates that the application has requested access authorization. However the user has denied the authorization request for this data type e.g. maybe because this personal health information is not something the user wishes to share with third party applications . As such even though a data result exists in the data store the result provided to the requesting application may be the same as when no value existed. That is when authorization is denied the result may be empty. In this way the denial and approval of authorization requests can be masked by the type of response given to the requesting application.

Additionally some any or all of the processes described herein may be performed under the control of one or more computer systems configured with specific executable instructions and may be implemented as code e.g. executable instructions one or more computer programs or one or more applications executing collectively on one or more processors by hardware or combinations thereof. As noted above the code may be stored on a non transitory computer readable storage medium for example in the form of a computer program including a plurality of instructions executable by one or more processors.

In some examples the user device e.g. utilizing at least the authorization module shown in may perform the process of . The process may begin at by including receipt of health information of a user associated with a subset of a plurality of different data types. In some examples this may include receiving a single data entry of health data corresponding to a single data type or a set of data entries of health data corresponding to a single data type each. Additionally in some cases the health information may be received from one or more applications e.g. a third party application or a first party application of the user device and may have initially been collected by a data collection device. At the process may include storing the health information of the user in a secure storage device. For example the health information may be stored in a database configured to restrict access of the data to particular applications based at least in part on configurable settings the requesting application and or the data type being requested. In some cases the process may include receiving an authorization request for accessing a data type from a first application at . The process may also include providing an indication to the first application that the authorization request was provided to the user at .

At the process may include receiving a request for health information corresponding to the data type. This request may be received from the first application. At the process may also include providing an empty result to the first application when the user has not authorized access. In this way the fact that the user denied the authorization request the first application is not made of aware of this. In other words the first application will not know whether the authorization request was denied or whether no data value existed in the data store for that data type. Further in some examples the process may include receiving another authorization request for accessing the data type at . This request may come from a second application. At the process may include receiving an authorization grant for the second application to access the same data type. In some aspects the process may end at where the same indication given to the first application may be provided to the second application. That is the same result e.g. an empty result may be provided to the first application when the data type info e.g. a value was not provided as is provided to the second application when the data value was provided but authorization was not granted.

In at least one non limiting example the third party application may be configured to subscribe to one or more data types of the user information stored within the database . The third party application may also include a frequency corresponding to each subscription. In some examples each subscription may be associated with a different data type and have its own associated frequency. For example the third party application may subscribe to the weight data type with a frequency of daily and also subscribe to the blood glucose level data type with a frequency of immediate. As such in some examples the first party process may launch the third party application in the background when certain actions occur based at least in part on the subscription and provide the data to the third party application while it is launched. For example whenever the third party source application provides a new blood glucose reading assuming the data collection device collects and provides such data the first party process may automatically launch the third party application enable it to request the new reading and then provide the data to the third party application based at least in part on the request. In this scenario the third party application was launched nearly immediately e.g. within a second or so after the new blood glucose reading was received because the subscription frequency was set to immediate thus providing the data e.g. the new blood glucose reading nearly immediately. Alternatively if the new reading had been weight the third party application may not have been launched and the data provided until the end of the day based at least in part on that subscription being set to daily. 

In some cases the third party application may receive the new reading e.g. the blood glucose reading noted above and begin to process the data . While the processing may be agnostic to the first party process e.g. the first party process may not know what processing is being done with the data reading the first party process may be configured to look or otherwise poll for a transaction complete confirmation . In some examples if the transaction complete confirmation is not received within a particular time period the first party process may relaunch the third party application until the confirmation is received. In other examples the first party process may be also be configured to relaunch the third party application if the third party application crashes while running in the background. In other words the first party process may be configured to repeatedly relaunch the third party application in the background until the confirmation is received thus ensuring that the third party application was able to complete its processing . In this way a virtual service level agreement SLA may be provided to the third party applications based at least in part on the subscription.

In some cases the frequency may be automatically determined based at least in part on the type of data and or a historical frequency associated with the data. For example weight data doesn t generally change that much within a day so the frequency may be automatically set at daily. Alternatively blood glucose level can change drastically within a few minutes and can be life threatening. As such the frequency for a subscription to blood glucose level may be automatically set at immediate or every minute. Additionally in some examples the amount of time the first party process waits before relaunching the third party application in the background may change between each relaunch. For example the first party process may launch the third party application in the background upon the initial new blood glucose reading e.g. using the example above and wait 2 minutes for the third party application to provide the confirmation . If no confirmation is received within the two minute period the first party process might relaunch the third party application and wait a second period of time. In some cases the period of time that the first party process waits may increase for each relaunch. An exponential backoff function may be used to determine the wait period between each relaunch. For example if the first wait period is two minutes the second wait period might be four minutes then eight minutes and so on. If the day or a 24 hour period ends without receiving the confirmation the first party process may start the cycle over by waiting two minutes each period or it may switch to waiting for a more consistent period of time e.g. relaunching the third party application every day . Once confirmation is received the first party process may stop relaunching the third party application . However if the confirmation is never received the first party process may continue to relaunch and wait for confirmation until confirmation is eventually received that the processing of the requested data is complete. For certain third party applications this continual relaunch may save a user s life.

In some cases the first party process may not be configured to provide the activity and or health data to the third party application when the user device is locked e.g. if that data is stored in the class A data store . This configuration may be based at least in part on privacy and or security restrictions. Thus some third party applications that are subscribed to certain data types may not be able to receive data if the device is locked typically because most health and or activity data is stored in the class A data store . Even if the third party application is able to be launched it is possible that the first party process may not be able to send the data. However in some cases when a third party application is subscribed to a data type the corresponding data may instead be stored in the class C data store so that it can be served even with the user device is locked. Once confirmation of the completed transaction is received the first party process may remove or otherwise delete the corresponding data from the class C data store and or move the corresponding data to the class A data store . Alternatively or in addition if the corresponding data is stored in the class A data store and the user device is locked a notification or alert may be provided on the lock screen that indicates that data is waiting to be sent to a third party application but that the data cannot be sent until the device is unlocked. Once unlocked the device can provide the corresponding data from the class A data store .

In some examples a third party application may ask for a sample type using an API method that includes an identifier. The identifier may be a string that can be predefined and or baked into the code for existing data types. However in some examples once implemented via the asset download and published a new string may be utilized to read from and or write to the new data type. Additionally once implemented any application e.g. third party applications and or first party applications may utilize the new data type. The asset download may also include additional information about the new data type including but not limited to what type it is e.g. cumulative or discrete what string should be used the identifier metadata about display descriptions etc.

Additionally in some cases the first party process may have the ability to load plug ins. The first party process may look for plug ins in one or more particular directories and the plug ins may be configured to enable changes in behavior of the first party process . For example based at least in part on the device that the plug ins are installed on they may enable different behavior changes. In some cases plug ins may be utilized for creating differences in behavior e.g. to make the first party process behave differently than initially programmed . For example a plug in may be utilized to enable the first party process to register for notifications and or harvesting different data. Additionally in some cases the plug ins may be utilized for registering the new data types as described above.

As noted above a third party application may ask for a data type by making an API call and passing in an identifier and or a kind. The kind may include particular types of the data type e.g. cumulative discrete or category . The identifier in some cases may be represented as a string that is passed in via the API and a data type may be returned to the requesting application. The plug ins as noted can register new data types that adhere to different identifiers so they can store their own data in the database automatically. As such the first party process may not need to manage or provide the new data type data to the database . Instead the plug ins may provide the data to the updated database that includes the new data types and or both the original data types and the new data types.

In some examples the asset download may be a data file e.g. not executable code that can be downloaded to the device to provide the appropriate information for extending the data types as described above. In some examples the asset download may include data type definition updates. In this way the user device can download the asset download and have that information available on the device for access use by third party applications. Thus once downloaded and used by the first party process to configure the new data types the third party applications can write to the new data type and read back from it. In some examples the APIs for reading and writing to the new data type may be extensible so that the executable code for the user device does not need to be changed but the first party process can still support the new data type.

The asset download may be provided by the service provider computers and as noted may include all the information for the new data types. In this way the first party process may utilize the information in the asset download to register the new data types identified in the asset download instead of or in addition to using the plug ins described above. The service provider computers may also publish the identifiers listed in the asset download to a network resource over a private or public network e.g. the Internet . In some cases if an identifier is published before an asset download is implemented and an application requests a data type that has not yet been registered with the first party process then the first party process may return an error e.g. nill or a null result .

From an implementation perspective one difference between changing the behavior of the first party process with plug ins versus the asset download is that plug ins are executable code that include appropriate information for making changes to the functionality while the asset download is merely data. As such code within first party process may be executed to interpret the data of the asset download and turn it into actual data types. Any number and or type of new data types may be added to the first party application framework and or utilized by the first party process even before later software releases for the user device . In some cases data types may also include analysis of the data values e.g. whether a data value for a particular data type is good or bad for a particular user . This analysis information may also be included in the asset download and or published to the network resource for availability to the developers and or third party applications. Database may represent the state of the data types prior to implementation of the asset download e.g. with the original data types while the database may represent the state of the data types after the implementation of the asset download e.g. including the new data types .

At the process may include identifying a new data type requested for use with a third party application of the user device . In some examples these new data types may be identified by the service provider computers receiving a request from a developer or other user of the framework. At the process may include providing data e.g. the mobile asset to the user device that identifies the information about the new data type. In some aspects the process may also include publishing this information e.g. the identifiers descriptions etc. at to a network resource e.g. a web page or other resource accessible over a network that may be accessible to the public or at least to developers of third party applications. At the process may include causing a background process e.g. the first party process of the user device to interpret the data to implement the new data type. At the process may include enabling the background process of the user device to manage second health information e.g. associated with the new data type . In some examples the process may end at where the service provider computer may update the maintained data types with the new data type. In other words the service provider computers may update their own tables or databases to include the new data type.

While the data collection device A is shown communicating with the third party application A over a network and the data collection device B is shown communicating with the third party application B over the network it should be understood that any combination of application to device s pairings are possible and that such pairings may be facilitated by any number of different or same network connections. Still when the first party process is managing input data from a plurality of different applications and or a plurality of different devices the first party process may request priority information from a user of the user device . In this way the user may provide priority information associated with which of the data collection devices the user would prefer to track when multiple devices are providing data for the same data type and or for the same time period.

For example the first party process may receive data entries from both the data collection device A and the data collection device B for the same time period. The data may correspond to a particular data type e.g. heart rate yet the data entries may differ slightly e.g. the two collection devices may not be calibrated the same or one might be more sensitive than the other . Instead of tracking both data entries the first party process may determine to track only one of the sets of data entries. Similarly the first party process may determine to track one set of data for a first set of time and the other set of data of data for a second set of time. The determination of which data entries to track may be based at least in part on a priority set by the user a type or kind of the data type e.g. whether it is cumulative or discrete timing information e.g. what time the data was received and or other information about the data entry.

Additionally all of the data from the multiple sources may be tracked however only some of it may be aggregated into a data record that may be provided or presented to the user via the user device . For example the first party application framework may be configured to implement a UI for presenting collected data e.g. from a single or multiple data collection devices and or aggregated data e.g. the data record . In some examples the data record may also be provided to one or more requesting entities e.g. either or both of the third party applications or other third party applications. The UI may be configured to present the aggregated data record or subsets of the data record to the user.

For discrete data the UI may present a different looking representation of the data than for cumulative data. As such the first party process may first identify whether the data to be provided to the UI is discrete or cumulative. The first party process may also identify if there is priority information provided by the user. If not the first party process may determine priority information based at least in part on previous configurations of the user historical and or use information from other users of the device or of other devices e.g. a probability that the user will use the data collection device at a particular time and or information about accuracy of the respective collection devices . If priority information exists the first party process may use that priority information to determine which collected data for a single data type should be included in the data record for each time period or for each time segment of the time period e.g. each second of the 5 minute window of collected data etc. . The priority information may be configured via the UI such that the user may slide drag or otherwise virtually move the sources e.g. the data collection devices up and down to identify a preferred priority. As desired the priority information and the received data entries may correspond to any number of data collection devices and or applications.

The collected data may be segmented for each time period such that data is represented in a meaningful manner. For example if a person never takes more than a single step per millisecond using milliseconds as the segmentation for steps would probably not provide meaningful results. However if the lower bounds for steps were half a second e.g. when someone is running and 2 seconds e.g. when someone is walking very slow then the segments for steps should be somewhere between 0.5 and 2 seconds for a particular time window e.g. an entire day or at least the hours that the user spends awake . As such historical and or use information for each data type may be collected and analyzed to automatically identify appropriate segment bounds. In some cases this may avoid double counting for example when multiple data sources are providing the same data entries for the same segment. In other examples predefined segments may be used for each data type and or information about the user collected from other sources devices applications etc.

The first party process and or the first party application framework may provide API methods for third parties e.g. the third party application to utilize to retrieve the aggregated data records. In this way the third party application may be able to customize a request for aggregated data over a particular period of time and or for a particular data type. As desired the first party process may respond to the API method calls by providing an aggregated data record that includes data collected from sources other than the requestor e.g. other than the third party application . This may enable one application to receive an aggregated data record that is not solely based on the data provided by that application. Additionally the UI may be configured to provide cumulative and or discrete data for multiple data sources to a user or other application.

In some examples when the data is cumulative the data may be summed or otherwise added up over the entire time period. As shown in the cumulative data type presentation this may cause a double counting problem when multiple sources provide data for the same time segments. For example over the first third of the time period the first party process may only have received data from a first source e.g. A number of steps . For a cumulative data type e.g. steps walked the data entries at each segment may be added together to get a total. Similarly at the last third of the time period the first party process may also have only received data from the first source e.g. C number of steps . However if two sources provided step data during the middle third of the time period adding both B number of steps and alpha number of steps would not provide an accurate total step count because the number of steps during that time period would be double counted or at least counted from two different sources. As such using the priority information collected from the user the UI may be able to present a piecemeal representation such as the prioritized cumulative data type presentation . In this presentation the alpha number of steps may have been identified as the user s prioritized data source for this subset of the time period. As such only alpha number of steps e.g. coming from one source is shown during that subset of the time period while A and C number of steps e.g. coming from a different source . The total number of steps aggregated over the time period in this presentation may be A alpha C as opposed to A B alpha C from the cumulative data type presentation .

At the process may include identifying a time interval for partitioning the health data. These partitions also referred to as segments may be based at least in part on user information data type information historical and or use data or the like. At the process may include identifying a data entry corresponding to a source with the highest priority during each time interval or segment. In some examples this may only apply when a data entry exists for that segment. At the process may include aggregating each identified data record over the amount of time e.g. the day an hour etc. . In some cases the process may end at where the process may include providing the aggregated data record for presentation e.g. to the user .

Illustrative methods and systems for managing user device connections are described above. Some or all of these systems and methods may but need not be implemented at least partially by architectures such as those shown at least in above. While many of the embodiments are described above with reference to personal and or health related information it should be understood any time of user information or non user information e.g. data of any type may be managed using these techniques. Further in the foregoing description various non limiting examples were described. For purposes of explanation specific configurations and details are set forth in order to provide a thorough understanding of the examples. However it should also be apparent to one skilled in the art that the examples may be practiced without the specific details. Furthermore well known features were sometimes omitted or simplified in order not to obscure the example being described.

The various embodiments further can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User devices e.g. client devices can include any type of general purpose personal computer such as but not limited to desktop or laptop computers running a standard operating system as well as cellular wireless and or handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. These devices can also include other electronic devices such as dummy terminals thin clients gaming systems or other devices capable of communicating via a network.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as TCP IP OSI FTP UPnP NFS CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers. Alternatively the memory can be remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as desired.

The system and various devices may also include one or more software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the disclosure as set forth in the claims.

Other variations are within the spirit of the present disclosure. Thus while the disclosed techniques are susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the disclosure to the specific form or forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the disclosure as defined in the appended claims.

The use of the terms a and an and the and similar referents in the context of describing the disclosed embodiments especially in the context of the following claims are to be construed to cover both the singular and the plural unless otherwise indicated herein or clearly contradicted by context. The terms comprising having including and containing are to be construed as open ended terms i.e. meaning including but not limited to unless otherwise noted. The term connected is to be construed as partly or wholly contained within attached to or joined together even if there is something intervening. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range unless otherwise indicated herein and each separate value is incorporated into the specification as if it were individually recited herein. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples or exemplary language e.g. such as provided herein is intended merely to better illuminate embodiments of the disclosure and does not pose a limitation on the scope of the disclosure unless otherwise claimed. No language in the specification should be construed as indicating any non claimed element as essential to the practice of the disclosure.

Disjunctive language such as the phrase at least one of X Y or Z unless specifically stated otherwise is otherwise understood within the context as used in general to present that an item term etc. may be either X Y or Z or any combination thereof e.g. X Y and or Z . Thus such disjunctive language is not generally intended to and should not imply that certain embodiments require at least one of X at least one of Y or at least one of Z to each be present.

Any of the methods described herein may be totally or partially performed with a computer system including one or more processors which can be configured to perform the steps. Thus embodiments can be directed to computer systems configured to perform the steps of any of the methods described herein potentially with different components performing a respective steps or a respective group of steps. Although presented as numbered steps steps of methods herein can be performed at a same time or in a different order. Additionally portions of these steps may be used with portions of other steps from other methods. Also all or portions of a step may be optional. Additionally any of the steps of any of the methods can be performed with modules circuits or other means for performing these steps.

The specific details of particular embodiments may be combined in any suitable manner without departing from the spirit and scope of embodiments of the disclosure. However other embodiments of the disclosure may be directed to specific embodiments relating to each individual aspect or specific combinations of these individual aspects

The above description of exemplary embodiments of the disclosure has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the disclosure to the precise form described and many modifications and variations are possible in light of the teaching above. The embodiments were chosen and described in order to best explain the principles of the disclosure and its practical applications to thereby enable others skilled in the art to best utilize the disclosure in various embodiments and with various modifications as are suited to the particular use contemplated.

All references including publications patent applications and patents cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.

