---

title: State grouping for element utilization
abstract: Embodiments of a system and method for generating an image configured to program a parallel machine from source code are disclosed. One such parallel machine includes a plurality of state machine elements (SMEs) grouped into pairs, such that SMEs in a pair have a common output. One such method includes converting source code into an automaton comprising a plurality of interconnected states, and converting the automaton into a netlist comprising instances corresponding to states in the automaton, wherein converting includes pairing states corresponding to pairs of SMEs based on the fact that SMEs in a pair have a common output. The netlist can be converted into the image and published.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104828&OS=09104828&RS=09104828
owner: Micron Technology, Inc.
number: 09104828
owner_city: Boise
owner_country: US
publication_date: 20140718
---
This patent application is a continuation of U.S. application Ser. No. 13 357 511 filed Jan. 24 2012 which claims the benefit of priority under 35 U.S.C. Section 119 e to U.S. Provisional Patent Application Ser. No. 61 436 075 titled STATE GROUPING FOR ELEMENT UTILIZATION filed on Jan. 25 2011 both of which are hereby incorporated by reference herein in their entirety.

A compiler for a parallel machine converts source code into machine code e.g. an image for configuring e.g. programming the parallel machine. The machine code can implement a finite state machine on the parallel machine. One stage of the process of converting the source code into machine code includes forming a netlist. A netlist describes the connectivity between instances of the hardware elements of the parallel machine. The netlist can describe connections between the hardware elements such that the hardware elements implement the functionality of the source code.

The following description and the drawings sufficiently illustrate specific embodiments to enable those skilled in the art to practice them. Other embodiments may incorporate structural logical electrical process and other changes. Portions and features of some embodiments may be included in or substituted for those of other embodiments. Embodiments set forth in the claims encompass all available equivalents of those claims.

This document describes among other things a compiler that generates a netlist based on a physical design of the parallel machine. In an example the physical design of the parallel machine can include connectivity limitations between state machine elements of the parallel machine. For example the state machine elements in the parallel machine can be grouped into pairs that share a common output. Accordingly the compiler can generate a netlist based on a physical design where pairs of SMEs share a common output.

The parallel machine includes a plurality of programmable elements including general purpose elements and special purpose elements . A general purpose element can include one or more inputs and one or more outputs . A general purpose element can be programmed into one of a plurality of states. The state of the general purpose element determines what output s the general purpose elements will provide based on a given input s . That is the state of the general purpose element determines how the programmable element will react based on a given input. Data input to the data input port can be provided to the plurality of general purpose elements to cause the general purpose elements to take action thereon. Examples of a general purpose element can include a state machine element SME discussed in detail below and a configurable logic block. In an example a SME can be set in a given state to provide a certain output e.g. a high or 1 signal when a given input is received at the data input port . When an input other than the given input is received at the data input port the SME can provide a different output e.g. a low or 0 signal . In an example a configurable logic block can be set to perform a Boolean logic function e.g. AND OR NOR ext. based on input received at the data input port .

The parallel machine can also include a programming interface for loading a program e.g. an image onto the parallel machine . The image can program e.g. set the state of the general purpose elements . That is the image can configure the general purpose elements to react in a certain way to a given input. For example a general purpose element can be set to output a high signal when the character a is received at the data input port . In some examples the parallel machine can use a clock signal for controlling the timing of operation of the general purpose elements . In certain examples the parallel machine can include special purpose elements e.g. RAM logic gates counters look up tables etc. for interacting with the general purpose elements and for performing special purpose functions. In some embodiments the data received at the data input port can include a fixed set of data received over time or all at once or a stream of data received over time. The data may be received from or generated by any source such as databases sensors networks etc coupled to the parallel machine .

The parallel machine also includes a plurality of programmable switches for selectively coupling together different elements e.g. general purpose element data input port output port programming interface and special purpose elements of the parallel machine . Accordingly the parallel machine comprises a programmable matrix formed among the elements. In an example a programmable switch can selectively couple two or more elements to one another such that an input of a general purpose element the data input port a programming interface or special purpose element can be coupled through one or more programmable switches to an output of a general purpose element the output port a programming interface or special purpose element . Thus the routing of signals between the elements can be controlled by setting the programmable switches . Although illustrates a certain number of conductors e.g. wires between a given element and a programmable switch it should be understood that in other examples a different number of conductors can be used. Also although illustrates each general purpose element individually coupled to a programmable switch in other examples multiple general purpose elements can be coupled as a group e.g. a block as illustrated in to a programmable switch . In an example the data input port the data output port and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements.

In an example a single parallel machine is implemented on a physical device however in other examples two or more parallel machines can be implemented on a single physical device e.g. physical chip . In an example each of multiple parallel machines can include a distinct data input port a distinct output port a distinct programming interface and a distinct set of general purpose elements . Moreover each set of general purpose elements can react e.g. output a high or low signal to data at their corresponding input data port . For example a first set of general purpose elements corresponding to a first parallel machine can react to the data at a first data input port corresponding to the first parallel machine . A second set of general purpose elements corresponding to a second parallel machine can react to a second data input port corresponding to the second parallel machine . Accordingly each parallel machine includes a set of general purpose elements wherein different sets of general purpose elements can react to different input data. Similarly each parallel machine and each corresponding set of general purpose elements can provide a distinct output. In some examples an output port from first parallel machine can be coupled to an input port of a second parallel machine such that input data for the second parallel machine can include the output data from the first parallel machine .

In an example an image for loading onto the parallel machine comprises a plurality of bits of information for setting the state of the general purpose elements programming the programmable switches and configuring the special purpose elements within the parallel machine . In an example the image can be loaded onto the parallel machine to program the parallel machine to provide a desired output based on certain inputs. The output port can provide outputs from the parallel machine based on the reaction of the general purpose elements to data at the data input port . An output from the output port can include a single bit indicating a match of a given pattern a word comprising a plurality of bits indicating matches and non matches to a plurality of patterns and a state vector corresponding to the state of all or certain general purpose elements at a given moment.

Example uses for the parallel machine include pattern recognition e.g. speech recognition image recognition etc. signal processing imaging computer vision cryptography and others. In certain examples the parallel machine can comprise a finite state machine FSM engine a field programmable gate array FPGA and variations thereof. Moreover the parallel machine may be a component in a larger device such as a computer pager cellular phone personal organizer portable audio player network device e.g. router firewall switch or any combination thereof control circuit camera etc.

The FSM engine includes a plurality of programmable elements including general purpose elements and special purpose elements. The general purpose elements can be programmed to implement many different functions. These general purpose elements include SMEs shown in that are hierarchically organized into rows shown in and blocks shown in . To route signals between the hierarchically organized SMEs a hierarchy of programmable switches is used including inter block switches shown in intra block switches shown in and intra row switches shown in . A SME can correspond to a state of a FSM implemented by the FSM engine . The SMEs can be coupled together by using the programmable switches as described below. Accordingly a FSM can be implemented on the FSM engine by programming the SMEs to correspond to the functions of states and by selectively coupling together the SMEs to correspond to the transitions between states in the FSM.

In an example the input block the output block and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements. Accordingly bits from the image stored in the registers corresponding to the programming interface can be loaded on the SMEs . Although illustrates a certain number of conductors e.g. wire trace between a block input block output block and an inter block switch it should be understood that in other examples fewer or more conductors can be used.

In an example the row includes a first and second plurality of row interconnection conductors . In an example an input of a GOT can be coupled to one or more row interconnection conductors and an output can be coupled to one row interconnection conductor . In an example a first plurality of the row interconnection conductors can be coupled to each SME of each GOT within the row . A second plurality of the row interconnection conductors can be coupled to one SME of each GOT within the row but cannot be coupled to the other SME of the GOT . In an example a first half of the second plurality of row interconnection conductors can couple to first half of the SMEs within a row one SME from each GOT and a second half of the second plurality of row interconnection conductors can couple to a second half of the SMEs within a row the other SME from each GOT . The limited connectivity between the second plurality of row interconnection conductors and the SMEs is referred to herein as parity .

In an example the row can also include a special purpose element such as a counter a programmable Boolean logic element a field programmable gate array FPGA an application specific integrated circuit ASIC a programmable processor e.g. a microprocessor and other elements. Additionally in an example the special purpose element is different in different rows . For example four of the rows in a block can include Boolean logic as the special purpose element and the other eight rows in a block can include a counter as the special purpose element .

In an example the special purpose element includes a counter also referred to herein as counter . In an example the counter comprises a 12 bit programmable down counter. The 12 bit programmable counter has a counting input a reset input and zero count output. The counting input when asserted decrements the value of the counter by one. The reset input when asserted causes the counter to load an initial value from an associated register. For the 12 bit counter up to a 12 bit number can be loaded in as the initial value. When the value of the counter is decremented to zero 0 the zero count output is asserted. The counter also has at least two modes pulse and hold. When the counter is set to pulse mode the zero count output is asserted during the first clock cycle when the counter decrements to zero and at the following clock cycles the zero count output is no longer asserted even if the counting input is asserted. This state continues until the counter is reset by the reset input being asserted. When the counter is set to hold mode the zero count output is asserted during the first clock cycle when the counter decrements to zero and stays asserted when the counting input is asserted until the counter is reset by the reset input being asserted.

In an example a state machine element comprises a plurality of memory cells such as those often used in dynamic random access memory DRAM coupled in parallel to a detect line . One such memory cell comprises a memory cell that can be set to a data state such as one that corresponds to either a high or a low value e.g. a 1 or 0 . The output of the memory cell is coupled to the detect line and the input to the memory cell receives signals based on data on the data stream line . In an example an input on the data stream line is decoded to select one of the memory cells . The selected memory cell provides its stored data state as an output onto the detect line . For example the data received at the data input port can be provided to a decoder not shown and the decoder can select one of the data stream lines . In an example the decoder can convert an ACSII character to 1 of 256 bits.

A memory cell therefore outputs a high signal to the detect line when the memory cell is set to a high value and the data on the data stream line corresponds to the memory cell . When the data on the data stream line corresponds to the memory cell and the memory cell is set to a low value the memory cell outputs a low signal to the detect line . The outputs from the memory cells on the detect line are sensed by a detect circuit . In an example the signal on an input line sets the respective detect circuit to either an active or inactive state. When set to the inactive state the detect circuit outputs a low signal on the respective output regardless of the signal on the respective detect line . When set to an active state the detect circuit outputs a high signal on the respective output line when ahigh signal is detected from one of the memory cells of the respective SME . When in the active state the detect circuit outputs a low signal on the respective output line when the signals from all of the memory cells of the respective SME are low.

In an example an SME includes 256 memory cells and each memory cell is coupled to a different data stream line . Thus an SME can be programmed to output a high signal when a selected one or more of the data stream lines have a high signal thereon. For example the SME can have a first memory cell e.g. bit set high and all other memory cells e.g. bits set low. When the respective detect circuit is in the active state the SME outputs a high signal on the output when the data stream line corresponding to bit has a high signal thereon. In other examples the SME can be set to output a high signal when one of multiple data stream lines have a high signal thereon by setting the appropriate memory cells to a high value.

In an example a memory cell can be set to a high or low value by reading bits from an associated register. Accordingly the SMEs can be programmed by storing an image created by the compiler into the registers and loading the bits in the registers into associated memory cells . In an example the image created by the compiler includes a binary image of high and low e.g. 1 and 0 bits. The image can program the FSM engine to operate as a FSM by cascading the SMEs . For example a first SME can be set to an active state by setting the detect circuit to the active state. The first SME can be set to output a high signal when the data stream line corresponding to bit has a high signal thereon. The second SME can be initially set to an inactive state but can be set to when active output a high signal when the data stream line corresponding to bit has a high signal thereon. The first SME and the second SME can be cascaded by setting the output of the first SME to couple to the input of the second SME . Thus when a high signal is sensed on the data stream line corresponding to bit the first SME outputs a high signal on the output and sets the detect circuit of the second SME to an active state. When a high signal is sensed on the data stream line corresponding to bit the second SME outputs a high signal on the output to activate another SME or for output from the FSM engine .

In an example the compiler includes an application programming interface API that allows software developers to create images for implementing FSMs on the FSM engine . The compiler provides methods to convert an input set of regular expressions in the source code into an image that is configured to program the FSM engine . The compiler can be implemented by instructions for a computer having a Von Nuemann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler. For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor. An example computer having a Von Nuemann architecture is shown in and described below.

In an example the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings the source code can include a plurality of regular expressions regexes . A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains such as programming languages text editors network security and others. In an example the regular expressions supported by the compiler include search criteria for the search of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes printable and non printable within the data. In an example the compiler can support multiple different source code languages for implementing regexes including Perl e.g. Perl compatible regular expressions PCRE PHP Java and .NET languages.

Referring back to at block the compiler can parse the source code to form an arrangement of relationally connected operators where different types of operators correspond to different functions implemented by the source code e.g. different functions implemented by regexes in the source code . Parsing source code can create a generic representation of the source code. In an example the generic representation comprises an encoded representation of the regexes in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree also known as an abstract syntax tree . In other examples however a concrete syntax tree or other arrangement can be used.

Since as mentioned above the compiler can support multiple languages of source code parsing converts the source code regardless of the language into a non language specific representation e.g. a syntax tree. Thus further processing blocks by the compiler can work from a common input structure regardless of the language of the source code.

As noted above the syntax tree includes a plurality of operators that are relationally connected. A syntax tree can include multiple different types of operators. That is different operators can correspond to different functions implemented by the regexes in the source code.

At block the syntax tree is converted into an automaton. An automaton also referred to as a finite state automaton finite state machine FSM or simply a state machine is a representation of states transitions between states and actions and can be classified as deterministic or non deterministic. A deterministic automaton has a single path of execution at a given time while a non deterministic automaton has multiple concurrent paths of execution. The automaton comprises a plurality of states. In order to convert the syntax tree into an automaton the operators and relationships between the operators in the syntax tree are converted into states with transitions between the states. In an example the automaton can be converted based partly on the hardware of the FSM engine .

In an example input symbols for the automaton include the symbols of the alphabet the numerals 0 9 and other printable characters. In an example the input symbols are represented by the byte values 0 through 255 inclusive. In an example an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example a transition from state p to state q on an input symbol i.e. p is shown by a directed connection from node p to node q. In an example the language accepted e.g. matched by an automaton is the set of all possible character strings which when input sequentially into the automaton will reach a final state. Each string in the language accepted by the automaton traces a path from the start state to one or more final states.

In an example special transition symbols outside the input symbol range may be used in the automaton. These special transition symbols can be used for example to enable use of special purpose elements . Moreover special transition symbols can be used to provide transitions that occur on something other than an input symbol. For example a special transition symbol may indicate that a first state is to be enabled e.g. transitioned to when both a second state and a third state are enabled. Accordingly the first state is activated when both the second state and the third state are activated and the transition to the first state is not directly dependent on an input symbol. Notably a special transition symbol that indicates that a first state is to be enabled when both a second state and a third state are enabled can be used to represent a Boolean AND function performed for example by Boolean logic as the special purpose element . In an example a special transition symbol can be used to indicate a counter state has reached zero and thus transitions to a downstream state.

In an example the automaton comprises general purpose states as well as special purpose states. The general purpose states and special purpose states correspond to general purpose elements and special purpose elements supported by a target device for which the compiler is generating machine code. Different types of target devices can support different types of general purpose elements as well as one or more different types of special purpose elements. A general purpose element can typically be used to implement a broad range of functions while a special purpose element can typically be used to implement a more narrow range of functions. In an example however a special purpose element can achieve for example greater efficiency within its narrow range of function. Accordingly a special purpose element can be used to for example reduce the machine cycles or the machine resources required to implement certain functions in the target device. In some examples the target device supports solely special purpose elements wherein multiple different types of special purpose elements are supported.

In an example where the compiler is generating machine code for the FSM engine the general purpose states can correspond to SMEs and the general purpose states are accordingly referred to herein as SME states . Moreover when the compiler is generating machine code for the FSM engine one example of a special purpose state can correspond to counters and is accordingly referred to herein as a counter state . Another example of a special purpose state can correspond to a logic element e.g. programmable logic Boolean logic and is accordingly referred to herein as a logic state . In an example the SME states in the automaton map 1 1 to SMEs e.g. SME in the FSM engine with the exception of the starting state of the automaton which does not map to a SME. The special purpose elements may or may not map 1 1 to special purpose states.

In an example an automaton can be constructed using one of the standard techniques such as Glushkov s method. In an example the automaton can be an free homogeneous automaton. A homogeneous automaton is a restriction on the general automaton definition. The restriction requires that all transitions entering a state must occur on the same input symbol s . The homogeneous automaton satisfies the following condition For any two states qand q if r q q denote S a a r q a S a a r q a . Sis the set of symbols that allows qto transition to r and Sis the set of symbols that allows qto transition to r. Here S S i.e. if state qand state qboth transition to state r then the homogeneous restriction is that the transitions must occur on the same symbol s .

The homogenous automaton begins at starting state which transitions to state on the input symbol a . State transitions to state on the input symbol b and state transitions to state on the input symbol b . State transitions to state on the input symbol c . State transitions to state on the input symbol b and transitions to state on the input symbol d . State is a final state and is identified as such by the double circle. In an example final states can be significant since activation of a final state indicates a match of a regex corresponding to the automaton. The automaton is a homogeneous automaton since all in transitions e.g. a transition into the state for a given state occur on the same symbol s . Notably state has two in transitions from state and state and both in transitions occur on the same symbol b .

The non homogeneous automaton includes the same states and as the homogenous automaton however the state transitions to state on the input symbol e . Accordingly the automaton is non homogeneous since the state has in transitions on two different symbols symbol b from state and symbol e from state .

At block after the automaton is constructed the automaton is optimized to among other things reduce its complexity and size. The automaton can be optimized by combining redundant states.

At block the automaton is converted into a netlist. Converting the automaton into a netlist maps the states of the automaton to instances of a hardware element e.g. SMEs GOT special purpose element of the FSM engine and determines the connections between the instances. In an example the netlist comprises a plurality of instances each instance corresponding to e.g. representing a hardware element of the FSM engine . Each instance can have one or more connection points also referred to herein as a port for connection to another instance. The netlist also comprises a plurality of connections between the ports of the instances which correspond to e.g. represent conductors to couple the hardware elements corresponding to the instances. In an example the netlist comprises different types of instances corresponding to different types of hardware elements. For example the netlist can include a general purpose instance corresponding to a general purpose hardware element and a special purpose instance corresponding to a special purpose hardware element. As an example general purpose states can be converted into general purpose instances and special purpose states can be converted into special purpose instances. In an example the general purpose instances can include an SME instance for an SME and a SME group instance for a hardware element comprising a group of SMEs. In an example the SME group instance includes a GOT instance corresponding to a GOT in other examples however the SME group instance can correspond to a hardware element comprising a group of three or more SMEs. The special purpose instances can include a counter instance for a counter and a logic instance for logic elements . Since a GOT includes two SMEs a GOT instance contains two SME instances.

To create the netlist states in the automaton are converted into instances in the netlist except the starting state does not have a corresponding instance. SME states are converted into GOT instances and counter states are converted into counter instances. Additionally a corresponding connection from a first instance to a second instance is created for a transition from a state corresponding to the first instance to a state corresponding to the second instance. Since the SMEs in the FSM engine are grouped in pairs referred to as GOTs the compiler can group SME states into pairs in a GOT instance. Due to physical design of a GOT not all SME instances can be paired together to form a GOT . Accordingly the compiler determines which SME states can be mapped together in a GOT and then pairs the SME state into GOT instances based on the determination.

As shown in a GOT has output limitations on the SMEs . In particular the GOT has a single output shared by the two SMEs . Accordingly each SME in a GOT cannot independently drive the output . This output limitation restricts which SMEs states can be paired together in a GOT instance. Notably two SME states that drive e.g. transition to activate different sets of external SME states e.g. SME states corresponding to SMEs outside of the GOT instance cannot be paired together in a GOT instance. This limitation however does not restrict whether the two SMEs states drive each other or self loop since a GOT can internally provide this functionality with the switches . Although the FSM engine is described as having certain physical design corresponding to the SMEs in other examples the SMEs may have other physical designs. For example the SMEs may be grouped together into three or more sets of SMEs . Additionally in some examples there may be limitations on the inputs to the SMEs with or without limitations on the outputs from the SMEs .

In any case however the compiler determines which SME states can be grouped together based on the physical design of the FSM engine . Accordingly for a GOT instance the compiler determines which SME states can be paired together based on the output limitations for the SMEs in a GOT . In an example there are five situations in which two SME states can be paired together to form a GOT based on the physical design of the GOT .

The first situation when a first and a second SME state can be paired together in a GOT occurs when neither the first or second SME state are final states and when one of the first and second SME states does not drive any states other than the first or second SME states. As an example a first state is considered to drive a second state when the first state transitions to the second state. When this first situation occurs at most one of the first and second SME states is driving an external state s . Accordingly the first and second SME states can be paired together without being affected by the output limitations of the GOT . Due to the ability of the GOT to couple the SMEs to one another internally however the first and second SME states are allowed to drive each other and self loop to drive themselves. In automaton terms the first SME state corresponding to state q1 and the second SME state corresponding to state q2 can be paired together when neither q1 nor q2 are final states and q1 q1 q2 is empty or when q2 q1 q2 is empty.

The second situation when a first and a second SME state can be paired together in a GOT occurs when neither the first or second SME state are final states in the automaton and when both the first and the second SME state drive the same external states. As used herein external states correspond to states outside of the GOT instance for example notwithstanding whether first and second SME states in a GOT instance drive each other or self loop. Here again the output limitations of a GOT do not affect the first and second SME states since the first and second SME states drive the same external states. Also due to ability of the GOT to couple the SMEs to one another internally the restriction on driving the same states does not include whether the first and second states drive each other or self loop. Using automaton terms the first SME state corresponding to state q1 and the second SME state corresponding to state q2 can be paired together when neither q1 nor q2 are final states and q1 q1 q2 q2 q1 q2.

The third and fourth situations in which a first and a second SME state can be paired together in a GOT occur when one of the first and second SME state are a final state and the other of the first and second SME state does not drive any external state. That is the first SME state corresponding to state q1 and the second SME state corresponding to state q2 can be paired together when q1 is a final state and q2 q1 q2 is empty or when q2 corresponds to a final state and q1 q1 q2 is empty. Since a final state outputs an indication of a match to a regex a SME state corresponding to a final state should have independent use of the output of the GOT in order to indicate the match. Accordingly the other SME state in the GOT is not allowed to use the output .

The fifth situation when a first and a second SME state can be paired together in a GOT occurs when both the first and second SME states correspond to final states in an automaton and both the first and the second SME states drive the same external states. Using automaton terms the first state corresponding to state q1 and the second SME state corresponding to state q2 can be paired together when both q1 and q2 are final states and q1 q1 q2 q2 q1 q2.

Once the compiler determines whether one or more SME states can be paired together the compiler pairs the SMEs states into GOT instances. In an example the compiler pairs SME states into GOT instances in the order they are determined to be capable of being paired to form a GOT instance. That is once two particular SME states are determined to be capable of being paired together these two SME states can be paired into a GOT instance. Once two SME states have been paired to form a GOT instance these paired SME states are not available for pairing with other SME states. This process can continue until there are no longer any SME states left to be paired.

In an example the compiler uses graph theory to determine which SMEs to pair together into a GOT instance. Since only certain SMEs can be paired together some SME pairing can result in other SMEs having to be implemented in their own GOT instance with the other SME location in the GOT instance unused and hence wasted. Graph theory can be used to optimize SME utilization e.g. reduce the number of unused SMEs in the GOTs by reducing the number of unused SME instances in the GOT instances of the netlist. To use graph theory the compiler first determines all possible pairings between the SME states according to the physical design of the FSM engine discussed above. The compiler then creates a graph where the vertices of the graph correspond to SME states and the edges of the graph correspond to possible pairings of the SME states. That is if two SME states are determined to be capable of being paired together in a GOT instance the two corresponding vertices are connected with an edge. Thus the graph contains all the possible pairings of SME states.

The compiler can then find matching vertices for the graph to identify which SME states to pair together in a GOT . That is the compiler identifies edges and therefore pairs of vertices such that no two edges between matching vertices of the graph share a common vertex. In an example the compiler can find a maximal matching for the graph. In another example the compiler can find a maximum matching for the graph. A maximum matching is a matching that contains the largest possible number of edges. There may be many maximum matchings. The problem of finding a maximum matching of a general graph can be solved in polynomial time.

Once all the matching vertices have been identified e.g. as a maximum matching each pair of SME states corresponding to matching vertices is mapped to a GOT instance. SME states corresponding to vertices that are un matched are mapped to their own GOT instance. That is SME states corresponding to vertices that are un matched are mapped into one of SME location in GOT instance and the other SME location in the GOT instance is unused. Accordingly given the netlist N and its corresponding set of matching vertices M a number of GOT instances of N used equals Q 1 M where Q is the set of states of the automaton and 1 is because in this example the starting state of the automaton does not correspond to an SME state.

In an example the netlist N is constructed from the maximum matching M of G uses the least number of GOT instances. This can be proved by the following if there exists another netlist N that uses a lesser number of GOT instances denote the corresponding matching as M . Since the number of GOT instances of N equals Q 1 M we have that M 

Once the SME states are paired into GOT instances the GOT instances counter instances and logic instances are connected according to the transitions between the states in the automaton. Since each GOT has a single output each GOT instance in the netlist has a single output port to connect to other instances. Accordingly if either SME state in a first GOT instance drives an SME state in a second GOT instance the output port of the first GOT instance is coupled to an input of the second GOT instance.

The netlist is an example of a non optimal netlist. The netlist uses four GOT instances while leaving three SME instances unused. The netlist however is an example of an optimal netlist created using graph theory to identify a maximum matching. The netlist uses three GOT instances and has a single unused SME instance . In the netlist the instance can be connected to instance with connections internal to the GOT instance e.g. via switch .

At block once the netlist has been generated the netlist is placed to select a specific hardware element of the target device e.g. SMEs other elements for each instance of the netlist. According to an embodiment of the present invention placing selects the hardware elements based on general input and output constraints for the hardware elements.

At block the globally placed netlist is routed to determine the settings for the programmable switches e.g. inter block switches intra block switches and intra row switches in order to couple the selected hardware elements together to achieve the connections describe by the netlist. In an example the settings for the programmable switches are determined by determining specific conductors of the FSM engine that will be used to connect the selected hardware elements and the settings for the programmable switches. Routing may adjust the specific hardware elements selected for some of the netlist instances during placement such as in order to couple hardware elements given the physical design of the conductors and or switches on the FSM engine .

Once the netlist is placed and routed the placed and routed netlist can be converted into a plurality of bits for programming of a FSM engine . The plurality of bits are referred to herein as an image.

At block an image is published by the compiler. The image comprises a plurality of bits for programming specific hardware elements and or programmable switches of the FSM engine . In embodiments where the image comprises a plurality of bits e.g. 0 and 1 the image can be referred to as a binary image. The bits can be loaded onto the FSM engine to program the state of SMEs the special purpose elements and the programmable switches such that the programmed FSM engine implements a FSM having the functionality described by the source code. Placement block and routing block can map specific hardware elements at specific locations in the FSM engine to specific states in the automaton. Accordingly the bits in the image can program the specific hardware elements and or programmable switches to implement the desired function s . In an example the image can be published by saving the machine code to a computer readable medium. In another example the image can be published by displaying the image on a display device. In still another example the image can be published by sending the image to another device such as a programming device for loading the image onto the FSM engine . In yet another example the image can be published by loading the image onto a parallel machine e.g. the FSM engine .

In an example an image can be loaded onto the FSM engine by either directly loading the bit values from the image to the SMEs and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs and other hardware elements . In an example the state of the programmable switches e.g. inter block switches intra block switches and intra row switches . In an example the hardware elements e.g. SMEs other elements programmable switches of the FSM engine are memory mapped such that a programming device and or computer can load the image onto the FSM engine by writing the image to one or more memory addresses.

Method examples described herein can be machine or computer implemented at least in part. Some examples can include a computer readable medium or machine readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code such as microcode assembly language code a higher level language code or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further the code may be tangibly stored on one or more volatile or non volatile computer readable media during execution or at other times. These computer readable media may include but are not limited to hard disks removable magnetic disks removable optical disks e.g. compact disks and digital video disks magnetic cassettes memory cards or sticks random access memories RAMs read only memories ROMs and the like.

Thus other embodiments can be realized. For example an article of manufacture such as a computer a memory system a magnetic or optical disk some other storage device or any type of electronic device or system can include one or more processors coupled to a computer readable medium such as a memory e.g. removable storage media as well as any memory including an electrical optical or electromagnetic conductor having instructions stored thereon e.g. computer program instructions which when executed by the one or more processors result in performing any of the actions described with respect to the methods above.

The computer can take the form of a computer system having a processor coupled to a number of components directly and or using a bus . Such components can include main memory static or non volatile memory and mass storage . Other components coupled to the processor can include an output device such as a video display an input device such as a keyboard and a cursor control device such as a mouse. A network interface device to couple the processor and other components to a network can also be coupled to the bus . The instructions can further be transmitted or received over the network via the network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP . Any of these elements coupled to the bus can be absent present singly or present in plural numbers depending on the specific embodiment to be realized.

In an example one or more of the processor the memories or the storage device can each include instructions that when executed can cause the computer to perform any one or more of the methods described herein. In alternative embodiments the computer operates as a standalone device or can be connected e.g. networked to other devices. In a networked environment the computer can operate in the capacity of a server or a client device in server client network environment or as a peer device in a peer to peer or distributed network environment. The computer can include a personal computer PC a tablet PC a set top box STB a Personal Digital Assistant PDA a cellular telephone a web appliance a network router switch or bridge or any device capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that device. Further while only a single computer is illustrated the term computer shall also be taken to include any collection of devices that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The computer can also include an output controller for communicating with peripheral devices using one or more communication protocols e.g. universal serial bus USB IEEE 1394 etc. The output controller can for example provide an image to a programming device that is communicatively coupled to the computer . The programming device can be configured to program a parallel machine e.g. parallel machine FSM engine . In other examples the programming device can be integrated with the computer and coupled to the bus or can communicate with the computer via the network interface device or another device.

While the computer readable medium is shown as a single medium the term computer readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database or associated caches and servers and or a variety of storage media such as the processor registers memories and the storage device that store the one or more sets of instructions . The term computer readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the computer and that cause the computer to perform any one or more of the methodologies of the present invention or that is capable of storing encoding or carrying data structures utilized by or associated with such a set of instructions. The term computer readable medium shall accordingly be taken to include but not be limited to tangible media such as solid state memories optical and magnetic media.

The Abstract is provided to comply with 37 C.F.R. Section 1.72 b requiring an abstract that will allow the reader to ascertain the nature and gist of the technical disclosure. It is submitted with the understanding that it will not be used to limit or interpret the scope or meaning of the claims. The following claims are hereby incorporated into the detailed description with each claim standing on its own as a separate embodiment.

Example 1 includes a computer implemented method for generating an image configured to program a parallel machine from source code. The method includes converting source code into an automaton comprising a plurality of interconnected states converting the automaton into a netlist comprising instances corresponding to states of the automaton wherein the instances correspond to hardware elements of the parallel machine wherein converting the automaton into a netlist includes grouping states together based on a physical design of the parallel machine and converting the netlist into the image.

Example 2 includes a computer readable medium including instructions which when executed by the computer cause the computer to perform operations. The operations including converting source code into an automaton comprising a plurality of interconnected states converting the automaton into a netlist comprising instances corresponding to states of the automaton wherein the instances correspond to hardware elements of the parallel machine wherein converting the automaton into a netlist includes grouping states together based on a physical design of the parallel machine and converting the netlist into the image.

Example 3 includes a computer including a memory having software stored thereon and a processor communicatively coupled to the memory. Wherein the software when executed by the processor causes the processor to convert source code into an automaton comprising a plurality of interconnected states convert the automaton into a netlist comprising instances corresponding to states of the automaton wherein the instances correspond to hardware elements of the parallel machine wherein the instances include a plurality of first instances and a group instance containing two or more first instances wherein convert the automaton into a netlist includes group states together in a group instance based on a number of unused first instances and convert the netlist into the image.

Example 4 includes a system including a computer configured to convert source code into an automaton comprising a plurality of interconnected states convert the automaton into a netlist comprising instances corresponding to states of the automaton wherein the instances correspond to hardware elements of the parallel machine wherein the instances include a plurality of first instances and a group instance containing two or more first instances wherein convert the automaton into a netlist includes group states together in a group instance based on a number of unused first instances and convert the netlist into the image. The system also includes a device configured to load the image onto a parallel machine.

In Example 5 the subject matter of any of Examples 1 4 can optionally include wherein the instances include a state machine element SME instance corresponding to a SME hardware elements and a SME group instance corresponding to a hardware element comprising a group of SMEs and wherein grouping includes grouping states into a SME group instance.

In Example 6 the subject matter of any of Examples 1 5 can optionally include wherein the physical design includes a physical design of the hardware element comprising a group of SMEs.

In Example 7 the subject matter of any of Examples 1 6 can optionally include wherein the physical design includes one of an input or output limitation on the SMEs in the hardware element comprising a group of SMEs.

In Example 8 the subject matter of any of Examples 1 7 can optionally include wherein the physical design includes a limitation that the SMEs in the hardware element comprising a group of SMEs share an output.

In Example 9 the subject matter of any of Examples 1 8 can optionally include wherein a SME group instance includes a group of two GOT instance containing two SME instances and wherein the physical design includes that the SMEs in each GOT are coupled to a common output.

In Example 10 the subject matter of any of Examples 1 9 can optionally include wherein converting the automaton into a netlist comprises determining which of the states can be grouped together in a GOT instance and pairing the states based on the determination.

In Example 11 the subject matter of any of Examples 1 10 can optionally include wherein a first and a second state can be paired together in a GOT instance when neither the first nor the second state are a final state of the automaton and one of the first and the second state does not drive any states other than the first or the second states.

In Example 12 the subject matter of any of Examples 1 11 can optionally include wherein a first and a second state can be paired together in a GOT instance when neither the first nor the second state are a final state of the automaton and both the first and the second state drive the same external states.

In Example 13 the subject matter of any of Examples 1 12 can optionally include wherein a first and a second state can be paired together in a GOT instance when one of the first and the second state are a final state of the automaton and the other of the first and the second states does not drive any external states.

In Example 14 the subject matter of any of Examples 1 13 can optionally include wherein a first and a second state can be paired together in a GOT instance when both the first and second state are final states of the automaton and both the first and the second state drive the same external states.

In Example 15 the subject matter of any of Examples 1 14 can optionally include wherein determining which of the states can be grouped together in a GOT instance comprises determining which of the states can be grouped together in a GOT instance using graph theory.

In Example 16 the subject matter of any of Examples 1 15 can optionally include wherein determining which of the states can be grouped together in a GOT instance using graph theory comprises determining which of the states can be grouped together in a GOT instance using graph theory to identify a maximum matching.

In Example 17 the subject matter of any of Examples 1 16 can optionally include publishing the image.

In Example 18 the subject matter of any of Examples 1 17 can optionally include wherein the instances comprise general purpose instances and special purpose instances wherein the general purpose instances correspond to general purpose states of the automaton and the special purpose instances correspond to special purpose states of the automaton.

In Example 19 the subject matter of any of Examples 1 18 can optionally include wherein the hardware elements corresponding to the general purpose instances include a state machine elements SME and a group of two GOT and wherein the hardware elements corresponding to the special purpose instances include counters and logic elements.

In Example 20 the subject matter of any of Examples 1 19 can optionally include wherein the automaton is a homogonous automaton.

In Example 21 the subject matter of any of Examples 1 20 can optionally include wherein converting the automaton into a netlist comprises mapping each of the states of the automaton to an instance corresponding to the hardware elements and determining the connectivity between the instances.

In Example 22 the subject matter of any of Examples 1 21 can optionally include wherein the netlist further comprises a plurality of connections between the instances representing conductors between the hardware elements.

In Example 23 the subject matter of any of Examples 1 22 can optionally include wherein converting the automaton into a netlist comprises converting the automaton into a netlist comprising instances corresponding to states of the automaton except for a starting state.

In Example 24 the subject matter of any of Examples 1 23 can optionally include determining the location in the parallel machine of the hardware elements corresponding to the instances of the netlist.

In Example 25 the subject matter of any of Examples 1 24 can optionally include wherein grouping states together includes grouping states together based on a physical design of a hardware element comprising a group of general purpose elements.

In Example 26 the subject matter of any of Examples 1 25 can optionally include determining which conductors of the parallel machine will be used to connect the hardware elements and determining settings for programmable switches of the parallel machine wherein the programmable switches are configured to selectively couple together the hardware elements.

In Example 27 the subject matter of any of Examples 1 26 can optionally include wherein the group instance includes a group of two GOT instance and wherein group states includes pair states as a function of which states the paired states drive.

In Example 28 the subject matter of any of Examples 1 27 can optionally include wherein group states in a group instance based on a number of unused first instances includes determine whether a first state and a second state can be paired based on the following conditions neither the first state or second state are final states in the automaton and one of the first state and second state does not drive any states other than the first or second states neither the first or second state are final states in the automaton and both the first state and the second state drive the same external states either the first state or the second state are a final state and the first state or second state that is not a final state does not drive any states except the first state or second state and both the first state and the second state are final states and both the first state and the second state drive the same external states.

In Example 29 the subject matter of any of Examples 1 28 can optionally include wherein convert the automaton into a netlist includes model the states as a graph wherein vertices of the graph correspond to states and edges of the graph correspond to possible pairings of the states determine matching vertices for the graph and pair states corresponding to the matching vertices.

In Example 30 the subject matter of any of Examples 1 29 can optionally include wherein convert the automaton into a netlist includes determine a maximum matching for the graph.

In Example 31 the subject matter of any of Examples 1 30 can optionally include wherein convert the automaton into a netlist includes pair each set of states corresponding to a matching vertices and map each state that corresponds to an unmatched vertex to a GOT instance wherein one SME instance in the GOT instance is to be unused.

In Example 32 the subject matter of any of Examples 1 31 can optionally include wherein group states together includes pair states as a function of which states the paired states drive.

In Example 33 the subject matter of any of Examples 1 32 can optionally include wherein group states together in a group instance based on a number of unused first instances includes determine whether a first state and a second state can be paired based on the following conditions neither the first state or second state are final states in the automaton and one of the first state and second state does not drive any states other than the first or second states neither the first or second state are final states in the automaton and both the first state and the second state drive the same external states either the first state or the second state are a final state and the first state or second state that is not a final state does not drive any states except the first state or second state and both the first state and the second state are final states and both the first state and the second state drive the same external states.

In Example 34 the subject matter of any of Examples 1 33 can optionally include wherein group states together in a group instance based on a number of unused first instances includes model the states as a graph wherein vertices of the graph correspond to states and edges of the graph correspond to possible pairings of the states determine matching vertices for the graph and pair states corresponding to the matching vertices.

In Example 35 the subject matter of any of Examples 1 34 can optionally include wherein group states together in a group instance based on a number of unused first instances determine a maximum matching for the graph.

In Example 36 the subject matter of any one of Examples 1 35 can optionally include wherein group states together in a group instance based on a number of unused first instances includes pair each set of states corresponding to a matching vertices and map each state that corresponds to an unmatched vertex to a GOT instance wherein one SME instance in the GOT instance is to be unused.

In Example 37 the subject matter of any of Examples 1 36 can optionally include wherein the device is configured to implement each pair of states as a group of two hardware element in the parallel machine.

Example 38 includes a parallel machine programmed by an image produced by the process of any of Examples 1 37.

