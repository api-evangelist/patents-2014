---

title: System and method for model-based inventory management of a communications system
abstract: A method for management entity operations includes receiving a request to collect data for an entity in a communications system, collecting the data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system, and saving the data collected.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09558454&OS=09558454&RS=09558454
owner: Futurewei Technologies, Inc.
number: 09558454
owner_city: Plano
owner_country: US
publication_date: 20140307
---
The present disclosure relates generally to managing networked communications systems and more particularly to a system and method for model based inventory management of a communications system.

Communications systems have changed life in the modern world by enabling users access to a wide range of services. As an example a first user may remotely access a work computer using a laptop from home or a conference room while on a business trip a second user may visually verify that his children has arrived home safely from a day at school on his desktop computer at work a third user may watch a favorite movie on a smart telephone a fourth user may initiate the cooking of dinner from a digital tablet and the like.

In order to support such a wide range of users services and access technologies the communications systems have become increasingly complex. Additionally the number of hardware and software components as well as hardware and software types making up the communications systems has also increased. The increased complexity of the communications systems along with increased number and type of hardware and software components help to make the configuration and management of the communications systems more difficult and potentially error prone.

Example embodiments of the present disclosure which provide a system and method for model based inventory management of a communications system.

In accordance with an example embodiment of the present disclosure a method for management entity operations is provided. The method includes receiving by a management entity a request to collect data for an entity in a communications system collecting by the management entity the data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system and saving by the management entity the data collected.

In accordance with another example embodiment of the present disclosure a management entity is provided. The management entity includes a receiver and a processor operatively coupled to the receiver. The receiver receives a request to collect data for an entity in a communications system. The processor collects the data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system and saves the data collected.

In accordance with another example embodiment of the present disclosure a management system is provided. The management system includes a managed entity and a management entity operatively coupled to the managed entity. The management entity including a receiver that receives a request to collect data for the managed entity in a communications system and a processor operatively coupled to the receiver. The processor collects the data for the managed entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system and saves the data collected.

In accordance with another example embodiment of the present disclosure a method for management entity operations is provided. The method includes receiving by a management entity a request to collect data for an entity in a communications system collecting by the management entity data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system and detecting by the management entity that the data collected includes an object that cannot be recognized. The method also includes replacing by the management entity the unrecognizable object in the data collected with an equivalent recognizable object thereby producing revised data collected and saving by the management entity the revised data collected.

In accordance with another example embodiment of the present disclosure a management entity is provided. The management entity includes a receiver and a processor operatively coupled to the receiver. The receiver receives a request to collect data for an entity in a communications system. The processor collects data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system detects that the data collected includes an object that cannot be recognized to replace the unrecognizable object in the data collected with an equivalent recognizable object thereby producing revised data collected and saves the revised data collected.

In accordance with another example embodiment of the present disclosure a method for management entity operations is provided. The method includes receiving by a management entity a request to collect data for an entity in a communications system collecting by the management entity data for the entity and detecting by the management entity that the data collected contains an object that cannot be recognized. The method also includes determining by the management entity that the unrecognizable object is a new object not previously known to the management entity defining by the management entity a new Abstract Data Type ADT to represent the behavior of the unrecognizable object and mapping by the management entity the new ADT to a new model element in an information model. The method further includes mapping by the management entity the new model element in the information model to a new model element in a data model and saving by the management entity the new model element in the information model.

In accordance with another example embodiment of the present disclosure a management entity is provided. The management entity includes a receiver and a processor operatively coupled to the receiver. The receiver receives a request to collect data for an entity in a communications system. The processor collects data for the entity detects that the data collected contains an object that cannot be recognized determines that the unrecognizable object is a new object not previously known to the management entity defines a new Abstract Data Type ADT to represent the behavior of the unrecognizable object maps the new ADT to a new model element in an information model maps the new model element in the information model to a new model element in a data model and saves the new model element in the information model.

One advantage of an embodiment is that the use of model driven techniques for data collection allows for a consistent and scalable approach to configuring and managing a communications system.

A further advantage of an embodiment is that the use of policy rules allow for efficient and easy deployment of the communications system wherein changes to the communications system are detected and reflected in the configuring and managing of the communications system.

The operating of the current example embodiments and the structure thereof are discussed in detail below. It should be appreciated however that the present disclosure provides many applicable inventive concepts that can be embodied in a wide variety of specific contexts. The specific embodiments discussed are merely illustrative of specific structures of the disclosure and ways to operate the disclosure and do not limit the scope of the disclosure.

One embodiment of the disclosure relates to inventory management of a communications system. For example in a management system a management entity receives a request to collect data for one or more entities in a communications system. The management entity collects the data for the one or more entities utilizing a set of protocols selected using knowledge defined by one or more data models in a data model list derived from an information model of the communications system. The management entity saves the data collected. As another example the management entity collects data for one or more entities in a communications system and generates a function to transform the collected data from a first schema into a second schema wherein the collected data is in the first schema defined by one or more data models derived from an information model of the communications system. The management entity applies the function to the collected data.

The present disclosure will be described with respect to example embodiments in a specific context namely a model based management system for a communications system wherein the management system utilizes models to drive the collection of data for the communications system. The data being collected may be categorized as operational administrative management and performance data. The communications system may be a standards compliant communications system such as 3GPP LTE WiMAX IEEE 802.11 IEEE 802.16 and the like a non standards compliant communications system or a combination of one or more technical standards compliant communications system with one or more non standards compliant communications system.

Communications systems are generally dynamic. Not only do their logical topologies change dynamically new physical devices are added while existing physical devices are moved or removed. The dynamic nature of communications systems makes maintaining a real time list of network devices along with one or more attributes that can be used to identify them e.g. Internet Protocol IP addresses port information and the like challenging. Additionally new applications modules or versions of software including both operating systems and software applications may be downloaded and hardware e.g. RAM CPUs hard drives solid state memories network cards and the like may be changed.

Network discovery may be scheduled to occur at pre defined times and or intervals it may also be performed on an as needed basis. Since a typical communications system is large such network discovery operations usually involve a large amount of processing. Typically network discovery is collector based and multiple scanning methods such as ping sweeps port scans simple network management protocol SNMP scans searching for different types of SNMP attributes and the like may be utilized.

However applications for network inventory vary. High end applications utilize network discovery and generate open systems interconnection OSI level 1 2 and 3 topological views of the communications system. Higher end applications include network devices operating systems high level application data e.g. CPU disk memory uptime utilization and the like . Once the views of the communications systems are generated changes to the communications system can be quickly detected.

There may be dependencies between the type of data being discovered and or inventoried and the type of protocols being used to discover and or report the data. There may be an important dependency between the type of protocol used to collect the data and the type of data to be collected. As an example if SNMP is used then there are various management information base MIB objects defined that differentiate between hosts and devices that forward datagrams e.g. a device that acts as a router . It is noted that this does not mean that the device is a router for example a layer three switch may also act as a router. More importantly a other protocols may not have this capability defined b other protocols may define a set of capabilities that have more or less functionality than this capability and or c this differentiation may not be enough to accurately classify a particular network entity.

As another example the type of ManageableEntity may have specific attributes and or behavior that dictate the need to use a specific type of protocol. For example a port that is defined as a bridge sends bridge packet data units BPDUs whereas the same port may send different PDUs for communication at different layers. This is made more complex because higher layers such as layers 5 7 do not refer to a PDU per se but rather to the actual data or transfer of the data .

As yet another example the selection of the type of data to collect affects the type of protocol to use when looking for specific types of neighbors for a specific entity type. For example if discovery is performed on a port whose role is a Provider Edge role then in some circumstances that port can connect to other ports with a role of Customer Edge Provider Edge or Provider Core . While in other circumstances it may be limited to only looking for ports whose role is Provider Edge . Furthermore if that same port was using multiprotocol label switching MPLS then it could also look for Label Switching Routers as well as ingress egress and other types of MPLS routers.

As yet another example the type of attributes that an entity has when looking for specific types of functionality that a device or port has can also dictate the use of a specific protocol to use because the data to be retrieved may be very specific. For example a device may be interested in determining if a node supports neighbor discovery such as active reservation protocol ARP or neighbor discovery protocol NDP capability or how a node obtains its address es e.g. by using bootstrap protocol BOOTP or dynamic host configuration protocol DHCP .

The above discusses several types of dependencies between protocols used to collect data and the data to be collected. There may also be relationships between the data to be collected and the type s of pre and post processing operations that should be performed on the collected data to make said data more useful to the management system and which data if any should be stored in what type of repository at what step in the above operations e.g. pre processing or post processing. The set of these dependencies and relationships require coordination and optimization of computational and storage resources. The example embodiments presented herein may use the knowledge represented in an information model to define the characteristics and behavior of model elements that represent ManageableEntities as well as to represent different types of decision making and reasoning processes and rules to govern the application of said processes.

First entity may manage as well as interact with second entity through one or more levels. As an example management may occur at an operating system level where first entity may utilize a protocol such as web management interface WMI to manage second entity . Management may also occur at a software level where first entity may utilize a protocol such as command line interface CLI SNMP representation state transfer REST and the like to manage second entity . Management may also occur at an application level where first entity may utilize a protocol such as system log SYSLOG REST and the like to manage second entity . Management may also occur at a hardware level where first entity may utilize a protocol such as SNMP machine to machine extensible markup language M2MXML and the like to manage second entity . Entities and are aspects of the system being managed the management system may obtain their current state values and or configuration information from second entity and may then change one or more of these aspects i.e. entities and as part of its management processes.

The example embodiments presented herein uses an object oriented information model to define managed entities e.g. entities in a communications system of interest. The discussion presented herein will make use of the following terminology 

First entity may examine the data that is requested to be collected from management request and compares this request with the capabilities of second entity in order to determine how best to obtain the data requested. A problem is that many elements in the data collection process may be dependent on each other. As an example the type of protocol used can affect which data can be collected and at what frequency granularity and other factors. These and other dependencies are modeled using Information Model . As an example the exchange of capabilities request and capabilities response messages define which protocols are supported by both first entity and second entity . Using the protocols first entity may then issue a set of data requests to appropriate ManageableEntities that comprise second entity where each ManageableEntity in second entity may use the same or a separate protocol.

As an illustrative example a Hypertext Transfer Protocol Secure HTTP S capability request may be sent by first entity to second entity to provide various performance metrics such as the time since its last reboot the amount of memory currently being used and so forth. Such metrics may typically be supported by multiple protocols e.g. Simple Network Management Protocol SNMP System Log Syslog Command Line Interface CLI and others however each protocol may use a different set of resources and have a different accuracy. It is possible that first entity through use of information model will first optimize the request for data from second entity by optimizing the use of the same protocol where possible to get the best data possible. The set of ManageableEntities that comprise second entity may be defined by data model of second entity and data model may be derived from information model .

Hence first entity may use a particular protocol with a specific management interface to request specific data from second entity e.g. WMI for Operating System data CLI for software SNMP for hardware and the like . It is noted that a protocol may be used to support one or more types of data and that a particular type of data may require multiple protocols to obtain all of the information that constitute a particular type of data for example this is illustrated in by using the combination of CLI SNMP and REST to retrieve all of the Software information from second entity . These requests then query the appropriate ManageableEntities that are part of second entity . Replies to the query or queries may come back through the same management interface of second entity that the requests were received. First entity may then read the collected data optionally process and store it and then either notify a requestor of the data that the data is ready or directly send the data to the requestor.

There may be several types of data models. A first data model type may be a technology specific but vendor neutral instantiation of information model . As an example data models are technology specific but vendor neutral instantiations of information model and could represent concepts using a directory a relational database and a flat file. A second data model type is a technology specific and vendor specific instantiation of information model . As an example data models are technology specific and vendor specific instantiations of information model as well as data model .

A benefit of using the information model is that it provides a self describing set of mechanisms that define how knowledge can be used to describe the semantics of characteristics and behavior of a ManageableEntity including its attributes and relationships.

Management system may also include a data collection system to collect data from entities in communications system . Data collection system may make use of one or more protocols as specified by management entity to collect data from communications system . Data collection system may stream data using a streaming data unit to management entity . The streamed data may be delivered out of order fragmented with some data missing and the like. Some data may be retrieved using specific protocols under specific conditions. A management graphical user interface GUI may allow users such as operators managers and the like to interact with management entity as well as communications system .

Using an information model of a communications system allows for a common set of model elements that can be used to define interrelated semantics that exist between the type of data to be collected the type of protocols used to collect the data the type of pre processing and post processing operations that are to be performed on the collected data which data if any should be stored in what type of data repository and the like. Each of these interrelated semantics may represent dependencies between these fundamental portions of the data collection process. Furthermore each are uni directional. For example the type of data that is to be collected restricts the type of protocol that can be used since the type of protocol may need to satisfy a number of requirements including 1 the protocol may need to be able to transport the data reliably and possibly securely meaning that the accuracy of each datum as well as the entire data set should not be altered and 2 the protocol may need to be able to support appropriate operations e.g. create read update delete and the like on the data. Similarly the protocol constrains the type of data in that the protocol 1 may need to be able to support the data structures that are used by the data to be collected and 2 the protocol may need to be semantically compatible with the use of the data. For example while directories can theoretically store and retrieve any type of data structure their protocol e.g. the Lightweight Directory Access Protocol LDAP or even its stronger and more robust version X.500 a set of standards defining directory services by the ITU T was designed primarily to be used with simple textual search applications. This may place a fundamental limitation on how data can be searched created edited and retrieved in a directory.

If the above dependencies are understood and satisfied then a unified platform may be built i.e. a platform that is independent of the technology used to implement the type of protocol the type of ManageableEntity the type of data to be collected the types of pre processing and post processing operations to be performed the types of storage operations and storage to be performed and the like. In particular the unified platform allows for 

Data collection system may include an initiating process that controls the collection of the data including starting and or stopping the collection of the data. Also included may be a collector manager that is responsible for collecting the data provided by a plurality of collector agents such as collector agent . Since the data provided by the plurality of collector agents may be fragmented out of order lost and the like collector manager may unfragment or equivalently defragment reorder correct and or recover the collected data. The collected data may be provided to management entity . Data collection system may receive instructions on the data to be collected from management entity .

The data collected i.e. the data collected from the ManageableEntity or set of ManageableEntities may be used to discover if new capabilities have been added to an existing ManageableEntity e.g. a new card was added having additional ports or if new ManageableEntities have been added to the communications system e.g. a new Virtual LAN VLAN was created . These two examples correspond to the management system being able to detect the addition of new physical and logical or virtual capabilities of the system being managed. Similarly data collection may be used to discover if existing ManageableEntities and or their capabilities have been removed from the system or are no longer functioning properly. The data collected may also be used for collecting metrics usable in calculating and or estimating a performance level of a ManageableEntity. The metrics may also be used to generate alarms and or faults optimize the performance of the ManageableEntity perform maintenance operations execute additional management operations and the like. These operations commonly referred to as operational and or management operations may be more complex since different types of ManageableEntities have different types of characteristics and behavior. Furthermore a single instance of a ManageableEntity may exhibit different behavior in different contexts. Therefore a robust mechanism may be needed to relate the impact of a context on the collection of the data.

Data collection may also be used to query existing parent and or child nodes to determine additional information about each node. Generally given a set of known ManageableEntities referred to herein as parent nodes each parent node may have a set of child ManageableEntities e.g. ports of a ManageableEntity or services of an application . As an example the type of node will often determine the type s of ManageableEntity that may be related to that node as well as protocol media layer and other physical and or logical characteristics that form semantics of those relationships. Examples include port bonding and link aggregation which are a function of the type of port type of media and the type of protocol being used . Different types of VLANs and Virtual Private Networks VPNs have similar semantics. Similarly services may also be found from parent nodes and or child nodes using several different protocols e.g. simple service discovery protocol SSDP service location protocol SLP universal plug and play UPnP and the like . These protocols have different applications and hence different semantics. Hence the information model provides a single source for representing different types of ManageableEntities and their relationships using a common set of model elements with a common set of semantics.

Usually data collected from ManageableEntities attached to one or more communications systems will be intermingled making it difficult to associate data with a specific ManageableEntity to which it belongs. This may be exacerbated by change e.g. ManageableEntities can join or leave communications systems without the management system being informed. Furthermore ManageableEntities may be changed. As an example the configuration of a ManageableEntity s configuration may be changed which alters the functionality that the ManageableEntity provides. The information model of the communications system provides the knowledge needed to recognize one or more capabilities of a ManageableEntity or a set of ManageableEntities. Management of heterogeneous entities may therefore be normalized by matching common aspects of different capabilities of each of the different ManageableEntities. Once a set of common capabilities is determined further processing may continue if needed across applicable sets of ManageableEntities.

An information model may be used to optimize the data collection process or set of processes for obtaining data from all or a subset of ManageableEntities. The optimization may be based on optimization factors including the nature of the data to be collected the type of ManageableEntities involved the type of protocols that are used the context of the communications system needs of users and or applications of the collected data and the like. Optimizations may include determining which users and or applications need the same data and optimizing the collection of the data so that the data is queried as few times as possible use the same protocol and optimizing the collection of the data so that the number of protocol connections is minimized and use the same commands e.g. vendor specific CLI vendor neutral scripting languages and the like to query different attributes of the same or different ManageableEntities and optimizing the collection of the data optionally with different attributes being filtered differently .

The behavior of a ManageableEntity A may be defined as a set of intrinsic attributes and or relationships that involve ManageableEntity A and or a set of extrinsic classes attributes and or relationships between the ManageableEntity A and a set of model elements that represent one or more ManageableEntities B. . . B. It is noted that the definition also holds when the single ManageableEntity A is replaced with a set of ManageableEntities A. . . A. The use of an information model may enable behavior to be statically defined and managed through a set of mechanisms that are themselves expressed in the information model e.g. by using a dedicated set of model elements such as policy rules and or state automata. It may also be possible to dynamically define behavior as well as enable changes in behavior.

The use of the information model may allow the management entity to be independent of technology specific implementation. This is applicable to the protocols used as well as the type of data to be collected the type of ManageableEntity that is the target for the data collection operations e.g. storage device vs. network device vs. server vs. application how that data is collected the type of pre and post processing done on the collected data the type of storage used for the collected data how the ManageableEntities themselves are represented and the like. Furthermore the management entity is independent of data collection mechanism e.g. collection agents agentless collection or a combination thereof.

Operations may be partitioned into two distinct operations. A first operation may involve collecting the data which may be referred to as data collection and a second operation may involve transforming the collected data into a form compliant with a specified schema which may be referred to as data transformation .

Operations may begin with the management entity receiving a request to collect inventory data block . The request may be in the form of input from a user of the management entity an application executing in the management entity or another management entity an external management entity another instantiation of the management entity such as in a distributed inventory management system and the like.

The management entity may perform data collection based upon the request to collect inventory data block . Data collection is described in additional detail in . Referencing forward to which illustrates a high level overview of the principal operations required to collect data the request to collect inventory data may be parsed to determine dependencies present in the request and to form a dependency list block . Parsing the request to determine dependencies is explained in greater detail below.

Referencing now to which illustrates a flow diagram of operations occurring in the beginning of the determining of a dependency list that enumerates the different dependencies between type of data protocol used to collect the data pre and post processing and pre and post storage the management entity may parse the request to collect inventory data block . In general the parsing of the request produces a set of objects such as a set of objects generated by a parsing process that uses either an abstract syntax tree or a concrete syntax tree. In an example embodiment a constituency based parse tree may be used where the grammar differentiates between terminal and non terminal categories. However it should be noted that any parsing mechanism may be used.

The management entity may examine the objects produced by the parsing operation in block and subsequently attempt to identify a mechanism for representing types of data that will be gathered for this data collection request block . An object of the examination may be to understand explicit as well as implicit semantics in the request to collect data so that dependencies between the type of data protocol used pre and post processing and pre and post storage functions that make up the data collection process may be defined.

There may be several techniques that may be used to determine the different dependency relationships that may exist in the request to collect data. According to an example embodiment a set of Abstract Data Types ADTs that were used to define the information model is used to help determine the different dependency relationships that may exist as part of the data collection process. Typically an ADT is a formal model of a set of data structures that have similar characteristics and behavior with formal meaning having a mathematical model. The presence of the mathematical model enables the ADT to represent building blocks e.g. a stack queue array graph and the like of the model in a technology independent way. The ADTs may be used to help transform the information model from a technology neutral to a technology specific i.e. a data model form. The ADTs may also be used to describe algorithms the different types of data structures that a given implementation requires e.g. the programming languages used to build the data structures and the associated data models and evaluate which algorithms and data structures are optimal for a given application. A generic algorithm is used herein to define ADTs. An example embodiment of this algorithm is shown below.

Referring now to and where a flow diagram of operations occurring in the determining of Abstract Data Types are illustrated. The flow diagram illustrates a technique that may be used to determine ADTs for use in creating a dependency list. Operations may begin with the management entity initializing a set of seven counters i j k m n p or q block . As an example the counters are each initialized to 0. As an illustrative example counter i is used to keep track of the parsed collection request objects and counters j q are used to keep track of the six dependency types respectively. The management entity may retrieve the i th object or set of objects in the set of parsed objects from the current request to collect data block . The management entity may map the i th object or set of objects into at least one model element that is defined in the information model block . As an example if the i th object is a simple determiner e.g. definite and indefinite articles such as the demonstratives such as that interrogatives such as which quantifiers such as all numerals such as ten fractions such as one half and possessive determiners such as my and so forth then the management entity knows that it may temporarily store the i th object and retrieve the next object. This is because the function of a determiner is to add context to the noun or noun phrase that immediately follows the determiner. Hence such an object must be examined together with the noun or noun phrase that it applies to. As an alternative if the management entity identifies a noun phrase then the i th object may instead be the determiner along with the noun or noun phrase that it applies to.

As yet another example if the i th object being examined by the management entity is the noun phrase all devices then this may be interpreted as every object that can be instantiated from the device class as defined in the information model. As yet another example if the i th object being examined by the management entity is the noun phrase all devices whose IP address is 192.168.0.0 16 then this may be satisfied either by all objects that can be instantiated from the device class whose IP attribute is equal to 192.169.0.0 16 and or all objects that can be instantiated from the device class that aggregate an IPAddress object where an attribute of the IPAddress object is its address i.e. 192.168.0.0 16 . It is noted that in the two examples above the number of model elements that are mapped to are 1 2 and 4 which correspond to a single object an object with a particular attribute value and an object a relationship or another object with a particular attribute value respectively. It is also noted that other combinations of model elements are also possible. Since a variety of parser techniques and a variety of different analysis methods may be used the techniques shown in and are intentionally generic and used for illustrative purposes only and do not limit the scope or the spirit of the example embodiments. Hence the management entity may retrieve one or more objects from the parsing process block and it may map one or more parsed objects to one or more attributes of an information model block .

The management entity may map the at least one model element from the information model to at least one data structure block . It is noted that zero or more metadata objects may also be defined as part of the mapping. The mapping performed by the management entity may comprise either the model elements or references to the model elements and may be realized as any appropriate data structure such as an array of complex objects. The mapping captures the syntactical restrictions of the type of data being analyzed. The management entity may store a reference to each data structure and metadata into a set of eighth objects block . According to an example embodiment a reference to each data structure and metadata is grouped into its own dictionary a first dictionary . While in an alternative scenario other data structures such as a set or an associative array may be used instead as long as the other data structures ensure that each member is unique and associated with a unique key. In this alternative scenario the key may be the current value of i.

The management entity may capture the semantic restrictions of the type of data being analyzed by mapping each behavior of the parsed request to collect data to at least one operation axiom pre condition post condition and or invariant block . Each of these objects may have one or more metadata objects associated with them in order to express context restrictions or other factors that influence the semantics. The management entity may store a reference to each data structure and metadata into a set of eighth objects block . Each reference to each data structure and metadata is grouped into its own second dictionary. Again the key in this scenario may be the current value of i.

The management entity may combine the two dictionaries the first dictionary and the second dictionary into a single dictionary of dictionaries block . The combination of the two dictionaries enables the features syntax and behavior semantics of the at least one model element to be described below in as generic a manner as possible while still enabling efficient access to the features and or behavior of the at least one model element.

At this point the management entity may define zero or more ADTs representing the syntactical and semantic requirements from blocks and respectively block . The zero or more ADTs are defined by matching the syntactical and semantic requirements from blocks and to a list of ADTs that were used to construct the information model. The management entity may test to see if any ADTs were found block . If one or more ADTs were found then the management entity may add each newly found ADT to the appropriate set of objects second third eleventh thirteenth fifteenth or seventeenth respectively block . Discussion of the technique continues with . Furthermore if no ADTs were found in block then the management entity may also continue to .

The management entity may increment an appropriate counter i.e. j k m n p or q depending on the type of ADT that was identified type of data protocol pre processing post processing pre storage or post storage respectively block . The management entity may test to determine if there are any dependencies between the newly defined ADT and any existing ADTs block . The mapping may make use of types of constraints including a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype a subtype a supertype or a combination thereof. If there are not any dependencies between the newly defined ADT and any existing ADTs then the management entity proceeds to block to increment the counter. If there are dependencies between the newly defined ADT and any existing ADTs then the management entity may maps the functional requirements of each dependency found between the newly defined ADT and each existing ADT into its own new data structure block . The mapping may optionally be enhanced with metadata. It is noted that multiple dependencies may exist between the same objects. In such a situation each dependency is mapped into its own separate data structure.

The management entity may store the mapping as a third data dictionary and attaches the third data dictionary to the dictionary of dictionaries block . The management entity may map the behavioral semantic requirements of each dependency into its own separate data structure block . The management entity may store the mapping as part of each corresponding third data dictionary i.e. the third data dictionary that had functional dependencies between the two ADTs being compared if applicable and attaches the third data dictionary to the existing dictionary of dictionaries block .

The management entity may increment counter i block and then the management entity may check to determine if any additional parsed objects remain block . If there are remaining parsed objects then the management entity returns to block . Otherwise these operations terminate and returns control to block of .

Referencing back to the result of block e.g. blocks of and comprises at least one of a set of first ADTs to represent the types of data that are to be used during the data collection process. The parsed output may help identify additional semantics that may be embedded in the request to collect data. In general the ADTs identify a set of characteristics and behavior required of the data to be collected in a technology neutral manner. Therefore the same ADTs may be used to define the different objects required for completing the request to collect data in a technology neutral manner. It also enables the same ADTs to be used for different types of data produced by different applications and which exist in different scenarios since ADTs are used to guide the implementation via mapping from an information model to a data model.

As an example a user may have requested that all devices that interact with Carrier X should have their inventory data updated. An information model processing unit of a management entity can locate an abstract class called Device in the information model but may not know which instantiated objects of that abstract class that are defined in its data models to use without parsing the request and realizing that the devices should have a relationship with Carrier X. The relationship is defined in the request generically so the relationship could include ownership the ability to transport traffic the ability to backup data for Carrier X and other roles. Similarly the information model processing unit of the management entity may not know what Carrier X is or means since the information model is a generic model and does not define specific vendors. However by parsing the request it may be able to determine that for this request Carrier X is the name of a service provider. Hence it will be able to assign a subclass of the ServiceProvider class which is used to represent different types of carriers and providers to this role by using the model elements defined in that subclass. The assignment of the subclass includes inherited attributes constraints and relationships as well as attributes constraints and relationships that are defined for that particular subclass. Similarly the information model processing unit of the management entity may not know how to detect dependencies between types of data protocols pre and post processing and pre and post storage without examining either instantiated objects or their more abstract equivalent such as ADTs. Finally the information model processing unit of the management entity may not know how to create a data model with appropriate object instances to represent the request to collect information. explains how the dependency list is generated. The example will be used throughout the remaining discussion to show how the information processing units and data processing units and other units operate.

The management entity may use the ADTs to help map the request to collect data to different types of objects and data structures that are used by the data being requested block . The mapping may enable the management entity to be able to better identify the types of data that should be present when the data is collected. The management entity may save references to the set of first ADTs as a set of second objects block . The result of blocks and are then checked by the management entity in block . If no data was parsed or if no ADTs were found then the content is logged for further processing and the technique terminates in a fatal error block . In contrast if data was parsed and if at least one ADT was found then the management entity proceeds to block .

Similar to blocks and the management entity performs a similar set of operations in blocks and but for protocol dependencies instead of data dependencies. The management entity may examine the objects produced by the parsing operation in block to help determine the different dependency relationships that may exist that involve a protocol and other elements that are part of the data collection process block . It is noted that the presence of at least one protocol is mandatory since a protocol is required to collect data. As an example specific types of data may require a particular protocol to be used to transmit and receive the data without error. As another example a particular datum may have one representation in data model that requires protocol X but a different representation in data model that requires protocol Y. In this approach the same ADT can be used in both cases to detect dependencies.

The management entity may examine the parsed output of the request to collect data and maps that output to at least one of a set of second ADTs to represent the types of data that are to be used during the data collection process block . The parsed output may help to identify additional semantics that may be embedded in the request to collect data. The ADTs identify a set of characteristics and behavior required of a protocol in a technology neutral manner. The result of blocks and are then checked by the management entity in block . If no data was parsed or if no ADTs were found then the content is logged for further processing and the technique terminates in a fatal error block . In contrast if data was parsed and if at least one ADT was found then management entity proceeds to block .

Similar to blocks and the management entity performs a similar set of operations in blocks and but for pre processing dependencies instead of data dependencies. The management entity may examine the objects produced by the parsing operation in block to help determine the different dependency relationships that may exist that involve a pre processing operation and other elements that are part of the data collection process block . The management entity may examine the parsed output of the request to collect data and maps that output to at least one of a set of third ADTs to represent the pre processing operations that are to be used during the data collection process as a set of eleventh objects block . The parsed output may help to identify additional semantics that may be embedded in the request to collect data. The ADTs may identify a set of characteristics and behavior required of a set of pre processing operations in a technology neutral manner. It is noted that blocks and may be optional since a pre processing operation is not always mandatory.

The management entity may continue to block where it determines whether a pre processing operation is mandatory based on parsing the request to collect data. If the request is not mandatory the management entity proceeds to block . If a pre processing operation is mandatory then management entity proceeds to block where the management entity tests to determine if any data as well as any ADTs were found. If either data and or ADTs were not found the management entity continues to block where the context is logged and the technique exits with a fatal error. In contrast if both data and ADTs were found the management entity proceeds to block . As an example specific types of data may require a particular set of pre processing operations to be used as the data is being collected in order to reduce the amount of data that has to be analyzed as part of the data collection process.

Similar to blocks and the management entity performs a similar set of operations in blocks and but for post processing dependencies instead of data dependencies. The management entity may examine the objects produced by the parsing operation in block to help determine the different dependency relationships that may exist that involve a post processing operation and other elements that are part of the data collection process block . The management entity may examine the parsed output of the request to collect data and maps that output to at least one of a set of fourth ADTs to represent the post processing operations that are to be used during the data collection process as a set of thirteenth objects block . The parsed output may help to identify additional semantics that may be embedded in the request to collect data. The ADTs may identify a set of characteristics and behavior required of a set of post processing operations in a technology neutral manner. It is noted that blocks and may be optional since a post processing operation is not always mandatory.

The management entity may continue to block where it determines whether a post processing operation is mandatory based on parsing the request to collect data. If the request is not mandatory the management entity proceeds to block point A of . If a post processing operation is mandatory the management entity proceeds to block where it tests to determine if any data as well as any ADTs were found. If either data and or ADTs were not found the management entity continues to block where the context is logged and the technique exits with a fatal error. In contrast if both data and ADTs were found the management entity proceeds to block point A in . As an example specific types of data may require a particular set of post processing operations to be used after all of the data has been collected in order to find trends and patterns among all of the data.

Referring now to similar to blocks and the management entity performs a similar set of operations in blocks and but for pre storage dependencies instead of data dependencies. The management entity may examine the objects produced by the parsing operation in block to help determine the different dependency relationships that may exist that involve a pre storage operation and other elements that are part of the data collection process block . The management entity may examine the parsed output of the request to collect data and maps that output to at least one of a set of fifth ADTs to represent the pre storage operations that are to be used during the data collection process as a set of fifteenth objects block . The parsed output may help identify additional semantics that may be embedded in the request to collect data. The ADTs may identify a set of characteristics and behavior required of a set of pre storage operations in a technology neutral manner. It is noted that blocks and may be optional since a pre storage operation is not always mandatory.

The management entity may continue to block where it determines whether a pre storage operation is mandatory based on parsing the request to collect data. If the request is not mandatory the management entity proceeds to block . If a pre storage operation is mandatory the management entity proceeds to block where it tests to determine if any data as well as any ADTs were found. If either data and or ADTs were not found the management entity continues to block point B on where the context is logged and the technique exits with a fatal error. In contrast if both data and ADTs were found the management entity proceeds to block . As an example specific types of pre processing operations may require temporary storage i.e. pre storage operations to be used as the data is being collected in order to execute correctly.

Similar to blocks and the management entity performs a similar set of operations in blocks and but for post storage dependencies instead of data dependencies. The management entity may examine the objects produced by the parsing operation in block to help determine the different dependency relationships that may exist that involve a post storage operation and other elements that are part of the data collection process block . The management entity may examine the parsed output of the request to collect data and maps that output to at least one of a set of sixth ADTs to represent the post storage operations that are to be used during the data collection process as a set of seventeenth objects block . The parsed output may help identify additional semantics that may be embedded in the request to collect data. The ADTs may identify a set of characteristics and behavior required of a set of post storage operations in a technology neutral manner. It is noted that blocks and may be optional since a post storage operation is not always mandatory.

The management entity may continue to block where it determines whether a post storage operation is mandatory based on parsing the request to collect data. If the request is not mandatory the management entity proceeds to block . If a post storage operation is mandatory the management entity proceeds to block where it tests to determine if any data as well as any ADTs were found. If either data and or ADTs were not found the management entity continues to block point B on where the context is logged and the technique exits with a fatal error. In contrast if both data and ADTs were found the management entity proceeds to block . As an example specific types of data may require a particular set of post storage operations to be used after the data has been collected either as part of an archiving process or for other operations required as part of the data collection analysis process.

The second set of four statements is similar defining the protocol dependencies first for data then for pre processing post processing pre storage and then post storage. Similarly lines 3 through 6 do the same for pre processing then post processing then pre storage then post storage. It is noted that the notation . . . indicates that text within the brackets is optional.

The second line defines the dependencies between the protocol s used and the type s of data being collected the pre processing method s used the post processing method s used and any associated storage requirements. The difference between this line and the first line is that the first line describes the dependency from the point of view of the data whereas this line describes the dependency from the point of view of the protocol. This is an asymmetric relationship hence each dependency may be different.

The third line defines the dependencies between the pre processing method s used and the type s of data being collected the protocol s being used by each method the post processing method s used and any associated storage requirements. It is noted that the dependencies are optional.

The fourth line defines the dependencies between the post processing method s used and the type s of data being collected the protocol s being used by each method the pre processing method s used and any associated storage requirement. It is noted that the dependencies are optional.

The fifth line defines the dependencies between the pre storage method s used and the type s of data being collected the protocol s being used by each method the pre and post processing method s used and any associated post storage requirement. Here the term pre storage means that temporary storage is required during the data collection process. It is noted that the dependencies are optional.

The sixth line defines the dependencies between the post storage method s used and the type s of data being collected the protocol s being used by each method the pre and post processing method s used and any associated pre storage requirement. Here the term post storage means that temporary and or permanent storage is required after the data collection processing operation has finished. It is noted that the dependencies are optional.

Referencing back now to the output of block is a dependency tuple that represents the dependency list such as that described in . Once the dependency list is formed the management entity may perform a check to determine if human intervention is required block . The check may also allow for linking to additional processes and features not presently discussed. If human intervention is required human intervention may be obtained block . It is noted that it is possible that after human intervention is performed the data collection process may continue at one of the entry points described in and through through and through

If human intervention is not required block the management entity may retrieve an information model for the communications system being inventoried block . As an example the information model may be stored in a memory local to the management entity or a memory remote to the management entity and the management entity may retrieve a subset of the information model from the memory. As another example the information model may be retrieved from an entity coupled to the management entity.

The management entity may make use of the information model retrieved in block to determine specific data model s required to collect the data requested in block . A detailed discussion of an embodiment is explained using to provided below.

Referencing now to block of where a new list for containing data models that are required to collect data for this collection request is initialized. The management entity may retrieve the first type of data to be collected from the dependency list block and retrieve the corresponding set of first ADTs for the first type of data block . It is noted that the retrieval of the corresponding set of first ADTs was discussed previously in reference to blocks of and . The management entity may look for a first protocol to use with the first type of data block and retrieve the at least one protocol ADT block . The management entity may compare the first type of data ADT with each of the at least one protocol ADTs block . If no dependencies between the type of data and protocol ADTs are found block the management entity continues to block . Otherwise the management entity proceeds to block where it saves references to ADTs and dependency information describing each dependency in a set of eighth objects block .

The management entity may map each first ADT from block to one or more model elements from the information model and then stores these model elements as a set of fifth objects block . The management entity may update the set of fifth objects with any appropriate metadata block . The management entity may map and store each model element in the set of fifth objects to at least one model element of a selected data model in a set of sixth objects where the data model being used has been derived from the information model block . The management entity may store each model element from the selected data model as a new object in a set of seventh objects block . This may be done by a variety of methods. One simple embodiment is by instantiating the model element from the set of sixth objects to produce an object instance which is then stored as an object in the set of seventh objects. The management entity continues to block of where it determines one or more data models from the set of seventh objects. The management entity may add the new data model to the list of data models if it is not already in the list block .

The management entity may map the protocol ADT to at least one model element and associated metadata from the information model blocks and and map and store the at least one model element of the information model to at least one model element of a data model that has been derived from the information model in set of sixth objects block . The management entity may store the set of sixth objects as a new set of ninth objects block which may be used to determine if a new data model is required to meet the requirements of the current ADT in block . The management entity may add the selected model to the list of data models if required block .

The management entity may retrieve the first pre processing algorithm and its corresponding set of ADTs blocks and . The management entity may compare the first ADT type of data with each of the third ADTs pre processing block . Referring now to block of where the management entity checks to see if any dependencies have been detected between the first type of data and third pre processing ADTs. If no dependencies were detected the management entity continues to block . If one or more dependencies were detected the management entity continues to block and point M of .

Referring now to block of the management entity may save references to each ADT and the dependency information in a set of eleventh objects. The management entity may map each object in the set of eleventh objects to a fourth data structure block and store the fourth data structure into the set of eighth objects block . The management entity may define an association between an object in the set of second objects i.e. ADTs for types of data and the object in the set of eleventh objects e.g. pre processing ADTs as a fifth data structure block which is then stored in the set of eighth objects block . The management entity may use the set of first fourth and fifth data structures to select one or more data models that can be used to meet the requirements of each data structure block .

The management entity may initialize a counter k to a value such as one block . The management entity may map each pre processing ADT in the set of eleventh objects into at least one or more model elements in the information model the set of fifth objects block and map each model element in the information model into at least one model element in a selected data model the set of sixth objects block . The newly created set of data model elements are then mapped into a new set of twelfth objects block . The management entity may ensure that the pre processing objects can operate with the data and protocol objects already defined the set of sixth and ninth objects respectively block . If the pre processing objects cannot operate with the data and protocol objects already defined the k th object is removed block and the management entity increments counter k block . If the pre processing objects can operate with the data and protocol objects already defined the management entity increments counter k block . The management entity may check to determine if there are additional types of pre processing objects block . If there are additional pre processing types the management entity returns to block . If there are not any additional pre processing types the management entity returns to block of .

Referencing now to block of the management entity may map each pre processing ADT to one or more model elements of the information model block and update any metadata associated with that mapping block . The management entity may map and store each model element of the information model to at least one model element of a selected data model block and store each model element in the set of sixth objects as a new object in a set of eleventh objects block . The management entity may determine one or more data models that are required to accommodate the needs of the pre processing ADTs block and add any data models to the list of data models if they are not already in the list block .

If post processing ADTs are present the management entity may retrieve the first post processing algorithm and its corresponding set of ADTs blocks and . The management entity may compare the first ADT type of data with each of the fourth ADTs post processing block . The management entity may check to determine if any dependencies have been detected between the first type of data and fourth post processing ADTs block . If no dependencies were detected then execution continues to block of . If one or more dependencies were detected the management entity continues to point N block of .

Referring now to block of the management entity may save references to each ADT and the dependency information in a set of thirteenth objects. The management entity may map each object in the set of thirteenth objects to a sixth data structure block and store the sixth data structure into the set of eighth objects block . The management entity may define an association between an object in the set of second objects i.e. ADTs for types of data and the object in the set of thirteenth objects e.g. post processing ADTs as a seventh data structure block which may then be stored in the set of eighth objects block . The management entity may use the set of first sixth and seventh data structures to select one or more data models that can be used to meet the requirements of each data structure block .

The management entity may initialize counter k to a value such as one block . The management entity may map each post processing ADT in the set of thirteenth objects into at least one or more model elements in the information model block and map each model element in the information model into at least one model element in a selected data model block . The newly created set of data model elements may then be mapped into a new set of fourteenth objects block . The management entity may check to ensure that the post processing objects can operate with the data and protocol objects already defined the set of sixth and ninth objects respectively block . If they cannot then the k th object is removed block and the management entity increments counter k block . If they can the management entity proceeds directly to block . The management entity may check to determine if there are additional post processing objects block . If there are additional post processing objects the management entity returns to block . Otherwise the management entity returns to block point W of which returns to point G block of .

Referencing back to block of the management entity may map each post processing ADT to one or more model elements of the information model block and update any metadata associated with that mapping block . The management entity may map and store each model element of the information model to at least one model element of a selected data model block . The management entity may store each model element in the set of sixth objects as a new object in a set of thirteenth objects block . The management entity may determine one or more data models that are required to accommodate the needs of the post processing ADTs block and add any data models to the list of data models if they are not already in the list block .

If pre storage ADTs are present the management entity may retrieve the first pre storage algorithm and its corresponding set of ADTs blocks and . The management entity may compare the first ADT type of data with each of the fifth ADTs pre storage block . The management entity may check to see if any dependencies have been detected between the first type of data and fifth pre storage ADTs block . If no dependencies were detected the management entity continues to block . If one or more dependencies were detected then execution continues to block and point O of .

Referring now to block of the management entity may save references to each ADT and the dependency information in a set of fifteenth objects. The management entity may map each object in the set of fifteenth objects to an eighth data structure block and store the eighth data structure into the set of eighth objects block . The management entity may define an association between an object in the set of second objects i.e. ADTs for types of data and the object in the set of fifteenth objects e.g. pre storage ADTs as a ninth data structure block which is then stored in the set of eighth objects block . The management entity may use the set of first eighth and ninth data structures to select one or more data models that can be used to meet the requirements of each data structure block .

The management entity may initialize counter k to a value such as one block . The management entity may map each pre storage ADT in the set of fifteenth objects into at least one or more model elements in the information model block and map each model element in the information model into at least one model element in a selected data model block . The newly created set of data model elements may then be mapped into a new set of sixteenth objects block . The management entity may ensure that the pre processing objects can operate with the data and protocol objects already defined the set of sixth and ninth objects respectively block . If they cannot then the k th object is removed block and the management entity increments counter k block . Otherwise the management entity proceeds directly to block . Finally the management entity may check to determine if there are additional pre storage objects block . If there are additional pre storage objects the management entity returns to block . Otherwise the management entity returns to block of .

Referring now to block of the management entity may map each pre storage ADT to one or more model elements of the information model block . Referring now to the management entity may update any metadata associated with that mapping block . The management entity may map and store each model element of the information model to at least one model element of a selected data model block . The management entity may store each model element in the set of sixth objects as an object in a new set of fifteenth objects block . The management entity may determine one or more data models that are required to accommodate the needs of the pre storage ADTs block and add any data models to the list of data models if they are not already in the list block .

If post storage ADTs are present the management entity may retrieve the first post storage algorithm and its corresponding set of ADTs blocks and . The management entity may compare the first ADT type of data with each of the sixth ADTs post storage block . The management entity may check to determine if any dependencies have been detected between the first type of data and sixth post storage ADTs block . If no dependencies were detected the management entity continues to block . If one or more dependencies were detected the management entity continues to block and point P of .

Referring now to block of the management entity may save references to each ADT and the dependency information in a set of seventeenth objects block . The management entity may map each object in the set of seventeenth objects to a tenth data structure block and store the tenth data structure into the set of eighth objects block . The management entity may define an association between an object in the set of second objects i.e. ADTs for types of data and the object in the set of seventeenth objects e.g. post storage ADTs as an eleventh data structure block which is then stored in the set of eighth objects block . The management entity may use the set of first tenth and eleventh data structures to select one or more data models that can be used to meet the requirements of each data structure block .

The management entity may initialize counter k to a value such as one block . The management entity may map each post storage ADT in the set of seventeenth objects into at least one or more model elements in the information model block and map each model element in the information model into at least one model element in a selected data model block . The newly created set of data model elements are then mapped into a new set of eighteenth objects block . The management entity may ensure that the post processing objects can operate with the data and protocol objects already defined the set of sixth and ninth objects respectively block . If they cannot the k th object is removed block and the management entity increments counter k block . Otherwise the management entity proceeds to block . Finally the management entity may check to see if there are additional post storage objects block . If there are additional post storage objects the management entity returns to block . Otherwise the management entity returns back to block of .

Referring now to block of the management entity continues to block where it may map each post storage ADT to one or more model elements of the information model. The management entity may update any metadata associated with that mapping block . Referring now to the management entity may map and store each model element of the information model to at least one model element of a selected data model block . The management entity may store the set of data model elements as a new set of seventeenth objects block . The management entity may determine one or more data models that are required to accommodate the needs of the post storage ADTs block and add any data models to the list of data models if they are not already in the list block .

The remainder of illustrates six loops that ensure that all ADTs of all components of the data collection process are analyzed. The management entity may check to determine if there are any more post storage ADTs left to process block . If there are the management entity returns to point K block in . The management entity may check to determine if there are any more pre storage ADTs left to process block . If there are the management entity returns to point H block in . The management entity may check to determine if there are any more post processing ADTs left to process block . If there are the management entity returns to point F block in . The management entity may check to determine if there are any more pre processing ADTs left to process block . If there are the management entity returns to point D in block . The management entity may check to determine if there are any more protocol ADTs left to process block . If there are the management entity returns to point C block in . The management entity may check to determine if there are any more type of data ADTs left to process block . If there are the management entity returns to point B block in . Otherwise management entity returns to block of .

The management entity may collect the data block . An example embodiment of the collection of the data is shown in . Referring now to block of the management entity may retrieve the information model block . The management entity may retrieve the dependency list block and retrieve the first data model to be used block . The remainder of illustrates the defining of a set of loops to process the collected data using the dependencies found.

The management entity may retrieve the first protocol to be used with the first type of data block and retrieve the first dependency block between the first type of data and the first protocol. The management entity may use these elements to determine if any constraints are placed on the data by the selected dependency block . The management entity may retrieve any other dependencies on the type of data that use the selected dependency block . As an example a pre or post processing function may depend on the retrieved type of data and protocol. If this is the case then this also means that the pre or post processing function also depends on the retrieved dependency and data model. The management entity may perform the data collection process using the mandatory from block and optional from block dependencies block . Since the data may have pre and post processing as well as pre and post storage dependencies an example embodiment may collect data in groups according to the dependencies found. While data may be collected on a per datum basis this is in general inefficient when compared with the example embodiments discussed herein.

The management entity may first analyze the various dependencies found in order to develop one or more strategies to govern the data collection process. Since there may be a number of viable strategies for different types of collection requests an example collection and analysis process is described in . It is noted that there are other possible collection and analysis processes.

Referring now to block of the management entity may analyze the collected data through the use of a series of loops block . According to an example embodiment the management system has already analyzed the various dependencies found in the collection request and defined one or more strategies with which to satisfy the collection request. The management entity may analyze the collected data stream seeking to find an atomic element that it can identify using a data model from the list of data models that it is using to meet the data collection request block . It is noted that some data are easily distinguishable and can be immediately identified due to having or exhibiting unique properties or behavior. In contrast some data are not easily distinguishable and can only be identified in the context of other data. A generic approach for solving this problem is illustrated in and is initiated in block of whose operation is described in more detail in

Referring now to block in the management entity may initialize looping constructs used to perform the matching process to identify data collected. The management entity may retrieve a list of data models block and retrieve the first data model in the list of data models block . The management entity may use one or more of feature based structure based behavior based or semantic relatedness matching to match data collected to at least one model element in the first data model block . The management entity may perform a check to determine if a match has been found block . If no match is found in block then in block the management entity may check to determine if more data models are available. If more data models are available then the management entity returns to block where the next data model is retrieved and the process is repeated. If no more data models are available then the management entity proceeds to point A block in to attempt a more computationally expensive method to identify the data. An example identification technique is illustrated in . Since there may be a number of viable strategies for identifying different types of data the example identification process illustrated in should not be construed as being limiting to either the scope or the spirit of the example embodiments.

If a match is found in block then the management entity moves to block where the management entity may use one or more of feature based structure based behavior based and semantic relatedness matching to match the at least one model element from the first data model to at least one model element in the information model block . The matching may enable the management entity to be cognizant of the set of features and behaviors that an instance of the at least one model element should have. As an illustrative example if a router has been identified and a physical port of the router has been assigned speed and duplex values but no address is associated with that physical port then the management entity may conclude that the physical port is not completely initialized e.g. at a minimum it needs an address object to be associated with the physical port and the physical port itself must be enabled . Repeating this procedure is an example of the management entity recognizing enough objects that have simple functionality and behavior as well as recognizing various relationships between these simple objects to build a more complex ManageableEntity e.g. a router . By viewing the information model description of the element the management entity may verify that the assembled ManageableEntity is correct as well as learn what other data to look for in the collected data in order to determine if the object is complete or not. This leads to better understanding of the context of the data.

The management entity may perform a check to determine if a match between the at least one model element from the retrieved data model and at least one model element from the information model is found block . If so the management entity may move to block where it checks to determine if there is more data to be identified. If there is not any more data to identify the management entity returns to block of . If there is more data to be identified the management entity returns to block and the technique repeats. If a match is not found in block the management entity may return to point A block in to attempt a more computationally expensive method to identify the data.

Referring now to block of the management entity may initialize looping constructs used to perform the element matching process to identify data collected block . A purpose of the technique shown in is to match elements in the data collected to known model elements in the information model in order to identify them using ADTs. An advantage of this technique is that it enables the management entity to match data collected to known features and behavior of a ManageableEntity or part thereof as each match of each feature and or behavior is verified then the confidence that these data collected are in fact an instance of the ManageableEntity. As used herein the term element means a set of data that are logically a part of a larger data object. Element may correspond to one or more model elements of the information model. As an example a router may comprise chassis port interfaces power supplies and other objects. Each of these objects may in turn comprise other lower level objects e.g. an interface may have an IP address and or a MAC address depending on the type of interface . It should be noted that all of these example objects are either ManageableEntities e.g. an interface or UnManageableEntities e.g. a chassis .

The management entity may use one or more of feature based structure based behavior based or semantic relatedness matching to match the data from the retrieved data model to at least one ADT defined in or used to construct the information model block . The matching enables the management entity to recognize one or more features and behaviors that an instance of the at least one element should have. If a match is not found in block the management entity is unable to identify these data. Accordingly the management entity assesses the severity of the inability to currently identify these data. The assessment is used to determine whether this technique should continue block . It is noted that the severity may be context sensitive and in most cases the object matching technique can be continued. The technique may continue because by identifying more data in the collected data more information about the collected data is gathered which may then be used to help identify the currently unidentifiable element. The context is logged block and the management entity may perform a second check to determine if this error is fatal within the gathered context block . If the error is not fatal then the management entity returns to point B block of . If the error is fatal this technique terminates and the management entity returns to block in

If a match is found in block the syntactic requirements of the ADT may be mapped to at least one model element in the information model block . The management entity may use the syntactic requirements to examine the data in order to map the semantic requirements of the ADT to at least one model element in the information model block . The management entity may enrich the mapping by adding metadata as appropriate block . The metadata may be derived from information that the management entity already knows and may contain hints for the management entity to aid in the current and future object identification technique. The model element being mapped to in blocks and may be a single model element or a single set of model elements. The management entity may return to point B block of

Once the element is identified using the selected data model block the management entity may continue to match the at least one object that was identified block to at least one model element in the selected data model block . The management entity may then match the at least one model element from the selected data model block to at least one model element from the information model block . These three steps blocks have thus matched objects from the data collected to conceptual model elements from the information model. This serves to identify the class of the object instance which in turn serves as a syntactical and semantic check of the veracity of this identification technique. The management entity may then match each model element from the information model to at least one ADT this enables the management entity to recognize changes in the structure attribute values operations and or relationships that this object instance has as represented in the information model in this particular application specific context by relying on a more abstract definition of its functionality and behavior as defined by the at least one ADT . Hence the same management entity may recognize variations in the instantiation of the same object caused by different application contexts. As an illustrative example a router that has 16 PhysicalPort objects may enable a different number of object instances in different applications. As another illustrative example the same Interface object may be configured in different ways or be used to create higher level logical MangeableEntities e.g. a VLAN or VPN for different applications.

The management entity may then check for any errors in the matching processes blocks in this technique. If no errors are found the management entity may then check for the presence of additional elements in the data collected to analyze block . If there are additional elements to analyze then the management entity may return to block and repeat the above process. If not then this technique terminates and returns to block of . If at least one error was found then the management entity performs element identification as described in in order to try to resolve the error by identifying the unknown object.

Referring now back to block of the management entity has completed collection of the data and identified the objects of the data. The management entity may validate the data block . In this technique the management entity may check to ensure that the results of the data collection process make sense e.g. data about a given Entity makes sense for that Entity and in the context of the application s that this Entity supports or interacts with and that the collected data when viewed from a global point of view is consistent. As an example domains and ranges will be checked catching errors like an IP address with a negative value objects e.g. a card is plugged into a Slot of a Chassis and not into a PhysicalPort or a Protocol elements e.g. groups of related objects that form a higher level ManageableEntity such as a Chassis a Card a PhysicalPort and an IPAddress that are combined into a single Router and the like. An example approach illustrated in will be described herein. Since there are a variety of methods to validate data the approach illustrated herein should not be construed as being limiting to either the scope or the spirit of the example embodiments.

Referring now to block of where the validation module may be initialized block . The management entity may retrieve the information model block and a subset of the data models block if they are not already available to the management entity. The management entity may validate the collected data block .

Referring now to block of where a first looping construct is initialized. It is noted that the operations described herein are applicable to all elements of the collected data block . The management entity may be defined to store the collected data along with associated information and metadata block . Referring now to operations in the definition of the set of applicable repositories to store the collected data along with associated information and metadata are discussed in detail. Referring now to block of the set of ADTs for the data to be collected are retrieved by the management entity. The management entity may retrieve the ADT s for the current protocol s being used block and check to see if any pre processing functions are required block . If so then the management entity retrieves their associated ADT s block and then proceeds to block . Otherwise the management entity goes directly to block . Similar checks are done for post processing blocks and pre storage blocks and and post storage blocks and 

At this point the management entity may have a complete description of all capabilities and requirements of the data collection process via the ADTs . The management entity may now examine the capabilities of each repository that can be used to ensure that it is capable of performing all desired operations on the collected data such as storing retrieving searching and the like. Hence in block the management entity retrieves ADTs that define such operations for each candidate repository. In block the management entity may determine which repositories satisfy the requirements of the data collection process by checking to see if the current repository being checked may perform all desired operations without adversely affecting the collected data to be operated on. If the current repository does not meet these requirements control proceeds directly to block . Otherwise that repository is added to the set of tenth objects which contains the repositories that can be used to save validated data block . The management entity then moves to block .

The management entity may check to determine if there are any more candidate repositories to check block . If so the management entity returns to block and the process repeats. Otherwise the management entity returns to point B block in . The management entity may map each object of the collected data to one or more data model elements block . The management entity may perform a check to determine if an error is detected block . Since each object in the data collected has either been already identified block of or known to be unidentifiable blocks of the management entity may be able to perform the mapping without any problems block . If this is the case the management entity may first save the mapped data. Since there are many different ways to perform this operation an example technique is illustrated in starting at point C.

Referring forward to the management entity may retrieve model elements in each data model for each ADT that matches an object in the collected data block The management entity may save each matched model element from the data model that is currently being used block . The management entity may update the metadata for each matched model element with data that describes the mapping from an ADT to a data model element as well as any other context block . The management entity returns to point D block in .

The management entity may perform a check to determine if there is more data to process block . If there is more data to process the management entity returns to block . Otherwise the management entity may move to a second loop which starts at block .

If an error is found in block the severity of the problem is assessed block . As an example the data collection process may have correctly identified an IPAddress object but may have not found another higher level ManageableEntity to either contain and or aggregate the IPAddress. In such a case the data model may not be able to determine with which object the IPAddress should be associated. As another example an IPAddress could be associated with a variety of different devices e.g. routers switches firewalls hosts and the like that are all part of a Local Area Network. A data model may not provide associated business logic policy rules and other semantics that may be required to properly associate the IPAddress object with another containing or aggregating object. Hence the management entity may log the current context of the process block and test to determine if not being able to map the current object to one or more data model elements should be considered a fatal error block . If fatal the technique terminates. Otherwise the management entity returns to block which acts as described above.

Once the management entity moves to the lower loop operation may be substantially identical to the upper loop except that the data model element is mapped to one or more model elements of the information model block . After the mapping is attempted in block the management entity may perform a check to determine if the mapping succeeded or produced errors block . If an error was detected the severity of the problem may be assessed block . As an example the information model may not have the appropriate business logic to solve a problem e.g. matching the IPAddress object to an appropriate containing or aggregating object . Thus the management entity may log the current context block and test to see if this error should be considered a fatal error block . If it is a fatal error the technique terminates. If an error is not detected then the management entity may save the mapped model element of the information model. Since there are many different ways to perform this operation an example technique is illustrated in starting at point E.

Referring forward to the management entity may retrieve model elements in the information model for each matched model element in the current data model block The management entity may save each matched model element from the information model block . The management entity may update the metadata for each matched model element with data that describes the mapping from a model element in the data model to a model element in the information model as well as any other applicable context block . Control is then passed back to point F block in .

Otherwise the management entity moves to block where it may test to determine if more data needs to be mapped to model elements of the information model. If more data needs to be mapped the management entity returns to block and the technique repeats. Otherwise the management entity returns to block of . Referring back to block of the validation process is now complete. The management entity may return to block in

Referring now to block of the data validation process is now complete. The management entity may perform a check to determine if other dependencies still need to be processed for the currently selected protocol and data model block . If so the management entity may obtain a next dependency block and returns to block which continues the data collection process for the given type of data given data model given protocol and the next dependency for these four components of the data collection process.

The management entity may perform a check to determine if more protocols still need to be processed for the currently selected data model block . If so the management entity may retrieve the next protocol block and returns to block which continues the data collection process for the given type of data given data model and given protocol.

The management entity may perform a check to determine if more data models still need to be processed block . If so the management entity may retrieve the next data model block and returns to block which continues the data collection process using this new data model. Otherwise the management entity returns to block of . This completes the data collection process and the management entity returns to block of

Referring back now to the management entity may save references of collected data as a set of first objects block in order to facilitate identification and processing of the collected data. This may be necessary because the data may be delivered out of order or split into multiple segments or even have some missing elements. In general the example embodiments perform identification of ManageableEntities as well as other functions by converting the data collected into ManageableEntities and then matching the data characteristics and behavior of those ManageableEntities to information provided in the set of data models and the information model that the management system is using.

The management entity may then perform zero or more data collection processing operations block . Such operations may be necessary in order to convert the collected data into a form more suitable for use by other entities that receive these data via the collection request block . As an example the amount of data collected may exceed the ability of the requesting entity to store and process. In such a case an example of data collection processing could be to filter out unneeded data and or provide a lesser amount of data that collectively has more semantics through operations such as aggregation correlation and enrichment. and illustrate a generic approach to data collection processing. Since the data collection processing can be performed in many different ways the generic approach shown in and is not intended to limit the spirit or the scope of the example embodiments.

Referring now to block of the management entity may retrieve the parsed data collection request block . The parsed data collection request may be used to retrieve any appropriate knowledge that the management system knows about that is related to the data collection request block . As an example the management system may have stored information from previous data collection requests and analyses that may apply to the current data collection processing request and its analysis. The management entity may retrieve the dependency list selected data models and selected protocols block . The ordering of each of these sets of information may be adjusted by the information retrieved in block and the nature of the data collection request from block .

At this point the management system has access to the data collection request represented as a parse tree or similar data structure for example along with the various dependencies that the management system has discovered which may be ordered according to increasing importance on identifying dependencies between components that collect and or analyze the data types of data to be analyzed the results of pre and or post processing on the collected data and the like. The management entity may partition the collected data into a set of different groups of objects where each group contains a subset of the collected data based upon a different combination of one or more type of data dependencies and one or more protocol dependencies block . The partitioning enables the management entity to uncover hidden relationships that may not otherwise be apparent from just examining the data. As an example an IPAddress is typically found before the device that the IPAddress is bound to. The data model will define which devices can contain and or aggregate IPAddress objects but in general it cannot define which IPAddress is associated with which device until runtime. The restriction is due to the way the data model treats permanent association. The restriction would in turn negate the generalness of the data model. Similarly the information model would not define which IPAddress was bound to which device. However the information model could represent policy rules that would govern such associations. Assuming that the management entity is able to determine if the system being managed was using any such policy rules then these policy rules may form part of a knowledge based that the management entity could use and apply to the collected data.

After partitioning the collected data into different groups based on dependencies between a type of data and one or more protocols block the management entity may select a specific protocol to use for each partition block . Then if any optional dependencies such as those involving pre or post dependencies or pre or post storage functions are found additional partitions may be defined block . In general the management entity has a total of at least j k m n p q partitions where j is the number of types of data k is the number of protocols used for a given type of data m and n are the number of pre and post processing functions used per type of data and p and q are the number of pre and post storage functions used per type of data.

The management entity may initialize counters and containers required for the analysis of the collected data block . Typically there are three types of containers used. The first two containers are used to contain Entities that can contain and or aggregate other Entities these Entities will henceforth be referred to as containing Entities that have and have not been processed. Such Entities start in the first container and are processed by the management entity in blocks to of . Once it is determined that a given Entity has no more associations with any other Entities then that Entity is placed in the second container. Both the first container and the second container are used to determine if different types of associations but especially whole part relationships exist in the data. The third container contains all other Entities that are not containing Entities. The management entity may analyze the collected data according to the dependencies block .

Referring now to block of for a detailed discussion of an example analysis of the collected data according to the dependencies selected in blocks of .

The management entity may retrieve the first containing Entity that can contain and or aggregate other Entities and or ManageableEntities block . The retrieval of the first containing Entity may enable the management entity to start assembling elements e.g. collections of objects that are all related to each other . The elements can be nested. As an illustrative example an IPAddress object and a PhysicalPort object may be aggregated with each other a Protocol object uses the PhysicalPort number and the IPAddress to communicate the PhysicalPort may be contained by a Card the Card may be aggregated by a Chassis and the Chassis along with other objects such as cables and a power supply may all be aggregated into a Router. It should be noted that there are many different types of relationships in this example including aggregation e.g. a PhysicalPort object may aggregate an IPAddress object association e.g. a Protocol object may use an attribute of the PhysicalPort that it is running on to communicate and composition e.g. a PhysicalPort is contained by a Card and if the Card is removed then that PhysicalPort is also removed . Each relationship has different semantics which may entail the use of different data collection processing techniques.

According to an example embodiment all objects in the above example are represented as model elements that exist in the information model the Card Chassis and PhysicalPort are each UnManageableEntities while the IPAddress and the Protocol objects are ManageableEntities both UnManageableEntity and ManageableEntity inherit from the Entity class . The management entity may use the semantics associated with each Entity to help assemble the set of objects in the data collected into a more meaningful form.

The management entity may identify any of the other objects in the first partition that are part of the collected data to test if any may be associated with the current containing Entity using any of feature based structure based behavior based or semantic relatedness matching block . The identification associates the identified object which may be an Entity or a ManageableEntity to the currently selected containing Entity which may also be an Entity or a ManageableEntity using one or more of the above matching mechanisms. As an example a set of objects from the collected data may correspond to a sub graph in the information model. Structural matching would detect this and combine the objects into a larger object. It is noted that in some systems when a process implementing this technique is executed the combined objects are not eliminated. Rather a new containing Entity and or new relationships are created to represent the appropriate semantics.

The management entity may check to determine if any associations can be deduced or inferred about the Entity that can contain and or aggregate Entities and the set of objects being analyzed block . As an example if an object is known to be a type of Card that has 16 physical ports that are all 10 100 Mb then the management entity can attempt to find 16 distinct but related IPAddress objects that can each be associated with a different PhysicalPort of the Card. Implied are a number of facts e.g. the PhysicalPort must be capable of transmitting and receiving Ethernet traffic at either 10 or 100 Mbps the PhysicalPort must be enabled and the like that the management entity can check or use as hypotheses to attempt and verify as more of the objects in the collected data are processed. These facts are added to the collective knowledge of the management system enabling the management system to deduce or infer new facts. As an example the newly constructed object a Card that now has a new IPAddress associated with a PhysicalPort could now support running a set of Protocols. In contrast if the management entity finds more than 16 IPAddresses then it may conclude that at least a second device having one of those IPAddresses exists. If the management entity finds less than 16 IPAddresses then it may also make one or more conclusions depending on the current state of the collected data analysis 

If one or more associations were generated the management entity may continue to block where it adds the newly constructed containing Entity to the front of the first container of containing Entities. The management entity may return to block so that additional objects from the set of collected data in the first partition may be analyzed to determine if they are related to any of the containing Entities in the first container.

If no associations were created in block the management entity may move to block where it moves the containing Entity to the second container. The management entity may test to determine if there are more containing Entities block . If so the management entity may obtain the next containing Entity block . The management entity may return to block to continue the analysis process. If there are no containing Entities the management entity may test to determine if any new containing Entities were found on this analysis iteration block . If so then the counter i is incremented block . The management entity may clear the contents of the first container rename the second container i.e. the container that has processed containing Entities to be the new first container and rename the old second container to be the new first container block and move to block to continue analyzing collected data from the first partition.

If the analytic iteration does not find any new containing Entities the management entity may check to determine if there are more data to be processed in this partition block . If there are more data to process the management entity returns to block to continue analyzing collected data from the current partition. If there is no further data to process the management entity may perform a check to determine if there are any more partitions to be processed block . If there are more partitions to be processed the management entity may obtain the next partition and reinitialize the system block and return to bock to start analyzing collected data from the new partition. If there are no more partitions to be processed the management entity may use one or more mechanisms to analyze the results of the previous element creation process block . Such mechanisms include but are not limited to machine learning statistical analysis fuzzy matching and the like. The management entity may save the analysis block . The management entity may return to block of .

Referring back now to with the data collection processing analysis is complete the management entity may save the results block . The management entity may perform one or more data transformations if necessary block .

Referring now to wherein blocks illustrate an example data transformation block in on the collected data. According to an example embodiment transformation of the collected data may make consumption of the collected data easier for a set of entities that are requesting all or part of the data collected. The set of data transformations enable the overall structure syntax and semantics of the data collected to be transformed into a different data set having different overall structure syntax and or semantics. The management entity may perform a check to determine if the collected data requires a transformation to be compliant with the specified schema block . As an example the collected data may be in a form compliant with a first internal schema but not compliant with a second schema that is specified by the requester of the data collection process. Hence a transformation may be needed to make the collected data compliant with the specified schema. If the collected data does not require transformation data transformation may be skipped.

If the collected data does require transformation then it may be assumed that the first schema is already defined in either the information model or in one of the data models. The management entity may retrieve the specified schema block . The specified schema may be stored in a memory local or remote to the management entity.

Utilizing the first schema and the specified schema the management entity may determine a transformation function block . The transformation function may be considered to be a mapping function that maps instances of one schema e.g. the first schema to another schema e.g. the specified schema . It is noted that the transformation may consist of either a set of operations a set of sub transformations and or multiple transformations performed in series.

Referring now to block of the management entity may start by retrieving the source and target schemata blocks and respectively . The management entity may check to determine if the target schema is already defined or can be defined in the information model block . If the target schema is already defined or if it can be defined the management entity may to block . If it cannot the management entity may define a mapping transformation function. The management entity may initialize loops block . The management entity may map each element in the target schema to at least one ADT in the information model block . The management entity may map each ADT to at least one model element in the information model that corresponds to another at least one model element in the source schema block .

The management entity may perform aa check to determine if there is enough information to define the mapping directly block . If so the management entity may perform a check to determine if there are more elements left to map block . If there are more elements to map the management entity returns to block . If there are no more elements to map the management entity returns back to block in . If there is not enough information to define the mapping directly the management entity may define a function to map source elements to target elements block . The function may be based on the ADTs that describe the target schema and hence define the characteristics and behavior of each element in the target schema and the ability to map each ADT to at least one model element in the information model. Once the mapping is defined in block the management entity moves to block and the technique proceeds as explained above.

Once the data transformation function is completed for all elements of the target schema the management entity returns to block of . The management entity may start the transformation process block . An example transformation process is illustrated in

Referring now to block of the management entity may retrieve the source schema block retrieve the target schema block and retrieve the transformation function block respectively if they are not already present. The management entity may initialize looping constructs to visit all data block and apply the transformation mapping to each element in the source schema block . In general the application of the transformation mapping produces a set of instances to populate the target schema. The management entity may perform a check for errors in the data transformation process block . If there are none the management entity may check to determine if there are more elements to be transformed block . If there are more elements to be transformed the management entity returns to block . If there are no more elements to be transformed the management entity returns to block of

If an error was detected in block the severity of the error may be assessed block and its context logged block . The error may then be assessed as to whether it is of sufficient severity that the transformation should stop or whether the transformation may continue block . If the transformation can continue the management entity returns to block . If the transformation cannot continue then the technique terminates.

Referring now to block of the management entity may then save the collected data block thereby enabling the management entity as well as other entities to store a snapshot of the collected data in its fully processed form before further operations are performed.

Operations in may begin with the management entity receiving a request to collect inventory data and generating a dependency list from the request to collect inventory data block . The dependency list may have been obtained by the management entity in block of and saved for subsequent use. As an example the management entity may retrieve the dependency list from a memory.

The dependency list consists of a set of ordered tuples that define the dependencies between each component used in the process of collecting data. A summary of the tuple is shown in . The tuple may be implemented in a variety of data structures. For discussion purposes a stack data type will be used. This should not be construed as limiting the scope of how the dependency list should be implemented.

A stack may be defined as a type of ADT that is used to define a linear data structure. The linear data structure is used to maintain a sequence of elements. For the sake of simplicity the stack that we will use is assumed to be a homogeneous stack meaning that it can only store elements that all have the same data type. A characteristic of a stack is that insert and delete operations are only allowed at one end of the stack called the top or the bottom of the stack respectively. Insertion and deletion are done in a last in first out order. The principal operations of a stack are a push which inserts a value into the stack a pop which removes a value from the stack and a copy which creates a new stack that has the same content as the current stack.

In general two types of dependencies are mandatory data protocol and protocol data. These define the types of protocols that will not adversely alter the selected data and the data types that a given protocol can transmit and receive without error respectively. The first dependency data protocol may be obtained from the dependency list by using a pop operation block . The management entity may determine data model s that are required to represent the type of data block as previously explained in . As an example if a complex object consists of several data structures then only a data model or data models capable of representing querying editing and managing the complex object may be used. As another example if an inventory object requires semantics such as metadata or other types of programmable logic to be stored along with the inventory object then only a data model or data models that can represent this type of association may be used.

The data model or data models may be added to a list of data models to be used to collect the data regarding the communications system if it is not already in the list block . The management entity may perform a check to determine if there are any remaining types of data that have not been analyzed for purposes of defining a dependency or dependencies block . If there are remaining types of data that have not been analyzed then the management entity may return to block to repeat analysis of another type of data. If there are no more remaining types of data to need to be analyzed then the management entity may proceed to block .

The management entity may obtain from the dependency list types of protocol block that can transmit and receive the set of types of data retrieved in block without error by using a pop operation. The management entity may determine data model s that are required to represent the type s of protocol block . As an example if detailed information about a VLAN object is required then only those protocols that are capable of retrieving detailed information about the VLAN object may be used e.g. 802.1Q Media Access Control Bridges and Virtual Bridge Local Access Networks or the VLAN Trunking Protocol VTP . The data model or data models may be added to a list of data models to be used to collect the data regarding the communications system if it is not already in the list block . The management entity may perform a check to determine if there are any remaining types of protocol that have not been analyzed for purposes of defining a dependency or dependencies block . If there are remaining types of protocol that have not been analyzed then the management entity may return to block to repeat analysis of another type of protocol. If there are no more remaining types of protocol to need to be analyzed then the management entity may proceed to block of .

The management entity may obtain from the dependency list types of pre processing operations block by using a pop operation. The management entity may determine data model s that are required to represent the type s of pre processing operations block that may be required in order to collect data in a form that is useful for the requester. As an example a pre processing method may be applied to the data being collected and may include one or more of the following 1 operations on each datum or a set of data in the collected data 2 sending of one or more data elements of the collected data that meet some criteria to additional logic for further processing via another protocol and the like. Hence the pre processing operation may also have dependencies on protocols and storage. The data model or data models may be added to a list of data models to be used to collect the data regarding the communications system if it is not already in the list block . The management entity may perform a check to determine if there are any remaining types of pre processing that have not been analyzed for purposes of defining a dependency or dependencies block . If there are remaining types of pre processing that have not been analyzed then the management entity may return to block to repeat analysis of another type of pre processing. If there are no more remaining types of pre processing that need to be analyzed then the management entity may proceed to block .

The management entity may obtain a type of post processing from the dependencies list and define a dependency dependencies for the type of post processing block . The management entity may obtain from the dependency list types of post processing operations block by using a stack pop operation. The management entity may determine data model s that are required to represent the type s of post processing operations block that may be required in order to collect data in a form that is useful for the requester. As an example a post processing method may be applied to the collected data but before said data is sent to the requestor and may include one or more of the following 1 operations on the set of collected data as a whole in order to derive new data based on e.g. trending information extracted from the data collected 2 sending of one or more data elements of the collected data that meet some criteria to additional logic for further processing via another protocol and the like. Hence the post processing operation may also have dependencies on protocols pre processing and storage. The data model or data models may be added to a list of data models to be used to collect the data regarding the communications system if it is not already in the list block . The management entity may perform a check to determine if there are any remaining types of post processing that have not been analyzed for purposes of defining a dependency or dependencies block . If there are remaining types of post processing that have not been analyzed then the management entity may return to block to repeat analysis of another type of post processing. If there are no more remaining types of post processing to need to be analyzed then the management entity may proceed to block on shown after point B of .

The management entity may obtain from the dependency list type s of pre storage operations block by using a stack pop operation. The management entity may determine data model s that are required to represent the type s of pre storage operations block that may be required in order to collect data in a form that is useful for the requester. As an example a pre storage method may be applied to the data as it is being collected and may include storing and retrieving collected and stored data respectively for further analysis and processing. The data model or data models may be added to a list of data models to be used to collect the data regarding the communications system if it is not already in the list block . The management entity may perform a check to determine if there are any remaining types of pre storage that have not been analyzed for purposes of defining a dependency or dependencies block . If there are remaining types of pre storage that have not been analyzed then the management entity may return to block to repeat analysis of another type of pre storage. If there are no more remaining types of pre storage to need to be analyzed then the management entity may proceed to block .

The management entity may obtain from the dependency list type s of post storage operations block . The management entity may determine data model s that are required to represent the type s of post storage operations block that may be required in order to collect data in a form that is useful for the requester. As an example a post storage method may be applied to the data after all data have been collected and may include storing and retrieving collected and stored data respectively for further analysis and processing. The data model or data models may be added to a list of data models to be used to collect the data regarding the communications system if it is not already in the list block . The management entity may perform a check to determine if there are any remaining types of post storage that have not been analyzed for purposes of defining a dependency or dependencies block . If there are remaining types of post storage that have not been analyzed then the management entity may return to block to repeat analysis of another type of post storage. If there are no more remaining types of post storage to need to be analyzed then the management entity is finished with determining data model s required to collect the data requested.

Referring now to the management entity receives the request to collect inventory data block just as in the previous case block of . The request to collect inventory data is parsed in block . Producing a parse tree may in general be performed by a variety of different techniques. For the purposes of this invention some amount of morphological and lexical processing e.g. tokenization part of speech tagging inflection and derivation analysis followed by syntactic analysis e.g. term recognition and application of grammatical rules is required. The management entity may then be able to perform a variety of semantic analyses including named entity recognition and semantic role labeling.

Since there are a wide variety of techniques that can be applied to parse the request a typical embodiment is described in . Referring now to block of the request to collect inventory data is parsed block producing a parse tree block . Any type of parse tree will suffice though an example embodiment may use a constituency based parse tree where the grammar differentiates between terminal and non terminal categories. The context when the parsing operation was started and completed as well as any other data e.g. special libraries or routines that were called by the parsing process in order for it to finish are recorded as metadata and or annotations blocks and . As an example in the DEN ng information model an annotation is a type of metadata. However other information models may choose to differentiate between metadata and annotations. If this is the case both types of information are added in block .

The management entity may perform named entity recognition block . Block may also include word sense disambiguation. In general a named entity is an Entity that is an instance of a pre defined category of interest such as the name of a person an organization a location or a date or time expression. Such Entities typically have special significance in a data collection operation. However when occurring in free text named entities can be very hard to recognize due to different variations in their declaration or use e.g. Dr. Smith vs. Harold vs. Harold Smith Ph.D. ambiguity e.g. is June a Person or the name of a Month or is Washington a Person or a Location usage e.g. edge router vs. core router sentence structure e.g. the presence or absence of different parts of speech punctuation spelling spacing and the like . Hence different types of disambiguation may be required. These take the form of different processes such as format detection tokenization sentence splitting part of speech tagging and others some or all of which may be employed in block . Once again any metadata or annotations are detected block and written block as part of this process.

The management entity may perform semantic role labeling block . Semantic role labeling typically identifies constituents that fill a semantic role for each verb in a sentence e.g. the arguments to a predicate . Typically this can be a difficult task. An example embodiment uses a combination of a manual classifier augmented with various types of machine learning e.g. for determining starting and ending positions for each argument that is associated with a verb enabling supplemental linguistic information to be combined with linguistic and structural constraints by explicitly incorporating inferencing into the decision process. Once again any metadata or annotations are detected block and written block as part of this process.

The management entity may perform co reference resolution block . Co reference resolution normally involves identifying entities that are related to each other in different sentences e.g. Find an edge router that has at least one congested port. Fix the port. . Once again any metadata or annotations are detected block and written block as part of this process.

The management entity may perform pragmatics analysis block . Pragmatics analysis usually involves mapping a sentence to its intended meaning. This is most often done using a set of transformations that use a set of beliefs and goals. Once again any metadata or annotations are detected block and written block as part of this process.

Referencing back to once the request has been parsed the management entity may perform the requested data collection block . While similar to the previous description for collecting data this version has additional steps to enable the process to be able to recognize pieces of the data collected that cannot be immediately identified and to perform additional processes on those unrecognizable pieces of data to ultimately identify them. Provision for recognizing new model elements not previously known to the management system is later described in and and their attendant discussion.

Referencing forward now to the first task required to collect data is to first determine any dependencies present between the data to be collected protocol s used to collect the data pre and or post processing that must be done on some or all of the collected data and or pre and or post storage that must be applied to some or all of the collected data block . Previously and described how to create a dependency list to accomplish the above tasks. This approach may be used as previously described by the management entity as shown in block of . All pertinent metadata is then updated block .

The management entity may then test to determine if human intervention is required block . For example the data collection process may require some manual steps. If this is the case then in block the management entity returns control to the user. The check may also allow for linking to additional processes and features not presently discussed. It is noted that it is possible that after human intervention is performed the data collection process may continue at one of the entry points described in and through through through and through

If human intervention is not required the management entity may retrieve an information model for the communications system being inventoried block . As an example the information model may be stored in a memory local to the management entity or a memory remote to the management entity and the management entity may retrieve a subset of the information model from the memory. As another example the information model may be retrieved from an entity coupled to the management entity.

The management entity may make use of the information model retrieved in block to determine specific data model s required to collect the data requested in block . A detailed discussion of an embodiment is explained using to as previously explained. The management entity may then update appropriate metadata with the results of how the set of data models to be used was determined this may be of use later if the management entity determines that all or part of the data collected cannot be recognized. Metadata for all affected entities are updated in block . This may complete the initialization of the data collection process. The management entity may then decide to collect data block which is described in detail in and .

Referencing forward to block of where the management entity initializes mechanisms that are required to collect data for this collection request block . The management entity may retrieve the information model and the first data model of the list of data models to be used in blocks and respectively. The management entity uses the dependency list to retrieve the first protocol and first dependency in blocks and respectively. The management entity may determine the set of mandatory and optional constraints and other types of dependencies that are required to retrieve data of the current data type using the current protocol in blocks and respectively. At this point the management entity is ready to collect data block . It is noted that the management entity may choose to collect data one datum at a time or collect data as a stream from a particular source or collect data until an error is detected or employ other approaches or as a combination of approaches. The mechanics of the data collection process was previously explained using and

The management entity may check to ensure that all objects have been identified block . Alternatively the management entity may check each object as it is collected or groups of objects or any combination to ensure that it can identify the object. Recognizing that some objects are inherently ambiguous until the context of their usage execution configuration monitoring and or other factors are completely understood the management entity may elect to collect data and identify each datum in stages this enables the management entity to use knowledge that it is gathering and or inferring during the data collection process to help it identify data.

If the management entity can identify the object s it may then check to see if more objects need to be identified block . If more objects need to be identified the management entity returns to block . Otherwise if the management entity cannot identify one or more objects then it may elect to identify each recognizable object with one or more methods. If the one or more methods are successful in identifying the object then the management entity may choose to either directly replace each set of unidentified objects with at least one identified object block or it may elect to create a new object or set of objects block . This is a complex process and may be performed in a variety of ways. An example embodiment for the replacement process is described in and . An example process for the generation process is described in and .

Referencing forward to block of the management entity decides how to replace an unidentified object with a set of known objects by first identifying the unidentified object at increasingly more detailed levels of abstraction and second successively matching the functionality of the unidentified object to known model elements and objects. The management entity first initializes the system to prepare for replacing unidentified objects with currently known objects block . The data collected may be in the form of a discrete set of objects that may contain attributes a set of individual attributes that have direct or indirect pointers to an object or in other formats. In addition the data collected may have missing data or data not properly ordered or data fragmented into different pieces or the like. Hence an example embodiment will treat the data collected as a set of records where each record can be a part of a datum e.g. a piece of an attribute a full datum e.g. an attribute a set of data e.g. a set of related attributes an object e.g. an instance derived from a class with or without attributes and other model elements a set of objects and the like. For simplicity all of these forms will be termed a record .

The management entity may save a reference to each object in the current record of the collected data as a set of first objects block . Similarly the management entity may save a reference to each ADT defined in the information model as a set of second objects block . The management entity may compare the functionality present in the set of first objects with the functionality that is specified in the set of second objects block . Put another way the management entity tries to match the functionality specified by an ADT to the functionality presented by the collected data. Examples of this matching include specifying the characteristics via attributes and behavior via attributes relationships and or constraints of an object. If the functionality of the current record is not equal to or a proper subset of the functionality specified by the ADT block the current record exhibits functionality that is not completely matched by any ADT. Hence the management entity may conclude that there is at least one object that cannot be recognized in the current record. In this case the management entity adds all objects that are part of the current record to a set of sixth objects block increments a counter i for each added object block to record the fact that i new objects have been found that do not match any known ADTs and then updates appropriate metadata block to record this conclusion in the set of sixth objects. Otherwise if the functionality of the current record is equal to or a proper subset of the functionality specified by the ADT the management entity can then conclude that the set of objects comprising the current record are all recognized. The management entity then records this fact by updating the metadata associated with the identified object block .

The management entity may check to see if additional records need to be analyzed block . If so then the next record is retrieved block and control is returned to block to repeat the analysis process. If not then the management entity is ready to continue the identification process by attempting to derive at least one model element from the information model that corresponds to the ADT of the information model that matched the previously unidentified objects in the set of first objects . The previous step identified in abstract terms the functionality that the collected data exhibits by matching the collected data to at least one ADT. This is now codified by mapping each matched ADT to at least one model element from the information model. This enables the collected data to be more precisely identified by breaking the data into model elements e.g. classes attributes constraints and relationships . The matching process may involve taking each element specified by the ADT e.g. an attribute or a state value or a relationship or an action and the like and mapping it to a ManageableEntity or a set of ManageableEntities. In addition due to context and data possibly arriving out of order fragmented containing errors and or missing the management entity may choose to examine the data using groups of different objects represent different parts of the collected data.

Accordingly the management system retrieves the first record in the set of first objects block since it has previously processed all of the data collected in the previous loop when it matched objects in the set of first objects to ADTs. The management entity then retrieves the first matched ADT from the previous step and saves a reference to the at least one model element defined in the information model that corresponds to the at least one matched ADT as a set of third objects block . The mapping between the at least one matched ADT in the set of second objects and the at least one model element in the information model i.e. objects in the set of third objects for this record is then written as metadata block . The management entity may compare the functionality present in the current record with the functionality that is specified in the set of third objects block . The management entity tries to match the functionality specified by a set of model elements from the information model that correspond to the previously matched ADT to the functionality presented by the collected data. If the functionality of the current record is not equal to or a proper subset of the functionality specified by the at least one model element block then the management entity may conclude that there is at least one object that cannot be recognized in the current record. Since an ADT was previously recognized this likely means that a new model element needs to be created or that an existing model element needs to be extended e.g. by subclassing or by adding a new relationship or both . An example process for this case is described after this discussion using 

If the functionality of the current record is not equal to or a proper subset of the functionality specified by the at least one model element of the information model the management entity adds all objects that are part of the current record to a set of seventh objects block increments a counter j for each added object block to record the fact that j new objects have been found that match at least one ADT but do not match any known model elements from the information model and then updates appropriate metadata block to record this conclusion in the set of seventh objects. Otherwise if the functionality of the current record is equal to or a proper subset of the functionality specified by the at least one model element in the information model that matches the at least one ADT the management entity can conclude that the set of objects comprising the current record are all recognized and furthermore that they currently exist as a formal part of the information model. In other words the previous test block showed that the information model is capable of representing the current record. However it did not prove that at least one model element form the information model currently exists that can represent this functionality it only proved that this functionality may be represented using one or more ADTs that were used to build the information model. This in turn means that a data model object could not be instantiated to represent this functionality which is why the object is currently not able to be identified i.e. there are no instantiated object instances that can be compared to the part of the collected data being examined . This test block shows that the current record is in fact a part of the information model. However a test still needs to be performed to determine if the current data model defines at least one model element to implement this functionality.

The management entity may test to determine if more records need to be analyzed block . If so then the next record is retrieved block and execution continues at block . If not then control is passed to point B block of . In this part of the technique for replacing unidentified objects with known objects the management entity may try and map each model element from the information model that matched the set of ADTs which matched the functionality of the collected data to at least one model element from at least one data model. This test proves that at least one of the data models currently being used has at least one object defined that corresponds to the functionality of the collected data that are currently being analyzed. Hence the most likely reason that the current record is not recognized is that the at least one model element from the at least one data model has not been instantiated.

Accordingly the management entity saves a reference to the at least one model element defined by the at least one data model being used in the data collection process to a set of fourth objects in block where the at least one model element of the at least one data model corresponds to the at least one model element of the information model that was derived from the at least one ADT that matched the functionality of the current record in the set of first objects . Metadata is defined that records the mappings from the at least one object in the set of fourth objects to the at least one object in the set of third objects block . The management entity may compare the functionality of the at least one model element in the data model in the set of fourth objects with the current record i.e. the at least one object in the set of first objects in block . If the functionality of the current record is not equal to or a proper subset of the functionality specified by the at least one object in the set of fourth objects block the management entity adds all objects that are part of the current record to a set of eighth objects block increments a counter k for each added object block to record the fact that k new objects have been found that match both at least one ADT as well as at least one model element from the information model but do not match any known model elements from the data model and then updates appropriate metadata block to record this conclusion in the set of eighth objects. Otherwise if the functionality of the current record is equal to or a proper subset of the functionality specified by the at least one model element from the set of fourth objects the management entity can conclude that the set of objects comprising the current record are all recognized and furthermore that they are a formal part of at least one data model. In other words the previous test block shows that the information model is capable of representing the current record but did not prove that model elements exist that can be instantiated to represent it. This test block shows that the current record is in fact a part of at least one data model. As such this test also shows that the at least one data model can instantiate an object that will match the functionality of the collected data that is currently being analyzed.

The management entity may test to see if more records need to be analyzed block . If so then the next record is retrieved block and execution continues at block . If not then the first record of the collected data is once again retrieved block and a final test is started. This test attempts to match the current record to at least one instantiated object from at least one of the data models being used.

Accordingly the management entity instantiates at least one object from the at least one model element defined by the at least one data model being used in the data collection process to a set of fifth objects in block where the at least one instantiated object is derived from the at least one model element of the at least one data model and where the at least one model element of the at least one data model corresponds to the at least one model element of the information model that matched the functionality of the at least one ADT which in turn matched the functionality of the current record in the set of first objects . Metadata is defined that records the mappings from the at least one object in the set of fifth objects to the at least one object in the set of fourth objects block . The management entity may compare the functionality of the at least one instantiated object in the set of fifth objects with the current record i.e. the at least one object in the set of first objects in block . If the functionality of the current record is not equal to or a proper subset of the functionality specified by the at least one object in the set of fifth objects block the management entity adds all objects that are part of the current record to a set of ninth objects block increments a counter m for each added object block to record the fact that m new objects have been found that match at least one ADT at least one model element from the information model and at least one model element from the data model but do not match any currently instantiated objects. This information is updated in the appropriate metadata block to record this conclusion in the set of ninth objects. Otherwise if the functionality of the current record is equal to or a proper subset of the functionality specified by the at least one model element from the set of fourth objects the management entity can conclude that the set of objects comprising the current record are all recognized and furthermore that they are a formal part of at least one data model. In other words the previous test block shows that the data model is capable of representing the current record but did not prove that such an object had been instantiated. This test block shows that the current record is in fact a part of at least one data model and has been instantiated.

The management entity may then test to see if more records need to be analyzed block . If so then the next record is retrieved block and execution continues at block . If not then execution continues at point C block of .

This final part of this technique iterates through the previous decisions by using the set of four counters i j k and m to try to recognize as far as possible each object in each record of the collected data. This is done by having the management entity check to ensure that the most concretely recognized object can be mapped to the next level of abstraction. Specifically it performs four checks in the following order 

1 a given instantiated object in the set of ninth objects can be mapped to at least one object that is instantiated from at least one known model element from at least one data model in the set of fourth objects 

2 a given object that previously did not match any model element from any data model in the set of eighth objects can be mapped to at least one model element from at least one data model in the set of fourth objects 

3 a given object that previously did not match any model element from the information model in the set of seventh objects can be mapped to at least one model element from the information model in the set of third objects and

4 a given object that previously did not match any ADTs from the information model in the set of sixth objects can be mapped to at least one new ADT that can be derived from the information model in the set of second objects .

Accordingly in block the value of the m counter is tested. If it is equal to 0 then execution proceeds to block . Otherwise the management entity maps the at least one object that originally did not match any instantiated objects in any of the data models being used i.e. an object in the set of ninth objects to an instantiated object from at least one of the data models i.e. an object in the set of fifth objects block . The instantiated object is then mapped to at least one model element in at least one of the data models being used i.e. an object in the set of fourth objects block . If the result of both of these mappings is OK block then the metadata for all affected objects are updated block the m counter is decremented block and control is returned to block . Otherwise the context is logged block and error processing is started block . The result of the error processing will determine whether this technique continues or is terminated.

In block the value of the k counter is tested. If it is equal to 0 then execution proceeds to block . Otherwise the management entity maps the at least one object that originally did not match any model elements in any of the data models being used i.e. an object in the set of eighth objects to at least one model element from at least one of the data models i.e. an object in the set of fourth objects block . If the result of this mapping is OK block then the metadata for all affected objects are updated block the k counter is decremented block and control is returned to block . Otherwise the context is logged block and error processing is started block . The result of the error processing will determine whether this technique continues or is terminated.

In block the value of the j counter is tested. If it is equal to 0 then execution proceeds to block . Otherwise the management entity maps the at least one object that originally did not match any model elements in the information model i.e. an object in the set of seventh objects to at least one model element from the information model i.e. an object in the set of third objects block . If the result of this mapping is OK block then the metadata for all affected objects are updated block the j counter is decremented block and control is returned to block . Otherwise the context is logged block and error processing is started block . The result of the error processing will determine whether this technique continues or is terminated.

In block the value of the i counter is tested. If it is equal to 0 then this technique is completed and execution is returned to block in . It is noted that this corresponds to blocks and of . Otherwise the management entity maps the at least one newly synthesized ADT from block i.e. an object in the set of sixth objects into the information model block . If the result of this mapping is OK block then the metadata for all affected objects are updated block the i counter is decremented block and control is returned to block . Otherwise the context is logged block and error processing is started block . The result of the error processing will determine whether this technique continues or is terminated.

Referencing back to block in the management entity tests to ensure that all objects have been identified. This is necessary because the preceding test in block only checks for existing objects except for the case of synthesizing a new ADT . Hence the management entity in block tries to synthesize a new object for each unrecognized object found. It is noted that this corresponds to blocks and of . Since there are many ways to perform this task one example solution is shown using and .

Referencing forward to block in the management entity may initialize the system in preparation for attempting to synthesize new objects block . The management entity checks to see if at least one synthesized ADT is present block . If not this technique ends. If so then in block the first synthesized ADT is retrieved. Since an ADT is an abstract concept it may define zero or more attributes and zero or more behaviors with the constraint that at least one attribute or one behavior is defined by the ADT. Therefore in block a check is made to see if the current synthesized ADT defines any attributes. If not control is passed to block where this is recorded as part of the metadata for this ADT. Otherwise the management entity continues to block where it retrieves the first characteristic i.e. attribute or constraint of the current synthesized ADT. The management entity attempts to find at least one model element from the information model to represent the current characteristic of the ADT block . The management entity may check to see if at least one model element from the information model was found block . If not control is passed to block where this is recorded as part of the metadata for this ADT. Otherwise execution continues with block which attempts to disambiguate the relationship of the current characteristic to the set of model elements that could contain this characteristic. For example if the characteristic was the name of a host computer then a number of different object classes such as Computer Device WebServer and others could contain that particular attribute. Hence block uses the knowledge that it currently has about the collected data along with the knowledge inherent in the information model to deduce or infer if that characteristic can be associated with one particular object class block . If this was unsuccessful i.e. if the number of object classes found was not exactly one control is passed to block where this is recorded as part of the metadata for this ADT. Otherwise execution continues with block where the counter i is incremented. The management entity then gets the next characteristic block and control is returned to block .

Once all characteristics of the synthesized ADT are defined the metadata for the ADT and affected model elements is updated in block . In block the management entity checks to see if the synthesized ADT defines any behaviors. If not and i is equal to 0 block then this technique ends and control is passed back to block in . It should be noted that this identified an ADT used for classification purposes only and hence is completely abstract. Otherwise if there are no behaviors defined by this synthesized ADT then control is passed to point A block of for further processing. Otherwise if there is at least one behavior block execution continues with block where the management entity retrieves the first behavior defined in the current synthesized ADT. The management entity attempts to find at least one model element from the information model to represent the behavior defined in the current synthesized ADT block . The management entity checks to see if at least one model element from the information model was found block . If not then control is passed to point A of block . Otherwise if there is at least one model element from the information model that was found the management entity continues with block which disambiguates the relationship of the current behavior to the set of model elements that could contain this behavior. For example if the ADT specifies that a model element must have a particular attribute and the only way to satisfy this requirement is to use a relationship to associate aggregate or composite two model elements together then this could be inferred by the management entity and used to satisfy this particular requirement. Hence block uses the knowledge that it currently has about the collected data along with the knowledge inherent in the information model to deduce or infer if this behavior can be satisfied using at least one model element from the information model. If this was unsuccessful block control is passed to point A block of . Otherwise execution continues with block where the counter j is incremented. The management entity then gets the next behavior block and control is returned to block .

In block of a deterministic acyclic finite state automaton DAFSA also referred to as a directed acyclic word graph DAWG is defined for representing the characteristics and behavior of the synthesized ADT block . Generally a DAFSA is a data structure that typically represents a set of strings and enables query operations to efficiently test whether a given string belongs to the data structure in time proportional to its length. In these respects a DAFSA is very similar to a trie but it is much more space efficient. However it should be noted that the example embodiments presented herein can use a DAFSA a trie or any other suitable data structure as long as the functionality described herein can be met.

At least one new model element is then constructed in accordance with the DAFSA or data structure of equivalent functionality . The at least one new model element is stored as at least one new object in the set of third objects block . Similarly at least one new data model element from at least one data model that is currently being used is constructed and stored in the set of fourth objects block . This enables the management entity to instantiate at least one new object from the at least one new model element from the at least one data model and store this at least one instantiated object as at least one object in the set of fifth objects block .

The management entity may then verify that the functionality of the newly instantiated object in the set of fifth objects equals the functionality of the record currently being analyzed block . If so then the metadata for all affected objects i.e. any objects in the set of second objects ADTs any objects in the set of third objects model elements from the information model any objects in the set of fourth objects model elements from any one of the data models and any objects in the set of fifth objects object instances are updated block and a check is made to see if there are any more synthesized ADTs that need analysis. If not then this technique ends and control is returned back to block in . Otherwise execution continues with block where the next synthesized ADT is retrieved. Control is then passed to point B block in .

If the functionality of the first object does not equal the functionality of the newly synthesized object then the context is logged block and a set of alternative techniques are attempted in order of increasing complexity. First data type substitution is tried. Accordingly in block a data type is selected based on the DAFSA and a transformation function is defined block to transform the first object to a new object using data type substitution. It should be noted that this step may chain transformations together in the case of complex object construction e.g. an attribute that is in reality an object that has its own attributes relationships and behavior as well as in the case of constructing complex transformations e.g. it is typically simpler and more effective to construct a complex transformation as a set of simpler transformations this also encourages reuse of the set of simpler transformations . This may solve cases where an existing model element defines an attribute of one data type e.g. an integer but higher precision is specified by the newly synthesized ADT e.g. a floating point number . The result of this transformation is checked in block . If the match is successful block the metadata for all affected objects is updated in block and control is passed to point C block in . Otherwise n gram analysis is attempted in block .

Generally an n gram is a contiguous sequence of n items from a given sequence of text or speech. Typically a n gram is a combination of letters. However n grams that use lexemes morphemes phonemes syllables or other components of a given language can also be used. For the purposes of the example embodiments n gram based approaches are used to encode the likelihood that a word or phrase will appear in the future. An example embodiment is shown in

Referencing forward from block in to block in the management entity retrieves the first synthesized ADT block . It retrieves pre defined n gram weights block which can be used to better adjust the stochastic model being used. Alternatively other approaches such as repetition of lexemes and morphemes may be used instead of or in addition to the weighted approach as appropriate. The collected data is analyzed in block . The output of the n gram analysis can be measured by several different mechanisms. One example method is to define a set of profiles that categorize expected words or phrases and then compare the profile for the collected data to the set of category profiles. The set of differences between n grams of any single category profile and the profile for the collected data can be defined as the distance between that category and the collected data block . The distance is one type of semantic relatedness function. Other examples can be defined as well. As an example different sets of collected data can be represented as a vector with values of term weights used for each n gram. Inverse document frequency IDF which is a measure of how important a given n gram is for categorizing the text in an item can be used to reduce the dimension of the vector space.

Blocks and are example mechanisms and represent the use of at least two different measurements both based on n grams to categorize the data collected. If no matches are found block the context is logged in block and appropriate error processing is executed block . Otherwise the synthesized ADT can be classified and stored in a set of second objects block . This enables at least one new model element defined in the information model to be constructed by using the definition of the synthesized ADT. The at least one new model element is then stored as at least one object in the set of third objects block . Given at least one new model element from the information model at least one new model element from at least one data model can be constructed. The at least one new model element from the at least one data model is stored as at least one object in a set of fourth objects block . This new object can be instantiated and stored as at least one object in the set of fifth objects block which enables the management entity to compare the characteristics and behavior of the at least one instantiated object with the synthesized ADT block . If the two are not equal the context is logged and error processing is initiated blocks and respectively . It is noted that blocks and may be the same as blocks and . However they are labeled differently to prevent confusion. Otherwise the metadata of all affected objects i.e. any objects in the set of second objects ADTs any objects in the set of third objects model elements from the information model any objects in the set of fourth objects model elements from any one of the data models and any objects in the set of fifth objects object instances is updated block . The management entity may check to see if any more synthesized ADTs exist block . If not then this technique terminates and control is returned to block in . Otherwise the next synthesized ADT is retrieved block and control is returned in block .

Referring back to block in the management entity may use one or more mechanisms including feature based matching structure based matching behavior based matching semantic relatedness matching and the like to further classify the collected data block . Specifically these mechanisms enable the characteristics and behavior of the newly synthesized object to be better understood so that a more complete definition of it can be computed. As an example these different types of matching mechanisms may find additional model elements such as relationships or constraints which apply to the newly synthesized object. The management entity may check the results of the application of one or more of the matching methods in block . If there are matches then the metadata of all affected objects are updated in block and execution is passed to point C in i.e. block . Otherwise execution continues to block where linguistic models are used to synthesize the object. This block represents a set of computational linguistic approaches that can be used to classify and mine specific text using language models. The management entity may check the results of the application of one or more of the matching methods in block . If there are matches then the metadata of all affected objects are updated in block and execution is passed to point C in i.e. block . Otherwise execution continues to block where domain specific models are used to validate the synthesized object. This block represents a set of approaches such as Entity Relationship Diagrams ERDs which provide domain specific knowledge that can be used to more precisely model entities that are expected to be present in the collected data. The management entity may check the results of the application of one or more of the matching methods in block . If there are matches then the metadata of all affected objects are updated in block and execution is passed to point C in i.e. block . Otherwise execution continues to block which performs appropriate error processing. The result of the error processing will determine the next action taken by the management entity.

Referencing back to block in the management entity may then check to see if all objects that in the currently collected data have been identified block . If so in block the management entity checks to determine if there are other objects that may need to be identified. If so the management entity returns to block . Otherwise the management entity continues to point A block of . If all objects have still not been identified error processing is performed block and this technique ends.

Referencing forward to block the collected data which have all now been identified are validated such as previously described in through block . The management entity checks to see if any other dependencies exist that use this particular data model block . If so the next dependency is retrieved block and execution returns to point B block in . If not then the management entity checks to see if any other protocols exist that use this set of dependencies with this particular data model block . If so the next protocol is retrieved block and execution returns to point C block in . If not then the management entity checks to see if any other data models exist that use this set of dependencies and this protocol block . If so then the next data model is retrieved block and execution returns to point D block in . If not then this technique ends and control is returned to block in it is noted that block and have already been processed in and .

The management entity makes a final check to ensure that all objects in all collected data have been identified block of . If not then there are no other ways that this management entity has to identify an object and more complex checks to establish the presence of new objects ensues block .

Referencing forward to four nested loops are constructed to cover four types of matching in order to start more complex object identification processes blocks and . These blocks will iterate over each object in the set of second third fourth and fifth sets of objects i.e. each ADT model element of the information model model element of all data models and object instances that have been instantiated to check for deep equality between the original object from the collected data i.e. the object in the set of first objects that has not yet been recognized and the object being compared to i.e. the object in the set of second third fourth or fifth objects . Deep equality checks that objects are not only the same type but their attributes constraints and relationships are also the same. This applies recursively for each model element such as arrays. Deep equality also checks for null equality. The reason that deep equality is used is to ensure that the syntax and semantics of the two objects are the same.

Accordingly in block the unrecognizable object is compared to the first object in the set of fifth objects e.g. each object instance from each model element from each data model being used . Conceptually this checks to see if any object has been instantiated from any of the data models being used that is deeply equal to this unknown object. This is the simplest of the four tests. If the objects are equal then the previously unrecognizable object has been identified. This is useful for situations in which an object was originally instantiated and then removed. If the result of the test in block is true then in block the metadata for the objects being compared is updated. Then a check for more objects in the set of first objects is performed block . If there more first objects to check the next first object is retrieved the first object in the set of fifth objects is retrieved and control is returned to block . If there are no more first objects to check then control is passed to point B in block .

If the unrecognizable object is compared to the first object in the set of fifth objects block and the result is not equal then a check is made to see if there are any more objects in the set of fifth objects to compare. If there is the next fifth object is retrieved and control is returned to block . If not then the unrecognizable object does not match any instantiated object from any data model and hence has not yet been identified. Consequently the unrecognizable object is then compared to the first object in the set of fourth objects block . This is useful for situations in which a model element from a data model was never instantiated. If the result of the test in block is true then in block the metadata for the objects being compared is updated. Then a check for more objects in the set of first objects is performed block . If there more first objects to check the next first object is retrieved the first object in the set of fifth objects is retrieved and control is returned to block . If there are no more first objects to check then control is passed to point B in block .

If the unrecognizable object is compared to the first object in the set of fourth objects block and the result is not equal then a check is made to see if there are any more objects in the set of fourth objects to compare. If there is the next fourth object is retrieved and control is returned to block . If not then the unrecognizable object does not match any model element from any data model and hence has not yet been identified. Consequently the unrecognizable object is then compared to the first object in the set of third objects block . This is useful for situations in which a model element from an information model was never mapped into an object for any data model. If the result of the test in block is true then in block the metadata for the objects being compared is updated. Then a check for more objects in the set of first objects is performed block . If there more first objects to check the next first object is retrieved the first object in the set of fifth objects is retrieved and control is returned to block . If there are no more first objects to check then control is passed to point B in block .

If the unrecognizable object is compared to the first object in the set of third objects block and the result is not equal then a check is made to see if there are any more objects in the set of third objects to compare. If there is the next third object is retrieved and control is returned to block . If not then the unrecognizable object does not match any model element from the information model and hence has not yet been identified. Consequently the unrecognizable object is then compared to the first object in the set of second objects block . This is useful for situations in which an ADT was never mapped into a model element from the information model. If the result of the test in block is true then in block the metadata for the objects being compared is updated. Then a check for more objects in the set of first objects is performed block . If there more first objects to check the next first object is retrieved the first object in the set of fifth objects is retrieved and control is returned to block . If there are no more first objects to check then control is passed to point B in block .

Otherwise execution continues to block where data collection processing analysis is performed as previously described using and .

The analyzed data is then saved in block . The management entity may then determine if at least one data transformations are needed block . If not then this technique ends. Otherwise the set of data transformations is defined executed and saved in blocks and respectively. These operations were previously described in respectively.

A data collector is configured to collect data for MangeableEntities in a communications system coupled to device . Data collector utilizes knowledge derived from an information model of the communications system and a data model s that is an instantiation of the information model to select a protocol s to collect the data. The knowledge may also be used to select a combination of none or more pre processing post processing pre storage and post storage to process the collected data.

A request processing unit is configured to process a request for device to collect data for ManageableEntities in the communications system. A dependency processing unit is configured to determine dependencies present in the request and to form a dependency list. Dependency processing unit detects several different types of dependencies including a type of data to collect a type of protocol to use to collect each type of data types of pre processing operations and or post processing operations to be performed on each type of data and types of pre storage and or post storage operations for each type of data. An information model processing unit is configured to retrieve an information model of the communications system e.g. the information model may be retrieved from a memory or an entity coupled to device . A data model processing unit is configured to determine specific data model s that are required to collect the data requested in the request. As an example dependencies between a type of managed object that uses a specific set of data types that require a particular access pattern along with other characteristics may be used to imply the need for one or more protocols data stores pre processing and or post processing functions and pre storage and or post storage functions. Similar arguments can be made for the other types of dependencies. These dependencies collectively may be used to determine the data model s that are required. A data collecting unit is configured to collect the data from the ManageableEntities in the communications system. Data collecting unit may stream the collected data and may include facilities for managing data that is delivered out of order fragmented missing and the like.

A data transformer is configured to transform collected data in a first schema into a format compatible with a second schema. Data transformer makes use of knowledge provided by the information model and or the data model s . A schema processing unit is configured to determine if the collected data requires transformation. If transformation is required schema processing unit retrieves the second schema which may be stored in a memory or a remote entity. A transformation determining unit is configured to determine a transformation s to be used to transform the collected data from the first schema to the second schema. The transformation s may be a mapping function that maps instances of the first schema to the second schema. A transformation processing unit is configured to apply the transformation s to the collected data.

A data analyzer is configured to perform data analysis including object identifying object replacing object synthesizing and the like. An object identifying unit is configured to identify objects present in the collected data. Object identifying unit is also configured to mark unidentified objects or unrecognizable objects. An object replacing unit is configured to replace an unidentified object or an unrecognizable object with an object that is identifiable or recognizable. An object synthesizing unit is configured to synthesize an object for each unidentified or unrecognizable object found in the collected data.

A memory is configured to store the information model the data model s the pre processing the post processing the pre storage and the post storage the collected data the transformation the transformed data schemas and the like. Memory may be a physical memory such as a disk drive solid state memory or a combination of the two. Memory may be physically a part of device it may be remotely located or a combination of the two. Memory may also consist of physical memory that is virtualized thereby enabling multiple physical memory elements to be treated as a single pool of memory that can be allocated on an as needed basis. A user interface includes hardware and or software to permit user interaction with device . As an example user interface includes a display a keyboard a touch pad a voice recognition system a speaker a mouse a stylus and the like to allow the user to interact with device .

The elements of device may be implemented as specific hardware logic blocks. In an alternative the elements of device may be implemented as software executing in a processor controller application specific integrated circuit or so on. In yet another alternative the elements of device may be implemented as a combination of software and or hardware.

As an example transmitter and receiver may be implemented as a specific hardware block while data collector including request processing unit dependency processing unit information model processing unit data model processing unit and data collecting unit data transformer including schema processing unit transformation determining unit and transformation processing unit and data analyzer including object identifying unit object replacing unit and object synthesizing unit may be software modules executing in a processor a microprocessor a custom circuit or a custom compiled logic array of a field programmable logic array. It is noted that processor the microprocessor the custom circuit the custom compiled logic array and the like may be implemented in a multiple processing unit configuration that may be local to one another or distributed and coupled through a communications network. Data collector including request processing unit dependency processing unit information model processing unit data model processing unit and data collecting unit data transformer including schema processing unit transformation determining unit and transformation processing unit and data analyzer including object identifying unit object replacing unit and object synthesizing unit may be stored as modules in memory .

Advantageous features of example embodiments may include a method for management entity operations the method comprising receiving by a management entity a request to collect data for an entity in a communications system collecting by the management entity the data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system and saving by the management entity the data collected.

The method could further include forming the dependency list comprising saving references to objects in the data collected as a set of first objects determining a first set of Abstract Data Types ADTs to represent a behavior of an object in the set of first objects wherein the first set of ADTs comprises a specification of at least one of a functionality an axiom a pre condition a post condition and an invariant of the first set of ADTs storing the first set of ADTs as a set of second objects determining a second set of ADTs to represent a behavior of a first protocol used to collect the data storing the set of second ADTs as a set of third objects and comparing a first compared object from the set of second objects to at least one second compared object from the set of third objects where the comparing comprises determining that a behavior of the first compared object constrains the behavior of the at least one second compared object determining a type of constraint by the behavior of the first compared object wherein the type of constraint comprises one of a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype a subtype and a supertype and saving as a new object in a set of fourth objects references to the first compared object the at least one second compared object the behavior of the first compared object constraining the behavior of the at least one second compared object and the type of constraint by the behavior of the first compared object.

The method could further include repeating determining the first set of ADTs for remaining objects in the set of first objects and adding the first set of ADTs to the set of second objects.

The method could further include repeating determining the second set of ADTs for remaining protocols in the set of protocols and adding the second set of ADTs to the set of third objects.

The method could further include repeating for remaining objects in a set of second objects determining that a behavior of the first compared object constrains a behavior of the at least one second compared object determining the type of constraint the behavior of the first compared object wherein the type of constraint comprises a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype a subtype and a supertype and saving as a new object in the set of fourth objects references to the first compared object the at least one second compared object the behavior of the first compared object constraining the behavior of the at least one second compared object and the type of constraint the behavior of the first compared object.

The method could further include repeating for a group of two or more objects in the set of second objects determining that a behavior of the first compared object constrains a behavior of the at least one second compared object and saving as a new object in the set of fourth objects references to the group of two or more objects in the set of second objects the at least one compared second object and the behavior of the first compared object that constrains the behavior of the group of two or more objects.

The method could further include wherein determining the first set of ADTs comprises mapping an object in the set of first objects that is incapable of being mapped to an object in a set of seventh objects to a set of nineteenth objects mapping objects in the set of nineteenth objects to at least one model element in a set of fifth objects mapping the at least one model element in the set of fifth objects to an object in a set of sixth objects instantiating the object in the set of sixth objects as an object in a set of seventh objects and comparing each object in the set of seventh objects to a corresponding object in the set of first objects wherein the comparing comprises determining whether the object in the set of seventh objects and the corresponding object in the set of first objects have identical behavior and saving results of the determining into metadata associated with the object in the set of seventh objects.

The method could further include wherein determining the first set of ADTs comprises mapping each object in the set of second objects to an object of a set of fifth objects wherein each object in the set of fifth objects corresponds to a model element defined in the information model adding first metadata to each object in the set of fifth objects wherein the first metadata defines the mapping from the object in the set of fifth objects to one or more objects in the set of second objects mapping each object in a set of fifth objects to an object in a set of sixth objects and adding second metadata to each object in the set of sixth objects wherein the second metadata defines the mapping from the object in the set of sixth objects to at least one object in the set of fifth objects.

The method could further include instantiating and saving a reference to each object in the set of sixth objects in a set of seventh objects comparing each object in the set of seventh objects to a corresponding object in the set of first objects wherein the comparing comprises determining whether the object in the set of seventh objects and the corresponding object in the set of first objects have identical behavior and saving results of comparing each object in third metadata associated with objects in the set of seventh objects.

The method could further include wherein collecting the data further comprises determining a set of pre processing algorithms from the first data model in the data model list to transform the data collected into a form preferred by an application using the data collected determining a second set of dependencies between the data collected and the set of pre processing algorithms and collecting the data utilizing the set of pre processing algorithms in accordance with the second set of dependencies wherein the second set of dependencies constrains pre processing algorithms used to transform the data.

The method could further include wherein forming the dependency list comprises determining a third set of ADTs to represent a behavior of a first pre processing algorithm to transform the data collected into a form preferred by the application using the data collected storing the third set of ADTs as a set of eleventh objects and comparing a first compared object from the set of second objects to the at least one second compared object in the set of eleventh objects wherein the comparing comprises determining that the behavior of the first compared object constrains the behavior of the at least one second compared object determining the type of constraint by the behavior of the first compared object wherein the type of constraint comprises a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype a subtype and a supertype and saving as a new object in a set of fourth objects references to the first compared object the at least one second compared object the behavior of the first compared object constraining the behavior of the at least one second compared object and the type of constraint by the behavior of the first compared object.

The method could further include repeating determining the third set of ADTs to represent the behavior for remaining pre processing algorithms in the set of eleventh objects and adding the set of third ADTs to a set of second objects.

The method could further include repeating comparing the first compared object from the set of second objects to the at least one second compared object in the set of eleventh objects for remaining objects in a set of second objects.

The method could further include wherein determining the first data model in the data model list in accordance with the dependency list and the subset of the information model comprises mapping each object in a set of eleventh objects to a fourth concrete data structure in a set of eighth objects storing the fourth concrete data structure in a set of eighth objects defining an association between an object in a set of second objects and an object in the set of eleventh objects as a fifth concrete data structure in the set of eighth objects storing the fifth concrete data structure in the set of eighth objects and using a set of first concrete data structures the set of fourth concrete data structures and the set of fifth concrete data structures to add the first data model to the data model list.

The method could further include wherein determining the set of pre processing algorithms comprises defining a set of candidate pre processing algorithms as a set of twelfth objects wherein the set of twelfth objects is a subset of a set of sixth objects determining for each object in the set of twelfth objects whether the object is capable of operating on a subset of objects in the set of sixth objects and a subset of objects in a set of ninth objects without adversely affecting the behavior of at least one of the set of sixth objects and the set of ninth objects and eliminating the objects that are not capable from the set of twelfth objects.

The method could further include wherein forming the dependency list comprises determining a fourth set of ADTs to represent a behavior of a first post processing algorithm to transform the data collected into a form preferred by the application using the data collected storing the fourth set of ADTs as a set of thirteenth objects and comparing a first compared object from a set of second objects to the at least one second compared object in the set of thirteenth objects wherein the comparing comprises determining that a behavior of the first compared object constrains a behavior of the at least one second compared object determining the type of constraint by the behavior of the first compared object wherein the type of constraint comprises a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype a subtype and a supertype and saving as a new object in a set of fourth objects references to the first compared object the at least one second compared object and the type of constraint by the behavior of the first compared object.

The method could further include repeating determining of the fourth set of ADTs to represent the behavior for remaining post processing algorithms in the set of thirteenth objects and adding the fourth set of ADTs to a set of second objects.

The method could further include repeating comparing the first compared object from the set of second objects to the at least one second compared object in the set of thirteenth objects for remaining objects in a set of second objects.

The method could further include wherein determining the first data model in the data model list in accordance with the dependency list and the subset of the information model comprises mapping each object in a set of thirteenth objects to a sixth concrete data structure in a set of eighth objects storing the sixth concrete data structure in the set of eighth objects defining an association between an object in a set of second objects and an object in the set of thirteenth objects as a seventh concrete data structure in the set of eighth objects storing the seventh concrete data structure in the set of eighth objects and using a set of first concrete data structures the set of sixth concrete data structures and the set of seventh concrete data structures to add the first data model to the data model list.

The method could further include wherein determining the set of post processing algorithms comprises defining a set of candidate post processing algorithms as a set of fourteenth objects wherein the set of fourteenth objects is a subset of a set of sixth objects determining for each object in the set of fourteenth objects whether the object is capable of operating on a subset of objects in the set of sixth objects and a subset of objects in a set of ninth objects without adversely affecting the behavior of at least one of the set of sixth objects and the set of ninth objects and eliminating the objects that are not capable from the set of fourteenth objects.

The method could further include wherein forming a dependency list comprises determining a fifth set of ADTs to represent a behavior of a first pre storage algorithm that is used to store the data collected before the data collected has been completely processed and delivered to the application using the data collected storing the fifth set of ADTs as a set of fifteenth objects and comparing a first compared object from the set of second objects to the at least one second compared object in the set of fifteenth objects wherein the comparing comprises determining that a behavior of the first compared object constrains a behavior of the at least one second compared object determining the type of constraint by the behavior of the first compared object wherein the type of constraint comprises a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype subtype and a supertype and saving as a new object in a set of fourth objects references to the first compared object the at least one second compared object and the type of constraint by the behavior of the first compared object.

The method could further include repeating determining the fifth set of ADTs to represent the behavior for remaining pre storage algorithms in the set of fifteenth objects and adding the fifth set of ADTs to a set of second objects.

The method could further include repeating comparing the first compared object from the set of second objects to the at least one second compared object in the set of fifteenth objects for remaining objects in a set of second objects.

The method could further include wherein determining the first data model in the data model list in accordance with the dependency list and the subset of the information model comprises mapping each object in a set of fifteenth objects to an eighth concrete data structure in a set of eighth objects storing the eighth concrete data structure in the set of eighth objects defining an association between an object in a set of second objects and an object in the set of fifteenth objects as a ninth concrete data structure in the set of eighth objects storing the ninth concrete data structure in the set of eighth objects and using a set of first concrete data structures the set of eighth concrete data structures and the set of ninth concrete data structures to add the first data model to the data model list.

The method could further include wherein determining the set of pre storage algorithms comprises defining a set of candidate pre storage algorithms as a set of sixteenth objects wherein the set of sixteenth objects is a subset of a set of sixth objects determining for each object in the set of sixteenth objects whether the object is capable of operating on a subset of objects in the set of sixth objects and a subset of a set of ninth objects without adversely affecting the behavior of at least one of the set of sixth objects and the set of ninth objects and eliminating the objects that are not capable from the set of sixteenth objects.

The method could further include wherein forming a dependency list comprises determining a sixth set of ADTs to represent a behavior of a first post storage algorithm that is used to store the data collected after the data collected has been completely processed and delivered to the application using the data collected storing the sixth set of ADTs as a set of seventeenth objects and comparing a first compared object from the set of second objects to the at least one second compared object in the set of seventeenth objects wherein the comparing comprises determining that a behavior of the first compared object constrains a behavior of the at least one second compared object determining the type of constraint by the behavior of the first compared object wherein the type of constraint comprises a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype a subtype and a supertype and saving as a new object in a set of fourth objects references to the first compared object the at least one second compared object and the type of constraint by the behavior of the first compared object.

The method could further include repeating determining the sixth set of ADTs to represent the behavior for remaining post storage algorithms in the set of seventeenth objects and adding the sixth set of ADT to a set of second objects.

The method could further include repeating comparing the first compared object from the set of second objects to the at least one second compared object in the set of seventeenth objects for remaining objects in a set of second objects.

The method could further include wherein determining the first data model in the data model list in accordance with the dependency list and the information model comprises mapping each object in a set of seventeenth objects to a tenth concrete data structure in a set of eighth objects storing the tenth concrete data structure in the set of eighth objects defining an association between an object in a set of second objects and an object in the set of seventeenth objects as an eleventh concrete data structure in the set of eighth objects storing the eleventh concrete data structure in the set of eighth objects and using a set of first concrete data structures the set of tenth concrete data structures and the set of eleventh concrete data structures to add the first data model to the data mode list.

The method could further include wherein determining the set of post storage algorithms comprises defining a set of candidate post storage algorithms as a set of eighteenth objects wherein the set of eighteenth objects is a subset of a set of sixth objects determining for each object in the set of eighteenth objects whether the object is capable of operating on a subset of objects in the set of sixth objects and a subset of objects in a set of ninth objects without adversely affecting the behavior of at least one of the set of sixth objects and the set of ninth objects and eliminating the objects that are not capable from the set of eighteenth objects.

Advantageous features of example embodiments may include a management entity comprising a receiver configured to receive a request to collect data for an entity in a communications system and a processor operatively coupled to the receiver the processor configured to collect the data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system and to save the data collected.

The management entity could further include wherein the processor is configured to save references to objects in the data collected as a set of first objects to determine a first set of Abstract Data Types ADTs to represent a behavior of an object in the set of first objects wherein the first set of ADTs comprises a specification of at least one of a functionality an axiom a pre condition a post condition and an invariant of the first set of ADTs to store the first set of ADTs as a set of second objects to determine a second set of ADTs to represent a behavior of a first protocol used to collect the data to store the set of second ADTs as a set of third objects and to compare a first compared object from the set of second objects to at least one second compared object from the set of third objects wherein the processor is configured to determine that a behavior of the first compared object constrains the behavior of the at least one second compared object to determine a type of constraint by the behavior of the first compared object wherein the type of constraint comprises one of a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype a subtype and a supertype and to save as a new object in a set of fourth objects references to the first compared object the at least one second compared object the behavior of the first compared object constraining the behavior of the at least one second compared object and the type of constraint by the behavior of the first compared object.

The management entity could further include wherein the processor is configured to map a first object in a set of second objects to a first concrete data structure to store in a set of eighth objects a reference to the first concrete data structure to map each object in a set of third objects to a second concrete data structure to store the second concrete data structure in the set of eighth objects to determine an association between objects in the set of second objects and objects in the set of third objects as a third concrete data structure to store the third concrete data structure in the set of eighth objects and to use the first concrete data structure the second concrete data structure and the third concrete data structure to select the first data model.

The management entity could further include wherein the processor is configured to determine a set of pre processing algorithms from the first data model in the data model list to transform the data collected into a form preferred by an application using the data collected to determine a second set of dependencies between the data collected and the set of pre processing algorithms and to collect the data utilizing the set of pre processing algorithms in accordance with the second set of dependencies wherein the second set of dependencies constrains pre processing algorithms used to transform the data.

The management entity could further include wherein the processor is configured to determine a third set of ADTs to represent a behavior of a first pre processing algorithm to transform the data collected into a form preferred by the application using the data collected to store the third set of ADTs as a set of eleventh objects and to compare a first compared object from the set of second objects to the at least one second compared object in the set of eleventh objects wherein the processor is configured to determine that the behavior of the first compared object constrains the behavior of the at least one second compared object to determine the type of constraint by the behavior of the first compared object wherein the type of constraint comprises a hyponym a hypernym a holonym a meronym a behavioral subtype a behavioral supertype a subtype and a supertype and to save as a new object in a set of fourth objects references to the first compared object the at least one second compared object the behavior of the first compared object constraining the behavior of the at least one second compared object and the type of constraint by the behavior of the first compared object.

The management entity could further include wherein the processor is configured to determine a set of post processing algorithms from the first data model in the data model list that is used to transform the data collected into a form preferred by an application using the collected data to determine a third set of dependencies between the data collected and the set of post processing algorithms and to collect the data utilizing the set of post processing algorithms in accordance with the third set of dependencies wherein the third set of dependencies constrains post processing algorithms used to transform the data.

The management entity could further include wherein the processor is configured to determine a set of pre storage algorithms from the first data model in the data model list to store the data collected prior to the data collected being completely processed and delivered to an application using the data collected to determine a fourth set of dependencies between the data collected and the set of pre storage algorithms and to collect the data utilizing the set of pre storage algorithms in accordance with the fourth set of dependencies wherein the fourth set of dependencies constrains pre storage algorithms used to store the data.

The management entity could further include wherein the processor is configured to determine a set of post storage algorithms from the first data model in the data model list to store the data collected after the data collected has been completely processed and delivered to an application using the data collected to determine a fifth set of dependencies between the data collected and the set of post storage algorithms and to collect the data utilizing the set of post storage algorithms in accordance with the fifth set of dependencies wherein the fifth set of dependencies constrains the post storage algorithms used to store the data.

Advantageous features of example embodiments may include a method for management entity operations the method comprising receiving by a management entity a request to collect data for an entity in a communications system collecting by the management entity data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system detecting by the management entity that the data collected includes an object that cannot be recognized replacing by the management entity the unrecognizable object in the data collected with an equivalent recognizable object thereby producing revised data collected and saving by the management entity the revised data collected.

The method could further include wherein the determining that the first object in the set of first objects cannot be instantiated from the set of fourth objects comprises instantiating objects in the set of fourth objects as objects in a set of fifth objects wherein metadata associated with the set of fifth objects includes mapping information from objects in the set of fourth objects to objects in the set of fifth objects comparing objects in the set of first objects to objects in the set of fifth objects and verifying that there is additional functionality and behavior of objects in the set of first objects not present in the objects in the set of fifth objects.

The method could further include repeating the determining that the first object in the set of first objects cannot be instantiated from the set of fourth objects for each object in the set of first objects that cannot be recognized.

The method could further include repeating the determining that the first object in the set of first objects cannot be instantiated from the set of fourth objects for each object in the set of first objects that cannot be recognized.

The method could further include wherein the replacing comprises synthesizing an ADT a second object to represent at least one of a characteristic and a behavior of the unrecognizable object generating a new third object as a new first model element in the information model in accordance with the ADT generating a new fourth object as a new second model element in the data model in accordance with the new first model element instantiating a new fifth object for the new second model element in accordance with the new second model element verifying that the new fifth object provides the same characteristics and behavior as the object in the set of first objects adding and saving the second object to a set of second objects the third object to a set of third objects the fourth object to a set of fourth objects and the fifth object to a set of fifth objects and updating the metadata of the fifth object wherein metadata associated with the fifth object includes mapping information from objects in the set of third objects to objects in the set of fourth objects and mapping information from objects in the set of fourth objects to objects in the set of fifth objects.

Advantageous features of example embodiments may include a management entity comprising a receiver configured to receive a request to collect data for an entity in a communications system and a processor operatively coupled to the receiver the processor configured to collect data for the entity utilizing a set of protocols selected using knowledge defined by a first data model of a data model list derived from an information model of the communications system to detect that the data collected includes an object that cannot be recognized to replace the unrecognizable object in the data collected with an equivalent recognizable object thereby producing revised data collected and to save the revised data collected.

The management entity could further include wherein the processor is configured to determine that an ADT in a set of second objects has at least the same first set of behaviors as the object in the set of first objects to map a second set of behaviors of the ADT in the set of second objects to a model element in a set of third objects to map the model element in the set of third objects to a model element in a set of fourth objects to instantiate an object from the set of fourth objects to an object in the set of fifth objects to compare the object in the set of fifth objects to the object in the set of first objects to determine that the result of the comparison is an equality to update the metadata of objects in the set of second objects objects in the set of third objects objects in the set of fourth objects and objects in the set of fifth objects that were used to produce a new object whose behavior is the same as the first object in the set of first objects and to replace and save the object from the set of first objects with the object from the set of fifth objects.

The management entity could further include wherein the processor is configured to form and save a set of first references to each object in the data collected as a set of first objects to form and save a set of second references to each object having an Abstract Data Type ADT defined by the information model as a set of second objects to form and save a set of third references to each model element defined by the information model as a set of third objects in accordance with each object in the set of second objects wherein metadata associated with the set of third objects includes mapping information from objects in the set of third objects to objects in the set of second objects to form and save a set of fourth references to each model element defined by the data model as a set of fourth objects in accordance with each object in the set of third objects wherein metadata associated with the set of fourth objects includes mapping information from objects in the set of fourth objects to objects in the set of third objects to determine that a first object in the set of first objects cannot be instantiated from the set of fourth objects and to save the first object in a set of sixth objects.

The management entity could further include wherein the processor is configured to instantiate objects in the set of fourth objects as objects in a set of fifth objects wherein metadata associated with the set of fifth objects includes mapping information from objects in the set of fourth objects to objects in the set of fifth objects to compare objects in the set of first objects to objects in the set of fifth objects and to verify that there is additional functionality and behavior of objects in the set of first objects not present in the objects in the set of fifth objects.

The management entity could further include wherein the processor is configured to synthesize an ADT a second object to represent at least one of a characteristic and a behavior of the unrecognizable object to generate a new third object as a new first model element in the information model in accordance with the ADT to generate a new fourth object as a new second model element in the data model in accordance with the new first model element to instantiate a new fifth object for the new second model element in accordance with the new second model element to verify that the new fifth object provides the same characteristics and behavior as the object in the set of first objects to add and save the second object to a set of second objects the third object to a set of third objects the fourth object to a set of fourth objects and the fifth object to a set of fifth objects and to update the metadata of the fifth object wherein metadata associated with the fifth object includes mapping information from objects in the set of third objects to objects in the set of fourth objects and mapping information from objects in the set of fourth objects to objects in the set of fifth objects.

The management entity could further include wherein the processor is configured to retrieve a set of pre calculated weighted n gram statistics for each data type defined by a set of ADTs in the set of second objects where n is a value optimized for a set of expected data types to assign each n gram found in the data collected a data type from a set of known data types defined by the set of ADTs in the set of second objects to apply the assigned data type to the unrecognizable object thereby generating a new recognizable object to verify that the new recognizable object has equivalent functionality and behavior to the originally unrecognizable object to replace the unrecognizable object with the newly created recognizable object and to save a reference to the data collected including the recognizable object.

The management entity could further include wherein the processor is configured to select a data type from the set of known data types to transform an object in the set of first objects using a transformation function and the selected data type to produce a new object to save the new object in the set of sixth objects to verify that an object in the set of fifth objects contains the behavior of the new object in the set of sixth objects to save the transformation function and a relationship between the new object and the object in the set of fifth objects as metadata in the new object and to save a reference to the new object in the set of fifth objects.

The management entity could further include wherein the processor is configured to determine a number of elements present in the new object wherein the element includes a model element derived from the set of fourth objects to store the model element in a set of seventh objects and to write in each object in the set of seventh objects metadata defining which data type is used to make the new object recognizable which element was recognized by applying the data type which object of the set of fourth objects matches the element and which object in the set of first objects is used to derive the new object.

The management entity could further include wherein the processor is configured to determine that there is an object where a first subset of the elements of the object is now recognizable and a second subset of the elements of the object is still unrecognizable to apply a second data type from the set of data types to an unrecognizable element in the second subset of elements thereby making the unrecognizable element recognizable to record the second data type used to make the unrecognizable element recognizable and from which object the unrecognizable element is contained by updating the metadata for the object in the set of sixth objects and to store in a set of seventh objects each object in the first subset of elements of the object with its associated elements.

The management entity could further include wherein the processor is configured to use at least one of feature based matching structure based matching behavior based matching and semantic relatedness matching to identify the element contained in the object in the set of first objects to record an algorithm used to make the object recognizable and the object from the set of first objects used to derive the new object by updating metadata for objects in the set of seventh objects and to save a reference to the element successfully recognized in the set of seventh objects.

Advantageous features of example embodiments may include a method for management entity operations the method comprising receiving by a management entity a request to collect data for an entity in a communications system collecting by the management entity data for the entity detecting by the management entity that the data collected contains an object that cannot be recognized determining by the management entity that the unrecognizable object is a new object not previously known to the management entity defining by the management entity a new Abstract Data Type ADT to represent the behavior of the unrecognizable object mapping by the management entity the new ADT to a new model element in an information model mapping by the management entity the new model element in the information model to a new model element in a data model and saving by the management entity the new model element in the information model.

The method could further include attaching an annotation to at least one of the collecting the detecting the determining the defining the mapping the new ADT the mapping the new model element and the saving.

The method could further include wherein the detecting comprises translating the data collected into a first reference to a first object in a set of first objects forming and saving a set of second references to each ADT defined by the information model as a set of second objects forming and saving a set of third references to a model element defined by the information model as a set of third objects wherein the set of third references includes metadata containing mapping information from a first object in a set of second objects to an object in the set of third objects forming and saving a set of fourth references to a model element defined by the data model as a set of fourth objects wherein the set of fourth references includes metadata containing mapping information from a second object in the set of third objects to an object in the set of fourth objects forming and saving a set of fifth references to an object instantiated by the model element in the set of fourth objects as a set of fifth objects wherein the set of fifth references includes metadata containing mapping information from each object in the set of fourth objects to each object in the set of fifth objects comparing the first object in the set of first objects to objects in the set of fifth objects and logging the result of the comparing in response to determining that the comparing resulted in an inequality.

The method could further include wherein the comparing comprises determining whether objects in the set of fifth objects have at least the same characteristics and behavior than the first object in the set of first objects and saving the results of the comparison into metadata of objects in the set of fifth objects.

The method could further include repeating the comparing and the logging for remaining objects in the set of first objects updating the metadata of the set of first objects and storing the results of the comparing in a set of sixth objects wherein the set of sixth objects includes metadata containing mapping information that defines a reference to objects in the set of first objects that had additional behavior not present in the objects in the set of fifth objects.

The method could further include detecting an unrecognizable second object in the set of first objects determining that the unrecognizable second object in the set of first objects includes at least one element verifying that the at least one element matches an existing model element from the set of third objects and verifying that part of the unrecognizable second object in the set of first objects is still unrecognized.

The method could further include repeating the determining that the unrecognizable second object in the set of first objects includes at least one element for remaining objects in the set of first objects.

The method could further include using at least one of feature based matching structure based matching behavior based matching and semantic relatedness matching to identify the at least one element contained in the unrecognizable second object as a model element in the set of third objects.

The method could further include repeating the using for remaining model elements in the set of third objects.

The method could further include wherein the determining comprises verifying that a first object in the set of first objects has more behavior than the object in the set of fifth objects.

The method could further include wherein the defining the new ADT comprises comparing an object in the set of first objects to an object in the set of fifth objects determining that no object in the set of fifth objects provide the same characteristics and behavior as the first object in the set of first objects constructing a new ADT in the set of second objects that specifies identical behavior as the compared object in the set of first objects constructing a new model element in the set of third objects that specifies identical behavior as the compared object in the set of first objects in accordance with the new ADT in the set of second objects constructing a first new model element in the set of fourth objects that specifies identical behavior as the compared object in the set of first objects in accordance with the new model element in the set of third objects instantiating a new object instance from the first new model element in the set of fourth objects and storing the new object instance in the set of fifth objects mapping the new ADT in the set of second objects to the new model element in the set of third objects the new model element in the set of third objects to the first new model element in the set of fourth objects and the first new model element in the set of fourth objects to a new object instance in the set of fifth objects adding metadata to define the mapping to the new ADT in the set of second objects the mapping to the new model element in the set of third objects the mapping to the first new model element in the set of fourth objects and the mapping to the object instance in the set of fifth objects and storing the new ADT in the set of second objects the new model element to the information model in the set of third objects the new model element to the data model in the set of fourth objects and the object instance of the data model to the set of fifth objects.

The method could further include wherein the constructing the new model element in the data model comprises applying a data type to a previously unrecognizable object in the set of first objects to generate a newly transformed object in the set of first objects determining that the applying the data type does not alter the syntax and the semantics of the newly transformed object in the set of first objects generating a second new model element in the set of fourth objects having the same characteristics and behavior as the newly transformed object when instantiated instantiating an object instance in the set of fifth objects in accordance with the second new model element in the set of fourth objects verifying that the object instance has the same characteristics and behavior as the newly transformed object updating the metadata to contain generation and mapping information for the second new model element in the set of fourth objects updating the metadata to contain the generation and mapping information for the new object instance in the set of fifth objects storing a reference to the second new model element in the set of fourth objects and storing the reference to the new object instance in the set of fifth objects.

The method could further include applying a data type to a previously unrecognizable object in the set of first objects to generate a newly transformed object in the set of first objects determining that the applying the data type does not alter the syntax of the newly transformed object in the set of first objects determining that the applying the data type does alter the semantics of the newly transformed object in the set of first objects generating a third new model element in the set of fourth objects having the same characteristics as the newly transformed object when instantiated matching the semantics of the newly transformed object to a relationship between an existing model element in the set of fourth objects and the third new model element in the set of fourth objects instantiating an object instance in the set of fifth objects in accordance with the third new model element in the set of fourth objects instantiating two additional object instances that represent the semantics of the newly transformed object wherein the two additional object instances correspond to instantiating the relationship and the existing model element connected by the relationship to the new model element verifying that the combination of the first object instance and the two additional object instances has the same characteristics and behavior as the newly transformed object updating the metadata to contain generation and mapping information for the third new model element in the set of fourth objects the relationship between the third new model element in the set of fourth objects and the existing model element in the set of fourth objects and the existing model element in the set of fourth objects storing a reference for the third new model element in the set of fourth objects the relationship between the third new model element in the set of fourth objects and the existing model element in the set of fourth objects and the existing model element in the set of fourth objects and storing the reference to the new object instance in the set of fifth objects.

The method could further include applying a data type to a previously unrecognizable object in the set of first objects to generate a newly transformed object in the set of first objects determining that the applying the data type does alter the syntax of the newly transformed object in the set of first objects determining that the applying the data type does not alter the semantics of the newly transformed object in the set of first objects generating a fourth new model element in the set of fourth objects having the same behavior as the newly transformed object when instantiated matching the syntax of the newly transformed object to a relationship between an existing model element in the set of fourth objects and the fourth new model element in the set of fourth objects instantiating an object instance in the set of fifth objects in accordance with the fourth new model element in the set of fourth objects instantiating two additional object instances that represent the syntax of the newly transformed object wherein the two additional object instances correspond to instantiating a second object in the set of fourth objects and the relationship between the existing model element connected by the relationship to the fourth new model element in the set of fourth objects verifying that the combination of the first object instance and the two additional object instances has the same characteristics and behavior as the newly transformed object updating the metadata to contain generation and mapping information for the fourth new model element in the set of fourth objects the relationship between the fourth new model element in the set of fourth objects and the existing model element in the set of fourth objects and the existing model element in the set of fourth objects storing a reference for the fourth new model element in the set of fourth objects the relationship between the fourth new model element in the set of fourth objects and the existing model element in the set of fourth objects and the existing model element in the set of fourth objects and storing the reference to the new object instance in the set of fifth objects.

The method could further include applying a data type to a previously unrecognizable object in the set of first objects to generate a newly transformed object in the set of first objects determining that the applying the data type does alter both the syntax and the semantics of the newly transformed object in the set of first objects generating a fifth new model element in the set of fourth objects having the same characteristics as the newly transformed object when instantiated matching the syntax of the newly transformed object to a relationship between a first existing model element in the set of fourth objects and the fifth new model element in the set of fourth objects generating a sixth new model element in the set of fourth objects having the same behavior as the newly transformed object when instantiated matching the semantics of the newly transformed object to a relationship between a second existing model element in the set of fourth objects and the sixth new model element in the set of fourth objects instantiating a first object instance in the set of fifth objects in accordance with the fifth new model element in the set of fourth objects instantiating a first two additional object instances that represents the syntax of the newly transformed object wherein the first two additional object instances correspond to instantiating a first instantiated object in the set of fourth objects and the relationship between the first model element connected by the relationship to the fifth new model element instantiating a second object in the set of fifth objects in accordance with the sixth new model element in the set of fourth objects instantiating a second two additional object instances that represents the semantics of the newly transformed object wherein the second two additional object instances correspond to instantiating a second instantiated object in the set of fourth objects and the relationship between the second model element connected by the relationship to the sixth new model element verifying that the combination of the first object instance the first two additional object instances the second object and the second two additional object instances has the same characteristics and behavior as the newly transformed object updating the metadata to contain generation and mapping information for the fifth new model element in the set of fourth objects the existing model element in the set of fourth objects representing the syntax of the newly transformed object the relationship between the fifth new model element in the set of fourth objects and the existing model element in the set of fourth objects representing the syntax of the newly transformed object the sixth new model element in the set of fourth objects the existing model element in the set of fourth objects representing the semantics of the newly transformed object and the relationship between the sixth new model element in the set of fourth objects and the existing model element in the set of fourth objects representing the semantics of the newly transformed object storing a reference to the fifth new model element in the set of fourth objects the existing model element in the set of fourth objects representing the syntax of the newly transformed object the relationship between the fifth new model element in the set of fourth objects and the existing model element in the set of fourth objects representing the syntax of the newly transformed object the sixth new model element in the set of fourth objects the existing model element in the set of fourth objects representing the semantics of the newly transformed object and the relationship between the sixth new model element and the existing model element in the set of fourth objects representing the semantics of the newly transformed object and storing the reference to the new object instance in the set of fifth objects.

The method could further include repeating the applying to remaining objects in the set of first objects.

The method could further include wherein the determining that no object in the set of second objects comprises using at least one of feature based matching structure based matching behavior based matching and semantic relatedness matching to verify that the object in the set of first objects does not match any object in the set of second objects.

The method could further include wherein the determining that no object in the set of fifth objects comprises comparing an object in the set of first objects to objects in the set of second objects wherein each comparison includes verifying that the syntax and semantics of each ADT in the set of second objects does not match the syntax and semantics of the objects in the set of first objects and determining that no metadata exists defining extensions or interpretations that would enable the previous verification of the syntax and semantics to be equal and updating the metadata of all compared ADTs in the set of second objects to denote the above conclusions.

The method could further include repeating the comparing for remaining objects in a set of first objects.

Advantageous features of example embodiments may include a management entity comprising a receiver configured to receive a request to collect data for an entity in a communications system and a processor operatively coupled to the receiver the processor configured to collect data for the entity to detect that the data collected contains an object that cannot be recognized to determine that the unrecognizable object is a new object not previously known to the management entity to define a new Abstract Data Type ADT to represent the behavior of the unrecognizable object to map the new ADT to a new model element in an information model to map the new model element in the information model to a new model element in a data model and to save the new model element in the information model.

The management entity could further include wherein the processor is configured to attach an annotation to at least one of the collecting the detecting the determining the defining the mapping the new ADT the mapping the new model element and the saving.

The management entity could further include wherein the processor is configured to translate the data collected into a first reference to a first object in a set of first objects to form and save a set of second references to each ADT defined by the information model as a set of second objects to form and save a set of third references to a model element defined by the information model as a set of third objects wherein the set of third references includes metadata containing mapping information from a first object in a set of second objects to an object in the set of third objects to form and save a set of fourth references to a model element defined by the data model as a set of fourth objects wherein the set of fourth references includes metadata containing mapping information from a second object in the set of third objects to an object in the set of fourth objects to form and save a set of fifth references to an object instantiated by the model element in the set of fourth objects as a set of fifth objects wherein the set of fifth references includes metadata containing mapping information from each object in the set of fourth objects to each object in the set of fifth objects to compare the first object in the set of first objects to objects in the set of fifth objects and to log the result of the comparing in response to determining that the comparing resulted in an inequality.

The management entity could further include wherein the processor is configured to detect an unrecognizable second object in the set of first objects to determine that the unrecognizable second object in the set of first objects includes at least one element to verify that the at least one element matches an existing model element from the set of third objects and to verify that part of the unrecognizable second object in the set of first objects is still unrecognized.

The management entity could further include wherein the processor is configured to compare an object in the set of first objects to an object in the set of fifth objects to determine that no object in the set of fifth objects provide the same characteristics and behavior as the first object in the set of first objects to construct a new ADT in the set of second objects that specifies identical behavior as the compared object in the set of first objects to construct a new model element in the set of third objects that specifies identical behavior as the compared object in the set of first objects in accordance with the new ADT in the set of second objects to construct a first new model element in the set of fourth objects that specifies identical behavior as the compared object in the set of first objects in accordance with the new model element in the set of third objects to instantiate a new object instance from the first new model element in the set of fourth objects and storing the new object instance in the set of fifth objects to map the new ADT in the set of second objects to the new model element in the set of third objects the new model element in the set of third objects to the first new model element in the set of fourth objects and the first new model element in the set of fourth objects to a new object instance in the set of fifth objects to add metadata to define the mapping to the new ADT in the set of second objects the mapping to the new model element in the set of third objects the mapping to the first new model element in the set of fourth objects and the mapping to the object instance in the set of fifth objects and to store the new ADT in the set of second objects the new model element to the information model in the set of third objects the new model element to the data model in the set of fourth objects and the object instance of the data model to the set of fifth objects.

The management entity could further include wherein the processor is configured to apply a data type to a previously unrecognizable object in the set of first objects to generate a newly transformed object in the set of first objects to determine that the applying the data type does not alter the syntax and the semantics of the newly transformed object in the set of first objects to generate a second new model element in the set of fourth objects having the same characteristics and behavior as the newly transformed object when instantiated to instantiate an object instance in the set of fifth objects in accordance with the second new model element in the set of fourth objects to verify that the object instance has the same characteristics and behavior as the newly transformed object to update the metadata to contain generation and mapping information for the second new model element in the set of fourth objects to update the metadata to contain the generation and mapping information for the new object instance in the set of fifth objects to store a reference to the second new model element in the set of fourth objects and to store the reference to the new object instance in the set of fifth objects.

The management entity could further include wherein the processor is configured to apply a data type to a previously unrecognizable object in the set of first objects to generate a newly transformed object in the set of first objects to determine that the applying the data type does not alter the syntax of the newly transformed object in the set of first objects to determine that the applying the data type does alter the semantics of the newly transformed object in the set of first objects to generate a third new model element in the set of fourth objects having the same characteristics as the newly transformed object when instantiated to match the semantics of the newly transformed object to a relationship between an existing model element in the set of fourth objects and the third new model element in the set of fourth objects to instantiate an object instance in the set of fifth objects in accordance with the third new model element in the set of fourth objects to instantiate two additional object instances that represent the semantics of the newly transformed object wherein the two additional object instances correspond to instantiating the relationship and the existing model element connected by the relationship to the new model element to verify that the combination of the first object instance and the two additional object instances has the same characteristics and behavior as the newly transformed object to update the metadata to contain generation and mapping information for the third new model element in the set of fourth objects the relationship between the third new model element in the set of fourth objects and the existing model element in the set of fourth objects and the existing model element in the set of fourth objects to store a reference for the third new model element in the set of fourth objects the relationship between the third new model element in the set of fourth objects and the existing model element in the set of fourth objects and the existing model element in the set of fourth objects and to store the reference to the new object instance in the set of fifth objects.

The management entity could further include wherein the processor is configured to apply a data type to a previously unrecognizable object in the set of first objects to generate a newly transformed object in the set of first objects to determine that the applying the data type does alter the syntax of the newly transformed object in the set of first objects to determine that the applying the data type does not alter the semantics of the newly transformed object in the set of first objects to generate a fourth new model element in the set of fourth objects having the same behavior as the newly transformed object when instantiated to match the syntax of the newly transformed object to a relationship between an existing model element in the set of fourth objects and the fourth new model element in the set of fourth objects to instantiate an object instance in the set of fifth objects in accordance with the fourth new model element in the set of fourth objects to instantiate two additional object instances that represent the syntax of the newly transformed object wherein the two additional object instances correspond to instantiating a second object in the set of fourth objects and the relationship between the existing model element connected by the relationship to the fourth new model element in the set of fourth objects to verify that the combination of the first object instance and the two additional object instances has the same characteristics and behavior as the newly transformed object to update the metadata to contain generation and mapping information for the fourth new model element in the set of fourth objects the relationship between the fourth new model element in the set of fourth objects and the existing model element in the set of fourth objects and the existing model element in the set of fourth objects to store a reference for the fourth new model element in the set of fourth objects the relationship between the fourth new model element in the set of fourth objects and the existing model element in the set of fourth objects and the existing model element in the set of fourth objects and to store the reference to the new object instance in the set of fifth objects.

The management entity could further include wherein the processor is configured to apply a data type to a previously unrecognizable object in the set of first objects to generate a newly transformed object in the set of first objects to determine that the applying the data type does alter both the syntax and the semantics of the newly transformed object in the set of first objects to generate a fifth new model element in the set of fourth objects having the same characteristics as the newly transformed object when instantiated to match the syntax of the newly transformed object to a relationship between a first existing model element in the set of fourth objects and the fifth new model element in the set of fourth objects to generate a sixth new model element in the set of fourth objects having the same behavior as the newly transformed object when instantiated to match the semantics of the newly transformed object to a relationship between a second existing model element in the set of fourth objects and the sixth new model element in the set of fourth objects to instantiate a first object instance in the set of fifth objects in accordance with the fifth new model element in the set of fourth objects to instantiate a first two additional object instances that represents the syntax of the newly transformed object wherein the first two additional object instances correspond to instantiating a first instantiated object in the set of fourth objects and the relationship between the first model element connected by the relationship to the fifth new model element to instantiate a second object in the set of fifth objects in accordance with the sixth new model element in the set of fourth objects to instantiate a second two additional object instances that represents the semantics of the newly transformed object wherein the second two additional object instances correspond to instantiating a second instantiated object in the set of fourth objects and the relationship between the second model element connected by the relationship to the sixth new model element to verify that the combination of the first object instance the first two additional object instances the second object and the second two additional object instances has the same characteristics and behavior as the newly transformed object to updating the metadata to contain generation and mapping information for the fifth new model element in the set of fourth objects the existing model element in the set of fourth objects representing the syntax of the newly transformed object the relationship between the fifth new model element in the set of fourth objects and the existing model element in the set of fourth objects representing the syntax of the newly transformed object the sixth new model element in the set of fourth objects the existing model element in the set of fourth objects representing the semantics of the newly transformed object and the relationship between the sixth new model element in the set of fourth objects and the existing model element in the set of fourth objects representing the semantics of the newly transformed object to store a reference to the fifth new model element in the set of fourth objects the existing model element in the set of fourth objects representing the syntax of the newly transformed object the relationship between the fifth new model element in the set of fourth objects and the existing model element in the set of fourth objects representing the syntax of the newly transformed object the sixth new model element in the set of fourth objects the existing model element in the set of fourth objects representing the semantics of the newly transformed object and the relationship between the sixth new model element and the existing model element in the set of fourth objects representing the semantics of the newly transformed object and to store the reference to the new object instance in the set of fifth objects.

The management entity could further include wherein the processor is configured to compare an object in the set of first objects to objects in the set of second objects with each comparison the processor is configured to verify that the syntax and semantics of each ADT in the set of second objects does not match the syntax and semantics of the objects in the set of first objects and to determine that no metadata exists defining extensions or interpretations that would enable the previous verification of the syntax and semantics to be equal and the processor is configured to update the metadata of all compared ADTs in the set of second objects to denote the above conclusions.

Although the present disclosure and its advantages have been described in detail it should be understood that various changes substitutions and alterations can be made herein without departing from the spirit and scope of the disclosure as defined by the appended claims.

