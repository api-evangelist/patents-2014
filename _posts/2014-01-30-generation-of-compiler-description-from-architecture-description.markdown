---

title: Generation of compiler description from architecture description
abstract: A computer implemented method of generating a compiler description from an architecture description. Information is automatically extracted from an architecture description that is usable in a description of an architecture described by the architecture description. The extracted information is imported into a program comprising a graphical user interface that accepts user provided additional information that is usable in the compiler description. User provided additional information is accessed that is usable in the compiler description. A compiler description is automatically generated for the architecture described by the architecture description, based on the automatically extracted information and the accessed user provided additional information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09383977&OS=09383977&RS=09383977
owner: Synopsys, Inc.
number: 09383977
owner_city: Mountain View
owner_country: US
publication_date: 20140130
---
This application is a continuation application of U.S. patent application Ser. No. 10 815 228 filed Mar. 30 2004 which is incorporated by reference herein in its entirety.

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright holder has no objection to the facsimile reproduction by any one of the patent disclosure as it appears in the Patent and Trademark Office files or records but otherwise reserves all copyright rights whatsoever.

Embodiments of the present invention relate to the field of software tools for system level design. Specifically embodiments of the present invention relate to semi automatically generating a compiler description from an architecture description.

The design and test of modern electronic devices such as embedded processors EP and systems on a chip SoC is a complex process involving many stages. For example many systems such as mobile devices networking products and modems require new embedded processors EP . These EPs can either be general purpose such as microcontrollers C and digital signal processors DSP or application specific using application specific instruction set processors ASIP .

Compared to ASICs DSPs ICs and general purpose processors ASIPs provide a tradeoff of computational performance and flexibility on the one hand and power consumption on the other. Therefore ASIPs that are designed to execute specific tasks very efficiently can be found in a wide range of embedded systems.

However designing systems with ASIPs is far more complex than assembling systems with standard processors. Typically designing ASIPs comprises an iterative exploration in which hardware and software are explored and modified. This iterative process is referred to as an architecture exploration loop. The architecture exploration requires a number of tools such as an assembler linker and simulator. If hardware and software are available profiling results are acquired that usually lead to architecture modifications making the processor more efficient. To be consistent with these modifications the software tools potentially need to be changed as well.

The algorithm that is executed by the ASIP is usually specified by algorithm designers in a high level language such as the C programming language. The overall design time can be significantly reduced by introducing into the architecture exploration loop a compiler that reflects the architecture. Besides reducing the implementation and verification time the availability of a compiler also increases the system reusability for similar applications.

However using a compiler in the architecture exploration loop is only beneficial if the compiler itself can be created accurately and efficiently. Thus there is a need for an efficient and accurate technique for creating a compiler that is usable in an architecture exploration loop.

There have been a number of attempts at generating a compiler for use in architecture exploration. However these conventional techniques have various weaknesses such as being limited to the type of architecture that may be explored.

A detailed overview of work related to compiler generation from processor architecture description languages ADLs or compiler specifications is given by R. Leupers and P. Marwedel in Retargetable Compiler Technology for Embedded Systems Kluwer Academic Publishers Boston October 2001.

A compiler development environment that is mainly useful for VLIW architectures is the Instruction Set Description Language ISDL ISDL An Instruction Set Description Language for Retargetability G. Hadjiyiannis S. Hanono and S. Devadas. In Proc. of the Design Automation Conference DAC June 1997. This conventional technique hierarchically describes the processor and lists invalid instruction combinations in a constraints section. This list becomes very lengthy and complex for DSP architectures like the Motorola 56 k. Therefore this technique is mainly useful for orthogonal processors.

A technique described by Trimaran is capable of retargeting a sophisticated compiler. However the technique is limited to a very restricted class of VLIW architectures called HPL PD. HPL PD Hewlett Packard Laboratories PlayDoh is a parametric processor architecture conceived for research in instruction level parallelism ILP . Trimaran s tool input is a manual specification of processor resources functional units instruction latencies etc. Trimaran. An Infrastructure for Research in Instruction Level Parallelism http www.trimaran.com. 

An extension of the CoSy environment ACE Associated Computer Experts bv. The CoSy Compiler Development System http www.ace.nl. can be retargeted from a FlexWare2 description. P. Paulin. Towards Application Specific Architecture Platforms Embedded Systems Design Automation Technologies. In Proc. of the EuroMicro April 2000. Unfortunately for the generation of the other software tools FlexWare2 requires separate descriptions. This redundancy introduces a consistency verification problem.

The concept for scheduler generation has been proposed in EXPRESSION. Peter Grun Ashok Halambi Nikil D. Dutt and Alexandru Nicolau. RTGEN An Algorithm for Automatic Generation of Reservation Tables from Architectural Descriptions. In Proc. of the Int. Symposium on System Synthesis ISSS pages 44 50 1999. The concept for scheduler generation has also been proposed in PEAS III. M. Itoh S. Higaki J. Sato A. Shiomi Y. Takeuchi A. Kitajima and M. Imai. PEAS III An ASIP Design Environment. In Proc. of the Int. Conf. on Computer Design ICCD September 2000 . Both of these conventional techniques extract structural information from the processor description that allows the tracing of instructions through the pipeline. Instructions are automatically classified by their temporal I O behavior and their resource allocation. Based on this information a scheduler can be generated. In PEAS III all functional units that are used to model the behavior of instructions are taken from a predefined set called flexible hardware model database FHT .

MIMOLA traces the interconnects of functional units to detect resource conflicts and I O behavior of instructions. R. Leupers and P. Marwedel. Retargetable Code Compilation based on Structural Processor Descriptions. Design Automation for Embedded Systems 3 1 1 36 January 1998. Kluwer Academic Publishers . For non pipelined architectures it is possible to generate a compiler called MSSQ which also includes an instruction scheduler. However the abstraction level of MIMOLA descriptions is very low which slows down the architecture exploration loop.

The CHESS D. Lanner J. Van Praet A. Kiffl K. Schoofs W. Geurts F. Thoen and G. Goosens. Chess Retargetable Code Generation for Embedded DSP Processors. In P. Marwedel and G. Goosens editors Code Generation for Embedded Processors. Kluwer Academic Publishers 1995. code generator is based on an extended form of the nML ADL A. Fauth J. Van Praet and M. Freericks. Describing Instruction Set Processors Using nML. In Proc. of the European Design and Test Conference ED TC March 1995 . Similar to the MSSQ compiler the scheduler uses the instruction coding to determine which instructions can be scheduled in parallel. In contrast to MSSQ the CHESS compiler can be used to generate code for pipelined architectures. This is achieved by manually attaching latency information e.g. number of delay slots to the instructions. CHESS is primarily useful for retargeting compilers for DSPs.

The Marion system uses the Maril language to generate a compiler. D. G. Bradlee R. E. Henry and S. J. Eggers. The Marion System for Retargetable Instruction Scheduling. In Proc. of the Int. Conf. on Programming Language Design and Implementation PLDI pages 229 240 1991. However the system is restricted to RISC architectures All target machines need to have general purpose register sets each instruction produces at most one result and only load and store operations can access memory.

The Mescal group which is part of the Gigascale Research Center recently proposed an operation state machine OSM based modeling framework. W. Qin and S. Malik. Flexible and formal modeling of microprocessors with application to retargetable simulation. In Proc. of the Conference on Design Automation Test in Europe DATE March 2003. OSM separates the processor into two interacting layers an operation and timing layer and a hardware layer that describes the micro architecture. A StrongARM and a PowerPC 750 simulator could be generated.

An operBT listBT backtracking scheduler has been proposed. S. G. Abraham W. Meleis and I. D. Baev. Efficient backtracking instruction schedulers. In IEEE PACT pages 301 308 May 2000. However the technique described in that paper is limited in its ability to handle delays. The paper presents two different backtracking scheduler techniques The operBT scheduler and the listBT scheduler. Both schedulers assign priorities to the nodes of the dependence DAG. In contrast to other schedulers the operBT scheduler does not maintain a ready list. It utilizes a list of nodes not yet scheduled that is sorted by node priority. It takes the highest priority node from this list and schedules it using one of the following three scheduling modes 

Un schedule high priority operations to avoid invalid schedules and schedule an instruction into a so called force cycle force .

The operBT scheduler has the drawback of being relatively slow due to many un scheduling operations. To overcome this drawback the operBT scheduler was extended to the listBT scheduler. This scheduler tries to combine the advantage of the conventional list scheduler fast with the advantage of the operBT scheduler better schedule . The listBT scheduler does maintain a ready list. This means only nodes that are ready can be scheduled. Unfortunately the delay slot filling of the listBT scheduler does not work for all cases.

Therefore it would be advantageous to provide a method and system that reduce the time required for the design exploration phase. It would be further advantageous to accurately and efficiently generate a compiler description that may be used in an architecture exploration. It would be still further advantageous to meet the above constraints while being compatible with existing technologies for developing embedded processors systems on a chip and ASIPs.

Accordingly embodiments of the present invention provide methods of and systems that reduce the time required for the design exploration phase. Embodiments of the present invention accurately and efficiently generate a compiler description that may be used in an architecture exploration. Embodiments of the present invention meet the above constraints while being compatible with existing technologies for developing embedded processors systems on a chip and ASIPs. Embodiments of the present invention provide these advantages and others not specifically mentioned above but described in the sections to follow.

One embodiment of the present invention comprises a computer implemented method of generating a compiler description from an architecture description. This embodiment comprises automatically extracting from an architecture description information that is usable in a description of a compiler for an architecture described by the architecture description importing the extracted information into a computer program comprising a graphical user interface that accepts user provided additional information that is usable in the compiler description accessing user provided additional information that is usable in the compiler description and automatically generating a compiler description for the architecture described by the architecture description based on the automatically extracted information and the accessed user provided additional information.

Another embodiment of the present invention comprises a method of mapping an architecture description to a compiler description. This embodiment comprises accessing an architecture description embodied in an architecture description language having a hierarchical format accessing a mapping of rules for a compiler to instructions in said architecture description language and generating a description for a compiler for the architecture description based on the mapping wherein said compiler description has a flattened format.

In the following detailed description of embodiments of the present invention semi automatically generating a compiler description from an architecture description numerous specific details are set forth in order to provide a thorough understanding of the present invention. However it will be recognized by one skilled in the art that the present invention may be practiced without these specific details or with equivalents thereof. In other instances well known methods procedures and components have not been described in detail as not to unnecessarily obscure aspects of the present invention.

Some portions of the detailed descriptions that follow are presented in terms of procedures steps logic blocks processing and other symbolic representations of operations on data bits that can be performed on computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. A procedure computer executed step logic block process etc. is here and generally conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present invention discussions utilizing terms such as executing or receiving or generating or processing or computing or translating or mapping or determining or maintaining or importing or storing or constructing or accessing or extracting or selecting or removing or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The compiler generator with GUI extracts information from the architecture description that is useful in generating a compiler description. This extracted information is imported into a computer program that displays this information in a GUI. The GUI allows the architecture s designer to input additional information that is useful in generating the compiler. The GUI also allows the architecture s designer to modify the extracted information if so desired. depict various dialog windows of the GUI that allow the user to input and modify information that is useful in generating a compiler description for the architecture being developed. The compiler generator with GUI outputs a compiler description based on the information extracted from the architecture description and the information that the architecture s designer input and or modified using the GUI.

The compiler description is input into the compiler generator which outputs the compiler . A suitable compiler generator is the COSY Compiler Development System provided by Associated Computer Experts ACE of Amsterdam The Netherlands. However the present invention is not limited to this compiler generator. The compiler parses the C code applies typical high level optimizations utilizes a tree pattern matcher for code selection and conducts a global register allocation. The output of the compiler is unscheduled instrumented assembly code . This means that each assembly instruction contains an instruction class identifier and information about the resources e.g. registers memory that it reads or writes. From this input the Ipacker tool creates a dependence directed acyclic graph DAG . An exemplary dependence DAG is illustrated in . The DAG is fed into a mixedBT scheduler which is implemented in the Ipacker tool . Exemplary pseudocode for an implemented mixedBT scheduler is depicted in . The scheduling result is assembly code that is compliant with the ADL model of the architecture being developed. The assembly code is read by the assembler linker . The assembler linker may be generated from the architecture description as well. However the generation of the assembler linker is not a requirement of the present invention.

To retarget the output of the compiler generator and Ipacker the information extracted from the architecture description is presented in a GUI. One reason for this extension is the fact that the compiler generator with GUI requires information not contained in the architecture description e.g. calling conventions stack layout . This information can be added in the GUI. Another reason is to offer the architecture designer the opportunity to override analysis results. It is possible to start the architecture design with a very simple architecture description that mainly describes the instruction set but no temporal behavior e.g. the pipeline is not modeled . The compiler generator with GUI can be used to model instruction latencies register file sizes etc. Thus the impact of major architectural changes can quickly be profiled through the compiler generator with GUI . A third benefit of the GUI is that it provides an opportunity to override analysis results that are too conservative. Such overriding can be useful if the architecture description contains unrecognized hardware to hide instruction latencies.

For a given set of instructions a scheduler decides which instructions are issued on the processor in which cycle. For instruction level parallelism ILP architectures this not only means that the scheduler decides on the sequence in which instructions are executed but it also arranges instructions to be executed in parallel. The freedom of scheduling is limited by two major constraints structural hazards and data hazards. Structural hazards result from instructions that utilize exclusive processor resources. If two instructions require the same resource then these two instructions are mutually exclusive. A typical example of structural hazards is the number of issue slots available on a processor architecture. For example it is never possible to issue more instructions in a cycle than the number of available slots. Data hazards result from the temporal I O behavior of instructions. Data hazards can be subdivided into read after write RAW write after write WAW and write after read WAR hazards. An example for a RAW dependency is a multiplication that takes two cycles to finish computation on a processor without interlocking hardware followed by a second instruction that consumes the result of the multiplication. In this case the multiplication has a RAW dependence of two cycles onto the second instruction. Consequently the second instruction is issued two or more cycles after the multiplication.

Embodiments in accordance with the present invention find and associate a set of virtual resources e.g. resources that have no direct correspondence in the processor hardware with each instruction of an architecture description. These resources are exclusively allocated if an instruction is scheduled. Using a reservation table technique the scheduler can decide which instructions are allowed to be issued in the same clock cycle.

Embodiments in accordance with the present invention automatically extract the RAW WAW and WAR data flow hazards from an architecture description. This allows the generation of a complete instruction scheduler from the architecture description.

The following discussion outlines aspects of the structure of an exemplary ADL in order to facilitate explanation and understanding of embodiments in accordance with the present invention. However the present invention is not limited to using this exemplary ADL. The following exemplary ADL is substantially compliant with the LISA language. A more detailed explanation of LISA and related software tools is provided in Architecture Exploration for Embedded Processors With LISA by A. Hoffmann H. Meyr and R. Leupers. Kluwer Academic Publishers January 2003.

An exemplary single LISA operation is illustrated in . A LISA processor description consists of two parts The LISA operation tree and a resource specification. The operation tree is a hierarchical specification of instruction coding syntax and behavior. The resource specification describes memories caches processor registers signals and pipelines. There is not a resource specification in the example of . The name of this operation in is register alu instr and it is located in the ID stage instruction decode of the pipeline called pipe.

The DECLARE section contains local declarations and announcements for a LISA operation. In this example the DECLARE section lists the sons of register alu instr in the operation tree. ADD and SUB are names of other LISA operations that have their own binary coding syntax and behavior.

The CODING section describes the binary image of the instruction word that is a part of the instruction set model. The SYNTAX section describes the assembly syntax of instructions and their operands.

The BEHAVIOR section indicates that elements of the GP Regs array resource are read and written into a pipeline register. This means that the general purpose register file is read in the instruction decode stage.

The ACTIVATION section describes the subsequent control flow of the instruction through the processor. The LISA operation behind Opcode is generally but not necessarily located in a subsequent pipeline stage which means that it will be activated in a subsequent cycle. Thus the ACTIVATION section creates a chain of operations as depicted in .

Based on the activation chain it can be determined which LISA operation of the instruction is executed in which cycle. Furthermore it can be determined if the C code in the BEHAVIOR section of the operations accesses processor resources of the LISA model. In the example of the decoding of the instruction results in the register alu instr as opposed to the imm alu instr. In this case an add is performed in cycle and the result is written back to register in cycle as indicated by the alu wb box .

The analysis of activation chains in accordance with embodiments of the present invention differs from a trace technique that is used in some conventional design environments. Traces include information about which functional units are used by an instruction in a specific cycle. Traces require modeling of functional units and their interconnects. In the LISA language operations are abstracted from functional units which significantly speeds up the architecture exploration phase. For example a processor such as the ST200 VLIW processor has four parallel ALUs that can execute an addition. In the LISA model there is only a single ADD operation that is potentially activated four times in the same clock cycle from different sources.

The vectors of two example assembly instructions are depicted in the diagram of depicting latency analysis in accordance with an embodiment of the present invention. The add immediate instruction ADDI R R reads the program counter PC in its cycle . In its cycle it reads a source operand from register R and in cycle it writes a result back to register R. The add immediate instruction is followed by a return instruction RET that reads the PC in its cycle and writes the PC in its cycle . The dependency between the two instructions is a write after read WAR . Furthermore the latency from the add immediate instruction to the return instruction is 1.

Based on the LISA activation chains a determination can be made as to when an instruction accesses processor resources. The access direction read or write and the resource names are organized in an instruction specific vector. Starting from cycle each vector component represents a cycle that is required to execute the instruction.

To schedule a sequence of instructions embodiments in accordance with the present invention construct a directed acyclic graph DAG data structure such as the one depicted in . The DAG comprises three instructions labeled and in this example. The arrow between each instruction is referred to as an edge and is assigned a weight based on the latency between the instructions. In general each edge weight of the DAG represents a RAW WAW or WAR dependency between a pair of instructions. In all dependencies are of the WAR variety. If there is more than one latency between two instructions e.g. the second instruction reads and writes a register that is written by the first instruction the maximum latency is taken.

The following discussion covers more general sequences of instructions than depicted in . If a second instruction I reads a register resource R that was written by a first instruction I then the RAW latency is calculated by the formula expressed in Equation 1. last write cycle 1 first read cycle 2 1 Eq. 1 

The last write cycle function iterates through the vector of instruction I and returns the greatest component index that indicates a write to register resource R. Similarly the first read cycle function returns the first component index of instruction I that contains a read of register resource R. The inherent resource latency is taken into account by the last addend because it takes one cycle to read a value from a register that has been written to it an addition of 1 is required.

If two sequential instructions I and I write to the same register resource R then the WAW latency is computed as expressed in Equation 2. last write cycle 1 last write cycle 2 1. Eq. 2 

In Equation 2 the addition of 1 is needed because it is not possible that two instructions write a resource at the same time.

If the second instruction I writes register resource R and the first instruction I reads register resource R then the WAR latency is computed as in Equation 3. last read cycle 1 first write cycle 2 Eq. 3 

An example for a WAR latency is depicted in . As previously discussed the instruction ADDI R R reads the program counter PC in its cycle . In its cycle it reads a source operand from register R and in cycle it writes a result back to register R. It is followed by a RET instruction that reads the PC in its cycle and writes it in its cycle . This means that WAR PC 0 1 1.

Consequently the RET instruction is scheduled 1 or more cycles behind the instruction ADDI R R . The negative latency can be interpreted as an opportunity to fill the delay slot of the RET instruction. For the scheduler it is possible to issue the RET instruction one cycle before the instruction ADDI R R . This means that the activation chains can be used to automatically generate schedulers capable of delay slot filling in accordance with an embodiment of the present invention. The time required for analyzing the latencies in the scheduler generator is negligible.

Unfortunately typical conventional list schedulers are not capable of filling delay slots. In contrast embodiments in accordance with the present invention are able to fill delay slots. A list scheduler in accordance with an embodiment of the present invention takes a dependence DAG representing a basic block as an input. The technique of this embodiment selects one or more of the nodes that have no predecessor the so called ready set to be scheduled into a cycle as determined by a current cycle variable. The scheduled nodes are removed from the DAG the current cycle is potentially incremented and the loop starts again.

An embodiment in accordance with the present invention processes the exemplary DAG of a follows. A current cycle variable is initialized to 0 and the list scheduler would schedule instruction which is the only ready node e.g. it has no predecessor into cycle . The node for instruction is removed from the DAG and instruction becomes ready. Assuming that the underlying architecture has only a single issue slot it is not possible to schedule any ready instruction into current cycle which is still 0 . Consequently current cycle is incremented. Since no latency constraint is violated instruction is scheduled into cycle . After another scheduling loop instruction is scheduled into cycle . Because the RET instruction has a delay slot the list scheduler appends a NOP as the last instruction of the basic block. A better schedule would be instructions which means that the delay slot of the RET instruction is filled with one of the preceding instructions. To create this schedule the scheduler is able to revoke decisions on instructions being scheduled into certain cycles. An embodiment of the present invention discussed below provides for an improved scheduling that is able to revoke decisions on instructions being scheduled into certain cycles.

As discussed herein conventional back tracking algorithms are limited in their ability to handle delays. illustrates an example of a dependence DAG for which a conventional listBT scheduler creates the following schedule after 11 scheduling loops iterations 

The reason for the NOP is that in the 9th schedule loop iteration the scheduler tries to schedule ADDI R R instead of the higher prioritized RET. This leads to a correct but sub optimal schedule. Embodiments in accordance with the present invention provide a more optimal schedule than the schedule provided by this conventional back tracking algorithm.

A mixedBT scheduler in accordance with embodiments of the present invention reduces the number of computational intense instruction un scheduling by maintaining a ready list but is able to switch to a better quality priority scheduling when applicable. To support both modes a ready list and a list of nodes not yet scheduled are maintained by an embodiment of the present invention. Exemplary pseudo code of a scheduling algorithm 600 is depicted in in accordance with an embodiment of the present invention. The initial priority of the DAG leaf nodes is equivalent to the cycles these instructions require to finish their computation. For all other nodes the edge weights of any path from that node to any leaf node is accumulated. The maximum sum is the node priority.

The get next current insn to be scheduled function decides from which list to take the next node that is to be scheduled. It takes the highest priority node from the list of nodes not yet scheduled if the priority is higher than any node priority in the ready list. Otherwise the highest priority node from the ready list is scheduled next.

If there are only positive data dependencies the ready nodes have the highest priorities. For nodes that have zero latency the function selects the father node. In contrast a conventional operBT scheduler would potentially select the son here. Thus the conventional technique would most probably lead to an un scheduling of this node later on.

If nodes are connected by a negative latency the son has a higher priority. The present embodiment schedules this son node first even if it is not ready. Thus this embodiment speeds up the filling of delay slots.

The automatically extracted scheduling information may be input to a computer program that semi automatically generates a compiler description.

Embodiments of the present invention semi automatically generate a compiler description from an architecture description. A graphical user interface GUI is used to allow user interaction in conversion from the architecture description to the compiler description. The GUI visualizes information that was extracted from the architecture description that is relevant for the compiler generator and provides the user the opportunity to refine extend or override the information such that a desired compiler description may be generated. The extracted information may comprise schedule information as described herein. The extracted information may also comprise other information such as resources defined in the architecture description.

The GUI in accordance with embodiments of the present invention comprises several on screen display windows that address different aspects of the conversion process. are exemplary dialog screens that allow a user to refine a description of the architecture such that a compiler description may be generated in accordance with embodiments of the present invention.

The type sizes box of the exemplary data layout dialog allows a user to specify certain bitwidth and alignment information. For example the C standard does not define any bit width for the native C data types. This information is specified by the user in bit width column of the exemplary data layout dialog . The desired alignment of the types in memory is specified by the user in the alignment column .

In addition to the native C types the compiler may support the long long and long double types for example. Column has fields that allow the user to input structure alignments Structures the alignment of heap data elements Memory Data and stack elements Stack . The size of an addressing unit can be specified in the Addressable Unit field.

Continuing with the discussion of to support recursive function calls the compiler makes sure that each function call dynamically reserves a certain amount of memory on a global stack. This stack frame stores all data private to the function. It contains room for all local variables Local Area spilled values Spill Area e.g. values of registers that temporarily needed to be dumped to memory and values that are passed as arguments to subsequent function calls Args Area . The callee saved registers that were clobbered by the function are also saved on the stack in the Regsave Area . The relative position of these elements can be changed by selecting an item in the dialog and pushing one of the arrow buttons in the middle of the dialog.

The compiler that is created by embodiments of the present invention generates the code needed to set and clean up the stack each time a function is entered or left. Therefore the user specifies some essential instructions needed for this operation which can be entered in a pro epilogue mapping dialog that is accessible by clicking on the pro epilogue button .

An embodiment of the present invention generates two additional IR nodes for each function. These are the prologue which is the first basic block of a function and the epilogue at the end of the function. The prologue performs the following steps 

If the current function is main it will set the stack pointer SP to the base address of the stack if there is no boot code.

In order to perform these actions embodiments of the present invention allow the specification of several mapping rules such that a working compiler can be generated. A mapping rule consists of a pattern and one or more instructions associated with the pattern. The user is allowed to specify these instructions the pro epilogue mapping dialog . The required pattern view contains a set of patterns grammar rules that are needed to handle the stack layout. These rules are not modified by the user. The compiler pattern view shows the corresponding pattern in terms of IR nodes. The instruction box allows the user to map the patterns to instructions composed from the tree of operations. The discussion of provides more details of the mapping process.

The pro epilogue GUI concerns the following rules in accordance with an embodiment of the present invention. In the following the notion is C semantic CoSy rule . However the present invention is not limited to the programming language C or to the CoSy environment.

Rule C SP FP CoSy FP SP. Needed to copy the frame pointer FP to the stack pointer SP . The instruction assigned to this rule will also be used for an assignment of the SP to the FP. During generation the registers names will simply be exchanged for this case. Thus the instruction is also capable of assigning the SP to the FP.

Rule C SP SP Immediate CoSy mirPlus SP Immediate SP. This rule is used to increase the stack pointer by a constant value.

Rule C SP SP Immediate CoSy mirSub SP Immediate SP. The stack pointer is reduced by a constant using the instruction assigned to this rule.

Rule C SP Stackbase CoSy mirAssign SP Stackbase SP. The first assign rule is used to initialize the SP in the very first function of a program generally main. A stack base symbol  stackbase will be generated in the assembly file which can be defined during the invocation of a linker thus determining the absolute stack frame location in memory.

Rule C FP Offset Reg CoSy mirAssign FP Offset Reg . In case registers have to be saved on the stack this rule would be applied. At least one register non terminal is specified in the non terminal dialog that contains all pushable registers and the frame pointer. Furthermore the assigned instruction should be valid if the SP is used as base address instead of the FP.

Rule C Reg FP Offset CoSy mirContent FP Offset Reg In the epilogue the saved registers have to be restored. Therefore an instruction is needed that loads registers from the address given by FP plus Offset. Again one register non terminal should contain the pushable registers and the FP. Restoring the FP will use the SP as base address hence this instruction should be correct for this case as well.

Rule C goto Label CoSy mirGoto Label The epilogue of the main function will generate an endless loop. Therefore an instruction is needed that jumps to a label.

Non terminals are used to factorize the tree grammar rules of the instruction selector. This means that an IR pattern specified in the mapping dialog produces its result in a non terminal which can be the input of other IR patterns. This also means that non terminals can have attributes. For example if a pattern was specified for mapping an address constructed by the sum of the stack pointer and an offset the name of the stack pointer register and the offset value will be written to the non terminal attributes. A hypothetical rule for loading data from memory could have this non terminal as input and use the attributes to fill the arguments of assembly instructions loading data from memory.

The non terminals used for mapping IR patterns to assembly instructions are listed in the non terminals dialog depicted in . The main window lists all existing non terminal names their types and potential attributes. Non terminals are added removed or modified with the buttons on the right hand side of the main window . A separate dialog which has its own buttons facilitates the adding removing and modifying of non terminals. A nonterminal tab has been selected in to bring up the nonterminals dialog.

The non terminal has an arbitrary but unique name. Several kinds of non terminals are supported in accordance with this embodiment of the present invention. Following is a brief description of several non terminal types. Other kinds of non terminals could be supported if desired.

REGISTERS This non terminal kind is used for grammar rules that produce results in processor registers. After instruction selection the register allocator will assign a register to all rule instances of this kind that are used to cover the IR tree. The selection of the REGISTER kind activates a list box not depicted in . In the list box the list of registers that are contained in the non terminal can be specified.

ADDRMODE REGISTER non terminals are usually used to pass data between instructions. In contrast the ADDRMODE non terminal is used to factor out addressing modes common to several instructions. Attributes can be associated with ADDRMODE non terminals. The dialog depicts the attributes that are used for a register offset addressing mode. Currently supported types of attributes are registers and integers.

MEMORY Statement rules e.g. rules that do not produce any non terminal or that store their result in memory are of the MEMORY kind.

UNIQUE The UNIQUE non terminal kind is used for rules that produce their result in a unique location. Comparison instructions that write to a single condition code register are a typical example. The scheduler makes sure that only one condition code value is live at any time. Consequently the register allocator is not affected by this non terminal kind.

The separate dialog in illustrates the specification of a register offset addressing mode. The non terminal name is addr. It is of ADDRMODE kind and has the attributes reg and offset. The attributes represent a register and an integer respectively.

Table I is exemplary code that is generated in accordance with an embodiment of the present invention. The code which is suitable for use as a compiler description describes non terminal information in accordance with an embodiment of the present invention. Some of the information is provided by the user in various dialogs. For example the registers may be automatically extracted from an architecture description. The pushable registers saved registers callee changed registers and available registers may be user specified. For example dialogs and may be used to input various information about registers that is included in the exemplary code in Table I.

By double clicking the table elements an ordered list of registers can be selected that is used to pass applicable function arguments return values. If no register is specified or if all registers are already used by other arguments then the argument return value is passed via the stack instead.

For example if the specification of is applied to a hypothetical C function declared as int f long long a char b float c short d then the registers are assigned as follows. Register register  would be used to pass the 64 bit integral long long argument a. The integral 8 bit char b argument would go into register regster . The same register could also be used for the float c argument. However since this register is already occupied register  is utilized. The short d argument is passed over the stack because register  and register  are not available. The allocation of the register for the return value is independent from the arguments. Thus the return value of the function will be passed in register .

In the callee changed registers box of the dialog the callee saved registers are selected. If a function clobbers the contents of these registers it has to restore the register contents at its end. There is no need to specify any caller saved registers i.e. registers that are temporarily stored to memory by the calling function before a function call. The generated compiler automatically stores the appropriate registers on the stack. If the definition of the callee is visible to the compiler it calculates the set of caller saved registers by taking an intersection of registers alive at calling time with the set of registers modified by the callee not in the callee saved register set. Otherwise it stores all registers alive at calling time.

Table II is exemplary code that is generated in accordance with an embodiment of the present invention. The code which is suitable for use as a compiler description describes various register information in accordance with an embodiment of the present invention. Some of the information is automatically extracted from an architecture description. Some of the information is provided by the user in various dialogs. For example the registers may be automatically extracted from an architecture description. The pushable registers saved registers callee changed registers and available registers may be user specified. For example dialogs and may be used to input various information about registers that is included in the exemplary code in Table II.

A data producer table and a data consumer table list sets of instructions referred to as data producers or data consumers. A read after write table a write after write table and a write after read table specify respectively the true output dependency and anti dependence latency in clock cycles for the instructions. Using the Generate Latency Tables button the information in tables and is automatically extracted from the architecture description in accordance with an embodiment of the present invention.

The extracted values in tables and can be overridden by the user. This may be useful because the current version of the analysis tool does not recognize processor hardware for hiding latencies e.g. forwarding paths . It may be further useful if the computed latency of instructions that utilize forwarding logic is greater than necessary which is a conservative analysis result . The user of the GUI can enter the correct latency values in the tables and .

The producer consumer instruction sets in tables and are generated automatically using the Generate Latency Tables button . However they may be added edited removed manually by using the buttons in the producers and consumers boxes .

For a specific assembly instruction the children of all GROUPs are selected. Such selections are tested in the Boolean expression. An example expression would be instruction integer insn opcode add wherein instruction and opcode are LISA GROUPs and integer insn and add are names of LISA operations. If the expression evaluates to true for an instruction it is associated with the producer consumer name. If the expressions of several producers consumers evaluate to true the producer consumer name with the smaller index is used according to tables and .

Valid operators in the Boolean expression are the logical and and the logical or operators parentheses and LISA GROUP expressions. A LISA GROUP expression starts with the name of a GROUP declared in the LISA model followed by an equal or a not equal sign and a list of OPERATION names separated by a vertical bar . A LISA GROUP expression evaluates to true if the declaration tree of the instruction in question contains a group whose selected son operation is or is not part of the operation name list.

An example of a LISA GROUP expression would be opcode add sub which evaluates to true if the instruction in question has a GROUP called opcode that has a selected son operation with the name add or sub.

The group list on the left hand side of the dialog lists all GROUPS of the LISA processor model. If an entry is selected the OPERATIONs that are declared in the GROUP are displayed in the operations column . Clicking a GROUP or an OPERATION in respectively columns or inserts the corresponding name into the Boolean expression field at the current cursor position. Similarly operations can be inserted by clicking the buttons on the right hand side of the window. It is possible to exclude LISA processor resources from the latency analysis. This is useful for example if instructions write or read registers or resources that are used for debugging only.

The resource templates frame utilizes these resources to create reservation tables. These tables are associated with LISA INSTRUCTIONs in accordance with an embodiment of the present invention. This means that scheduling of instructions leads to an allocation of the specified resources. Furthermore an instruction can only be scheduled if the specified resources are available.

Resources do not necessarily have a direct correspondence to hardware resources. Their only purpose is to express valid instruction combinations by the reservation tables. All entries in this dialog can automatically be generated by pressing the Generate Reservation Tables button on top of the window. Frame entries can be added edited or deleted by the buttons on the right hand side of the window.

A so called resource template expression is used to model the reservation table. An exemplary dialog in accordance with an embodiment of the present invention for adding editing resource templates is depicted in . The discussion of describes an embodiment that uses the LISA language. However it will be understood that the present invention is not limited to the LISA language. The LISA INSTRUCTION name is depicted in the template name box of this dialog . The template string contains elements and operators. Elements are resources or the names of other templates. This means that it is possible to factorize reservation tables. The following is a list of valid operators 

Resource union The resource union creates sets of resources. This operator is used if an instruction allocates several resources.

Subsequent cycle The execution of an instruction is usually not finished in one cycle. To allocate different resources in subsequent cycles the operator can be used.

Alternatives If instructions can allocate alternative resources e.g. one register file port out of two the operator can be used to express the alternative resources.

A number of buttons are provided for editing purposes. The text of resources is inserted at the current cursor position into the template string by clicking the appropriate items in the resource box . The template box is used to select the instruction to be edited as appears in the template name box .

Several tables of exemplary code have been presented for various types of IR nodes. A detailed explanation of all IR nodes is provided in ACE Associated Compiler Experts bv. CCMIR Definition May 2003 Specification in fSDL Description and Rationale. 

The code in table III is exemplary code for arithmetic IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through for example the arithmetic tab of the mapping dialog . The arithmetic IR nodes related to arithmetic operations mirPlus a b mirDiff a b mirAddrPlus ptr b mirAddrDiff ptr b mirShiftLeft ab mirShiftRightSign a b mirOr a b and a b mirAnd a b and a b mirXor a b mirNot a and a mirNeg a and mirCompare ab .

The code in table IV is exemplary code for calling IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through for example the calling tab of the mapping dialog . The calling nodes related to function calls mirCall call to void function xirFuncCall call to function returning a value mirReturn return statement and mirActual function arguments .

The code in table V is exemplary code for control IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through for example the control tab of the mapping dialog . The control nodes are related to nodes such as mirlf and mirGoto.

The exemplary code in table VI is exemplary code for convert IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through for example the convert tab of the mapping dialog . Convert type casts are performed with mirConvert nodes.

The exemplary code in table VII is exemplary code for load store IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through for example the load store tab of the mapping dialog . Load Store IR nodes covered comprises mirintConst mirNil mirObjectAddr mirContent and mirAssign.

The exemplary code in table IX is exemplary code for specifying how to convert from one non terminal to another that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through for example the move tab of the mapping dialog . Besides specifying how to convert one non terminal into another the rules for move cover the IR nodes mirObjectAddr and mirNil.

The exemplary code in table X is exemplary code for specifying spill rules that are generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through for example the spill tab of the mapping dialog . The spill rules determine how to load store the contents of non terminals from to the special spill memory location.

The dialog of also has an extra tab . Clicking on the extra tab bring up a text editor that allows the inclusion of code generator description syntax.

Each mapping is specified in the instruction mapping dialog depicted in in accordance with an embodiment of the present invention. The IR nodes are listed in IR element box . The non terminal box contains the non terminals appearing in the non terminals dialog of . With a drag and drop technique the elements in boxes and can be used to construct the pattern of the mapping rule in pattern box . An error message is displayed if a drop was not accepted. Additionally valid drops are confirmed.

The pattern box of illustrates an exemplary mirCompare node with two incoming non terminals Nt i of register kind and a result non terminal Nt cc of unique kind that has an attribute par . The incoming non terminals could be produced by some other rules e.g. a rule that loads a variable into a register.

The next step in creating a mapping is to give names to the nodes and non terminals that are used in the pattern. The nodes o s s and d are listed in the pattern box . For all operands and the result non terminal the user specifies a name otherwise the rule will not be accepted when the Ok button is pressed. It is also possible to assign values expressions or registers to the attributes of the result non terminal.

If the user clicks on a result non terminal register attribute as it is used for a register offset addressing mode non terminal a register selector pops up to specify the assigned register. Clicking an integer attribute opens an editor in which the user can enter arithmetic expressions. The user can also drop compatible source IR nodes attributes of the rule on the result non terminal attributes. This is only allowed if a name was specified for the root node of the attribute.

In this example the zero beside the par attribute in the pattern box indicates that the instruction selector will write a zero into the non terminal attribute if it uses this mapping rule. There are other mapping rules that consume the Nt cc non terminal. One of them is a rule that covers the mirNot IR node. It also produces an Nt cc but inverts the bits of the par attribute. Two other rules that consume a Nt cc are the rules used to cover the mirlf IR node. The rules contain conditions that check if the par attribute is zero or not and issue a conditional jump that branches on true or on false condition.

Furthermore by clicking on an arbitrary register non terminal of the rule the user can limit the register set of this non terminal to a certain set. This might be used if the user desires to map instructions with restricted input registers to the rule. In case the result register is equal to one of the operand registers the user can express this by choosing the same name for the result register non terminal and the source non terminal. The register allocator will then use the same physical register for both operands.

The instruction box allows a mapping of the pattern to assembly instructions. Generally the pattern from the pattern box needs to be mapped to zero or more assembly instructions. Some rules do not need to be mapped. For example rules producing addressing mode non terminals are not mapped to assembly instructions. Buttons near the instruction box facilitate the mapping.

By clicking into the tree in the instruction box the sons of LISA GROUPs can be selected. This selection is done for all groups that are part of the instruction. LISA LABELS are also part of the declaration tree. They are used to link the pattern with the instruction. By dragging the names or the attributes of the IR pattern into the LISA LABELS a link is established. For all valid nodes except register attributes attributes an editor appears where the user can specify an additional arithmetic expression to modify the dropped value. It is also possible to edit the LABELS directly by double clicking them. In case of a register label a register selector will pop up otherwise a normal editor will appear.

The assembly syntax of the instruction is depicted in the assembly syntax area and is updated every time the declaration tree is modified. It is possible to have multi instruction rules.

It is quite common that additional information needs to be assigned to the grammar rule. For example the mirCompare node usually requires a condition that tests what type of comparison needs to be performed ab . By pressing the extended tab such information can be specified in the mapping clauses dialog as illustrated in in accordance with an embodiment of the present invention.

A brief explanation of the rule clauses is presented below. A more detailed explanation of the rule clauses is provided in ACE Associated Compiler Experts bv. BEG CoSy Manual May 2003. CoSy System Documentation. BARRIER Using this clause will introduce additional dependencies before PREBARRIER or behind the rule POSTBARRIER . BARRIER adds both. This can be selected in the drop down menu in the parameter column. The scheduler generally will not move instructions across these barriers.

CLOBBER Indicates that the rule changes the value of the indicated operand which can be selected in the opening dialog. May be used several times on a rule.

CONDITION Adding this clause opens a dialog depicted in to build a Boolean expression from a set of fixed conditions which are available for the current rule. In the MIR node box the user can select one of the nodes of the rule. The conditions box displays the conditions that are available for the selected node. Most of the conditions check for the data type of an operand or for a certain data type with a specific bit width which can be passed as parameter the condition in another dialog. Only if the specified condition is evaluated to true during the match phase this rule will be applied.

CONTROL Indicates a control dependency between this rule and surrounding ones. The user selects between three kinds from a drop down menu in the parameter column. branch and call are currently equivalent. The third one fall through indicates that the rule is a null instruction e.g. a fall through to the only successor basic block. This should be specified for all rules dealing with control flow in general mirGoto mirReturn and mirlf.

COST Specifies the cost of this rule if it is applied. This is used by the matcher to find the optimal match for a statement. If no COST clause is specified a default COST clause will be generated with costs of the number of assigned instructions.

EVAL This clause cosists of a list of statements that can be entered in an editor. They will be executed during the matching phase. Useful for evaluating non terminal attributes in this phase.

INTERFERE Specifies the interferences of the rule operands explicitly. The register allocator will assign different physical registers for the interfering registers.

LOCK This clause will lock the operands of the rule e.g. a following instruction that writes the operands will stall.

OUTPUT With this clause it can be specified which pseudo registers leave this rule alive. The clause is used for rules producing more than one result.

PREEMIT Contains a list of C statements which will be executed during the emit phase and is basically an escape mechanism for rules that need special preprocessing.

READ WRITE These clauses can be used to specify data dependencies explicitly. The MEMORY parameter indicates an operand representing a memory address whereas the REGISTER parameter specifies dependencies through different physical registers.

RESULT With this clause it can be specified that the result register is the same as one of the source operands. Such rules should not emit code.

SCRATCH The user can request additional scratch e.g. temporary register non terminals for the mapping. After specifying the type and amount of the scratch registers the scratch non terminals will appear in the mapping dialog and can be used for the mapping procedure.

UNIQUE This clause specifies that all registers used by the rule are distinct. This includes also the registers used by addressing mode non terminals.

In step the extracted information is imported into a program comprising a graphical user interface that allows a user to input additional information that is usable in the compiler description. This step may comprise automatically extracting data flow hazard and control flow hazard information from the architecture description.

In step user provided information is accessed that is usable in the compiler description. If desired user provided modifications to the extracted information may be accessing as well.

In step the compiler description is automatically generated for the described architecture based on the automatically extracted information and the received user provided information. If user provided modifications were accessed in step then step comprises automatically generating the compiler description based on the extracted information as modified by the user. Step may comprise accessing a mapping of compiler rules to instructions used in the architecture description. For example information that is entered via a GUI is accessed.

In step a mapping of rules for a compiler to instructions in said architecture description language is accessed. For example information that is entered via a GUI is accessed. In order to fully describe the compiler description it is also useful to provide definitions for abstract elements in the compiler description that have no direct representative in said architecture description language. For example as discussed herein embodiments of the present invention provide definitions for non terminals in the compiler description that have no direct representative in the architecture description language.

In step a description for a compiler for the architecture description based on the mapping is generated wherein said compiler description has a flattened format.

In step a list of ready nodes in the directed acyclic graph is maintained. In step a list of nodes not yet scheduled is maintained.

In step a determination is made of whether the next instruction to be scheduled is to be taken from the list of ready nodes or from the list of nodes not yet scheduled. Step may further comprise accumulating edge weights for all paths from a given node to leaf nodes and assigning a priority to the given node based on the path having the maximum accumulated edge weight. Step may still further comprise if a node that has the highest priority from the list of nodes not yet scheduled has a higher priority than the priority any node in the list of ready nodes scheduling the node that has the highest priority from the list of nodes not yet scheduled otherwise scheduling a node from the ready list having the highest priority. Process then ends.

For purposes of illustration Tables XI XVIII provide exemplary architecture description input code in accordance with an embodiment of the present invention. Table XI is exemplary input code that is a main module of an architecture description in accordance with an embodiment of the present invention.

Table XII is exemplary code that is an operands module of an architecture description in accordance with an embodiment of the present invention.

Table XIII is exemplary input code that is a load store module of an architecture description in accordance with an embodiment of the present invention.

Table XIV is exemplary input code that is a data forwarding module of an architecture description in accordance with an embodiment of the present invention.

Table XV is exemplary input code that is a control flow module of an architecture description in accordance with an embodiment of the present invention.

Table XVI is exemplary input code that is a compare module of an architecture description in accordance with an embodiment of the present invention.

Table XVII is exemplary input code that is an arithmetic module of an architecture description in accordance with an embodiment of the present invention.

Table XVIII is exemplary input code that is a miscellaneous module of an architecture description in accordance with an embodiment of the present invention.

With reference still to system also includes an alphanumeric input device including alphanumeric and function keys coupled to bus for communicating information and command selections to central processor unit . System also includes a cursor control device coupled to bus for communicating user input information and command selections to central processor unit . System of the present embodiment also includes a display device coupled to bus for displaying information. A signal input output communication device coupled to bus provides communication with external devices.

The preferred embodiment of the present invention a process and system for semi automatically generating a compiler description from an architecture description are thus described. While the present invention has been described in particular embodiments it should be appreciated that the present invention should not be construed as limited by such embodiments but rather construed according to the below claims.

