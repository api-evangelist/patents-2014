---

title: Power level control using power assertion requests
abstract: A method and an apparatus for a power assertion management are described. A power assertion indicator may be maintained for a device component having a power level. The power assertion indicator can indicate whether the power level of the device component is allowed to be lowered. A power assertion request may be sent from a first process to prevent lowering the power level of the device component before a data processing task is completed. A second process can receive a request from the first process to perform operations for the data processing task. The power level of the device component may not be allowed to be lowered before the second process completes the operations for the data processing task. The power level of the device component may be lowered after the data processing task is completed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619012&OS=09619012&RS=09619012
owner: Apple Inc.
number: 09619012
owner_city: Cupertino
owner_country: US
publication_date: 20141219
---
This application is related to and claims the benefits of U.S. Provisional Patent Application No. 62 005 921 filed on May 30 2014 entitled METHOD AND APPARATUS FOR DISTRIBUTED POWER ASSERTION James Magee et al. which is hereby incorporated by reference herein in its entirety.

The present U.S. Patent application is related to the following U.S. Patent applications each of which is incorporated herein by reference to the extent they are consistent with this disclosure 

The present invention relates generally to power management in an operating environment. More particularly this invention relates to dynamically passing power assertion requests among runtime processes in an operating environment.

Data structures describing states and resource ownership of processes are typically maintained in an operating environment or operating system OS to enable controls over these processes. Typically the data structure representing a process is centrally managed via the OS to characterize how the process is running. For example the OS may assign certain security levels and or priority settings to a process via the data structure according to certain registered information of a user account authorization credentials or other applicable configurations.

For example the OS can assign a security or authorization level to a process. Multiple processes working cooperatively with each other to perform a task may have to run with different levels of privilege independent of the task. As a result certain services running as daemon processes may be assigned as uber processes with a high level of authorization capability to accommodate requests for a wide variety of applications or processes. When hijacked these uber processes may pose security risks for the system.

Capability based security models in OS have been implemented to improve system securities such as Hydra from Carnegie Mellon University and in FreeBSD operating system. Hydra was a microkernel based on IPC inter process communication ports and messaging with a mechanism for passing a single un spoofable capability along with each message. However the capabilities in Hydra were specific to the task being requested during an IPC and user code had to provide the specific capability needed for a given operation. There is no concept of adoption in a Hydra based system. Hydra or other true capability based systems have to pass specific capabilities to authorize each request independently.

Further execution priorities pre assigned for multiple processes interacting with each other to accomplish a task may not be consistent with an intended importance of the task. It is common to run more than one process together to complete an action requested by an interactive user who may expect a snappy response for the action regardless how many different processes of various priorities are involved. However executing processes based on pre assigned priorities may result in delayed responses to the user as processes with high priorities but not related to the action may have more likelihood to be scheduled for processor cycle time.

Furthermore when detecting a thread execution is blocked an OS runtime may raise execution priority of certain processes e.g. daemons randomly to passively wait for a resolution to execute the blocked thread. Typically threads of a whole process may have their priorities raised together regardless what operations or tasks each thread is executing. Often times threads working on unimportant tasks may get priority for execution when execution conflicts occur. As a result responsiveness of the overall system performance may be adversely affected.

Furthermore a process may request a power assertion to prevent a system from going to a sleep state when certain operations are performed. Subsequently the process can issue a release to remove the power assertion. However tracking down when these operations are completed to issue the release may be difficult. For example the operations may fan out to multiple processes or daemons running asynchronously to add a significant complexity in managing the power assertion requests. As a result the system may enter a sleep state unexpectedly and or remain in a high power state unintendedly.

Thus existing mechanisms in process or task management of an operating environment tend to be statically constrained inefficient and ineffective to dynamically distribute characteristics of processes between each other.

A voucher may be containers for attributes and values used to pass context through an operating system or environment via inter process communication IPC mechanisms. Vouchers can be created destroyed redeemed and adopted. Messages carrying vouchers may be exchanged among separate processes or other runtime execution instances to distribute context information of the processes.

In one embodiment a plurality of processes may be running with each process having attributes including a privilege to control access to processing resources. A first process may be running with a first privilege prohibited from access to a processing resource. A second process may be running with a second privilege allowed to access the processing resource. The first process may receive a request from the second process to perform a data processing task for the second process. In response the second privilege may be dynamically transferred to the first process to allow the first process to access the processing resource. The first process may perform operations for the data processing task with the second privilege transferred from the second process.

In another embodiment a first process running with a first priority may receive a request from a second process running with a second priority to perform a data processing task for the second process. A dependency relationship may be identified between the first process and a third process running with a third priority performing a separate data processing task. The dependency relationship may indicate that the data processing task is to be performed via the first process subsequent to completion of the separate data processing task via the third process. The third process may be updated with the second priority to complete the separate data processing task. The first process may perform the data processing task with the second priority for the second process.

In another embodiment activities may be tracked among a plurality of threads belonging to a plurality of processes running in one or more processors. Each thread may be associated with one of the activities. Each activity may be associated with one or more of the threads in one or more of the processes for a data processing task. The activities may be ordered by a priority order. A group of the threads may be identified to be associated with a particular one of the activities with highest priority based on the priority order. A thread may be selected from the identified threads for next scheduled execution in the processors.

In another embodiment a power assertion indicator may be maintained for a device component having a power level. The power assertion indicator can indicate whether the power level of the device component is allowed to be lowered. A power assertion request may be sent from a first process to prevent lowering the power level of the device component before a data processing task is completed. A second process can receive a request from the first process to perform operations for the data processing task. The power level of the device component may not be allowed to be lowered before the second process completes the operations for the data processing task. The power level of the device component may be lowered after the data processing task is completed.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.

Methods and apparatuses for distributed power assertion are described herein. In the following description numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known components structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software such as is run on a general purpose computer system or a dedicated machine or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in different order. Moreover some operations may be performed in parallel rather than sequentially.

A voucher may provide a container to represent a portion of a context of a runtime process. A context of a process may include attributes related to a runtime state of the process. In one embodiment a voucher may include attribute value pairs. Each attribute and associated value may be managed via an attribute manager which can be predetermined and or dynamically configured in a kernel of an operating system. Examples of attributes may be related to runtime privilege execution priority power management usage accounting activity tracking task scheduling or other applicable management attributes on runtime operations.

A voucher may represent an assembled collection of meta attributes rather than a direct capability for authorizing a specific single operation. For example vouchers may be used as meta data or additional data to allow various attributes of processes or execution instances to be used simultaneously in their capabilities for implicit activity tracking importance representation resource accounting etc. Even in the security based voucher attributes a voucher carries meta data to be used in combination with or in addition to per task thread data already available for such authorization. For example a voucher may carry a security attribute or entitlement to alter the behavior of a sandbox authorization.

A context for an execution instance such as a process thread etc. may include a set of data used by this instance at a point in time. A process may be a user application a daemon running in the background or a system application etc. The context when saved can allow a continuation of this instance at an arbitrary future date. For example a context may include states or statuses of processor registers memory used control registers used by an operating system to manage the execution instance and or other applicable data.

Applications e.g. processes can pass around attributes of runtime contexts via vouchers or a voucher mechanism for other processes to take on different identities or context attributes to perform operations as requested. A process can send receive vouchers carrying context attributes e.g. via IPC mechanism or messages.

In one embodiment interfaces provided via a kernel may allow a process to access vouchers for example to create destroy redeem or adopt the vouchers. The process can redeem a received voucher to ask the kernel to update the process s own context according to attributes in the received voucher. The kernel may return a voucher back to the requested process in response to the redeem request. The returned voucher can be an altered modified voucher with respect to an original voucher. A voucher may not be modified once returned. A thread within the process may adopt the received and redeemed voucher by communicating with the voucher system to request the adoption. The voucher system can then associate that voucher with the future execution of that thread.

A voucher system can create vouchers to provide a transporting mechanism to distribute attributes of a process context. The voucher system can reside for example in a kernel of an operating system. In one embodiment the voucher system can include verification or certification operations to ensure that processes pass vouchers created by the voucher system. For example the voucher system may be privileged to retrieve attribute values and or determine validity of attribute values associated with a voucher. Such privilege may not be granted for processes or applications other than the voucher system. The voucher system may create vouchers which are immutable without the possibility of making changes e.g. altering attributes values to an existing voucher. The voucher system may allow another voucher to be created using an existing voucher e.g. via overlaying with additional attributes .

In some embodiments an IPC message may include a reference to a voucher for processes to pass the voucher. A voucher system can manage the reference to the voucher without a need for an application to track whether there are still existing references to the voucher. The voucher system may automatically increment decrement the reference count to the voucher as the voucher is being passed around. The voucher system can destroy a voucher for example when an associated reference count indicates that the voucher is no longer referenced.

Each attribute in a voucher may be managed via an attribute manager residing either in a kernel or a user space of an operating system. The voucher system may include a registry specifying which attribute managers have already been registered e.g. predetermined . Multiple attribute managers may be pre registered or dynamically updated with the voucher system. Examples of attribute managers may be related to security privilege settings activity tracing changes in execution priority execution scheduling power management and or other application context attributes.

For example a voucher can include an activity attribute managed by an activity manager to provide an inexpensive activity tracking mechanism. Operations incurred directly or indirectly via multiple processes or threads as a result of an activity e.g. a user interface or network event etc. can be identified via the voucher system.

In another embodiment a voucher can include an accounting attribute managed by a resource accounting manager to track the amount of resource usage to perform a task e.g. sending an email . Each task can cause executions in multiple processes daemons or other execution instances. The resource accounting manager may create a linkage among different processes e.g. a network daemon a user interface manager etc. performing operations for a common task based on an account attribute value for monitoring the resource usage.

Resource accounting can charge the use of CPU central processing unit or processor cycles by daemons e.g. a data indexing service daemon to an application that caused the daemon to do the work by using vouchers to track who caused the daemon to do the work. Hence a utility activity monitor can show for example processor cycle time consumed by a data indexing service daemon gets charged to different applications such as email application document processing application etc. Resource accounting can also extend beyond daemons.

As an example a business email account and a personal email account of an email application may be tracked as two separate tasks via different accounting attribute values. A resource accounting attribute in a voucher may allow a resource manager in an operating system to tally separate usages of processor cycles for the personal email account vs. the business email account without a need to require two separate email applications.

In one embodiment entitlements may be special privileges that can be transferred via vouchers. For example entitlements may include a cryptographically validated set of meta privileges associated with an application or daemon. They may be queried by the sandboxing mechanism s of the system to determine access to certain sandbox escapes. Entitlements may be live referenced in the voucher system. A crypto failure of the main application would render the entitlement reference held in the voucher ineffective just as it does for the originating process at any time during a e.g. complex IPC work transfer down through as many daemons as required.

In some embodiments roles may include means of identifying a mode of operation of an application. For instance a role may indicate that a process has been authorized to access work related items such as contacts emails messages VPNs virtual private network etc. . . . stored on a mobile device where another role may limit the very same application to personal items only. We envision carrying these roles in vouchers as well identifying the mode that subsequent daemons can execute in while servicing requests from a client in a particular mode. Just as with entitlements a switch of mode for the application while a request is in flight may be seen through the voucher reference and the daemons working on their behalf will adjust accordingly on the fly.

Kernel may include inter process communication handler module to provide interfaces or methods for the exchange of data among multiple threads in one or more processes. Inter process communication may be based on shared memory system calls application programming interface API or other applicable mechanism. For example process may communicate with process by sending IPC messages via IPC handler module . Voucher management module may be a subsystem in kernel . Voucher management module may include a daemon exposed via IPC operations e.g. IPC messages . In one embodiment vouchers of system such as vouchers may be maintained and managed in a single subsystem via voucher management module .

For example vouchers can be created destroyed referenced counted copied validated or invalidated or maintained via voucher management module . Data structures corresponding to vouchers may be stored within voucher management module . In one embodiment voucher management module may destroy a voucher when no longer referenced e.g. with zero reference count . Voucher may represent voucher references to corresponding actual vouchers stored via voucher management module .

Attributes and associated values may be managed via attribute managers which can reside inside a kernel such as attribute managers or in user space runtime such as attribute managers . Attribute managers may be registered in voucher management module to provide different functions via corresponding attribute values or tags keys carried via vouchers. These functions may include activity tracing importance donation power assertion management activity scheduling or other application functions.

In one embodiment an attribute manager can determine attribute values for a corresponding attribute for example as requested via voucher management module . An attribute manager can maintain runtime relationships among execution instances e.g. processes threads etc. referencing or having vouchers specifying the corresponding attribute values. Attribute managers may request updates on properties e.g. security privileges priorities etc. of execution instances and or system components e.g. power management via system management module .

In one embodiment process e.g. an application can send a voucher request for one or more attributes to voucher management module e.g. a daemon via IPC handler module . In response voucher management module can request corresponding attribute managers for values of requested attributes to create voucher . Voucher management module can return voucher e.g. a reference back to process e.g. via IPC handler module .

Subsequently process can send an IPC message carrying voucher to process e.g. via IPC handler module . In response process may send a redeem request with received voucher to voucher management module to take a new identity for execution based on attributes of voucher . IPC handler module can forward voucher from the redeem message received to voucher management module . In turn voucher management module may send voucher e.g. a new voucher or another reference to voucher to process .

In response process may send an adopt message with voucher to inform voucher management module on taking new identities or properties based on attribute values included in voucher . Process may perform operations or data processing tasks for process based on the new identities. Process may return voucher e.g. when the data processing tasks for process are completed back to voucher management module for example to decrement a reference count of voucher and update attribute values managed in corresponding attribute managers.

In one embodiment a context of an execution instance e.g. a process may include execution privilege such as a permission to perform an action or access a processing resource. Examples of various privileges may include the ability to create a file in a directory or to read or delete a file access a device or have read or write permission to a socket for communicating over the network. A process may acquire a privilege dynamically by performing a successful verification using for example an encryption key a pass code or other cryptographic or security settings. Privileges may be dynamically distributed among processes based on a voucher mechanism.

For example a process which has already acquired or established a special privilege required to access a computing resource e.g. a file may temporarily and securely transfer the special privilege to another process to perform a task which requires accessing the computing resource. In other words a process may be updated with a special privilege from a separate process with the special privilege to perform a task. The process may be stripped of the special privilege when the last reference to the voucher containing the special privilege is voluntarily released by the process. In other embodiments the process may be stripped of the special privilege after the task is completed.

In some embodiments distributing security privileges via vouchers may prohibit daemons capable of performing certain system level operations e.g. or tasks from being hijacked by attackers to perform unintended operations. For example the daemon may run with little privilege e.g. being toothless or harmless unless after redeeming a voucher transferring required privileges or entitlements from another process with such privileges. The daemon may dynamically become more privileged or pick up more privileges via vouchers received from other processes. Without vouchers received from other process the daemon may not be able to compromise e.g. make changes to a system. Thus possibility of security attacks such as jailbreaking via daemons may be reduced.

In one embodiment a daemon may be launched in the background running in a low or restricted privilege e.g. via a least privileged model . The daemon may wait for donations of higher privileges from other processes via vouchers. During different periods of time the daemon may run with different privileges e.g. incompatible or compatible privileges according to vouchers received. Incompatible privileges when combined may render a process incapable of performing operations as intended for each individual privilege. For example a first privilege allowing access to a first file but not access to a second file may be incompatible with a second privilege allowing access to the second file but no access to the first file. Vouchers may grant privileges to enable a daemon to perform operations for different privileges separately without a need to combine these privileges together. Vouchers may grant restricted privileges but may not restrict privileges .

Process may include for example an application running with a user privilege. Process may transfer the user privilege to daemon to run under the user privilege for providing a service to process via IPC mechanism. For example process may send a voucher request to kernel . A voucher subsystem such as voucher management system of may return a voucher including privilege value back to process .

Privilege attribute manager may generate privilege value for a privilege attribute in a voucher requested by process . Privilege value may correspond to a current privilege associated with process . For example privilege attribute manager can identify the current privilege of process via runtime privilege management module to generate privilege value . Relationships e.g. mapping or association between privilege value and process may be stored or registered in privilege value registry . Whether an attribute value in a voucher is valid or not may depend on whether the attribute value is already registered in privilege registry via privilege attribute manager .

Privileges may be transferred or donated selectively e.g. not just all or nothing between processes. For example privilege attribute manager can determine which privileges or which portions of privileges currently associated with a process to generate a privilege value. A process may specify whether to donate all its privileges or selective portions of its privileges via for example parameters of an IPC message or other applicable interface mechanism.

In some embodiments daemon may include a main thread receiving a voucher with privilege value from process via an IPC message. As a result one or more threads or worker threads may be dispatched e.g. asynchronously to take identities of the received voucher to perform processing tasks or services requested by process for example using a privilege of process indicated in privilege attribute value of the voucher received.

For example daemon may include a plurality e.g. a pool of threads executing blocks scheduled in queue . Block may include voucher specifying execution attributes such as a privilege value for executing the code in block . Block may be scheduled in queue with a voucher with privilege value received from process . Block may correspond to a logic execution unit or a set of instructions e.g. a function or a piece of code to be executed in sequence to perform services requested by process . Block scheduled in queue may include the voucher received from process which can include properties of runtime context of process including privilege value and other applicable attribute values e.g. resource usage accounting activity scheduling etc. 

Each thread in daemon such as thread or thread may wake up taking a task scheduled according to queue e.g. from the head of a queue in sequence for execution. For example thread may execute block via identities of process specified in a voucher including privilege value . Runtime privilege management module may update execution of thread with a user privilege indicated via privilege value determined by privilege attribute manager .

Multiple threads may wake up to pull blocks from one or more queues to execute concurrently with a common voucher or different vouchers. For example thread may switch vouchers taking on separate blocks from queue at different times with different privileges. Daemon may not run with a specific privilege all the time.

In one embodiment the first process may be running with a first privilege. The first process may be prohibited from an access to a processing resource with the first privilege e.g. controlled via runtime privilege management module of . For example the first process may be a daemon process invoked or initiated with a default privilege incapable of accessing resources which could cause a system such as system to be compromised.

In some embodiments the second process may run with a second privilege allowing or permitting an access to a processing resource not available for processes running with the first privilege. For example the second process may be a user application assigned with the second privilege according to an authenticated or verification mechanism.

At block the processing logic of process can dynamically transfer the second privilege of the second process to the first process to allow the first process to access a processing resource for the first process to perform a data processing task. For example the processing logic of process may update attributes of the first process with the second privilege in response to receiving a request from the second process for the first process to perform the data processing task for the second process.

A request received from the second process may include a voucher maintained via a voucher system such as voucher management module of . The voucher may include attributes indicating the second privilege of the second process. The processing logic of process can send an attribute change request e.g. a voucher redeem request including the voucher received from the second process to the voucher system. The attribute change request may be sent from the first process running with the first privilege.

The processing logic of process can receive a separate voucher at the first process from the voucher system in response to a redeem request or an attribute change request. The separate voucher can indicate the transferred attributes from the second process to the first process. The processing logic of process can send a confirmation message e.g. an adopt message including the separate voucher to the voucher system via the first process running with the transferred attributes. The confirmation message can indicate that the first process has adopted the transferred attributes according to the separate voucher.

A redeem operation e.g. via a redeem message can modify a set of voucher attributes for example via combining current process attributes with those found in the voucher in some controlled way. An adopt operation e.g. via an adopt message can make a voucher live for a current execution context. An adopt message may inform the voucher system which voucher is current for a given execution context or thread.

In some embodiments a voucher can specify attributes to be transferred. For example the attributes can include a privilege attribute. The processing logic of process can send a voucher request or a request for a voucher to the voucher system via the second process running with the second privilege. The voucher request can specify the privilege attribute. The processing logic of process can receive a voucher from the voucher system responding to the voucher request. The received voucher can include a privilege value associated with a privilege attribute to represent the second privilege. The vouchers may be maintained in a storage structure in the voucher system.

The processing logic of process can generate a privilege value associated with the second process and the second privilege in response to a voucher request from the second process. The generated privilege value may be registered or stored in a registry such as privilege value register of .

In some embodiments the processing logic of process can verify whether a voucher received via an attribute change request is valid via an attribute value of the voucher. For example if a privilege value or privilege attribute value in an attribute change request is not registered in a registry for privilege attribute values the voucher associated with the attribute change request may not be valid.

A voucher may not be created with an invalid attribute value. An attribute manager may perform validation at the time a recipe element is passed to the attribute manager during voucher creation. That recipe element may contain an attribute value from an existing voucher for example as proof of access to a voucher containing an original value to which a recipe command e.g. with the recipe command to create a voucher is applied. A new attribute value may be provided as a result of the recipe command. In one embodiment an attribute value of an existing voucher e.g. via a voucher system is always valid.

In certain embodiments the first process may perform a data processing task including a subtask to be performed by a third process. The third process may be running with a third privilege which may be less privileged than the second privilege of the second process. The processing logic of process may send the voucher e.g. based on IPC message with a reference to the voucher received from the second process to the third process via the first process to allow the third process to run with the second privilege to perform the subtask.

A privilege value included in the voucher may have an association e.g. via privilege attribute manager of indicating the second privilege transferred from the second process for the first process. The processing logic of process can update the association of the privilege value to indicate that the third process running with the second privilege transferred from the second process via the first process.

In one embodiment the first process may include a plurality of threads executing works scheduled in at least one queue concurrently. The processing logic of process can dispatch at least one work to the queues to perform a data processing task via the first process. Each work may be associated with a block of code and a voucher e.g. indicating a privilege for executing the block of code. At block the processing logic of process can perform the data processing task for the second process via the first process running with the second privilege. One or more threads of the first process may execute works retrieved from the queues substantially concurrently.

For example a thread may retrieve a scheduled work from the queues and switch the privilege of the thread according to a privilege value included in a voucher of the retrieved work e.g. via a redeem request . A thread of the first process may execute a corresponding block with the second privilege of the second process while at least one other thread of the first process is currently executing a separate block of code with a separate privilege different from the second privilege.

In some embodiments if an exit of the second process is detected while the first process is performing the data processing task for the second process with the transferred attributes including the second privilege the processing logic of process can dynamically reset the attributes of the first process in response to the detection. For example when informed of the second process exit via other means outside the voucher management system the processing logic of process e.g. via an attribute manager can make the effective privilege reflected by that privilege attribute value moot. The first process may still run with it but it has little to no effect. Other attribute managers may allow the privilege to outlive the second process to guarantee completion of operations started on behalf of the second process. Priority type privileges tend to go away with the donating process demise while security type privileges may tend to live on beyond the donor s demise.

At block the processing logic of process can receive requests from one or more separate processes at the first process to perform the data processing task for the separate processes. The requests may be based on messages via inter process communication mechanism. Each separate process may be running with a separate privilege. Each request can include a separate voucher indicating the separate privilege of the requesting process. Each voucher can include one or more attributes including a privilege attribute associated with a privilege value indicating an execution privilege.

At block the processing logic of process can dispatch one or more work units to a queue via the first process to perform the data processing task for the separate processes. Each work unit may be associated with a separate voucher of one of the requests. Each work unit may be associated with one of the blocks of code.

At block the processing logic of process can execute the associated blocks of code of the work units from the queue via one or more threads of the first process concurrently. Each thread may retrieve one of the work units at a time to execute the associated block of code of the one work unit. Each thread may run for the work unit retrieved with a separate privilege indicated in a separate voucher associated with the work unit.

A resource accounting value assigned for the resource accounting attribute may correspond to an identifier e.g. activity identifier uniquely identifying one of a plurality of activities occurring in a system. For example an activity resource manager in attribute managers of may generate and maintain the activity identifiers for the resource accounting attribute. An activity may include processing operations caused by for example a user interface action a network event or other applicable trigger detected by the system. A process may perform operations for different activities based on different activity identifiers dynamically currently associated with the process for example via vouchers.

At block A the processing logic of process A may track resource usage for operations performed for a particular activity via one or more processes. The particular activity may be identified by a particular identifier as attribute value for the resource accounting attribute. The processing logic of process A can maintain separate usage charges associated with separate identifiers for example in an activity resource manager.

In one embodiment the processing logic of process A can monitor usage of a processing resource such as cycle time spent in a processor based on the identifiers. For example interfaces for identifying when cycle time of a processor is assigned to a process may include a resource accounting attribute value e.g. an identifier of the process to identify an activity. The processing logic of process A can update the usage charge according to the monitored usage based on the corresponding identifier.

In certain embodiments a processing resource may include a processing logic a communication system a cellular data transceiver WIFI wireless local area network products that are based on the Institute of Electrical and Electronics Engineers 802.11 standards interface other applicable wired or wireless network interfaces or other types of resources in a data processing system. A usage of a processing resource may be accounted for based on the amount of time or number of times the processing resource is dedicated to an activity.

In one embodiment the processes may include a first process and a second process. At block A the processing logic of process A may dynamically update the resource accounting attribute of the second process with the particular identifier in response to a request received at the second process from the first process which is performing operations for a particular activity identified by the particular identifier.

For example the request may be received via a message based on inter process communication mechanisms. The message may include a reference to a voucher carrying the particular identifier. The second process may receive the request to perform operations for the first process currently associated with the particular activity identified by the particular identifier.

In one embodiment the operations performed by the first process for the particular activity may account for a first amount of the resource usage. The operations performed by the second process with the particular identifier may account for a second amount of the resource usage. The monitored usage of the processing resource may indicate the first amount and the second amount based on the particular identifier.

The processing logic of process A may charge e.g. record or update a particular usage charge associated with the particular identifier with the first and second amounts of the resource usage. At block A the processing logic of process A can generate a report e.g. via a user interface of the resource usage for the particular activity based on the particular identifier. The report may indicate a total amount or separate amounts of the resource usage for the particular activity across multiple processes including the first and second amounts of the resource usage by the first and second processes.

In one embodiment priority or importance of a process may be donated or granted to other processes dynamically and temporarily for one process to provide influence on how processing tasks should be performed by other processes for the one process. For example a foreground application e.g. process may be running with a higher priority or importance to support timely and snappy responses to a user. A background daemon e.g. process capable of a specific task e.g. networking indexing searching etc. may run with less importance or lower priority to support interactivity of the foreground application.

A link between the foreground application and the background daemon may be established via a voucher mechanism to raise importance of the background daemon with the importance of the foreground application for the background daemon to perform associated special service or task for the foreground application. The link may be dropped for the background daemon to return back to its default importance once the requested service is completed.

In some embodiments daemon processes may be started with a default priority at a level of low importance without affecting for example interactivity of a system. In other words a daemon may run in the background with a default low priority when no process is talking to the daemon. Over time these daemons may adapt their priorities from other processes via a voucher mechanism to perform tasks or provide services requested.

In one embodiment the priority or importance of a process such as a daemon may be dynamically boosted by another process by inclusion of a voucher containing a priority importance privilege along with the request to perform a task. A first process e.g. a daemon with a priority boosted by a voucher received e.g. from a high priority process may pass along the voucher to a second process e.g. another daemon to automatically boost the priority of the second process. The boosted priority of a process to perform a requested task may be dropped from the process when the requested task is completed.

In one embodiment process A e.g. an application may run with an application level priority to support an interactive usage. Process B and Process C may run with priorities lower than the application level priority of process A . For example process B and or processes C may start as daemon processes in the background running with a default priority configured to be low enough not to affect interactivity of foreground applications.

Process A may execute code making an IPC call to process B to perform a task. In one embodiment process A may send a voucher request with priority attribute from kernel for example via voucher management module of . Accordingly priority attribute manager can generate a priority value a for the priority attribute based on the current priority of process A .

For example runtime priority management module may indicate which level of priority is currently associated with process A . In some embodiments priority attribute manager can maintain priority attribute values in priority value registry . Priority attribute manager may register generated priority value a for process A in priority value registry .

In one embodiment process A may send an IPC request with a voucher having attribute value a to process B to perform a task for process A . In response process B may redeem the received voucher from process A for example when running with a default low priority. Kernel may respond to the redeem request from process B with a separate voucher having a priority attribute value b . Process B may run with an updated priority e.g. the application priority of process A according to priority attribute value b .

According to some embodiments priority attribute manager may generate priority attribute value b based on a redeem request received from process B . The redeem request may include a reference to a voucher with priority attribute value a from process A . In one embodiment priority attribute manager may include priority map storing dependency or linkage relationships of a priority value generated. For example relationship may indicate that priority value b is associated with a priority donation from process A to process B . Priority attribute value b may be registered in priority value registry . Runtime priority management module may boost priority of process B to the priority of process A for example according to priority attribute manager .

In some embodiments process B may request process C to perform operations or subtasks when process B is performing a task for process A using a priority or importance donated from process A . Process B may send an IPC request with the voucher having priority attribute value b to process C . As a result priority attribute manager may generate and register priority attribute value c for a voucher forwarded to process C . Relationship may be stored to indicate a linkage from process C to process B for priority attribute c . Relationships may correspond to a linkage chain between processes A B and C. Priority of Process C may be boosted to the priority of process A to perform subtasks requested by process B.

Dependency relationships among different execution instances may be tracked based on vouchers via for example voucher manager management module of . Priority attribute manager may determine whether a process is boosted by another process and whether to drop a boosted priority when a voucher is no longer referenced. For example process A may exit and cause a decrease of a reference count of a voucher e.g. with priority attribute value of to zero or passing a threshold value . As a result priority attribute manager may drop the boosted priorities of process B and process C back to their previous priority levels e.g. before being boosted via the priority attribute values according to the chained relationships in priority map .

In some embodiments when a second process sends an IPC message to a first process a priority attribute value is automatically added by the IPC message system to a received voucher. This automatic process may be controlled by an attribute on the communications channel e.g. Mach port . This received priority attribute is already redeemed such that the first process will already be influenced by the priority attribute from the time the message is enqueued while it is received and all the way through the execution of the requested task.

The request received at the first process may include a reference to a voucher. The processing logic of process may send before sending the request to the first process a voucher request for the voucher to a voucher system such as voucher management module of via the second process running with the second priority. The voucher request may contain a priority attribute without a value . The processing logic of process may receive the voucher including a priority attribute value via the second process from the voucher system subsequent to the voucher request.

In one embodiment the second process may send the request based on an interface call via an inter process communication mechanism. The request may include a voucher maintained in a voucher system. The voucher can indicate the second priority of the second process for example via attribute values including a priority attribute value. The processing logic of process can send a priority change request e.g. a voucher redeem request based on the voucher received to the voucher system from the first process running with the first priority. The processing logic of process may update the priority of the first process with the second priority indicated in the voucher according to the priority change request.

In one embodiment the processing logic of process may receive a reply from the voucher system at the first process in response to the priority change request. Subsequently the processing logic of process may send a priority change confirmation message e.g. a voucher adopt message from the first process to the voucher system. In some embodiments the first process may have already been updated to run with the second priority when sending the priority change confirmation message.

The processing logic of process can register and maintain priority values generated in a registry such as in priority value registry of . For example a priority attribute value associated with the second process and the second priority may be generated for a voucher request received from the second process. A priority attribute value associated with a process may be maintained in a priority map such as priority map of . The processing logic of process can update the priority map for the priority attribute value generated in response to receiving a priority change request having a voucher including the priority attribute value. The processing logic of process can update the priority map to indicate a dependency relationship between two processes.

In some embodiments the processing logic of process can verify whether the voucher referenced or included in the priority change request is valid in response to receiving a priority change request referencing a voucher. The verification may be based on for example a priority attribute manager such as priority attribute manager of . The voucher may not be valid if the priority value referenced is not yet registered in the registry.

At block the processing logic of process can identify a dependency relationship between the first process and a third process running with a third priority to perform a separate data processing task. The dependency relationship e.g. execution or resource usage dependency relationship may indicate that the data processing task requested by the second process is to be performed via the first process subsequent to completion of the separate data processing task of the third process.

In one embodiment a priority map such as priority map may include priority values associated with one or more dependency relationships among two or more processes. The processing logic of process can search the priority map to identify one or more processes the first process depends on or waits for. Two dependency relationships e.g. a b b c may be transitive corresponding to a third dependency relationship e.g. a c . The search may be based on the transitivity of the dependency relationship.

In some embodiments priorities of the identified one or more processes the first process depending on may be automatically updated according to the second priority of the second process via the voucher received in the first process based on the priority map without requiring requests from the identified processes. Priority of an identified process the first process depending on may be updated or boosted to the second priority if its priority is lower than the second priority.

In one embodiment the first process may depend on a third process and a fourth process and the fourth process may depend on the third process based on the priority map. For example the priority map can specify a dependency relationship between the fourth process and the third process based on an IPC request with a voucher from the fourth process to the third process prior to the request received at the first process from the second process. The processing logic of process may detect an exit of the fourth process e.g. being unloaded from a runtime to cause an update of the priority map to remove the dependency relationship between the fourth process and the third process.

The processing logic of process may detect completion of work in the fourth process directly as a result of IPC requests from the first process. For example the detection may be based on reference counting the exposed voucher s resulting from those requests. In response to the detection that the fourth process has completed its work or requested task the processing logic of process may update the priority map of the fourth process to remove the dependency relationship from the first process. The priority map may still maintain the dependency relationship between the first process and the third process.

In other words when a daemon in a middle of a chain completes all the work it is directly executing on behalf of a client i.e. requested by the client there is no need to continue to raise its priority as a result of that request. However if it sends work downstream to another daemon that work would still be affected by the importance of the ultimate e.g. the original requesting client AND the intermediate daemon both still may depend on it completing timely . In this way a middle chain daemon process e.g. a broker model daemon servicing many clients simultaneously can be allowed to not have to remain boosted as long as all downstream work is progressing.

The processing logic of process may perform the data processing task for the second process via the first process running with the second priority. The processing logic of process may ensure priorities of other processes the first process depending on may also be boosted to the second priority via the voucher mechanism for the first process to perform the requested data processing task.

The processing logic of process may send a message via an IPC mechanism from the first process to the second process. The message may include a reference to the voucher. The second process may receive the voucher based on the reference in the message. At block the processing logic of process can grant the second process with the first priority of the first process to perform the data processing task in response to receiving the voucher from the first process.

At block the processing logic of process can reset the second process back to the second priority in response to a completion indication of the data processing task for the first process by the second process. For example the completion indication may be identified based on a return of the IPC message requesting the data processing task from the second process to the first process.

In one embodiment execution scheduling may be based on activity ids included in vouchers associated with processes threads or other applicable execution instances. For example a group of threads having the same activity id or activity based thread group may be scheduled together. A thread may pick up a voucher associated with a work unit e.g. a code block from a work queue for executing the work unit. The activity id included in the voucher may be used as another dimension e.g. other than a process id to determine when the thread is to be given processor time. An activity based thread group may include threads from different processes running with separate priorities. A voucher mechanism may facilitate tracking of activity based thread groups.

For example a system may schedule threads running codes in response to email activity such as sending an email message including user interface handler security processing network interface for sending receiving messages etc. These threads may be scheduled together regardless which process each thread is associated with. Thread execution order can be allowed to cut through different processes. Thus inefficiency because of running threads of high priority processes for operations not related to this email activity can be avoided.

In one embodiment a voucher mechanism can maintain an efficient representation of linkage structures among different execution instances in a system. For example instead of the costly processing work to provide detailed marks or accounting on each individual owner e.g. processes threads of each resource short hand marks may be implemented via vouchers to describe a collection or set of possible owners of each resource with less cost in system overhead.

When conflicts are detected detailed analysis of dependencies on individual execution instances may be performed for a resolution. A conflict may occur when scheduled execution instances have blocking conditions to be satisfied by other execution instances. Detailed analysis may include recalling or identifying resources owned by an execution instance e.g. a process . In some embodiments linkage information provided from a voucher mechanism may be used for activity id based execution scheduling without performing detailed analysis when there is no conflict in scheduled execution.

A thread may pick up different vouchers during different periods of time to take on different activities. Thus an activity identifier may be temporarily tied to a thread. A process may include multiple threads simultaneously scheduled for more than one activity or activity id . A process or task may be associated with a process priority. In one embodiment each activity id picked up by a thread may be of a higher priority e.g. more important than a process priority. As an example threads performing relevant works e.g. based on code blocks executed associated with a window scrolling event may be tagged with one activity id with a higher priority than other processes running in a system.

According to certain embodiments a single thread can be associated with multiple activities simultaneously. For instance and these are just examples others are possible 

A contented resource can be associated with one or more types of activities e.g. including the above listed types of activities as a hint or resource hint as to what needs to happen to make the resource available. A thread trying to gain access to the resource can look at the activity hint and try to drive e.g. execute code of the thread s that are members associated with the activity hint. If any of these member threads are blocked on a resource that resource s activity hint can be referenced and so on until a runnable thread is encountered in which case it is run or until none is found at which point the thread ultimately blocks and gives up the remainder of its quantum .

In one embodiment dynamic activity linking at blocking points may provide the hints required to resolve contention and to wake the appropriate processes when some progress can be attempted again. An activity id specific to a thread blocked waiting for resolving the contention can be linked to an activity associated with the contention e.g. blocking condition . The thread may be unblocked when any other thread of the activity is unblocked.

For example when a thread first encounters a resource it cannot acquire the thread can link its own private thread activity to the activity in the resource hint e.g. via activity linkage information . As other threads have done the same this makes a backward tree e.g. in the activity linkage information of possible candidates to run a piece of work when something gets unblocked the thread that is woken itself can be at the root of that tree but then all the other threads directly or indirectly depending upon are linked up through this tree . This backward linkage may be used to summon the highest priority thread waiting for progress to be made when a wakeup occurs anywhere within the tree.

In one embodiment a process may be identified with a normal activity or normal activity id. Each thread of the process may run with the normal activity id by default until changes or updates are received. For example a window scroll event may cause creation of an activity id via a voucher system. A thread running with the normal activity id may adopt a voucher carrying the newly created activity id via an IPC message. The thread can be temporarily updated to run with the newly created activity id instead of running with the normal activity id.

In some embodiments vouchers maintained in a voucher system may have a hierarchical relationship. A voucher e.g. for a child activity or sub activity created by overlaying or copying attributes from a separate voucher e.g. a parent activity may be hierarchically related to the separate voucher. Information included in multiple vouchers hierarchically related may be combined to allow a scheduling decision or other application runtime decisions to be made along multiple dimensions. An effective value of an attribute or key in a voucher may correspond to a combined attribute value or flatten value over its hierarchically related vouchers.

An attribute manager such as in attribute managers of may include a policy to determine how corresponding attribute values are flattened e.g. according to XOR bit operations statistical functions or other applicable combination or selection operations . According to a certain embodiment a combined value priority or importance attribute value among a stack of hierarchically related vouchers may be selected as the priority value of the voucher which is the last or lowest level in the hierarchy among the stack of vouchers

In one embodiment execution priority may be based on an ordering relationship among activities or activity ids . A thread group of the activity id highest in the ordering relationship may be selected for execution scheduling. Runnable threads among the selected thread group may be identified for the next scheduled execution. A runnable thread may have no outstanding blocking conditions waiting to be satisfied to proceed on thread execution. A blocking condition may be related to a synchronization structure or object such as a mutex to be unlocked a condition variable to be signaled etc. which may block execution of a thread waiting for the condition to be satisfied.

If there are no runnable threads in the selected thread group blocking threads may be identified for example by following existing pointers to the blocking threads. Execution of blocking threads may satisfy an outstanding blocking condition of at least one thread of the selected thread group to allow the execution of this one thread. In one embodiment there is no need to passively raise priority of a whole process e.g. daemon a potential blocking thread belongs to. Raising the priority to execute code of the potential blocking thread can resolve the blocking conditions for example to continue execution of a selected thread group. Expensive processing resources such as tracking marking and or recording individual resource thread dependencies or ownerships to handle blocking threads can be avoided.

In one embodiment a thread in an activity id based thread group may execute code associated with blocking threads identified for the thread with a priority corresponding to the activity id. For example the thread can take the scheduled contexts of the blocking threads change priorities of the scheduled contexts to the priority associated with the activity id and execute the code for the blocking threads. As a result when the blocking conditions are satisfied such as when certain resources are released execution can immediately return back to the thread of the activity id without involving an execution scheduler.

In one embodiment activity ids via a voucher mechanism may provide hints on resolving a blocking condition. For example a blocking call may indicate an activity id of owners e.g. threads processes etc. of a resource related to a blocking condition. One by one threads in the thread group based on the activity id may be selected to run in turn i.e. one at a time with raised priority instead of raising priorities of the whole collection of threads in the thread group.

Activity identifiers based on vouchers can provide a way to locate a blocking thread or blocking execution instance quickly e.g. immediately without a need to constantly perform expensive and complex operations setting up and or tracking linkage structures e.g. priorities inheritances ownerships etc. . Propagation of activity ids may be less expensive than propagation of importance or priority via vouchers. Activity id can be cheaply propagated via vouchers. Priority or importance may be updated or propagate when blocking conditions are detected. Potential blocking threads across multiple processes can be identified with more precision via activity ids to resolve a blocking condition for a blocked thread.

In one embodiment linkage relationships or structures may not be set up until when execution is blocked e.g. via outstanding blocking conditions . A thread scheduled to execute e.g. with a highest priority may setup the linkage structures or information when blocked. Thus linkage structures may be created only when needed without a need for firing semi or unrelated threads.

In one embodiment linkage structures may include hierarchical wait queues. A thread with an outstanding blocking condition may be executed to push forward chains of threads to build or construct the wait queues recursively. Dependent threads or execution instances may be identified and given high priority. The wait queues can allow focused traversing back and waking up or running waiting threads when a resolution to satisfy the blocking condition occurs e.g. an input output event received .

Thus a collection of threads waiting to be executed to resolve a blocking condition for a thread may be available via wait queues to automatically detect a chain of high priority threads. A scheduler can quickly jump back to the blocked thread via wait queues once the blocking condition is resolved.

In some embodiments execution scheduler may determine which thread e.g. a runnable thread to execute during runtime for system . Activity based scheduling module may allow a collection of threads having a common activity e.g. an activity based thread group to be scheduled together. Activity priority management module can assign an ordering relationship among different activities or activity ids via for example configuration settings or runtime states. An activity id based thread group may be selected for execution based on the ordering relation ship provided via activity priority management module .

For example process P1 may include threads T1 T2 and T3 . Process P2 can include threads T4 T5 and T6 . Each thread may have adopted a voucher including an activity attribute value or an activity id such as a1 for T1 a2 for T2 a1 for T3 a1 for T4 a2 for T5 and a3 for T6 . In one embodiment a thread group based on activity id a1 may include threads T1 T3 and T4 . Threads T1 T3 and T4 may be collected across processes P1 and P2 to be scheduled as a group together based on activity id a1.

In one embodiment activity based conflict resolution handler module can allow a blocked thread to execute the code of a blocking thread using the priority of the blocked thread if the blocking thread is known. The code of the blocking thread may be executed to resolve a conflict or a blocking condition for the blocked thread.

If the blocking thread s is not known activity based conflict resolution handler module may identify a potential activity id based thread group e.g. according to a hint in an IPC call . Each thread of the potential thread group may be executed with a higher priority e.g. based on the priority of the blocked thread one by one e.g. in a round robin manner for conflict resolution. Activity based conflict resolution handler module may initiate setting up linkage information during conflict resolution to allow quick execution to jump back quickly to the blocking thread when blocking conditions are resolved.

During periods threads P1T1 P2T1 and P2T2 may be collected as a group associated with activity A e.g. via vouchers to be scheduled together for execution e.g. assigned processor cycles . Activity C may be selected for execution via thread P2T2 during period . Activity B may have the highest priority during period .

Turning now to thread T2 may perform operations associated with activity E e.g. via a voucher during period . Thread T2 may be blocked waiting for thread T3 to complete operations associated with activity F . Execution priorities of activity F activity E and activity D may be ordered in an ascending manner according to for example activity priority management module of .

In one embodiment thread T1 may be blocked after performing operations for activity D during period with a high priority. Thread T1 may identify a blocking thread T2 executing code for activity E blocked waiting for another thread T3 executing code for activity F . Identification of a chain of blocking threads T2 associated with activity E and T3 associated with activity F may be based on available information e.g. via pointer tracing without requiring substantial computing resources. In some embodiments identification of blocking threads may require setting up linkage structures to track down the blocking threads.

Thread T1 may execute code of thread T3 for activity F with the execution priority of activity D during period . Subsequently during period thread T1 may execute code of thread T2 associated with activity E with the execution priority of activity D e.g. high priority as indicated in the pointers identified corresponding to waking up thread T2 for activity E . During period thread T1 can immediately return e.g. without involving a scheduler from executing code of thread T2 for activity E to continue perform operations for activity D as the blocking condition has been resolved.

Turning now to threads T5 T6 and T7 may perform operations for activity e.g. identifier H during period . Threads T5 T6 and T7 may belong to a thread group based on activity H . Activity G may be of a higher execution priority than activity H . Thread T4 may pick up a voucher with activity G to perform operations for activity G during period .

Thread T4 may be blocked at the end of period . Blocking threads may not be identified or known for thread T4 . A hint may indicate potential blocking threads associated with or owned by activity H based on for example records of IPC calls. A voucher system may identify a thread group based on activity H for thread T4 to resolve conflict. During periods thread T4 may execute code for each thread of activity H based thread group in a round robin manner under the priority of activity G .

Linkage structures may be set up to track activity or thread dependency information during executions to resolve conflict. The blocking condition may be resolved after executing code for thread T7 via thread T4 . After executing code of thread T7 for activity H which can satisfy the blocking condition thread T4 may immediately return back to execute code for activity G during period .

Each activity may correspond to a data processing task or operations performed by at least one of these threads of one or more processes. The data processing operations may be incurred in response to occurrence of an event such as a user action a network signal or other applicable initiations to a system. The activities can be identified by activity identifiers. A priority order for execution may be maintained among these activity identifiers.

In one embodiment the processing logic of process can store the activity identifiers in a registry. Each activity identifier may be associated with a reference count indicating whether a corresponding activity identified by the activity identifier has been completed.

For example a first process may receive a message from a second process to perform operations for a first activity with a first activity identifier. The message can include the first activity identifier based on an inter process communication mechanism. The processing logic of process can receive from the first process a request e.g. a voucher redeem request including a first activity identifier. In response the processing logic of process can update e.g. increase by one a first reference count of the first activity identifier to indicate an additional reference.

In one embodiment a registry such as activity value registry may include associations between threads and activity identifiers. The processing logic of process can update the associations in response to a request from a first thread with an activity identifier to indicate that the first thread is associated with the activity identifier. The request may be for example a voucher redeem request sent from the first thread before performing an operation for an activity identified by the activity identifier.

In one embodiment a request from a thread or process such as a voucher redeem request can include or refer to a voucher maintained via a voucher system. The voucher can specify an activity identifier for example via an activity attribute. The processing logic of process can verify whether the voucher received via the request is valid via the voucher system. If the voucher is not valid the reference count associated with the activity identifier may not be updated in the voucher system. A valid voucher may be created via the voucher system and received via an IPC message for the request.

There may be no need to verify the activity identifier with respect to the voucher. A valid voucher can refer to the activity identifier. If the voucher is not valid whether the voucher refers to an activity identifier may not be known as the content of an invalid voucher may not be examined.

At block the processing logic of process can identify a group of threads associated with an activity. The group of threads can be identified via the associations between the threads and the activity identifiers stored in a registry based on for example activity attribute manager . The group of threads may be identified based on an activity identifier for execution scheduling conflict resolution or other applicable thread grouping.

At block the processing logic of process may select a thread from an activity id based thread group identified for next scheduled execution in the processors. The processes may be prioritized via a process priority. The activity id based thread group may belong to two or more of the processes. In one embodiment a thread may be selected from within the identified thread group based on the process priority associated with the thread. Alternatively or optionally a runnable thread in the thread group may have a higher priority to be selected than a non runnable thread of the thread group.

At block the processing logic of process can execute the selected thread for next execution in the processors. If the selected thread is not runnable e.g. no thread in the identified thread group is runnable waiting for a blocking condition to be satisfied the processing logic of process may perform conflict resolution operations to satisfy or remove the blocking condition or conflicts . For example a blocking condition related to a lock may be satisfied when the lock is released. A lock may include a synchronization mechanism for enforcing a mutual exclusion concurrency control policy to limit access to a resource.

In one embodiment if one of the threads has already been identified for satisfying a blocking condition of a selected thread which is being blocked the selected thread can execute code of the identified thread to resolve the blocking condition. Subsequent to the solution of the blocking condition the execution can return back to the code of the selected thread without involving a scheduler as the selected thread is already running.

In some embodiments if no thread has been identified for satisfying the blocking condition of the selected threads the processing logic of process may heuristically determine a particular thread group of a particular activity identifier based on for example a hint of an IPC call. Other hints may include membership in the same task as the resource holder being processed in the same set of GCD Grand Central Dispatch queues and therefore a member of the same thread work group or other applicable runtime information. Execution of one or more of the particular thread group may resolve or satisfy the blocking condition of the selected thread. The processing logic of process can execute the code of each of the particular thread group one by one e.g. in a round robin manner via the execution priority of the selected thread.

The processing logic of process may recursively perform operations e.g. based on the execution priority of the selected thread until the blocking condition is satisfied. The selected thread may be executed substantially immediately right after the blocking condition is satisfied. In one embodiment the processing logic of process can set up linkage structures describing ownership or dependency relationship among threads process and or resources when performing operations for conflict resolution.

Relationships among the activities identified by activity identifiers may provide information to resolve or satisfy a blocking condition of a thread. Execution of the thread may be halted waiting for satisfaction of the blocking condition. For example one of the activities may be identified based on hints or other applicable information indicating possibility of resolving the blocking condition if one or more threads of the identified activity are executed. Each thread of the identified activity may have a reference to a voucher with an activity attribute indicating the identified activity.

In one embodiment a voucher indicating an activity identifier may be passed from one process to another process via an inter process message. The message may be sent from a first process to the second process for the second process to perform operations for the indicated activity identified. The activity identifier can have a reference count e.g. based on vouchers counting a number of the references via messages of the inter process communication to maintain relationships among the activity identifiers.

At block the processing logic of process can execute executable code associated with the threads of the identified activity via the thread which is blocked until the blocking condition is satisfied. According to a certain embodiment the processing logic of process may execute each separate code associated with each thread of the identified activity in turn with execution priority of the blocked thread in a round robin manner. At block the processing logic of process can resume execution of the blocked thread subsequent to the satisfaction of the blocking condition.

The example shown in includes a software application which can be a foreground or background application such as an email program a contact program or other software program with which a user can interact e.g. provide inputs and receive outputs and two software daemon processes and that perform operations in the background in regards to calls from other software processes.

As shown in the application makes a call to daemon process to perform an operation for application the call from application can result from an input from a user interacting with application which is a foreground application or from an event associated with application while it is a background application for example a push notification that is received by application while it is a background application .

When daemon receives call 1 it performs one or more operations which in turn cause daemon to call daemon via call 2 . The voucher methods described herein can be used throughout the interaction between application daemon and daemon such that when daemon receives call 2 the voucher system can determine the origin of call 1 to ultimately identify the originating application in this case application . Daemon can request the operating system kernel such as kernel of to identify the originating application using the voucher system described herein and can request the kernel to specify the state of the originating application the state returned by kernel to daemon can then be used to decide where to execute software that is part of daemon such as library that is part of daemon or a library that can be called by daemon .

In one embodiment library can be part of the graphics library known as OpenGL or in another embodiment can call an Open GL library. In some embodiments if the state indicates that the originating application is a foreground application then the daemon can cause the GPU to execute the software in daemon in the GPU rather than execute that software in a CPU . An example of a method which can use the architecture of is shown in the flowchart of .

Turning now to a method can begin in operation in which daemon can receive a call to cause the execution of software in library . In operation the method determines whether the originating application is a foreground application or a background application. A foreground application is normally an application that has at least some view or window that is visible on a display and not obscured by other view of other applications and has at least one input form such as an input from a keyboard mouse or touch input device and hence a user input will be directed to and received by the foreground application and not to other applications . A background application on the other hand will not have the input forms and may not be visible at all on a display.

The operation can use the voucher system described herein to determine the originating application and the kernel can determine whether the originating application is a foreground application or a background application. In the example shown in if the kernel determines that the originating application is a foreground application then the GPU will be selected in operation to perform the execution of the software in library on the other hand if the kernel determines in operation that the originating application is a background application then the processing proceeds to operation in which the kernel determines the operating priority of the originating application and if the originating application has a medium priority then the GPU is scheduled in operation to perform the execution of the software in library at a low graphics resolution. If the operating priority of the originating application is lower than medium priority then in operation the CPU e.g. a core of a CPU is selected to perform the execution of the software in library .

Power states of certain device components can remain asserted via power assertion attributes of vouchers propagated among execution instances e.g. processes applications daemons threads etc. before operations associated with the vouchers are completed via these execution instances. Vouchers with power assertion attributes can allow an application to request a power assertion and forward the requested power assertion to other processes to perform operations. The requested power assertion can still be honored or remain in effect before the operations are completed even after the application releases the requested power assertion.

A power assertion request may be issued e.g. by an application to provide a hint to an operating system that certain components e.g. the processor display screen network hard disks etc. should be kept at a certain power level e.g. asserted or not to go to sleep before the power assertion is released. For example a network notification daemon can listen to an incoming message event to take a power assertion on a machine and notify e.g. wake up a message synchronization daemon via vouchers with attributes of the power assertion to perform synchronization operations between multiple message related applications. The synchronization daemon can complete the synchronization operations before the machine goes to sleep regardless whether the network notification daemon drops the power assertion before or after the synchronization operations are completed.

In one embodiment a power assertion can be issued via a voucher request with power assertion attribute. A power assertion attribute manager may maintain or register power assertion attribute values via for example a power daemon e.g. in user space . Additional power assertion requests e.g. for different components or same components may be obtained based on an existing voucher with power assertion attribute values. The voucher system can provide a new voucher by duplicating or overlaying an existing voucher with updated power assertion attribute values. When power assertions are to be released may be determined according to when related vouchers are no longer referenced as automatically tracked by the voucher system.

Power assertion attribute values may include a finite length of bits. Each bit corresponds to a separate device component such as a disk a memory a display screen a processor a network interface card or other applicable device component having a power state. A bit value one can indicate existence of a power assertion request for the corresponding component. Multiple power assertion bit values may be combined e.g. via power attribute manager via binary bit operations such as logic OR operation to one combined power assertion value. Power attribute manager can send power management requests based on a combined power attribute value to a kernel for managing device power states.

In one embodiment voucher management module can request a power assertion attribute value from power assertion attribute manager based on the voucher request received from process . Power assertion attribute manage can generate the power assertion attribute value for the voucher request. Each power assertion attribute value may be a bit vector with each vector position or field corresponding to one device component with a power state. Each bit of the bit vector may be set to 1 or 0 depending on whether the corresponding component is included in a power assertion request.

In one embodiment power assertion attribute manager can maintain outstanding power assertion attribute values in assertion value registry . Each power assertion attribute value may be associated with a reference count indicating a current number of references by different vouchers in voucher management module . A power assertion value may be removed e.g. no longer outstanding if not referenced by any vouchers. Each time a power assertion value is assigned to a voucher attribute the reference count of the power assertion value may be increased by one. Voucher management module may notify power assertion attribute manager to decrease a reference count of an existing power assertion value when a voucher having this existing power assertion value is deleted e.g. not referenced or used .

Power assertion attribute manager can track changes in outstanding power assertion values to request release power assertions to corresponding device components via for example power management module . Power assertion attribute manager can combine outstanding power assertion values to determine whether there is any change in power assertion requests. Different power assertion values e.g. bit vectors may be combined according to bit level binary operations e.g. OR XOR or other applicable operations . A new power assertion value may be generated by combining multiple existing or outstanding power assertion values.

In one embodiment process can send a voucher request e.g. via an IPC message with power assertion attributes to voucher management module for requesting a power assertion on a device component. In response voucher management module can return voucher with power assertion attribute value e.g. PowerAssert 001 as a bit vector indicating a power assertion has been issued for the device component corresponding to the third bit of the bit vector.

Process may send a message to process to perform operations for process via voucher passing power assertion requests. In a certain embodiment process may issue additional power assertion requests via voucher management module while performing the operations for process . As a result of the additional power assertion requests process may have voucher with an updated power assertion attribute value 011 for example indicating a power assertion request for a device component corresponding to the second bit of a bit vector for a power assertion attribute value has been issued.

Process while performing operations for process may request process to perform additional operations indirectly for process passing along voucher . Process may adopt voucher with the same power attribute value as voucher e.g. referencing the same actual voucher in voucher management module . Power assertions indicated in the power assertion attribute value of voucher may not be released before process completes operations for process . In some embodiments an exit e.g. process crashes or being unloaded of process may indicate its corresponding voucher reference has been removed to prevent zombie power assertion requests.

Power assertion indicators may correspond to one or more power assertion attribute values provided for example via power assertion attribute manager of . Each attribute value or power assertion attribute value can include a bit vector. Each bit of the bit vector may correspond to one of device components of a device. Each bit of an attribute value can indicate whether there is a power assertion request or power assertion request for its corresponding device component via the attribute value. A bit value e.g. 1 can represent an outstanding power assertion request for its corresponding device component.

At block the processing logic of process can send a power assertion request from a first process for a data processing task to prevent lowering the power level of the device component before the data processing task is completed. For example the power assertion request may correspond to a voucher request with a power assert or assertion attribute. The power assertion request may identify the device component whose power level should not be lowered. The processing logic of process may issue the power assertion request based on a program interface call via an inter process communication mechanism.

The processing logic of process can receive a reply from the voucher system in response to the power assertion request from the first process. The reply may include a voucher maintained and or generated via the voucher system. The voucher may have attributes including a power assertion attribute associated with an attribute value to indicate the requested power assertion on the device component. An attribute value for a power assertion attribute may include a bit vector having bit fields corresponding to one or more device components in a device. As a bit vector each bit of the attribute value can indicate whether the attribute value represents a power assertion request for a device component corresponding to the bit.

In some embodiments an attribute value may be associated with a voucher count maintained in for example an attribute manager such as power assertion attribute manager of . The power level of a device component associated with the attribute value may not be lowered if the voucher count indicates that there is at least one voucher which includes the attribute value with the power assertion attribute for the device component. The voucher count of the attribute value may be updated when the voucher is deleted. For example a voucher system may delete a voucher when the voucher is no longer referenced e.g. with a zero reference count . The voucher system may cause an update of the voucher count in an attribute manager.

In one embodiment a power assertion request can include an existing voucher which was previously requested from a voucher system by the first process. The existing voucher may have already an existing attribute value for the power assertion attribute which represents existing power assertion requests previously made for one or more devices components. The processing logic of process can generate a new attribute value based on the current power assertion request and the existing attribute value for example via power assertion attribute manager of . The new attribute value may represent an aggregation of the power assertion request currently issued and the previously requested power assertion requests which have not yet been released. For example the voucher may be generated via an overlay of the existing voucher with a copy of the attributes included in the existing voucher

The processing logic of process can remove the existing voucher as a result of generating the new voucher based on the existing voucher. In some embodiments the processing logic of process can decrement a reference count of the existing voucher for the removal of the existing voucher. The existing voucher may be deleted if the reference count of the existing voucher becomes zero.

At block the processing logic of process can receive a request at a second process from the first process for the second process to perform operations for a data processing task. The request may include the voucher or a reference to the voucher with attributes indicating a power assertion request on a device component. The power level of the device component may not be lowered before the operations are completed via the second process.

In one embodiment the request received at the second process may include a voucher requested from the first process. The processing logic of process can send a redeem request including the voucher from the first process to the voucher system to maintain a power assertion request of a device component indicated in the voucher. The redeem request for the voucher may prevent lowering the power level of the device component before the second process completes performing the operations for the first process.

In some embodiments the voucher may be associated with a reference count in the voucher system. The second process may acquire a reference to the voucher of the first process to perform operations for the first process. The redeem request from the second process may cause an increase of the reference count of the voucher in the voucher system. The power level of the device component with a power assertion request indicated in the voucher may be prevented from being lowered if at least one process has a reference to the voucher for example based on the reference count.

The processing logic of process may verify validity e.g. based on attribute values of the voucher associated with a redeem request received from the second process. No reference counts of vouchers are updated if the voucher of the redeem request is not valid. On detecting an exit of the second process before completing the operations for the first process in one embodiment the processing logic of process may decrement the reference count of the voucher. At block the processing logic of process may lower the power level of the device component after the data processing task performed via the first process and the second process is completed.

At block the processing logic of process can generate a voucher for a first process to indicate an outstanding request to prevent the power level of the device component from being lowered. The power assertion status for the device component may be associated with a reference count of the voucher. For example the power assertion status can indicate whether there is any outstanding power assertion request on the device component based on the number of processes currently referring to the voucher. If the reference count on the voucher indicates at least one process currently referring to the voucher the power level of the device component may not be lowered for the outstanding power assertion request in the voucher.

At block the processing logic of process may update the power assertion status of the device component in response to receiving the voucher from a second process. The power assertion status may be updated to indicate an additional outstanding request to prevent the power level of the device component from being lowered.

The processing logic of process can send a message passing the voucher via an inter process communication mechanism from the first process to the second process. The message may include a reference to the voucher for the second process.

At block the processing logic of process may lower the power level of the device component when the power assertion status indicates that there is no outstanding request to prevent the power level of the device component from being lowered. For example the power level of the device component may be lowered after the outstanding power assertion request from the first process and the additional outstanding request power assertion request from the second process have been released.

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to a microprocessor s and a ROM Read Only Memory and volatile RAM and a non volatile memory . The microprocessor may retrieve the instructions from the memories and execute the instructions to perform operations described above. The bus interconnects these various components together and also interconnects these components and to a display controller and display device and to peripheral devices such as input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art. Typically the input output devices are coupled to the system through input output controllers . The volatile RAM Random Access Memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory.

The mass storage is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory systems which maintain data e.g. large amounts of data even after power is removed from the system. Typically the mass storage will also be a random access memory although this is not required. While shows that the mass storage is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface or wireless networking interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art.

Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine executable instructions that cause a machine that executes these instructions to perform certain functions. In this context a machine may be a machine that converts intermediate form or abstract instructions into processor specific instructions e.g. an abstract execution environment such as a virtual machine e.g. a Java Virtual Machine an interpreter a Common Language Runtime a high level language virtual machine etc. and or electronic circuitry disposed on a semiconductor chip e.g. logic circuitry implemented with transistors designed to execute instructions such as a general purpose processor and or a special purpose processor. Processes taught by the discussion above may also be performed by in the alternative to a machine or in combination with a machine electronic circuitry designed to perform the processes or a portion thereof without the execution of program code.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be kept in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention.

