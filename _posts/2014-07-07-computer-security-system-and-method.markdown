---

title: Computer security system and method
abstract: A method is provided for protecting a computer system, comprising creating an isolated process, then assigning a first process group to the process; creating an additional group process within the first process group; performing a first determination by an application programming interface (API) that the additional group process is within the first process group, and as a result of the first determination, causing the additional group process to inherit and duplicate a handle of the process. Process communications and control within isolated groups is permitted freely, whereas process control by an isolated process for non-isolated processes or isolated processes in different groups is constrained or prohibited.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454652&OS=09454652&RS=09454652
owner: Secure Vector, LLC
number: 09454652
owner_city: Chicago
owner_country: US
publication_date: 20140707
---
The present application is a continuation in part of parent application Ser. No. 13 867 447 filed Apr. 22 2013 which issued as U.S. Pat. No. 8 775 802 entitled A COMPUTER SECURITY SYSTEM AND METHOD which is a continuation in part of parent application Ser. No. 12 911 184 filed Oct. 25 2010 now U.S. Pat. No. 8 429 429 entitled A COMPUTER SECURITY SYSTEM AND METHOD which claims the benefit of U.S. provisional application No. 61 254 432 filed Oct. 23 2009 entitled A COMPUTER SECURITY SYSTEM AND METHOD all of which are herein incorporated by reference.

Computer security is becoming an increasingly important issue as more and more reliance is placed on computers to manage important information. The increasing threat of viruses has required that systems provide adequate protection against both known and unknown threats.

The present system and method for providing computer security relate primarily to the Microsoft Windows based operating system platforms including but not limited to Windows XP Windows Vista Windows 7 Windows 8 Windows Server 2008 Windows Server 2012 which are tied to the Intel Itanium and AMD processors with an Intel 8086 based or RISC based instruction set register and memory configurations. The present system and method particularly relate to both the 32 bit and the 64 bit versions of these operating systems in which more robust features are provided. However the principles established herein are do not specifically require Windows or the specific hardware platforms noted above and the invention is not to be construed as so limiting. Numerous other embodiments are contemplated.

In the 32 bit Windows architectures an application running in user mode can chain patch into a system call table via a known user mode application program interface API . The problem with this approach is that a malicious application can chain into the system call table and from there easily infect almost any part of the system.

In the 64 bit version of Windows a feature called the Kernel Patch Protection KPP informally known as PatchGuard was implemented that does not allow alteration of the operating system code itself making the system more secure and less vulnerable to malicious code. However since some useful programs rely on patching the OS in order to work properly these applications do not work on the 64 bit version.

For both the 32 bit and the 64 bit versions of Windows anti virus and anti spyware software is needed since it is possible to install programs that can give an attacker access to and control over the system merely by clicking on a link in an e mail or by visiting a malicious website containing malware.

Conventional anti virus and anti malware software relies on signatures or specific attributes of malware to detect viruses and malware and to defend against them. Such signatures could be e.g. a specific series of instructions or a data field that is consistent across copies of the virus payload. However new so called polymorphic and automatically self modifying malware can get around these protections by changing their signature dynamically. Criminal enterprises have formed and are currently using these techniques to invade Windows based systems and steal passwords and account information in some cases such techniques have been used to steal hundreds of thousands of dollars using online banking credentials that were stolen.

Furthermore the zero day problem also negates signature based anti virus and anti malware solutions. The zero day problem is the day on which a virus or malicious software is first introduced into the general population. On the first day no analysis has been performed on the threat and no potential signatures have been identified and provided in the anti virus program databases.

Previous attempts to protect against this sort of malware have been based on a separate area of memory or physical disk where all changes to the system are recorded and mapped to the actual files so that changes are not committed to the actual system files but rather the temporary image of those files. However these systems have significant limitations in their ability to function and some cannot function at all on the 64 bit platform because of their reliance on using routines that can be considered security risks.

What is needed is a kernel mode product for both 32 bit and 64 bit Windows platforms which allows users to selectively isolate processes from sensitive areas in the operating system. The important components that are protected through isolation may include the file system the system registry named pipe and mail slot access socket based connections and port communications 

Port based accesses may be filtered for isolated processes. The actions which isolated processes can perform over these ports such as asking the caller about the connections not registering any ports which can be used for call back from the outside etc. can be provided as well.

Based on the above background discussion and in accordance with various embodiments of the invention discussed in more detail below a method is provided for protecting a computer system comprising attaching a security descriptor to a process running on a processor of the computer system that has been previously started associating with the security descriptor an isolation indicator that by itself indicates the process is to run in an isolation mode thereby rendering it as an isolated process the isolated process running with non isolated processes in a common environment calling a kernel routine by the isolated process that is also callable by a process that is not running in isolation mode attempting to write to an object of a disk or a registry by the kernel routine called by the isolated process determining by a filter driver running in kernel mode whether the kernel routine is requesting the write on behalf of the isolated process or a non isolated process if the write is requested on behalf of the isolated process then performing the write in a pseudo storage area and if the write is requested on behalf of the non isolated process then performing the write in an actual storage area in which the disk registry or other actual system or process data resides wherein if the requested write is a first object write then copying the object from the actual storage area to the pseudo storage area assigning a first process group to the process creating an additional group process within the first process group performing a first determination by an application programming interface API that the additional group process is within the first process group and as a result of the first determination causing the additional group process to inherit and duplicate a handle of the process.

A method is also provided for protecting a computer system comprising attaching a security descriptor to a process running on a processor of the computer system that has been previously started associating with the security descriptor an isolation indicator that by itself indicates the process is to run in an isolation mode thereby rendering it as an isolated process the isolated process running with non isolated processes in a common environment calling a kernel routine by the isolated process that is also callable by a process that is not running in isolation mode attempting to write to an object of a disk or a registry by the kernel routine called by the isolated process determining by a filter driver running in kernel mode whether the kernel routine is requesting the write on behalf of the isolated process or a non isolated process if the write is requested on behalf of the isolated process then performing the write in a pseudo storage area and if the write is requested on behalf of the non isolated process then performing the write in an actual storage area in which the disk registry or other actual system or process data resides wherein if the requested write is a first object write then copying the object from the actual storage area to the pseudo storage area utilizing a communication element that allows inter process communication between the process and an other process within a first process group but blocks inter process communication between the process and a further process that is not within the first process group.

Finally a method is provided for protecting a computer system comprising attaching a security descriptor to a process running on a processor of the computer system that has been previously started associating with the security descriptor an isolation indicator that by itself indicates the process is to run in an isolation mode thereby rendering it as an isolated process the isolated process running with non isolated processes in a common environment calling a kernel routine by the isolated process that is also callable by a process that is not running in isolation mode attempting to write to an object of a disk or a registry by the kernel routine called by the isolated process determining by a filter driver running in kernel mode whether the kernel routine is requesting the write on behalf of the isolated process or a non isolated process if the write is requested on behalf of the isolated process then performing the write in a pseudo storage area and if the write is requested on behalf of the non isolated process then performing the write in an actual storage area in which the disk registry or other actual system or process data resides wherein if the requested write is a first object write then copying the object from the actual storage area to the pseudo storage area providing a user mode library for patching import and export tables for isolated process groups to control isolated processes from performing calls into system application program interface routines that could allow the isolated processes from modifying controlling or terminating a non isolated process or a process from a different process group.

A general principle is that the present system protects against malware that attempts to destroy information steal security information or even simply tries to crash or overload the system by reducing and controlling the footprint of an isolated process to the operating system primarily by denying access filtering and restricting the target of output. Thus the present system is preferably active at any place the software interfaces to the operating system.

The security system and method are implemented by software algorithms that run on a computer system to be protected. Various embodiments of the invention are described below.

The computer has an actual file system that is provided on a non volatile storage device such as a hard drive or non volatile writable memory. The file system also includes the necessary hardware and software as part of the operating system code for providing organized read and write access of information typically organized into files and directories. In the Microsoft Windows operating system an actual Windows Registry is provided that is used to store important system information.

On operating systems that do not use a form of registry the discussion below related to the registry can be ignored although any equivalent functionality implemented through the file system would still be applicable.

As described in more detail below the security system code distinguishes between processes that are to run normally and those that are to run in an isolated mode isolated processes . Isolated processes will generally interact with a pseudo or shadow file system and a pseudo windows registry unless read only access is used by the process . The a pseudo file system and a pseudo windows registry are preferably implemented on the non volatile storage medium of the computer but could also be implemented in volatile memory as well although with many large file accesses the amount of available volatile memory may be limiting. The data created with an isolated process may be stored in a saved pseudo file system and saved pseudo windows registry so that it can be further utilized by a later instance of the isolated process .

When the security software is first installed on a computer a list of executable file names and or processes that are to be isolated are loaded into the Windows Registry or possibly in a system file . This list identifies applications and process names that may result in compromised data and executable files to be loaded onto the computer . An example would be web browser software such as Microsoft s Internet Explorer or Mozilla s Firefox. The list can be easily updated manually or automatically so that the code can modify the processes that it treats as isolated processes. This list could vary depending on the username or a user group attribute. For example a user with administrative privileges on the computer might be able to run the browser with write access to the actual file system whereas a non privileged user may be restricted as described herein. Or the isolation could be provided for all process of a particular user or user group attribute. The system software in the form of a driver then subsequently reads this list when the driver is loaded.

An isolated process is allowed read only access to the actual file system and registry however any changes that it attempts to make are redirected to the pseudo file system and registry .

When a user initiates a browser instance the operating system creates a new instance of a browser process iexplore.exe . The software has a process creation callback so whenever a new process gets created on the system the software callback gets called indicating that a new process is being created the process ID and the fact that it is a new process that s getting created.

The software checks to see if this process iexplore.exe is on the isolated process list . If it s not the system continues on with the normal process creation routines . If it is then the system sets a flag identifying this instance of the process as an isolated process . A data structure is created that indicates this as an isolated process

Information about the location of the pseudo file system and registry is obtained at this point. The root location of these items are known ahead of time but a unique index value is assigned to the process group and that is the unique starting point for the pseudo file system and directory. By way of example refer to discussed in more detail below process group may have a pseudo file system located at c User PeteWectorShield Group1 whereas process group may have a pseudo file system starting at c User Pete VectorShield Group2. In this way multiple groups can be running in parallel and not interfere with each other.

In addition if the process being created is a sub process of an isolated process the sub process is also flagged as an isolated process since a sub process of an isolated process should be subject to the same write restrictions of the isolated process. The detection of processes within an isolated process group may use the Microsoft s Access Control Entry ACE inheritance model see MSDN Microsoft Developer s Network Library Access Control Model and associated subchapters build date Sep. 30 2010 .

For system processes which perform work on behalf of an isolated process a special discretionary access control list DACL may be attached to a token of the isolated process. The DACL is an access control list that is controlled by the owner of an object and that specifies the access particular users or groups can have to the object. The isolated object s token can be passed through the system and provides an identifiable flag to the filter driver that a particular server request should in fact be isolated.

A handle duplication and inheritance subsystem within the system may be filtered by registering with system APIs. Isolated processes can be organized into process groups. Referring to isolated process group comprises a number of processes process . and process .. Furthermore a subprocess .. may be created by process . . Similarly isolated process group comprises a number of processes process . and process .. Processes and in process group can read and write from a pseudo file system and pseudo Windows registry and processes and in process group can read and write from a pseudo file system and pseudo Windows registry .

Handle inheritance and duplication within an isolated process group e.g. within group is supported and allowed. In a process . creating a subprocess .. can call an API of the operating system that permits the inheritance and duplication of the handle . The API is aware that the process . is in the same process group as the subprocess .. . Although the within group handle inheritance and duplication are described above with regard to a process and subprocess it works in a similar manner between processes at the same level e.g. proc. . and proc . .

In contrast handle inheritance and duplication across an isolated process group boundary e.g. between group and group is adjusted via the API to remove any access which could allow an isolated process to modify control or terminate a non isolated processes memory or functionality.

The handle inheritance and duplication filtering is performed on a per process and per thread basis to eliminate any possibility that an isolated process group can modify control or terminate a process or thread which is not isolated. Handle inheritance and duplication from non isolated process groups modifying an isolated process groups process or thread is also restricted in the same manner described above.

Registry isolation may be similarly implemented through a registry filter driver. This filter like the file system filter may use a token based technique to recognize system processes which are operating on behalf of an isolated process. All modifications made by an isolated process are redirected so that no changes to the real registry can be made from within an isolated process.

In one embodiment a user may have decided to preserve the pseudo data from a previous session. In this case if a flag is set the software then loads the preserved pseudo data into the pseudo file system and registry . Then normal process creation is carried out . Alternately a similar operation could take place not with data preserved from a previous session but from pre canned data associated with a particular process to be isolated. For example it may be desirable to have a browser with pre canned PDF viewing software already present so that the user does not have to download it even the first time. It is preferable that each process group has its own pseudo file system and registry storage so that they cannot overlap.

The handling of the request for an isolated process depends on whether the request is a read request or a write request. The software determines the type of request . If it is a write request then the software determines if this is the first write request for this particular data . If it is then the data associated with the write request is copied from the actual file system or registry into the pseudo file system or registry respectively.

For file system requests in one embodiment the entire file is copied and all subsequent read write operations performed on the file are done in the pseudo file system file. However for large files this may significantly slow down the initial write request. Therefore in an embodiment only some portion of the file is copied over based on some predefined size. For example the first write request on a file may trigger the copying of a 10 MB data chunk of the file to the pseudo file system . Any subsequent read write operations within that 10 MB chunk of the file take place from to the pseudo file system whereas subsequent read operations outside of that 10 MB chunk take place from the actual file system .

The data is subsequently written to either the pseudo file system or the pseudo registry . In one embodiment the data is encrypted before it is written to the pseudo file system or pseudo Windows Registry. This can prevent e.g. malicious code that is downloaded with the browser from being accessed by non isolated processes. It is also possible to make the encryption as a selectable option. This provides an ability to control an isolated application s access to the real computer i.e. encrypting the pseudo machine prevents it from seeing the real machine and vice versa thereby thwarting viruses that might compromise users passwords contact list and other private information. This design defeats a fundamental access mechanism a criminal hacker would try to use to gain access to a user s system. In addition to isolating the process and the workspace it also effectively hides the computer from assault.

For an isolated process read request in one embodiment a check is performed to see if the isolated process is allowed the type of read access requested. For example a browser application may attempt to access a user s e mail contacts list. However the contact list may be indicated as a type of read access that is not permitted by isolated processes. In such a situation access to the desired data is denied and the read write process ends . An error message could be generated and returned to the calling process. The list of information that a particular isolated process may access or conversely not access can also be provided in the registry or in a file on the file system and provided when the software is installed. This list could vary depending on a particular username or user group attribute.

The list may include list of directories a list of wildcard delimited filenames that disk drives etc. to which access should be denied or allowed . The list could include system files a My Documents folder the Outlook address book etc. In this manner unauthorized reads can be prevented.

If read access is allowed for the isolated process then a determination is made as to whether the data has actually been copied to the pseudo area via either a previous write operation or a preloading of preserved data . If it has not then read access is permitted on the actual file system and registry . If it has then read access is only permitted on the pseudo file system and registry. If the data was encrypted when written it is then decrypted prior to being provided to the calling isolated process .

Process termination is illustrated in . In this embodiment when a process terminates the flag is checked to determine if it is an isolated process . If it is not then the system continues with normal process termination . If it is a check is made to determine if a data preservation flag is set . Alternately a user could be prompted to indicate whether the pseudo data should be preserved and made available for a subsequent instance of the application. If pseudo data preservation is indicated then the pseudo data is preserved in the preserved pseudo data storage area .

Subsequently regardless of whether a choice was made to preserve the pseudo data or not the current pseudo data associated with the terminating process and any associated sub processes is deleted and normal process termination takes place.

It is also possible for the software to determine if data has been compromised and then delete the preserved pseudo data or not allow preserving the pseudo data . Or the user could be provided with an indication that the data has been compromised and ask if the user would still like to preserve or delete the preserved data. It may be possible to assess the risk threat detected by compromised data and take differing actions. For example relatively benign adware downloaded on the system might not flag a deletion of preserved pseudo data whereas a disk destroying virus may require the deletion of preserved pseudo data although such a virus poses no threat to non isolated parts of the system it could still harm data acquired within a session of a user executing isolated processes.

In one embodiment the user may be asked whether to merge the pseudo data with the actual data although this option largely defeats its intended purpose since a user is unlikely to know whether the pseudo data has been compromised or not.

In an embodiment it is also possible to attempt to maintain integrity even within an isolated process or group of processes by utilizing encryption techniques at a low level e.g. socket communications event processing etc. so that e.g. a keystroke reading malware program downloaded via a web browser can not obtain e.g. password information for a user accessing a bank account page. Preferably this would be implemented via a kernel mode filter since this would be extremely difficult to thwart however this could also be handled in user mode but a user mode implementation could be easier for a virus or malware to get around.

For Windows XP 32 bit and earlier Microsoft operating systems accesses to the registry and file system can be implemented by the software using a technique called patching the kernel which is an unsupported modification of the central component of Windows. In this scheme for registry access the Windows System Service Descriptor Table SSDT is opened and all of the system application program interfaces APIs that perform registry access are identified. Then for each interface a patch is added that directs it to a routine of the software that performs the requested registry access either to the actual registry or to the pseudo registry. If necessary the original access routine may be subsequently called but this is often not necessary. Thus a user mode process attempting to access a registry key via the kernel mode interface is actually accessing the patched registry access routines of the software. The Windows file I O subsystem APIs can be similarly patched so that file I O requests are redirected to the software routines.

The same mechanism cannot be used on Windows 64 bit platforms due to Microsoft s implementation of Kernel Patch Protection KPP or PatchGuard noted above. On this platform any attempt to perform a patch to the descriptor table in this manner is detected by the OS and causes the system to shut down. On Windows Vista and later versions of Microsoft s OSs Microsoft s Registry Filtering Model RFM is utilized. This is described in relevant part in Jerry Kelley Introduction to Registry Filtering in Vista Part I Vol. 15 Issue 1 May 28 2008 .

The RFM provides a framework by which a driver can be developed that provides callbacks for registry IO that it s interested in. These callbacks are registered with the RFM and are called whenever specific registry IO is processed. All of the RFM interfaces that the driver uses are provided by the Configuration Manager CM . In addition to managing the callbacks the RFM also provides for three types of contexts that a driver can use to associate private information with an object or operation.

The software implemented on 64 bit architectures comprise both a file system and a registry filter driver although this model described below will also work on a 32 bit architecture . Those are actually two different binary modules in kernel mode. One of them is the file system which is a standalone full file system implementation. The other is a filter driver which actually registers with this RFM framework. Thus the software registers various callback routines.

As registry access occurs from different processes in user mode a respective callback is notified. For example when a registry key is being opened the callback routine is notified that an open on a specific key is happening and receives its name type of access that the user wants etc. In isolated processes such notifications are captured and then redirect off to a virtual registry instead of allowing them to access the real registry.

File system isolation may be achieved through a file system filter driver which ensures that nothing in the underlying name space is modified by an isolated process. This may be implemented using Microsoft s Minifilter Driver architecture see MSDN File System Minifilter Drivers and subchapters build date Sep. 28 2010 which is a model for implementing file system filters. The presently implemented filter driver implements both the filtering for the file system and for the registry filtering.

Isolated processes go through a re parsing in which filenames get reconstructed. By way of example if the user in an isolated process wishes to access C foo.txt when the file was created the file system also created a named device object see MSDN Microsoft Developer s Network Library Named Device Objects and associated subchapters build date Sep. 21 2010 . The name is reconstructed and then sent to that file system instance. A special status code is returned back to the system I O manager. The I O manager sees this status code and recognizes that a caller to redirect this open access so it re parses the name and it sends it over to the file system routines of the software . Thus the software leverages the Windows redirection functions.

The rebuilding of the filename and returning the special status code indicates that the I O manager should re parse the file name and send the request to a location with a new name. In NTFS directory and file symbolic links can be set. By way of example if an isolated process attempted to write to c dir this could be set as a re parse point that actually points to e isolated dir for the actual write even though the process believes it is writing to c dir. So at the heart of the I O manager the redirection occurs and the process is unaware that it has been redirected.

The isolation of a process preferably include named pipes mail slots remote procedure call RPC local procedure call LPC and sockets. All methods for modifying the environment can be handled to ensure complete isolation of the given process. In this implementation channel access is monitored for an isolated process and appropriate action is taken depending on the type of access request is being made the port on which it is to be performed etc. Named pipes may be filtered by using a legacy based filter driver attaching to the Named Pipe File System or NPFS. Named pipes are used for inter process communication and this avenue for an isolated process group to leak information outside of the isolated process group is closed in an embodiment of the invention. The named pipe names are mangled such that inter process communication within an isolated process group is supported but when named pipes are used for communication outside of the isolated process group they are blocked.

The pipe names are always mangled for isolated processes in the same manner. In contrast pipe names for non isolated processes are not mangled. Thus for processes within a process group their pipe names are mangled in the same way and thus they are oblivious to or not aware of the name mangling. But a process outside of the process group does not know about the name mangling and thus will not be able to access a named pipe opened by an isolated process. The same holds true for an isolated process attempting to open a named pipe created by a non isolated process the name opened by the isolated process would be mangled and thus would fail to open the non isolated process named pipe.

Network sockets may be filtered within the kernel mode framework for isolated process groups to control how the isolated process group processes access networks resources. This is accomplished by using the kernel mode module for filtering socket creation and access. The determination of whether to allow connections to external network resources is mandated by policies setup during initial configuration of the system software.

Other network resources such as shared network storage network printers and other resources shareable over a network connection should be denied access from within an isolated process group. File system access for system libraries may be controlled such that for an isolated process group any request to modify delete or overwrite a system library is denied. File system access control for system libraries may be implemented through a file system filter driver.

The Local Procedure Call or LPC interface may be controlled for isolated process groups. This control can be implemented through a filtering mechanism which utilizes the previously described security descriptor which is attached to isolated processes within an isolated process group. LPC requests for isolated process groups made to non isolated processes are controlled or denied based upon the type of request made. A typical example which uses LPC communication is installer packages or any module which would need to be executed in a controlled environment. In this case an LPC call is made to a system service to run a given application located at a specific location. In an embodiment of the invention we can filter these LPC calls and modify the location of the executable which is to be executed.

The Remote Procedure Call or RPC interface may be controlled for isolated process groups. This control is implemented through a file system filter driver and any RPC request from an isolated process group is denied.

All requests which are isolated for a given process should be redirected to a name space registry location or necessary pseudo area for persistent storage. This storage can then later be used to launch the isolated process so that it can resume within the environment that it had previously modified. The user can be provided with the option at the time an isolated process ends to destroy all history of the process allowing for a clean initialization the next time the process is launched.

One major challenge in the implementation was recognizing operations that are requested by isolated processes yet are actually carried out inside of a server process. For example certain file system accesses are sent from the original process through an LPC channel and the file system APIs are actually called by a server process such as csrss Isass svchost etc.

When the file system filter sees these requests it looks at the calling process and sees the server not the client. However the server is handling a combination of requests from both isolated and non isolated processes and thus cannot be marked as isolated a priori.

A process based recognition strategy is not enough to deal with these client server cases. In order to ensure that a server process is not performing operations that are illegal for the client process the client process passes its token along with the request. The server process then enters an impersonation mode where it takes on the identity and privileges of the client and is thus guaranteed to be limited to whatever the client itself would normally be allowed to access.

This token impersonation scheme can be utilized by overloading some of the information within an isolated client process token. Every token has a DACL that enumerates pairings of access type and identity to allow or disallow various rights to certain users. A special access control entry ACE can be added to this DACL which can then be recognized by the filter when it is handling requests coming from server processes.

The custom ACE that is built may be a concatenation of a special and specific globally unique identifier GUID in order to avoid collisions with real user identities and the process group that this particular application is a member of. For each request coming in to the filter if it is not possible to determine the isolation status through normal process tracking then the DACL can be scanned for this special ACE. If a matching ACE is found the isolation process group is extracted and the request is treated as isolated. If no matching ACE is found then the request is treated as non isolated. An additional benefit of using this strategy is that the process token is automatically inherited by new child processes. Therefore the existing semantics of having all children of an isolated process remain isolated still hold.

A user mode DLL may be used for patching the import and export tables for isolated process groups. This user mode patching may be performed for 32 and 64 bit isolated processes. Note that this is different from attempting to patch kernel mode components to override specific functionality which is prohibited in the Windows 64 bit operating systems. User mode binaries can be patched without problems on 32 and 64 bit systems and patching user mode binaries is not restricted in the same manner as patching kernel mode components and can be performed without problems.

The user mode patching allows for control of isolated processes from performing calls into system APIs which could allow the isolated process to modify control or terminate a non isolated process.

The APIs which are patched in the above user mode DLL include any which would allow the isolated process or any process within the isolated process group from opening a non isolated process and accessing memory handles message queues internal queues window based frameworks or any additional access point which could allow the isolated process to modify control or terminate the non isolated process.

The above mechanism may also be used to control access for isolated process groups requesting COM requests to from non isolated processes.

The system is preferably implemented as a full fledged file system such as NTFS or FAT not an unnamed file system hidden in Kernel Mode. Such a file system can thus provide the functionality described below.

The system provides isolation from and may be different in structure access methods and characteristics from NTFS and FAT. Preferably the only commonality to NTFS and FAT is that they are file systems. NTFS and FAT talk directly to the disk whereas the present file system should be a file system that talks to NTFS and FAT instead of talking to the disk. NTFS and FAT have a goal of data integrity whereas the present goal is process isolation. Thus the file system driver FSD is implemented to provide isolation for underlying files.

Thus a file aspect is that normal utilities can work on a pseudo directory looking for signatures. A registry aspect provides that if one is not running inside of an isolated process the keys can be seen but they don t make any sense nor will they be in the right place to do something wrong or corrupt.

A process group can be created which is a group of processes like the parent process and child processes that all have a consistent view of the system and its processes. Outside of this group changes cannot be set that are made by the isolated processes. A process can be added to a process group such as a scanner and it could scan and see the changes. This would permit a clean pseudo file directory which could then be merged back into the registry. Thus it is possible to run everything isolated so that there is consistency in registry changes if committing the changes to the registry.

The registry filter is a Kernel model component that provides the registry isolation. The registry filter assures that registry changes are written to the pseudo registry area and not the actual registry area and also redirects calls to the pseudo area so that system operates as though the changes had in fact been made to the registry. When a process launches the filter intercepts references to the Kernel and redirects to the pseudo area for both write and read. Advantageously this system has true redirection if a key is being read it is going to the real registry. Thus the present implementation sits above the file system and works on a registry key and value and operates on a per file system basis having a fine level of detail permitting specific knowledge of what is happening to every single file.

Printing both local and network may be denied from protected sessions to eliminate possibilities of corrupting the system through malware attacks on this vector. The system can thus protect against a possible virus or malware introduced into e.g. the print spooler or other printer file driver.

In an embodiment printing might be allowed to PDF devices i.e. printed to PDF files which can possibly be stored outside of the virtual system and these files can then be later printed . This protection can be implemented at install time or a run time through configuration settings.

Other local resources i.e. within the isolated process can be protected as well and this can be specified at the folder level file level file type level etc. Preferably any of these restrictions can be set via configuration files at install time or at initialization time for the application.

The system can specify for a protected session that certain areas or certain resources are hidden from processes executing within the protected session and specified local and network resources can be denied access from protected sessions. For example when a process within a protected session requests to read something even from within a protected session a check is initially performed to determine if it is actually viewable and if the process actually has access to it even to the point of knowing whether the requested element exists . This is done so that malware even though it cannot corrupt information outside of the protected session cannot necessarily gain access to information such as a user s address book etc.

Local i.e. within the isolated process and within the virtual space resources such as folders and file types can be specified to be hidden protected. Protected session applications are denied access e.g. the system blocks attempts to perform reads writes . For example one can specify that the directory My Documents is a protected area and thus malware in a protected session would not be able to see or access information within the My Documents or other specified directory.

This could also be done at a specific file level extension level and also by the use of wildcarding at any level e.g. deny access to an address book by adding a .adr template to a hidden resources list .

Although discussed at a file level above this form of access restriction could take place for any type of I O or resource local disk network disk network printer other hardware device etc. and at any communication level hardware accesses to high level applications communications .

The list of these hidden resources can be specified at installation time via setup configuration files or can be specified in loadable configuration files such as application initialization files so that the hiding of resources can take place dynamically. It can also be done in a group policy file where such installations and or configurations are taking place on many machines such as within a corporate setting. The installation program could also contain intelligence such that it could determine e.g. which email client is being used and then restrict access based on the known address book format extension for that particular client. This intelligence could be extended to any application or file type. It can indicate which processes within the protected session have what type of access to which resources.

By restricting these types of accesses within isolated processes the system can prevent the spread of a virus within e.g. corporate computers that might all share network drives and other networked resources and thus prevent bringing down a company or a corporation s infrastructure.

The system can in an embodiment automatically make a determination of a protected state when other instances of the same browser or other applications are currently running. This determination can be a sole exclusive determination. The service can automatically assign a status as protected unprotected if a current instance of the same browser is already running that is protected unprotected . This is handled in user mode. For example if a protected Internet Explorer IE session is running and the user starts another IE browser session the system can presume that the user wants this to be protected as well. Conversely if a non protected IE session is running and the user starts another IE browser session the system can presume that the user does not want this to be protected. One option is to force all sessions or no sessions to be protected this can be configurable .

When the system is running in a corporate setting corporate rules can be established that dictate how computers within the corporation are run. One option is that the system is turned on or off in its entirety i.e. either everything is protected or nothing is protected.

In one embodiment a mechanism can be provided by which a user may recover a previously run session i.e. there is some level of persistence for an isolated process session. For example if a session was run in which the user installed Adobe Acrobat Reader instead of losing this install when the session is ended the session information can be preserved so that a new session in which the browser is launched will retain the Acrobat Reader install. As long as a session has not been compromised or corrupted there is no reason why a previous session cannot be maintained.

The session information can be stored in a file that can be reloadable either by the user s choice the user is prompted to determine if a previously loaded session should be used or by a system configuration option. The session information could be saved off into a shadow folder i.e. an encrypted folder and could include a session index value. When the session closes the session index value can be returned.

In one embodiment only the latest saved session would be used which would result in relatively simple implementation and maintenance. In such a system the user could be prompted to see if they wish to revert to their last session or not.

However it is also possible that multiple sessions could be maintained although this could significantly increase the complexity and usability of the system. Such a system could if a user s preferred session became corrupted or infected and they were unaware of this permit the user to go back to an earlier saved session that did not have the corruption infection. In one embodiment each new protected instance can be an evolution of the one before so that if the current one becomes corrupted one could actually return to the previous session without having previously intentionally saved it. Basically the ability to go back to a slightly earlier version without having to go all the way back to some previously saved state could be beneficial.

Items that could persist from an isolated session could include things such as but not limited to the shadow folder for the file system content that has been saved modified registry information installed software application configuration files and data e.g. bookmarks for web browsers and browser configuration files cookies web site usernames passwords etc. . All of this can be indexed off of a session index value. As an example a user launches an Internet Explorer session. The file system sends a request out to the user mode service to request whether or not that session is going to be isolated or not. A dialog pops up and the user can indicate yes or no . If the user says yes then the user service returns an index value back down to the kernel mode process and then this is within the shadow folder for both the file system and registry as sort of a root directory that is created. Everything for the session can then be created underneath this root directory with that index value. When the session closes all of this content is normally deleted if it is not persisted . But when persisted when the user opens a protected browser session and indicates a desire to return to the session the content underneath this root directory is simply used again. This information is all encrypted so it is not available outside of the protected session.

For systems in a public location and or used by multiple users it may not be desirable to allow this persistence whereas a computer for a particular employee in a corporate setting a liberal use of persistence might be allowed. Again this can be dictated by configuration files either at installation time or initialization run time.

In another embodiment it is possible to provide a port without encryption i.e. one that is not a part of the shadow disk that serves as a port outside of the virtual world the copy on write discussed above in order to save this and or any other information in clear plain text and without encryption such that it is accessible outside of the virtual world and even after the isolated process has ended. However this also opens up the possibility of a security breach it opens up a hole where product specific attacks could occur to circumvent the product. Therefore the benefits of allowing this must be weighed against the risk. Some form of data file filtering for this port could also be utilized and specified via configuration files as well e.g. only text files or scrubbed PDF files can be sent this would minimize the risk of transmitting a virus . Office type files can be scrubbed for harmful macros and other sorts of filtering scrubbing could be utilized.

In an embodiment a further application may be provided in which periodically e.g. every couple of seconds a check is made to see if the user mode service including the user interface process is running the user mode service can be killed even though the system is protected by the kernel mode code and if it is not it is restarted. When the user interface restarts it spins through all of the processes to determine which ones are running protected isolated on the system by asking the kernel code about each of them. From this it can rebuild the user mode service and reinitialize the user interface. As discussed above an isolated process remains an isolated process throughout its life and any sub processes it creates are also isolated processes.

The system or systems described herein may be implemented on any form of computer or computers and the components may be implemented as dedicated applications or in client server architectures including a web based architecture and can include functional programs codes and code segments. Any of the computers may comprise a processor a memory for storing program data and executing it a permanent storage such as a disk drive a communications port for handling communications with external devices and user interface devices including a display keyboard mouse etc. When software modules are involved these software modules may be stored as program instructions or computer readable codes executable on the processor on a computer readable media such as read only memory ROM random access memory RAM CD ROMs magnetic tapes floppy disks and optical data storage devices. The computer readable recording medium can also be distributed over network coupled computer systems so that the computer readable code is stored and executed in a distributed fashion. This media can be read by the computer stored in the memory and executed by the processor.

All references including publications patent applications and patents cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.

For the purposes of promoting an understanding of the principles of the invention reference has been made to the preferred embodiments illustrated in the drawings and specific language has been used to describe these embodiments. However no limitation of the scope of the invention is intended by this specific language and the invention should be construed to encompass all embodiments that would normally occur to one of ordinary skill in the art.

The present invention may be described in terms of functional block components and various processing steps. Such functional blocks may be realized by any number of hardware and or software components configured to perform the specified functions. For example the present invention may employ various integrated circuit components e.g. memory elements processing elements logic elements look up tables and the like which may carry out a variety of functions under the control of one or more microprocessors or other control devices. Similarly where the elements of the present invention are implemented using software programming or software elements the invention may be implemented with any programming or scripting language such as C C Java assembler or the like with the various algorithms being implemented with any combination of data structures objects processes routines or other programming elements. Furthermore the present invention could employ any number of conventional techniques for electronics configuration signal processing and or control data processing and the like. The words mechanism and element are used broadly and are not limited to mechanical or physical embodiments but can include software routines in conjunction with processors etc.

The particular implementations shown and described herein are illustrative examples of the invention and are not intended to otherwise limit the scope of the invention in any way. For the sake of brevity conventional electronics control systems software development and other functional aspects of the systems and components of the individual operating components of the systems may not be described in detail. Furthermore the connecting lines or connectors shown in the various figures presented are intended to represent exemplary functional relationships and or physical or logical couplings between the various elements. It should be noted that many alternative or additional functional relationships physical connections or logical connections may be present in a practical device. Moreover no item or component is essential to the practice of the invention unless the element is specifically described as essential or critical .

The use of the terms a and an and the and similar referents in the context of describing the invention especially in the context of the following claims are to be construed to cover both the singular and the plural. Furthermore recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range unless otherwise indicated herein and each separate value is incorporated into the specification as if it were individually recited herein. Finally the steps of all methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples or exemplary language e.g. such as provided herein is intended merely to better illuminate the invention and does not pose a limitation on the scope of the invention unless otherwise claimed.

Numerous modifications and adaptations will be readily apparent to those skilled in this art without departing from the spirit and scope of the present invention.

