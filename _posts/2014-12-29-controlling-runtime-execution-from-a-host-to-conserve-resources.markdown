---

title: Controlling runtime execution from a host to conserve resources
abstract: A runtime management system is described herein that allows a hosting layer to dynamically control an underlying runtime to selectively turn on and off various subsystems of the runtime to save power and extend battery life of devices on which the system operates. The hosting layer has information about usage of the runtime that is not available within the runtime, and can do a more effective job of disabling parts of the runtime that will not be needed without negatively affecting application performance or device responsiveness. The runtime management system includes a protocol of communication between arbitrary hosts and underlying platforms to expose a set of options to allow the host to selectively turn parts of a runtime on and off depending on varying environmental pressures. Thus, the runtime management system provides more effective use of potentially scarce power resources available on mobile platforms.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09448840&OS=09448840&RS=09448840
owner: Microsoft Technology Licensing, LLC
number: 09448840
owner_city: Redmond
owner_country: US
publication_date: 20141229
---
This application is a continuation of and claims priority to U.S. application Ser. No. 12 957 413 filed on Dec. 1 2010 titled CONTROLLING RUNTIME EXECUTION FROM A HOST TO CONSERVE RESOURCES at least some of which may be incorporated herein.

Computer users are more and more frequently using mobile devices to perform tasks once thought to require the power of desktop computers. Mobile devices today such as smartphones are more powerful than desktop computers of just 10 years ago and are advancing at a pace faster than their desktop counterparts did. Current smartphones allow running applications browsing the web and editing documents in addition to the more traditional smartphone function of making calls. Many mobile devices include a graphics processing unit GPU for offloading graphics intensive processes from the central processing unit CPU to more specialized hardware. Mobile devices have ever increasing display resolutions that involve pushing more and more pixels to the screen to display content.

With the rise in computing power of mobile devices an important consideration is battery life. Although mobile devices are powerful leveraging the full computational power of the device all the time would lead to a battery that did not last very long. Most mobile device users expect their devices to last at least a day on a standard charge so that the user can use the device as needed throughout the day and charge the device at night. One factor that influences mobile battery life is the execution of underlying subsystems provided by the mobile device for applications to leverage. Subsystems can include application platforms such as a Java Virtual Machine JVM MICROSOFT SILVERLIGHT Mobile the MICROSOFT .NET Compact Runtime and so forth.

Prior runtimes have attempted to automate the task of tuning the runtime to allow the runtime to shut itself down or turn off parts of the runtime to conserve power and extend battery life. Unfortunately the runtime often has very little knowledge of how it will be used by an application that invokes it. If the runtime chooses to shut down a component or service that the application will soon attempt to use then the runtime may introduce undesirable application delays and cause the mobile device to feel sluggish to the user as the runtime wakes up to handle the user s requests.

A runtime management system is described herein that allows a hosting layer to dynamically control an underlying runtime to selectively turn on and off various subsystems of the runtime to save power and extend battery life of devices on which the system operates. The hosting layer has information about usage of the runtime that is not available within the runtime and can do a more effective job of disabling parts of the runtime that will not be needed without negatively affecting application performance or device responsiveness. The runtime management system includes a protocol of communication between arbitrary hosts and underlying platforms to expose a set of options to allow the host to selectively turn parts of a runtime on and off depending on varying environmental pressures. Thus the runtime management system provides more effective use of potentially scarce power resources available on mobile platforms.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A runtime management system is described herein that allows a hosting layer to dynamically control an underlying runtime to selectively turn on and off various subsystems of the runtime to save power and extend battery life of devices on which the system operates. The hosting layer has information about usage of the runtime that is not available within the runtime and can do a more effective job of disabling parts of the runtime that will not be needed without negatively affecting application performance or device responsiveness. The runtime management system includes a protocol of communication between arbitrary hosts and underlying platforms to expose a set of options to allow the host to selectively turn parts of a runtime on and off depending on varying environmental pressures. For example the system can provide a Component Object Model COM or other application programming interface API through which a host can instruct the runtime to turn parts of the runtime on or off. The protocol can be scaled to arbitrary platforms to achieve a high degree of flexibility from the host without having to fragment the runtime. Thus the runtime management system provides more effective use of potentially scarce power resources available on mobile platforms.

As one example MICROSOFT SILVERLIGHT is a runtime that allows itself to be hosted in a variety of different environments. MICROSOFT SILVERLIGHT began as a browser plugin but is quickly spreading to other ecosystems and includes standalone environments for several hardware platforms. MICROSOFT SILVERLIGHT now allows arbitrary hosts to be able to allow the runtime to execute within their confines subject to a set of rules that the host gets to configure. The runtime provides a set of COM contracts with which the host can control the plugin. The runtime management system extends these contracts to include a pause and resume construct with configurable parameters that the host can set unset to make intelligent choices about how to utilize the runtime efficiently. The implementation itself is not tied to COM and is hence very extensible.

In some embodiments the runtime provides multiple levels of pausing to reduce resource usage rendering only and pausing of rendering and execution. Pausing rendering keeps the whole subsystem executing but simply turns off rendering. One usage pattern for this functionality is to allow playing of media but conserve battery by not rendering when the media application is obscured by another application. Since the user cannot see the media anyway rendering the media just consumes resources unnecessarily. When everything is paused i.e. rendering and execution the system produces a state of suspension for the application at large. This type of pausing may or may not block common language runtime CLR threads. This level of pausing can be used to enable background processing when the resources on a device are low. Following is an example interface contract for the behavior described herein between a host and a runtime 

This model is flexible avoids fragmentation of the runtime without causing undue pain in the inner layers and does not involve hosts understanding the internal operation of the runtime. The portability and flexibility of this solution differentiates the runtime management system from previous solutions.

The state store manages state information related to pausing and resuming tasks in progress within a runtime running on a computing device. The state store may include one or more in memory data structures files databases cloud based storage services or other storage facilities for persisting data. In some embodiments the runtime manages a list of animations and timelines for displaying the animations that constitute part of a rendering pipeline. Upon pausing rendering the state store may include information about the list of animations and their current state so that upon resuming the system can reinstate the list and continue the rendering pipeline at an appropriate point in time. The runtime may also manage one or more dispatch items that represent tasks being performed by the runtime. Upon pausing execution the system may persist the list of dispatch items to the state store so that the system can resume processing the list later.

The host interface component provides a programmatic interface through which application hosts manage the execution state of the runtime to turn on and off parts of the runtime. The host interface component may provide one or more APIs that are available to a variety of programming languages and application types. Those of ordinary skill in the art will recognize several models for exposing APIs between a runtime and a host application. The runtime management system exposes APIs that allow pausing rendering pausing execution and resuming either or both. In some embodiments the runtime may provide additional levels of granularity of the subsystems that a host can pause in addition to those listed as examples herein.

The pause rendering component performs a break in the rendering pipeline of the runtime to turn off the processing of the runtime s rendering subsystem. Rendering is often one of the most resource intensive tasks of a runtime that provides user interface elements and the ability to pause rendering can save substantial resources on resource limited devices. The pause rendering component removes any animations in progress from a tree of animation timelines managed by the runtime and places these animations on a resume list managed by the state store . The pause rendering component may also stop a compositor that is currently rendering items. For content items that include audio and video the component may pause the video but allow the audio to continue. The component removes video only items from the rendering pipeline.

In some embodiments a pause of rendering is a less invasive operation that can be more easily resumed than pausing execution. The system may be balanced to perform less tear down during a pause of rendering than a pause of execution. For example the runtime may manage graphical objects such as MICROSOFT DIRECTX or other surfaces or devices that the pause rendering component caches and keeps in place for future use after rendering resumes. Setting up such devices and the compositor previously mentioned may consume more resources than is desirable when pausing rendering. In some embodiments the system provides configuration options that allow the application host to tune such decisions to properly balance tradeoffs in resource consumption expected by the application host.

The pause execution component performs a break in the execution of runtime processes to turn off the runtime s core processing. The component may walk a tree of operations in progress within the runtime handling each item as appropriate to shut it down. For example the component may through away any cache composition surfaces tear down MICROSOFT DIRECTX or other graphical devices destroy the compositor object stop media destroy in memory items related to stopped media and so forth. A break in execution is similar to a near shutdown state with the intention that the runtime consume substantially fewer resources than when executing. In a mobile device the pause execution state may be invoked by a host when the device is locked e.g. closing the device to place in the user s pocket or displaying a lock screen when no applications are running and so forth.

In some embodiments the pause execution component notifies applications or other processes that a pause in execution has been requested. The runtime may allow applications a limited amount of time to store state information or complete tasks before pausing the application s execution. This can be helpful to allow the application to end in a known good state and gracefully complete or pause tasks in progress.

The resume component resumes execution of the runtime after a break in rendering or execution. The component first determines the type of pause previously requested and then performs appropriate steps to bring the runtime back to a running state. For example the resume component may access the state store to identify items that were in progress before the runtime was paused and then take actions to reinstate processing of those items. For rendering operations the component copies animations back onto a list of active animations in the rendering pipeline. If the graphical objects and or compositor were destroyed then resuming recreates these objects so that they can be used to continue rendering where it left off. Resuming starts the rendering pipeline and any execution that was previously paused.

Pausing and resuming may happen frequently in mobile devices such as during application switching when a user brings up a lock screen when a pop up dialog is displayed e.g. due to an arriving phone call when an application jumps to a browser application and so forth. Pausing allows the prior application to be placed in a dormant state where fewer resources are consumed while resuming allows the application to return to a running state quickly.

The OS interface component provides an interface between the runtime and an underlying operating system OS that manages hardware resources of the computing device. The runtime uses the OS interface component to access state and other information from the operating system and to carry out operations such as persisting state to the state store for pausing and resuming. The OS interface component may include APIs for managing processes threads storage devices application state and other information useful to the runtime for performing runtime tasks or changing runtime state.

The computing device on which the runtime management system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives or other non volatile storage media . The memory and storage devices are computer readable storage media that may be encoded with computer executable instructions e.g. software that implement or enable the system. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communication link. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the system may be implemented in various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics digital cameras network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices set top boxes systems on a chip SOCs and so on. The computer systems may be cell phones personal digital assistants smart phones personal computers programmable consumer electronics digital cameras and so on.

The system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Continuing in block the system identifies one or more animations scheduled to render in a rendering pipeline. For example the animations may represent window movements button presses web page animations multimedia content and so forth. The rendering pipeline maintains a schedule of animations to be performed in accordance with a clock. Continuing in block the system removes the identified animations from the rendering pipeline to pause rendering of the animations. Alternatively the system may mark the animations as paused and leave them in the rendering pipeline queue so that the animations can be resumed by changing their state. Continuing in block the system adds the paused animations to a resume list for subsequently resuming the animations. The resume list allows the runtime to come out of the paused state upon request by the application as described further with reference to .

Continuing in block the system stops a rendering compositor from rendering software graphical objects to one or more hardware graphics devices. The compositor prepares one or more rendering items for display to a screen or other display device and stopping the compositor stops the preparation of rendering items for display. Continuing in block the system pauses video only items. Video only items are content items that do not include an audio portion. For content items that contain audio the system will continue to play the audio during rendering and these items will not be paused completely so that the audio can still play as scheduled. For video only items however the system can pause them to stop rendering of these items and reduce the resources consumed by the runtime.

Continuing in block the system stores resume state information so that the runtime can resume rendering upon request by the application. For example the system may persist resume state information to a file or other data storage facility for later access. After block these steps conclude.

Continuing in block the system notifies an application hosting the runtime that execution of the runtime will pause after a determined period. Based on the notification the application may store state information or conclude tasks that are in progress so that the application can cleanly enter the paused state and resume smoothly upon a subsequent request.

Continuing in block the system identifies tasks scheduled to execute within the runtime. For example the runtime may manage one or more dispatch items rendering tasks input handling tasks and so forth in a queue or tree of items. The system identifies the items schedule to execute by walking the tree or other data structure used by the runtime to schedule tasks. Continuing in block the system pauses the identified tasks to stop execution of tasks within the runtime. For example the system may mark the tasks not ready to execute e.g. paused or remove the tasks from a queue of tasks scheduled to execute. In cases where the runtime passes tasks to the operating system for execution the pausing stops further tasks from being handed to the operating system until the runtime is resumed.

Continuing in block the system destroys one or more graphical objects associated with a rendering subsystem of the runtime. Unlike pausing online rendering where graphics objects that take time to create may be kept so that rendering can resume quickly a pause of execution is a deeper level of pause that may include tearing down objects that will be recreated upon resuming the runtime. Pausing of execution is expected in many cases to last long enough that freeing the extra resources by tearing down these objects is a reasonable performance tradeoff. Continuing in block the system stops any media playback and destroys any objects associated with media items. For example the runtime may be playing a multimedia file or displaying one or more animations and pausing execution terminates the display of such items that will be resumed later.

Continuing in block the system stores resume state information so that the runtime can resume execution upon request by the application. For example the system may persist resume state information to a file or other data storage facility for later access. After block these steps conclude.

Continuing in block the system copies animations from a resume list stored previously to a rendering pipeline of active rendering tasks. For example the system may store animations from a rendering pipeline to a resume list when rendering is paused and then restore the animations back to the rendering pipeline when rendering is resumed. Continuing in block the system restarts any paused execution tasks managed by the runtime. For example when execution is paused the system may mark tasks as paused or remove the items from a dispatch queue and store them on a resume list or other list to be restored upon resuming.

Continuing in decision block if the system determines that a graphics compositor exists then the system jumps to block else the system continues at block . Continuing in block the system creates a graphics compositor for managing rendering tasks in the rendering pipeline. The compositor prepares items in the rendering pipeline for display using graphical hardware of a computing device on which the runtime executes. Some levels of pause may destroy the compositor while others may not so the system determines whether a compositor is available before creating one.

Continuing in block the system starts rendering by instructing the rendering pipeline to resume processing items. For example the system may schedule rendering tasks for execution by a CPU or GPU or the computing device on which the runtime is executing.

Continuing in decision block if the system determines that one or more graphics objects used for rendering exists then the system completes and begins rendering items else the system continues to block . Continuing in block the system creates one or more graphics objects used for rendering. For example the system may create a MICROSOFT DIRECTX device for interacting with graphical hardware such as a screen display buffer and other hardware of the computing device. Different levels of pause may tear down these objects and if they do not exist resuming recreates them. After block these steps conclude.

The power resources of the hardware may be limited and the processing requested by the runtime places demands on the available power of the device. The runtime management system provides a facility through which the application host can control the processing of the runtime to reduce the demands of the runtime on the available power of the device under various conditions determined by the application host . For example the application host may detect that it is being moved to the background so that another application can occupy the foreground. The application host may instruct the runtime to pause execution in such conditions until the application host is restored to the foreground e.g. by the other application exiting or the user choosing to switch applications .

In some embodiments the runtime management system provides a one to one relationship between hosts and runtimes. For example for a computing device that multitasks between multiple applications each application may include a runtime that can be paused and resumed according to the methods described herein. Each application manages the state of its own runtime to determine resources used by that application under various conditions. Alternatively or additionally the system may provide a device wide runtime instance that manages processes across applications so that power consumption can be reduced based by an operating system or other device level actor.

In some embodiments the runtime management system fully kills an application rather than pausing execution. For example the runtime may detect that restarting the application is faster than placing each of the application s ongoing tasks in a paused state. In such cases the system may notify the application that it is terminating and then terminate the application. The application can be run again later by the user or by a system request.

In some embodiments the runtime management system serializes application state to place the application in a hibernation state. Hibernation is commonly used in computer systems to perform an operating system level shutdown but the runtime management system can apply serialization and hibernation at an application level to shut down individual applications. While hibernation similarly reduces resource consumption pausing and resuming is often faster and thus may be selected in cases where fast resuming is useful. Hibernation typically copies an application s memory state to persistent storage and halts execution in a way that the memory state can be subsequently restored and execution continued.

In some embodiments the runtime management system operates on non mobile devices to reduce power consumption. For example the system can be applied to desktop operating systems to pause applications such as upon a user request to minimize a window or switch foreground applications. The system allows any runtime to provide application level controls for managing the runtime power consumption and the execution state of various subsystems within the runtime.

In some embodiments the runtime management system allows applications to identify individual subsystems of the runtime to pause and or resume. A runtime may include many subsystems and the ability to turn on and off individual subsystems allows applications a finer granularity of control over the runtime s consumption of resources. For example a runtime may include a subsystem for managing network communications rendering file access and other tasks some of which are not used by applications at all times and can be paused to save resources.

In some embodiments the runtime management system provides multiple levels of pause that applications can request for a particular runtime subsystem. For example an application may request that normal priority tasks be paused but that high priority tasks continue to execute. This allows the application finer gained control and allows saving some resources while continuing to ensure responsiveness for important tasks.

From the foregoing it will be appreciated that specific embodiments of the runtime management system have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims.

