---

title: System and processor that include an implementation of decoupled pipelines
abstract: A system and apparatus are provided that include an implementation for decoupled pipelines. The apparatus includes a scheduler configured to issue instructions to one or more functional units and a functional unit coupled to a queue having a number of slots for storing instructions. The instructions issued to the functional unit are stored in the queue until the functional unit is available to process the instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471307&OS=09471307&RS=09471307
owner: NVIDIA Corporation
number: 09471307
owner_city: Santa Clara
owner_country: US
publication_date: 20140103
---
The present invention relates to processor architectures and more particularly to processors with multiple pipelines.

Many conventional processors implement pipeline techniques to make the processor more efficient. Pipelining is an architecture that enables a long latency operation to be divided into multiple stages where the output of one stage is the input to the next stage. Pipelining allows a system architect to hide some latency within a system by processing multiple instructions at the same time within the pipeline.

Some pipelines such as pipelines implemented in texture units may receive requests i.e. instructions from multiple independent schedulers within the processor or from a single scheduler executing multiple threads. Compilers may be configured to optimize code in a particular thread by matching the order of instructions with the known throughput of the various pipelines the instructions are configured to be issued to. For example if a processor includes 32 threads executing simultaneously utilizing 32 arithmetic logic units ALUs and 16 double precision units DPUs the compiler may order the instructions of the 32 threads to issue any instructions routed to the DPU every other instruction to allow for 2 cycles for the 16 DPUs to process the single instruction from the 32 threads. However in some processors many pipelines have a variable throughput such that the compiler cannot properly optimize the code at compile time. The throughput of a particular pipeline may be variable if the resource accesses some other resource e.g. a memory access that has a variable latency. Furthermore in multi threaded systems the compiler may not have an accurate scope at compile time of which threads are executed and in what order. Thus the compiler cannot accurately track which resources should be available when a particular instruction is issued. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system and apparatus are provided that include an implementation for decoupled pipelines. The apparatus includes a scheduler configured to issue instructions to one or more functional units and a functional unit coupled to a queue having a number of slots for storing instructions. The instructions issued to the functional unit are stored in the queue until the functional unit is available to process the instructions.

A processor may include one or more functional units associated with a decoupled pipeline. One or more schedulers may be configured to issue instructions to the functional units. Each scheduler may arbitrate among a plurality of threads to determine which instructions are ready to be issued in a given clock cycle. The functional units are coupled to corresponding queues that provide a small amount of temporary storage for instructions issued to the functional unit. The queues may buffer a number e.g. 16 32 etc. of instructions received by the functional unit until the functional unit is available to process another instruction. Thus the schedulers may issue instructions at a rate of one instruction per clock cycle to any functional unit associated with a decoupled pipeline as long as there is at least one empty slot in the queue associated with that functional unit. The architecture described above may prevent the scheduler from stalling issuance of an instruction from a particular thread when the resource required to process that instruction is not available. This enables the scheduler to issue instructions that are ordered subsequent to that instruction to other functional units that have resources available to process such instructions.

For example a processor may include a scheduler that is coupled to an arithmetic logic unit ALU for performing integer math operations and a load store unit LSU for reading values from a memory coupled to the processor. If the next instruction in a thread is a load instruction the scheduler may transmit the load instruction to the LSU even if the LSU is unavailable to process the instruction because the LSU is processing a previously issued instruction. The issuance of the load instruction enables the scheduler to issue a math instruction to the ALU during the next clock cycle even though the LSU has not processed the previous instruction in the thread i.e. the load instruction . It will be appreciated that the scheduler may only issue instructions that have had all dependencies resolved at the time of issuance. In other words the scheduler must still determine that any source operands referenced as input to the instruction have been loaded with the correct data and that any output operands are available to be written to at the time the instruction is issued. Various mechanisms well known in the art such as scoreboarding or register renaming may be implemented to manage the protection of source operands and output operands.

In order to optimize execution of a program on processor a compiler may order the instructions in a way that helps ensure an optimal use of available resources within the processor . Because the compiler can implement a state machine when a particular instruction for a given resource i.e. functional unit is included in the program the compiler can determine when that resource should be available to process another instruction. For example for each instruction that is configured to be executed by the second functional unit the compiler will attempt to order three instructions between that instruction and the next subsequent instruction configured to be executed by the second functional unit . The compiler matches the frequency of the instructions in the program to the known throughput of the functional units thereby reducing cycles during execution where the scheduler delays issuance of an instruction to the functional units because the functional unit is busy.

These types of optimizations are easily implemented when the throughput of the functional units are easily modeled. However many processors may include functional units that may have a variable throughput. For example a particular functional unit may comprise a shared resource that can have instructions issued to the functional unit by two or more schedulers or even different threads managed by the same scheduler. In such cases the compiler cannot model how instructions are going to be issued from multiple unrelated threads. In addition one or more stages of the pipeline implemented by a functional unit may perform operations that have variable latency. For example a particular stage of a texture unit may load texture samples from a memory. Performing memory access operations can cause a delay based on the number of units attempting to access the memory substantially simultaneously. Such delays may stall conventional schedulers from issuing another instruction to the texture unit even if independent instructions from such threads could be executed by other available resources.

For example a program may include 16 instructions 12 instructions configured to be executed by the first functional unit and four instructions configured to be executed by the second functional unit . If the throughput of the functional units was known such as described above in conjunction with then the compiler may order the instructions to include three instructions for the first functional unit between any two instructions for the second functional unit . However since the throughput of the functional units is not known because the functional units are a shared resource the compiler can simply order each of the four instructions for the second functional unit consecutively and the scheduler can issue the four instructions to the second functional unit in four consecutive clock cycles. The instructions are stored temporarily in the queue and the second functional unit processes the instructions in the order received from the scheduler as the pipeline in the second functional unit becomes available. The decoupled pipeline described above reduces the complexity of the compiler which no longer needs to optimize instruction order based on resource availability and prevents lower throughput operations from stalling other independent operations from being processed by an available resource.

It will be appreciated that reading the source operands specified by the instructions may be delayed while the instructions are temporarily stored in the queue . In other words values located in the registers specified by the source operands of the instruction are not read until the instruction is popped from the queue and the instruction is ready to be executed by the second functional unit .

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a Pete bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

A just in time JIT compiler implemented by a device driver for the PPU may be configured to generate code for execution by one or more of the SMs . Unlike prior art devices the compiler may not optimize the order of instructions based on the availability of processor resources because the decoupled pipelines can receive instructions at any rate specified by the program given that at least one slot in the queue is available. As long as the number of instructions sent to a particular pipeline does not fill up the corresponding queue faster than the functional unit can drain the queue then the order of the instructions does not matter as long as any dependencies for the instruction have been resolved when the instruction is issued by the scheduler unit .

The scheduler unit receives a command to schedule one or more threads associated with a plurality of instructions. The threads include instructions to be issued to one or more of the functional units . The scheduler unit resolves any dependencies for the instructions e.g. ensuring that operand data has been loaded into the register file ensuring that an output register is not allocated to another issued instruction etc. and issues instructions from the threads to the one or more functional units . The queues receive the instructions and temporarily store the instructions until the corresponding functional unit is available to process the next pending instruction. Once the functional unit is available an instruction may be extracted i.e. popped from the queue and processed by the functional unit .

In one embodiment the queue may transmit a signal to the scheduler unit s when the queue is full. For example a signal e.g. a one bit interconnect may be asserted when the queue has no empty slot available to store an instruction. When the signal is asserted the scheduler unit s may stall the issuance of any further instructions to the corresponding functional unit . Once the functional unit has extracted at least one instruction from the queue thereby creating an empty slot the signal may be cleared and the scheduler unit s may resume issuing instructions to the functional unit .

In one embodiment the scheduler unit s is configured to protect source operands and output operands for instructions issued to the functional units . While it is well known in the art that output operands for issued instructions should be protected until the operand is used by subsequent instructions it is far less common that source operands need to be protected. This is because typically when an instruction is issued the source operands are immediately read into the data path and the registers may be used for other instructions. However because the processing of the instructions i.e. reading source operand values from the register file is delayed while the instructions are stored in the queues the scheduler unit s is configured to implement some technique for protecting source operands as well.

In one embodiment the scheduler unit s may utilize a scoreboarding technique to track when registers have been read and or written by an issued instruction. When each instruction is issued by a scheduler unit the scheduler unit may increment a read counter associated with each source operand register as well as a write counter associated with a destination operand register for the instruction. When an instruction is extracted from the queue by a functional unit the source operands are read from the register file. The read counter for each of the source operands may then be decremented to indicate that the source operands have been read from the register file. Similarly when the functional unit finishes executing a particular instruction and has written the output to the destination operand register the write counter for the destination operand register may be decremented to indicate that output for the instruction has been written to the register file.

The scheduler unit may delay the issuing of any instruction that includes a destination operand register that is associated with a read counter that is not equal to zero. In other words an instruction will be prevented from issuing if any previously issued instruction specifying the register as a source operand has not read a value from the register specified by the destination operand register in the instruction. Multiple instructions reading the same source operand register may be outstanding at any one time.

The scheduler unit may also delay any instruction that is configured to read any source operand registers or write to a destination operand register associated with a write counter that is greater than zero. In one embodiment the write counter may correspond to a single bit such that only one instruction specifying a particular register as a destination operand may be in flight at any given time.

As also shown in a functional unit may implement a pipeline that includes a plurality of stages e.g. J stages . When the functional unit is ready to execute an instruction the functional unit may read an instruction from the slot pointed to by the tail pointer . The instruction may cause the functional unit to load an input at the start of the datapath for the first stage i.e. stage of the pipeline. The input may include an opcode from the instruction as well as one or more operands specified by the instruction and read from the register file . The first stage processes the input and generates an intermediate output that is passed to the input of the second stage . The second stage processes the output of the first stage and generates an intermediate output that is passed to the input of the next stage and so forth. The last stage i.e. stage J 1 J 1 generates the output that is written back to e.g. the register file or the shared memory L1 cache as specified by the output operand of the instruction.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk MID drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

