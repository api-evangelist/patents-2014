---

title: Techniques for conservative rasterization
abstract: This disclosure describes a method for performing conservative rasterization in a processor comprising determining vertices of a primitive, defining edges of the primitive by determining a set of edge equations based on the determined vertices, wherein the edge equations are based on an edge shifting parameter plus an offset, determining pixels that touch the edges of the primitive using the determined edge equations, and rasterizing the primitive using the determined pixels.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09324127&OS=09324127&RS=09324127
owner: QUALCOMM Incorporated
number: 09324127
owner_city: San Diego
owner_country: US
publication_date: 20140807
---
This application claims the benefit of U.S. Provisional Application No. 61 940 260 filed Feb. 14 2014 the entire content of which is incorporated by reference herein.

This disclosure relates to techniques for graphics processing and more specifically to techniques for conservative rasterization.

As graphics processing units GPUs become increasingly ubiquitous in the arena of hardware accelerated applications be it graphics applications or otherwise they may be expected to provide a rich set of features to facilitate the efficient and correct implementation of a wide range of algorithms. One such feature is conservative rasterization.

In a standard rasterization pipeline an inclusion test is carried out at a sample point usually being at the center of the pixel. If the sample is calculated to be inside the triangle a fragment is generated for that pixel. The pixel is rejected otherwise. While this process succeeds in including all the pixels that are wholly contained within the triangle several pixels along the edges may not be included even though they overlap the triangle. This is because the center of such pixels along the edges is outside the edge of the triangle.

Conservative rasterization is a rasterization technique that attempts to guarantee the inclusion of all the pixels that overlap even partially with each primitive. However due to limited precision in hardware conventional conservative rasterization may not always include all pixels that overlap a primitive.

Conservative rasterization is a graphics processing technique with the goal of a identifying and rasterizing all pixels that touch a particular primitive. Conventional conservative rasterization techniques may not always identify all pixels that touch a primitive due to the limited precision of hardware. This is since graphics processing hardware has a limited amount of precision in the fractional part of numbers used in calculations the resultant rounding my result in some pixels being not correctly identified as touching a primitive during rasterization. In view of this drawback this disclosure describes techniques for conservative rasterization that use an edge offset parameter to ensure that all touching pixels are identified during rasterization.

In one example of the disclosure a method for performing conservative rasterization in a processor comprises determining vertices of a primitive defining edges of the primitive by determining a set of edge equations based on the determined vertices wherein the edge equations are based on an edge shifting parameter plus an offset determining pixels that touch the edges of the primitive using the determined edge equations and rasterizing the primitive using the determined pixels.

In another example of the disclosure an apparatus configured to perform conservative rasterization comprises a memory configured to store primitive data and a processor configured to determine vertices of a primitive define edges of the primitive by determining a set of edge equations based on the determined vertices wherein the edge equations are based on an edge shifting parameter plus an offset determine pixels that touch the edges of the primitive using the determined edge equations and rasterize the primitive using the determined pixels.

In another example of the disclosure an apparatus configured to perform conservative rasterization in a processor comprises means for determining vertices of a primitive means for defining edges of the primitive by determining a set of edge equations based on the determined vertices wherein the edge equations are based on an edge shifting parameter plus an offset means for determining pixels that touch the edges of the primitive using the determined edge equations and means for rasterizing the primitive using the determined pixels.

In another example this disclosure describes a computer readable storage medium storing instructions that when executed cause one or more processors of a device configured to perform conservative rasterization to determine vertices of a primitive define edges of the primitive by determining a set of edge equations based on the determined vertices wherein the edge equations are based on an edge shifting parameter plus an offset determine pixels that touch the edges of the primitive using the determined edge equations and rasterize the primitive using the determined pixels.

The details of one or more examples of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

As illustrated in the example of computing device may include a user input interface a central processing unit CPU a memory controller a system memory a graphics processing unit GPU a graphics memory a display interface a display and buses and . Note that in some examples graphics memory may be on chip with GPU . In some cases all hardware elements shown in may be on chip for example in a system on a chip SoC design. User input interface CPU memory controller GPU and display interface may communicate with each other using bus . Memory controller and system memory may also communicate with each other using bus . Buses may be any of a variety of bus structures such as a third generation bus e.g. a HyperTransport bus or an InfiniBand bus a second generation bus e.g. an Advanced Graphics Port bus a Peripheral Component Interconnect PCI Express bus or an Advanced eXentisible Interface AXI bus or another type of bus or device interconnect. It should be noted that the specific configuration of buses and communication interfaces between the different components shown in is merely exemplary and other configurations of computing devices and or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.

CPU may comprise a general purpose or a special purpose processor that controls operation of computing device . A user may provide input to computing device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include for example an operating system a word processor application an email application a spread sheet application a media player application a video game application a graphical user interface application or another program. Additionally CPU may execute a GPU driver for controlling the operation of GPU . The user may provide input to computing device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to computing device via user input interface .

The software applications that execute on CPU may include one or more graphics rendering instructions that instruct CPU to cause the rendering of graphics data to display . In some examples the software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct3D API an X3D API a RenderMan API a WebGL API or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU e.g. through GPU driver to cause GPU to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include a list of graphics primitives e.g. points lines triangles quadrilaterals triangle strips etc.

In other examples the software instructions that execute on CPU may cause GPU to execute a general purpose shader for performing more general computations applicable to be executed by the highly parallel nature of GPU hardware. Such general purpose applications may be a so called general purpose graphics processing unit GPGPU and may conform to a general purpose API such as OpenCL

Memory controller facilitates the transfer of data going into and out of system memory . For example memory controller may receive memory read and write commands and service such commands with respect to system memory in order to provide memory services for the components in computing device . Memory controller is communicatively coupled to system memory via memory bus . Although memory controller is illustrated in as being a processing module that is separate from both CPU and system memory in other examples some or all of the functionality of memory controller may be implemented on one or both of CPU and system memory .

System memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example system memory may store a window manager application that is used by CPU to present a graphical user interface GUI on display . In addition system memory may store user applications and application surface data associated with the applications. System memory may additionally store information for use by and or generated by other components of computing device . For example system memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example system memory may store any combination of texture buffers depth buffers stencil buffers vertex buffers frame buffers or the like. System memory may include one or more volatile or non volatile memories or storage devices such as for example random access memory RAM static RAM SRAM dynamic RAM DRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

GPU may be configured to perform graphics operations to render one or more graphics primitives to display . Thus when one of the software applications executing on CPU requires graphics processing CPU may provide graphics commands and graphics data to GPU for rendering to display . The graphics data may include e.g. drawing commands state information primitive information texture information etc. GPU may in some instances be built with a highly parallel structure that provides more efficient processing of complex graphic related operations than CPU . For example GPU may include a plurality of processing elements that are configured to operate on multiple vertices or pixels in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to draw graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than drawing the scenes directly to display using CPU .

GPU may in some instances be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

GPU may be directly coupled to graphics memory . Thus GPU may read data from and write data to graphics memory without using bus . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by eliminating the need of GPU to read and write data via bus which may experience heavy bus traffic. In some instances however GPU may not include a separate memory but instead utilize system memory via bus . Graphics memory may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

CPU and or GPU may store rendered image data in a frame buffer . Frame buffer may be an independent memory or may be allocated within system memory . Display interface may retrieve the data from frame buffer and configure display to display the image represented by the rendered image data. In some examples display interface may include a digital to analog converter DAC that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples display interface may pass the digital values directly to display for processing. Display may include a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array such as an organic LED OLED display a cathode ray tube CRT display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone. Alternatively display may be a stand alone device coupled to computing device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

As will be described in more detail below according to one example of the disclosure GPU may be configured to determine vertices of a primitive define edges of the primitive by determining edge equations based on the determined vertices wherein the edge equations are based on an edge shifting parameter plus an offset determine pixels that touch the edges of the primitive using the determined edge equations and rasterize the primitive using the determined pixels. In this way an over conservative rasterization of primitives may be achieved whereby no pixels touching the edges of the primitives are excluded despite employing fixed precision hardware. In some examples a triangle setup engine of GPU may be configured to perform the techniques of this disclosure.

Software application may be any application that utilizes the functionality of GPU . For example software application may be a GUI application an operating system a portable mapping application a computer aided design program for engineering or artistic applications a video game application or another type of software application that may utilize a GPU.

Software application may include one or more drawing instructions that instruct GPU to render a graphical user interface GUI and or a graphics scene. For example the drawing instructions may include instructions that define a set of one or more graphics primitives to be rendered by GPU . In some examples the drawing instructions may collectively define all or part of a plurality of windowing surfaces used in a GUI. In additional examples the drawing instructions may collectively define all or part of a graphics scene that includes one or more graphics objects within a model space or world space defined by the application.

Software application may invoke GPU driver via graphics API to issue one or more commands to GPU for rendering one or more graphics primitives into displayable graphics images. For example software application may invoke GPU driver via graphics API to provide primitive definitions to GPU . In some instances the primitive definitions may be provided to GPU in the form of a list of drawing primitives e.g. triangles rectangles triangle fans triangle strips etc. The primitive definitions may include vertex specifications that specify one or more vertices associated with the primitives to be rendered. The vertex specifications may include positional coordinates for each vertex and in some instances other attributes associated with the vertex such as e.g. color coordinates normal vectors and texture coordinates. The primitive definitions may also include primitive type information e.g. triangle rectangle triangle fan triangle strip etc. scaling information rotation information and the like. Based on the instructions issued by software application to GPU driver GPU driver may formulate one or more commands that specify one or more operations for GPU to perform in order to render the primitive. When GPU receives a command from CPU graphics processing pipeline decodes the command and configures one or more processing elements within graphics processing pipeline to perform the operation specified in the command. After performing the specified operations graphics processing pipeline outputs the rendered data to frame buffer associated with a display device. Graphics pipeline may be configured to execute in one of a plurality of different rendering modes including a binning rendering mode and a direct rendering mode.

GPU driver may be further configured to compile one or more shader programs and to download the compiled shader programs onto one or more programmable shader units contained within GPU . The shader programs may be written in a high level shading language such as e.g. an OpenGL Shading Language GLSL a High Level Shading Language HLSL a C for Graphics Cg shading language etc. The compiled shader programs may include one or more instructions that control the operation of a programmable shader unit within GPU . For example the shader programs may include vertex shader programs and or pixel shader programs. A vertex shader program may control the execution of a programmable vertex shader unit or a unified shader unit and include instructions that specify one or more per vertex operations. A pixel shader program may include pixel shader programs that control the execution of a programmable pixel shader unit or a unified shader unit and include instructions that specify one or more per pixel operations.

Graphics processing pipeline may be configured to receive one or more graphics processing commands from CPU via graphics driver and to execute the graphics processing commands to generate displayable graphics images. As discussed above graphics processing pipeline includes a plurality of stages that operate together to execute graphics processing commands. It should be noted however that such stages need not necessarily be implemented in separate hardware blocks. For example portions of geometry processing stage and pixel processing pipeline may be implemented as part of a unified shader unit. Again graphics pipeline may be configured to execute in one of a plurality of different rendering modes including a binning rendering mode and a direct rendering mode.

Command engine may receive graphics processing commands and configure the remaining processing stages within graphics processing pipeline to perform various operations for carrying out the graphics processing commands. The graphics processing commands may include for example drawing commands and graphics state commands. The drawing commands may include vertex specification commands that specify positional coordinates for one or more vertices and in some instances other attribute values associated with each of the vertices such as e.g. color coordinates normal vectors texture coordinates and fog coordinates. The graphics state commands may include primitive type commands transformation commands lighting commands etc. The primitive type commands may specify the type of primitive to be rendered and or how the vertices are combined to form a primitive. The transformation commands may specify the types of transformations to perform on the vertices. The lighting commands may specify the type direction and or placement of different lights within a graphics scene. Command engine may cause geometry processing stage to perform geometry processing with respect to vertices and or primitives associated with one or more received commands.

Geometry processing stage may perform per vertex operations and or primitive setup operations on one or more vertices in order to generate primitive data for rasterization stage . Each vertex may be associated with a set of attributes such as e.g. positional coordinates color values a normal vector and texture coordinates. Geometry processing stage modifies one or more of these attributes according to various per vertex operations. For example geometry processing stage may perform one or more transformations on vertex positional coordinates to produce modified vertex positional coordinates. Geometry processing stage may for example apply one or more of a modeling transformation a viewing transformation a projection transformation a ModelView transformation a ModelViewProjection transformation a viewport transformation and a depth range scaling transformation to the vertex positional coordinates to generate the modified vertex positional coordinates. In some instances the vertex positional coordinates may be model space coordinates and the modified vertex positional coordinates may be screen space coordinates. The screen space coordinates may be obtained after the application of the modeling viewing projection and viewport transformations. In some instances geometry processing stage may also perform per vertex lighting operations on the vertices to generate modified color coordinates for the vertices. Geometry processing stage may also perform other operations including e.g. normal transformations normal normalization operations view volume clipping homogenous division and or backface culling operations.

Geometry processing stage may produce primitive data that includes a set of one or more modified vertices that define a primitive to be rasterized as well as data that specifies how the vertices combine to form a primitive. Each of the modified vertices may include for example modified vertex positional coordinates and processed vertex attribute values associated with the vertex. The primitive data may collectively correspond to a primitive to be rasterized by further stages of graphics processing pipeline . Conceptually each vertex may correspond to a corner of a primitive where two edges of the primitive meet. Geometry processing stage may provide the primitive data to rasterization stage for further processing.

In some examples all or part of geometry processing stage may be implemented by one or more shader programs executing on one or more shader units. For example geometry processing stage may be implemented in such examples by a vertex shader a geometry shader or any combination thereof. In other examples geometry processing stage may be implemented as a fixed function hardware processing pipeline or as a combination of fixed function hardware and one or more shader programs executing on one or more shader units.

Triangle setup engine TSE is responsible for among other things producing edge equations which may be used by rasterization stage to generate fragments. In order for TSE to calculate the edge coefficients used in the edge equations TSE is provided with the vertex coordinates in screen space from geometry processing stage . These coordinates are expressed in a fixed precision format which means that there is a possibility that their values were truncated when converted from their original floating point format. This may result in some pixels being rejected due to the precision loss. While this behavior is acceptable when graphics processing pipeline is configured to perform standard rasterization such pixel rejection compromises the results when graphics processing pipeline is configured to perform conservative rasterization. Conservative rasterization is a rasterization technique that is in theory supposed to guarantee the inclusion of all the pixels that overlap even partially with each primitive. As will be discussed in more detail below the techniques of this disclosure include techniques for computing edge equations and edge coefficients such that all pixels that overlap with a primitive are included thus negating or reducing any loss due to fixed precision processing.

Rasterization stage is configured to receive from geometry processing stage primitive data that represents a primitive to be rasterized and to rasterize the primitive to generate a plurality of source pixels that correspond to the rasterized primitive. In some examples rasterization stage may determine which screen pixel locations are covered by the primitive to be rasterized and generate a source pixel for each screen pixel location determined to be covered by the primitive. Rasterization stage may determine which screen pixel locations are covered by a primitive by using techniques known to those of skill in the art such as e.g. an edge walking technique evaluating edge equations etc. Rasterization stage may provide the resulting source pixels to pixel processing pipeline for further processing.

The source pixels generated by rasterization stage may correspond to a screen pixel location e.g. a destination pixel and be associated with one or more color attributes. All of the source pixels generated for a specific rasterized primitive may be said to be associated with the rasterized primitive. The pixels that are determined by rasterization stage to be covered by a primitive may conceptually include pixels that represent the vertices of the primitive pixels that represent the edges of the primitive and pixels that represent the interior of the primitive.

Pixel processing pipeline is configured to receive a source pixel associated with a rasterized primitive and to perform one or more per pixel operations on the source pixel. Per pixel operations that may be performed by pixel processing pipeline include e.g. alpha test texture mapping color computation pixel shading per pixel lighting fog processing blending a pixel ownership test a source alpha test a stencil test a depth test a scissors test and or stippling operations. In addition pixel processing pipeline may execute one or more pixel shader programs to perform one or more per pixel operations. The resulting data produced by pixel processing pipeline may be referred to herein as destination pixel data and stored in frame buffer . The destination pixel data may be associated with a destination pixel in frame buffer that has the same display location as the source pixel that was processed. The destination pixel data may include data such as e.g. color values destination alpha values depth values etc.

Frame buffer stores destination pixels for GPU . Each destination pixel may be associated with a unique screen pixel location. In some examples frame buffer may store color components and a destination alpha value for each destination pixel. For example frame buffer may store Red Green Blue Alpha RGBA components for each pixel where the RGB components correspond to color values and the A component corresponds to a destination alpha value where the alpha value represents transparency. Although frame buffer and system memory are illustrated as being separate memory units in other examples frame buffer may be part of system memory .

As GPUs become increasingly ubiquitous in the arena of hardware accelerated applications be it graphics applications or otherwise GPU may be expected to provide a rich set of features to facilitate the efficient and correct implementation of a wide range of algorithms. One such feature is conservative rasterization. As discussed above graphics processing pipeline may be configured to perform conservative rasterization.

In a standard rasterization pipeline an inclusion test is carried out at a sample point usually being at the center of the pixel. If the sample is calculated to be inside the triangle a fragment is generated for that pixel. The pixel is rejected otherwise. While this process succeeds in including all the pixels that are wholly contained within the triangle several pixels along the edges may not be included even though they overlap the triangle. This is because the center of such pixels along the edges is outside the edge of the triangle. A combination of multisampling and target independent rendering may be used to reduce this effect but it only offers a tradeoff for accuracy at the cost of performance without completely eliminating the problem. To eliminate the problem infinite multisampling is required which is impractical.

Conservative rasterization is a rasterization technique that attempts to guarantee the inclusion of all the pixels that overlap even partially with each primitive e.g. a triangle . illustrates the difference between standard and conservative rasterization techniques. As shown in traditional rasterization techniques i.e. non conservative rasterization would only identify the pixels having their center on or within triangle . Such pixels are identified with hash shading in . Traditional rasterization techniques would leave out pixels that only partially overlap triangle i.e. pixels whose center is outside the triangle . Those pixels that only partially overlap triangle i.e. pixels whose center is outside the triangle are shown with dot shading in . Conservative rasterization techniques are designed to also include those pixels with dot shading that only partially overlap the primitive in addition to the pixels that having their center on or within triangle identified with hash shading .

There are several algorithms that may benefit from conservative rasterization in order to function optimally. Such algorithms may be used in applications such as collision detection visibility testing occlusion culling and voxelization. Currently developers who require the use of conservative rasterization resort to a shader based implementation. The conservative rasterization techniques of this disclosure however are not limited to shader based implementations but may utilize a hardware implementation of conservative rasterization at the level of a TSE e.g. TSE . It should be understood however that the techniques of this disclosure may also be implemented in a shader.

The next section of the disclosure will discuss triangle setup for conservative rasterization. Edge equations defining a primitive are used to determine if a particular pixel intersects the triangle. The three edges of a triangle are each represented by a function E x y based on the vertices of the triangle. The function E x y divides the screen space into a positive to the right of the edge and a negative to the left of the edge side. The function evaluates to 0 for any point lying on the edge. Given a point s x y this point is considered inside the triangle if E s E s and E s are all 0.

The edge functions are defined as follows where A Band Care coefficients associated with the locations of the triangle s three vertices and are computed by TSE .

In the following we consider that the triangle vertices are ordered clockwise and that the origins of the window and the bounding box are at the top left corner. Also all the coordinates are in screen space and we ignore the z component as it is only used to interpolate a depth buffer value note that conservative depth may be used for certain applications like voxelization .

Consider the edge pq in defined by the vertices p x y and q x y . The edge equation is defined by the line pq which is expressed by the line equation 0 where s x y is an arbitrary point and

The goal of conservative rasterization is to generate a fragment for each pixel that shares any amount of its area with the triangle being rendered. In the following example we use a triangle as the use case without loss of generality. The techniques of this disclosure may be used with any primitive type.

One premise is that GPU may be configured to confirm whether or not a pixel overlaps the area of a triangle or other primitive by only testing one of the four corners of the pixel for inclusion. GPU may determine the inclusion of a particular pixel by evaluating the sign of E s E s and E s at the corner location. But first an appropriate corner is selected. One techniques of selecting a corner of a pixel involves selecting a semi diagonal that lies within the same quadrant as the edge normal. In essence this is equivalent to shifting the edge defined by the edge equation by one semi diagonal in the opposite direction of the sample shift as is shown in .

The E s edge equation presented in the previous section can be rewritten in terms of the positive normal right arrow over n pointing toward the inside of the triangle of the edge pq once we observe that coefficients A and B are nothing more than the negative x and y coordinates of the non normalized normal right arrow over n right arrow over Therefore where The vector right arrow over p is a vector from origin o 0 0 to the vertex p x1 y1 .

Now that the equation is re written in vector terms it becomes easy to assess the value of E s right arrow over t where right arrow over t t t is the semi diagonal vector that shares the same quadrant as the normal vector.

We define the vector right arrow over t which may be referred to as an edge shifting parameter from the center of the pixel to the selected corner 0.5 represents half a pixel width 

Therefore to achieve conservative rasterization the C term above may be modified to exclude the constant right arrow over n right arrow over t .

This technique effectively shifts the edge of the triangle outward to include the center of any pixel that it originally overlapped. Note that this is true for clockwise triangles. For counterclockwise the term right arrow over n right arrow over t is added to C to produce the same effect 

Also note that adding the term right arrow over n right arrow over t instead of subtracting it from C in the case of C and subtracting instead of adding in the case of C achieves what is referred to as underestimated conservative rasterization whereby only the pixels that are wholly contained within the convex hull of the triangle are rasterized. Additional description of conservative rasterization may be found in by Tomas Akenine Moller and Timo Aila Journal of Graphics GPU and Game Tools Volume 10 Issue 3 pp. 1 8 2005.

An example implementation will now be discussed. In this example the coefficients A B and C are calculated within TSE before rasterization. If conservative rasterization is enabled TSE will produce the modified C term described above instead of C.

Before describing the actual implementation of conservative rasterization an understanding of certain precision issues will be discussed. In order for TSE to calculate the edge coefficients it is provided with the vertex coordinates in screen space. These coordinates are expressed in a fixed precision format which means that there is a possibility their values were truncated when converted from their original floating point format . Below is an example to illustrate a potential problem.

Referring to assume that GPU is rendering to a 4 4 pixel render target that the GPU hardware is limited to 8 bits of precision in the fraction part and that the normalized coordinates of a triangle are expressed in the application as V 0.5f 0.5f 0.2f V 0.5f 0.5f 0.2f and V 0.5 f 0.5f 0.2f . As shown in white pixels shown as unfilled boxes are included as touching the triangle with vertices V V and V. Black pixels shown as filled boxes would not be included. Normally using traditional rasterization GPU would select the white pixels shown in for inclusion when rasterizing the triangle. With conservative rasterization enabled additional pixels with slight overlap would result as shown in . As illustrated in and the x y coordinates of Vtranslate to 3.0 1.0 in screen space.

As shown in and if we change the x coordinate of the Vvertex slightly to V 0.5001f 0.5f 0.2f the screen space coordinate for x should become 3.0002. Note that the vertex Vin FIG. c and is exaggerated for illustration. However since the precision of the hardware is often limited in the fractional part e.g. to 8 bits thus truncating any value below

Note that this problem is reduced as the resolution increases. This is because the range of valid values in normalized device coordinates 1 1 maps to a larger number of pixels in screen space and so small changes in the former result in big changes in the latter. In other words for the problem to manifest itself at high resolutions the change in normalized device coordinates NDC has to be extremely small.

In view of the foregoing an exactly correct implementation of conservative rasterization may not be possible due to the precision limitation inherent to the graphics hardware. Three options exist 1 To accept the snapping and truncation of small values 2 To provide an over conservative rasterization which guarantees that no overlapping pixels are missed but may generate extra fragments or 3 To optimally have the programmer choose which of the two previous options to activate.

Achieving the third option requires little to no additional resources other than exposing the possibility to the programmer. The remainder of this disclosure describes the techniques of an example implementation of the second option. That is this disclosure proposes techniques for over conservative rasterization which guarantees that all pixels that touch a triangle will be included in the rasterization while also possibly including some pixels that do not touch the triangle.

According to the techniques of this disclosure to achieve an over conservative rasterization that guarantees no overlapping pixels are missed TSE may be configured to calculate modified edge shifting parameters tand tby including an offset . One example is shown as follows 

An analysis has been conducted to study the effect of said over conservative rasterization. shows the results of this analysis. Several thousand triangles were randomly generated at different resolutions x axis using a conventional conservative technique as well as the over conservative rasterization technique of this disclosure. The y axis refers to the average percentage of the total number of pixels generated for the triangle the area of the triangle . Overhead pixels are those that lie completely outside the triangle but for which a fragment has been generated. Extra pixels are those that were not included by conventional conservative rasterization techniques but were included by the over conservative rasterization techniques of this disclosure. Good catches refer to the pixels that would have been missed were it not for over conservatism. In effect the techniques of this disclosure result in the inclusion of more good catches at the expense of additional extra pixels being included. In some applications it is more beneficial to have all pixels that overlap a primitive to be included than it is detrimental to have the extra pixels included.

As we can be seen in the smaller the triangle the more it is prone to having overhead pixels i.e. extra pixels . However in all cases the number of such pixels does not exceed 0.4 of the total number of pixels generated for the triangle. This is an acceptable cost in order to guarantee correctness which is in this case defined as no overlapping pixels being missed. Alternatively one can ignore over conservative rasterization techniques and accept that at most 0.2 of pixels may be missed.

The hardware requirements for the example implementation of conservative rasterization of this disclosure are minimal. TSE may be configured to execute four additions to adjust the bounding box performed once per primitive two sign comparisons two additions three in the case of a line and two multiplications to calculate the dot product and adjust the C term performed once per edge or line . This implementation is thought to be the worst case cost because it does not take into account any optimizations.

For example the sign comparisons may be eliminated by calculating the absolute value of A and B and using them as the x and y coordinates of right arrow over n respectively. TSE may then use the positive value for tand t right arrow over 0.5 

This disclosure provides an elegant and efficient implementation of precision corrected conservative rasterization that is possible in hardware. The cost both in terms of hardware resources and clock cycles is expected to be extremely small. It should be noted that the conservative rasterization techniques of this disclosure may also be used at the level of tiles bins. In the tile example the value of right arrow over t i.e. tand t would in one example be respectively equal to half the width and height of the tile.

Another example optimization is to include the ability to activate conservative rasterization on a per edge basis. The benefit of this is that all the inner triangles of a mesh would have the over conservative rasterization feature disabled while only the contour edges of the mesh have over conservative rasterization enabled. This carries with it the complexity of determining which are the silhouette edges but that is a task that can be implemented in a shader.

In summary the techniques of this disclosure allow for GPU to preform conservative rasterization by using a modified edge shifting parameter e.g. the term t 0.5 as part of the calculation of the new edge coefficients. The techniques of this disclosure solve the aforementioned problem of fixed precision hardware by adding a programmable offset delta to the edge shifting parameter t. In one example delta 1 1

In another example of the disclosure TSE may be configured to calculate the offset based on a number of fractional bits supported by the processor. In one example TSE is configured to calculate the offset with the equation delta 1 1

In one or more examples the functions described above may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on an article of manufacture comprising a non transitory computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more DSPs general purpose microprocessors ASICs FPGAs or other equivalent integrated or discrete logic circuitry. In addition in some aspects the functionality described herein may be provided within dedicated hardware and or software modules. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs e.g. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

