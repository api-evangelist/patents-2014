---

title: Method and apparatus for compiling regular expressions
abstract: Apparatus, systems, and methods for a compiler are described. One such compiler converts source code into an automaton comprising states and transitions between the states, wherein the states in the automaton include a special purpose state that corresponds to a special purpose hardware element. The compiler converts the automaton into a netlist, and places and routes the netlist to provide machine code for configuring a target device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09146714&OS=09146714&RS=09146714
owner: Micron Technology, Inc.
number: 09146714
owner_city: Boise
owner_country: US
publication_date: 20140414
---
This patent application is a continuation of U.S. application Ser. No. 13 357 472 filed Jan. 24 2012 and now issued as U.S. Pat. No. 8 726 253 which claims the benefit of priority under 35 U.S.C. Section 119 e to U.S. Provisional Patent Application Ser. No. 61 436 013 titled METHOD AND APPARATUS FOR COMPILING REGULAR EXPRESSIONS filed on Jan. 25 2011 all of which are hereby incorporated by reference herein in their entirety.

A finite state machine FSM also referred to as a finite state automaton automaton or simply a state machine is a representation of states transitions between states and actions. A finite state machine can be used to design digital logic computer programs or images for a parallel machine. A finite state machine is a model of behavior composed of a finite number of states transitions between those states and outputs. A finite state machine can be represented as a graph where the vertices of the graph correspond to states of the finite state machine and the edges of the graph correspond to transitions between states which occur due to one or more inputs to the finite state machine. Finite state machines can also have probabilistic transitions fuzzy states or other oddities. A finite state machine has a finite internal memory an input feature and an optional output feature. Finite state machines with an output can be referred to as finite state transducers.

Applications of finite state machines include electronic design automation communication protocol design biology and artificial intelligence research and linguistics to describe the grammars of natural languages.

The following description and the drawings sufficiently illustrate specific embodiments to enable those skilled in the art to practice them. Other embodiments may incorporate structural logical electrical process and other changes. Portions and features of some embodiments may be included in or substituted for those of other embodiments. Embodiments set forth in the claims encompass all available equivalents of those claims.

This document describes among other things a compiler for converting source code e.g. regular expressions into machine code e.g. image for configuring e.g. programming a parallel machine. The image output file produced by the compiler can program the parallel machine to perform certain functions. In certain examples the parallel machine can include a finite state machine FSM engine a field programmable gate array FPGA and variations thereof.

The parallel machine includes a plurality of programmable elements including general purpose elements and special purpose elements . A general purpose element can include one or more inputs and one or more outputs . A general purpose element can be programmed into one of a plurality of states. The state of the general purpose element determines what output s the general purpose elements will provide based on a given input s . That is the state of the general purpose element determines how the programmable element will react e.g. respond to a given input. Data input to the data input port can be provided to the plurality of general purpose elements to cause the general purpose elements to take action thereon. Examples of a general purpose element can include for example a state machine element SME as discussed in detail below a counter and or a configurable logic block among other programmable elements. In an example a SME can be programmed e.g. set to provide a certain output e.g. a high or 1 signal when a given input is received at the data input port . When an input other than the given input is received at the data input port the SME can provide a different output e.g. a low or 0 signal . In an example a configurable logic block can be set to perform a Boolean logic function e.g. AND OR NOR ext. based on input received at the data input port . An example of a counter is discussed later herein. A special purpose element can include memory e.g. RAM logic gates counters look up tables field programmable gate arrays FPGAs and other hardware elements. A special purpose element can interact with the general purpose elements and performing special purpose functions.

The parallel machine can also include a programming interface for loading a program e.g. an image onto the parallel machine . The image can program e.g. set the state of the general purpose elements . That is the image can configure the general purpose elements to react in a certain way to a given input. For example a general purpose element can be set to output a high signal when the character a is received at the data input port . In some examples the parallel machine can use a clock signal for controlling the timing of operation of the general purpose elements . In some embodiments the data received at the data input port can include a fixed set of data received over time or all at once or a stream of data received over time. The data may be received from or generated by any source such as databases sensors networks etc coupled to the parallel machine .

The parallel machine also includes a plurality of programmable switches for selectively coupling together different elements e.g. general purpose element data input port output port programming interface and special purpose elements of the parallel machine . Accordingly the parallel machine comprises a programmable matrix formed among the elements. In an example a programmable switch can selectively couple two or more elements to one another such that an input of a general purpose element the data input port a programming interface or special purpose element can be coupled through one or more programmable switches to an output of a general purpose element the output port a programming interface or special purpose element . Thus the routing of signals between the elements can be controlled by setting the programmable switches . Although illustrates a certain number of conductors e.g. wires between a given element and a programmable switch it should be understood that in other examples a different number of conductors can be used. Also although illustrates each general purpose element individually coupled to a programmable switch in other examples multiple general purpose elements can be coupled as a group e.g. a block as illustrated in to a programmable switch . In an example the data input port the data output port and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements.

In an example a single parallel machine is implemented on a physical device however in other examples two or more parallel machines can be implemented on a single physical device e.g. physical chip . In an example each of multiple parallel machines can include a distinct data input port a distinct output port a distinct programming interface and a distinct set of general purpose elements . Moreover each set of general purpose elements can react e.g. output a high or low signal to data at their corresponding input data port . For example a first set of general purpose elements corresponding to a first parallel machine can react to the data at a first data input port corresponding to the first parallel machine . A second set of general purpose elements corresponding to a second parallel machine can react to a second data input port corresponding to the second parallel machine . Accordingly each parallel machine includes a set of general purpose elements wherein different sets of general purpose elements can react to different input data. Similarly each parallel machine and each corresponding set of general purpose elements can provide a distinct output. In some examples an output port from first parallel machine can be coupled to an input port of a second parallel machine such that input data for the second parallel machine can include the output data from the first parallel machine .

In an example an image for loading onto the parallel machine comprises a plurality of bits of information for setting the state of the general purpose elements programming the programmable switches and configuring the special purpose elements within the parallel machine . In an example the image can be loaded onto the parallel machine to program the parallel machine to provide a desired output based on certain inputs. The output port can provide outputs from the parallel machine based on the reaction of the general purpose elements to data received at the input port . An output from the output port can include a single bit indicating a match of a given pattern a word comprising a plurality of bits indicating matches and non matches to a plurality of patterns and an output vector corresponding to the state of all or certain general purpose elements at a given moment.

Example uses for the parallel machine include pattern recognition e.g. speech recognition image recognition etc. signal processing imaging computer vision cryptography and others. In certain examples the parallel machine can comprise a finite state machine FSM engine a field programmable gate array FPGA and variations thereof. Moreover the parallel machine may be a component in a larger device such as a computer pager cellular phone personal organizer portable audio player network device e.g. router firewall switch or any combination thereof control circuit camera etc.

The FSM engine includes a plurality of programmable elements including general purpose elements and special purpose elements. The general purpose elements can be programmed to implement many different functions. These general purpose elements include SMEs shown in that are hierarchically organized into rows shown in and blocks shown in . To route signals between the hierarchically organized SMEs a hierarchy of programmable switches is used including inter block switches shown in intra block switches shown in and intra row switches shown in . A SME can correspond to a state of a FSM implemented by the FSM engine . The SMEs can be coupled together by using the programmable switches as described below. Accordingly a FSM can be implemented on the FSM engine by programming the SMEs to correspond to the functions of states and by selectively coupling together the SMEs to correspond to the transitions between states in the FSM.

In an example the input block the output block and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements. Accordingly bits from the image stored in the registers corresponding to the programming interface can be loaded on the SMEs . Although illustrates a certain number of conductors e.g. wire trace between a block input block output block and an inter block switch it should be understood that in other examples fewer or more conductors can be used.

In an example the row includes a first and second plurality of row interconnection conductors . In an example an input of a GOT can be coupled to one or more row interconnection conductors and an output can be coupled to one row interconnection conductor . In an example a first plurality of the row interconnection conductors can be coupled to each SME of each GOT within the row . A second plurality of the row interconnection conductors can be coupled to one SME of each GOT within the row but cannot be coupled to the other SME of the GOT . In an example a first half of the second plurality of row interconnection conductors can couple to first half of the SMEs within a row one SME from each GOT and a second half of the second plurality of row interconnection conductors can couple to a second half of the SMEs within a row the other SME from each GOT . The limited connectivity between the second plurality of row interconnection conductors and the SMEs is referred to herein as parity .

In an example the row can also include a special purpose element such as a counter a programmable Boolean logic element a field programmable gate array FPGA an application specific integrated circuit ASIC a programmable processor e.g. a microprocessor and other elements. Additionally in an example the special purpose element is different in different rows . For example four of the rows in a block can include Boolean logic as the special purpose element and the other eight rows in a block can include a counter as the special purpose element .

In an example the special purpose element includes a counter also referred to herein as counter . In an example the counter comprises a 12 bit programmable down counter. The 12 bit programmable counter has a counting input a reset input and zero count output. The counting input when asserted decrements the value of the counter by one. The reset input when asserted causes the counter to load an initial value from an associated register. For the 12 bit counter up to a 12 bit number can be loaded in as the initial value. When the value of the counter is decremented to zero 0 the zero count output is asserted. The counter also has at least two modes pulse and hold. When the counter is set to pulse mode the zero count output is asserted during the first clock cycle when the counter decrements to zero and at the following clock cycles the zero count output is no longer asserted even if the counting input is asserted. This state continues until the counter is reset by the reset input being asserted. When the counter is set to hold mode the zero count output is asserted during the first clock cycle when the counter decrements to zero and stays asserted when the counting input is asserted until the counter is reset by the reset input being asserted.

In an example a state machine element comprises a plurality of memory cells such as those often used in dynamic random access memory DRAM coupled in parallel to a detect line . One such memory cell comprises a memory cell that can be set to a data state such as one that corresponds to either a high or a low value e.g. a 1 or 0 . The output of the memory cell is coupled to the detect line and the input to the memory cell receives signals based on data on the data stream line . In an example an input on the data stream line is decoded to select one of the memory cells . The selected memory cell provides its stored data state as an output onto the detect line . For example the data received at the data input port can be provided to a decoder not shown and the decoder can select one of the data stream lines . In an example the decoder can convert an ACSII character to 1 of 256 bits.

A memory cell therefore outputs a high signal to the detect line when the memory cell is set to a high value and the data on the data stream line corresponds to the memory cell . When the data on the data stream line corresponds to the memory cell and the memory cell is set to a low value the memory cell outputs a low signal to the detect line . The outputs from the memory cells on the detect line are sensed by a detect circuit . In an example the signal on an input line sets the respective detect circuit to either an active or inactive state. When set to the inactive state the detect circuit outputs a low signal on the respective output regardless of the signal on the respective detect line . When set to an active state the detect circuit outputs a high signal on the respective output line when a high signal is detected from one of the memory cells of the respective SME . When in the active state the detect circuit outputs a low signal on the respective output line when the signals from all of the memory cells of the respective SME are low.

In an example an SME includes memory cells and each memory cell is coupled to a different data stream line . Thus an SME can be programmed to output a high signal when a selected one or more of the data stream lines have a high signal thereon. For example the SME can have a first memory cell e.g. bit set high and all other memory cells e.g. bits set low. When the respective detect circuit is in the active state the SME outputs a high signal on the output when the data stream line corresponding to bit has a high signal thereon. In other examples the SME can be set to output a high signal when one of multiple data stream lines have a high signal thereon by setting the appropriate memory cells to a high value.

In an example a memory cell can be set to a high or low value by reading bits from an associated register. Accordingly the SMEs can be programmed by storing an image created by the compiler into the registers and loading the bits in the registers into associated memory cells . In an example the image created by the compiler includes a binary image of high and low e.g. 1 and 0 bits. The image can program the FSM engine to operate as a FSM by cascading the SMEs . For example a first SME can be set to an active state by setting the detect circuit to the active state. The first SME can be set to output a high signal when the data stream line corresponding to bit has a high signal thereon. The second SME can be initially set to an inactive state but can be set to when active output a high signal when the data stream line corresponding to bit has a high signal thereon. The first SME and the second SME can be cascaded by setting the output of the first SME to couple to the input of the second SME . Thus when a high signal is sensed on the data stream line corresponding to bit the first SME outputs a high signal on the output and sets the detect circuit of the second SME to an active state. When a high signal is sensed on the data stream line corresponding to bit the second SME outputs a high signal on the output to activate another SME or for output from the FSM engine .

In an example the compiler includes an application programming interface API that allows software developers to create images for implementing FSMs on the FSM engine . The compiler provides methods to convert an input set of regular expressions in the source code into an image that is configured to program the FSM engine . The compiler can be implemented by instructions for a computer having a Von Nuemann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler. For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor. An example computer having a Von Nuemann architecture is shown in and described below.

In an example the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings the source code can include a plurality of regular expressions regexs . A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains such as programming languages text editors network security and others. In an example the regular expressions supported by the compiler include search criteria for the search of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes printable and non printable within the data. In an example the compiler can support multiple different source code languages for implementing regexes including Perl e.g. Perl compatible regular expressions PCRE PHP Java and .NET languages.

Referring back to at block the compiler can parse the source code to form an arrangement of relationally connected operators where different types of operators correspond to different functions implemented by the source code e.g. different functions implemented by regexes in the source code . Parsing source code can create a generic representation of the source code. In an example the generic representation comprises an encoded representation of the regexs in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree also known as an abstract syntax tree in other examples however a concrete syntax tree or other arrangement can be used.

Since as mentioned above the compiler can support multiple languages of source code parsing converts the source code regardless of the language into a non language specific representation e.g. a syntax tree. Thus further processing blocks by the compiler can work from a common input structure regardless of the language of the source code.

As noted above the syntax tree includes a plurality of operators that are relationally connected. A syntax tree can include multiple different types of operators. That is different operators can correspond to different functions implemented by the regexes in the source code.

At block the syntax tree is converted e.g. transformed into an automaton. In an example the automaton comprises a software model of a FSM and can accordingly be classified as deterministic or non deterministic. A deterministic automaton has a single path of execution at a given time while a non deterministic automaton has multiple concurrent paths of execution. An automaton includes a plurality of states that can be represented by nodes. In order to convert a syntax tree into an automaton the operators and relationships between the operators in the syntax tree are converted into states represented by nodes with transitions represented by directed edges between the states in the automaton. In an example the automaton can be converted based partly on the hardware of the FSM engine .

In an example input symbols for the automaton include the symbols of the alphabet the numerals 0 9 and other printable characters. In an example the input symbols are represented by the byte values through inclusive. In an example an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example the data accepted e.g. matched by an automaton is the set of all possible character data which when input sequentially into the automaton will reach a final state. Each symbol in the data accepted by the automaton traces a path from the start state to one or more final states.

In an example the automaton comprises general purpose states as well as special purpose states. The general purpose states and special purpose states correspond to general purpose elements and special purpose elements supported by a target device for which the compiler is generating machine code. Different types of target devices can support different types of general purpose elements as well as one or more different types of special purpose elements. A general purpose element can typically be used to implement a broad range of functions while a special purpose element can typically be used to implement a more narrow range of functions. In an example however a special purpose element can achieve for example greater efficiency within its narrow range of function. Accordingly a special purpose element can be used to for example reduce the machine cycles or the machine resources required to implement certain functions in the target device. In some examples the target device supports solely special purpose elements wherein multiple different types of special purpose elements are supported.

In an example where the compiler is generating machine code for the FSM engine the general purpose states can correspond to SMEs and the general purpose states are accordingly referred to herein as SME states . Moreover when the compiler is generating machine code for the FSM engine the special purpose states can correspond to counters and are accordingly referred to herein as counter states . In an example the SME states in the automaton map 1 1 to SMEs e.g. SME in the FSM engine with the exception of the starting state of the automaton which does not map to a SME. The counters may or may not map 1 1 to counter states.

In an example special transition symbols outside the input symbol range may be used in the automaton. These special transition symbols can be used for example to enable use of special purpose elements . Moreover special transition symbols can be used to provide transitions that occur on something other than an input symbol. For example a special transition symbol may indicate that a first state is to be enabled e.g. transitioned to when both a second state and a third state are enabled. Accordingly the first state is activated when both the second state and the third state are activated and the transition to the first state is not directly dependent on an input symbol. Notably a special transition symbol that indicates that a first state is to be enabled when both a second state and a third state are enabled can be used to represent a Boolean AND function performed for example by Boolean logic as the special purpose element . In an example a special transition symbol can be used to indicate a counter state has reached zero and thus transitions to a downstream state.

In an example the automaton created from the syntax tree is a homogenous automaton. A homogeneous automaton is a restriction on the general automaton definition. The restriction requires that all transitions entering a state must occur on the same input symbol s . The homogeneous automaton satisfies the following condition For any two states qand q if r q q denote S a a r q a S a a r q a . Sis the set of symbols that allows qto transition to r and Sis the set of symbols that allows qto transit to r. Here S S i.e. if state qand state qboth transition to state r then the homogeneous restriction is that the transitions must occur on the same symbol s .

For additional details on conversion of a syntax tree into the automaton see discussion below in reference to .

At block after the automaton is constructed the automaton is optimized to among other things reduce its complexity and size. The automaton can be optimized by combining redundant states.

At block the automaton is converted into a netlist. Converting the automaton into a netlist maps the states of the automaton to instances of a hardware element e.g. SMEs GOT special purpose element of the FSM engine and determines the connections between the instances. In an example the netlist comprises a plurality of instances each instance corresponding to e.g. representing a hardware element of the FSM engine . Each instance can have one or more connection points also referred to herein as a port for connection to another instance. The netlist also comprises a plurality of connections between the ports of the instances which correspond to e.g. represent conductors to couple the hardware elements corresponding to the instances. In an example the netlist comprises different types of instances corresponding to different types of hardware elements. For example the netlist can include a general purpose instance corresponding to a general purpose hardware element and a special purpose instance corresponding to a special purpose hardware element. As an example general purpose states can be converted into general purpose instances and special purpose states can be converted into special purpose instances. In an example the general purpose instances can include an SME instance for an SME and a SME group instance for a hardware element comprising a group of SMEs. In an example the SME group instance includes a GOT instance corresponding to a GOT in other examples however the SME group instance can correspond to a hardware element comprising a group of three or more SMEs. The special purpose instances can include a counter instance for a counter and a logic instance for logic elements . Since a GOT includes two SMEs a GOT instance contains two SME instances.

To create the netlist states in the automaton are converted into instances in the netlist except the starting state does not have a corresponding instance. SME states are converted into GOT instances and counter states are converted into counter instances. Additionally a corresponding connection from a first instance to a second instance is created for a transition from a state corresponding to the first instance to a state corresponding to the second instance. Since the SMEs in the FSM engine are grouped in pairs referred to as GOTs the compiler can group SME states into pairs in a GOT instance. Due to physical design of a GOT not all SME instances can be paired together to form a GOT . Accordingly the compiler determines which SME states can be mapped together in a GOT and then pairs the SME state into GOT instances based on the determination. Additional details on an example method of converting an automaton into a netlist are discussed below in reference to below.

At block once the netlist has been generated the netlist is placed to select a specific hardware element of the target device e.g. SMEs other elements for each hardware element instance of the netlist. According to an embodiment of the present invention placing selects each specific hardware element based on general input and output constraints for the hardware elements.

Placement can be a difficult problem and is typically solved by using heuristics. It can be performed using methods such as force directed techniques partitioning techniques simulated annealing or a combination of the above mentioned techniques.

In an example two methods can be used to address the large combinatorial optimization problem these are simulated annealing and multi level hyper graph partitioning. The trade off between these methods is accuracy versus speed. Simulated annealing can produce a very high quality placement but is extremely expensive on central processing unit CPU time. In contrast hyper graph partitioning can be orders of magnitude faster but tends to produce less optimum placements. In an example simulated annealing can be used to ensure a high quality placement that meets the needs of the target hardware device. In another example hyper graph partitioning can be used as a first stage followed by simulating annealing operation to refine the placement created by the hyper graph partitioning stage. In some example a combination of both simulated annealing and multi level hyper graph partitioning is used in order to capitalize on the strengths of each heuristic.

At block placed netlist is routed to determine the settings for the programmable switches e.g. inter block switches intra block switches and intra row switches in order to couple the selected hardware elements together to achieve the connections describe by the netlist. In an example the settings for the programmable switches are determined by determining specific conductors of the FSM engine that will be used to connect the selected hardware elements and the settings for the programmable switches. Routing can take into account more specific limitations of the connections between the hardware elements than placement at block . Accordingly routing may adjust the location of some of the hardware elements as determined by the global placement in order to make appropriate connections given the actual limitations of the conductors on the FSM engine .

Once the netlist is placed and routed the placed and routed netlist can be converted into a plurality of bits for programming of a FSM engine . The plurality of bits are referred to herein as an image.

In some examples prior to converting the automaton into a netlist at block the automaton is split into multiple smaller automatons and each smaller automaton is individually converted into a netlist at block . Since the complexity of placement at block increases as the number of instances increases splitting the automaton into a plurality of smaller automatons and converting the smaller automatons in individual netlists can provide smaller netlists for placing and routing at block and block . Accordingly placing the smaller netlists can help reduce the time required to determine an acceptable configuration. In an example the automaton is split into multiple smaller automatons using graph theory. Each smaller automaton can then be individually converted into a netlist block and placed block within an assigned area. Accordingly the available area can be divided up and assigned to different netlists with each netlist being individually placed within its assigned portion. As noted above some portions of the available area may remain unassigned and thus are available for placement of other netlists. In an example each netlist formed from a smaller automaton can have a configuration determined in parallel in order to reduce the overall processing time.

At block an image is published by the compiler. The image comprises a plurality of bits for programming specific hardware elements and or programmable switches of the FSM engine . In embodiments where the image comprises a plurality of bits e.g. 0 and 1 the image can be referred to as a binary image. The bits can be loaded onto the FSM engine to program the state of SMEs the special purpose elements and the programmable switches such that the programmed FSM engine implements a FSM having the functionality described by the source code. Placement block and routing block can map specific hardware elements at specific locations in the FSM engine to specific states in the automaton. Accordingly the bits in the image can program the specific hardware elements and or programmable switches to implement the desired function s . In an example the image can be published by saving the machine code to a computer readable medium. In another example the image can be published by displaying the image on a display device. In still another example the image can be published by sending the image to another device such as a programming device for loading the image onto the FSM engine . In yet another example the image can be published by loading the image onto a parallel machine e.g. the FSM engine .

In an example an image can be loaded onto the FSM engine by either directly loading the bit values from the image to the SMEs and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs and other hardware elements . In an example the hardware elements e.g. SMEs other elements programmable switches of the FSM engine are memory mapped such that a computer e.g. a programming device coupled to or integral with the computer can load the image onto the FSM engine by writing the image to one or more memory addresses.

In an example the method inserts special transition symbols into an automaton while converting the syntax tree into the automaton. In one such example special transition symbols correspond to operators that do not map 1 1 to automaton states. As mentioned above special transition symbols can be reserved for Boolean operations Counters and End of data functions among others.

At the method can include an operation to adjust the syntax trees in view of constraints of a target hardware device. In an example constraints of the target hardware device e.g. the FSM engine can impose limitations on the structure of an automaton. In situations where such constraints impose limitations the complier can include operations at the conversion stage to adjust the states and or transitions created within an automaton to conform to the hardware constraints.

At the method can include an operation to classify each syntax tree using a set of attributes. In an example the operations can be classified using one of the standard techniques such as Glushkov s method.

At the method can include an operation to replace non deterministic operators of a syntax tree with equivalent deterministic operators. In an example certain types of non deterministic operators such as loops can be implemented using a counter in conjunction with standard programmable elements. In an example if the non deterministic operator is not suitable for implementation with a special purpose hardware element such as a counter then the non deterministic operator can be unrolled. Unrolling an operator can be accomplished by serializing all possible combinations of states corresponding to the non deterministic operator.

Certain regular expressions when converted into an automaton can result in a large number of states. A large number of states can use a large number of the general purpose elements to implement. To reduce the number of states and thus the number of general purpose elements used special purpose hardware elements can be used to implement certain regular expressions. For example one regular expression that when converted to standard general purpose elements can require a large amount of states is a quantification expression. A quantification expression corresponds to a looped structure that repeats one or more expressions a number of times. A quantification expression can be unrolled and implemented with a large number of general purpose states in series. In an example however special purpose hardware elements e.g. other elements such as a counter can be used to take advantage of the repeated expressions in a quantification expression to reduce the number of states used to implement the quantification expression.

Quantifications are well known in the art and are used to describe repeated patterns. As an example A B n1 n2C is a general regular expression where A B and C are sub expressions and B n1 n2 comprises a quantification. As described herein upper case letters are used to represent regular expressions or a portion of a regular expression e.g. a sub expression . Double quotation marks may be added around regular expressions or sub expressions to avoid confusion. Accordingly an upper case letter describing an expression can correspond to a search string for multiple input symbols. For example the expression A can correspond to the input string abbc .

Moreover it should be understood that the terms expression and sub expression are used herein for relational description only e.g. a sub expression is a portion of an expression and that the terms expression and sub expression should not be limited to any specific length syntax or number of characters. In particular source code can include a large number of characters including meta characters and search characters of which the entire set of characters or any individual portion thereof can be considered an expression . For example each of the following can be considered an expression a bb d 5 20c b 0 10 b d and b .

A quantification is expressed in regex as B n1 n2 where B is a sub expression and n1 and n2 are integers specifying how many times the preceding sub expression is allowed to occur. B is referred to herein as a repeated sub expression since B is a sub expression that is repeated the number of times specified by n1 and n2. To match the quantification B n1 n2 the repeated sub expression B must be matched from n1 to n2 number of times. For example the regex B 5 7 would require the sub expression B to be matched 5 6 or 7 times. In the regex A B n1 n2C the sub expression A is referred to herein as a drive expression since the sub expression A when matched transitions to a quantification. Additionally to continue repeating and incrementing the count for the quantification the repeated sub expression s of the quantification must be matched consecutively. That is when a repeated sub expression is not matched during a given loop of the quantification the quantification ends. In an example the symbol also corresponds to quantification where the symbol preceding the can be identified either one or zero times.

When the target device is the FSM engine the method can identify and map certain quantifications to the counters on the FSM engine . Implementing certain quantifications with the counters can result in efficiencies over implementing the quantifications with the state machine elements . Accordingly the automaton and the resulting image for the FSM engine can be simplified. For example portions of the syntax tree implementing quantifications can require a large amount of SMEs to implement. In an example however some of these quantifications can be implemented using a counter with fewer states than would be required by SMEs .

At block the compiler identifies portions of the syntax tree that correspond to a quantification for possible implementation with the counters in the FSM engine . If the portion of the syntax tree does not correspond to a quantification the method proceeds to block where the portion is converted into general purpose states for implementation with SMEs . If the portion of the syntax tree does correspond to a quantification the quantification is further analyzed to determine whether the identified portion can be implemented with the counters .

Prior to making the determination of whether a quantification can be possibly implemented with a counter if the language of pattern B i.e. all strings that B matches written as B includes empty string the quantification of Bn1 n2 is rewritten as B 0 n2 where B is the non empty string version of B B B . For example bc 10 20 can be rewritten to bc 0 20 since these regexes accept the exact same data. Then for a given quantification Bn1 n2 the quantification can possibly be implemented with a counter method proceeds to block or alternatively implemented with SMEs and no counter method proceeds to block according to the following conditions 

At block once the compiler has identified a quantification that can possibly be implemented with a counter the compiler determines whether a portion of the syntax tree corresponding to the identified portion is deterministic. When the identified portion is deterministic the identified portion can be implemented with one or more counters and the method proceeds to blocks and where the identified portion is converted into one or more counter states along with one or more SME states. When the identified portion is non deterministic the identified portion is not implemented using a counter and the method proceeds to block where the identified portion is unrolled using one or more SME states as described below with respect to .

Generally block and blocks correspond to the two ways to convert a quantification into an automaton. At block the quantification is converted using one or more counter states possibly in conjunction with one or more SME states to implement the quantification as a loop. At blocks the quantification is converted by unrolling the quantification which includes using SME states and no counter states. Unrolling comprises rewriting the quantification with non quantification syntax. For example the regex b c 1 2 can be unrolled as b c b c . The merits of unrolling include 1 the resulted automaton is a directed acyclic graph DAG and can be easy to analyze and implement and 2 the resulting automaton can be implemented with general purpose elements especially state machine elements instead of special purpose elements. However the number of general purpose states and thus state machine elements used to implement the unrolled quantification is linear to n1 and n2. Thus the number of states may be large when n1 or n2 is a large number. In particular real life resources are limited thus in some examples this unrolling technique is used for only a limited category of quantifications. More detail regarding unrolling a quantification is provided below with respect to blocks and .

When the target device however has a special purpose element designed to implement a counting function such as a counter unrolling can be avoided in certain instances. The merit of this method is that fewer copies of a repeated expression are needed in the automaton and the number of copies is independent of n1 and n2. Therefore significant resources can be saved. For example one or more counters can be used to implement the quantification by creating a loop with the repeated expression s and the one or more counters . Each time the repeated expression s is matched a counter can be incremented or decremented . The repeated expression s can then be re activated to search for another match. When the counter has be incremented or decremented equal to a number of times stated by the quantification the counter can activate the state s following the quantification. Accordingly the quantification can be implemented with fewer SMEs since the SMEs used to implement the repeated expression s are re used. However due to the parallelism of the entire automaton e.g. corresponding to the entire syntax tree that is multiple states that can be active at the same time the counters in some examples can only be used with quantifications that correspond to deterministic portions of the entire automaton.

The regex A B n1 n1C is converted into a several SME states and a counter state . The SME states correspond to the sub expressions A B and C . The SME states can be implemented with SMEs while the counter state can be implemented with a counter . When the automaton is implemented on the FSM engine a counter corresponding to the counter state is initially loaded with the value n1 and set to assert the zero count output when the value in the counter reaches zero. When n1 equals n2 the counter can be set to Stop 0 and Pulse Output mode which means that the counter will assert its output once its value reaches zero and the counter will remain at zero and not issue any signal until the counter is reset.

The automaton begins at state and transitions to state upon matching the sub expression A . While at state each time the sub expression B is matched the IN port of the counter state is activated and the counter state decrements by one. Additionally each time the sub expression B is matched state activates itself as well as activating state . When the counter state reaches zero the output is activated and the automaton will then search for the sub expression C . In the following cycle two scenarios will occur the first scenario occurs when B is matched. When B is matched the counter state is reset and its value is set back to n1. Accordingly the next time the sub expression A is matched the process starts over from state . In the second scenario the self loop of state is still active and the IN port of the counter continues to be triggered on a match of the sub expression B . Since the counter state is configured in pulse mode the counter state will not activate its output again although the self loop of state remains active.

The negated version of the sub expression B is also referred to herein as B . In an example the negated version of the sub expression B is used to activate the reset port of the counter state . This is because since B is the repeated expression of the quantification B n1 n1 when anything other than B e.g. the negated version of B is received at the input once state has been activated the quantification ends and the counter is accordingly reset. Accordingly once state is activated the counter state is reset and the quantification is not matched when the negated version of the sub expression B is matched. In an example the repeated expression s are negated using standard automaton theory.

Although a single counter state is illustrated and described to implement a quantification when n1 equals n2 it should be recognized that multiple counters can be cascaded as to account for numbers larger than supported by a single counter .

The counter state is initially set to n1 and the counter state is initially set to n2. The automaton transitions from state to state when the sub expression A is matched. Once state is activated the IN port of both counter state and counter state are activated each time that the sub expression B is matched. Accordingly both counter state and counter state are decremented by one. When counter state reaches zero its output is activated and the automaton then searches for a match of the sub expression C and activate state . Once the sub expression B has been matched n1 times the value of the counter state is n2 n1. Later on each time that the sub expression B is matched the IN port of counter state is activated and value of counter state remains at zero and its output is still activated. Meanwhile the counter state continues to be decremented. When the sub expression B is matched n2 times the counter state also reaches zero and its output is activated which drives the reset port of counter state . Since the counter state to counter state latency is two cycles the counter state continues activating its output to state . In the next cycle the counter state is reset from the output of counter state and no output is asserted from the counter state . In the following cycle two scenarios will occur. In the first scenario B is matched. Both counter state and counter state are reset by state and their values are set to n1 and n2 respectively. Accordingly the next time state is active and the next time the sub expression A is matched state is activated and the counter states being decrementing again. In the second scenario the self loop of state remains activated and both counter states IN ports are activated. Since the counter state continually activates its output the counter state is continually reset and does not activate its output as long as the self loop of state is active.

In addition a match of the sub expression B while state is active activates the state . Once state is activated and B is matched the counter states are reset and the quantification is not matched. The negated version of the sub expression B is used since B is the repeated expression of the quantification B n1 n2 . Accordingly the expression B at state can be matched repeatedly for from n1 to n2 number of times. Although a single counter is illustrated and described to implement the lower e.g. n1 and upper e.g. n2 thresholds respectively it should be recognized that multiple counters can be cascaded as known to those skilled in the art to count for numbers larger than supported by a single counter.

Prior to converting a quantification using a counter state the compiler at block determines whether an automaton corresponding to the quantification is deterministic. In an example the automaton is deterministic when the expression meets both the no prefix the no re entrance conditions discussed below. That is in order for a quantification to be mapped to a counter the quantification should meet the no prefix and no re entrance conditions as discussed below.

Referring to automaton of the no re entrance condition requires that the edge from state to state cannot be activated while the counter state is active e.g. while the counter state is counting . That is it is determined whether the drive expression for the quantification can be matched while the quantification is already being processed. Matching a drive expression means that the states immediately prior to the quantification will transition to the states corresponding to the quantification. Accordingly the quantification will be re entered while a counter state is still processing a repeated expression. Since in this example of the FSM engine a counter can only implement a single loop at any given time transitioning to a quantification while a loop is already being processed can cause the counter to count incorrectly during a given loop.

The automaton corresponds to the regular expression abb b c 1 2 and includes a starting state and final states . The final states are identified in as double circles. The starting state is initially activated and transitions to state upon the input symbol a . State transitions to both state and state on the input symbol b . State transitions to state on the input symbol b and state transitions to state on either the input symbol b or c . The automaton transitions from state to state on either the input symbol b or c .

The automaton comprises the automaton for the regex abb b c 1 2 which is to be checked for compliance with the no re entrance condition. The automaton comprises the automaton of the derived regex SS abb b c 2 from the regex abb b c 1 2 of automaton . SS M N is defined as a regex derived from M N. The deriving steps include 1 concatenate M and N the result is denoted as MN . 2 Construct the automaton for MN denoted as A MN . 3 Modify A MN as following a Make the starting state of A MN drive all other states and b make all states corresponding to N as final states. Finally 4 denote the regex for the modified automaton as SS M N . The accepted data of SS M N is composed of the sub strings that start from any state of MN and end at any state of N.

The no re entrance condition can be defined as follows. Given a regular expression with a quantification ABn1 n2C the no re entrance condition requires that SS A Bn1 n2 A . In other words once the sub expression A is matched and the counter state begins to count to meet the no re entrance condition the edge from state to state will not be activated again until Bn1 n2 is done either match or fail . For example abb abb SS abb b c 2 and thus abb b c 1 2 will not be correctly implemented with a counter .

Referring now to the no prefix condition will be explained with reference to the automaton . The no prefix condition states that any string of B should not be the prefix of another string of B which is to guarantee that B does not cause the counter s to count more than once. In other words a quantification is not implemented as and thus converted to a counter when a first repeated sub expression of the quantification is a prefix of a second repeated sub expression of the quantification. The formal statement is For all l l B l l we require l l .

For example the regex a b bc 3 does not meet the no prefix condition. Accordingly the regex a b bc 3 would not be converted using a counter state and thus would not be implemented with a counter . Instead the regex a b bc 3 would be converted into general purpose states without any counter states.

If the regex a b bc 3 were implemented with a counter the input abbc would be falsely matched. For example the automaton is the result of a hypothetical conversion of the regex a b bc 3 using a counter state . As described below this conversion results in incorrect performance of the counter state . State is initially activated and at the input a state activates state . With state activated at the input b state activates states and re activates itself state . Also at the input b state activates the IN port of the counter where the initial value of the counter state is at 3 and is then reduced to 2. With the states and activated the IN port of the counter state is activated by state again at another input b and the value in the counter state is reduced to 1. At this point state and are activated. Then an input value c causes the IN port of the counter state to be activated by state to reduce the value in the counter to 0. With the value in the counter at zero the output is activated and state is activated indicating a match. This match however is a false positive since the input abbc has caused a match when the sequence abbc does not meet the regex a b bc 3 . Accordingly the regex a b bc 3 does not meet the no prefix condition and should not be converted using a counter state and implemented with a counter .

If the quantification meets both the no prefix condition and the no re entrance condition at block then the quantification is converted using a special purpose counter state at block . The quantification can be converted as described with respect to above. If however the quantification does not meet either the no prefix or the no re entrance condition the quantification is converted at blocks by unrolling the quantification and converting to general purpose states and no counter state . The quantification is accordingly implemented with SMEs and not a counter .

Referring back to block a quantification that can be matched with a single number of loops is unrolled to form an automaton having a plurality of the repeated sub expressions linked serially. A quantification having a single number of loops corresponds to a quantification where n1 equals n2. The quantification Bn1 for example can be unrolled as BB . . . B having n1 copies of B.

At block a quantification that can be matched with a multiple number of loops is unrolled when n1 does not equal n2 and when n1 equals 1 and n2 is greater than 1. When n1 is greater than 1 the quantification is split into a first quantification that can be matched with n1 1 number of loops and a second quantification that can be matched with from one to n2 n1 1 numbers of loops. For example the quantification Bn1 n2 where n1 1 n2 1 and n1

The second quantification B1 n2 n1 1 can be unrolled based on the in degree and or out degree of the resulting automaton. Unrolling a quantification can create states that have a large in degree or a large out degree. In an example in degree corresponds to the number of transitions to a state of the automaton and out degree corresponds to the number of transitions from a state of the automaton. Accordingly the second quantification can be unrolled to control the transitions into the in degree or out of the out degree states when converting the second quantification into an automaton. For example the quantification can be unrolled to limit the in degree of each unrolled state to below a threshold number. Limiting the in degree can be performed for example to take into account aspects and or limitations of elements in the target device. Moreover limiting the in degree during unrolling can reduce the subsequent processing for the compiler.

In an example when unrolling the quantification B1 n2 n1 1 the automaton is generated as a trade off between in degree and out degree. Accordingly reducing the in degree may increase the out degree and reducing the out degree may increase the in degree. In an example to unroll the loop structure of the quantification B1 n2 n1 1 a number of transitions are made either to or from the unrolled states to make the automaton accept any string of k concatentated B where l

Although method is described as corresponding to a single quantification method can be repeated for a plurality of quantifications within a syntax tree and the resulting separate automatons can then be linked into a larger automaton.

In an example an expression having a quantification is unrolled to limit one of the out degree or the in degree to less than a threshold. In an example to unroll the expression AB1 n1 to limit the in degree to a threshold a number of transitions for the quantification B1 n1 up to the threshold can be assigned as in transitions to the last state of the quantification B1 n1 and other transitions can be assigned as out transitions for the first state of the quantification B1 n1. Conversely to unroll an expression AB1 n1 to limit the out degree to a threshold a number of transitions for the quantification B1 n1 up to the threshold can be assigned as out transitions to the first state for the quantification and other transitions can be assigned as out transitions for the last state of the quantification B1 n1.

In other examples the in degree and out degree of an expression can be set to be certain ratio e.g. 1 to 1 2 to 1 of each other. In yet other examples the in degree and out degree of an expression can be set to be a certain ratio of each other up until a threshold is reached for either the in transitions or out transitions and then another ratio can be used or all of the transitions can be assigned as in transitions or out transitions respectively.

A netlist is a connectivity instance where instances correspond to hardware elements and directed edges are nets connecting the hardware elements. If a state drives another state there would be an electrical connection between the SMEs to which these two states are assigned. Most physical devices have some limit on the number of connections between hardware components. To get a feasible mapping from an automaton to the physical device the automaton has to be transformed such that in degrees of all states meet the hardware connection limits.

As noted above the compiler determines which SMEs can be grouped together based on the limitations of the FSM engine if any. Accordingly for the GOT the compiler determines which SMEs can be paired together based on the output limitations for the SMEs in GOT .

In one such embodiment the FSM engine has limited connection for all hardware components. To get a feasible mapping from an automaton to the FSM engine the automaton has to be transformed such that in degrees of all states meet the connection limits.

In an example therefore the in degree of an automaton can be limited based on hardware constraints of the target device. In an example a two level scheme can be used with FSM engine to limit the drive in of SMEs . First one can leverage the OR gates provided by GOT which will reduce the in degree by at most 50 by pairing up outputs from SME states into a single output. The other component is Boolean which can be configured to provide complex logical functions. In this example we only consider it as a simple OR component. In the below algorithm we estimate the usage of GOTs in a conservative way. In the algorithm when the estimated in degree is greater than the constraints of the FSM engine some states are split into multiple states or a Boolean OR is inserted to reduce the in degree as needed.

The basic idea of state splitting is to split a state into multiple states and distribute the drive in of the pre split state to the split states so that the in degree of each split state meets the constraints. When the automaton is a directed acyclic graph DAG a simple breadth first traversal of the automaton can solve the problem. When loops e.g. quantifications exist however splitting may increase the number of states exponentially or may create a situation where no feasible solution is possible. Boolean logic can help reduce the increased states and thus alleviate this situation. In one embodiment a Boolean OR or its equivalent is used to handle loop conditions.

An example of splitting states is shown in . In the example shown in eight states feed one state which in turn feeds two states . As shown in a state split as detailed above results in the addition of two new states C and C . Now three states however feed the two states .

Referring back to a GOT has output limitations on the SMEs . In particular the GOT has a single output shared by the two SMEs . Accordingly each SME in a GOT cannot independently drive the output . This output limitation restricts which SMEs states can be paired together in a GOT instance. Notably two SME states that drive e.g. transition to activate different sets of external SME states e.g. SME states corresponding to SMEs outside of the GOT instance cannot be paired together in a GOT instance. This limitation however does not restrict whether the two SMEs states drive each other or self loop since a GOT can internally provide this functionality with the switches . Although the FSM engine is described as having certain physical design corresponding to the SMEs in other examples the SMEs may have other physical designs. For example the SMEs may be grouped together into three or more sets of SMEs . Additionally in some examples there may be limitations on the inputs to the SMEs with or without limitations on the outputs from the SMEs .

In any case however the compiler determines which SME states can be grouped together based on the physical design of the FSM engine . Accordingly for a GOT instance the compiler determines which SME states can be paired together based on the output limitations for the SMEs in a GOT . In an example there are five situations in which two SME states can be paired together to form a GOT based on the physical design of the GOT .

The first situation when a first and a second SME state can be paired together in a GOT occurs when neither the first or second SME state are final states and when one of the first and second SME states does not drive any states other than the first or second SME states. As an example a first state is considered to drive a second state when the first state transitions to the second state. When this first situation occurs at most one of the first and second SME states is driving an external state s . Accordingly the first and second SME states can be paired together without being affected by the output limitations of the GOT . Due to the ability of the GOT to couple the SMEs to one another internally however the first and second SME states are allowed to drive each other and self loop to drive themselves. In automaton terms the first SME state corresponding to state q1 and the second SME state corresponding to state q2 can be paired together when neither q1 nor q2 are final states and q1 q1 q2 is empty or when q2 q1 q2 is empty.

The second situation when a first and a second SME state can be paired together in a GOT occurs when neither the first or second SME state are final states in the automaton and when both the first and the second SME state drive the same external states. As used herein external states correspond to states outside of the GOT instance for example notwithstanding whether first and second SME states in a GOT instance drive each other or self loop. Here again the output limitations of a GOT do not affect the first and second SME states since the first and second SME states drive the same external states. Also due to ability of the GOT to couple the SMEs to one another internally the restriction on driving the same states does not include whether the first and second states drive each other or self loop. Using automaton terms the first SME state corresponding to state q1 and the second SME state corresponding to state q2 can be paired together when neither q1 nor q2 are final states and q1 q1 q2 q2 q1 q2.

The third and fourth situations in which a first and a second SME state can be paired together in a GOT occur when one of the first and second SME state are a final state and the other of the first and second SME state does not drive any external state. That is the first SME state corresponding to state q1 and the second SME state corresponding to state q2 can be paired together when q1 is a final state and q2 q1 q2 is empty or when q2 corresponds to a final state and q1 q1 q2 is empty. Since a final state outputs an indication of a match to a regex a SME state corresponding to a final state should have independent use of the output of the GOT in order to indicate the match. Accordingly the other SME state in the GOT is not allowed to use the output .

The fifth situation when a first and a second SME state can be paired together in a GOT occurs when both the first and second SME states correspond to final states in an automaton and both the first and the second SME states drive the same external states. Using automaton terms the first state corresponding to state q1 and the second SME state corresponding to state q2 can be paired together when both q1 and q2 are final states and q1 q1 q2 q2 q1 q2.

Once the compiler determines whether one or more SME states can be paired together the compiler pairs the SMEs states into GOT instances. In an example the compiler pairs SME states into GOT instances in the order they are determined to be capable of being paired to form a GOT instance. That is once two particular SME states are determined to be capable of being paired together these two SME states can be paired into a GOT instance. Once two SME states have been paired to form a GOT instance these paired SME states are not available for pairing with other SME states. This process can continue until there are no longer any SME states left to be paired.

In an example the compiler uses graph theory to determine which SMEs to pair together into a GOT instance. Since only certain SMEs can be paired together some SME pairing can result in other SMEs having to be implemented in their own GOT instance with the other SME location in the GOT instance unused and hence wasted. Graph theory can be used to optimize SME utilization e.g. reduce the number of unused SMEs in the GOTs by reducing the number of unused SME instances in the GOT instances of the netlist. To use graph theory the compiler first determines all possible pairings between the SME states according to the physical design of the FSM engine discussed above. The compiler then creates a graph where the vertices of the graph correspond to SME states and the edges of the graph correspond to possible pairings of the SME states. That is if two SME states are determined to be capable of being paired together in a GOT instance the two corresponding vertices are connected with an edge. Thus the graph contains all the possible pairings of SME states.

The compiler can then find matching vertices for the graph to identify which SME states to pair together in a GOT . That is the compiler identifies edges and therefore pairs of vertices such that no two edges between matching vertices of the graph share a common vertex. In an example the compiler can find a maximal matching for the graph. In another example the compiler can find a maximum matching for the graph. A maximum matching is a matching that contains the largest possible number of edges. There may be many maximum matchings. The problem of finding a maximum matching of a general graph can be solved in polynomial time.

Once all the matching vertices have been identified e.g. as a maximum matching each pair of SME states corresponding to matching vertices is mapped to a GOT instance. SME states corresponding to vertices that are un matched are mapped to their own GOT instance. That is SME states corresponding to vertices that are un matched are mapped into one of SME location in GOT instance and the other SME location in the GOT instance is unused. Accordingly given the netlist N and its corresponding set of matching vertices M a number of GOT instances of N used equals Q 1 M where Q is the set of states of the automaton and 1 is because in this example the starting state of the automaton does not correspond to an SME state.

In an example the netlist N is constructed from the maximum matching M of G uses the least number of GOT instances. This can be proved by the following if there exists another netlist N that uses a lesser number of GOT instances denote the corresponding matching as M . Since the number of GOT instances of N equals Q 1 M we have that M 

Once the SME states are paired into GOT instances the GOT instances counter instances and logic instances are connected according to the transitions between the states in the automaton. Since each GOT has a single output each GOT instance in the netlist has a single output port to connect to other instances. Accordingly if either SME state in a first GOT instance drives an SME state in a second GOT instance the output port of the first GOT instance is coupled to an input of the second GOT instance.

Method examples described herein can be machine or computer implemented at least in part. Some examples can include a computer readable medium or machine readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code such as microcode assembly language code a higher level language code or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further the code may be tangibly stored on one or more volatile or non volatile computer readable media during execution or at other times. These computer readable media may include but are not limited to hard disks removable magnetic disks removable optical disks e.g. compact disks and digital video disks magnetic cassettes memory cards or sticks random access memories RAMs read only memories ROMs and the like.

Thus other embodiments can be realized. For example an article of manufacture such as a computer a memory system a magnetic or optical disk some other storage device or any type of electronic device or system can include one or more processors coupled to a computer readable medium such as a memory e.g. removable storage media as well as any memory including an electrical optical or electromagnetic conductor having instructions stored thereon e.g. computer program instructions which when executed by the one or more processors result in performing any of the actions described with respect to the methods above.

The computer can take the form of a computer system having a processor coupled to a number of components directly and or using a bus . Such components can include main memory static or non volatile memory and mass storage . Other components coupled to the processor can include an output device such as a video display an input device such as a keyboard and a cursor control device such as a mouse. A network interface device to couple the processor and other components to a network can also be coupled to the bus . The instructions can further be transmitted or received over the network via the network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP . Any of these elements coupled to the bus can be absent present singly or present in plural numbers depending on the specific embodiment to be realized.

In an example one or more of the processor the memories or the storage device can each include instructions that when executed can cause the computer to perform any one or more of the methods described herein. In alternative embodiments the computer operates as a standalone device or can be connected e.g. networked to other devices. In a networked environment the computer can operate in the capacity of a server or a client device in server client network environment or as a peer device in a peer to peer or distributed network environment. The computer can include a personal computer PC a tablet PC a set top box STB a Personal Digital Assistant PDA a cellular telephone a web appliance a network router switch or bridge or any device capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that device. Further while only a single computer is illustrated the term computer shall also be taken to include any collection of devices that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The computer can also include an output controller for communicating with peripheral devices using one or more communication protocols e.g. universal serial bus USB IEEE 1394 etc. The output controller can for example provide an image to a programming device that is communicatively coupled to the computer . The programming device can be configured to program a parallel machine e.g. parallel machine FSM engine . In other examples the programming device can be integrated with the computer and coupled to the bus or can communicate with the computer via the network interface device or another device.

While the computer readable medium is shown as a single medium the term computer readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database or associated caches and servers and or a variety of storage media such as the processor registers memories and the storage device that store the one or more sets of instructions . The term computer readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the computer and that cause the computer to perform any one or more of the methodologies of the present invention or that is capable of storing encoding or carrying data structures utilized by or associated with such a set of instructions. The term computer readable medium shall accordingly be taken to include but not be limited to tangible media such as solid state memories optical and magnetic media.

The Abstract is provided to comply with 37 C.F.R. Section 1.72 b requiring an abstract that will allow the reader to ascertain the nature and gist of the technical disclosure. It is submitted with the understanding that it will not be used to limit or interpret the scope or meaning of the claims. The following claims are hereby incorporated into the detailed description with each claim standing on its own as a separate embodiment.

Example 1 includes a computer including a memory having instructions stored thereon. The computer also includes a processor communicatively coupled to the memory wherein the instructions when executed by the processor cause the processor to convert source code into an automaton comprising states and transitions between the states wherein the states in the automaton include a special purpose state that corresponds to a special purpose hardware element. The instructions also cause the processor to convert the automaton into a netlist and place and route the netlist to provide machine code for configuring a target device.

Example 2 includes a computer implemented method including parsing using one or more processors source code into a syntax tree. The method also includes converting using the one or more processors the syntax tree into an automaton wherein the automaton defines a model of behavior having a plurality of states and transitions between the plurality of states and wherein the automaton structure is dictated by a target hardware device. The method also includes converting using the one or more processors the automaton into a netlist wherein the netlist includes a plurality of instances each instance corresponding to a hardware element of a target device. The method also includes placing using the one or more processors each of the instances wherein placing includes assigning each instance in the netlist to a hardware element of the target device. The method also includes routing using the one or more processors the connections between the hardware elements as a function of the netlist and creating programming data used to program the target device based on placing and routing.

Example 3 includes a programmable device including a plurality of programmable elements including one or more inputs and one or more outputs. The programmable device also includes an input block and an output block for interfacing a portion of the plurality of programmable elements to external circuits. The programmable device also includes a plurality of programmable switches communicatively connecting the plurality of programmable elements and the input block and the output block wherein the setting of one or more programmable switches selectively controls signal routing between any two or more of the plurality of programmable elements and the plurality of programmable switches. The programmable device also includes a plurality of registers configured to store programmable data capable of configuring the plurality of programmable elements and the plurality of programmable switches wherein the programming data is created by parsing using one or more processors source code into a syntax tree converting using the one or more processors the syntax tree into an automaton wherein the automaton defines a model of behavior having a plurality of states and transitions between the plurality of states and wherein the automaton structure is dictated by a target hardware device converting using the one or more processors the automaton into a netlist wherein the netlist includes a plurality of instances each instance corresponding to a hardware element of a target device placing using the one or more processors each of the instances wherein placing includes assigning each instance in the netlist to a hardware element of the target device routing using the one or more processors the connections between the hardware elements as a function of the netlist and creating programming data used to program the target device based on placing and routing.

Example 4 includes a computer readable medium including instructions which when implemented by one or more processors perform the following operations parse source code into a syntax tree convert the syntax tree into an automaton wherein the automaton defines a model of behavior having a plurality of states and transitions between the plurality of states and wherein the automaton structure is dictated by a target hardware device convert the automaton into a netlist wherein the netlist includes a plurality of hardware elements associated with the target device and wherein the netlist defines connections between the hardware elements place each of the hardware elements wherein placing includes assigning each hardware element in the netlist to a location within the target device route the connections between the hardware elements as a function of the netlist and create programming data used to program the target device to reflect placement and routing.

Example 5 includes a computer implemented method including parsing using one or more processors source code into a syntax tree converting using the converting using the one or more processors the syntax tree into an automaton wherein the converting includes restricting the automaton structure based on a target device wherein the target hardware device includes state machine elements paired into groups of two. The method also includes converting using the one or more processors the automaton into a netlist wherein the netlist includes a plurality of hardware elements associated with the target device and wherein the netlist defines connections between the hardware elements placing using the one or more processors each of the hardware elements wherein placing includes assigning each hardware element in the netlist to a location within the target device routing using the one or more processors the connections between the hardware elements as a function of the netlist and creating a plurality of bits used to program the target device to reflect placement and routing.

In Example 6 the subject matter of any of Examples 1 5 can optionally include wherein convert source code includes converting the quantification into a plurality of states including the special purpose hardware state when the quantification meets a condition to be mapped to a special purpose hardware element.

In Example 7 the subject matter of any of Examples 1 6 can optionally include wherein convert source code includes unrolling the quantification into a plurality of general purpose states when the quantification does not meet the condition to be mapped to a special purpose hardware element.

In Example 8 the subject matter of any of Examples 1 7 can optionally include wherein unrolling includes unrolling the quantification to control an in degree of the automaton.

In Example 9 the subject matter of any of Examples 1 8 can optionally include optimizing the automaton wherein optimizing includes splitting a particular state of the automaton into multiple states when an estimated in degree of the particular state is greater than the constraint of the target device.

In Example 10 the subject matter of any of Examples 1 9 can optionally include wherein splitting the particular state comprises distributing driving states of the particular state to the multiple states so that an in degree of each of the multiple states meets the constraint.

In Example 11 the subject matter of any of Examples 1 10 can optionally include wherein convert the automaton into the netlist includes mapping the states to instances of the netlist wherein mapping includes mapping the special purpose state to a special purpose instance corresponding to a special purpose element.

In Example 12 the subject matter of any of Examples 1 11 can optionally include wherein convert the automaton into a netlist includes grouping states together based on a physical design of the target device.

In Example 13 the subject matter of any of Examples 1 12 can optionally include wherein the instances include a state machine element SME instance corresponding to a SME hardware elements and a SME group instance corresponding to a hardware element comprising a group of SMEs and wherein grouping includes grouping states into a SME group instance.

In Example 14 the subject matter of any of Examples 1 13 can optionally include wherein converting the syntax tree into an automaton includes converting a quantification in the source code into a plurality of states including a special purpose state corresponding to a counter element of the target device.

In Example 15 the subject matter of any of Examples 1 14 can optionally include wherein a plurality of general purpose states corresponding to SMEs are grouped together to form a GOT instance based on an output limitation of a GOT hardware element.

In Example 16 the subject matter of any of Examples 1 15 can optionally include limiting the in degree of the automaton wherein limiting the in degree includes limiting a number of transitions into a state of the automaton.

In Example 17 the subject matter of any of Examples 1 16 can optionally include wherein limiting the in degree includes splitting a particular state into multiple states and distributing driving states of the particular state to the multiple states so that an in degree of each of the multiple states meets a constraint.

In Example 18 the subject matter of any of Examples 1 17 can optionally include wherein limiting the in degree includes unrolling a quantification into a plurality of unrolled states and limiting the number of in transitions for any of the unrolled states.

In Example 19 the subject matter of any of Examples 1 18 can optionally include wherein converting includes determining whether a quantification in the source code meets a condition to be mapped to a counter of the target device when the quantification meets the condition converting the quantification into a plurality of states including a counter state and when the quantification does not meet the condition converting the quantification into a plurality of SME states by unrolling the quantification.

In Example 20 the subject matter of any of Examples 1 19 can optionally include wherein determining whether the quantification meets the condition includes determining whether a drive expression for the quantification can be matched while the quantification is being processed.

In Example 21 the subject matter of any of Examples 1 20 can optionally include wherein determining whether the quantification meets the condition includes determining whether a repeated expression of the quantification is a prefix of another repeated expression of the quantification.

In Example 22 the subject matter of any of Examples 1 21 can optionally include wherein converting the quantification into a plurality of states including a counter state includes implementing the plurality of states as a loop comprising a repeated expression of the quantification and the counter state wherein the counter state is configured to count a number of times the repeated expression is matched and wherein the counter state activates a downstream state when the repeated expression is matched a number of times specified by the quantification.

In Example 23 the subject matter of any of Examples 1 22 can optionally include wherein unrolling includes unrolling the quantification to control an in degree of the automaton based on an in degree constraint of the target device.

In Example 24 the subject matter of any of Examples 1 23 can optionally include wherein converting includes restricting the automaton structure based on the groups of two sharing a common output.

In Example 25 the subject matter of any of Examples 1 24 can optionally include wherein restricting includes restricting the automaton structure based on a counter element of the target device.

In Example 26 the subject matter of any of Examples 1 25 can optionally include publishing the plurality of bits.

In Example 27 the subject matter of any of Examples 1 26 can optionally include optimizing the automaton to reduce the plurality of states.

Example 28 includes a parallel machine programmed by an image produced using the subject matter of any of claims .

