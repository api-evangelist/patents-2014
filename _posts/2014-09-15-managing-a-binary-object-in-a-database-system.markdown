---

title: Managing a binary object in a database system
abstract: A method for managing a binary object in a database system is provided. The method may include receiving a request to store the binary object and determining if a size of the binary object is above a first threshold. If the size is less than the first threshold, the method may include storing the binary object in a database of the database system using a database communication protocol. If the size is above the first threshold, the method may include determining if the size is above a second threshold. To this end, if the size is less than the second threshold, the method may include storing the binary object in a file system of the database system using the database communication protocol. Furthermore, if the size is above the second threshold, the method may include storing the binary object in the file system using a file system communication protocol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09336218&OS=09336218&RS=09336218
owner: Microsoft Technology Licensing, LLC
number: 09336218
owner_city: Redmond
owner_country: US
publication_date: 20140915
---
This application is a continuation of U.S. patent application Ser. No. 13 565 608 filed Aug. 2 2012 which is a division of U.S. patent application Ser. No. 12 784 508 filed May 21 2010 both of which are incorporated herein by reference in their entireties.

In database management systems a binary large object also referred to as a blob is a collection of binary data stored as a single entity. Typically blobs may be images audio or other multimedia objects though occasionally they may be executable code as well. When discussing the performance of a database management system reading writing storing and transferring blobs can present a significant issue.

Currently blobs may be conventionally stored inside a database file e.g. the varbinary datatype of SQL Server or inside a traditional file system. Storing and retrieving relatively large blobs inside the database may be inefficient because of extra overhead that is required to do so. Particularly the overhead required to store blobs in the database may increase as the size of the blob increases. In SQL the Filestream feature was created in order to avoid this extra overhead by allowing the storing of blobs in the file system e.g. disk storage. To this end file system blob storage may be associated with a constant overhead independent of blob size. However while storing blobs in the file system may stabilize overhead this overhead may nevertheless be prohibitive when storing smaller size blobs. As a result neither technique of storing blobs may by itself present an optimal method of managing blobs in a database system.

Described herein are implementations of various technologies for managing binary objects in a database system. While various protocols may exist to facilitate management of binary objects in database system their performance may vary widely depending on the size of the binary object. As such various technologies described herein may generally seek to determine and select a relatively efficient protocol to manage a binary object according to the size of the binary object.

At a high level several aspects of managing binary objects in a database system are encompassed within the various technologies described herein. A first aspect may focus on a method for storing a binary object in various locations using various protocols depending on the binary object size. To this end an application may receive a request from a user or other entity to store a binary object. The application may pass such a request to a provider that performs the actual management of binary object data. As such the provider may interface with both a database and a file system in communication with the database system. Thus the application may be free from having to know any particular implementations regarding any backend devices with which the provider may interface.

Under this method when storing a binary object the provider may first determine the size of the binary object. If the binary object size is below a first threshold the provider may store the binary object in the database using a database communication protocol. If the binary object size is above the first threshold but below a second higher threshold the provider may store the binary object in the file system using the database communication protocol. If the binary object size is above the second threshold the provider may store the binary object in the file system using a file system communication protocol. By storing relatively small sized binary objects in the database and storing relatively medium and large sized binary objects in the file system the method may facilitate relatively efficient storing of binary objects.

Another aspect may be related to the first aspect and may involve determining the size of the binary object if its size is not already known. To this end when a request to store a binary object is received the provider may initially begin buffering the data associated with the binary object in memory. The memory may be located on the same device as the application. If the size of the data buffered has reached the second threshold before the buffering is complete the provider may discontinue buffering and create a new binary object in the file system. The provider may then write the data in the buffer to the newly created binary object as well as write any additional data associated with the binary object directly to the new binary object.

If the data has been completely buffered before its size has reached the second threshold the provider can then determine the size of the binary object by determining the amount of data buffered. The provider may then store the binary object in the various locations using the various communication protocols according to the method described in the first aspect.

The above referenced summary section is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description section. The summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter. Furthermore the claimed subject matter is not limited to implementations that solve any or all disadvantages noted in any part of this disclosure.

In general one or more implementations described herein are directed to managing a binary object in a database system. Various techniques for managing a binary object in a database system will be described in more detail with reference to .

Implementations of various technologies described herein may be operational with numerous general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the various technologies described herein include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The various technologies described herein may be implemented in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that performs particular tasks or implement particular abstract data types. The various technologies described herein may also be implemented in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network e.g. by hardwired links wireless links or combinations thereof. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

The computing system may include a central processing unit CPU a system memory and a system bus that couples various system components including the system memory to the CPU . Although only one CPU is illustrated in it should be understood that in some implementations the computing system may include more than one CPU. The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus. The system memory may include a read only memory ROM and a random access memory RAM . A basic input output system BIOS containing the basic routines that help transfer information between elements within the computing system such as during start up may be stored in the ROM .

The computing system may further include a hard disk drive for reading from and writing to a hard disk a magnetic disk drive for reading from and writing to a removable magnetic disk and an optical disk drive for reading from and writing to a removable optical disk such as a CD ROM or other optical media. The hard disk drive the magnetic disk drive and the optical disk drive may be connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media may provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computing system .

Although the computing system is described herein as having a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that the computing system may also include other types of computer readable media that may be accessed by a computer. For example such computer readable media may include computer storage media and communication media. Computer storage media may include volatile and non volatile and removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media may further include RAM ROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM flash memory or other solid state memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computing system . Communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and may include any information delivery media. The term modulated data signal may mean a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media may include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above may also be included within the scope of computer readable media.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs program data and a database system . The database system may be configured to manage storing and retrieving binary objects and will be described in more detail with reference to in the paragraphs below. The operating system may be any suitable operating system that may control the operation of a networked personal or server computer such as Windows XP Mac OS X Unix variants e.g. Linux and BSD and the like.

A user may enter commands and information into the computing system through input devices such as a keyboard and pointing device . Other input devices may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices may be connected to the CPU through a serial port interface coupled to system bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device may also be connected to system bus via an interface such as a video adapter . In addition to the monitor the computing system may further include other peripheral output devices such as speakers and printers.

Further the computing system may operate in a networked environment using logical connections to one or more remote computers . The logical connections may be any connection that is commonplace in offices enterprise wide computer networks intranets and the Internet such as local area network LAN and a wide area network WAN . When using a LAN networking environment the computing system may be connected to the local network through a network interface or adapter . When used in a WAN networking environment the computing system may include a modem wireless router or other means for establishing communication over a wide area network such as the Internet. The modem which may be internal or external may be connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computing system or portions thereof may be stored in a remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

It should be understood that the various technologies described herein may be implemented in connection with hardware software or a combination of both. Thus various technologies or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the various technologies. In the case of program code execution on programmable computers the computing device may include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the various technologies described herein may use an application programming interface API reusable controls and the like. Such programs may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s may be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

Typically the user may interface with the application . For example the user may enter information into a form on a web page hosted by the application machine . After the user enters the information the application may generate a request to the provider to store such information as a binary object. Conversely the user may request to view information already stored in a binary object which may result in the application requesting the provider to retrieve the binary object. To this end binary objects may be stored in the database itself or in the file system . In some instances binary objects may be referred to as binary large objects or blobs.

In light of the interactions describe above while the application may interface with the user and the database at a high level the provider may perform the actual backend communications with the database and or the file system in regards to storing or retrieving binary objects. Thus the application may be prevented from having to know how the database and file system are implemented. Indeed the application may instead rely on the provider to provide such functionality. Such flexibility may enable the application to continue functioning properly even while backend devices in the database or file system may be changed. In one implementation the provider may be implemented for Remote Blob Storage RBS . RBS may refer to an application programming interface API that enables applications to store binary objects without being tied to any particular backend storage solution.

In another implementation the file system may be located remotely from the database and or the application machine and may be referred to as a remote blob store. As previously mentioned storing binary objects in the file system may be relatively efficient for relatively larger sized binary objects compared to relatively smaller sized binary objects. Furthermore the file system may be implemented using any type of storage solution including but not limited to hard disk drives magnetic tape drives solid state storage and optical disk mediums.

At step the provider may receive a request to store a binary object. Such a request may occur due to various circumstances as described above. For instance the user may interact with the application by entering information into a webpage hosted by the application machine . After the user enters the information a request may be sent to the application to store the information in a binary object. The application may then request the provider to perform the actual task of storing the binary object. It should be noted that there exist many paths that may result in the provider receiving the request to store a binary object and that the manner in which the provider receives the request is not limited to the example provided above.

At step the provider may determine if the size of the binary object is above a first threshold. At step if the size of the binary object is not above the first threshold the provider may store the binary object in the database using a database transfer protocol. In one implementation the first threshold may be approximately 60 Kilobytes. Under these circumstances the binary object may be considered relatively small in size. In another implementation the database communication protocol may be Tabular Data Stream TDS though various other communication protocols may also be used. Additionally when the binary object is stored in the database the binary object may be stored as an SQL varbinary data type.

At step if the binary object size is above the first threshold the provider may determine if the binary object size is above a second threshold. As such the second threshold may be larger than the first threshold. In one implementation the second threshold may be approximately 1.2 Megabytes. Under these circumstances the binary object may be considered relatively medium in size. At step if the binary object size is less than the second threshold the provider may store the binary object in the file system using the database communication protocol e.g. TDS . When the binary object is stored in the file system the binary object may be stored as an SQL Filestream data type.

At step if the binary object size is indeed above the second threshold the provider may store the binary object in the file system using a file system communication protocol. Under these circumstances the binary object may be considered relatively large in size. In one implementation the file system communication protocol may be Microsoft Server Message Block protocol SMB protocol though various other file system communication protocols may also be used.

At step the provider may receive a request to store a binary object. As previously mentioned such a request may occur as a result of the user interacting with the application which may then generate the request to the provider . At step because the size of the binary object may be unknown the provider may begin buffering the data that is to be included in the binary object to determine the size of the binary object. In one implementation the provider may buffer the binary object data in a memory located on the application machine .

At step the provider may determine if the size of the data associated with the binary object has reached the second threshold i.e. the second threshold of . If the size of the data has reached the second threshold then the binary object may be considered relatively large in size. Therefore at step the provider may create a new binary object in the file system e.g. a binary object of the Filestream data type. Furthermore the provider may then transfer the data that has been buffered into the newly created binary object using the file system communication protocol e.g. SMB protocol. Additionally at step any further data that is to be stored as part of the binary object may then be written directly to the newly created binary object on the file system .

At step if the data has been completely buffered before its size has reached the second threshold then the provider may determine the size of the binary object in the buffer. In one implementation the provider may keep a counter to track the size of the data as it is being buffered. Then at step the provider may determine whether the size of the binary object is above the first threshold i.e. the first threshold described in .

If the size of the binary object is not above the first threshold the provider may store the binary object in the database using the database communication protocol at step . For example the provider may store the binary object as an SQL Varbinary data type using the TDS protocol. At step if the binary object size is indeed above the first threshold the provider may store the binary object in the file system using the database communication protocol. For example the provider may store the binary object as an SQL Filestream data type using the TDS protocol.

Managing binary objects in the database system according to various technologies described above may have an advantage of storing binary objects in an efficient manner according to the size of the binary objects. For example storing a binary object in the database may be relatively efficient for binary objects relatively small in size but may grow increasingly inefficient with larger binary objects. Indeed storing blobs in the database may involve writing a separate copy to a database log. This overhead may therefore grow with binary object size.

Conversely storing binary objects in the file system may prove relatively efficient for binary objects of relatively medium and large size but may be inefficient for relatively small binary objects. For example storing a binary object as a Filestream data type may involve a constant overhead independent of the binary object size. However this overhead may be prohibitive in regards to storing relatively small binary objects. Therefore various technologies described herein may store binary objects of relatively medium and large sizes in the file system . As a result various technologies described herein may enable relatively small binary objects to be efficiently stored in the database and relatively larger binary objects to be efficiently store in the file system .

In addition buffering a binary object in memory when the size of the binary object is not known beforehand prevents certain overheads in storing relatively large binary objects. For example in typical implementations the entire binary object may first be cached on the application machine . In order to determine the size of the binary object the database may then be queried. Under this framework typical implementations would first need to store the binary object query the database for its size then choose the correct method of storage depending on the size. By buffering the binary object the provider may avoid writing the entire binary object before determining where to store it.

Furthermore various technologies described herein may provide for certain optimizations in managing a binary object in the database system . For example the size of a binary object may be associated with an identifier representing the binary object. In one implementation the size of a binary object may be encoded into a global unique identifier GUID associated with the binary object. A GUID may provide a unique reference number for each binary object and may be typically represented by 32 character hexadecimal string. However because various other information may also be encoded into the GUID the GUID may not be able to provide enough storage to encode the entire size of the binary object. Thus instead of encoding the exact size of the binary object which in some cases may take up to eight bytes the size may instead be compressed and then encoded. In one implementation the size may be compressed by taking the logarithm of the size of the binary object. As such the encoding of the binary object size may be reduced to approximately four bytes.

In another implementation buffering binary object data or any other data may be optimized for use in the .NET CLR framework. To this end in .NET CLR allocating or freeing space for data greater than 85 000 bytes may result in relatively severe performance issues. For example severe fragmentation of memory in the application machine may occur thereby decreasing overall performance of the database system . Therefore when transferring a binary object larger than 85 000 bytes the binary object may be divided into various buffers smaller than 85 000 bytes. These smaller buffers may be combined or stringed together to form the entire binary object. In one implementation when reading a binary object of a known size an array of array of buffers may be formed to compose the binary object. In another implementation when writing a binary object buffers may be added while writing until the entire binary object is written. These buffers may be stored in a single list. Thus the binary object may be transferred communicated or otherwise managed while avoiding the performance issues related to .NET CLR.

Another implementation may relate to determining the file path of a binary object stored in the file system when the binary object is queried or otherwise requested. In typical database systems each time a binary object is requested a query may be made to the database to discover its file path. Under the various technologies described herein the file paths associated with binary objects stored in the file system may contain a constant portion for all such binary objects and a variable portion that differs for each binary object. The constant portion may typically contain information such as the machine name share name database table and the like associated with the binary object. The variable portion may simply be the GUID of the binary object.

To this end when retrieving a binary object from the file system the provider may itself construct the file path associated with the binary object. Thus the provider may avoid querying the database for a binary object s file path each time the binary object is requested. The provider may discover the constant portion of the file path for every binary object by making a single query to the database when the provider is first initialized. The variable portion of a binary object s file path may be inferred from by the provider from the application requesting the binary object. Therefore after discovering the constant portion and variable portion the provider may simply combine both portions to construct the file path for the binary object.

In yet another implementation an optimization may be performed when handling a binary object using the file system communication protocol. Typically every time a binary object is read using the file system communication protocol the database may be queried for a parameter sometimes referred to as a transaction context. Under the various technologies provided herein the provider may instead keep track of a pool of read only transactions. For these transactions the provider may then cache their transaction contexts which may be applied when a binary object is read. Thus redundant queries to the database for transaction contexts may be avoided.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

