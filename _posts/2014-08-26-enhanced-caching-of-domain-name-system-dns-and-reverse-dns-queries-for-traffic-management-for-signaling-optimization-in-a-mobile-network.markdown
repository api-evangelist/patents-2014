---

title: Enhanced caching of domain name system (DNS) and reverse DNS queries for traffic management for signaling optimization in a mobile network
abstract: Methods, systems, and non-transitory computer readable media for enhanced domain name system (DNS) caching are disclosed. According to one aspect, a method for enhanced DNS caching includes, at a mobile device for operating in a wireless network, providing, within the mobile device, a local DNS cache that stores DNS-related queries and their respective responses received from a DNS server for responding to DNS-related queries issued from applications hosted within the mobile device, where each response received from the DNS server is associated with a first time-to-live (TTL) value for that response, and assigning to each query/response pair in the local DNS cache a second TTL value that is larger than that response's first TTL value, where the second TTL value is used in place of the first TTL value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09444916&OS=09444916&RS=09444916
owner: Seven Networks, LLC
number: 09444916
owner_city: Marshall
owner_country: US
publication_date: 20140826
---
This application claims the benefit of U.S. Provisional Patent Application Ser. No. 61 870 210 filed Aug. 26 2013 the disclosure of which is incorporated herein by reference in its entirety.

This disclosure relates to signaling optimization in telecommunication networks and data networks. More specifically it relates to methods and systems for reducing traffic to and from a mobile device via the implementation of enhanced caching of DNS and reverse DNS queries.

Domain Name System DNS records typically expire from a DNS resolver s cache typically managed by the device operating system after a short time to live TTL period specified in the record. The short time to live period allows web site administrators to change the IP addresses of their servers without worrying that users will try to contact the servers at the old addresses and receive an error. However when such requests are made over time in a mobile network the repeated queries consume mobile network resources and consume mobile device battery life.

This is a concern for mobile devices where resources are limited since the constant connections and disconnections increase the amount of signaling network traffic which lowers the performance of the network overall and puts the pressure on network operators and providers to increase network bandwidth and network access. To date carriers have been able to invest in 4G and LTE networks to boost network capacity in hotspots. However these solutions are only accessible in metropolitan areas and are reaching their limit LTE and 4G are also showing that the perceived capacity of added bandwidth is causing users and applications to increase usage and data consumption. In the long run it might add to the congestion problem rather than help.

While mobile or broadband networks may be designed for high throughput of large amounts of data they were not necessarily tailored to service the mobile applications that require frequent low throughput requests of small amounts of data. Existing networks also do not take into account different types of mobile traffic and priorities of the different types of traffic for example from a user experience perspective. The issue has been exacerbated by the rapid increase of the popularity of applications with network initiated functionalities such as push email news feeds status updates multimedia content sharing multimedia content streaming mobile games and other mobile applications etc. Furthermore mobile phones also rely on signaling to send and receive calls and SMS messages and sometimes the fundamental phone based functions are forced to take a backseat to mobile applications and other mobile clients.

According to one aspect the subject matter described herein includes a method for enhanced DNS caching. The method includes at a mobile device for operating in a wireless network providing within the mobile device a local DNS cache that stores DNS related queries and their respective responses received from a DNS server for responding to DNS related queries issued from applications hosted within the mobile device where each response received from the DNS server is associated with a first time to live TTL value for that response and assigning to each query response pair in the local DNS cache a second TTL value that is larger than that response s first TTL value where the second TTL value is used in place of the first TTL value.

According to another aspect the subject matter described herein includes a system for enhanced DNS caching. The system includes a mobile device for operating in a wireless network the mobile device including a local DNS cache for storing DNS related queries and their respective responses received from a DNS server and for providing responses to DNS related queries issued from applications hosted within the mobile device wherein each response received from the DNS server is associated with a first time to live TTL value for that response and a local DNS harmonizer component for assigning to each query response pair in the local DNS cache a second TTL value that is larger than that response s first TTL value wherein the second TTL value is used in place of the first TTL value.

According to yet another aspect the subject matter described herein includes a non transitory computer readable medium having stored thereon executable instructions that when executed by the processor of a computer control the computer to perform steps that include providing within the mobile device a local DNS cache that stores DNS related queries and their respective responses received from a DNS server for responding to DNS related queries issued from applications hosted within the mobile device where each response received from the DNS server is associated with a first time to live TTL value for that response and assigning to each query response pair in the local DNS cache a second TTL value that is larger than that response s first TTL value where the second TTL value is used in place of the first TTL value.

The following description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding of the disclosure. However in certain instances well known or conventional details are not described in order to avoid obscuring the description. References to one embodiment or an embodiment in the present disclosure can be but not necessarily are references to the same embodiment and such references mean at least one of the embodiments.

Reference in this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the disclosure. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover various features are described which may be exhibited by some embodiments and not by others. Similarly various requirements are described which may be requirements for some embodiments but not other embodiments.

The terms used in this specification generally have their ordinary meanings in the art within the context of the disclosure and in the specific context where each term is used. Certain terms that are used to describe the disclosure are discussed below or elsewhere in the specification to provide additional guidance to the practitioner regarding the description of the disclosure. For convenience certain terms may be highlighted for example using italics and or quotation marks. The use of highlighting has no influence on the scope and meaning of a term the scope and meaning of a term is the same in the same context whether or not it is highlighted. It will be appreciated that same thing can be said in more than one way.

Consequently alternative language and synonyms may be used for any one or more of the terms discussed herein nor is any special significance to be placed upon whether or not a term is elaborated or discussed herein. Synonyms for certain terms are provided. A recital of one or more synonyms does not exclude the use of other synonyms. The use of examples anywhere in this specification including examples of any terms discussed herein is illustrative only and is not intended to further limit the scope and meaning of the disclosure or of any exemplified term. Likewise the disclosure is not limited to various embodiments given in this specification.

Without intent to limit the scope of the disclosure examples of instruments apparatus methods and their related results according to the embodiments of the present disclosure are given below. Note that titles or subtitles may be used in the examples for convenience of a reader which in no way should limit the scope of the disclosure. Unless otherwise defined all technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art to which this disclosure pertains. In the case of conflict the present document including definitions will control.

Embodiments of the present disclosure include systems and methods for enhancing DNS caching to provide signaling optimization for application level traffic.

Embodiments of the present disclosure further include systems and methods for the reduction of mobile network traffic used for domain name system DNS queries.

There are multiple factors that contribute to the proliferation of data the end user mobile devices wireless devices mobile applications and the network. As mobile devices evolve so do the various elements associated with them availability applications user behavior location thus changing the way the network interacts with the device and the application.

The disclosed technology provides a comprehensive and end to end solution that is able to address each element for operators and devices manufacturers to support both the shift in mobile or wireless devices and the surge in data by leveraging the premise that mobile content has a definable or relevant freshness value. The freshness of mobile content can be determined either with certainty or with some heuristics having a tolerance within which the user experience is enhanced or not negatively impacted or negatively impacted but is either not perceptible to the user or within a tolerable threshold level.

The disclosed innovation transparently determines such freshness by monitoring analyzing and applying rules which may be heuristically determined the transactions requests responses between applications e.g. mobile applications and the peers corresponding server or other clients . Moreover the technology is further able to effectively cache content which may be marked by its originating host server as being non cacheable and identify some freshness value which can then be used in implementing application specific caching. In general the freshness value has an approximate minimum value which is typically determined using the update interval e.g. interval with which requests are sent between the application and its corresponding server host.

Domain Name System DNS records typically expire from a DNS resolver cache after a short time to live TTL period. This permits site administrators to change the IP addresses of their servers without worrying that users will try to contact those servers at the old addresses. Over time repeated queries consume network resources and consume battery life. This is a concern for mobile devices making DNS queries over mobile networks where bandwidth resources are already congested and limited.

In one embodiment records returned from a Domain Name System DNS server or host are cached in a manner which integrates with a local content caching system and in some instances also the web based service addressed in the DNS query. The caching and management thereof can be performed by a DNS harmonization component in a local proxy on a mobile device e.g. DNS harmonization component or of and respectively . The enhanced caching maintains and uses the cached DNS entries e.g. stored in a local cache or harmonization cache of for a time period that is longer than the TTL typical of a DNS resolver. The increased TTL allows for a reduction in the network traffic related to DNS queries. The increased TTL also prevents DNS queries from causing a radio on a mobile device from being powered up. When transactions following DNS queries are cached delayed clumped blocked and the like extending the TTL to the time period of operating on any transactions that the DNS request was for allows signaling optimization from the caching delaying clumping blocking and the like to be achieved. By employing enhanced DNS caching at the client side it can be ensured that DNS queries does not prevent management of application level traffic and signaling optimization. Further by employing distributed monitoring mechanisms of a DNS server or host e.g. DNS system of by a remote server e.g. the harmonization server of it can be ensured that mobile applications or clients on the mobile device have access to valid DNS records.

In one embodiment the enhanced caching for DNS related traffic reduction performs the following example steps 

In the TCP IP model an Internet connection utilizing a transmission control protocol TCP socket connection can specify a destination Internet protocol IP address for example 69.63.189.11 where a browser or application will typically use a human readable hostname identifier such as www.facebook.com . To convert from a hostname to an IP address the application or client can query the device platform e.g. the operating system for a domain name resolver e.g. DNS resolver to resolve or otherwise determine and identify the hostname. For example 

Note that the name server resides in the network and reaching it requires over the air traffic with radio access and battery consumption. To reduce this impact a resolver typically includes a resolver DNS cache of recent DNS responses and the entries are typically maintained for a short duration. The resolver DNS cache is typically maintained by the operating system and the time to live of the cache entries are either specified by the operating system or configured via the operating system. In general if an application tries to resolve a hostname twice within the time to live it can receive a cached response from the resolver DNS cache instead of needing to go over the air. For example 

2. Resolver to application That s in my cache already so I don t need to contact the Name server. You can open a socket to 69.63.189.11. 

However the time to live TTL of the DNS resolver cache e.g. DNS resolver cache shown in the example of is typically relatively low e.g. on the order of minutes 5 10 15 20 30 min This low TTL is generally what causes frequent DNS queries at a mobile device to go over the cellular network. For example if sequential requests are generated by local applications just above that setting e.g. every 10 15 20 25 30 45 or 60 minutes etc. the system DNS resolver cache e.g. DNS resolver cache of will provide no benefit with respect to radio state change and reduction of traffic used for DNS queries sent over the wireless network. One embodiment of the disclosed technology utilizes for example a harmonization component e.g. harmonization component of able to cache DNS records for longer periods of times e.g. 30 40 50 60 75 90 120 minutes etc. . The harmonization component is typically implemented locally on the mobile device and communicates with a remote server e.g. harmonization server of which monitors a host or service to determine if and when a cached DNS record needs to be purged or updated.

In this manner the DNS records maintained in the local cache on the local device can be used as long as the response from the actual DNS server or host has not changed as determined by the remote server or the harmonization server. This configuration and process allows the time period with which DNS records can be maintained by the harmonization component to be configurable and typically also dynamically adjustable depending on factors including but not limited to the predetermined lifetime per platform by the OS based on the requirement of a particular deployment application settings user preferences application characteristics device limitations network operator settings network operator policies or limitations and or application behavior and application characteristics.

As an example consider a Facebook application e.g. a mobile application on a mobile device that polls a URL e.g. api.facebook.com every 30 minutes in this scenario a polling task can be established at the Harmonization server to monitor responses to DNS queries. The initial DNS response for api.facebook.com may remain in the device s harmonization cache for the life of that polling task or for another specified duration. The harmonization cache entry can be reference counted using a counter so a second polling session referencing api.facebook.com will increment the counter e.g. reference count . The counter can be decremented on invalidate or in response to receipt of stop poll commands from the harmonization server. Entries may expire from the harmonization cache when the counter reaches a certain number or the age in the cache reaches a threshold e.g. 24 hours whichever comes first for example. Upon expiration the DNS entries may be automatically purged or marked as expired e.g. in accordance with one or more metrics . Once marked as expired the entries may be purged or purged upon verification that the entry is no longer valid relevant.

In one embodiment the enhanced DNS caching includes enhanced caching of DNS requests and reverse DNS requests. The enhanced DNS caching allows a mobile device to implement traffic management techniques for signaling optimization for application level traffic. For example when a transaction is cached to save on unnecessary network connections and conserve battery resources e.g. by not powering up or down a radio on a mobile device a DNS request for the cached transaction if cached at all or not cached long enough can cause a radio on the mobile device to be powered up to establish a connection to the network. This results in loss of the benefits form the caching of the transaction.

In an embodiment DNS caching can be extended to a time period of operating on any transactions that the DNS request was for. For example DNS requests for those transactions that are cached can also be cached for at least the duration of time for which the transactions are cached. This prevents DNS requests for the cached transactions from going out to the network. DNS caching can also be extended for other transactions such as cached HTTP transactions delayed or blocked HTTP transactions TCP socket openings and the like. For example if a transaction is being delayed for an hour the DNS caching can be extended to at least an hour or a period of time long enough to prevent a DNS request for the delayed transaction from causing the radio on the mobile device to be powered up to establish a connection to the network. Thus extending DNS caching enables a mobile device to implement traffic management techniques such as delaying blocking clumping or shaping of traffic e.g. application traffic user interactive traffic user non interactive traffic and the like for signaling optimization.

Communication over protocols such as Hyper Text Transfer Protocol Secure HTTPS is encrypted using the Secure Sockets Layer SSL or other protocols that use a combination of public key and or symmetric key encryption. An SSL session always begins with a handshake where messages are exchanged between a client and a server to agree on various parameters for establishing the security of a connection between the client and the server. When caching or operating on HTTPS requests the reverse DNS requests that are part of the SSL handshake can be cached. In an embodiment a local proxy of the distributed proxy and cache system can maintain a reverse mapping from IP addresses to host names to be able to know which IP addresses to cache for reverse DNS lookups. Caching of reverse DNS requests and maintaining the mapping prevent the reverse DNS request from causing a radio on a mobile device from going up when the HTTPS request can be satisfied with response from the cache and a connection need not be established between the mobile device and the server.

In some embodiments the disclosed proxy system is able to establish policies for choosing traffic data content messages updates etc. to cache and or shape. Additionally by combining information from observing the application making the network requests getting explicit information from the application or knowing the network destination the application is reaching the disclosed technology can determine or infer what category the transmitted traffic belongs to.

For example in one embodiment mobile or wireless traffic can be categorized as a1 interactive traffic or a2 background traffic. The difference is that in a1 a user is actively waiting for a response while in 2 a user is not expecting a response. This categorization can be used in conjunction with or in lieu of a second type of categorization of traffic b1 immediate b2 low priority b3 immediate if the requesting application is in the foreground and active.

For example a new update message or email may be in the b1 category to be delivered immediately but it still is a2 background traffic a user is not actively waiting for it. A similar categorization applies to instant messages when they come outside of an active chat session. During an active chat session a user is expecting a response faster. Such user expectations are determined or inferred and factored into when optimizing network use and device resources in performing traffic categorization and policy implementation.

Some examples of the applications of the described categorization scheme include the following a1 interactive traffic can be categorized as b1 immediate but a2 background traffic may also be b2 or b3 . An example of a low priority transfer is email or message maintenance transaction such as deleting email or other messages or marking email as read at the mail or application server. Such a transfer can typically occur at the earlier of a timer exceeding a timeout value for example 2 minutes and b data being sent for other purposes.

An example of b3 is IM presence updates stock ticker updates weather updates status updates news feeds. When the UI of the application is in the foreground and or active for example as indicated by the backlight of the device phone being lit or as determined or inferred from the status of other sensors updates can be considered immediate whenever server has something to push to the device. When the application is not in the foreground or not active such updates can be suppressed until the application comes to foreground and is active.

With some embodiments networks can be selected or optimized simultaneously for a1 interactive traffic and a2 background traffic.

In some embodiments as the wireless device or mobile device proxy separately or in conjunction with the server proxy is able to categorize the traffic as for example a1 interactive traffic or a2 background traffic it can apply different policies to different types of traffic. This means that it can internally operate differently for a1 and a2 traffic for example by allowing interactive traffic to go through to the network in whole or in part and apply stricter traffic control to background traffic or the device side only allows a request to activate the radio if it has received information from the server that the content at the host has been updated etc. .

When the request does require access over the wireless network the disclosed technology can request the radio layer to apply different network configurations to different traffic. Depending on the type of traffic and network this may be achieved by different means 

 2 Explicitly specifying network configuration for different data sets e.g. in terms of use of FACH forward access channel vs. DCH dedicated channel or otherwise requesting lower more network efficient data rates for background traffic or

 3 Utilizing different network access points for different data sets access points which would be configured to use network resources differently similar to 1 and 2 above .

Additionally 3GPP Fast Dormancy calls for improvements so that applications operating systems or the mobile device would have awareness of the traffic type to be more efficient in the future. Embodiments of the disclosed system having the knowledge of the traffic category and being able to utilize Fast Dormancy appropriately may solve the problem identified in Fast Dormancy. This way the mobile or broadband network does not need to be configured with a compromised configuration that adversely impacts both battery consumption and network signaling resources.

Detecting or determining a polling schedule allows the proxy server server side of the distributed cache system to be as close as possible with its polls to the application polls. Many applications employ scheduled interval polling e.g. every 4 hours or every 30 seconds at another time interval . The client side proxy can detect automatic polls based on time measurements and create a automatic polling profile for an application. As an example the local proxy attempts to detect the time interval between requests and after 2 3 4 or more polls determines an automatic rate if the time intervals are all within 1 second or another measure of relative closeness of each other. If not the client may collect data from a greater number of polling events e.g. 10 12 polls and apply a statistical analysis to determine compute or estimate a value for the average interval that is used. The polling profile is delivered to the server where it is used. If it is a frequent manual request the locally proxy can substitute it with a default interval for this application taken from a profile for non critical applications.

In some embodiments the local proxy e.g. device side proxy may keep monitoring the application client polls and update the polling interval. If it changes by more than 30 or another predetermined dynamic conditional value from the current value it is communicated to the proxy server e.g. server side proxy . This approach can be referred to as the scenario of lost interest. In some instances the local proxy can recognize requests made outside of this schedule consider them manual and treat them accordingly.

In some embodiments applications can be organized into three groups or modes of caching. Each mobile client application can be categorized to be treated as one of these modes or treated using multiple modes depending on one or more conditions.

A Fully cached local proxy updates e.g. sends application requests directly over the network to be serviced by the application server content host only when the proxy server tells the local proxy to update. In this mode the local proxy can ignore manual requests and the proxy server uses the detected automatic profile e.g. sports score applets Facebook every 10 15 30 or more polls to poll the application server content provider.

B Partially cached the local proxy uses the local or internal cache for automatic requests e.g. application automatic refreshes other scheduled requests but passes through some manual requests e.g. email download Ebay or some Facebook requests and

C Never cached e.g. real time stock ticker sports scores statuses however in some instances 15 minutes delayed quotes can be safely placed on 30 seconds schedules B or even A .

The actual application or caching mode classification can be determined based on the rate of content change and critical character of data. Unclassified applications by default can be set as class C.

In some embodiments the local proxy starts by detecting the device backlight status. Requests made with the screen light off can be allowed to use the local cache if a request with identical signature is registered with the proxy server which is polling the original host server content server s to which the requests are directed. If the screen light is on further detection can be made to determine whether it is a background application or for other indicators that local cache entries can or cannot be used to satisfy the request. When identified the requests for which local entries can be used may be processed identically to the screen light off situation. Foreground requests can use the aforementioned application classification to assess when cached data is safe to use to process requests.

The client devices can be any system and or device and or any combination of devices systems that is able to establish a connection including wired wireless cellular connections with another device a server and or other systems such as host server and or application server content provider . Client devices will typically include a display and or other output functionalities to present information and data exchanged between among the devices and or the host server and or application server content provider . The application server content provider can by any server including third party servers or service content providers further including advertisement promotional content publication or electronic coupon servers or services. Similarly separate advertisement servers A promotional content servers B and or e Coupon servers C as application servers or content providers are illustrated by way of example.

For example the client devices can include mobile hand held or portable devices wireless devices or non portable devices and can be any of but not limited to a server desktop a desktop computer a computer cluster or portable devices including a notebook a laptop computer a handheld computer a palmtop computer a mobile phone a cell phone a smart phone a PDA a Blackberry device a Palm device a handheld tablet e.g. an iPad or any other tablet a hand held console a hand held gaming device or console any SuperPhone such as the iPhone and or any other portable mobile hand held devices or fixed wireless interface such as a M2M device etc. In one embodiment the client devices host server and application server are coupled via a network and or a network . In some embodiments the devices and host server may be directly connected to one another.

The input mechanism on client devices can include touch screen keypad including single touch multi touch gesture sensing in 2D or 3D etc. a physical keypad a mouse a pointer a track pad motion detector e.g. including 1 axis 2 axis 3 axis accelerometer etc. a light sensor capacitance sensor resistance sensor temperature sensor proximity sensor a piezoelectric device device orientation detector e.g. electronic compass tilt sensor rotation sensor gyroscope accelerometer or a combination of the above.

Signals received or detected indicating user activity at client devices through one or more of the above input mechanism or others can be used in the disclosed technology in acquiring context awareness at the client device . Context awareness at client devices generally includes by way of example but not limitation client device operation or state acknowledgement management user activity behavior interaction awareness detection sensing tracking trending and or application e.g. mobile applications type behavior activity operating state etc.

Context awareness in the present disclosure also includes knowledge and detection of network side contextual data and can include network information such as network capacity bandwidth traffic type of network connectivity and or any other operational state data. Network side contextual data can be received from and or queried from network service providers e.g. cell provider and or Internet service providers of the network and or network e.g. by the host server and or devices . In addition to application context awareness as determined from the client side the application context awareness may also be received from or obtained queried from the respective application service providers by the host and or client devices .

The host server can use for example contextual information obtained for client devices networks applications e.g. mobile applications application server provider or any combination of the above to manage the traffic in the system to satisfy data needs of the client devices e.g. to satisfy application or any other request including HTTP request . In one embodiment the traffic is managed by the host server to satisfy data requests made in response to explicit or non explicit user requests and or device application maintenance tasks. The traffic can be managed such that network consumption for example use of the cellular network is conserved for effective and efficient bandwidth utilization. In addition the host server can manage and coordinate such traffic in the system such that use of device side resources e.g. including but not limited to battery power consumption radio use processor memory use are optimized with a general philosophy for resource conservation while still optimizing performance and user experience.

For example in context of battery conservation the device can observe user activity for example by observing user keystrokes backlight status or other signals via one or more input mechanisms etc. and alters device behaviors. The device can also request the host server to alter the behavior for network resource consumption based on user activity or behavior.

In one embodiment the traffic management for resource conservation is performed using a distributed system between the host server and client device . The distributed system can include proxy server and cache components on the server side and on the device client side for example as shown by the server cache on the server side and the local cache on the client side.

Functions and techniques disclosed for context aware traffic management for resource conservation in networks e.g. network and or and devices reside in a distributed proxy and cache system. The proxy and cache system can be distributed between and reside on a given client device in part or in whole and or host server in part or in whole. The distributed proxy and cache system are illustrated with further reference to the example diagram shown in . Functions and techniques performed by the proxy and cache components in the client device the host server and the related components therein are described respectively in detail with further reference to the examples of .

In one embodiment client devices communicate with the host server and or the application server over network which can be a cellular network and or a broadband network. To facilitate overall traffic management between devices and various application servers content providers to implement network bandwidth utilization and device resource e.g. battery consumption the host server can communicate with the application server providers over the network which can include the Internet e.g. a broadband network .

In general the networks and or over which the client devices the host server and or application server communicate may be a cellular network a broadband network a telephonic network an open network such as the Internet or a private network such as an intranet and or the extranet or any combination thereof. For example the Internet can provide file transfer remote log in email news RSS cloud based services instant messaging visual voicemail push mail VoIP and other services through any known or convenient protocol such as but is not limited to the TCP IP protocol UDP HTTP DNS FTP UPnP NSF ISDN PDH RS 232 SDH SONET etc.

The networks and or can be any collection of distinct networks operating wholly or partially in conjunction to provide connectivity to the client devices and the host server and may appear as one or more networks to the serviced systems and devices. In one embodiment communications to and from the client devices can be achieved by an open network such as the Internet or a private network broadband network such as an intranet and or the extranet. In one embodiment communications can be achieved by a secure communications protocol such as secure sockets layer SSL or transport layer security TLS .

In addition communications can be achieved via one or more networks such as but are not limited to one or more of WiMax a Local Area Network LAN Wireless Local Area Network WLAN a Personal area network PAN a Campus area network CAN a Metropolitan area network MAN a Wide area network WAN a Wireless wide area network WWAN or any broadband network and further enabled with technologies such as by way of example Global System for Mobile Communications GSM Personal Communications Service PCS Bluetooth WiFi Fixed Wireless Data 2G 2.5G 3G 4G IMT Advanced pre 4G LTE Advanced mobile WiMax WiMax 2 WirelessMAN Advanced networks enhanced data rates for GSM evolution EDGE General packet radio service GPRS enhanced GPRS iBurst UMTS HSPDA HSUPA HSPA UMTS TDD 1 RTT EV DO messaging protocols such as TCP IP SMS MMS extensible messaging and presence protocol XMPP real time messaging protocol RTMP instant messaging and presence protocol IMPP instant messaging USSD IRC or any other wireless data networks broadband networks or messaging protocols.

The distributed proxy and cache system can include for example the proxy server e.g. remote proxy and the server cache components on the server side. The server side proxy and cache can as illustrated reside internal to the host server . In addition the proxy server and cache on the server side can be partially or wholly external to the host server and in communication via one or more of the networks and . For example the proxy server may be external to the host server and the server cache may be maintained at the host server . Alternatively the proxy server may be within the host server while the server cache is external to the host server . In addition each of the proxy server and the cache may be partially internal to the host server and partially external to the host server . The application server content provider can by any server including third party servers or service content providers further including advertisement promotional content publication or electronic coupon servers or services. Similarly separate advertisement servers A promotional content servers B and or e Coupon servers C as application servers or content providers are illustrated by way of example.

The distributed system can also include in one embodiment client side components including by way of example but not limitation a local proxy e.g. a mobile client on a mobile device and or a local cache which can as illustrated reside internal to the device e.g. a mobile device .

In addition the client side proxy and local cache can be partially or wholly external to the device and in communication via one or more of the networks and . For example the local proxy may be external to the device and the local cache may be maintained at the device . Alternatively the local proxy may be within the device while the local cache is external to the device . In addition each of the proxy and the cache may be partially internal to the host server and partially external to the host server .

In one embodiment the distributed system can include an optional caching proxy server . The caching proxy server can be a component which is operated by the application server content provider the host server or a network service provider and or any combination of the above to facilitate network traffic management for network and device resource conservation. Proxy server can be used for example for caching content to be provided to the device for example from one or more of the application server provider host server and or a network service provider . Content caching can also be entirely or partially performed by the remote proxy to satisfy application requests or other data requests at the device .

In context aware traffic management and optimization for resource conservation in a network e.g. cellular or other wireless networks characteristics of user activity behavior and or application behavior at a mobile device e.g. any wireless device can be tracked by the local proxy and communicated over the network to the proxy server component in the host server for example as connection metadata. The proxy server which in turn is coupled to the application server provider provides content and data to satisfy requests made at the device .

In addition the local proxy can identify and retrieve mobile device properties including one or more of battery level network that the device is registered on radio state or whether the mobile device is being used e.g. interacted with by a user . In some instances the local proxy can delay expedite prefetch and or modify data prior to transmission to the proxy server when appropriate as will be further detailed with references to the description associated with the examples of .

The local database can be included in the local proxy or coupled to the local proxy and can be queried for a locally stored response to the data request prior to the data request being forwarded on to the proxy server . Locally cached responses can be used by the local proxy to satisfy certain application requests of the mobile device by retrieving cached content stored in the cache storage when the cached content is still valid.

Similarly the proxy server of the host server can also delay expedite or modify data from the local proxy prior to transmission to the content sources e.g. the application server content provider . In addition the proxy server uses device properties and connection metadata to generate rules for satisfying request of applications on the mobile device . The proxy server can gather real time traffic information about requests of applications for later use in optimizing similar connections with the mobile device or other mobile devices.

In general the local proxy and the proxy server are transparent to the multiple applications executing on the mobile device. The local proxy is generally transparent to the operating system or platform of the mobile device and may or may not be specific to device manufacturers. In some instances the local proxy is optionally customizable in part or in whole to be device specific. In some embodiments the local proxy may be bundled into a wireless model a firewall and or a router.

In one embodiment the host server can in some instances utilize the store and forward functions of a short message service center SMSC such as that provided by the network service provider in communicating with the device in achieving network traffic management. Note that can also utilize any other type of alternative channel including USSD or other network control mechanisms. As will be further described with reference to the example of the host server can forward content or HTTP responses to the SMSC such that it is automatically forwarded to the device if available and for subsequent forwarding if the device is not currently available.

In general the disclosed distributed proxy and cache system allows optimization of network usage for example by serving requests from the local cache the local proxy reduces the number of requests that need to be satisfied over the network . Further the local proxy and the proxy server may filter irrelevant data from the communicated data. In addition the local proxy and the proxy server can also accumulate low priority data and send it in batches to avoid the protocol overhead of sending individual data fragments. The local proxy and the proxy server can also compress or transcode the traffic reducing the amount of data sent over the network and or . The signaling traffic in the network and or can be reduced as the networks are now used less often and the network traffic can be synchronized among individual applications.

With respect to the battery life of the mobile device by serving application or content requests from the local cache the local proxy can reduce the number of times the radio module is powered up. The local proxy and the proxy server can work in conjunction to accumulate low priority data and send it in batches to reduce the number of times and or amount of time when the radio is powered up. The local proxy can synchronize the network use by performing the batched data transfer for all connections simultaneously.

Client Side Proxy a component installed in the Smartphone mobile device or wireless device that interfaces with device s operating system as well as with data services and applications installed in the device. The client side proxy is typically compliant with and able to operate with standard or state of the art networking protocols. Additional components and features of the client side proxy are illustrated with further references to the examples of and .

The server side proxy can include one or more servers that can interface with third party application servers e.g. mobile operator s network which can be proxy or an additional server that is not illustrated and or the client side proxy . In general the server side proxy can be compliant with and is generally able to operate with standard or state of the art networking protocols and or specifications for interacting with mobile network elements and or third party servers. Additional components and features of the server side proxy are illustrated with further references to the examples of and .

Reporting and Usage Analytics Server The Reporting and Usage Analytics system or component can collect information from the client side and or the server side and provides the necessary tools for producing reports and usage analytics can used for analyzing traffic and signaling data. Such analytics can be used by the proxy system in managing reducing network traffic or by the network operator in monitoring their networks for possible improvements and enhancements. Note that the reporting and usage analytics system component as illustrated may be a server separate from the server side proxy or it may be a component of the server side proxy residing partially or wholly therein.

The client side components can include software components or agents installed on the mobile device that enables traffic optimization and performs the related functionalities on the client side. Components of the client side proxy can operate transparently for end users and applications . The client side proxy can be installed on mobile devices for optimization to take place and it can effectuate changes on the data routes. Once data routing is modified the client side proxy can respond to application requests to service providers or host servers in addition to or instead of letting those applications access data network directly. In general applications on the mobile device will not notice that the client side proxy is responding to their requests. Some example components of the client side proxy are described as follows 

Device State Monitor The device state monitor can be responsible for identifying several states and metrics in the device such as network status display status battery level etc. such that the remaining components in the client side proxy can operate and make decisions according to device state acting in an optimal way in each state.

Traffic Recognizer The traffic recognizer analyzes all traffic between the wireless device applications and their respective host servers in order to identify recurrent patterns. Supported transport protocols include for example DNS HTTP and HTTPS such that traffic through those ports is directed to the client side proxy . While analyzing traffic the client side proxy can identify recurring polling patterns which can be candidates to be performed remotely by the server side proxy and send to the protocol optimizer .

Protocol Optimizer The protocol optimizer can implement the logic of serving recurrent request from the local cache instead of allowing those request go over the network to the service provider application host server. One is its tasks is to eliminate or minimize the need to send requests to the network positively affecting network congestion and device battery life.

Local Cache The local cache can store responses to recurrent requests and can be used by the Protocol Optimizer to send responses to the applications .

Traffic Scheduler The traffic scheduler can temporally move communications to optimize usage of device resources by unifying keep alive signaling so that some or all of the different applications can send keep alive messages at the same time traffic pipelining . Traffic scheduler may also decide to delay transmission of data that is not relevant at a given time for example when the device is not actively used .

Policy Manager The policy manager can store and enforce traffic optimization and reporting policies provisioned by a Policy Management Server PMS . At the client side proxy first start traffic optimization and reporting policies policy profiles that is to be enforced in a particular device can be provisioned by the Policy Management Server.

Watch Dog The watch dog can monitor the client side proxy operating availability. In case the client side proxy is not working due to a failure or because it has been disabled the watchdog can reset DNS routing rules information and can restore original DNS settings for the device to continue working until the client side proxy service is restored.

Reporting Agent The reporting agent can gather information about the events taking place in the device and sends the information to the Reporting Server. Event details are stored temporarily in the device and transferred to reporting server only when the data channel state is active. If the client side proxy doesn t send records within twenty four hours the reporting agent may attempt to open the connection and send recorded entries or in case there are no entries in storage an empty reporting packet. All reporting settings are configured in the policy management server.

Push Client The push client can be responsible for the traffic to between the server side proxy and the client side proxy . The push client can send out service requests like content update requests and policy update requests and receives updates to those requests from the server side proxy . In addition push client can send data to a reporting server e.g. the reporting and or usage analytics system which may be internal to or external to the server side proxy .

The proxy server has a wide variety of uses from speeding up a web server by caching repeated requests to caching web DNS and other network lookups for a group of clients sharing network resources. For example the proxy server may be a DNS harmonization server or may perform the functions described for the harmonization server in conjunction with the description of . The proxy server is optional. The distributed proxy and cache system and or allows for a flexible proxy configuration using either the proxy additional proxy s in operator s network or integrating both proxies and an operator s or other third party s proxy.

The server side of the distributed system can include for example a relay server which interacts with a traffic harmonizer a polling server and or a policy management server . Each of the various components can communicate with the client side proxy or other third party e.g. application server service provider and or other proxy and or a reporting and usage analytics system. Some example components of the server side proxy is described as follows 

Relay Server The relay server is the routing agent in the distributed proxy architecture. The relay server manages connections and communications with components on the client side proxy installed on devices and provides an administrative interface for reports provisioning platform setup and so on.

Notification Server The notification server is a module able to connect to an operator s SMSC gateways and deliver SMS notifications to the client side proxy . SMS notifications can be used when an IP link is not currently active in order to avoid the client side proxy from activating a connection over the wireless data channel thus avoiding additional signaling traffic. However if the IP connection happens to be open for some other traffic the notification server can use it for sending the notifications to the client side proxy . The user database can store operational data including endpoint MSISDN organization and Notification server gateway for each resource URIs or URLs .

Traffic Harmonizer The traffic harmonizer can be responsible for communication between the client side proxy and the polling server . The traffic harmonizer connects to the polling server directly or through the data storage and to the client over any open or proprietary protocol such as the 7TP. The traffic harmonizer can be also responsible for traffic pipelining on the server side if there s cached content in the database for the same client this can be sent over to the client in one message.

Polling Server The polling server can poll third party application servers on behalf of applications that are being optimized . If a change occurs i.e. new data available for an application the polling server can report to the traffic harmonizer which in turn sends a notification message to the client side proxy for it to clear the cache and allow application to poll application server directly.

Policy Management Server The policy management server PMS allows administrators to configure and store policies for the client side proxies device clients . It also allows administrators to notify the client side proxies about policy changes. Using the policy management server each operator can configure the policies to work in the most efficient way for the unique characteristics of each particular mobile operator s network.

Reporting and Usage Analytics Component The Reporting and Usage Analytics component or system collects information from the client side and or from the server side and provides all the necessary tools for producing reports and usage analytics that operators can use for analyzing application signaling and data consumption.

The device which can be a portable or mobile device e.g. any wireless device such as a portable phone generally includes for example a network interface an operating system a context API and mobile applications which may be proxy unaware or proxy aware . Note that the device is specifically illustrated in the example of as a mobile device such is not a limitation and that device may be any wireless broadband portable mobile or non portable device able to receive transmit signals to satisfy data requests over a network including wired or wireless networks e.g. WiFi cellular Bluetooth LAN WAN etc. .

The network interface can be a networking module that enables the device to mediate data in a network with an entity that is external to the host server through any known and or convenient communications protocol supported by the host and the external entity. The network interface can include one or more of a network adaptor card a wireless network interface card e.g. SMS interface WiFi interface interfaces for various generations of mobile communication standards including but not limited to 2G 3G 3.5G 4G LTE etc. Bluetooth or whether or not the connection is via a router an access point a wireless router a switch a multilayer switch a protocol converter a gateway a bridge a bridge router a hub a digital media receiver and or a repeater.

Device can further include client side components of the distributed proxy and cache system which can include a local proxy e.g. a mobile client of a mobile device and a cache . In one embodiment the local proxy includes a user activity module a proxy API a request transaction manager a caching policy manager having an application protocol module a traffic shaping engine and or a connection manager . The traffic shaping engine may further include an alignment module and or a batching module the connection manager may further include a radio controller . The request transaction manager can further include an application behavior detector and or a prioritization engine the application behavior detector may further include a pattern detector and or and application profile generator . Additional or less components modules engines can be included in the local proxy and each illustrated component.

As used herein a module a manager a handler a detector an interface a controller a normalizer a generator an invalidator or an engine includes a general purpose dedicated or shared processor and typically firmware or software modules that are executed by the processor. Depending upon implementation specific or other considerations the module manager handler detector interface controller normalizer generator invalidator or engine can be centralized or its functionality distributed. The module manager handler detector interface controller normalizer generator invalidator or engine can include general or special purpose hardware firmware or software embodied in a computer readable storage medium for execution by the processor.

As used herein a computer readable medium or computer readable storage medium is intended to include all mediums that are statutory e.g. in the United States under 35 U.S.C. 101 and to specifically exclude all mediums that are non statutory in nature to the extent that the exclusion is necessary for a claim that includes the computer readable storage medium to be valid. Known statutory computer readable mediums include hardware e.g. registers random access memory RAM non volatile NV storage to name a few but may or may not be limited to hardware.

In one embodiment a portion of the distributed proxy and cache system for network traffic management resides in or is in communication with device including local proxy mobile client and or cache . The local proxy can provide an interface on the device for users to access device applications and services including email IM voice mail visual voicemail feeds Internet games productivity tools or other applications etc.

The proxy is generally application independent and can be used by applications e.g. both proxy aware and proxy unaware applications and and other mobile applications to open TCP connections to a remote server e.g. the server in the examples of and or server proxy shown in the examples of and . In some instances the local proxy includes a proxy API which can be optionally used to interface with proxy aware applications or applications e.g. mobile applications on a mobile device e.g. any wireless device .

The applications and can generally include any user application widgets software HTTP based application web browsers video or other multimedia streaming or downloading application video games social network applications email clients RSS management applications application stores document management applications productivity enhancement applications etc. The applications can be provided with the device OS by the device manufacturer by the network service provider downloaded by the user or provided by others.

One embodiment of the local proxy includes or is coupled to a context API as shown. The context API may be a part of the operating system or device platform or independent of the operating system as illustrated. The operating system can include any operating system including but not limited to any previous current and or future versions releases of Windows Mobile iOS Android Symbian Palm OS Brew MP Java 2 Micro Edition J2ME Blackberry etc.

The context API may be a plug in to the operating system or a particular client application on the device . The context API can detect signals indicative of user or device activity for example sensing motion gesture device location changes in device location device backlight keystrokes clicks activated touch screen mouse click or detection of other pointer devices. The context API can be coupled to input devices or sensors on the device to identify these signals. Such signals can generally include input received in response to explicit user input at an input device mechanism at the device and or collected from ambient signals contextual cues detected at or in the vicinity of the device e.g. light motion piezoelectric etc. .

In one embodiment the user activity module interacts with the context API to identify determine infer detect compute predict and or anticipate characteristics of user activity on the device . Various inputs collected by the context API can be aggregated by the user activity module to generate a profile for characteristics of user activity. Such a profile can be generated by the user activity module with various temporal characteristics. For instance user activity profile can be generated in real time for a given instant to provide a view of what the user is doing or not doing at a given time e.g. defined by a time window in the last minute in the last 30 seconds etc. a user activity profile can also be generated for a session defined by an application or web page that describes the characteristics of user behavior with respect to a specific task they are engaged in on the device or for a specific time period e.g. for the last 2 hours for the last 5 hours .

Additionally characteristic profiles can be generated by the user activity module to depict a historical trend for user activity and behavior e.g. 1 week 1 mo. 2 mo. etc. . Such historical profiles can also be used to deduce trends of user behavior for example access frequency at different times of day trends for certain days of the week weekends or week days user activity trends based on location data e.g. IP address GPS or cell tower coordinate data or changes in location data e.g. user activity based on user location or user activity based on whether the user is on the go or traveling outside a home region etc. to obtain user activity characteristics.

In one embodiment user activity module can detect and track user activity with respect to applications documents files windows icons and folders on the device . For example the user activity module can detect when an application or window e.g. a web browser or any other type of application has been exited closed minimized maximized opened moved into the foreground or into the background multimedia content playback etc.

In one embodiment characteristics of the user activity on the device can be used to locally adjust behavior of the device e.g. mobile device or any wireless device to optimize its resource consumption such as battery power consumption and more generally consumption of other device resources including memory storage and processing power. In one embodiment the use of a radio on a device can be adjusted based on characteristics of user behavior e.g. by the radio controller of the connection manager coupled to the user activity module . For example the radio controller can turn the radio on or off based on characteristics of the user activity on the device . In addition the radio controller can adjust the power mode of the radio e.g. to be in a higher power mode or lower power mode depending on characteristics of user activity.

In one embodiment characteristics of the user activity on device can also be used to cause another device e.g. other computers a mobile device a wireless device or a non portable device or server e.g. host server and in the examples of and which can communicate e.g. via a cellular or other network with the device to modify its communication frequency with the device . The local proxy can use the characteristics information of user behavior determined by the user activity module to instruct the remote device as to how to modulate its communication frequency e.g. decreasing communication frequency such as data push frequency if the user is idle requesting that the remote device notify the device if new data changed data or data of a certain level of importance becomes available etc. .

In one embodiment the user activity module can in response to determining that user activity characteristics indicate that a user is active after a period of inactivity request that a remote device e.g. server host server and in the examples of and send the data that was buffered as a result of the previously decreased communication frequency.

In addition or in alternative the local proxy can communicate the characteristics of user activity at the device to the remote device e.g. host server and in the examples of and and the remote device determines how to alter its own communication frequency with the device for network resource conservation and conservation of device resources.

One embodiment of the local proxy further includes a request transaction manager which can detect identify intercept process manage data requests initiated on the device for example by applications and or and or directly indirectly by a user request. The request transaction manager can determine how and when to process a given request or transaction or a set of requests transactions based on transaction characteristics.

The request transaction manager can prioritize requests or transactions made by applications and or users at the device for example by the prioritization engine . Importance or priority of requests transactions can be determined by the request transaction manager by applying a rule set for example according to time sensitivity of the transaction time sensitivity of the content in the transaction time criticality of the transaction time criticality of the data transmitted in the transaction and or time criticality or importance of an application making the request.

In addition transaction characteristics can also depend on whether the transaction was a result of user interaction or other user initiated action on the device e.g. user interaction with a application e.g. a mobile application . In general a time critical transaction can include a transaction resulting from a user initiated data transfer and can be prioritized as such. Transaction characteristics can also depend on the amount of data that will be transferred or is anticipated to be transferred as a result of the requested transaction. For example the connection manager can adjust the radio mode e.g. high power or low power mode via the radio controller based on the amount of data that will need to be transferred.

In addition the radio controller connection manager can adjust the radio power mode high or low based on time criticality sensitivity of the transaction. The radio controller can trigger the use of high power radio mode when a time critical transaction e.g. a transaction resulting from a user initiated data transfer an application running in the foreground any other event meeting a certain criteria is initiated or detected.

In general the priorities can be set by default for example based on device platform device manufacturer operating system etc. Priorities can alternatively or in additionally be set by the particular application for example the Facebook application e.g. a mobile application can set its own priorities for various transactions e.g. a status update can be of higher priority than an add friend request or a poke request a message send request can be of higher priority than a message delete request for example an email client or IM chat client may have its own configurations for priority. The prioritization engine may include set of rules for assigning priority.

The prioritization engine can also track network provider limitations or specifications on application or transaction priority in determining an overall priority status for a request transaction. Furthermore priority can in part or in whole be determined by user preferences either explicit or implicit. A user can in general set priorities at different tiers such as specific priorities for sessions or types or applications e.g. a browsing session a gaming session versus an IM chat session the user may set a gaming session to always have higher priority than an IM chat session which may have higher priority than web browsing session . A user can set application specific priorities e.g. a user may set Facebook related transactions to have a higher priority than LinkedIn related transactions for specific transaction types e.g. for all send message requests across all applications to have higher priority than message delete requests for all calendar related events to have a high priority etc. and or for specific folders.

The prioritization engine can track and resolve conflicts in priorities set by different entities. For example manual settings specified by the user may take precedence over device OS settings network provider parameters limitations e.g. set in default for a network service area geographic locale set for a specific time of day or set based on service fee type may limit any user specified settings and or application set priorities. In some instances a manual synchronization request received from a user can override some most or all priority settings in that the requested synchronization is performed when requested regardless of the individually assigned priority or an overall priority ranking for the requested action.

Priority can be specified and tracked internally in any known and or convenient manner including but not limited to a binary representation a multi valued representation a graded representation and all are considered to be within the scope of the disclosed technology.

Table 1 above shows for illustration purposes some examples of transactions with examples of assigned priorities in a binary representation scheme. Additional assignments are possible for additional types of events requests transactions and as previously described priority assignments can be made at more or less granular levels e.g. at the session level or at the application level etc.

As shown by way of example in the above table in general lower priority requests transactions can include updating message status as being read unread deleting of messages deletion of contacts higher priority requests transactions can in some instances include status updates new IM chat message new email calendar event update cancellation deletion an event in a mobile gaming session or other entertainment related events a purchase confirmation through a web purchase or online request to load additional or download content contact book related events a transaction to change a device setting location aware or location based events transactions or any other events request transactions initiated by a user or where the user is known to be expected to be or suspected to be waiting for a response etc.

Inbox pruning events e.g. email or any other types of messages are generally considered low priority and absent other impending events generally will not trigger use of the radio on the device . Specifically pruning events to remove old email or other content can be piggy backed with other communications if the radio is not otherwise on at the time of a scheduled pruning event. For example if the user has preferences set to keep messages for 7 days old then instead of powering on the device radio to initiate a message delete from the device the moment that the message has exceeded 7 days old the message is deleted when the radio is powered on next. If the radio is already on then pruning may occur as regularly scheduled.

The request transaction manager can use the priorities for requests e.g. by the prioritization engine to manage outgoing traffic from the device for resource optimization e.g. to utilize the device radio more efficiently for battery conservation . For example transactions requests below a certain priority ranking may not trigger use of the radio on the device if the radio is not already switched on as controlled by the connection manager . In contrast the radio controller can turn on the radio such a request can be sent when a request for a transaction is detected to be over a certain priority level.

In one embodiment priority assignments such as that determined by the local proxy or another device entity can be used cause a remote device to modify its communication with the frequency with the mobile device or wireless device. For example the remote device can be configured to send notifications to the device when data of higher importance is available to be sent to the mobile device or wireless device.

In one embodiment transaction priority can be used in conjunction with characteristics of user activity in shaping or managing traffic for example by the traffic shaping engine . For example the traffic shaping engine can in response to detecting that a user is dormant or inactive wait to send low priority transactions from the device for a period of time. In addition the traffic shaping engine can allow multiple low priority transactions to accumulate for batch transferring from the device e.g. via the batching module . In one embodiment the priorities can be set configured or readjusted by a user. For example content depicted in Table I in the same or similar form can be accessible in a user interface on the device and for example used by the user to adjust or view the priorities.

The batching module can initiate batch transfer based on certain criteria. For example batch transfer e.g. of multiple occurrences of events some of which occurred at different instances in time may occur after a certain number of low priority events have been detected or after an amount of time elapsed after the first of the low priority event was initiated. In addition the batching module can initiate batch transfer of the cumulated low priority events when a higher priority event is initiated or detected at the device . Batch transfer can otherwise be initiated when radio use is triggered for another reason e.g. to receive data from a remote device such as host server or . In one embodiment an impending pruning event pruning of an inbox or any other low priority events can be executed when a batch transfer occurs.

In general the batching capability can be disabled or enabled at the event transaction level application level or session level based on any one or combination of the following user configuration device limitations settings manufacturer specification network provider parameters limitations platform specific limitations settings device OS settings etc. In one embodiment batch transfer can be initiated when an application window file is closed out exited or moved into the background users can optionally be prompted before initiating a batch transfer users can also manually trigger batch transfers.

In one embodiment the local proxy locally adjusts radio use on the device by caching data in the cache . When requests or transactions from the device can be satisfied by content stored in the cache the radio controller need not activate the radio to send the request to a remote entity e.g. the host server as shown in and or a content provider application server such as the server provider shown in the examples of and . As such the local proxy can use the local cache and the cache policy manager to locally store data for satisfying data requests to eliminate or reduce the use of the device radio for conservation of network resources and device battery consumption.

In leveraging the local cache once the request transaction manager intercepts a data request by an application on the device the local repository can be queried to determine if there is any locally stored response and also determine whether the response is valid. When a valid response is available in the local cache the response can be provided to the application on the device without the device needing to access the cellular network or wireless broadband network.

If a valid response is not available the local proxy can query a remote proxy e.g. the server proxy of to determine whether a remotely stored response is valid. If so the remotely stored response e.g. which may be stored on the server cache or optional caching server shown in the example of can be provided to the mobile device possibly without the mobile device needing to access the cellular network thus relieving consumption of network resources.

If a valid cache response is not available or if cache responses are unavailable for the intercepted data request the local proxy for example the caching policy manager can send the data request to a remote proxy e.g. server proxy of which forwards the data request to a content source e.g. application server content provider of and a response from the content source can be provided through the remote proxy as will be further described in the description associated with the example host server of . The cache policy manager can manage or process requests that use a variety of protocols including but not limited to HTTP HTTPS IMAP POP SMTP XMPP and or ActiveSync. The caching policy manager can locally store responses for data requests in the local database as cache entries for subsequent use in satisfying same or similar data requests.

The caching policy manager can request that the remote proxy monitor responses for the data request and the remote proxy can notify the device when an unexpected response to the data request is detected. In such an event the cache policy manager can erase or replace the locally stored response s on the device when notified of the unexpected response e.g. new data changed data additional data etc. to the data request. In one embodiment the caching policy manager is able to detect or identify the protocol used for a specific request including but not limited to HTTP HTTPS IMAP POP SMTP XMPP and or ActiveSync. In one embodiment application specific handlers e.g. via the application protocol module of the caching policy manager on the local proxy allows for optimization of any protocol that can be port mapped to a handler in the distributed proxy e.g. port mapped on the proxy server in the example of .

In one embodiment the local proxy notifies the remote proxy such that the remote proxy can monitor responses received for the data request from the content source for changed results prior to returning the result to the device for example when the data request to the content source has yielded same results to be returned to the mobile device. In general the local proxy can simulate application server responses for applications on the device using locally cached content. This can prevent utilization of the cellular network for transactions where new changed data is not available thus freeing up network resources and preventing network congestion.

In one embodiment the local proxy includes an application behavior detector to track detect observe monitor applications e.g. proxy aware and or unaware applications and accessed or installed on the device . Application behaviors or patterns in detected behaviors e.g. via the pattern detector of one or more applications accessed on the device can be used by the local proxy to optimize traffic in a wireless network needed to satisfy the data needs of these applications.

For example based on detected behavior of multiple applications the traffic shaping engine can align content requests made by at least some of the applications over the network wireless network e.g. via the alignment module . The alignment module can delay or expedite some earlier received requests to achieve alignment. When requests are aligned the traffic shaping engine can utilize the connection manager to poll over the network to satisfy application data requests. Content requests for multiple applications can be aligned based on behavior patterns or rules settings including for example content types requested by the multiple applications audio video text etc. device e.g. mobile or wireless device parameters and or network parameters traffic conditions network service provider constraints specifications etc.

In one embodiment the pattern detector can detect recurrences in application requests made by the multiple applications for example by tracking patterns in application behavior. A tracked pattern can include detecting that certain applications as a background process poll an application server regularly at certain times of day on certain days of the week periodically in a predictable fashion with a certain frequency with a certain frequency in response to a certain type of event in response to a certain type user query frequency that requested content is the same frequency with which a same request is made interval between requests applications making a request or any combination of the above for example.

Such recurrences can be used by traffic shaping engine to offload polling of content from a content source e.g. from an application server content provider of that would result from the application requests that would be performed at the mobile device or wireless device to be performed instead by a proxy server e.g. proxy server of or proxy server of remote from the device . Traffic shaping engine can decide to offload the polling when the recurrences match a rule. For example there are multiple occurrences or requests for the same resource that have exactly the same content or returned value or based on detection of repeatable time periods between requests and responses such as a resource that is requested at specific times during the day. The offloading of the polling can decrease the amount of bandwidth consumption needed by the mobile device to establish a wireless cellular or other wireless broadband connection with the content source for repetitive content polls.

As a result of the offloading of the polling locally cached content stored in the local cache can be provided to satisfy data requests at the device when content change is not detected in the polling of the content sources. As such when data has not changed application data needs can be satisfied without needing to enable radio use or occupying cellular bandwidth in a wireless network. When data has changed and or new data has been received the remote entity to which polling is offloaded can notify the device . The remote entity may be the host server as shown in the example of .

In one embodiment the local proxy can mitigate the need use of periodic keep alive messages heartbeat messages to maintain TCP IP connections which can consume significant amounts of power thus having detrimental impacts on mobile device battery life. The connection manager in the local proxy e.g. the heartbeat manager can detect identify and intercept any or all heartbeat keep alive messages being sent from applications.

The heartbeat manager can prevent any or all of these heartbeat messages from being sent over the cellular or other network and instead rely on the server component of the distributed proxy system e.g. shown in to generate the and send the heartbeat messages to maintain a connection with the backend e.g. application server provider in the example of .

The local proxy generally represents any one or a portion of the functions described for the individual managers modules and or engines. The local proxy and device can include additional or less components more or less functions can be included in whole or in part without deviating from the novel art of the disclosure.

In one embodiment the caching policy manager includes a metadata generator a cache look up engine a cache appropriateness decision engine a poll schedule generator an application protocol module a cache or connect selection engine and or a local cache invalidator . The cache appropriateness decision engine can further include a timing predictor a content predictor a request analyzer and or a response analyzer and the cache or connect selection engine includes a response scheduler . The metadata generator and or the cache look up engine are coupled to the cache or local cache for modification or addition to cache entries or querying thereof.

The cache look up engine may further include an ID or URI filter the local cache invalidator may further include a TTL manager and the poll schedule generator may further include a schedule update engine and or a time adjustment engine . One embodiment of caching policy manager includes an application cache policy repository . In one embodiment the application behavior detector includes a pattern detector a poll interval detector an application profile generator and or a priority engine . The poll interval detector may further include a long poll detector having a response request tracking engine . The poll interval detector may further include a long poll hunting detector . The application profile generator can further include a response delay interval tracker

The pattern detector application profile generator and the priority engine were also described in association with the description of the pattern detector shown in the example of . One embodiment further includes an application profile repository which can be used by the local proxy to store information or metadata regarding application profiles e.g. behavior patterns type of HTTP requests etc. 

The cache appropriateness decision engine can detect assess or determine whether content from a content source e.g. application server content provider in the example of with which a mobile device interacts and has content that may be suitable for caching. For example the decision engine can use information about a request and or a response received for the request initiated at the mobile device to determine cacheability potential cacheability or non cacheability. In some instances the decision engine can initially verify whether a request is directed to a blacklisted destination or whether the request itself originates from a blacklisted client or application. If so additional processing and analysis may not be performed by the decision engine and the request may be allowed to be sent over the air to the server to satisfy the request. The black listed destinations or applications clients e.g. mobile applications can be maintained locally in the local proxy e.g. in the application profile repository or remotely e.g. in the proxy server or another entity .

In one embodiment the decision engine for example via the request analyzer collects information about an application or client request generated at the mobile device . The request information can include request characteristics information including for example request method. For example the request method can indicate the type of HTTP request generated by the mobile application or client. In one embodiment response to a request can be identified as cacheable or potentially cacheable if the request method is a GET request or POST request. Other types of requests e.g. OPTIONS HEAD PUT DELETE TRACE or CONNECT may or may not be cached. In general HTTP requests with uncacheable request methods will not be cached.

Request characteristics information can further include information regarding request size for example. Responses to requests e.g. HTTP requests with body size exceeding a certain size will not be cached. For example cacheability can be determined if the information about the request indicates that a request body size of the request does not exceed a certain size. In some instances the maximum cacheable request body size can be set to 8092 bytes. In other instances different values may be used dependent on network capacity or network operator specific settings for example.

In some instances content from a given application server content provider e.g. the server content provider of is determined to be suitable for caching based on a set of criteria for example criteria specifying time criticality of the content that is being requested from the content source. In one embodiment the local proxy e.g. the local proxy or of and applies a selection criteria to store the content from the host server which is requested by an application as cached elements in a local cache on the mobile device to satisfy subsequent requests made by the application.

The cache appropriateness decision engine further based on detected patterns of requests sent from the mobile device e.g. by a mobile application or other types of clients on the device and or patterns of received responses can detect predictability in requests and or responses. For example the request characteristics information collected by the decision engine e.g. the request analyzer can further include periodicity information between a request and other requests generated by a same client on the mobile device or other requests directed to the same host e.g. with similar or same identifier parameters .

Periodicity can be detected by the decision engine or the request analyzer when the request and the other requests generated by the same client occur at a fixed rate or nearly fixed rate or at a dynamic rate with some identifiable or partially or wholly reproducible changing pattern. If the requests are made with some identifiable pattern e.g. regular intervals intervals having a detectable pattern or trend e.g. increasing decreasing constant etc. the timing predictor can determine that the requests made by a given application on a device is predictable and identify it to be potentially appropriate for caching at least from a timing standpoint.

An identifiable pattern or trend can generally include any application or client behavior which may be simulated either locally for example on the local proxy on the mobile device or simulated remotely for example by the proxy server on the host or a combination of local and remote simulation to emulate application behavior.

In one embodiment the decision engine for example via the response analyzer can collect information about a response to an application or client request generated at the mobile device . The response is typically received from a server or the host of the application e.g. mobile application or client which sent the request at the mobile device . In some instances the mobile client or application can be the mobile version of an application e.g. social networking search travel management voicemail contact manager email or a web site accessed via a web browser or via a desktop client.

For example response characteristics information can include an indication of whether transfer encoding or chunked transfer encoding is used in sending the response. In some instances responses to HTTP requests with transfer encoding or chunked transfer encoding are not cached and therefore are also removed from further analysis. The rationale here is that chunked responses are usually large and non optimal for caching since the processing of these transactions may likely slow down the overall performance. Therefore in one embodiment cacheability or potential for cacheability can be determined when transfer encoding is not used in sending the response.

In addition the response characteristics information can include an associated status code of the response which can be identified by the response analyzer . In some instances HTTP responses with uncacheable status codes are typically not cached. The response analyzer can extract the status code from the response and determine whether it matches a status code which is cacheable or uncacheable. Some cacheable status codes include by way of example OK Redirect Found See other Not Modified Temporary Redirect or Internal server error. Some uncacheable status codes can include for example Forbidden or Not found.

In one embodiment cacheability or potential for cacheability can be determined if the information about the response does not indicate an uncacheable status code or indicates a cacheable status code. If the response analyzer detects an uncacheable status code associated with a given response the specific transaction request response pair may be eliminated from further processing and determined to be uncacheable on a temporary basis a semi permanent or a permanent basis. If the status code indicates cacheability the transaction e.g. request and or response pair may be subject to further processing and analysis to confirm cacheability as shown in the example flow charts of .

Response characteristics information can also include response size information. In general responses can be cached locally at the mobile device if the responses do not exceed a certain size. In some instances the default maximum cached response size is set to 115 KB. In other instances the max cacheable response size may be different and or dynamically adjusted based on operating conditions network conditions network capacity user preferences network operator requirements or other application specific user specific and or device specific reasons. In one embodiment the response analyzer can identify the size of the response and cacheability or potential for cacheability can be determined if a given threshold or max value is not exceeded by the response size.

Furthermore response characteristics information can include response body information for the response to the request and other response to other requests generated by a same client on the mobile device or directed to a same content host or application server. The response body information for the response and the other responses can be compared for example by the response analyzer to prevent the caching of dynamic content or responses with content that changes frequently and cannot be efficiently served with cache entries such as financial data stock quotes news feeds real time sporting event activities etc. such as content that would no longer be relevant or up to date if served from cached entries.

The cache appropriateness decision engine e.g. the content predictor can definitively identify repeatability or identify indications of repeatability potential repeatability or predictability in responses received from a content source e.g. the content host application server shown in the example of . Repeatability can be detected by for example tracking at least two responses received from the content source and determines if the two responses are the same. For example cacheability can be determined by the response analyzer if the response body information for the response and the other responses sent by the same mobile client or directed to the same host server are same or substantially the same. The two responses may or may not be responses sent in response to consecutive requests. In one embodiment hash values of the responses received for requests from a given application are used to determine repeatability of content with or without heuristics for the application in general and or for the specific request. Additional same responses may be required for some applications or under certain circumstances.

Repeatability in received content need not be 100 ascertained. For example responses can be determined to be repeatable if a certain number or a certain percentage of responses are the same or similar. The certain number or certain percentage of same similar responses can be tracked over a select period of time set by default or set based on the application generating the requests e.g. whether the application is highly dynamic with constant updates or less dynamic with infrequent updates . Any indicated predictability or repeatability or possible repeatability can be utilized by the distributed system in caching content to be provided to a requesting application or client on the mobile device .

In one embodiment for a long poll type request the local proxy can begin to cache responses on a third request when the response delay times for the first two responses are the same substantially the same or detected to be increasing in intervals. In general the received responses for the first two responses should be the same and upon verifying that the third response received for the third request is the same e.g. if R0 R1 R2 the third response can be locally cached on the mobile device. Less or more same responses may be required to begin caching depending on the type of application type of data type of content user preferences or carrier network operator specifications.

Increasing response delays with same responses for long polls can indicate a hunting period e.g. a period in which the application client on the mobile device is seeking the longest time between a request and response that a given network will allow a timing diagram showing timing characteristics is illustrated in as detected by the long poll hunting detector of the application behavior detector .

An example can be described below using T0 T1 T2 where T indicates the delay time between when a request is sent and when a response e.g. the response header is detected received for consecutive requests 0 Response0 Request0 180 s. tolerance 1 Response1 Request1 240 s. tolerance 2 Response2 Request2 500 s. tolerance 

As such the local proxy can specify information that can be extracted from the timing sequence shown above e.g. polling schedule polling interval polling type to the proxy server and begin caching and to request the proxy server to begin polling and monitoring the source e.g. using any of T0 T1 T2 as polling intervals but typically T2 or the largest detected interval without timing out and for which responses from the source is received will be sent to the proxy server of for use in polling the content source e.g. application server service provider .

However if the time intervals are detected to be getting shorter the application e.g. mobile application client may still be hunting for a time interval for which a response can be reliably received from the content source e.g. application server server provider or and as such caching typically should not begin until the request response intervals indicate the same time interval or an increasing time interval for example for a long poll type request.

An example of handling a detected decreasing delay can be described below using T0 T1 T2 T3 and T4 where T indicates the delay time between when a request is sent and when a response e.g. the response header is detected received for consecutive requests 0 Response0 Request0 160 s. tolerance 1 Response1 Request1 240 s. tolerance 2 Response2 Request2 500 s. tolerance 3 Time out at 700 s. tolerance 4 Response4 Request4 600 tolerance 

Note that the above description shows that caching can begin while long polls are in hunting mode in the event of detecting increasing response delays as long as responses are received and not timed out for a given request. This can be referred to as the optional accelerated caching during long poll hunting. Caching can also begin after the hunting mode e.g. after the poll requests have settled to a constant or near constant delay value has completed. Note that hunting may or may not occur for long polls and when hunting occurs the proxy can generally detect this and determine whether to begin to cache during the hunting period increasing intervals with same responses or wait until the hunt settles to a stable value.

In one embodiment the timing predictor of the cache appropriateness decision engine can track timing of responses received from outgoing requests from an application e.g. mobile application or client to detect any identifiable patterns which can be partially wholly reproducible such that locally cached responses can be provided to the requesting client on the mobile device in a manner that simulates content source e.g. application server content provider or behavior. For example the manner in which e.g. from a timing standpoint responses or content would be delivered to the requesting application client on the device . This ensures preservation of user experience when responses to application or mobile client requests are served from a local and or remote cache instead of being retrieved received directly from the content source e.g. application content provider or .

In one embodiment the decision engine or the timing predictor determines the timing characteristics a given application e.g. mobile application or client from for example the request response tracking engine and or the application profile generator e.g. the response delay interval tracker . Using the timing characteristics the timing predictor determines whether the content received in response to the requests are suitable or are potentially suitable for caching. For example poll request intervals between two consecutive requests from a given application can be used to determine whether request intervals are repeatable e.g. constant near constant increasing with a pattern decreasing with a pattern etc. and can be predicted and thus reproduced at least some of the times either exactly or approximated within a tolerance level.

In some instances the timing characteristics of a given request type for a specific application for multiple requests of an application or for multiple applications can be stored in the application profile repository . The application profile repository can generally store any type of information or metadata regarding application request response characteristics including timing patterns timing repeatability content repeatability etc.

The application profile repository can also store metadata indicating the type of request used by a given application e.g. long polls long held HTTP requests HTTP streaming push COMET push etc. Application profiles indicating request type by applications can be used when subsequent same similar requests are detected or when requests are detected from an application which has already been categorized. In this manner timing characteristics for the given request type or for requests of a specific application which has been tracked and or analyzed need not be reanalyzed.

Application profiles can be associated with a time to live e.g. or a default expiration time . The use of an expiration time for application profiles or for various aspects of an application or request s profile can be used on a case by case basis. The time to live or actual expiration time of application profile entries can be set to a default value or determined individually or a combination thereof. Application profiles can also be specific to wireless networks physical networks network operators or specific carriers.

One embodiment includes an application blacklist manager . The application blacklist manager can be coupled to the application cache policy repository and can be partially or wholly internal to local proxy or the caching policy manager . Similarly the blacklist manager can be partially or wholly internal to local proxy or the application behavior detector . The blacklist manager can aggregate track update manage adjust or dynamically monitor a list of destinations of servers host that are blacklisted or identified as not cached on a permanent or temporary basis. The blacklist of destinations when identified in a request can potentially be used to allow the request to be sent over the cellular network for servicing. Additional processing on the request may not be performed since it is detected to be directed to a blacklisted destination.

Blacklisted destinations can be identified in the application cache policy repository by address identifiers including specific URIs or patterns of identifiers including URI patterns. In general blacklisted destinations can be set by or modified for any reason by any party including the user owner user of mobile device operating system mobile platform of device the destination itself network operator of cellular network Internet service provider other third parties or according to a list of destinations for applications known to be uncacheable not suited for caching. Some entries in the blacklisted destinations may include destinations aggregated based on the analysis or processing performed by the local proxy e.g. cache appropriateness decision engine .

For example applications or mobile clients on the mobile device for which responses have been identified as non suitable for caching can be added to the blacklist. Their corresponding hosts servers may be added in addition to or in lieu of an identification of the requesting application client on the mobile device . Some or all of such clients identified by the proxy system can be added to the blacklist. For example for all application clients or applications that are temporarily identified as not being suitable for caching only those with certain detected characteristics based on timing periodicity frequency of response content change content predictability size etc. can be blacklisted.

The blacklisted entries may include a list of requesting applications or requesting clients on the mobile device rather than destinations such that when a request is detected from a given application or given client it may be sent through the network for a response since responses for blacklisted clients applications are in most circumstances not cached.

A given application profile may also be treated or processed differently e.g. different behavior of the local proxy and the remote proxy depending on the mobile account associated with a mobile device from which the application is being accessed. For example a higher paying account or a premier account may allow more frequent access of the wireless network or higher bandwidth allowance thus affecting the caching policies implemented between the local proxy and proxy server with an emphasis on better performance compared to conservation of resources. A given application profile may also be treated or processed differently under different wireless network conditions e.g. based on congestion or network outage etc. .

Note that cache appropriateness can be determined tracked and managed for multiple clients or applications on the mobile device . Cache appropriateness can also be determined for different requests or request types initiated by a given client or application on the mobile device . The caching policy manager along with the timing predictor and or the content predictor which heuristically determines or estimates predictability or potential predictability can track manage and store cacheability information for various application or various requests for a given application. Cacheability information may also include conditions e.g. an application can be cached at certain times of the day or certain days of the week or certain requests of a given application can be cached or all requests with a given destination address can be cached under which caching is appropriate which can be determined and or tracked by the cache appropriateness decision engine and stored and or updated when appropriate in the application cache policy repository coupled to the cache appropriateness decision engine .

The information in the application cache policy repository regarding cacheability of requests applications and or associated conditions can be used later on when same requests are detected. In this manner the decision engine and or the timing and content predictors need not track and reanalyze request response timing and content characteristics to make an assessment regarding cacheability. In addition the cacheability information can in some instances be shared with local proxies of other mobile devices by way of direct communication or via the host server e.g. proxy server of host server .

For example cacheability information detected by the local proxy on various mobile devices can be sent to a remote host server or a proxy server on the host server e.g. host server or proxy server shown in the example of host and proxy server in the example of . The remote host or proxy server can then distribute the information regarding application specific request specific cacheability information and or any associated conditions to various mobile devices or their local proxies in a wireless network or across multiple wireless networks same service provider or multiple wireless service providers for their use.

In general the selection criteria for caching can further include by way of example but not limitation the state of the mobile device indicating whether the mobile device is active or inactive network conditions and or radio coverage statistics. The cache appropriateness decision engine can in any one or any combination of the criteria and in any order identifying sources for which caching may be suitable.

Once application servers content providers having identified or detected content that is potentially suitable for local caching on the mobile device the cache policy manager can proceed to cache the associated content received from the identified sources by storing content received from the content source as cache elements in a local cache e.g. local cache or shown in the examples of and respectively on the mobile device .

The response can be stored in the cache e.g. also referred as the local cache as a cache entry. In addition to the response to a request the cached entry can include response metadata having additional information regarding caching of the response. The metadata may be generated by the metadata generator and can include for example timing data such as the access time of the cache entry or creation time of the cache entry. Metadata can include additional information such as any information suited for use in determining whether the response stored as the cached entry is used to satisfy the subsequent response. For example metadata information can further include request timing history e.g. including request time request start time request end time hash of the request and or response time intervals or changes in time intervals etc.

The cache entry is typically stored in the cache in association with a time to live TTL which for example may be assigned or determined by the TTL manager of the cache invalidator . The time to live of a cache entry is the amount of time the entry is persisted in the cache regardless of whether the response is still valid or relevant for a given request or client application on the mobile device . For example if the time to live of a given cache entry is set to 12 hours the cache entry is purged removed or otherwise indicated as having exceeded the time to live even if the response body contained in the cache entry is still current and applicable for the associated request.

A default time to live can be automatically used for all entries unless otherwise specified e.g. by the TTL manager or each cache entry can be created with its individual TTL e.g. determined by the TTL manager based on various dynamic or static criteria . Note that each entry can have a single time to live associated with both the response data and any associated metadata. In some instances the associated metadata may have a different time to live e.g. a longer time to live than the response data.

The content source having content for caching can in addition or in alternate be identified to a proxy server e.g. proxy server or shown in the examples of and respectively remote from and in wireless communication with the mobile device such that the proxy server can monitor the content source e.g. application server content provider for new or changed data. Similarly the local proxy e.g. the local proxy or of and respectively can identify to the proxy server that content received from a specific application server content provider is being stored as cached elements in the local cache .

Once content has been locally cached the cache policy manager upon receiving future polling requests to contact the application server content host e.g. or can retrieve the cached elements from the local cache to respond to the polling request made at the mobile device such that a radio of the mobile device is not activated to service the polling request. For example the cache look up engine can query the cache to identify the response to be served to a response. The response can be served from the cache in response to identifying a matching cache entry and also using any metadata stored with the response in the cache entry. The cache entries can be queried by the cache look up engine using a URI of the request or another type of identifier e.g. via the ID or URI filter . The cache lookup engine can further use the metadata e.g. extract any timing information or other relevant information stored with the matching cache entry to determine whether response is still suited for use in being served to a current request.

Note that the cache look up can be performed by the engine using one or more of various multiple strategies. In one embodiment multiple cook up strategies can be executed sequentially on each entry store din the cache until at least one strategy identifies a matching cache entry. The strategy employed to performing cache look up can include a strict matching criteria or a matching criteria which allows for non matching parameters.

For example the look up engine can perform a strict matching strategy which searches for an exact match between an identifier e.g. a URI for a host or resource referenced in a present request for which the proxy is attempting to identify a cache entry and an identifier stored with the cache entries. In the case where identifiers include URIs or URLs the matching algorithm for strict matching will search for a cache entry where all the parameters in the URLs match. For example 

Under the strict strategy outlined above a match will not be found since the URIs differ in the query parameter.

In another example strategy the look up engine looks for a cache entry with an identifier that partially matches the identifier references in a present request for which the proxy is attempting to identify a matching cache entry. For example the look up engine may look for a cache entry with an identifier which differs from the request identifier by a query parameter value. In utilizing this strategy the look up engine can collect information collected for multiple previous requests e.g. a list of arbitrary parameters in an identifier to be later checked with the detected arbitrary parameter in the current request. For example in the case where cache entries are stored with URI or URL identifiers the look up engine searches for a cache entry with a URI differing by a query parameter. If found the engine can examine the cache entry for information collected during previous requests e.g. a list of arbitrary parameters and checked whether the arbitrary parameter detected in or extracted from the current URI URL belongs to the arbitrary parameters list.

Match will not be found since current request contains sort parameter which is not marked as arbitrary in the cache entry.

Additional strategies for detecting cache hit may be employed. These strategies can be implemented singly or in any combination thereof. A cache hit can be determined when any one of these strategies determines a match. A cache miss may be indicated when the look up engine determines that the requested data cannot be served from the cache for any reason. For example a cache miss may be determined when no cache entries are identified for any or all utilized look up strategies.

Cache miss may also be determined when a matching cache entry exists but determined to be invalid or irrelevant for the current request. For example the look up engine may further analyze metadata e.g. which may include timing data of the cache entry associated with the matching cache entry to determine whether it is still suitable for use in responding to the present request.

When the look up engine has identified a cache hit e.g. an event indicating that the requested data can be served from the cache the stored response in the matching cache entry can be served from the cache to satisfy the request of an application client.

By servicing requests using cache entries stored in cache network bandwidth and other resources need not be used to request receive poll responses which may have not changed from a response that has already been received at the mobile device . Such servicing and fulfilling application e.g. mobile application requests locally via cache entries in the local cache allows for more efficient resource and mobile network traffic utilization and management since the request need not be sent over the wireless network further consuming bandwidth. In general the cache can be persisted between power on off of the mobile device and persisted across application client refreshes and restarts.

For example the local proxy upon receipt of an outgoing request from its mobile device or from an application or other type of client on the mobile device can intercept the request and determine whether a cached response is available in the local cache of the mobile device . If so the outgoing request is responded to by the local proxy using the cached response on the cache of the mobile device. As such the outgoing request can be filled or satisfied without a need to send the outgoing request over the wireless network thus conserving network resources and battery consumption.

In one embodiment the responding to the requesting application client on the device is timed to correspond to a manner in which the content server would have responded to the outgoing request over a persistent connection e.g. over the persistent connection or long held HTTP connection long poll type connection that would have been established absent interception by the local proxy . The timing of the response can be emulated or simulated by the local proxy to preserve application behavior such that end user experience is not affected or minimally affected by serving stored content from the local cache rather than fresh content received from the intended content source e.g. content host application server of . The timing can be replicated exactly or estimated within a tolerance parameter which may go unnoticed by the user or treated similarly by the application so as to not cause operation issues.

For example the outgoing request can be a request for a persistent connection intended for the content server e.g. application server content provider of examples of . In a persistent connection e.g. long poll COMET style push or any other push simulation in asynchronous HTTP requests long held HTTP request HTTP streaming or others with a content source server the connection is held for some time after a request is sent. The connection can typically be persisted between the mobile device and the server until content is available at the server to be sent to the mobile device. Thus there typically can be some delay in time between when a long poll request is sent and when a response is received from the content source. If a response is not provided by the content source for a certain amount of time the connection may also terminate due to network reasons e.g. socket closure if a response is not sent.

Thus to emulate a response from a content server sent over a persistent connection e.g. a long poll style connection the manner of response of the content server can be simulated by allowing a time interval to elapse before responding to the outgoing request with the cached response. The length of the time interval can be determined on a request by request basis or on an application by application client by client basis for example.

In one embodiment the time interval is determined based on request characteristics e.g. timing characteristics of an application on the mobile device from which the outgoing request originates. For example poll request intervals e.g. which can be tracked detected and determined by the long poll detector of the poll interval detector can be used to determine the time interval to wait before responding to a request with a local cache entry and managed by the response scheduler

One embodiment of the cache policy manager includes a poll schedule generator which can generate a polling schedule for one or more applications on the mobile device . The polling schedule can specify a polling interval that can be employed by an entity which is physically distinct and or separate from the mobile device in monitoring the content source for one or more applications such that cached responses can be verified periodically by polling a host server host server or to which the request is directed on behalf of the mobile device. One example of such an external entity which can monitor the content at the source for the mobile device is a proxy server e.g. proxy server or shown in the examples of and .

The polling schedule e.g. including a rate frequency of polling can be determined for example based on the interval between the polling requests directed to the content source from the mobile device. The polling schedule or rate of polling may be determined at the mobile device by the local proxy . In one embodiment the poll interval detector of the application behavior detector can monitor polling requests directed to a content source from the mobile device in order to determine an interval between the polling requests made from any or all application e.g. mobile application .

For example the poll interval detector can track requests and responses for applications or clients on the device . In one embodiment consecutive requests are tracked prior to detection of an outgoing request initiated from the application e.g. mobile application on the mobile device by the same mobile client or application e.g. mobile application . The polling rate can be determined using request information collected for the request for which the response is cached. In one embodiment the rate is determined from averages of time intervals between previous requests generated by the same client which generated the request. For example a first interval may be computed between the current request and a previous request and a second interval can be computed between the two previous requests. The polling rate can be set from the average of the first interval and the second interval and sent to the proxy server in setting up the caching strategy.

Alternate intervals may be computed in generating an average for example multiple previous requests in addition to two previous requests may be used and more than two intervals may be used in computing an average. In general in computing intervals a given request need not have resulted in a response to be received from the host server content source in order to use it for interval computation. In other words the timing characteristics of a given request may be used in interval computation as long as the request has been detected even if the request failed in sending or if the response retrieval failed.

One embodiment of the poll schedule generator includes a schedule update engine and or a time adjustment engine . The schedule update engine can determine a need to update a rate or polling interval with which a given application server content host from a previously set value based on a detected interval change in the actual requests generated from a client or application e.g. mobile application on the mobile device .

For example a request for which a monitoring rate was determined may now be sent from the application e.g. mobile application or client at a different request interval. The scheduled update engine can determine the updated polling interval of the actual requests and generate a new rate different from the previously set rate to poll the host at on behalf of the mobile device . The updated polling rate can be communicated to the remote proxy proxy server over the cellular network for the remote proxy to monitor the given host. In some instances the updated polling rate may be determined at the remote proxy or remote entity which monitors the host.

In one embodiment the time adjustment engine can further optimize the poll schedule generated to monitor the application server content source or . For example the time adjustment engine can optionally specify a time to start polling to the proxy server. For example in addition to setting the polling interval at which the proxy server is to monitor the application server content host can also specify the time at which an actual request was generated at the mobile client application.

However in some cases due to inherent transmission delay or added network delays or other types of latencies the remote proxy server receives the poll setup from the local proxy with some delay e.g. a few minutes or a few seconds . This has the effect of detecting response change at the source after a request is generated by the mobile client application causing the invalidate of the cached response to occur after it has once again been served to the application after the response is no longer current or valid.

To resolve this non optimal result of serving the out dated content once again before invalidating it the time adjustment engine can specify the time t0 at which polling should begin in addition to the rate where the specified initial time t0 can be specified to the proxy server as a time that is less than the actual time when the request was generated by the mobile app client. This way the server polls the resource slightly before the generation of an actual request by the mobile client such that any content change can be detected prior to an actual application request. This prevents invalid or irrelevant out dated content response from being served once again before fresh content is served.

In one embodiment an outgoing request from a mobile device is detected to be for a persistent connection e.g. a long poll COMET style push and long held HTTP request based on timing characteristics of prior requests from the same application or client on the mobile device . For example requests and or corresponding responses can be tracked by the request response tracking engine of the long poll detector of the poll interval detector .

The timing characteristics of the consecutive requests can be determined to set up a polling schedule for the application or client. The polling schedule can be used to monitor the content source content source application server for content changes such that cached content stored on the local cache in the mobile device can be appropriately managed e.g. updated or discarded . In one embodiment the timing characteristics can include for example a response delay time D and or an idle time IT .

The response delay time and idle time typical of a long poll are illustrated in the timing diagram shown below. In one embodiment the response request tracking engine can track requests and responses to determine compute and or estimate the timing diagrams for applicant or client requests.

For example the response request tracking engine detects a first request Request 0 initiated by a client on the mobile device and a second request Request 1 initiated by the client on the mobile device after a response is received at the mobile device responsive to the first request. The second request is one that is subsequent to the first request.

In one embodiment the response request tracking engine can track requests and responses to determine compute and or estimate the timing diagrams for applicant or client requests. The response request tracking engine can detect a first request initiated by a client on the mobile device and a second request initiated by the client on the mobile device after a response is received at the mobile device responsive to the first request. The second request is one that is subsequent to the first request.

The response request tracking engine further determines relative timings between the first second requests and the response received in response to the first request. In general the relative timings can be used by the long poll detector to determine whether requests generated by the application are long poll requests.

Note that in general the first and second requests that are used by the response request tracking engine in computing the relative timings are selected for use after a long poll hunting period has settled or in the event when long poll hunting does not occur. Timing characteristics that are typical of a long poll hunting period is illustrated in the example of and can be for example detected by the long poll hunting detector . In other words the requests tracked by the response request tracking engine and used for determining whether a given request is a long poll occurs after the long poll has settled e.g. shown in of after the hunting mode has completed .

In one embodiment the long poll hunting detector can identify or detect hunting mode by identifying increasing request intervals e.g. increasing delays . The long poll hunting detector can also detect hunting mode by detecting increasing request intervals followed by a request with no response e.g. connection timed out or by detecting increasing request intervals followed by a decrease in the interval. In addition the long poll hunting detector can apply a filter value or a threshold value to request response time delay value e.g. an absolute value above which the detected delay can be considered to be a long poll request response delay. The filter value can be any suitable value characteristic of long polls and or network conditions e.g. 2 s 5 s 10 s 15 s 20 s. etc. and can be used as a filter or threshold value.

The response delay time D refers to the start time to receive a response after a request has been sent and the idle refers to time to send a subsequent request after the response has been received. In one embodiment the outgoing request is detected to be for a persistent connection based on a comparison e.g. performed by the tracking engine of the response delay time relative D or average of D e.g. any average over any period of time to the idle time IT for example by the long poll detector . The number of averages used can be fixed dynamically adjusted or changed over a longer period of time. For example the requests initiated by the client are determined to be long poll requests if the response delay time interval is greater than the idle time interval D IT or D IT . In one embodiment the tracking engine of the long poll detector computes determines or estimates the response delay time interval as the amount of time elapsed between time of the first request and initial detection or full receipt of the response.

In one embodiment a request is detected to be for a persistent connection when the idle time IT is short since persistent connections established in response to long poll requests or long poll HTTP requests for example can also be characterized in detecting immediate or near immediate issuance of a subsequent request after receipt of a response to a previous request e.g. IT 0 . As such the idle time IT can also be used to detect such immediate or near immediate re request to identify long poll requests. The absolute or relative timings determined by the tracking engine are used to determine whether the second request is immediately or near immediately re requested after the response to the first request is received. For example a request may be categorized as a long poll request if D RT IT D RT since IT is small for this to hold true. IT may be determined to be small if it is less than a threshold value. Note that the threshold value could be fixed or calculated over a limited time period a session a day a month etc. or calculated over a longer time period e.g. several months or the life of the analysis . For example for every request the average IT can be determined and the threshold can be determined using this average IT e.g. the average IT less a certain percentage may be used as the threshold . This can allow the threshold to automatically adapt over time to network conditions and changes in server capability resource availability or server response. A fixed threshold can take upon any value including by way of example but not limitation e.g. 1 s. 2 s. 3 s. . . . etc. .

In one embodiment the long poll detector can compare the relative timings e.g. determined by the tracker engine to request response timing characteristics for other applications to determine whether the requests of the application are long poll requests. For example the requests initiated by a client or application can be determined to be long poll requests if the response delay interval time D or the average response delay interval time e.g. averaged over x number of requests or any number of delay interval times averaged over x amount of time is greater than a threshold value.

The threshold value can be determined using response delay interval times for requests generated by other clients for example by the request response tracking engine and or by the application profile generator e.g. the response delay interval tracker . The other clients may reside on the same mobile device and the threshold value is determined locally by components on the mobile device. The threshold value can be determined for all requests over all resources server over all networks for example. The threshold value can be set to a specific constant value e.g. 30 seconds for example to be used for all requests or any request which does not have an applicable threshold value e.g. long poll is detected if D 30 seconds .

In some instances the other clients reside on different mobile devices and the threshold can be determined by a proxy server e.g. proxy server of the host shown in the example of which is external to the mobile device and able to communicate over a wireless network with the multiple different mobile devices as will be further described with reference to .

In one embodiment the cache policy manager sends the polling schedule to the proxy server e.g. proxy server or shown in the examples of and and can be used by the proxy server in monitoring the content source for example for changed or new content updated response different from the cached response associated with a request or application . A polling schedule sent to the proxy can include multiple timing parameters including but not limited to interval time from request 1 to request 2 or a time out interval time to wait for response used in long polls for example . The timing intervals RI D RT and or IT or some statistical manipulation of the above values e.g. average standard deviation etc. may all or in part be sent to the proxy server.

For example in the case when the local proxy detects a long poll the various timing intervals in a request response timing sequence e.g. D RT and or IT can be sent to the proxy server for use in polling the content source e.g. application server content host . The local proxy can also identify to the proxy server that a given application or request to be monitored is a long poll request e.g. instructing the proxy server to set a long poll flag for example . In addition the proxy server uses the various timing intervals to determine when to send keep alive indications on behalf of mobile devices.

The local cache invalidator of the caching policy manager can invalidate cache elements in the local cache e.g. cache or when new or changed data e.g. updated response is detected from the application server content source for a given request. The cached response can be determined to be invalid for the outgoing request based on a notification received from the proxy server e.g. proxy or the host server . The source which provides responses to requests of the mobile client can be monitored to determine relevancy of the cached response stored in the cache of the mobile device for the request. For example the cache invalidator can further remove delete the cached response from the cache of the mobile device when the cached response is no longer valid for a given request or a given application.

In one embodiment the cached response is removed from the cache after it is provided once again to an application which generated the outgoing request after determining that the cached response is no longer valid. The cached response can be provided again without waiting for the time interval or provided again after waiting for a time interval e.g. the time interval determined to be specific to emulate the response delay in a long poll . In one embodiment the time interval is the response delay D or an average value of the response delay D over two or more values.

The new or changed data can be for example detected by the proxy server e.g. proxy server or shown in the examples of and . When a cache entry for a given request poll has been invalidated the use of the radio on the mobile device can be enabled e.g. by the local proxy or the cache policy manager to satisfy the subsequent polling requests as further described with reference to the interaction diagram of .

One embodiment of the cache policy manager includes a cache or connect selection engine which can decide whether to use a locally cached entry to satisfy a poll content request generated at the mobile device by an application or widget. For example the local proxy or the cache policy manger can intercept a polling request made by an application e.g. mobile application on the mobile device to contact the application server content provider. The selection engine can determine whether the content received for the intercepted request has been locally stored as cache elements for deciding whether the radio of the mobile device needs to be activated to satisfy the request made by the application e.g. mobile application and also determine whether the cached response is still valid for the outgoing request prior to responding to the outgoing request using the cached response.

In one embodiment the local proxy in response to determining that relevant cached content exists and is still valid can retrieve the cached elements from the local cache to provide a response to the application e.g. mobile application which made the polling request such that a radio of the mobile device is not activated to provide the response to the application e.g. mobile application . In general the local proxy continues to provide the cached response each time the outgoing request is received until the updated response different from the cached response is detected.

When it is determined that the cached response is no longer valid a new request for a given request is transmitted over the wireless network for an updated response. The request can be transmitted to the application server content provider e.g. server host or the proxy server on the host server e.g. proxy on the host for a new and updated response. In one embodiment the cached response can be provided again as a response to the outgoing request if a new response is not received within the time interval prior to removal of the cached response from the cache on the mobile device.

In one embodiment the caching policy manager includes a cache defeat resolution engine an identifier formalizer a cache appropriateness decision engine a poll schedule generator an application protocol module a cache or connect selection engine having a cache query module and or a local cache invalidator . The cache defeat resolution engine can further include a pattern extraction module and or a cache defeat parameter detector . The cache defeat parameter detector can further include a random parameter detector and or a time date parameter detector . One embodiment further includes an application cache policy repository coupled to the decision engine .

In one embodiment the application behavior detector includes a pattern detector a poll interval detector an application profile generator and or a priority engine . The pattern detector can further include a cache defeat parameter detector having also for example a random parameter detector and or a time date parameter detector . One embodiment further includes an application profile repository coupled to the application profile generator . The application profile generator and the priority engine have been described in association with the description of the application behavior detector in the example of .

The cache defeat resolution engine can detect identify track manage and or monitor content or content sources e.g. servers or hosts which employ identifiers and or are addressed by identifiers e.g. resource identifiers such as URLs and or URIs with one or more mechanisms that defeat cache or are intended to defeat cache. The cache defeat resolution engine can for example detect from a given data request generated by an application or client that the identifier defeats or potentially defeats cache where the data request otherwise addresses content or responses from a host or server e.g. application server content host or that is cacheable.

In one embodiment the cache defeat resolution engine detects or identifies cache defeat mechanisms used by content sources e.g. application server content host or using the identifier of a data request detected at the mobile device . The cache defeat resolution engine can detect or identify a parameter in the identifier which can indicate that cache defeat mechanism is used. For example a format syntax or pattern of the parameter can be used to identify cache defeat e.g. a pattern format or syntax as determined or extracted by the pattern extraction module .

The pattern extraction module can parse an identifier into multiple parameters or components and perform a matching algorithm on each parameter to identify any of which match one or more predetermined formats e.g. a date and or time format as illustrated in parameters shown in . For example the results of the matching or the parsed out parameters from an identifier can be used e.g. by the cache defeat parameter detector to identify cache defeating parameters which can include one or more changing parameters.

The cache defeat parameter detector in one embodiment can detect random parameters e.g. by the random parameter detector and or time and or date parameters which are typically used for cache defeat. The cache defeat parameter detector can detect random parameters e.g. as illustrated in parameters shown in and or time dates using commonly employed formats for these parameters and performing pattern matching algorithms and tests.

In addition to detecting patterns formats and or syntaxes the cache defeat parameter detector further determines or confirms whether a given parameter is defeating cache and whether the addressed content can be cached by the distributed caching system. The cache defeat parameter detector can detect this by analyzing responses received for the identifiers utilized by a given data request. In general a changing parameter in the identifier is identified to indicate cache defeat when responses corresponding to multiple data requests are the same even when the multiple data requests uses identifiers with the changing parameter being different for each of the multiple data requests. For example the request response pairs shown in the examples of illustrate that the responses and in received are the same even though the resource identifier includes a parameter and in that changes with each request.

For example at least two same responses may be required to identify the changing parameter as indicating cache defeat. In some instances at least three same responses may be required. The requirement for the number of same responses needed to determine that a given parameter with a varying value between requests is cache defeating may be application specific context dependent and or user dependent user specified or a combination of the above. Such a requirement may also be static or dynamically adjusted by the distributed cache system to meet certain performance thresholds and or either explicit implicit feedback regarding user experience e.g. whether the user or application is receiving relevant fresh content responsive to requests . More of the same responses may be required to confirm cache defeat or for the system to treat a given parameter as intended for cache defeat if an application begins to malfunction due to response caching and or if the user expresses dissatisfaction explicit user feedback or the system detects user frustration implicit user cues .

The cache appropriateness decision engine can detect assess or determine whether content from a content source e.g. application server content provider in the example of with which a mobile device interacts has content that may be suitable for caching. In some instances content from a given application server content provider e.g. the server provider of is determined to be suitable for caching based on a set of criteria for example criteria specifying time criticality of the content that is being requested from the content source . In one embodiment the local proxy e.g. the local proxy or of and applies a selection criteria to store the content from the host server which is requested by an application as cached elements in a local cache on the mobile device to satisfy subsequent requests made by the application.

The selection criteria can also include by way of example but not limitation state of the mobile device indicating whether the mobile device is active or inactive network conditions and or radio coverage statistics. The cache appropriateness decision engine can any one or any combination of the criteria and in any order in identifying sources for which caching may be suitable.

Once application servers content providers having identified or detected content that is potentially suitable for local caching on the mobile device the cache policy manager can proceed to cache the associated content received from the identified sources by storing content received from the content source as cache elements in a local cache e.g. local cache or shown in the examples of and respectively on the mobile device . The content source can also be identified to a proxy server e.g. proxy server or shown in the examples of and respectively remote from and in wireless communication with the mobile device such that the proxy server can monitor the content source e.g. application server content provider for new or changed data. Similarly the local proxy e.g. the local proxy or of and respectively can identify to the proxy server that content received from a specific application server content provider is being stored as cached elements in the local cache.

In one embodiment cache elements are stored in the local cache as being associated with a normalized version of an identifier for an identifier employing one or more parameters intended to defeat cache. The identifier can be normalized by the identifier normalizer module and the normalization process can include by way of example one or more of converting the URI scheme and host to lower case capitalizing letters in percent encoded escape sequences removing a default port and removing duplicate slashes.

In another embodiment the identifier is normalized by removing the parameter for cache defeat and or replacing the parameter with a static value which can be used to address or be associated with the cached response received responsive to a request utilizing the identifier by the normalizer or the cache defeat parameter handler . For example the cached elements stored in the local cache shown in can be identified using the normalized version of the identifier or a hash value of the normalized version of the identifier. The hash value of an identifier or of the normalized identifier may be generated by the hash engine .

Once content has been locally cached the cache policy manager can upon receiving future polling requests to contact the content server retrieve the cached elements from the local cache to respond to the polling request made at the mobile device such that a radio of the mobile device is not activated to service the polling request. Such servicing and fulfilling application e.g. mobile application requests locally via local cache entries allow for more efficient resource and mobile network traffic utilization and management since network bandwidth and other resources need not be used to request receive poll responses which may have not changed from a response that has already been received at the mobile device .

One embodiment of the cache policy manager includes a poll schedule generator which can generate a polling schedule for one or more applications on the mobile device . The polling schedule can specify a polling interval that can be employed by the proxy server e.g. proxy server or shown in the examples of and in monitoring the content source for one or more applications. The polling schedule can be determined for example based on the interval between the polling requests directed to the content source from the mobile device. In one embodiment the poll interval detector of the application behavior detector can monitor polling requests directed to a content source from the mobile device in order to determine an interval between the polling requests made from any or all application e.g. mobile application .

In one embodiment the cache policy manager sends the polling schedule is sent to the proxy server e.g. proxy server or shown in the examples of and and can be used by the proxy server in monitoring the content source for example for changed or new content. The local cache invalidator of the caching policy manager can invalidate cache elements in the local cache e.g. cache or when new or changed data is detected from the application server content source for a given request. The new or changed data can be for example detected by the proxy server. When a cache entry for a given request poll has been invalidated and or removed e.g. deleted from cache after invalidation the use of the radio on the mobile device can be enabled e.g. by the local proxy or the cache policy manager to satisfy the subsequent polling requests as further described with reference to the interaction diagram of .

In another embodiment the proxy server e.g. proxy server or shown in the examples of and uses a modified version of a resource identifier used in a data request to monitor a given content source the application server content host of and to which the data request is addressed for new or changed data. For example in the instance where the content source or identifier is detected to employ cache defeat mechanisms a modified e.g. normalized identifier can be used instead to poll the content source. The modified or normalized version of the identifier can be communicated to the proxy server by the caching policy manager or more specifically the cache defeat parameter handler of the identifier normalizer .

The modified identifier used by the proxy server to poll the content source on behalf of the mobile device application e.g. mobile application may or may not be the same as the normalized identifier. For example the normalized identifier may be the original identifier with the changing cache defeating parameter removed whereas the modified identifier uses a substitute parameter in place of the parameter that is used to defeat cache e.g. the changing parameter replaced with a static value or other predetermined value known to the local proxy and or proxy server . The modified parameter can be determined by the local proxy and communicated to the proxy server. The modified parameter may also be generated by the proxy server e.g. by the identifier modifier module shown in the example of .

One embodiment of the cache policy manager includes a cache or connect selection engine which can decide whether to use a locally cached entry to satisfy a poll content request generated at the mobile device by an application or widget. For example the local proxy or the cache policy manger can intercept a polling request made by an application e.g. mobile application on the mobile device to contact the application server content provider. The selection engine can determine whether the content received for the intercepted request has been locally stored as cache elements for deciding whether the a radio of the mobile device needs to be activated to satisfy the request made by the application e.g. mobile application . In one embodiment the local proxy in response to determining that relevant cached content exists and is still valid can retrieve the cached elements from the local cache to provide a response to the application e.g. mobile application which made the polling request such that a radio of the mobile device is not activated to provide the response to the application e.g. mobile application .

In one embodiment the cached elements stored in the local cache shown in can be identified using a normalized version of the identifier or a hash value of the normalized version of the identifier for example using the cache query module . Cached elements can be stored with normalized identifiers which have cache defeating parameters removed or otherwise replaced such that the relevant cached elements can be identified and retrieved in the future to satisfy other requests employing the same type of cache defeat. For example when an identifier utilized in a subsequent request is determined to be utilizing the same cache defeating parameter the normalized version of this identifier can be generated and used to identify a cached response stored in the mobile device cache to satisfy the data request. The hash value of an identifier or of the normalized identifier may be generated by the hash engine of the identifier normalizer .

In this embodiment of the local proxy the user activity module further includes one or more of a user activity tracker a user activity prediction engine and or a user expectation manager . The application behavior detect can further include a prioritization engine a time criticality detection engine an application state categorizer and or an application traffic categorizer . The local proxy can further include a backlight detector and or a network configuration selection engine . The network configuration selection engine can further include one or more of a wireless generation standard selector a data rate specifier an access channel selection engine and or an access point selector.

In one embodiment the application behavior detector is able to detect determined identify or infer the activity state of an application on the mobile device to which traffic has originated from or is directed to for example via the application state categorizer and or the traffic categorizer . The activity state can be determined by whether the application is in a foreground or background state on the mobile device via the application state categorizer since the traffic for a foreground application vs. a background application may be handled differently.

In one embodiment the activity state can be determined detected identified or inferred with a level of certainty of heuristics based on the backlight status of the mobile device e.g. by the backlight detector or other software agents or hardware sensors on the mobile device including but not limited to resistive sensors capacitive sensors ambient light sensors motion sensors touch sensors etc. In general if the backlight is on the traffic can be treated as being or determined to be generated from an application that is active or in the foreground or the traffic is interactive. In addition if the backlight is on the traffic can be treated as being or determined to be traffic from user interaction or user activity or traffic containing data that the user is expecting within some time frame.

In one embodiment the activity state is determined based on whether the traffic is interactive traffic or maintenance traffic. Interactive traffic can include transactions from responses and requests generated directly from user activity interaction with an application and can include content or data that a user is waiting or expecting to receive. Maintenance traffic may be used to support the functionality of an application which is not directly detected by a user. Maintenance traffic can also include actions or transactions that may take place in response to a user action but the user is not actively waiting for or expecting a response.

For example a mail or message delete action at a mobile device generates a request to delete the corresponding mail or message at the server but the user typically is not waiting for a response. Thus such a request may be categorized as maintenance traffic or traffic having a lower priority e.g. by the prioritization engine and or is not time critical e.g. by the time criticality detection engine .

Contrastingly a mail read or message read request initiated by a user a the mobile device can be categorized as interactive traffic since the user generally is waiting to access content or data when they request to read a message or mail. Similarly such a request can be categorized as having higher priority e.g. by the prioritization engine and or as being time critical time sensitive e.g. by the time criticality detection engine .

The time criticality detection engine can generally determine identify infer the time sensitivity of data contained in traffic sent from the mobile device or to the mobile device from a host server e.g. host or application server e.g. app server content source . For example time sensitive data can include status updates stock information updates IM presence information email messages or other messages actions generated from mobile gaming applications webpage requests location updates etc. Data that is not time sensitive or time critical by nature of the content or request can include requests to delete messages mark as read or edited actions application specific actions such as a add friend or delete friend request certain types of messages or other information which does not frequently changing by nature etc. In some instances when the data is not time critical the timing with which to allow the traffic to pass through is set based on when additional data needs to be sent from the mobile device . For example traffic shaping engine can align the traffic with one or more subsequent transactions to be sent together in a single power on event of the mobile device radio e.g. using the alignment module and or the batching module . The alignment module can also align polling requests occurring close in time directed to the same host server since these request are likely to be responded to with the same data.

In the alternate or in combination the activity state can be determined from assessing determining evaluating inferring identifying user activity at the mobile device e.g. via the user activity module . For example user activity can be directly detected and tracked using the user activity tracker . The traffic resulting therefrom can then be categorized appropriately for subsequent processing to determine the policy for handling. Furthermore user activity can be predicted or anticipated by the user activity prediction engine . By predicting user activity or anticipating user activity the traffic thus occurring after the prediction can be treated as resulting from user activity and categorized appropriately to determine the transmission policy.

In addition the user activity module can also manage user expectations e.g. via the user expectation manager and or in conjunction with the activity tracker and or the prediction engine to ensure that traffic is categorized appropriately such that user expectations are generally met. For example a user initiated action should be analyzed e.g. by the expectation manager to determine or infer whether the user would be waiting for a response. If so such traffic should be handled under a policy such that the user does not experience an unpleasant delay in receiving such a response or action.

In one embodiment an advanced generation wireless standard network is selected for use in sending traffic between a mobile device and a host server in the wireless network based on the activity state of the application on the mobile device for which traffic is originated from or directed to. An advanced technology standards such as the 3G 3.5G 3G 4G or LTE network can be selected for handling traffic generated as a result of user interaction user activity or traffic containing data that the user is expecting or waiting for. Advanced generation wireless standard network can also be selected for to transmit data contained in traffic directed to the mobile device which responds to foreground activities.

In categorizing traffic and defining a transmission policy for mobile traffic a network configuration can be selected for use e.g. by the network configuration selection engine on the mobile device in sending traffic between the mobile device and a proxy server and or an application server e.g. app server host . The network configuration that is selected can be determined based on information gathered by the application behavior module regarding application activity state e.g. background or foreground traffic application traffic category e.g. interactive or maintenance traffic any priorities of the data content time sensitivity criticality.

The network configuration selection engine can select or specify one or more of a generation standard e.g. via wireless generation standard selector a data rate e.g. via data rate specifier an access channel e.g. access channel selection engine and or an access point e.g. via the access point selector in any combination.

For example a more advanced generation e.g. 3G LTE or 4G or later can be selected or specified for traffic when the activity state is in interaction with a user or in a foreground on the mobile device. Contrastingly an older generation standard e.g. 2G 2.5G or 3G or older can be specified for traffic when one or more of the following is detected the application is not interacting with the user the application is running in the background on the mobile device or the data contained in the traffic is not time critical or is otherwise determined to have lower priority.

Similarly a network configuration with a slower data rate can be specified for traffic when one or more of the following is detected the application is not interacting with the user the application is running in the background on the mobile device or the data contained in the traffic is not time critical. The access channel e.g. Forward access channel or dedicated channel can be specified.

The host server generally includes for example a network interface and or one or more repositories and . Note that server may be any portable mobile or non portable device server cluster of computers and or other types of processing units e.g. any number of a machine shown in the example of able to receive or transmit signals to satisfy data requests over a network including any wired or wireless networks e.g. WiFi cellular Bluetooth etc. .

The network interface can include networking module s or devices s that enable the server to mediate data in a network with an entity that is external to the host server through any known and or convenient communications protocol supported by the host and the external entity. Specifically the network interface allows the server to communicate with multiple devices including mobile phone devices and or one or more application servers content providers .

The host server can store information about connections e.g. network characteristics conditions types of connections etc. with devices in the connection metadata repository . Additionally any information about third party application or content providers can also be stored in the repository . The host server can store information about devices e.g. hardware capability properties device settings device language network capability manufacturer device model OS OS version etc. in the device information repository . Additionally the host server can store information about network providers and the various network service areas in the network service provider repository .

The communication enabled by network interface allows for simultaneous connections e.g. including cellular connections with devices and or connections e.g. including wired wireless HTTP Internet connections LAN WiFi etc. with content servers providers to manage the traffic between devices and content providers for optimizing network resource utilization and or to conserver power battery consumption on the serviced devices . The host server can communicate with mobile devices serviced by different network service providers and or in the same different network service areas. The host server can operate and is compatible with devices with varying types or levels of mobile capabilities including by way of example but not limitation 1G 2G 2G transitional 2.5G 2.75G 3G IMT 2000 3G transitional 3.5G 3.75G 3.9G 4G IMT advanced etc.

In general the network interface can include one or more of a network adaptor card a wireless network interface card e.g. SMS interface WiFi interface interfaces for various generations of mobile communication standards including but not limited to 1G 2G 3G 3.5G 4G type networks such as LTE WiMAX etc. Bluetooth WiFi or any other network whether or not connected via a router an access point a wireless router a switch a multilayer switch a protocol converter a gateway a bridge a bridge router a hub a digital media receiver and or a repeater.

The host server can further include server side components of the distributed proxy and cache system which can include a proxy server and a server cache . In one embodiment the proxy server can include an HTTP access engine a caching policy manager a proxy controller a traffic shaping engine a new data detector and or a connection manager .

The HTTP access engine may further include a heartbeat manager the proxy controller may further include a data invalidator module the traffic shaping engine may further include a control protocol and a batching module . Additional or less components modules engines can be included in the proxy server and each illustrated component.

As used herein a module a manager a handler a detector an interface a controller a normalizer a generator an invalidator or an engine includes a general purpose dedicated or shared processor and typically firmware or software modules that are executed by the processor. Depending upon implementation specific or other considerations the module manager handler detector interface controller normalizer generator invalidator or engine can be centralized or its functionality distributed. The module manager handler detector interface controller normalizer generator invalidator or engine can include general or special purpose hardware firmware or software embodied in a computer readable storage medium for execution by the processor. As used herein a computer readable medium or computer readable storage medium is intended to include all mediums that are statutory e.g. in the United States under 35 U.S.C. 101 and to specifically exclude all mediums that are non statutory in nature to the extent that the exclusion is necessary for a claim that includes the computer readable storage medium to be valid. Known statutory computer readable mediums include hardware e.g. registers random access memory RAM non volatile NV storage to name a few but may or may not be limited to hardware.

In the example of a device e.g. mobile device making an application or content request to an application server or content provider the request may be intercepted and routed to the proxy server which is coupled to the device and the application server content provider . Specifically the proxy server is able to communicate with the local proxy e.g. proxy and of the examples of and respectively of the mobile device the local proxy forwards the data request to the proxy server in some instances for further processing and if needed for transmission to the application server content server for a response to the data request.

In such a configuration the host or the proxy server in the host server can utilize intelligent information provided by the local proxy in adjusting its communication with the device in such a manner that optimizes use of network and device resources. For example the proxy server can identify characteristics of user activity on the device to modify its communication frequency. The characteristics of user activity can be determined by for example the activity behavior awareness module in the proxy controller via information collected by the local proxy on the device .

In one embodiment communication frequency can be controlled by the connection manager of the proxy server for example to adjust push frequency of content or updates to the device . For instance push frequency can be decreased by the connection manager when characteristics of the user activity indicate that the user is inactive. In one embodiment when the characteristics of the user activity indicate that the user is subsequently active after a period of inactivity the connection manager can adjust the communication frequency with the device to send data that was buffered as a result of decreased communication frequency to the device .

In addition the proxy server includes priority awareness of various requests transactions sessions applications and or specific events. Such awareness can be determined by the local proxy on the device and provided to the proxy server . The priority awareness module of the proxy server can generally assess the priority e.g. including time criticality time sensitivity etc. of various events or applications additionally the priority awareness module can track priorities determined by local proxies of devices .

In one embodiment through priority awareness the connection manager can further modify communication frequency e.g. use or radio as controlled by the radio controller of the server with the devices . For example the server can notify the device thus requesting use of the radio if it is not already in use when data or updates of an importance priority level which meets a criteria becomes available to be sent.

In one embodiment the proxy server can detect multiple occurrences of events e.g. transactions content data received from server provider and allow the events to accumulate for batch transfer to device . Batch transfer can be cumulated and transfer of events can be delayed based on priority awareness and or user activity application behavior awareness as tracked by modules and or . For example batch transfer of multiple events of a lower priority to the device can be initiated by the batching module when an event of a higher priority meeting a threshold or criteria is detected at the server . In addition batch transfer from the server can be triggered when the server receives data from the device indicating that the device radio is already in use and is thus on. In one embodiment the proxy server can order the each messages packets in a batch for transmission based on event transaction priority such that higher priority content can be sent first in case connection is lost or the battery dies etc.

In one embodiment the server caches data e.g. as managed by the caching policy manager such that communication frequency over a network e.g. cellular network with the device can be modified e.g. decreased . The data can be cached for example in the server cache for subsequent retrieval or batch sending to the device to potentially decrease the need to turn on the device radio. The server cache can be partially or wholly internal to the host server although in the example of it is shown as being external to the host . In some instances the server cache may be the same as and or integrated in part or in whole with another cache managed by another entity e.g. the optional caching proxy server shown in the example of such as being managed by an application server content provider a network service provider or another third party.

In one embodiment content caching is performed locally on the device with the assistance of host server . For example proxy server in the host server can query the application server provider with requests and monitor changes in responses. When changed or new responses are detected e.g. by the new data detector the proxy server can notify the mobile device such that the local proxy on the device can make the decision to invalidate e.g. indicated as out dated the relevant cache entries stored as any responses in its local cache. Alternatively the data invalidator module can automatically instruct the local proxy of the device to invalidate certain cached data based on received responses from the application server provider . The cached data is marked as invalid and can get replaced or deleted when new content is received from the content server .

Note that data change can be detected by the detector in one or more ways. For example the server provider can notify the host server upon a change. The change can also be detected at the host server in response to a direct poll of the source server provider . In some instances the proxy server can in addition pre load the local cache on the device with the new updated data. This can be performed when the host server detects that the radio on the mobile device is already in use or when the server has additional content data to be sent to the device .

One or more the above mechanisms can be implemented simultaneously or adjusted configured based on application e.g. different policies for different servers providers . In some instances the source provider server may notify the host for certain types of events e.g. events meeting a priority threshold level . In addition the provider server may be configured to notify the host at specific time intervals regardless of event priority.

In one embodiment the proxy server of the host can monitor track responses received for the data request from the content source for changed results prior to returning the result to the mobile device such monitoring may be suitable when data request to the content source has yielded same results to be returned to the mobile device thus preventing network power consumption from being used when no new changes are made to a particular requested. The local proxy of the device can instruct the proxy server to perform such monitoring or the proxy server can automatically initiate such a process upon receiving a certain number of the same responses e.g. or a number of the same responses in a period of time for a particular request.

In one embodiment the server through the activity behavior awareness module is able to identify or detect user activity at a device that is separate from the mobile device . For example the module may detect that a user s message inbox e.g. email or types of inbox is being accessed. This can indicate that the user is interacting with his her application using a device other than the mobile device and may not need frequent updates if at all.

The server in this instance can thus decrease the frequency with which new or updated content is sent to the mobile device or eliminate all communication for as long as the user is detected to be using another device for access. Such frequency decrease may be application specific e.g. for the application with which the user is interacting with on another device or it may be a general frequency decrease E.g. since the user is detected to be interacting with one server or one application via another device he she could also use it to access other services. to the mobile device .

In one embodiment the host server is able to poll content sources on behalf of devices to conserve power or battery consumption on devices . For example certain applications on the mobile device can poll its respective server in a predictable recurring fashion. Such recurrence or other types of application behaviors can be tracked by the activity behavior module in the proxy controller . The host server can thus poll content sources for applications on the mobile device that would otherwise be performed by the device through a wireless e.g. including cellular connectivity . The host server can poll the sources for new or changed data by way of the HTTP access engine to establish HTTP connection or by way of radio controller to connect to the source over the cellular network. When new or changed data is detected the new data detector can notify the device that such data is available and or provide the new changed data to the device .

In one embodiment the connection manager determines that the mobile device is unavailable e.g. the radio is turned off and utilizes SMS to transmit content to the device for instance via the SMSC shown in the example of . SMS is used to transmit invalidation messages batches of invalidation messages or even content in the case where the content is small enough to fit into just a few usually one or two SMS messages. This avoids the need to access the radio channel to send overhead information. The host server can use SMS for certain transactions or responses having a priority level above a threshold or otherwise meeting a criteria. The server can also utilize SMS as an out of band trigger to maintain or wake up an IP connection as an alternative to maintaining an always on IP connection.

In one embodiment the connection manager in the proxy server e.g. the heartbeat manager can generate and or transmit heartbeat messages on behalf of connected devices to maintain a backend connection with a provider for applications running on devices .

For example in the distributed proxy system local cache on the device can prevent any or all heartbeat messages needed to maintain TCP IP connections required for applications from being sent over the cellular or other network and instead rely on the proxy server on the host server to generate and or send the heartbeat messages to maintain a connection with the backend e.g. application server provider in the example of . The proxy server can generate the keep alive heartbeat messages independent of the operations of the local proxy on the mobile device.

The repositories and or can additionally store software descriptive data images system information drivers and or any other data item utilized by other components of the host server and or any other servers for operation. The repositories may be managed by a database management system DBMS for example which may be but is not limited to Oracle DB2 Microsoft Access Microsoft SQL Server PostgreSQL MySQL FileMaker etc.

The repositories can be implemented via object oriented technology and or via text files and can be managed by a distributed database management system an object oriented database management system OODBMS e.g. ConceptBase FastDB Main Memory Database Management System JDOInstruments ObjectDB etc. an object relational database management system ORDBMS e.g. Informix OpenLink Virtuoso VMDS etc. a file system and or any other convenient or known database management package.

The caching policy manager in one embodiment can further include a metadata generator a cache look up engine an application protocol module a content source monitoring engine having a poll schedule manager a response analyzer and or an updated or new content detector . In one embodiment the poll schedule manager further includes a host timing simulator a long poll request detector manager a schedule update engine and or a time adjustment engine . The metadata generator and or the cache look up engine can be coupled to the cache or server cache for modification or addition to cache entries or querying thereof.

In one embodiment the proxy server e.g. the proxy server or of the examples of and can monitor a content source for new or changed data via the monitoring engine . The proxy server as shown is an entity external to the mobile device of . The content source e.g. application server content provider of can be one that has been identified to the proxy server e.g. by the local proxy as having content that is being locally cached on a mobile device e.g. mobile device or . The content source can be monitored for example by the monitoring engine at a frequency that is based on polling frequency of the content source at the mobile device. The poll schedule can be generated for example by the local proxy and sent to the proxy server. The poll frequency can be tracked and or managed by the poll schedule manager .

For example the proxy server can poll the host e.g. content provider application server on behalf of the mobile device and simulate the polling behavior of the client to the host via the host timing simulator . The polling behavior can be simulated to include characteristics of a long poll request response sequences experienced in a persistent connection with the host e.g. by the long poll request detector manager . Note that once a polling interval behavior is set the local proxy on the device side and or the proxy server on the server side can verify whether application and application server content host behavior match or can be represented by this predicted pattern. In general the local proxy and or the proxy server can detect deviations and when appropriate re evaluate and compute determine or estimate another polling interval.

In one embodiment the caching policy manager on the server side of the distribute proxy can in conjunction with or independent of the proxy server on the mobile device identify or detect long poll requests. For example the caching policy manager can determine a threshold value to be used in comparison with a response delay interval time in a request response sequence for an application request to identify or detect long poll requests possible long poll requests e.g. requests for a persistent connection with a host with which the client communicates including but not limited to a long held HTTP request a persistent connection enabling COMET style push request for HTTP streaming etc. or other requests which can otherwise be treated as a long poll request.

For example the threshold value can be determined by the proxy using response delay interval times for requests generated by clients applications across mobile devices which may be serviced by multiple different cellular or wireless networks. Since the proxy resides on host is able to communicate with multiple mobile devices via multiple networks the caching policy manager has access to application client information at a global level which can be used in setting threshold values to categorize and detect long polls.

By tracking response delay interval times across applications across devices over different or same networks the caching policy manager can set one or more threshold values to be used in comparison with response delay interval times for long poll detection. Threshold values set by the proxy server can be static or dynamic and can be associated with conditions and or a time to live an expiration time date in relative or absolute terms .

In addition the caching policy manager of the proxy can further determine the threshold value in whole or in part based on network delays of a given wireless network networks serviced by a given carrier service provider or multiple wireless networks. The proxy can also determine the threshold value for identification of long poll requests based on delays of one or more application server content provider e.g. to which application e.g. mobile application or mobile client requests are directed.

The proxy server can detect new or changed data at a monitored content source and transmits a message to the mobile device notifying it of such a change such that the mobile device or the local proxy on the mobile device can take appropriate action e.g. to invalidate the cache elements in the local cache . In some instances the proxy server e.g. the caching policy manager upon detecting new or changed data can also store the new or changed data in its cache e.g. the server cache or of the examples of and respectively . The new updated data stored in the server cache can be used in some instances to satisfy content requests at the mobile device for example it can be used after the proxy server has notified the mobile device of the new changed content and that the locally cached content has been invalidated.

The metadata generator similar to the metadata generator shown in the example of can generate metadata for responses cached for requests at the mobile device . The metadata generator can generate metadata for cache entries stored in the server cache . Similarly the cache look up engine can include the same or similar functions are those described for the cache look up engine shown in the example of .

The response analyzer can perform any or all of the functionalities related to analyzing responses received for requests generated at the mobile device in the same or similar fashion to the response analyzer of the local proxy shown in the example of . Since the proxy server is able to receive responses from the application server content source directed to the mobile device the proxy server e.g. the response analyzer can perform similar response analysis steps to determine cacheability as described for the response analyzer of the local proxy. Examples of response analysis procedures are also described in conjunction with the flow charts shown in the examples of . The responses can be analyzed in addition to or in lieu of the analysis that can be performed at the local proxy on the mobile device .

Furthermore the schedule update engine can update the polling interval of a given application server content host based on application request interval changes of the application at the mobile device as described for the schedule update engine in the local proxy . The time adjustment engine can set an initial time at which polls of the application server content host is to begin to prevent the serving of out of date content once again before serving fresh content as described for the schedule update engine in the local proxy . Both the schedule updating and the time adjustment algorithms can be performed in conjunction with or in lieu of the similar processes performed at the local proxy on the mobile device .

The caching policy manager in one embodiment can further include a cache defeating source manager a content source monitoring engine having a poll schedule manager and or an updated or new content detector . The cache defeating source manager can further include an identifier modifier module and or an identifier pattern tracking module .

In one embodiment the proxy server e.g. the proxy server or of the examples of and can monitor a content source for new or changed data via the monitoring engine . The content source e.g. application server content provider of of can be one that has been identified to the proxy server e.g. by the local proxy as having content that is being locally cached on a mobile device e.g. mobile device or . The content source can be monitored for example by the monitoring engine at a frequency that is based on polling frequency of the content source at the mobile device. The poll schedule can be generated for example by the local proxy and sent to the proxy server . The poll frequency can be tracked and or managed by the poll schedule manager .

In one embodiment the proxy server uses a normalized identifier or modified identifier in polling the content source to detect new or changed data responses . The normalized identifier or modified identifier can also be used by the proxy server in storing responses on the server cache . In general the normalized or modified identifiers can be used when cache defeat mechanisms are employed for cacheable content. Cache defeat mechanisms can be in the form of a changing parameter in an identifier such as a URI or URL and can include a changing time data parameter a randomly varying parameter or other types parameters.

The normalized identifier or modified identifier removes or otherwise replaces the changing parameter for association with subsequent requests and identification of associated responses and can also be used to poll the content source. In one embodiment the modified identifier is generated by the cache defeating source manager e.g. the identifier modifier module of the caching policy manager on the proxy server server side component of the distributed proxy system . The modified identifier can utilize a substitute parameter which is generally static over a period of time in place of the changing parameter that is used to defeat cache.

The cache defeating source manager optionally includes the identifier pattern tracking module to track store and monitor the various modifications of an identifier or identifiers that address content for one or more content sources e.g. application server content host or to continuously verify that the modified identifiers and or normalized identifiers used by the proxy server to poll the content sources work as predicted or intended e.g. receive the same responses or responses that are otherwise still relevant compared to the original unmodified identifier .

In the event that the pattern tracking module detects a modification or normalization of an identifier that causes erratic or unpredictable behavior e.g. unexpected responses to be sent on the content source the tracking module can log the modification and instruct the cache defeating source manager to generate another modification normalization or notify the local proxy e.g. local proxy to generate another modification normalization for use in polling the content source. In the alternative or in parallel the requests from the given mobile application client on the mobile device e.g. mobile device can temporarily be sent across the network to the content source for direct responses to be provided to the mobile device and or until a modification of an identifier which works can be generated.

In one embodiment responses are stored as server cache elements in the server cache when new or changed data is detected for a response that is already stored on a local cache e.g. cache of the mobile device e.g. mobile device . Therefore the mobile device or local proxy can connect to the proxy server to retrieve the new or changed data for a response to a request which was previously cached locally in the local cache now invalid out dated or otherwise determined to be irrelevant .

The proxy server can detect new or changed data at a monitored application server content host and transmits a message to the mobile device notifying it of such a change such that the mobile device or the local proxy on the mobile device can take appropriate action e.g. to invalidate the cache elements in the local cache . In some instances the proxy server e.g. the caching policy manager upon detecting new or changed data can also store the new or changed data in its cache e.g. the server cache or of the examples of and respectively . The updated new data stored in the server cache can be used in some instances to satisfy content requests at the mobile device for example it can be used after the proxy server has notified the mobile device of the new changed content and that the locally cached content has been invalidated.

In one embodiment of the proxy server the traffic shaping engine is further coupled to a traffic analyzer for categorizing mobile traffic for policy definition and implementation for mobile traffic and transactions directed to one or more mobile devices e.g. mobile device of or to an application server content host e.g. of . In general the proxy server is remote from the mobile devices and remote from the host server as shown in the examples of . The proxy server or the host server can monitor the traffic for multiple mobile devices and is capable of categorizing traffic and devising traffic policies for different mobile devices.

In addition the proxy server or host server can operate with multiple carriers or network operators and can implement carrier specific policies relating to categorization of traffic and implementation of traffic policies for the various categories. For example the traffic analyzer of the proxy server or host server can include one or more of a prioritization engine a time criticality detection engine an application state categorizer and or an application traffic categorizer

Each of these engines or modules can track different criterion for what is considered priority time critical background foreground or interactive maintenance based on different wireless carriers. Different criterion may also exist for different mobile device types e.g. device model manufacturer operating system etc. . In some instances the user of the mobile devices can adjust the settings or criterion regarding traffic category and the proxy server is able to track and implement these user adjusted configured settings.

In one embodiment the traffic analyzer is able to detect determined identify or infer the activity state of an application on one or more mobile devices e.g. mobile device or which traffic has originated from or is directed to for example via the application state categorizer and or the traffic categorizer . The activity state can be determined based on whether the application is in a foreground or background state on one or more of the mobile devices via the application state categorizer since the traffic for a foreground application vs. a background application may be handled differently to optimize network use.

In the alternate or in combination the activity state of an application can be determined by the wirelessly connected mobile devices e.g. via the application behavior detectors in the local proxies and communicated to the proxy server . For example the activity state can be determined detected identified or inferred with a level of certainty of heuristics based on the backlight status at mobile devices e.g. by a backlight detector or other software agents or hardware sensors on the mobile device including but not limited to resistive sensors capacitive sensors ambient light sensors motion sensors touch sensors etc. In general if the backlight is on the traffic can be treated as being or determined to be generated from an application that is active or in the foreground or the traffic is interactive. In addition if the backlight is on the traffic can be treated as being or determined to be traffic from user interaction or user activity or traffic containing data that the user is expecting within some time frame.

The activity state can be determined from assessing determining evaluating inferring identifying user activity at the mobile device e.g. via the user activity module and communicated to the proxy server . In one embodiment the activity state is determined based on whether the traffic is interactive traffic or maintenance traffic. Interactive traffic can include transactions from responses and requests generated directly from user activity interaction with an application and can include content or data that a user is waiting or expecting to receive. Maintenance traffic may be used to support the functionality of an application which is not directly detected by a user. Maintenance traffic can also include actions or transactions that may take place in response to a user action but the user is not actively waiting for or expecting a response.

The time criticality detection engine can generally determine identify infer the time sensitivity of data contained in traffic sent from the mobile device or to the mobile device from the host server or proxy server or the application server e.g. app server content source . For example time sensitive data can include status updates stock information updates IM presence information email messages or other messages actions generated from mobile gaming applications webpage requests location updates etc.

Data that is not time sensitive or time critical by nature of the content or request can include requests to delete messages mark as read or edited actions application specific actions such as a add friend or delete friend request certain types of messages or other information which does not frequently changing by nature etc. In some instances when the data is not time critical the timing with which to allow the traffic to be sent to a mobile device is based on when there is additional data that needs to the sent to the same mobile device. For example traffic shaping engine can align the traffic with one or more subsequent transactions to be sent together in a single power on event of the mobile device radio e.g. using the alignment module and or the batching module . The alignment module can also align polling requests occurring close in time directed to the same host server since these request are likely to be responded to with the same data.

In general whether new or changed data is sent from a host server to a mobile device can be determined based on whether an application on the mobile device to which the new or changed data is relevant is running in a foreground e.g. by the application state categorizer or the priority or time criticality of the new or changed data. The proxy server can send the new or changed data to the mobile device if the application is in the foreground on the mobile device or if the application is in the foreground and in an active state interacting with a user on the mobile device and or whether a user is waiting for a response that would be provided in the new or changed data. The proxy server or traffic shaping engine can send the new or changed data that is of a high priority or is time critical.

Similarly the proxy server or the traffic shaping engine can suppressing the sending of the new or changed data if the application is in the background on the mobile device. The proxy server can also suppress the sending of the new or changed data if the user is not waiting for the response provided in the new or changed data wherein the suppressing is performed by a proxy server coupled to the host server and able to wirelessly connect to the mobile device.

In general if data including new or change data is of a low priority or is not time critical the proxy server can waiting to transfer the data until after a time period or until there is additional data to be sent e.g. via the alignment module and or the batching module .

The DNS harmonization component and the DNS resolver of the device operating system operate in conjunction to provide cached responses to DNS queries of mobile applications or . The DNS harmonization component in one embodiment maintains the cached responses to DNS queries longer than the DNS resolver otherwise would thus reducing the instances where DNS queries would need to be placed over the air thus reducing mobile network traffic that would otherwise be consumed for DNS queries.

The DNS harmonization component is able to intelligently maintain and serve cached responses to DNS queries for a longer period of time and ensure that they are still valid due to its interaction with a remote entity which monitors the application host service provider for changed or new responses to given DNS queries e.g. the server side proxy shown in the example of as described below.

The architecture for traffic reduction includes a mobile device connected to a wireless network by a radio . The wireless network is communicatively coupled to a domain name system server DNS server . The communicative coupling of the wireless network and the DNS server can be facilitated by a harmonization server .

The domain name system may be a computer network e.g. a public computer network such as the Internet that incorporates one or more computers or servers configured to map domain names to numerical identifiers for example in accordance with one or more Internet Engineering Task Force IETF Request for Comments RFC documents including P. Mockapetris Domain Names Concepts and Facilities IETF RFC 1034 November 1987 P. Mockapetris Domain Names Implementation and Specification IETF RFC 1035 November 1987 R. Braden et al. Requirements for Internet Hosts Application and Support IETF RFC 1123 October 1989 and or Elz et al. Clarifications to the DNS Specification IETF RFC 2181 July 1997 each of which is incorporated herein by reference.

The mobile device can include a system space having computing resources reserved for an operating system of the mobile device and the user space can include resources reserved for mobile applications accessed by users of the mobile device . For example user application can include a web browser or any mobile application client that makes application programming interface API calls to a DNS resolver . In one embodiment the DNS resolver is a DNS resolver of a mobile device operating system. Typically operating system DNS resolvers manage and maintain a DNS resolver cache which is configured at least to cache and store associations between domain names and network addresses determined from a DNS server . In general DNS resolvers also generate DNS protocol messages .

In accordance with embodiments of the present disclosure the mobile device further includes a DNS harmonization component e.g. such as the harmonization component shown in the example of which can monitor and or intercept outgoing DNS protocol messages and associated responses. The DNS Harmonization component can store DNS protocol request response pairs in the harmonization cache and can match outgoing DNS protocol messages to stored pairs. Should a match be found the DNS Harmonization component can generate a responsive DNS protocol message using the stored response of the matching pair such that the query need not be sent over the radio to resolve the DNS query.

If no match is found in the harmonization cache the DNS harmonization component can instead forward an outgoing DNS protocol message to a corresponding domain name system DNS server via the device radio and wireless network to resolve the DNS query. With respect to stored request response pairs in the harmonization cache the DNS harmonization component can instruct the harmonization server to monitor the domain name system DNS server for changes to corresponding domain name network address associations address bindings .

The DNS harmonization component can continue to serve the responses stored in the harmonization cache typically until a change or invalidate is received from the harmonization server for a period of time that is longer than the DNS resolver would serve responses in its cache . Upon detection of a change the harmonization server may notify the DNS Harmonization component to invalidate the corresponding harmonization cache entry so that it will be refreshed once the local DNS cache entry becomes invalid which occurs independently . Thus cache entries stored in the harmonization cache of the disclosed technology are updated dynamically and changed when needed rather than based on a pre configured setting e.g. of the device operating system designed to capture quickest changes at any given host e.g. DNS server . In this manner different hosts can be monitored differently and DNS requests can be sent over the radio to access the wireless network when needed for any given query from any given application . This is a lesser frequency than the situation when only the DNS resolver cache of the DNS resolver is used thus effectively conserving network resources and bandwidth consumption.

In one embodiment the DNS harmonization component can include an extended DNS caching engine that can determine a time period for caching DNS requests based on transactions that are being managed e.g. by caching delaying blocking delaying opening of sockets and the like for which the DNS requests were issued and cache the DNS requests for at least the determined time to ensure that the DNS requests for the transactions are not sent over the radio to access the wireless network . Thus when DNS messages or requests for cached blocked delayed or otherwise managed transactions are detected the DNS harmonization component can intercept such DNS requests and respond with cached DNS responses from the local cache . This allows the management of application traffic to remain effective in optimizing signaling in the wireless network and conserving power resources. In the absence of extended DNS caching a DNS request would cause the radio to go up even if the transaction following the DNS request would be cached blocked delayed clumped and the like.

In a further embodiment the DNS harmonization component the DNS Resolver or another component in the mobile device can include a reverse DNS request caching engine that can cache reverse DNS requests such as the reverse DNS requests that are part of the SSL handshake when caching or operating on HTTPS requests. The traffic harmonization component can detect reverse DNS requests for the cached HTTPS requests or delayed or blocked HTTPS requests and intercept the reverse DNS requests so that the reverse DNS requests are not sent over the radio to access the wireless network . In the absence of the reverse DNS request caching the reverse DNS request would cause the radio to go up even if the HTTPS request would have been served from cache.

Further the DNS harmonization component can include a reverse DNS mapping engine that maintains a reverse mapping from IP address to host names. Using the reverse mapping the reverse DNS caching engine can determine which IP addresses to cache for reverse DNS lookups. Based on the mapping and the response in the local cache the reverse DNS request can be satisfied while allowing the management of application traffic to remain effective in optimizing signaling in the wireless network and conserving power resources.

As shown in the distributed system interaction diagram in the example of the disclosed technology is a distributed caching model with various aspects of caching tasks split between the client side mobile device side e.g. mobile device in the example of and the server side e.g. server side including the host server and or the optional caching proxy .

In general the device side responsibilities can include deciding whether a response to a particular request can be and or should be cached. The device side of the proxy can make this decision based on information e.g. timing characteristics detected pattern detected pattern with heuristics indication of predictability or repeatability collected from during both request and response and cache it e.g. storing it in a local cache on the mobile device . The device side can also notify the server side in the distributed cache system of the local cache event and notify it monitor the content source e.g. application server content provider of .

The device side can further instruct the server side of the distributed proxy to periodically validate the cache response e.g. by way of polling or sending polling requests to the content source . The device side can further decide whether a response to a particular cache request should be returned from the local cache e.g. whether a cache hit is detected . The decision can be made by the device side e.g. the local proxy on the device using information collected from during request and or responses received from the content source.

In general the server side responsibilities can include validating cached responses for relevancy e.g. determine whether a cached response is still valid or relevant to its associated request . The server side can send the mobile device an invalidation request to notify the device side when a cached response is detected to be no longer valid or no longer relevant e.g. the server invalidates a given content source . The device side then can remove the response from the local cache.

The diagram of illustrates caching logic processes performed for each detected or intercepted request e.g. HTTP request detected at a mobile device e.g. client side of the distributed proxy . In step the client side of the proxy e.g. local proxy shown in or mobile device of receives a request from an application e.g. mobile application or mobile client . In step URL is normalized and in step the client side checks to determine if the request is cacheable. If the request is determined to be not cacheable in step the request is sent to the source application server content provider in step and the response is received and delivered to the requesting application similar to a request response sequence without interception by the client side proxy.

If the request is determined to be cacheable in step the client side looks up the cache to determine whether a cache entry exists for the current request. If so in step the client side can determine whether the entry is valid and if so the client side can check the request to see if includes a validator e.g. a modified header or an entity tag in step . For example the concept of validation is eluded to in section 13.3 of RFC 2616 which describes in possible types of headers e.g. eTAG Modified Since must revlaidate pragma no cache and forms a validating response if so to be delivered to the requesting application in step . If the request does not include a validator as determined by step a response is formed from the local cache in step and delivered to the requesting application in step . This validation step can be used for content that would otherwise normally be considered un cacheable.

If instead in step the cache entry is found but determined to be no longer valid or invalid the client side of the proxy sends the request to the content source application server content host and receives a response directly for the source in step . Similarly if in step a cache entry was not found during the look up the request is also sent in step . Once the response is received the client side checks the response to determine if it is cacheable in step . If so the response is cached in step . The client then sends another poll in step and then delivers the response to the requesting application in step .

In satisfying application or client requests on a mobile device without the distributed proxy system the mobile device or the software widget executing on the device performs a data request e.g. an HTTP GET POST or other request directly to the application server and receives a response directly from the server provider . If the data has been updated the widget on the mobile device can refreshes itself to reflect the update and waits for small period of time and initiates another data request to the server provider .

In one embodiment the requesting client or software widget on the device can utilize the distributed proxy system in handling the data request made to server provider . In general the distributed proxy system can include a local proxy which is typically considered a client side component of the system and can reside on the mobile device a caching proxy considered a server side component of the system and can reside on the host server or be wholly or partially external to the host server and a host server . The local proxy can be connected to the caching proxy and host server via any network or combination of networks.

When the distributed proxy system is used for data application requests the widget can perform the data request via the local proxy . The local proxy can intercept the requests made by device applications and can identify the connection type of the request e.g. an HTTP get request or other types of requests . The local proxy can then query the local cache for any previous information about the request e.g. to determine whether a locally stored response is available and or still valid . If a locally stored response is not available or if there is an invalid response stored the local proxy can update or store information about the request the time it was made and any additional data in the local cache. The information can be updated for use in potentially satisfying subsequent requests.

The local proxy can then send the request to the host server and the host server can perform the request and returns the results in response . The local proxy can store the result and in addition information about the result and returns the result to the requesting widget .

In one embodiment if the same request has occurred multiple times within a certain time period and it has often yielded same results the local proxy can notify the server that the request should be monitored e.g. steps and for result changes prior to returning a result to the local proxy or requesting widget .

In one embodiment if a request is marked for monitoring the local proxy can now store the results into the local cache. Now when the data request for which a locally response is available is made by the widget and intercepted at the local proxy the local proxy can return the response from the local cache without needing to establish a connection communication over the wireless network.

In addition the server proxy performs the requests marked for monitoring to determine whether the response for the given request has changed. In general the host server can perform this monitoring independently of the widget or local proxy operations. Whenever an unexpected response is received for a request the server can notify the local proxy that the response has changed e.g. the invalidate notification in step and that the locally stored response on the client should be erased or replaced with a new response.

In this case a subsequent data request by the widget from the device results in the data being returned from host server e.g. via the caching proxy and in step the request is satisfied from the caching proxy . Thus through utilizing the distributed proxy system the wireless cellular network is intelligently used when the content data for the widget or software application on the mobile device has actually changed. As such the traffic needed to check for the changes to application data is not performed over the wireless cellular network. This reduces the amount of generated network traffic and shortens the total time and the number of times the radio module is powered up on the mobile device thus reducing battery consumption and in addition frees up network bandwidth.

In one example when the mobile application widget polls an application server provider the poll can locally be intercepted on the mobile device by local proxy . The local proxy can detect that the cached content is available for the polled content in the request and can thus retrieve a response from the local cache to satisfy the intercepted poll without requiring use of wireless network bandwidth or other wireless network resources. The mobile application widget can subsequently receive a response to the poll from a cache entry .

In another example the mobile application widget polls the application server provider . The poll is intercepted by the local proxy and detects that cache content is unavailable in the local cache and decides to set up the polled source for caching . To satisfy the request the poll is forwarded to the content source . The application server provider receives the poll request from the application and provides a response to satisfy the current request . In the application e.g. mobile application widget receives the response from the application server provider to satisfy the request.

In conjunction in order to set up content caching the local proxy tracks the polling frequency of the application and can set up a polling schedule to be sent to the host server . The local proxy sends the cache set up to the host server . The host server can use the cache set up which includes for example an identification of the application server provider to be polled and optionally a polling schedule . The host server can now poll the application server provider to monitor responses to the request on behalf of the mobile device. The application server receives the poll from the host server and responds . The host server determines that the same response has been received and polls the application server according to the specified polling schedule . The application server content provider receives the poll and responds accordingly .

The host server detects changed or new responses and notifies the local proxy . The host server can additional store the changed or new response in the server cache or caching proxy . The local proxy receives notification from the host server that new or changed data is now available and can invalidate the affected cache entries . The next time the application e.g. mobile application widget generates the same request for the same server content provider the local proxy determines that no valid cache entry is available and instead retrieves a response from the server cache for example through an HTTP connection. The host server receives the request for the new response and sends the response back to the local proxy . The request is thus satisfied from the server cache or caching proxy without the need for the mobile device to utilize its radio or to consume mobile network bandwidth thus conserving network resources.

Alternatively when the application e.g. mobile application generates the same request in step the local proxy in response to determining that no valid cache entry is available forwards the poll to the application server provider in step over the mobile network. The application server provider receives the poll and sends the response back to the mobile device in step over the mobile network. The request is thus satisfied from the server provider using the mobile network in step .

In one example when the application e.g. mobile application widget polls an application server provider in step the poll can locally be intercepted in step on the mobile device by local proxy . In step the local proxy on the mobile device may also determine with some level of certainty and heuristics that a cache defeating mechanism is employed or may be employed by the server provider.

The local proxy can detect that the cached content is available for the polled content in the request and can thus retrieve a response from the local cache to satisfy the intercepted poll without requiring use of wireless network bandwidth or other wireless network resources. The application e.g. mobile application widget can subsequently receive a response to the poll from a cache entry in step e.g. a locally stored cache entry on the mobile device .

In another example the application e.g. mobile application widget polls the application server provider in step . The poll is intercepted in step by the local proxy which determines that a cache defeat mechanism is employed by the server provider . The local proxy also detects that cached content is unavailable in the local cache for this request and decides to setup the polled content source for caching in step . The local proxy can then extract a pattern e.g. a format or syntax of an identifier of the request and track the polling frequency of the application to setup a polling schedule of the host server in step .

To satisfy the request the poll request is forwarded to the content provider in step . The application server provider receives the poll request from the application and provides a response to satisfy the current request in step . In step the application e.g. mobile application widget receives the response from the application server provider to satisfy the request.

In conjunction in order to setup content caching the local proxy caches the response and stores a normalized version of the identifier or a hash value of the normalized identifier in association with the received response for future identification and retrieval in step . The local proxy sends the cache setup to the host server in step . The cache setup includes for example the identifier and or a normalized version of the identifier. In some instances a modified identifier different from the normalized identifier is sent to the host server .

The host server can use the cache setup which includes for example an identification of the application server provider to be polled and optionally a polling schedule in step . The host server can now poll the application server provider to monitor responses to the request in step on behalf of the mobile device. The application server receives the poll from the host server responds in step . The host server determines that the same response has been received and polls the application server for example according to the specified polling schedule and using the normalized or modified identifier in step . The application server content provider receives the poll and responds accordingly in step .

This time the host server detects changed or new responses and notifies the local proxy in step . The host server can additionally store the changed or new response in the server cache or caching proxy in step . The local proxy receives notification from the host server that new or changed data is now available and can invalidate the affected cache entries in step . The next time the application e.g. mobile application widget generates the same request for the same server content provider in step the local proxy determines that no valid cache entry is available and instead retrieves a response from the server cache in step for example through an HTTP connection. The host server receives the request for the new response and sends the response back to the local proxy in step . The request is thus satisfied from the server cache or caching proxy in step without the need for the mobile device to utilize its radio or to consume mobile network bandwidth thus conserving network resources.

Alternatively when the application e.g. mobile application generates the same request the local proxy in response to determining that no valid cache entry is available in step forwards the poll to the application server provider in step over the mobile network. The application server provider receives the poll and sends the response back to the mobile device in step over the mobile network. The request is thus satisfied from the server provider using the mobile network in step .

The DNS harmonization proxy on the client side proxy e.g. local proxy intercepts resolver requests e.g. DNS protocol messages that are intended to go over the wireless network to query a corresponding DNS server to resolve a DNS query. In one embodiment the harmonization proxy on the local proxy functions similarly to a repeater namely forwarding the request including the DNS query over the network and subsequently also observing and recording the traffic. For example at time 0 m0 s once the DNS harmonization proxy of the local proxy has observed a request and response pair it records them in the harmonization cache with a specified time to live TTL lifetime e.g. 20 25 30 40 45 60 minutes etc. . If the DNS Harmonization Proxy subsequently receives a similar request for example at time t 7 m0 s it can provide the last successful response to satisfy the request instead of accessing the wireless network to forward the request over the air for resolution of a query which has previously been successfully resolved.

On the mobile device the DNS harmonization proxy intercepts an outgoing DNS query for a hostname and check for matching responses in a Harmonization cache. Harmonization cache hits can be returned to a resolver e.g. intercepted protocol messages can be replayed to the resolver . Cache misses may result in the outgoing DNS query being forwarded to the corresponding Domain Name Server for resolution and the response can be stored into the DNS harmonization proxy s cache for future use.

When an application or client on the mobile device contacts the resolved IP address a related local content caching system can engage a network Harmonization server to monitor that content e.g. at t 14 m5 s and instruct the DNS harmonization proxy to retain the resolved IP address. For example the harmonization server can poll the host to determine whether a response has changed.

The DNS harmonization proxy can now respond to queries for that cached address with confidence that the network harmonization server will advise or notify when the record becomes invalid e.g. via a harmonization cache invalidation message . In one embodiment resolution requests for that host name may now be serviced by the client side DNS harmonization proxy resulting in reduced network and power usage. The polling continues e.g. at t 21 m5 s through 70 m5 s until the server detects new content in the polled response to the DNS query and notifies the harmonization proxy at the local client . The harmonization proxy at the local client receives the notification of invalid cache from the server and removes the invalid cache entry from the harmonization cache e.g. at t 70 m10 s .

The next time e.g. at t 77 min 10 s the harmonization proxy detects the same DNS query the request is sent over the network e.g. cellular broadband wifi or other wireless networks to the DNS server to resolve the query. The harmonization proxy again intercepts the response and is cached for subsequent use until notified of invalidation of the stored response.

In process an outgoing DNS query is detected at a mobile device. The outgoing DNS query may be initiated or caused to be generated by any background or user action performed on or via a mobile application or client on a device e.g. a mobile or wireless device .

In process cached DNS entries in a local cache on the mobile device are queried for a host name associated with the outgoing DNS query. In some instances prior to querying the local cache for cached DNS entries the resolver cache is queried for previously resolved cache entries. The resolver cache is typically maintained by the system s DNS resolver e.g. by the operating system or the mobile platform such as the DNS resolver . The resolver cache which is queried e.g. the DNS resolver cache can maintain DNS query responses for a short amount of time e.g. a short time to live that is typically shorter than the amount of time that the local cache e.g. the harmonization cache shown in the example of maintains cached DNS query responses. In general the resolved cache entries that are stored in the resolver cache cache have a lifetime determined from domain name records associated with domain names and is shorter than lifetime of cached DNS entries in the local cache e.g. the harmonization cache .

Thus in some instances the resolver cache can be first queried to determine if any cached entries can resolve a given DNS query and if not since the local cache maintains cache entries for a longer period of the the local cache can be queried in process to determine whether there is a matching cached DNS entry for the outgoing DNS query e.g. the DNS protocol message of .

If so in process the wireless network is not accessed and the matching cached DNS entry is provided as a response to the outgoing DNS query in process . If no matching entries exist it is detected that the local cache is absent of a matching cached DNS entry for the outgoing query in process . In process the wireless network is thus accessed. In process the outgoing DNS query is forwarded to a name server for resolution over the wireless network.

In process a response provided for the outgoing DNS query by the name server is stored as a cached DNS entry in the local cache or the harmonization cache managed by the DNS harmonization component . In one embodiment the local cache is managed by a local proxy which may be or may include the DNS harmonization component on the mobile device where the local proxy is able to communicate wirelessly with a remote entity e.g. a remote proxy to facilitate traffic control and network resource management in a wireless network.

When caching DNS responses the DNS harmonization component can simultaneously or in conjunction around the same time set up a monitoring request with a remote entity e.g. the remote server or remote proxy requesting monitoring of the source host for changes to a cached response for a given query. In general the host which is able to resolve the DNS query is a remote host server for the mobile application or the mobile client which generated the DNS query. The remote entity can perform the monitoring of the DNS query responses on the mobile device or mobile clients by polling the relevant server hosts or name servers periodically using the DNS query as further described in the flow chart of .

In process subsequent DNS queries that are the same as or similar to the outgoing DNS query are locally responded to using the stored response. The matched pair can be stored for a specific lifetime which can in some instances be in part or in whole platform dependent. The lifetime can also depend on the application parameters of the application generating the DNS query device resources storage computing resource user settings preferences account limitations operator specifications network conditions and or user account type etc.

In process a polling task is sent to a proxy. The proxy is usually remote from the mobile device from which DNS queries are initiated e.g. the harmonization server of in general the proxy or proxy server is wirelessly coupled to the mobile device and are able to communicate with one another over the wireless network via radio access at the mobile device. The polling task typically includes instructions from the local proxy or the DNS harmonization component on the mobile device for the proxy to monitor a given application server host or name server.

The application server host or name server that is monitored can be specified in the polling task by the local proxy or harmonization component on the mobile device and typically corresponds to the server whose response to a DNS query at the mobile device is being cached. The polling task typically also includes the specific DNS query whose response is being locally cached by the harmonization component on the mobile device. In general the proxy or proxy server can perform multiple polling tasks for one mobile device and or perform polling tasks for multiple mobile devices. In process the proxy polls a name server to monitor for changes in responses for the outgoing DNS query.

In process the proxy detects changes for responses to the outgoing DNS query whose response has been cached at the mobile device. In response to detecting the change in process the proxy can notify the mobile device of the detected change or in process the proxy can notify the mobile device to invalidate the matching cached DNS for the outgoing DNS query. In response to the notification of the detected change or an invalidate indication from the proxy the matching cached DNS entry is invalidated in the local cache in process . In process the changed response for the outgoing DNS query is stored as a new DNS entry in the local cache for use in locally responding to subsequent DNS queries. In process the new DNS entry for responding to the outgoing DNS query in locally responding to subsequent DNS queries

In process a mobile application or mobile client on the mobile device sends a DNS query. In process a local resolver cache of an operating system of the mobile device is queried for a matching response for the DNS query. In process no matching entry is detected in the local resolver cache. In process the DNS query is sent over a wireless network to a server. In process the server communicates with a host able to resolve a DNS query. In process the mobile device receives a response to the DNS query. In process the mobile device stores the response as a cached entry for a host name associated with the DNS query.

In process the cached entry stored on the mobile device is used as the host name. In process the mobile device sends a polling task to the server for the server to monitor the host for changes in responses to the DNS query. In process the cached entry stored on the mobile device for the DNS query is invalidated if the server identifies the change in the response to the DNS query In process the mobile device stores a response provided for the DNS query by the server as an updated cached entry. In process subsequent DNS queries are responded to without accessing the wireless network such that wireless bandwidth consumption is reduced. In process wireless bandwidth consumption used for DNS queries is reduced.

In alternative embodiments the machine operates as a standalone device or may be connected e.g. networked to other machines. In a networked deployment the machine may operate in the capacity of a server or a client machine in a client server network environment or as a peer machine in a peer to peer or distributed network environment.

The machine may be a server computer a client computer a personal computer PC a user device a tablet PC a laptop computer a set top box STB a personal digital assistant PDA a cellular telephone an iPhone an iPad a Blackberry a processor a telephone a web appliance a network router switch or bridge a console a hand held console a hand held gaming device a music player any portable mobile hand held device or any machine capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine.

While the machine readable medium or machine readable storage medium is shown in an exemplary embodiment to be a single medium the term machine readable medium and machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium and machine readable storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the presently disclosed technique and innovation.

In general the routines executed to implement the embodiments of the disclosure may be implemented as part of an operating system or a specific application component program object module or sequence of instructions referred to as computer programs. The computer programs typically comprise one or more instructions set at various times in various memory and storage devices in a computer that when read and executed by one or more processing units or processors in a computer cause the computer to perform operations to execute elements involving the various aspects of the disclosure.

Moreover while embodiments have been described in the context of fully functioning computers and computer systems those skilled in the art will appreciate that the various embodiments are capable of being distributed as a program product in a variety of forms and that the disclosure applies equally regardless of the particular type of machine or computer readable media used to actually effect the distribution.

Further examples of machine readable storage media machine readable media or computer readable storage media include but are not limited to recordable type media such as volatile and non volatile memory devices floppy and other removable disks hard disk drives optical disks e.g. Compact Disk Read Only Memory CD ROMS Digital Versatile Disks DVDs etc. among others and transmission type media such as digital and analog communication links.

Unless the context clearly requires otherwise throughout the description and the claims the words comprise comprising and the like are to be construed in an inclusive sense as opposed to an exclusive or exhaustive sense that is to say in the sense of including but not limited to. As used herein the terms connected coupled or any variant thereof means any connection or coupling either direct or indirect between two or more elements the coupling of connection between the elements can be physical logical or a combination thereof. Additionally the words herein above below and words of similar import when used in this application shall refer to this application as a whole and not to any particular portions of this application. Where the context permits words in the above Detailed Description using the singular or plural number may also include the plural or singular number respectively. The word or in reference to a list of two or more items covers all of the following interpretations of the word any of the items in the list all of the items in the list and any combination of the items in the list.

The above detailed description of embodiments of the disclosure is not intended to be exhaustive or to limit the teachings to the precise form disclosed above. While specific embodiments of and examples for the disclosure are described above for illustrative purposes various equivalent modifications are possible within the scope of the disclosure as those skilled in the relevant art will recognize. For example while processes or blocks are presented in a given order alternative embodiments may perform routines having steps or employ systems having blocks in a different order and some processes or blocks may be deleted moved added subdivided combined and or modified to provide alternative or sub combinations. Each of these processes or blocks may be implemented in a variety of different ways. Also while processes or blocks are at times shown as being performed in series these processes or blocks may instead be performed in parallel or may be performed at different times. Further any specific numbers noted herein are only examples alternative implementations may employ differing values or ranges.

The teachings of the disclosure provided herein can be applied to other systems not necessarily the system described above. The elements and acts of the various embodiments described above can be combined to provide further embodiments.

Any patents and applications and other references noted above including any that may be listed in accompanying filing papers are incorporated herein by reference. Aspects of the disclosure can be modified if necessary to employ the systems functions and concepts of the various references described above to provide yet further embodiments of the disclosure.

These and other changes can be made to the disclosure in light of the above Detailed Description. While the above description describes certain embodiments of the disclosure and describes the best mode contemplated no matter how detailed the above appears in text the teachings can be practiced in many ways. Details of the system may vary considerably in its implementation details while still being encompassed by the subject matter disclosed herein. As noted above particular terminology used when describing certain features or aspects of the disclosure should not be taken to imply that the terminology is being redefined herein to be restricted to any specific characteristics features or aspects of the disclosure with which that terminology is associated. In general the terms used in the following claims should not be construed to limit the disclosure to the specific embodiments disclosed in the specification unless the above Detailed Description section explicitly defines such terms. Accordingly the actual scope of the disclosure encompasses not only the disclosed embodiments but also all equivalent ways of practicing or implementing the disclosure under the claims.

While certain aspects of the disclosure are presented below in certain claim forms the inventors contemplate the various aspects of the disclosure in any number of claim forms. For example while only one aspect of the disclosure is recited as a means plus function claim under 35 U.S.C. 112 6 other aspects may likewise be embodied as a means plus function claim or in other forms such as being embodied in a computer readable medium. Any claims intended to be treated under 35 U.S.C. 112 6 will begin with the words means for. Accordingly the applicant reserves the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the disclosure.

