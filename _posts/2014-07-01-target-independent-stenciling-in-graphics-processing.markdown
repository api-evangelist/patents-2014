---

title: Target independent stenciling in graphics processing
abstract: In an example rendering graphics data includes determining a stencil parameter that indicates a sampling rate for determining a coverage value for each antialiased pixel of a path of an image, determining, separately from the stencil parameter, a render target parameter that indicates a memory allocation for each antialiased pixel of the path, and rendering the path using the stencil parameter and the render target parameter.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09299181&OS=09299181&RS=09299181
owner: QUALCOMM Incorporated
number: 09299181
owner_city: San Diego
owner_country: US
publication_date: 20140701
---
This application claims the benefit of U.S. Provisional Application No. 61 871 260 filed Aug. 28 2013 the entire contents of which is hereby incorporated by reference.

This disclosure relates to graphics processing and more particularly to techniques for path rendering.

Path rendering may refer to the rendering of two dimensional 2D vector graphics paths alternatively referred to herein as paths each of which may include one or more path segments. When a path includes two or more path segments the individual path segments may be of the same type or of different types. The types of path segments may include for example a line an elliptic arc a quadratic B zier curve and a cubic B zier curve. In some examples the path segment types may be defined in accordance with a standard vector graphics application programming interface API such as e.g. the Open Vector Graphics OpenVG API.

Path rendering may be implemented in a central processing unit CPU . However such an approach may be CPU intensive and may therefore limit the amount of CPU processing cycles available for other CPU tasks. Moreover in some cases a relatively large amount of data may need to be transferred to a graphics processing unit GPU to render the path segment at a desired level of detail. The relatively large amount of data may consume a significant amount of memory storage space when storing the data and may consume a significant amount of memory bandwidth when transferring the data to the GPU.

This disclosure includes techniques for generating graphics data with path filling and dashing. For example when filling a path according to aspects of this disclosure a GPU may perform stenciling operations at a different rate than the rate at which memory is allocated for rendered data referred to as a render target . That is a stencil parameter for performing stencil operations may be specified independently from a render target parameter for storing rendered data.

In addition with respect to dashing according to aspects of this disclosure a GPU may determine dash characteristics and perform dashing in a single rendering pass. For example the GPU may calculate the length of each of the segments as the segments are determined and apply the length information to determine a starting location e.g. a texture coordinate for each dash segment.

In an example a method of rendering graphics data includes determining a stencil parameter that indicates a sampling rate for determining a coverage value for each antialiased pixel of a path of an image determining separately from the stencil parameter a render target parameter that indicates a memory allocation for each antialiased pixel of the path and rendering the path using the stencil parameter and the render target parameter.

In another example an apparatus for rending graphics includes a graphics processing unit GPU configured to determine a stencil parameter that indicates a sampling rate for determining a coverage value for each antialiased pixel of a path of an image determine separately from the stencil parameter a render target parameter that indicates a memory allocation for each antialiased pixel of the path and render the path using the stencil parameter and the render target parameter.

In another example an apparatus for rendering graphics data includes means for determining a stencil parameter that indicates a sampling rate for determining a coverage value for each antialiased pixel of a path of an image means for determining separately from the stencil parameter a render target parameter that indicates a memory allocation for each antialiased pixel of the path and means for rendering the path using the stencil parameter and the render target parameter.

In another example a non transitory computer readable medium has instructions stored thereon that when executed cause a graphics processing unit GPU to determine a stencil parameter that indicates a sampling rate for determining a coverage value for each antialiased pixel of a path of an image determine separately from the stencil parameter a render target parameter that indicates a memory allocation for each antialiased pixel of the path and render the path using the stencil parameter and the render target parameter.

In another example a method of rendering graphics data includes determining with a graphics processing unit GPU a texture offset for a current segment of a plurality of ordered segments of a dashed line wherein the texture offset for the current segment of the plurality of ordered segments is based on an accumulation of lengths of segments that precede the current segment in the order and pixel shading the current segment including applying the texture offset to determine a location of the current segment.

In another example an apparatus for rendering graphics data includes a graphics processing unit GPU configured to determine a texture offset for a current segment of a plurality of ordered segments of a dashed line wherein the texture offset for the current segment of the plurality of ordered segments is based on an accumulation of lengths of segments that precede the current segment in the order and pixel shade the current segment including applying the texture offset to determine a location of the current segment.

In another example an apparatus for rendering graphics data includes means for determining with a graphics processing unit GPU a texture offset for a current segment of a plurality of ordered segments of a dashed line wherein the texture offset for the current segment of the plurality of ordered segments is based on an accumulation of lengths of segments that precede the current segment in the order and means for pixel shading the current segment including applying the texture offset to determine a location of the current segment.

In another example a non transitory computer readable medium has instructions stored thereon that when executed cause a graphics processing unit GPU configured to determine a texture offset for a current segment of a plurality of ordered segments of a dashed line wherein the texture offset for the current segment of the plurality of ordered segments is based on an accumulation of lengths of segments that precede the current segment in the order and pixel shade the current segment including applying the texture offset to determine a location of the current segment.

The details of one or more examples of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

This disclosure is directed to techniques for performing GPU based path rendering. Path rendering may refer to the rendering of two dimensional 2D vector graphics paths alternatively referred to herein as paths each of which may include one or more path segments. When a path includes two or more path segments the individual path segments may be of the same type or of different types. The types of path segments may include for example a line an elliptic arc a quadratic B zier curve and a cubic B zier curve. In some examples the path segment types may be defined in accordance with a standard vector graphics application programming interface API such as e.g. the Open Vector Graphics OpenVG API.

GPUs typically implement a three dimensional 3D graphics pipeline that is designed to be compliant with one or more 3D graphics APIs. Because the prevailing 3D graphics APIs in use today do not require that compliant devices support path rendering commands modern GPUs often provide little to no hardware acceleration for path rendering commands. For example a typical 3D graphics pipeline implemented in a modern GPU may include a rasterizer that is designed to rasterize low order non curved 3D graphics primitives such as e.g. points lines and triangles but is not capable of directly rendering curved path rendering primitives such as e.g. elliptic arcs and B zier curves .

One approach for path rendering may involve using a 3D GPU pipeline to provide partial GPU hardware acceleration for the execution of path rendering commands. This approach involves preprocessing a path segment with a central processing unit CPU in order to convert the path segment into one or more low order non curved 3D graphics primitives that can be rasterized by the GPU. For example a CPU may tessellate a curved path segment e.g. an elliptic arc or a B zier curve into a set of relatively small triangles that approximates the curvature of the path segment and may cause the set of triangles to be rendered using the GPU. Such an approach however may be CPU intensive and may therefore limit the amount of CPU processing cycles available for other CPU tasks. Moreover in some cases a relatively large amount of triangles may be needed to render the path segment at a desired level of detail. The relatively large amount of triangles may consume a significant amount of memory storage space when storing the data and may consume a significant amount of memory bandwidth when transferring the data to the GPU.

Another approach for providing partial to total GPU hardware acceleration for the execution of path rendering commands may involve modifying the architecture of the GPU to support a dedicated hardware accelerated path rendering pipeline. However because the prevailing 3D graphics APIs e.g. the Microsoft DirectX 11 DX API typically do not require a GPU architecture to include a dedicated path rendering pipeline such an approach does not result in a cross platform hardware accelerated path rendering solution that would be guaranteed to be supported by all GPUs which are compliant with a particular 3D graphics API e.g. the DX 11 API .

In some examples a GPU based path rendering technique may be used in which the GPU is configured to tessellate a received path segment into a plurality of line segments and to render the tessellated line segments using a 3D graphics pipeline. By using the GPU to tessellate a path segment into line segments the burden of preprocessing path segments is lifted from the CPU thereby freeing up processing resources for other CPU tasks. Moreover the GPU may in some examples utilize a highly parallel modern GPU tessellation architecture to perform the tessellation operations which may in some examples allow the GPU to render a path segment in a more efficient manner than the CPU. In addition because the tessellation occurs in the GPU rather than in the CPU a multitude of tessellated primitives do not need to be stored in system memory and do not need to be passed from the CPU to the GPU thereby reducing the memory footprint needed for path rendering as well as the memory bandwidth needed for path rendering.

In some examples a GPU may use a multi sample anti aliasing MSAA technique to perform antialiasing. For example pixels are uniformly colored and always of the same shape which may result in lines of a rendered image becoming jagged in appearance. With MSAA multiple samples may be generated for a single pixel. The samples may then be combined e.g. averaged to determine a final pixel value.

Accordingly in some instances a GPU may render an image at a higher resolution than the resolution being displayed. The GPU may then down sample the image to the appropriate size prior to display. The result may be smoother transitions from one line of pixels to another along the edges of objects. MSAA may be performed using a factor of 4 8 16 or other values. When performing MSAA the GPU may sample depth and stencil operations at the MSAA rate allocate memory at the MSAA rate and rasterize pixels at the MSAA rate e.g. 16 MSAA includes 16 depth stencil samples per pixel and 16 memory allocation per pixel and 16 rasterization samples per pixel .

In general a target may refer to memory allocated for a rendered pixel. Typically with respect to antialiased images a sampling rate for performing graphics operations such as rasterization and a memory allocation for the rendered target correspond with each other e.g. 1 1. Thus in an example for purposes of illustration a GPU may use a sampling rate of 16 per pixel for rasterization and allocate memory to store 16 samples per pixel. However in target independent rasterization TIR the sampling rate of the rasterization process may be specified independently from the memory allocated for the rendered image. For example a sampling rate of four samples per pixel may be used for rasterization while a memory allocation for storing color of pixels of the image may be one color per pixel in the image.

While TIR allows a rasterization rate to be independently specified from the memory allocated for the target other rendering operations may remain tied together. For example depth and stenciling operations as described in greater detail below may typically be associated with the render target. Accordingly a single render target is specified per pixel depth and stencil operations may also be performed at the same rate i.e. 1 sampling rate .

According to aspects of this disclosure a GPU may leverage the concept of TIR in stenciling operations. For example the GPU may perform stenciling at a higher rate than the amount of memory that is allocated for a particular pixel. That is in a process in which stencil operations are super sampled e.g. each pixel will have 16 samples the GPU may render by computing the coverage value per pixel based on which sample of the pixel of the super sampled pixel passed the stencil test e.g. was inside a particular path. For performance improvement a render target may be 1 sampled while the stencil may be 16 sampled. The GPU may assign each pixel a coverage value based on a per sample stencil test. Specifying a stenciling sampling rate independently from the target and the rasterization rate may be referred to herein as stenciled TIR.

The stenciled TIR process may be applied during path rendering. For example when path rendering a GPU may typically perform the following example functions to fill a path tessellate the path into line segments connect line segments to a pivot point to form triangles and render triangles to a stencil buffer including in some instances performing a depth test where the stencil buffer indicates visible pixels in of the image. The next and possibly final steps of the filling process are to render a bounding box with a stencil test enabled and to copy the contents of the stencil buffer to a frame buffer. This approach requires two rendering passes e.g. one pass to render the bounding box and one pass to render the texture.

According to aspects of this disclosure a GPU may fill a path in a single rendering pass without the need to pre process a bounding box. For example in some examples a GPU may incorporate a bounding box unit which may include hardware that is used at a rasterizer stage. For example as primitives are rendered to a stencil buffer the bounding box unit may track the outermost coordinate points of a given path e.g. top bottom left and right extrema . The outermost coordinate points may also be referred to as maximum boundary points in the sense that these points indicate the outermost boundary of the path. After stenciling is complete the bounding box unit has determined a bounding rectangle based on the outermost coordinate points.

In the example above the GPU does not shade the primitives of the path as they are rendered to the stencil buffer the primitives only affect the stencil . The GPU may then render the bounding box using the stencil buffer to assign the color. According to aspects of this disclosure another draw call is not needed after performing the stenciling and determining the bounding box. Rather the GPU rasterizes the bounding box using stenciled TIR in a single pass.

In this way the GPU may fill e.g. perform stencil and color operations in a single pass rather than for example determining primitives at a GPU determining a bounding box at a CPU and performing color operations on the GPU. That is techniques of this disclosure include a bounding box optimization that allows the GPU to determine a bounding box e.g. during tessellation which the GPU may then push to a rasterizer so that both stencil and color can be performed in a single pass.

Other aspects of this disclosure relate to dashing such as a dashed line . For example when dashing a stroked path the GPU may render dash segments in order referred to as a segment order and may generate one segment where the previous segments left off. That is the GPU determines a starting location for each segment in the dash pattern only after shading the previous segment. Such computations may reduce parallelism of graphics processing and require more than one rendering pass to perform because the locations for each section of the dash need to be processed in order to determine the correct starting location.

According to aspects of this disclosure the GPU may determine dash characteristics and perform dashing in a single pass e.g. a single rendering pass. For example the GPU may calculate the length of each of the segments as the segments are determined e.g. during geometry shading. That is the GPU may accumulate the lengths of the segments e.g. segments preceding a current segment in a segment order to determine a starting location of a current segment. This accumulation of lengths may be referred to herein as a prefix length or prefix summed length. The GPU may also determine the total length of the line.

In an example for purposes of illustration the GPU may determine a first segment of a dashed line. The GPU may also determine a second segment of the dashed line. The GPU may determine the starting location for the second segment based on a prefix summed length of previous segments. That is the GPU may determine the starting location for the second segment based on an accumulation of the lengths of the previous segments i.e. the first segment. The GPU may also determine a third segment of the dashed line. Again the GPU may determine the starting location for the third segment based on a prefix summed length of previous segments. That is the GPU may determine the starting location for the third segment based on an accumulation of the lengths of the previous segments i.e. the first segment and the second segment. The GPU may continue in this manner until the starting locations of each of the segments of the line have been determined.

In some examples the dashed line may include visible segments and invisible segments. For example GPU may determine a color for segments that are visible e.g. the dashes of the line and discard segments that are invisible e.g. the portion of the dashed line between the colored dashes . GPU may determine whether to retain a segment which may be interchangeably referred herein as a fragment e.g. during pixel shading based on a location of the segment being shaded. With respect to the three segments described above as an example assume the first and third segments of the dashed line and the second segment is an invisible segment separating the first and third segments that is not colored. GPU may determine whether to retain e.g. shade with a color or discard the segments during pixel shading based on the locations of the segments. That is GPU may determine that the first segment is retained based on the location of the first segment determine that the second segment is discarded based on the location of the second segment and determine that the third segment is retained based on the location of the third segment.

According to aspects of this disclosure the GPU may apply the prefix summed length for each segment as a texture offset during rendering. For example after rasterizing a segment the GPU may feed the value of the prefix summed length for the segment to a pixel shader as a texture offset value. The GPU may apply the texture offset to the texture coordinates of the beginning of the line to determine the location of the segment being shaded.

As illustrated in the example of computing device includes a user interface a CPU a memory controller a memory a graphics processing unit GPU a GPU cache a display interface a display and bus . User interface CPU memory controller GPU and display interface may communicate with each other using bus . It should be noted that the specific configuration of buses and communication interfaces between the different components shown in is merely exemplary and other configurations of computing devices and or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.

CPU may comprise a general purpose or a special purpose processor that controls operation of computing device . A user may provide input to computing device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include for example an operating system a word processor application an email application a spread sheet application a media player application a video game application a graphical user interface application or another program. The user may provide input to computing device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to computing device via user interface .

The software applications that execute on CPU may include one or more graphics rendering instructions that instruct GPU to cause the rendering of graphics data to display . In some examples the software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct3D API a DirectX API a RenderMan API a WebGL API or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU to cause GPU to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include a list of graphics primitives e.g. points lines triangles quadralaterals triangle strips patches etc. In further examples the graphics data to be rendered may include one or more path rendering primitives such as e.g. line segments elliptic arcs quadratic B zier curves and cubic B zier curves.

Memory controller facilitates the transfer of data going into and out of memory . For example memory controller may receive memory read requests and memory write requests from CPU and or GPU and service such requests with respect to memory in order to provide memory services for the components in computing device . Memory controller is communicatively coupled to memory . Although memory controller is illustrated in the example computing device of as being a processing module that is separate from each of CPU GPU and memory in other examples some or all of the functionality of memory controller may be implemented on one or more of CPU GPU and memory .

Memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example memory may store user applications and graphics data associated with the applications. Memory may also store information for use by and or generated by other components of computing device . For example memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example memory may store any combination of path data path segment data surfaces texture buffers depth buffers stencil buffers vertex buffers frame buffers or the like. In addition memory may store command streams for processing by GPU . For example memory may store path rendering commands 3D graphics rendering commands and or general purpose GPU computing commands. Memory may include one or more volatile or non volatile memories or storage devices such as for example random access memory RAM static RAM SRAM dynamic RAM DRAM synchronous dynamic random access memory SDRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM . Flash memory a magnetic data media or an optical storage media.

GPU may be configured to execute commands that are issued to GPU by CPU . The commands executed by GPU may include graphics commands draw call commands GPU state programming commands memory transfer commands general purpose computing commands kernel execution commands etc.

In some examples GPU may be configured to perform graphics operations to render one or more graphics primitives to display . In such examples when one of the software applications executing on CPU requires graphics processing CPU may provide graphics data to GPU for rendering to display and issue one or more graphics commands to GPU . The graphics commands may include e.g. draw call commands GPU state programming commands memory transfer commands blitting commands etc. The graphics data may include vertex buffers texture data surface data etc. In some examples CPU may provide the commands and graphics data to GPU by writing the commands and graphics data to memory which may be accessed by GPU .

In further examples GPU may be configured to perform general purpose computing for applications executing on CPU . In such examples when one of the software applications executing on CPU decides to off load a computational task to GPU CPU may provide general purpose computing data to GPU and issue one or more general purpose computing commands to GPU . The general purpose computing commands may include e.g. kernel execution commands memory transfer commands etc. In some examples CPU may provide the commands and general purpose computing data to GPU by writing the commands and graphics data to memory which may be accessed by GPU .

GPU may in some instances be built with a highly parallel structure that provides more efficient processing of vector operations than CPU . For example GPU may include a plurality of processing elements that are configured to operate on multiple vertices control points pixels and or other data in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to render graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than rendering the images using CPU . In addition the highly parallel nature of GPU may allow GPU to process certain types of vector and matrix operations for general purposed computing applications more quickly than CPU .

GPU may in some examples be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . In further instances GPU may be located on the same microchip as CPU forming a system on a chip SoC . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

In some examples GPU may be directly coupled to GPU cache . Thus GPU may read data from and write data to GPU cache without necessarily using bus . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by eliminating the need of GPU to read and write data via bus which may experience heavy bus traffic. In some instances however GPU may not include a separate cache but instead utilize memory via bus . GPU cache may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

CPU and or GPU may store rendered image data in a frame buffer that is allocated within memory . With respect to vector graphics the rendered image data may include rendered fill areas and stroke areas for a path segment to be rendered. Display interface may retrieve the data from the frame buffer and configure display to display the image represented by the rendered image data. In some examples display interface may include a digital to analog converter DAC that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples display interface may pass the digital values directly to display for processing.

Display may include a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array a cathode ray tube CRT display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone handset or a tablet computer. Alternatively display may be a stand alone device coupled to computer device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

Bus may be implemented using any combination of bus structures and bus protocols including first second and third generation bus structures and protocols shared bus structures and protocols point to point bus structures and protocols unidirectional bus structures and protocols and bidirectional bus structures and protocols. Examples of different bus structures and protocols that may be used to implement bus include e.g. a HyperTransport bus an InfiniBand bus an Advanced Graphics Port bus a Peripheral Component Interconnect PCI bus a PCI Express bus an Advanced Microcontroller Bus Architecture AMBA Advanced High performance Bus AHB an AMBA Advanced Peripheral Bus APB and an AMBA Advanced eXentisible Interface AXI bus. Other types of bus structures and protocols may also be used.

In some instances GPU may be configured to provide partial to total GPU based execution of various path rendering commands. For example CPU may issue one or more path rendering commands to GPU and GPU may execute the path rendering commands. As one example CPU may issue to GPU one or more path filling commands that instruct GPU to perform a path filling operation and GPU may execute the path filling commands. As another example CPU may issue to GPU one or more path stroking commands that instruct GPU to perform a path stroking operation and GPU may execute the path stroking commands.

In some examples GPU may be configured to receive data indicative of a path segment of a path to be rendered tessellate the path segment into a plurality of primitives and render at least one of a fill area and a stroke area for the path segment based on the plurality of primitives. The GPU may render a fill area for the path segment when performing a fill operation and may render a stroke area for the path segment when performing a stroke operation. The plurality of primitives in some examples may be a plurality of line segments.

In some examples GPU may use a two pass rendering approach to perform a path filling operation. For example as part of a first rendering pass GPU may receive data indicative of a path segment of a path to be rendered tessellate the path segment into a plurality of line segments and generate a plurality of triangle primitives based on the plurality of line segments. GPU may generate each of the plurality of triangle primitives based on a respective one of the plurality of line segments. GPU may render each of the plurality of triangle primitives into a common stencil buffer such that the common stencil buffer stores data indicative of which pixels are inside of the fill area for the path segment. After rendering the primitives into the common stencil buffer GPU may perform a second rendering pass. During the second rendering pass GPU may render one or more primitives that encompass the pixels that are inside of the fill area for the path segment based on the data stored in the stencil buffer and a fill color in order to generate a rasterized version of the fill area for the path segment.

To generate the plurality of triangle primitives for the path filling operation GPU may in some examples generate a plurality of triangle primitives such that each of the triangle primitives has a common vertex that is the same for all of the triangle primitives generated for a path segment. In such examples GPU may generate the plurality of triangle primitives such that each of the triangle primitives has two additional vertices i.e. two vertices in addition to the common vertex that correspond to the endpoints of a respective one of the plurality of line segments. Each additional vertex may correspond to a respective one of the endpoints of a corresponding line segment.

Thus when performing path rendering GPU may perform the following example functions to fill a path tessellate the path into line segments connect line segments to a pivot point to form triangle primitives and render triangles to a stencil buffer. The next and possibly final steps of the filling process are to render a bounding box that encompasses the path as described in greater detail for example with respect to with a stencil test enabled and to copy the stencil contents to a frame buffer. In some instances the bounding box may be determined based on commands received from CPU . As noted above this approach requires two rendering passes and pre processing of path to compute the bounding box.

In addition when performing antialiasing such as MSAA GPU may sample the stencil buffer at the same rate as the render target. For example if the stencil buffer and render target are both sampled at the MSAA rate the memory bandwidth consumed when copying the stencil buffer to the frame buffer may be relatively large. If GPU performs TIR and uses a relatively smaller allocation for the render target the stencil sampling rate may also be impacted thereby reducing the accuracy of the stencil buffer.

According to aspects of this disclosure GPU may perform stenciled TIR. For example GPU may determine a stencil parameter that indicates a sampling rate for determining a coverage value for each antialiased pixel of a path of an image. GPU may also determine separately from the stencil parameter a render target parameter that indicates a memory allocation for each antialiased pixel of the path. GPU may render the path using the stencil parameter and the render target parameter.

In some examples GPU may perform stenciling at a higher rate than the amount of memory that is allocated for pixels. For example with respect to MSAA GPU may perform stencil operations that are super sampled e.g. with each pixel having 16 samples. GPU may render a given path by computing a coverage value per pixel based on the number of samples of the pixel that passed a stencil test e.g. were determined to be inside the path . According to aspects of this disclosure GPU a render target for the pixels may be 1 sampled despite the stencil being 16 sampled.

In addition according to aspects of this disclosure GPU may fill a path in a single rendering pass without the need to pre process a bounding box. For example GPU may determine a bounding box during stenciling operations. In this example as GPU renders primitives during stenciling e.g. without shading the pixels GPU may determine the outermost points e.g. outermost boundary points of the primitives of the path. In some examples GPU may determine an upper point at the relative top of the path a lower point at the relative bottom of the path a right point at the right most point of the path and a left point at the left most point of the path . GPU may determine the bounding box using the outermost points determined during stenciling. That is GPU may determine a bounding box that encompasses all of the primitives of the path. In some examples the bounding box may be composed of two triangles.

After completing the bounding box GPU may further process e.g. in the same rendering pass the bounding box by performing stenciled TIR on top of the bounding box. That is as noted above GPU may determine a coverage value for each pixel and shade the pixels that GPU determines are located within the stencil. In this example GPU need not perform a separate depth test on the pixels.

With respect to stroking GPU may in some instances dash a stroked path. That is GPU may determine a plurality of segments for a stoked path such that the rendered path appears as a dashed line. Typically GPU may determine segments of the dashed path in order. For example GPU may receive commands from CPU to render one segment before moving on to the next segment of the path. Such a process may deter parallelism e.g. rasterizing and or shading more than one segment in a particular time instance and may prevent GPU from independently rendering the path.

According to aspects of this disclosure GPU may determine the locations of each segment of the path as well as the length of the path and apply the length information during rendering. For example GPU may determine a texture offset for each segment of a plurality of ordered segments of a dashed line. In some instances the segment order may be determined during geometry shading as described in greater detail below. In this example the texture offset for a current segment of the plurality of ordered segments may be based on an accumulation of lengths of segments that precede the current segment in the order. GPU may also pixel shade the segments including applying the texture offset to each segment to determine locations of the segments. For example for example GPU may determine whether segments are visible or invisible based on the location of the segments. GPU may retain e.g. determine a color for visible segments and discard segments of the dash that are not visible e.g. the space between the visible dashes . In this way GPU may perform path rendering of a dashed line e.g. without receiving dashing commands from CPU .

While described with respect to path rendering the prefix sum operations described above are not limited to vector graphics. For example the techniques for determining a prefix sum may be used in any application in which GPU tracks an accumulated value. In an example for purposes of illustration GPU may perform the prefix sum operations described above when determining gradients. For example in image processing creating gradients may require accumulation of some length information to determine colors. In this example GPU may apply the prefix sum operations described above to determine the length information.

The rendering techniques described in this disclosure may be implemented in any of the components of computing device illustrated in including e.g. CPU GPU and memory . In some examples the path rendering techniques may be implemented completely or almost completely by GPU e.g. in a graphics pipeline of GPU as described with respect to . In additional examples CPU may implement techniques for configuring the state of the graphics pipeline and binding shader programs to the graphics pipeline to implement a path rendering pipeline in GPU that performs the path rendering techniques of this disclosure. In further examples CPU may be configured to place data indicative of a path to be rendered into one or more buffers e.g. one or more vertex buffers that may be accessed by GPU to render one or more paths.

CPU is configured to execute a software application a graphics API a GPU driver and an operating system . Software application may include one or more instructions that cause graphics images to be displayed and or one or more instructions that cause a non graphics task e.g. a general purposed computing task to be performed on GPU . Software application may issue instructions to graphics API . Graphics API may be a runtime service that translates the instructions received from software application into a format that is consumable by GPU driver . GPU driver receives the instructions from software application via graphics API and controls the operation of GPU to service the instructions. For example GPU driver may formulate one or more commands place the commands into memory and instruct GPU to execute the commands . In some examples GPU driver may place the commands into memory and communicate with GPU via operating system e.g. via one or more system calls.

GPU includes a command engine and one or more processing units . In some examples the one or more processing units may form and or implement a 3D graphics rendering pipeline e.g. a DX 11 graphics rendering pipeline i.e. a 3D graphics pipeline that is compliant with the DX 1 graphics API .

Command engine is configured to receive commands from CPU e.g. via memory and to cause GPU to execute the commands. In response to receiving a state command command engine may be configured to set one or more state registers in GPU to particular values based on the state command and or to configure one or more of the fixed function processing units based on the state command. In response to receiving a draw call command command engine may be configured to cause processing units to render one or more path segments based on data that defines the geometry of the one or more path segments to be rendered and based on data indicative of the type of path segment for each of the path segments to be rendered. In some examples the data that defines the geometry of the one or more path segments to be rendered and the data that defines the type of path segment for each of the path segments may be stored in one or more vertex data structures in memory . Command engine may also receive shader program binding commands and load particular shader programs into one or more of the programmable processing units based on the shader program binding commands.

Processing units may include one or more processing units each of which may be a programmable processing unit or a fixed function processing unit. A programmable processing unit may include for example a programmable shader unit that is configured to execute one or more shader programs that are downloaded onto GPU from CPU . A shader program in some examples may be a compiled version of a program written in a high level shading language such as e.g. an OpenGL Shading Language GLSL a High Level Shading Language HLSL a C for Graphics Cg shading language etc.

In some examples a programmable shader unit may include a plurality of processing units that are configured to operate in parallel e.g. an SIMD pipeline. A programmable shader unit may have a program memory that stores shader program instructions and an execution state register e.g. a program counter register that indicates the current instruction in the program memory being executed or the next instruction to be fetched. The programmable shader units in processing units may include for example vertex shader units pixel shader units geometry shader units hull shader units domain shader units tessellation control shader units tessellation evaluation shader units compute shader units and or unified shader units. As shown in processing units also may include bounding box unit and prefix sum unit.

A fixed function processing unit may include hardware that is hard wired to perform certain functions. Although the fixed function hardware may be configurable via one or more control signals for example to perform different functions the fixed function hardware typically does not include a program memory that is capable of receiving user compiled programs. In some examples the fixed function processing units in processing units may include for example processing units that perform raster operations such as e.g. depth testing scissors testing alpha blending etc.

Memory may store path data and one or more commands . In some examples path data may be stored as a plurality of vertices or control points in one or more vertex buffers allocated in memory . In some examples the path data may be stored in a patch list data structure e.g. a four control point patch list . Commands may be stored in one or more command buffers e.g. a ring buffer . CPU e.g. GPU driver via operating system may place path data and commands into memory for consumption by GPU . GPU e.g. command engine may retrieve and execute commands stored in memory .

In examples where path data is stored as vertices e.g. control points the vertices may include one or more attributes that geometrically define a path segment to be rendered. For example for a line the vertices in the patch control list may include data indicative of coordinates for the endpoints of the line e.g. x0 y0 and x1 y1 . For a cubic B zier curve the vertices in the patch control list may include data indicative of the coordinates of the four control points that define the curve e.g. x0 y0 x1 y1 x2 y2 x3 y3 . For a quadratic B zier curve the vertices in the patch control list may include data indicative of coordinates for three control points instead of four control points. For elliptic arcs the vertices in the patch control list may include data indicative of an endpoint parameterization of the elliptic arc or data indicative of a center parameterization of the elliptic arc.

In some cases the one or more attributes that geometrically define the path segment to be rendered may be resolution independent. In other words the attributes that geometrically define the path segment may be independent of the amount of tessellation to be performed when rendering the path segment and or independent of the amount of vertices to be generated when rendering the path segment.

CPU may also place data indicative of the type of path segment to be rendered i.e. a path segment type indicator into one or more otherwise unused vertex attributes in the vertex buffer. In some examples the different path segment types may correspond to a set of path segment types that are defined by a vector graphics API and are available for use by software application . In some examples the different path segment types may correspond to a set of path segment types that are defined by the OpenVG API.

Commands may include one or more state commands and or one or more draw call commands. A state command may instruct GPU to change one or more of the state variables in GPU such as e.g. the draw color the fill color the stroke color etc. In some examples the state commands may include path rendering state commands that are configured to set one or more state variables associated with rendering a path. For example the state commands may include a paint mode command that is configured to indicate whether a path to be rendered is to be filled stroked or both. As another example the state commands may include a fill color command that specifies a color to be used for filling operations and or a stroke color command that specifies a color to be used for stroking operations. As a further example the state commands may specify one or more parameters for the stroke operation such as e.g. a stroke width an end cap style e.g. round square a line join style e.g. miter round bevel a miter limit etc. In some examples in addition to or in lieu of using a state command to set one or more state parameters one or more of the state parameters may be set by using a draw call command or by placing state indicators into a vertex buffer that contains path data .

A draw call command may instruct GPU to render the geometry defined by a group of one or more vertices e.g. defined in a vertex buffer stored in memory . In some examples the draw call command may invoke GPU to render all of the vertices stored in a defined section e.g. a vertex buffer or path data of memory . In other words once GPU receives the draw call command control is passed to GPU for rendering the geometry and primitives represented by the vertices in the defined section e.g. vertex buffer or path data of memory .

The draw call commands may include one or both of 3D draw call commands and path rendering draw call commands. For 3D rendering draw call commands the geometry defined by the group of one or more vertices in the vertex buffer may correspond to one or more 3D graphics primitives to be rendered e.g. points lines triangles quadralaterals triangle strips patches etc. and the 3D rendering draw call command may instruct GPU to render the one or more 3D graphics primitives. For path rendering draw call commands the geometry defined by the group of one or more vertices in the vertex buffer may correspond to one or more path primitives to be rendered e.g. line segments elliptic arcs quadratic B zier curves and cubic B zier curves etc. and the path rendering draw call command may instruct GPU to render the one or more path primitives. In some examples the path primitives capable of being rendered by GPU may correspond to the different types of path segments described in this disclosure.

In some examples the path rendering techniques described in this disclosure may be implemented in any of the components shown in including e.g. graphics API GPU driver command engine and processing units . In further examples all or almost all of the path rendering techniques may be implemented in a graphics pipeline in GPU formed by processing units . In additional examples software application graphics API and or GPU driver of CPU may implement techniques for configuring the state of the graphics pipeline and binding shader programs to the graphics pipeline to implement a path rendering pipeline in GPU that performs the path rendering techniques described in this disclosure. In further examples software application graphics API and or GPU driver of CPU may be configured to place data indicative of a path to be rendered into one or more buffers e.g. one or more vertex buffers that may be accessed by GPU to render one or more paths.

According to aspects of this disclosure processing units include a bounding box unit . Bounding box unit may include one or more programmable and or fixed function units for determining a bounding box. For example techniques of this disclosure include determining a bounding box and rendering the bounding box in a single rendering pass as described in greater detail for example with respect to below . When GPU performs a path filing operation bounding box unit may be responsible for determining the boundaries of the path.

According to aspects of this disclosure the bounding box unit may be initiated using an API call. For example graphics API may include one or more instructions for triggering the use of bounding box unit during rendering of a path. The API call may allow GPU to skip shading of primitives until bounding box unit has determined the bounding box. GPU may then perform stenciled TIR on top of the bounding box as noted above. In addition by incorporating bounding box unit GPU may fill a path in a single pass without using a depth buffer.

Bounding box unit may allow GPU to fill paths without pre processing a bounding box. For example bounding box unit may determine the bounding box using control polygons e.g. at CPU . That is bounding box unit may determine the bounding box based on the boundaries of all of the generated primitives.

According to aspects of this disclosure GPU may be configured to skip shading of primitives until bounding box unit has determined the bounding box. That is during generation of the bounding box. GPU may write primitives of the path to a stencil buffer of GPU without shading the primitives. By incorporating bounding box unit . GPU may fill a path in a single pass without using a depth buffer. For example GPU may perform stenciled TIR on top of the bounding box.

In an example for purposes of illustration after GPU has rasterized the bounding box determined by bounding box unit GPU may determine a coverage value for each pixel in the bounding box. In some examples GPU may determine the coverage values for quads of pixels 4 pixels at a time . In such examples before forming a pixel wave for processing GPU may perform a stencil test on samples of each pixel of the quad. GPU may update a coverage mask for each pixel based on the result of the test. This coverage value may be referred to as a stenciled TIR attribute that GPU may then use during shading. For example an InputCoverage value for each pixel may be based on the stenciled TIR. For example GPU may pixel shade e.g. color each pixel passing the stencil test e.g. where a pixel passes the stencil test when more samples of the pixel are visible shaded than not . That is GPU may pass both a coverage mask for centroid and sample mask after stencil test for InputCoverage from a distributed processor DProc to a sampler.

According to some aspects of this disclosure an API call may be used to support a stenciled TIR mode of rendering. For example graphics API may include one or more instructions for triggering the use of stenciled TIR during rendering of a path. When stenciled TIR is active a color buffer and a depth stencil buffer which may be allocated in a memory of GPU and or memory may be different. For example when performing MSAA GPU may render to a color buffer that is 1 MSAA and a stencil buffer that is 16 MSAA.

According to other aspects of this disclosure processing units also include a prefix sum unit for rendering dashed segments e.g. stroking a dashed path. Prefix sum unit may determine a texture offset for each segment of a plurality of ordered segments of a dashed line. In some examples a tessellation or geometry shader stage may determine the segment order when generating the segments. The texture offset for a current segment of the plurality of ordered segments may be based on an accumulation of lengths of segments that precede the current segment in the order. Prefix sum unit may provide the texture offset to a shader stage such as a pixel shader stage. The shader stage may apply the texture offset and render the segment in the appropriate location.

Accordingly prefix sum unit may include one or more programmable or fixed function units that accumulates the lengths of segments of a dashed line. In some examples prefix sum unit may be incorporated at a rasterizer stage. For example GPU may tessellate paths and a geometry shader stage may determine the path length. In other examples the length may be determined by one or more other shader units. For example according to aspects of this disclosure prefix sum unit may calculate a linelength value in a similar manner to a system interpreted value for the attribute pointsize indicating a size of a point primitive . That is linelength may be a system interpreted value indicating a location of a segment also referred to as a fragment in a dashed pattern.

When a pixel shader e.g. as described with respect to below of GPU receives the prefix summed linelength value the pixel shader may determine a location of a fragment being shaded in a dash pattern. The pixel shader may then either retain the fragment if it forms part of the visible dash or discard the fragment if it is not part of the visible dash based on the determined location. In any case prefix sum unit may accumulate the length information as a prefix sum and provide the prefix sum as a texture offset to a downstream shader stage such as a pixel shader.

During rendering GPU may send an event presum start to a tessellation engine TSE which may include a hull shader a tessellator and or a domain shader as described in greater detail with respect to below to reset a prefix sum parameter. For each primitive prefix sum unit may add a scalar value e.g. same field as pointsize of the primitive to prefix sum as new value. Prefix sum unit may pass the old pre fix sum value per pixel as texture offset.

In some examples the tessellation engine may incorporate a register to accumulate prefix sum parameter. Prefix sum unit may reset the register by the event presum start. The tessellation engine passes the prefix sum as a per primitive attribute to render backend RB in the barycentric plane interface similar to primitive faceness which may be similar to sending a texture offset . In this example an attribute may be added to the RB to provide a high level sequencer HLSQ with an interface to represent this per primitive attribute.

Resources block may correspond to one or more memory resources used by graphics pipeline such as e.g. one or more textures and or one or more buffers. Resources block may store input data to be processed by one or more of the processing stages in graphics pipeline and or output data from one or more of the processing stages in graphics pipeline . As one example resources block may store a stencil buffer used for performing a path filling operation as described in this disclosure. As another example resources block may store a frame buffer that holds a rasterized version of a fill area for a path segment and or a rasterized version of a stroke area for a path segment as described in this disclosure. In some examples the memory resources that form resources block may reside in memory and or GPU cache of computing device .

The processing stages depicted in with straight corners represent fixed function processing stages and the processing stages depicted in with rounded corners represent programmable processing stages. For example as shown in input assembler tessellator rasterizer and output merger are fixed function processing stages and vertex shader hull shader domain shader geometry shader and pixel shader are programmable processing stages. Each of the programmable stages may be configured to execute a shader program of a particular type. For example vertex shader may be configured to execute a vertex shader program hull shader may be configured to execute a hull shader program etc. Each of the different types of shader programs may execute either on a common shader unit of GPU or on one or more dedicated shader units that are dedicated to executing shader programs of one or more particular types.

As shown in input assembler vertex shader hull shader domain shader geometry shader pixel shader and output merger are communicatively coupled to resources block . Input assembler vertex shader hull shader domain shader geometry shader pixel shader and output merger are configured to retrieve and or to receive input data from resources block . Geometry shader and output merger are configured to write output data to resources block . The above described configuration of communication between the processing stages in graphics pipeline and resources block is merely one example of how the communication may be configured between the processing stages of graphics pipeline and resources block . In other examples more or less unidirectional and or bi directional communication channels may be provided between the processing stages of graphics pipeline and resources block .

Additional background information regarding the general operation of the DirectX 11 graphics pipeline may be found at http msdn.microsoft.com en us library windows desktop ff476882 28v vs.85 29.aspx. Further information regarding the general operation of the DirectX 11 graphics pipeline may be found in Zink et al. Practical Rendering Computation with Direct3D 11 CRC Press 2011 .

Two main path rendering operations may include 1 filling a path segment and 2 stroking a path segment. In some instances the filling operation may utilize a two pass approach that may generally involve the following steps 

For the first pass CPU may place data indicative of a path segment to be rendered into one or more vertices of a vertex buffer. In some examples the vertex buffer may correspond to path data shown in . The primitive topology for the vertices in the vertex buffer may be in some examples a patch control list. For a line the vertices in the patch control list may include data indicative of coordinates for the endpoints of the line e.g. x0 y0 and x1 y1 . For a cubic B zier curve the vertices in the patch control list may include data indicative of the coordinates of the four control points that define the curve e.g. x0 y0 x1 y1 x2 y2 x3 y3 . For a quadratic B zier curve the vertices in the patch control list may include data indicative of coordinates for three control points that define the curve instead of four control points. For elliptic arcs the vertices in the patch control list may include data indicative of an endpoint parameterization of the elliptic arc or data indicative of a center parameterization of the elliptic arc. CPU may also place data indicative of the type of path segment to be rendered into an otherwise unused vertex attribute of the patch control list.

One example format for the path data received and used by GPU to perform path rendering will now be described. It should be understood that this is merely one example of how data indicative of a path to be rendered and or a path segment to be rendered may be provided by CPU to GPU and that other examples are possible and within the scope of this disclosure. In this example GPU receives each path segment as a four 4 control point patch list primitive. Each of the vertices e.g. control points in the patch list in this example includes three 3 float attributes that define attributes for the respective vertex e.g. control point .

The remaining vertices and attributes in this example may be unused and or may be used to indicate other attributes for the path segment. Other attributes for the path segment may include e.g. whether the path segment is the beginning or end of an open path whether the path segment should be displayed for the path whether an endcap should be placed on either end of the path segment what type of endcap should be used if any whether a join should be placed on either end of the path segment and what type of join to use if any.

Similar input may be used for a quadratic B zier path segment except that three control points may be provided instead of four control points and the path segment type indicator may be different to distinguish the primitive from a cubic B zier path segment.

For example the input path data for a quadratic B zier path segment may take the following form or a similar form 

In some examples the input path data for an elliptic arc path segment may include data indicative of a center parameterization of the elliptic arc path segment. For example the input path data for an elliptic arc path segment may take the following form or a similar form 

In further examples the input path data for an elliptic arc path segment may include data indicative of an endpoint parameterization of the elliptic arc path segment. For example the input path data for an elliptic arc path segment may take the following form or a similar form 

In examples where the input path data includes an elliptic arc represented in an endpoint parametric form CPU may in some examples convert the representation of the elliptic arc from an endpoint parametric form into a center parametric form prior to sending data indicative of the elliptic arc to GPU for rendering. For example CPU may generate a center parameterization of an elliptic arc based on an endpoint parameterization of the elliptic arc and send the center parameterization of the elliptic arc to GPU . The center parameterization for the elliptic arc may conform to the example input data form specified above. The center parameterization may be used by CPU to find the endpoint tangents and or normals for the elliptic arc which may in turn be used by CPU to generate join primitives for rendering by GPU .

In some examples stroking operations may use three additional fields of the vertex path data input to handle endcaps joins and open paths. For example certain vertex coordinates may store data indicative of whether the path segment is the beginning of an open path the end of an open path and whether the path segment may be dropped e.g. the path segment is the closing path segment of an open path . The following is an example template that includes the above described vertex attributes 

To perform a path filling operation input assembler obtains path data from memory and passes the path data onto one or more subsequent stages of graphics pipeline to render the path segments e.g. path primitives specified by path data . For example input assembler may obtain a plurality of vertices from a vertex buffer stored in memory and cause vertex shader to process the vertices. In some examples input assembler may pass the vertices to be processed directly to vertex shader . In additional examples input assembler may direct vertex shader to retrieve particular vertices for processing from a vertex buffer in resources block .

Vertex shader is configured to process vertices received from input assembler and or resources block and to generate an output vertex for each input vertex processed by vertex shader . For example for each input vertex vertex shader may execute an instance of a vertex shader program on a shader unit of GPU . In some examples vertex shader may execute a pass through vertex shader program for each input vertex. The pass through vertex shader program may cause vertex shader to for each input vertex output a vertex that corresponds to the input vertex. In this case an output vertex may correspond to an input vertex if the output vertex has the same attributes as the input vertex. To implement the pass through vertex shader program in some examples vertex shader may apply an identity transformation to each input vertex to generate an output vertex with the same attributes. The input vertices received by vertex shader and the output vertices generated by vertex shader may be alternatively referred to as input control points and output control points respectively.

In further examples vertex shader may generate one or more output attributes for an output vertex that are not identical to the input attributes of a corresponding input vertex. For example vertex shader may perform substantive processing on one or more of the attributes of the input vertices to generate one or more attributes for the output vertices. As one example vertex shader may perform one or more of a world transformation a view transformation a projection transformation or any combination thereof on the positional attributes of the input vertices to generate one or more attributes for the output vertices. As another example vertex shader may add and or delete attributes from the set of input attributes to generate a set of output attributes for an output vertex.

Tessellation stages i.e. hull shader tessellator and domain shader may form a tessellation engine and may tessellate a path segment defined by the input path data into a plurality of line segments. The plurality of line segments may approximate the curvature of the path segment to be rendered. In general hull shader may pass the control points received from vertex shader to domain shader for further processing and provide configuration data to tessellator . Tessellator may determine values at which one or more parametric equations that represent a particular type of path segment should be evaluated. Domain shader may evaluate the parametric equations at the values determined by tessellator and output a vertex for each evaluation. In some examples each of the vertices output by domain shader may include one or more attributes that are indicative of the position of the vertex. In additional examples each of the vertices output by domain shader may include one or more attributes that are indicative of the type of path rendering primitive associated with the vertex.

In some examples hull shader may process the control points received from vertex shader and or resources block and may generate an output control point for each instance of the hull shader program executed by hull shader . For example for each output control point to be generated by hull shader hull shader may execute an instance of a hull shader program on a shader unit of GPU . In some examples hull shader may execute a pass through hull shader program for each output control point. The pass through hull shader program may cause hull shader to for each output control point output a control point that corresponds to a respective one of the input control points. In this case an output control point may correspond to an input control point if the output control point has the same attributes as the input control point.

In further examples hull shader may generate one or more output attributes for an output control point that are not identical to the input attributes of a respective one of the input control points. For example hull shader may perform substantive processing on one or more of the attributes of the input control points to generate one or more attributes for the output control points. As another example hull shader may add and or delete attributes from a set of input attributes to generate the set of output attributes for an output control point. In some examples if GPU receives path data for an elliptic arc that is in the form of an endpoint parameterization hull shader may convert the endpoint parameterization of the elliptic arc into a center parameterization for the elliptic arc as described in further detail below.

In additional examples hull shader may drop primitives that are not to be rendered for a particular rendering operation. Dropping a primitive may refer to the process of causing data corresponding to the primitive to not be passed on to further stages of graphics pipeline thereby effectively causing such a primitive to not be rendered by the remainder of the pipeline. For example when graphics pipeline is performing a filling operation hull shader may drop join primitives and cap primitives. As another example when graphics pipeline is performing a stroking operation hull shader may drop close path primitives for open paths. A closed path primitive may refer to a primitive that represents a line path segment that closes a loop. A close path primitive is typically used for paths that are closed paths rather than open paths. In some examples a close path primitive may be identified by a different primitive type identifier than the primitive type identifier used for identifying other line path segments in a path. For example a close path primitive may be identified by a primitive type identifier of 2.1f instead of 2.0f.

Hull shader may also execute an instance of a patch constant function for each path segment. The patch constant function may determine and provide configuration parameters to tessellator to be used by tessellator when generating output values. For example the patch constant function may cause hull shader to provide tessellation factors to tessellator . The tessellation factors may specify a degree of tessellation that tessellator is to apply to a particular tessellation domain e.g. how finely the domain should be subdivided and or the number of smaller objects into which the domain should be subdivided . In some examples hull shader may cause tessellator to perform 4 tessellation for cubic B zier curves 4 tessellation for round joins and caps and 1 tessellation for line segments.

As another example the patch constant function may cause hull shader to provide a type of tessellation domain to be used during tessellation to tessellator . A tessellation domain may refer to an object that is used by tessellator to generate a plurality of coordinates for use by domain shader . Conceptually the tessellation domain may correspond to an object that is subdivided by tessellator into a plurality of smaller objects. The positional coordinates of the vertices of the smaller objects are then sent to domain shader for further processing. In some examples the type of tessellation domain may be selected to be one of a quad a tri and an isoline. The smaller objects into which the domain is subdivided in some examples may correspond to triangles line segments or points. In some examples hull shader may specify an isoline tessellation domain type and specify that tessellator should subdivide the isoline domain into line segments.

Tessellator may generate a plurality of output values for each path segment processed by tessellation stages . The output values may determine the values at which one or more parametric equations that represent a particular type of path segment should be evaluated by domain shader . In some examples tessellator may generate the plurality of output values based on one or more tessellation factors and or a tessellation domain type provided to tessellator by hull shader . For example tessellator may subdivide an isoline into a plurality of line segments and generate an output value for each endpoint of the plurality of line segments in a normalized coordinate system.

Domain shader may receive output values from tessellator and control points for a path segment from hull shader and generate output vertices that correspond to a plurality of tessellated line segments that approximate the curvature and or shape of a path segment. For example for each of the output values received from tessellator domain shader may execute an instance of a domain shader program on a shader unit of GPU . The domain shader program may cause domain shader to for each of the output values received from tessellator evaluate one or more parametric equations at a particular value that is determined based on the respective output value to generate positional coordinates for an output vertex that corresponds to the respective output value. One or more of the coefficients of the parametric equations used to generate the output vertex coordinates may be defined based on one or more of the control points received from hull shader . Each output vertex may correspond to an endpoint of one of the plurality of tessellated line segments. Two consecutive output vertices may correspond to the endpoints of a single tessellated line segment.

In additional examples the domain shader program may cause domain shader to generate normal coordinates for output vertices that correspond to each of the output values received from tessellator . For example the domain shader program may cause domain shader to for each of the output values received from tessellator evaluate one or more additional parametric equations at a particular value that is determined based on the respective output value in order to generate tangent coordinates for an output vertex that corresponds to the respective output value. The tangent coordinates for an output vertex may be indicative of a direction of a tangent line of the path segment that intersects the path segment at the output vertex. Domain shader may generate normal coordinates for each of the output vertices based on the tangent coordinates that correspond to the respective output vertex. The normal coordinates generated for a particular output vertex may be indicative of a normal vector that indicates a direction which is perpendicular to a tangent of the path segment that intersects the path segment at the output vertex.

In some examples when graphics pipeline is performing a filling operation domain shader may generate vertices corresponding to the locations of the endpoints of the tessellated line segments without generating any normals for such locations. In such examples when graphics pipeline is performing a stroking operation domain shader may in some examples generate vertices corresponding to the locations of the endpoints of the tessellated line segments and generate normals corresponding to such locations.

Domain shader may output the vertices in an ordered sequence where each set of adjacent vertices represents a tessellated line segment. The line segments may collectively approximate the path segment that was defined in the vertex buffer. For example domain shader may output the following set of vertices 0 1 2 3 4 5 that define the following line segments 0 1 1 2 2 3 3 4 4 5. In additional examples domain shader may output the following set of vertices 0 1 1 2 2 3 3 4 4 5 that may define the same line segments as listed in the previous example.

In some examples tessellator and domain shader may be configured to uniformly tessellate a path segment into a plurality of line segments according to the following technique. Specifically tessellator may output coordinates for parametric evaluation e.g. t 0 T 1 T 2 T . . . T T where T is the tessellation factor . Depending on the type of primitive domain shader may evaluate one or more parametric equations at the values that are output by tessellator .

Geometry shader may receive tessellated line segments from domain shader and generate a plurality of primitives based on the tessellated line segments. In this manner geometry shader may determine a segment order for line segments. For each of the tessellated line segments geometry shader may execute an instance of a geometry shader program on a shader unit of GPU and generate a triangle primitive for the tessellated line segment based on the respective tessellated line segment. In some examples for each of the tessellated line segments geometry shader may receive two vertices from domain shader that correspond to the respective tessellated line segment and generate a set of three vertices that correspond to a triangle primitive.

In some examples two of the vertices of the triangle primitive may be the same vertices e.g. have the same positional coordinates as the two received vertices. In such examples geometry shader may generate the third vertex based on a common vertex that is common for all tessellated line segments associated with a path segment to be rendered. The common vertex may or may not correspond to one of the endpoints of the tessellated line segments. In some examples the common vertex may correspond to the first vertex in a set of vertices that correspond to the tessellated line segments for a path segment to be rendered.

Geometry shader may be invoked once for each of the tessellated line segments produced by domain shader . For each of the tessellated line segments geometry shader may generate a triangle primitive using a common control point as a first vertex of the triangle and using the two endpoints of the respective tessellated line segment as the second and third vertices of the triangle. For example an example was provided above where domain shader generated the following set of vertices 0 1 2 3 4 5 that define the following line segments 0 1 1 2 2 3 3 4 4 5. For the above listed sequence of line segments geometry shader may generate the following triangles C 0 1 C 1 2 C 2 3 C 3 4 C 4 5 C 4 5 where C is any single vertex that is common to all of the triangles.

Rasterizer may be configured to convert a plurality of 3D graphics primitives e.g. points lines and triangles into a plurality of pixels that correspond to the 3D graphics primitives. For example rasterizer may receive three vertices that correspond to a triangle primitive and convert the three vertices into a plurality of pixels that correspond to the screen pixel locations that are covered by the triangle primitive. Screen pixel locations that are covered by the triangle primitive may include screen pixel locations that correspond to the vertices of the triangle the edges of the triangle and the interior of the triangle.

Pixel shader may receive pixels from rasterizer and generate shaded pixels based on the received pixels according to a pixel shader program. For example for each pixel received from rasterizer pixel shader may execute an instance of a pixel shader program on a shader unit of GPU . In some examples pixel shader may execute a pass through pixel shader program for each pixel. The pass through pixel shader program may cause pixel shader to for each pixel output a pixel that corresponds to a respective one of the input pixel. In this case an output pixel may correspond to an input pixel if the output pixel has the same attributes as the input pixel.

In further examples pixel shader may generate one or more output attributes for an output pixel that are not identical to the input attributes of a respective one of the input pixels. For example pixel shader may perform substantive processing on one or more of the attributes of an input pixel to generate one or more attributes for an output pixel. As another example pixel shader may add and or delete attributes from a set of input attributes to generate the set of output attributes for an output pixel.

Output merger may place pixel data received from pixel shader into a render target e.g. a frame buffer or a stencil buffer . In some examples output merger may merge the pixel data received from pixel shader with the pixel data already stored in a render target based on a raster operation.

To perform the path filling operation rasterizer may rasterize each of the triangles received by geometry shader into a common stencil buffer e.g. a buffer stored in resources block . During the first pass pixel shader may be disabled or set to a pass through mode to pass input pixels directly to output merger . Output merger may be configured to populate the stencil buffer such that the stencil buffer stores values which are indicative of a fill area for the path segment according to one or more stencil buffer filling techniques.

According to aspects of this disclosure as noted above GPU may perform a filling operation using a single pass approach using stenciled TIR and a bounding box that involves the following steps 

When tessellation stages receive a bounding box end event e.g. bb end the tessellation stages may generate a rectlist corresponding to the determined bounding box coordinates e.g. form the bounding box that encompasses the triangle primitives of the path. Rasterizer may then rasterize the bounding box. According to aspects of this disclosure rasterizer may perform stenciled TIR in which the stenciled pixels are super sampled relative to the render target and pixel shader only shades stenciled pixels. As pixel shader shades pixels the stencil value for the pixels may be cleared from the stencil buffer.

Accordingly in the example described above tessellation stages maintain an accumulation of bounding box parameters bb box between a bounding box start event bb start and a bounding box end event bb end . The render backend e.g. including geometry shader rasterizer pixel shader and or output merger expects the fixed operations between the bounding box start event bb start and a bounding box end event bb end . That is the render backend may perform the operations associated with determining the bounding box without a driver such as GPU driver programming the render backend registers which may be allocated in resources block . While described with respect to tessellation stages it should be understood that the techniques above may be carried out by one or more other stages of the graphics pipeline. In this way GPU may use graphics pipeline to fill a path in a single pass and without the need to render a bounding box during a separate pass.

According to other aspects of this disclosure graphics pipeline may be configured to perform dashing for a stroked path segment. In an example for purposes of illustration geometry shader may receive tessellated line segments from domain shader and generate a plurality of primitives based on the tessellated line segments. The plurality of primitives may include the dash segments to be shaded and the plurality of primitives may be in a particular order e.g. a segment order. Geometry shader or another component of graphics pipeline may also determine the length of each of the dashes.

In addition geometry shader accumulates the length of the dashes as each dash is generated and assigns each dash segment a prefix sum of the lengths of previous dash segments e.g. dash segments that precede the current segment in the segment order. For example the first dash segment may be assigned a prefix sum of zero the second dash segment may be assigned a prefix sum of the length first dash segment the third dash segment may be assigned a prefix sum of the length of a combination of the first and second dash segments and so on.

Rasterizer typically receives the dash segments and follows a primitive order during rasterization where the primitive order refers to an order for rendering. After rasterization the prefix sum for each dash segment may be sent to the pixel shader for use when shading the dash segments. For example in order to shade the dash segments in the appropriate location pixel shader may apply the prefix sum for each dash segment as a texture offset. The texture offset indicates the location of the previous dash segments thereby allowing pixel shader to shade the next dash segment in the appropriate location relative to the previous segments.

As shown in GPU tessellates path to include a number of vertices that are connected in a linestrip fashion . As shown in GPU generates a number of line segments that are connected to a pivot point to form a number of triangle primitives. In the example of the relative first vertex of path is used as pivot point . The winding order of the triangles will determine the appropriate stencil operation. For example every generated line segment is connected to pivot point . The resulting orientation of the triangle e.g. clockwise or counterclockwise may determine the winding order of the triangle primitives. The winding order may affect the stencil value in different ways e.g. incrementing the stencil value for a clockwise winding order or decrementing the stencil value for a counterclockwise winding order .

In this example GPU does not shade the triangle primitives shown in during stenciling. Rather as noted above triangle primitives that are rendered during stenciling only impact a stencil texture . That is stencil texture indicates the portions of the path that appear in the image e.g. that are rendered and shaded.

As shown in GPU determines a bounding box that encompasses the stencil texture . That is the bounding box covers the entire of the path that is to be filled. GPU then performs stenciled TIR on bounding box to generate filled path . In this way GPU determines bounding box and fills path in a single rendering pass.

According to aspects of this disclosure GPU may perform stenciled TIR. Accordingly GPU may determine a stencil parameter e.g. the stencil sampling rate independently from a render target parameter e.g. memory allocation for a rendered pixel . In this example GPU may determine a coverage value for rendering the pixel based on whether the pixel passes a per sample stencil test.

In some examples GPU may perform a stencil test to determine if samples have a non zero value. For example GPU may perform a zero non zero stencil test in which samples having non zero stencil values are rendered. In another example GPU may perform an odd even stencil test in which samples having an odd or even value are rendered. Accordingly in some examples GPU may perform a stencil test to determine if samples have an odd value. In still other examples GPU may perform a stencil test to determine if samples have an even value.

In any case in the example shown in 10 of the 16 samples again represented by boxes of pixel are located within primitive . Accordingly a coverage mask for primitive may include pixel and GPU may shade pixel during rendering.

According to some examples the sequence of determining a bounding box during stenciling and rendering the primitives included in the stencil may be performed by GPU using the following API call 

As shown in the graph of the memory bandwidth requirement for MSAA are significantly greater than the memory bandwidth requirement for stenciled TIR and conservative rasterization . Table 1 shown below illustrates a comparison of MSAA conservative rasterization and stenciled TIR .

Table 2 shown below illustrates an additional comparison between MSAA stenciled TIR and conservative rasterization .

As shown in GPU tessellates path to include a number of vertices that are connected in a linestrip . In addition GPU determines a number of normals shown as arrows extending from vertices . In the example of double normals indicates a join location. Creating joins may require endpoint tangents of the next primitive in the linestrip. also includes an example segment .

GPU may apply the lengths as a texture offset for texture coordinates from 0 to line length L. For example according to aspects of this disclosure prefix sum unit may calculate a linelength value that indicates a location of each of segments . Prefix sum unit may send a prefix summed linelength value to a pixel shader stage which determines the respective locations of segments during pixel shading. GPU retains visible segments and as shaded fragments as forming a part of the visible dash pattern and discards segment without shading as being invisible in the dash pattern.

In some examples a graphics API that supports determining per primitive scalar values such as pointsize may be used to instruct GPU to determine the scalar lengths. According to aspects of this disclosure the graphics API may support a linelength value. This linelength value may be the same flat attribute of a primitive but the attribute may be provided to a pixel shader stage. For example GPU may apply the prefix sum path per tessellated primitive to determine offset coordinates during pixel shading. In addition API calls prsum start prsum end similar to query start end may bracketize one or more draw calls to indicate the relative start and end of the dashed line.

In the example of . GPU receives path data . The path data may be indicative of one or more path segments of a path to be rendered. GPU also determines a stencil parameter . In some examples the stencil parameter may indicate a sampling rate for determining a coverage value for each antialiased pixel of the path. GPU also determines separately from the stencil parameter a render target parameter . The render target parameter may indicate a memory allocation for each antialiased pixel of the path.

GPU tessellates a path segment defined by the path data into a plurality of line segments . For example GPU may tessellate the path data into a linestrip such as the one shown in . GPU then generates a plurality of triangle primitives based on the plurality of line segments . Each of the plurality of triangle primitives may be generated based on a respective one of the plurality of line segments. Each of the plurality of triangle primitives for a given path segment may share a common vertex. The other two vertices for each of the triangle primitives may correspond to the endpoints of a respective one of the plurality of line segments.

GPU renders each of the plurality of triangle primitives into a common stencil buffer using the stencil parameter and determines a bounding box . For example as noted above GPU does not shade the triangle primitives during stenciling. However. GPU may determine the outermost points of the triangle primitives to determine the bounding box for the primitives. In some examples GPU may determine the coordinates for each triangle primitive and overwrite an upper boundary point a lower boundary point a right boundary point and or a left boundary point each time a primitive extends beyond the outermost point of the previous triangle primitive.

After rendering all of the triangle primitives into the stencil buffer the stencil buffer may store data indicative of which pixels are inside of the fill area for the path segment. In addition the bounding box encompasses each of the triangle primitives.

GPU then rasterizes the bounding box using the render target parameter and the stencil buffer . For example according to aspects of this disclosure GPU performs stenciled TIR on the bounding box to determine color values for each pixel of the path data. The data in the stencil buffer may cause pixels inside of the fill area to be shaded with a fill color and cause pixels that are outside of the fill area to remain unshaded. Once the rendering of the bounding box has completed the render target e.g. the frame buffer may store a rasterized version of the fill area for the path segment using the render target parameter.

GPU receives path data . The path data may be indicative of one or more path segments of a path to be rendered. GPU tessellates a path segment defined by the path data into a plurality of line segments . For example GPU may tessellate the path data into a linestrip such as the one shown in .

GPU generates a plurality of primitives that spatially corresponds to the stroke area for the path segment . For example for each of the plurality of tessellated line segments GPU may generate one or more primitives that spatially correspond to a stroke area for the respective line segment. GPU may determine a number of tessellated primitives per line segment during geometry shading of the line segment. That is during geometry shading GPU may generate a stroke without dashing e.g. without shading particular segments of the stroke .

When dashing GPU determines a path length per tessellated primitive . For example GPU may determine an accumulation of lengths for each dash segment primitive produced during geometry shading. That is the dash segments may be ordered in a particular order e.g. an order determined during tessellation and or geometry shading . For each primitive GPU may accumulate the lengths of the primitives preceding it in order.

GPU may determine a texture offset for texture coordinates of each primitive being rendered based on the accumulation of lengths . For example as noted above GPU may use the length information to determine a texture coordinate for the beginning of each of the primitives. GPU may apply the texture offset during pixel shading . For example GPU applies the texture offset and shades each of the segments of the dash using the appropriate color for the stroked path data.

In some examples the techniques of this disclosure may allow users of DirectX 11 hardware to perform path rendering using DirectX 11 hardware or with hardware that has similar performance characteristics. In further examples the techniques of this disclosure may provide an all GPU rendering solution to path rendering.

Although the techniques of this disclosure have been primarily described with respect to a hardware architecture that is defined by the DX 11 graphics API the techniques of this disclosure may also be performed in hardware architectures defined according to other on chip tessellation enabled graphics APIs such as e.g. the OpenGL graphics API e.g. OpenGL versions 4.0 4.1 4.2 4.3 and later versions . In examples where the techniques of this disclosure are implemented in a hardware architecture defined according to the OpenGL graphics API one or more of the functions attributed to hull shader in this disclosure may be performed by a tessellation control shader and or one or more of the functions attributed to domain shader in this disclosure may be performed by a tessellation evaluation shader.

The techniques described in this disclosure may be implemented at least in part in hardware software firmware or any combination thereof. For example various aspects of the described techniques may be implemented within one or more processors including one or more microprocessors digital signal processors DSPs application specific integrated circuits ASICs field programmable gate arrays FPGAs or any other equivalent integrated or discrete logic circuitry as well as any combinations of such components. The term processor or processing circuitry may generally refer to any of the foregoing logic circuitry alone or in combination with other logic circuitry or any other equivalent circuitry such as discrete hardware that performs processing.

Such hardware software and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition any of the described units modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather functionality associated with one or more modules or units may be performed by separate hardware firmware and or software components or integrated within common or separate hardware or software components.

The techniques described in this disclosure may also be stored embodied or encoded in a computer readable medium such as a computer readable storage medium that stores instructions. Instructions embedded or encoded in a computer readable medium may cause one or more processors to perform the techniques described herein e.g. when the instructions are executed by the one or more processors. Computer readable storage media may include random access memory RAM read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM flash memory a hard disk a CD ROM a floppy disk a cassette magnetic media optical media or other computer readable storage media that is tangible.

Computer readable media may include computer readable storage media which corresponds to a tangible storage medium such as those listed above. Computer readable media may also comprise communication media including any medium that facilitates transfer of a computer program from one place to another e.g. according to a communication protocol. In this manner the phrase computer readable media generally may correspond to 1 tangible computer readable storage media which is non transitory and 2 a non tangible computer readable communication medium such as a transitory signal or carrier wave.

Various aspects and examples have been described. However modifications can be made to the structure or techniques of this disclosure without departing from the scope of the following claims.

