---

title: Technologies for efficient synchronization barriers with work stealing support
abstract: Technologies for multithreaded synchronization and work stealing include a computing device executing two or more threads in a thread team. A thread executes all of the tasks in its task queue and then exchanges its associated task stolen flag value with false and stores that value in a temporary flag. Subsequently, the thread enters a basic synchronization barrier. The computing device performs a logical-OR reduction over the temporary flags of the thread team to produce a reduction value. While waiting for other threads of the thread team to enter the barrier, the thread may steal a task from a victim thread and set the task stolen flag of the victim thread to true. After exiting the basic synchronization barrier, if the reduction value is true, the thread repeats exchanging the task stolen flag value and entering the basic synchronization barrier. Other embodiments are described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09348658&OS=09348658&RS=09348658
owner: Intel Corporation
number: 09348658
owner_city: Santa Clara
owner_country: US
publication_date: 20141212
---
For current computing devices and applications efficient multithreaded performance is becoming increasingly important. OpenMP is a popular application programming interface API for shared memory parallel programming. OpenMP specifies a synchronization barrier feature which may be used to coordinate multiple threads executing in a thread team. In general all threads of the thread team must reach the barrier before execution of the program may proceed. OpenMP also specifies a tasking system in which threads may create and execute tasks. All tasks must be completed before the threads may exit a synchronization barrier. Thus tasks are often executed while threads are waiting in synchronization barriers.

Many OpenMP implementations use work stealing in which a thread may steal tasks to execute from another thread that is a thread may claim a task from another thread and run the task to completion. To be compatible with tasking requirements OpenMP synchronization barriers are typically implemented as tree or linear barriers. However tree barriers have a relatively longer critical path compared to non tree barriers such as dissemination barriers.

While the concepts of the present disclosure are susceptible to various modifications and alternative forms specific embodiments thereof have been shown by way of example in the drawings and will be described herein in detail. It should be understood however that there is no intent to limit the concepts of the present disclosure to the particular forms disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives consistent with the present disclosure and the appended claims.

References in the specification to one embodiment an embodiment an illustrative embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may or may not necessarily include that particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to effect such feature structure or characteristic in connection with other embodiments whether or not explicitly described. Additionally it should be appreciated that items included in a list in the form of at least one A B and C can mean A B C A and B A and C B and C or A B and C . Similarly items listed in the form of at least one of A B or C can mean A B C A and B A and C B and C or A B and C .

The disclosed embodiments may be implemented in some cases in hardware firmware software or any combination thereof. The disclosed embodiments may also be implemented as instructions carried by or stored on a transitory or non transitory machine readable e.g. computer readable storage medium which may be read and executed by one or more processors. A machine readable storage medium may be embodied as any storage device mechanism or other physical structure for storing or transmitting information in a form readable by a machine e.g. a volatile or non volatile memory a media disc or other media device .

In the drawings some structural or method features may be shown in specific arrangements and or orderings. However it should be appreciated that such specific arrangements and or orderings may not be required. Rather in some embodiments such features may be arranged in a different manner and or order than shown in the illustrative figures. Additionally the inclusion of a structural or method feature in a particular figure is not meant to imply that such feature is required in all embodiments and in some embodiments may not be included or may be combined with other features.

Referring now to an illustrative computing device for efficient synchronization barriers with work stealing includes a processor an I O subsystem a memory and a data storage device . In use as described below the computing device is configured to execute a number of tasks by a group of threads organized into a thread team. Each thread is associated with a corresponding task queue and a Boolean flag. After completing all of its pending tasks a thread may enter a synchronization barrier. Before entering the barrier the thread atomically exchanges its flag value with false and stores the original flag value in a thread local temporary flag variable. While waiting for other threads to enter the barrier the active thread may steal a task from another thread the victim thread set the flag of the victim thread to true and execute the victim task i.e. the task stolen from the victim thread to completion. Execution of the victim task may cause more tasks to be added to the active thread s queue. The computing device performs a logical OR reduction operation over the temporary flag variables of each of the threads to generate a reduction value. The reduction value indicates whether any of the threads in the thread team had their corresponding flags set to true prior to entering the barrier. In other words the reduction value indicates whether any of the threads had a task stolen i.e. was a victim thread prior to entering the barrier. If the reduction value is true the computing device causes all of the threads to retry the synchronization barrier. If the reduction value is false the computing device allows all of the threads to continue execution.

The computing device may allow a non tree barrier such as a dissemination barrier to be used compatibly with OpenMP tasking semantics. Non tree barriers may improve performance compared to tree barriers. Illustratively a computing device as described herein including an Intel Xeon Phi coprocessor may achieve synchronization barrier performance that is about twice as fast as conventional tree barriers. Additionally although illustrated as a synchronization barrier for shared memory multithreading the techniques disclosed herein may be used for any concurrent execution environment including distributed computing environments.

The computing device may be embodied as any type of device capable of efficient execution of synchronization barriers with work stealing and otherwise performing the functions described herein. For example the computing device may be embodied as without limitation a computer a desktop computer a workstation a server computer a distributed computing system a multiprocessor system a laptop computer a notebook computer a tablet computer a smartphone a mobile computing device a wearable computing device a consumer electronic device a smart appliance and or any other computing device capable of efficient execution of synchronization barriers. As shown in the illustrative computing device includes the processor the I O subsystem the memory and the data storage device . Of course the computing device may include other or additional components such as those commonly found in a computer e.g. various input output devices in other embodiments. Additionally in some embodiments one or more of the illustrative components may be incorporated in or otherwise form a portion of another component. For example the memory or portions thereof may be incorporated in the processor in some embodiments.

The processor may be embodied as any type of processor capable of performing the functions described herein. For example the processor may be embodied as a single or multi core processor s coprocessor s digital signal processor microcontroller or other processor or processing controlling circuit. Similarly the memory may be embodied as any type of volatile or non volatile memory or data storage capable of performing the functions described herein. In operation the memory may store various data and software used during operation of the computing device such operating systems applications programs libraries and drivers. The memory is communicatively coupled to the processor via the I O subsystem which may be embodied as circuitry and or components to facilitate input output operations with the processor the memory and other components of the computing device . For example the I O subsystem may be embodied as or otherwise include memory controller hubs input output control hubs firmware devices communication links i.e. point to point links bus links wires cables light guides printed circuit board traces etc. and or other components and subsystems to facilitate the input output operations. In some embodiments the I O subsystem may form a portion of a system on a chip SoC and be incorporated along with the processor the memory and other components of the computing device on a single integrated circuit chip.

The data storage device may be embodied as any type of device or devices configured for short term or long term storage of data such as for example memory devices and circuits memory cards hard disk drives solid state drives or other data storage devices.

The computing device may also include a communication subsystem which may be embodied as any communication circuit device or collection thereof capable of enabling communications between the computing device and other remote devices over a computer network not shown . The communication subsystem may be configured to use any one or more communication technology e.g. wired or wireless communications and associated protocols e.g. Ethernet Bluetooth Wi Fi WiMAX etc. to effect such communication.

Referring now to in the illustrative embodiment the computing device establishes an environment during operation. The illustrative embodiment includes a transactional barrier module a basic barrier module a reduction module a task execution module a task stealing module and a threading module . The various modules of the environment may be embodied as hardware firmware software or a combination thereof. For example the various modules logic and other components of the environment may form a portion of or otherwise be established by the processor or other hardware components of the computing device . For example in some embodiments one or more of the modules of the environment may be embodied as a circuit e.g. a synchronization barrier circuit a reduction circuit etc. .

The threading module is configured to create execute and otherwise manage a thread team and one or more threads . The thread team may be embodied as a collection of threads that may be used to execute a particular group of tasks or other computing problem. Each of the threads may be embodied as an operating system thread managed executable thread application thread worker thread lightweight thread or other executable program. The threads may share a common memory space but may also access thread local storage private variables or other data that is not shared by multiple threads . Each thread maintains a task queue and a flag . The task queue includes a list of executable tasks to be performed by the thread . As further described below each thread may execute tasks from its own task queue or may steal tasks from the task queue of a different thread and execute the stolen tasks. The flag includes a Boolean value e.g. true or false that may be set if another thread has stolen a task from the task queue . A distinct task queue and or flag may be stored for each thread for example in a thread control structure or in thread local storage. Additionally although the illustrative embodiment includes a single thread team having two threads it should be understood that in some embodiments the environment may include multiple thread teams and each thread team may have multiple threads .

The transactional barrier module is configured to atomically exchange the flag of the thread with false and store the original value of the flag in a thread local temporary flag variable. The transactional barrier module is configured to enter a basic synchronization barrier after exchanging the flag and storing the temporary flag variable using the basic barrier module . As further described below the reduction module generates a reduction value over the temporary flag variables of all of the threads of the thread team . The transactional barrier module is further configured to determine whether the reduction value is true and if true cause the thread to retry exchanging the flag and re entering the basic synchronization barrier. That is if the reduction value is true transactional barrier module is configured to repeat atomically exchanging the flag of the thread with false and storing the original value of the flag in a thread local temporary flag variable.

The reduction module is configured to perform a logical OR reduction over the temporary flag variables of each of the threads of the thread team during execution of the basic synchronization barrier. In other words reduction module is configured to perform a logical OR operation on all of the locally stored flag values for each thread and distribute the resulting reduction value to each of the threads . The reduction module may use any algorithm for performing the reduction including performing a non tree based algorithm such as a dissemination barrier algorithm or a K radix barrier algorithm.

The task execution module is configured to pop tasks from the task queue of a thread and run those tasks to completion. The task execution module may pop the first task from the task queue or otherwise schedule tasks from the task queue . The task execution module is also configured to determine whether the task queue is empty prior to entering the synchronization barrier and to enter the synchronization barrier in response to determining the task queue is empty. The task execution module is configured to leave the transactional barrier after exiting the basic synchronization barrier if the reduction value is false i.e. if no further tasks were stolen from any threads of the thread team .

The task stealing module is configured to atomically steal a task from a victim thread when a thread is waiting in the synchronization barrier and to set the flag of the victim thread to true in response to stealing the task. In some embodiments as an optimization the task stealing module may only set the flag of the victim thread to true if the flag of the active thread is not true e.g. false . The task stealing module may identify the victim thread randomly determine whether the task queue of the victim thread is empty and if not empty pop a task from the task queue of the victim thread . The task stealing module may execute the victim task to completion and after completing the victim task execute any tasks that have been added to the task queue of the active thread .

Referring now to in use the computing device may execute a method for parallel task execution and work stealing. The method begins in block in which the computing device starts execution of a group of tasks by the thread team . Execution of the tasks may be started for example by a master thread or other control entity of the computing device . After starting execution of tasks the method proceeds in parallel to the blocks .

In the blocks the computing device executes tasks in parallel using the threads and performs work stealing. For example each of the threads may execute tasks from its task queue in parallel with the other threads . The illustrative method shows three blocks executed in parallel by three threads . Of course other embodiments may include fewer or additional blocks executed by corresponding threads . As shown in the method tasks may be transferred between the threads during execution of the blocks . For example a thread may steal a task from the task queue of a different thread and then execute that stolen task.

After executing the tasks in the blocks the method enters a transactional synchronization barrier . For example each thread may enter the synchronization barrier after it has completed executing all of the tasks in its task queue . The threads wait within the transactional synchronization barrier until all of the tasks to be executed by the thread team have been run to completion. As further described below threads waiting in the synchronization barrier may steal tasks from threads that are still executing within the blocks . After all tasks are complete the method loops back to the blocks to continue executing tasks in parallel and performing work stealing.

Referring now to in use the computing device may execute a method for executing a synchronization barrier. An instance of the method may be executed by each of the threads of the thread team for example during execution of the method of . The method begins in block in which the computing device in a thread pops a task from the task queue of the thread . The task queue may be embodied as any queue doubly ended queue list array buffer or other data structure used to store tasks to be executed by the thread . The task queue may be stored in thread local storage or other storage associated with the thread . In some embodiments the task queue may be accessible to other threads .

In block the computing device runs the task to completion using the thread . After completing the task in block the computing device determines whether the task queue of the thread is empty. If not the method loops back to block to continue executing tasks from the task queue . If the task queue is empty the method advances to block .

In block the computing device using the thread exchanges the flag with the Boolean false value and locally stores the previous value of the flag . For example the previous value of the flag may be stored in a private variable of the thread or otherwise stored in thread local storage of the thread . The computing device may exchange and locally store the flag value using one or more atomic operations. In some embodiments the computing device may instead use non atomic operations protected by a lock on the task queue or other synchronization mechanism.

In block the computing device enters a basic synchronization barrier using the thread . The basic synchronization barrier may be embodied as any type of synchronization barrier including a tree barrier a linear barrier or a non tree barrier such as a dissemination barrier. In some embodiments the basic synchronization barrier may be embodied as a K radix synchronization barrier such as the barrier described in the co pending U.S. patent application Ser. No. 14 568 890 entitled Technologies for Fast Synchronization Barriers for Many Core Processing. 

In block the computing device performs a logical OR reduction operation over the locally stored flag value. In other words the computing device performs a logical OR operation on all of the locally stored flag values for each thread and distributes the resulting reduction value to each of the threads . As further described below the reduction value is indicative of whether any of the threads had a task stolen prior to entering the synchronization barrier. In other words the reduction value is true if the flag of any of the threads was true prior to the corresponding thread entering the synchronization barrier.

In block if the thread is waiting in the synchronization barrier for other threads the computing device may steal one or more tasks from another thread the victim thread and set the flag of the victim thread to true. One potential embodiment of the work stealing process is further described below in connection with .

In block the computing device in the thread exits the basic synchronization barrier. The thread may exit the synchronization barrier in response to all other threads of the thread team entering the synchronization barrier. Thus upon exiting the synchronization barrier the reduction value may be determined.

In block the computing device in the thread determines the reduction value which is the result of the reduce all logical OR operation described above in connection with block . As described above if true then one or more tasks were stolen from a thread prior to that thread entering the synchronization barrier and thus those tasks may still be in flight. In block the computing device determines whether the reduction value is true or false. If true the method loops back to block to retry exchanging the flag and then entering the barrier. If the reduction value is false then the method is completed. In other words the computing device determines whether the synchronization barrier completes without any tasks being stolen from a thread and if not retries the synchronization barrier. Thus the synchronization barrier operation performed by the computing device during execution of the method may be known as a transactional synchronization barrier or a transactional barrier.

Referring now to in use the computing device may execute a method for work stealing. The method may be executed by the computing device using a thread while the thread is waiting within a synchronization barrier as described above in connection with block of . The method begins in block in which the computing device in the thread determines whether to exit the basic synchronization barrier. As described above in connection with block of the thread may exit the synchronization barrier in response to all other threads of the thread team entering the synchronization barrier. If the computing device determines to exit the synchronization barrier the method is completed. If the computing device determines not to exit the synchronization barrier i.e. the thread is waiting within the synchronization barrier the method advances to block .

In block the computing device in the thread determines a random victim thread . For example the computing device may randomly select a thread identifier or otherwise randomly select the victim thread from the threads of the thread team . In block the computing device using the thread determines whether the task queue of the victim thread is empty. If empty the method loops back to block to select another victim thread . If the task queue of the victim thread is not empty the method advances to block .

In block the computing device performs operations atomically in the thread . In particular the computing device performs the operations described below in connection with blocks atomically. The computing device may for example execute one or more atomic instructions or other atomic operations. In some embodiments the computing device may instead use non atomic operations protected by a lock on the task queue of the victim thread or other synchronization mechanism.

In block the computing device in the thread pops a task from the task queue of the victim thread . In some embodiments after popping the task the method may proceed to block . In embodiments that do not include the block the method may proceed directly to block described below. In block the computing device in the thread determines whether the flag of the thread is true. If true then the method exits the atomic operation of the block and proceeds to block described below. If the flag is false the method proceeds to the block in which the computing device in the thread sets the flag of the victim thread to true. Checking whether the flag is true in block may improve performance by skipping the block when it is not needed if the flag is already true then the thread can determine that the logical OR reduction will return true without accessing the flag of another thread

In block the computing device in the thread runs the victim task to completion. That is the computing device executes the task popped from the task queue of the victim thread to completion. In block the computing device in the thread determines whether the task queue of the thread is empty. As described above in connection with block of each thread determines that its task queue is empty prior to entering the synchronization barrier. However during execution of the victim task in connection with block one or more new tasks may have been created and added to the task queue of the thread . Thus the thread checks its own task queue to determine whether any additional tasks have been added. If the task queue is empty the method loops back to block to continue performing work stealing. If the task queue is not empty the method advances to block .

In block the computing device in the thread pops a task from its task queue . In block the computing device in the thread runs the task to completion. After completing the task the method loops back to block to continue executing any tasks in the task queue of the thread

Illustrative examples of the technologies disclosed herein are provided below. An embodiment of the technologies may include any one or more and any combination of the examples described below.

Example 1 includes a computing device for multithreaded execution the computing device comprising a transactional barrier module to exchange by a first thread of a thread team executed by the computing device a value of a task stolen flag of the first thread with false and store the value of the task stolen flag in a temporary flag of the first thread wherein the temporary flag is local to the first thread and enter by the first thread subsequent to exchange of the value of the task stolen flag a synchronization barrier and a reduction module to determine by the first thread whether any temporary flag of a plurality of temporary flags of the thread team was true upon entering of the synchronization barrier wherein the thread team comprises a plurality of threads including the first thread wherein the transactional barrier module is further to repeat by the first thread exchange of the value of the task stolen flag in response to a determination that any temporary flag of the plurality of temporary flags was true.

Example 2 includes the subject matter of Example 1 and wherein to determine whether any temporary flag of the plurality of temporary flags of the thread team was true comprises to perform in response to entering of the synchronization barrier a logical OR reduction operation over the plurality of temporary flags of the thread team to provide a reduction value to each thread of the thread team.

Example 3 includes the subject matter of any of Examples 1 and 2 and wherein to exchange the value of the task stolen flag of the first thread with false and store the value of the task stolen flag in the temporary flag comprises to atomically exchange the value of the task stolen flag of the first thread with false and store the value of the task stolen flag in the temporary flag.

Example 4 includes the subject matter of any of Examples 1 3 and further including a task execution module to execute by the first thread a first task from a task queue of the first thread and determine by the first thread whether the task queue is empty wherein to exchange the value of the task stolen flag comprises to exchange the value of the task stolen flag in response to a determination that the task queue is empty.

Example 5 includes the subject matter of any of Examples 1 4 and wherein each of the plurality of temporary flags corresponds to a thread of the thread team.

Example 6 includes the subject matter of any of Examples 1 5 and wherein the transactional barrier module is further to wait by the first thread for other threads of the thread team to enter the synchronization barrier in response to the entering of the synchronization barrier.

Example 7 includes the subject matter of any of Examples 1 6 and further including a task stealing module to steal by the first thread a task from a second thread of the thread team in response to waiting for the other threads of the thread team to enter the synchronization barrier and set by the first thread a task stolen flag of the second thread to true in response to stealing of the task.

Example 8 includes the subject matter of any of Examples 1 7 and wherein to steal the task and to set the task stolen flag of the second thread comprises to atomically steal the task and set the task stolen flag of the second thread.

Example 9 includes the subject matter of any of Examples 1 8 and wherein to steal the task comprises to identify the second thread of the thread team and pop the task from a task queue of the second thread wherein to pop the task and set the task stolen flag of the second thread comprises to atomically pop the task and set the task stolen flag of the second thread.

Example 10 includes the subject matter of any of Examples 1 9 and wherein to identify the second thread comprises to select the second thread randomly from the thread team.

Example 11 includes the subject matter of any of Examples 1 10 and wherein to identify the second thread further comprises to determine whether the task queue of the second thread is empty and repeat selection of the second thread randomly in response to a determination that the task queue is empty.

Example 12 includes the subject matter of any of Examples 1 11 and wherein to steal the task further comprises to execute by the first thread the task to completion in response to popping of the task determine by the first thread whether a task queue of the first thread is empty in response to execution of the task to completion pop by the first thread a second task from the task queue in response to a determination that the task queue is not empty and execute by the first thread the second task to completion in response to popping of the second task.

Example 13 includes the subject matter of any of Examples 1 12 and wherein the task stealing module is further to determine by the first thread whether the temporary flag of the first thread is equal to false in response to stealing of the task from the second thread wherein to set the task stolen flag of the second thread to true further comprises to set the task stolen flag of the second thread to true in response to a determination that the temporary flag is equal to false.

Example 14 includes a method for multithreaded execution the method comprising exchanging by a first thread of a thread team executed by a computing device a value of a task stolen flag of the first thread with false and storing the value of the task stolen flag in a temporary flag of the first thread wherein the temporary flag is local to the first thread entering by the first thread subsequent to exchanging of the value of the task stolen flag a synchronization barrier determining by the first thread whether any temporary flag of a plurality of temporary flags of the thread team was true upon entering the synchronization barrier wherein the thread team comprises a plurality of threads including the first thread and repeating by the first thread exchanging the value of the task stolen flag in response to determining that any temporary flag of the plurality of temporary flags was true.

Example 15 includes the subject matter of Example 14 and wherein determining whether any temporary flag of the plurality of temporary flags of the thread team was true comprises performing in response to entering the synchronization barrier a logical OR reduction operation over the plurality of temporary flags of the thread team to provide a reduction value to each thread of the thread team.

Example 16 includes the subject matter of any of Examples 14 and 15 and wherein exchanging the value of the task stolen flag of the first thread with false and storing the value of the task stolen flag in the temporary flag comprises atomically exchanging the value of the task stolen flag of the first thread with false and storing the value of the task stolen flag in the temporary flag.

Example 17 includes the subject matter of any of Examples 14 16 and further including executing by the first thread a first task from a task queue of the first thread and determining by the first thread whether the task queue is empty wherein exchanging the value of the task stolen flag comprises exchanging the value of the task stolen flag in response to determining that the task queue is empty.

Example 18 includes the subject matter of any of Examples 14 17 and wherein each of the plurality of temporary flags corresponds to a thread of the thread team.

Example 19 includes the subject matter of any of Examples 14 18 and further comprising waiting by the first thread for other threads of the thread team to enter the synchronization barrier in response to entering the synchronization barrier.

Example 20 includes the subject matter of any of Examples 14 19 and further including stealing by the first thread a task from a second thread of the thread team in response to waiting for the other threads of the thread team to enter the synchronization barrier and setting by the first thread a task stolen flag of the second thread to true in response to stealing the task.

Example 21 includes the subject matter of any of Examples 14 20 and wherein stealing the task and setting the task stolen flag of the second thread comprises atomically stealing the task and setting the task stolen flag of the second thread.

Example 22 includes the subject matter of any of Examples 14 21 and wherein stealing the task comprises identifying the second thread of the thread team and popping the task from a task queue of the second thread wherein popping the task and setting the task stolen flag of the second thread comprises atomically popping the task and setting the task stolen flag of the second thread.

Example 23 includes the subject matter of any of Examples 14 22 and wherein identifying the second thread comprises selecting the second thread randomly from the thread team.

Example 24 includes the subject matter of any of Examples 14 23 and wherein identifying the second thread further comprises determining whether the task queue of the second thread is empty and repeating selecting the second thread randomly in response to determining that the task queue is empty.

Example 25 includes the subject matter of any of Examples 14 24 and wherein stealing the task further comprises executing by the first thread the task to completion in response to popping the task determining by the first thread whether a task queue of the first thread is empty in response to executing the task to completion popping by the first thread a second task from the task queue in response to determining the task queue is not empty and executing by the first thread the second task to completion in response to popping the second task.

Example 26 includes the subject matter of any of Examples 14 25 and further including determining by the first thread whether the temporary flag of the first thread is equal to false in response to stealing the task from the second thread wherein setting the task stolen flag of the second thread to true further comprises setting the task stolen flag of the second thread to true in response to determining that the temporary flag is equal to false.

Example 27 includes a computing device comprising a processor and a memory having stored therein a plurality of instructions that when executed by the processor cause the computing device to perform the method of any of Examples 14 26.

Example 28 includes one or more machine readable storage media comprising a plurality of instructions stored thereon that in response to being executed result in a computing device performing the method of any of Examples 14 26.

Example 29 includes a computing device comprising means for performing the method of any of Examples 14 26.

Example 30 includes a computing device for multithreaded execution the computing device comprising means for exchanging by a first thread of a thread team executed by the computing device a value of a task stolen flag of the first thread with false and storing the value of the task stolen flag in a temporary flag of the first thread wherein the temporary flag is local to the first thread means for entering by the first thread subsequent to exchanging of the value of the task stolen flag a synchronization barrier means for determining by the first thread whether any temporary flag of a plurality of temporary flags of the thread team was true upon entering the synchronization barrier wherein the thread team comprises a plurality of threads including the first thread and means for repeating by the first thread exchanging the value of the task stolen flag in response to determining that any temporary flag of the plurality of temporary flags was true.

Example 31 includes the subject matter of Example 30 and wherein the means for determining whether any temporary flag of the plurality of temporary flags of the thread team was true comprises means for performing in response to entering the synchronization barrier a logical OR reduction operation over the plurality of temporary flags of the thread team to provide a reduction value to each thread of the thread team.

Example 32 includes the subject matter of any of Examples 30 and 31 and wherein the means for exchanging the value of the task stolen flag of the first thread with false and storing the value of the task stolen flag in the temporary flag comprises means for atomically exchanging the value of the task stolen flag of the first thread with false and storing the value of the task stolen flag in the temporary flag.

Example 33 includes the subject matter of any of Examples 30 32 and further including means for executing by the first thread a first task from a task queue of the first thread and means for determining by the first thread whether the task queue is empty wherein the means for exchanging the value of the task stolen flag comprises means for exchanging the value of the task stolen flag in response to determining that the task queue is empty.

Example 34 includes the subject matter of any of Examples 30 33 and wherein each of the plurality of temporary flags corresponds to a thread of the thread team.

Example 35 includes the subject matter of any of Examples 30 34 and further including means for waiting by the first thread for other threads of the thread team to enter the synchronization barrier in response to entering the synchronization barrier.

Example 36 includes the subject matter of any of Examples 30 35 and further including means for stealing by the first thread a task from a second thread of the thread team in response to waiting for the other threads of the thread team to enter the synchronization barrier and means for setting by the first thread a task stolen flag of the second thread to true in response to stealing the task.

Example 37 includes the subject matter of any of Examples 30 36 and wherein the means for stealing the task and the means for setting the task stolen flag of the second thread comprises means for atomically stealing the task and setting the task stolen flag of the second thread.

Example 38 includes the subject matter of any of Examples 30 37 and wherein the means for stealing the task comprises means for identifying the second thread of the thread team and means for popping the task from a task queue of the second thread wherein the means for popping the task and the means for setting the task stolen flag of the second thread comprises means for atomically popping the task and setting the task stolen flag of the second thread.

Example 39 includes the subject matter of any of Examples 30 38 and wherein the means for identifying the second thread comprises means for selecting the second thread randomly from the thread team.

Example 40 includes the subject matter of any of Examples 30 39 and wherein the means for identifying the second thread further comprises means for determining whether the task queue of the second thread is empty and means for repeating selecting the second thread randomly in response to determining that the task queue is empty.

Example 41 includes the subject matter of any of Examples 30 40 and wherein the means for stealing the task further comprises means for executing by the first thread the task to completion in response to popping the task means for determining by the first thread whether a task queue of the first thread is empty in response to executing the task to completion means for popping by the first thread a second task from the task queue in response to determining the task queue is not empty and means for executing by the first thread the second task to completion in response to popping the second task.

Example 42 includes the subject matter of any of Examples 30 41 and further including means for determining by the first thread whether the temporary flag of the first thread is equal to false in response to stealing the task from the second thread wherein the means for setting the task stolen flag of the second thread to true further comprises means for setting the task stolen flag of the second thread to true in response to determining that the temporary flag is equal to false.

