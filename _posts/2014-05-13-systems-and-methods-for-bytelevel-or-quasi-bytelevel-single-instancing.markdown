---

title: Systems and methods for byte-level or quasi byte-level single instancing
abstract: Described in detail herein are systems and methods for deduplicating data using byte-level or quasi byte-level techniques. In some embodiments, a file is divided into multiple blocks. A block includes multiple bytes. Multiple rolling hashes of the file are generated. For each byte in the file, a searchable data structure is accessed to determine if the data structure already includes an entry matching a hash of a minimum sequence length. If so, this indicates that the corresponding bytes are already stored. If one or more bytes in the file are already stored, then the one or more bytes in the file are replaced with a reference to the already stored bytes. The systems and methods described herein may be used for file systems, databases, storing backup data, or any other use case where it may be useful to reduce the amount of data being stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09158787&OS=09158787&RS=09158787
owner: Commvault Systems, Inc
number: 09158787
owner_city: Tinton Falls
owner_country: US
publication_date: 20140513
---
This application is a continuation of U.S. patent application Ser. No. 13 855 514 filed on Apr. 2 2013 entitled SYSTEMS AND METHODS FOR BYTE LEVEL OR QUASI BYTE LEVEL SINGLE INSTANCING now U.S. Pat. No. 8 725 687 which is a continuation of U.S. patent application Ser. No. 12 626 839 filed on Nov. 27 2009 now U.S. Pat. No. 8 412 677 entitled SYSTEMS AN METHODS FOR BYTE LEVEL OR QUASI BYTE LEVEL SINGLE INSTANCING which claims priority to and the benefit of U.S. Patent Application No. 61 118 379 filed on Nov. 26 2008 entitled SYSTEMS AND METHODS FOR BYTE LEVEL OR QUASI BYTE LEVEL SINGLE INSTANCING each of which is incorporated by reference in its entirety.

File based means that for example if an Excel spread sheet file on a disk is copied to another location on the disk on a single instanced data store it would be detected that they contain the same contents and only one reference to the file would be kept regardless of how many times it appears on the disk or other disks and under which filesystems.

However if this Excel spreadsheet is opened and only one number is changed then it is saved even though 99 of the document is still the same file level single instancing would not work.

Block level single instancing would help here. Block level single instancing chops up files into blocks and even if one block in the example where the number got changed doesn t match the other blocks still do so they can be single instanced.

However if new rows are inserted or using a different example a file e.g. a Word document that is split into blocks of certain fixed block sizes if somewhere at the start a single letter a word or a sentence is inserted everything below it will shift and all the blocks will become different even though only a small change in the file occurred.

The need exists for a system that overcomes the above problems as well as one that provides additional benefits. Overall the examples herein of some prior or related systems and their associated limitations are intended to be illustrative and not exclusive. Other limitations of existing or prior systems will become apparent to those of skill in the art upon reading the following Detailed Description.

The headings provided herein are for convenience only and do not necessarily affect the scope or meaning of the claimed invention.

One purpose of single instancing alternatively referred to herein as deduplicating is to minimize storage space and to avoid storing duplicate data multiple times.

One challenge of performing single instancing on a byte level is finding matches. With a block level where a strong hash function is used either the whole block can be used or nothing at all. Also the strong hash function such as MD5 or SHA1 may present a problem in that a sequence like 1234567890 and a hash of length 4 to calculate the hash of 1234 2345 3456 4567 5678 6789 7890 requires each byte 7 4 28 bytes here to be read again and again.

Using a rolling hash reduces the number of reads to 1234 1 5 2 6 3 7 4 8 5 9 6 0 or to 16. Rolling hashes reduce hash calculation time from one byte to the next which is needed in byte level single instancing from O n to O 1 . Even when a hash is present a hash only allows one to verify in one shot if a set number of bytes might be equal to another set number of bytes. It breaks down if the number of bytes one wants to compare becomes variable.

In addition when wanting to compare whether or not data of a variable size matches anything already encountered how to do the comparison a the size of the data can be very small or extremely large and b it may be difficult to ascertain what the size of the data to compare is.

This is where the power of 2 hashes can be used. By that a number of hashes is stored rather than just one where the amount of data hashed increases by powers of 2. Rolling hashes may not be reliable though so the data needs to be verified. If one would just link to the data stored in different files one would need to open and close hundreds and hundreds of files every minute. This may not work very well.

This document describes systems and methods that provide for storing data in a manner employing byte level or quasi byte level single instancing so that individual files or data objects can be read in a random access fashion modified and space can be reclaimed for reuse.

In some embodiments file names or other metadata of files may be stored. In other embodiments such metadata may not be stored. In these embodiments however the data of a file can be referenced by way of a reference pointer.

This makes the system useful not only for filesystems but anywhere where data needs to be referenced and it is desired to reduce the amount of data storage. This approach would also be useful for storing blob data or large strings in databases or as in a use case of storing backup data.

The system will store data in blocks however not the whole block needs to match for single instancing e.g. only the start of the sequence of data stored within a block needs to match in order for the block to become usable. Block sizes of data can be very small. The smaller the block size the better the single instancing achieved however also the higher the overhead. Blocks can reference other blocks by way of direct addressing and a length e.g. block 10 can reference block 2 starting at offset 26 for a length of 200 bytes source bytes . Due to this referencing even though the block size is very small one block can refer to gigabytes of actual data from now on referred to as source data . One implementation can also have pseudo blocks which are not coded data blocks but rather links to inside other coded data blocks. This may be useful to put a frequently used offset of an actual block into the search tree. A byte level or quasi byte level single instancing method allows single instancing of a block even though the entire block does not match another block only just the beginning or with a reference even only a part within it . This differs from block or file level single instancing where if data shifts by a byte a lot if not all blocks become out of alignment and cannot be used. With byte level or quasi byte level single instancing the maximum amount of data which cannot be single instanced due to such a data shift is one block length in the byte rather than kilobyte range . Blocks may further be stored within a search tree. Pseudo blocks may be inserted into the search tree but do not have to be. The search tree allows for random access of desired blocks.

This search tree should allow direct addressing of the nodes so that one node or leaf of the search tree can immediately link to another node or leaf of the search tree no matter where in the search tree the referenced block is. The resulting data structure may be considered to be a graph. This data structure will be referred to herein as the search tree. In some embodiments a node should not refer to any node that was added after the node so as to avoid cyclic dependencies.

The search tree portion will contain coded data blocks in a sorted fashion so it is easily traversable. Each block contains meta information for example but not limited to the number of references which byte within the block contains the half way mark of the data and what the source offset is and hashes.

In some embodiments the data is to be stored in very few files maybe only one file . This helps during verification that is required and adds the benefit that any number of bytes from a sequence already existing can be used also this adds the advantage of being able to update the reference counts of the individual code blocks while traversing the data. In addition storing the data in this fashion compresses the data on the fly.

The data should be stored in a sorted format so in some embodiments that data is stored in a search tree. Any suitable data structure may be used. The data structure should be a data structure where any node of the search tree can reference other nodes of the search tree regardless of where in the search tree the other nodes are possibly subject to some exceptions. In some embodiments a first node of the search tree can reference data in any other node excepting nodes that are descendants e.g. children grandchildren etc. of the first node.

A suitable mechanism of how to compare and sort two data blocks that can represent data gigabytes in length though the actual blocks are only a couple of bytes long is needed.

In some embodiments performing byte level or quasi byte level single instancing uses the following method by using power of 2 rolling hashes to sort a large number of small blocks of data representing a very large amount of data into a search tree where each node can reference data in other nodes for the purpose of storing data in a compressed and single instanced format whereby it is still possible to easily jump to any point within a file and read from it and also being able to modify and delete data from this data structure.

The advantages of byte level or quasi byte level single instancing are numerous a lot more data than previously with block level or file level can be single instanced and an automatic compression is achieved at the same time. Since hashes are in general not relied upon they may be used to detect repeat occurrences there are generally also no problems of hash collisions which could cause data corruption in previous approaches.

Various examples of the invention will now be described. The following description provides specific details for a thorough understanding and enabling description of these examples. One skilled in the relevant art will understand however that the invention may be practiced without many of these details. Likewise one skilled in the relevant art will also understand that the invention may include many other obvious features not described in detail herein. Additionally some well known structures or functions may not be shown or described in detail below so as to avoid unnecessarily obscuring the relevant description.

The terminology used below is to be interpreted in its broadest reasonable manner even though it is being used in conjunction with a detailed description of certain specific examples of the invention. Indeed certain terms may even be emphasized below however any terminology intended to be interpreted in any restricted manner will be overtly and specifically defined as such in this Detailed Description section.

The following discussion provides a brief general description of a suitable specialized environment in which the invention can be implemented. Those skilled in the relevant art will appreciate that aspects of the invention can be practiced with other communications data processing or computer system configurations including Internet appliances hand held devices including personal digital assistants PDAs wearable computers all manner of cellular phones mobile phones and or mobile devices multi processor systems microprocessor based or programmable consumer electronics set top boxes network PCs mini computers mainframe computers and the like. The terms computer server host host system and the like are generally used interchangeably herein and refer to any of the above devices and systems as well as any data processor.

While aspects of the invention such as certain functions are described as being performed exclusively on a single device the invention can also be practiced in distributed environments where functions or modules are shared among disparate processing devices which are linked through a communications network such as a Local Area Network LAN Wide Area Network WAN and or the Internet. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

Aspects of the invention may be stored or distributed on tangible computer readable media including magnetically or optically readable computer discs hard wired or preprogrammed chips e.g. EEPROM semiconductor chips nanotechnology memory biological memory or other data storage media. Alternatively computer implemented instructions data structures screen displays and other data under aspects of the invention may be distributed over the Internet or over other networks including wireless networks on a propagated signal on a propagation medium e.g. an electromagnetic wave s a sound wave etc. over a period of time or they may be provided on any analog or digital network packet switched circuit switched or other scheme .

With block level and file level single instancing there is only very little data the strong hash to check against a hash database one lookup every 128 KB or more not looking for a match for every single byte read. How to do this fast and quickly determining the best match is one problem.

Databases store data within trees also however they store the complete row data. In some embodiments the data is being divided up into tiny pieces compressing it into the tree and making all the parts searchable. While hashes are used they are not relied on they are just used to find potential matches.

The search tree should have the following capabilities 1 as balanced as possible with minimal overhead when adding new code blocks and 2 while the positions of blocks within the search tree may change the block should be addressable under its old location even if the location in the search tree changes due to inserts deletions.

In some embodiments the data structure is skipped lists. A skip list is a probabilistic data structure based on multiple parallel sorted linked lists with efficiency comparable to a binary search tree order log n average time for most operations . However another data structure for example a red black tree linking to coded blocks may be used.

One advantage of skipped lists is that it remains mostly balanced does not require reordering of nodes when items are inserted removed meaning absolute locations will remain the same and the sorted linked list property of it also lends itself well to objectives of byte level or quasi byte level single instancing. It also makes locking of nodes easier and keeps the rest of the search tree open in case of concurrent accesses. An entire block can be bypassed by providing alternate paths during locking and still have a valid search tree.

An important consideration is how to store the data within the search tree and how to determine if one block which can refer to gigabytes of source data is smaller equal or greater than an existing block.

In some embodiments the method used is rolling hashes. A rolling hash is a hash function where the input is hashed in a window that moves through the input. In some embodiments Robin Karp rolling hash techniques may be used.

Rolling hashes have the property that given an input stream and a fixed number of n bytes for which a hash is to be created that it is typically very easy and fast to get the next hash when the next input character is read example sequence is 1234567 a hash of 4 bytes is taken so hashes of 1234 2345 3456 4567 need to be calculated . With other hash mechanisms to calculate a new hash the hash needs to be calculated using all n bytes for a rolling hash the hash is only dependent on the previous hash and the character dropping out and the character coming in which may lead to speed advantages over other techniques.

In some embodiments there is not one rolling hash but several it is the hashes of the powers of 2 a hash of the first 64 source bytes the hash of the first 128 source bytes a hash of the first 256 source bytes etc.

Since there is a certain minimum number of bytes a sequence of bytes should have in order to be worthwhile to single instance the hash of this minimum sequence length would be an additional hash.

It may have advantages if this minimum hash is itself a power of two say 32 bytes length 2 5 . Anything below this may not be single instanceable. Not all power of 2 hashes for a block will be stored. The minimum sequence hash is stored and is the first sort criteria. However the next power of two stored for a block could be determined by the logarithm of the amount of source bytes stored in the first half of the block though other optimizations could also be applied.

In some embodiments not all blocks are inserted into a search tree. If a code block fills less than half the amount of space it will get a storage location but may not be included into the search tree. This algorithm could be varied to or the whole or any other fraction without changing the invention.

In regards to the sort order in a tree Whether one code block is less than another can be determined using an example process illustrated in . The process begins at step where a code block is received. At step the minimum sequence length rolling hash of source bytes is compared to others in the search tree. If it is not found then the process continues to step where it is determined that the code block is not equal to other code blocks. If the minimum sequence length rolling hash is found the process continues to step . For overlapping power of 2 hashes in order of lowest power of 2 hashes a check for equality is made. If any is less or greater than the other then the process continues to step where it is determined that the code block is not equal to other code blocks. Otherwise the process continues to step . If all are equal or no overlapping power of 2 s found then base the decision on the length of the amount of source bytes. If they are also equal then the process continues to step where the blocks are considered equal. If they are not equal then the process continues to step where it is determined that the code block is not equal to other code blocks. The process then ends.

Slight variations such as taking into account other criteria such as the source length of the half way mark in the block etc are also possible.

Note that in the above there are greater degrees of being not equal. Two blocks can totally mismatch or they can match partially. The more power of 2 hashes that match the better the match even if they do not all match.

The following types of data should be stored on a physical data storage medium e.g. a computer readable storage medium 1 search tree skip list base pointer list 2 actual code blocks themselves 3 pseudo code block containing a link inside a code block and 4 skip list node block pointer to previous and next skip list node pointer to code block .

These different entities may be stored in various ways. What should be stored is what they contain and which code blocks refer to which other code blocks and not necessarily how the data inside each block is stored. Each or any of the above may be stored separately. The code block should contain a number of code bytes going up to a small set maximum.

A code byte can either be a literal byte or it can be a reference to another block. If it is a reference the following data should be stored also 1 block number large number as there can be a large number of blocks 2 offset inside block this is small will be a byte or less 3 number of code bytes followed inside block will be a byte or less 4 number of source bytes contained can be a large number and 5 rolling hash of source bytes followed usually 32 bits .

If for example 6 bytes are taken for the block number 6 bytes for the number of source bytes followed 4 bytes for the hash and a byte each for codebyte offset and number of code bytes followed in block then there are 18 bytes for the code byte meaning that the sequence followed should be longer than 18 bytes source bytes.

The literal code bytes would need to be at least a bit extra in length 9 vs. 8 bits in order to signify that they are in fact literals.

A pseudo block would contain the pointer to the other block an offset measured in code bytes an offset measured in source bytes and a differential rolling hash which with modulo exponentiation can be used to calculate the power of 2 hashes of the pseudo block using the linked to block s power of 2 hashes . Modular exponentiation is a type of exponentiation performed over a modulus.

The power of 2 hashes need not necessarily be stored only one differential. This makes it light weight to store pseudo blocks in the search tree.

At step for each byte it is looked up whether there exists an entry in the search tree matching the hash of the minimum sequence. At step it is determined whether a match is found in the data structure. If found then the comparison as mentioned earlier also features comparing the power of two hashes the one matching the most number of power of 2 hashes is evaluated first.

By evaluating what is meant is that matching code block is evaluated and expanded code byte by code byte and compared against the input stream. If the code byte is a reference then the complete reference should match.

In some embodiments the reference could be followed to a deeper level for example to a certain maximum level or to a maximum number of bytes. However in some embodiments it was chosen not to go partially into a reference either a reference has to hold and be equal exactly or the other choice is to use a code block until the previous code byte in the code block.

This is where the reference hash is used by using modulo exponentiation it is possible to reconstruct the hash of the code block up to the point directly after the reference and compare it to the rolling hash which was built while following the tree. Only if after a reference the hash still matches is the link followed recursively and validated that it actually matches.

Even if there is a hash collision on a higher level one level down is already usually the place where a hash of another link will no longer match.

The task of following the search tree can be split up into multiple threads where one thread starts looking up the input stream at location 0 the next thread at location 1 etc. If no match is found it can go forward to an unprocessed location. If a match ends after less than a certain number of source bytes for example 18 or more depending on various factors then the thread can abort and also start from the beginning at an unprocessed location.

For threads when they have a match greater than a certain amount of threshold source bytes could be larger than the minimum it could also reset the unprocessed location to that number so that any threads not finding a match can start from that location. While that may not yield the optimal match it may result in a match that is good enough.

If while going through a search tree there are multiple candidates to follow then it can be up to the implementation to decide whether the first tried path was good enough. If from the matching hashes it is expected that a candidate perhaps to a hash collision could be a better match than the one found then it can be tried again.

As soon as a path is determined to be sufficient all the block reference counters at this stage should be increased by one also the references that are used following this.

At step if no reference is found then the literal byte is added to the current block. The process then continues to step . At step if a reference is found then one is added to the reference count of the block being referenced.

At step it is determined if the bock is full. If not the process returns to step . Once the block is full at step the block is marked to be added to the search tree. The process then concludes.

If a block that is marked to be added to a search tree contains multiple references in a row and the total length of these references exceeds the block size of the incoming data then it should be checked if there is not a block existing which has all of the same references one option is to first search for a block having matching hashes .

In some embodiments the second level pass is performed as an optimization. If no replacement can be done on a block then it is finalized and written to the search tree. The candidates for a second level pass could be marked while scanning if it is found that a large number of the power of 2 s match but it is not yet possible to match the remaining bytes. In such a case the potential match could be added to a buffer in memory and later checked.

While processing the input buffer an LZW algorithm could be run on the data not so much for actual compression of the data but to find repetitions in the input stream. LZW is a lossless data compression algorithm.

Normally it is only possible to refer to the beginning of a code block however with this mechanism it is possible to link inside of a code block starting at for example the 15th code byte rather than the first.

For a current input stream it is known which blocks were created by the current input stream and so links inside those blocks can easily be constructed if it is determined that a link is useful enough it could also be added to a search tree as a pseudo block.

 Useful enough could be defined by saving a significant percentage of the input stream in that link. Note that the links themselves generally will not be referenced only what the links link to will be referenced by other code blocks.

The output will only be one reference to a block. All blocks that got added will be recorded in a separate block. If that block becomes full it will itself be added as a block and a new block will be started which contains that block. One objective is that for each file stored that there is one block. If a block is not full it will only be stored but not linked to in the search tree.

Take the following string Present your card with every order and receive promotional discounts. An idea is to build a search tree and store the single instanceable data inside the search tree.

For sake of clarity to describe the algorithm only blocks of 8 code words will be used. In some embodiments blocks of 64 128 256 bytes or perhaps even higher may be used.

Given the string above the following code blocks are generated. The top value 01 02 is just some file offset. The value sp means space character. Given an empty tree there is not much that can be referenced so the first few blocks look like the following 

All these are added to the search tree sorted by the first four characters and then the power of 2 hashes and the length . The next block is able to make a reference if the LZW extension described above is used. This is possible because blocks 1 10 17 and 25 come from this instance for which an LZW table has been created.

The next block 33 would look something like blocks are named in this example after their storage location in this example it could have been just as easy to use B1 B2 B3 B4 etc. 

These references could be added to the search tree also by themselves. Certain criteria should be met especially having been used in the past and perhaps having been used a certain number of times or leading to a certain amount of data or rank these the used links by a points system and for every file added add the top x.

So block 41 will be B17 1 no length just the start offset block 42 will be B02 1 block 43 would be B25 1 .

Now an unfortunate case for block level single instancing would be if this string Present your card with every order and receive promotional discounts. was changed to resent your card with every order and receive promotional discounts. In other words the first letter was deleted.

Here for the first character there is already a link already going to B02 1 . So it is written B02 1 7 7 characters followed by the complete blocks B10 B17 B25 But even if this did not exist B10 B17 B25 would have been used in any case. The seven characters would have needed to be written into a new block before the first reference.

Each file links to one block. Each block has a half way marker and a value saying how many source bytes are left of the middle. Using this and since blocks are short and each reference contains the amount of source bytes in the reference it is trivial to follow exactly the right references to get to the exact offset that the user wants to and it is done in O log n . The reference stack would need to be saved in memory while the file handle to read from that location is active. Even without the halfway marker the order of time would still be O log n for the seek but it would take twice as long as without the halfway marker as twice as much data would need to be read to determine in which reference the location desired to be sought to is contained in.

In some embodiments the design may perform optimally if files are written and then not modified again however it does still work though if files are modified however some blocks a logarithmic amount of the file may need to be rewritten.

Say the g is to be changed to something else say i. If B9 has only one reference then it is easy as B12 must be the only one using it. Just replace it however the block needs to get a new block sequence number. If it is referenced by others then B9 s reference count should be reduced by 1. Then if fih is looked up to see if it has a reference if it does it is noted else fih is added as a block and use that in the following step x . Then the stack is went up to B10 it is checked to see if that has other references if so the recount is reduced and d e B x is added as block y else it is changed and a new sequence number is assigned and the process is completed. And so on. Changing 1 block could lead to around log n other blocks also having to change. In some embodiments one rule that should be kept when performing the above operations is that one block can only reference another block if the sequence number of the referenced block is lower.

Each block has a reference count and a sequence number which only goes up never down. The sequence number ensures that there will be no circular dependencies. A block should only reference a block with a lower sequence number. When a file is deleted blocks need to be traversed decreasing the reference count recursively. In some embodiments the sequence number may go down.

However this may be difficult to do in real time so an implementation could do this offline or periodically rather than doing it right away. Even if a new file references blocks which had actually reached a reference count of 0 but are still 1 in the tree it would just add 1 when the periodic check does get to the block and reduces it by whatever amount there will still be one left.

So what happens is that when a file is removed only the blocks of the file block the block which is directly linked to refer to the file are added to a sorted list of blocks to reduce the reference count of and only that one block is reduced by 1 meaning that in most cases the reference count will become 0. If any of them are already in the list the reduce count is just increased by 1.

When this offline space recoverer is implemented whenever a new block references a block instead of directly increasing the count it would have to check against this table and instead decrease the reduce count.

One implementation of the algorithm could be that the order in which this algorithm processes the blocks to reduce the reference count of could do it in order of sequence number. If there is a low water mark reached of items in the list then the ones with the highest sequence numbers are processed until the watermark is reached at which point all the entries with the lowest sequence numbers are processed. This can be done continuously when a writer thread is idle.

When the reference count of a block has reached 0 then the storage space of the block can be reused. It is up to the implementation how to deal with management of free space. For example one could have a number of n free block linked lists and a random one of these n is chosen to add the free block to. The list could include block ranges.

If multiple writers are allowed to write to the single instanced storage at the same time then locking should be done in a way so that the tree is only minimally affected. In fact locking should be such that reading from the tree should be able to continue happening while updating for example the reference count or adding new items.

The way locking is performed may not affect materially the described concepts as locking is only one aspect of the entire picture.

However a method to lock would be to have a fixed number of writers at any one given moment which can than be extracted out into any number of writers which queue their data until a writer becomes available.

If there is only one writer writing to the single instance store then no locking mechanism is needed however it has obvious advantages when multiple writers are allowed.

There are several types of locks. For example Group 1 reference counter locks which include a read lock which still allows increasing of the reference counters by others but no decreases and a reference count change lock which allows other writers to still read the actual data block but not the reference count. If determined that the block is usable the writer needs to wait for the lock to clear.

There are also Group 2 pointer locks which include an item pointer insert lock put in place when a next previous pointer needs to be updated. For most use cases the tree can still be scanned while this is going on just not other items inserted in the same place while the lock is in place and an item pointer delete lock put in place when a next previous pointer needs to be updated because an element pointing to it will be deleted. If such a lock is in place the writer needs to wait until the lock is released in order to go to the next previous item.

There are also Group 3 block level locks which include a block lock this is used to change an unused block into a used block. If this lock is detected another block should be chosen by the writer to write the new data. These types of locks can be stored in memory or with the actual data.

One alternative is to do the following Use macro blocks 128 KB or other large block sizes but each macro block would be chopped up into small 2 kb micro blocks. These microblocks could have their hashes calculated in a rolling hash format as well as a strong hash such as SHA1 or MD5. These strong hashes could be put into a search tree sorted by the weaker rolling hashes. If there is a match calculate the strong hash compare it against the one in the tree and then single instance using the microblock in case of a match. If for a certain minimum amount of data there is no hash match that becomes a new block. One possible requirement of this approach is that all 2048 bytes or however big the block size is need to match. Partial block matches are not possible.

One other possible requirement of this approach is that every single byte needs to do a lookup in the search tree. In the primary approach described herein it is similar to following a triep data structure the next byte to compare against is known and only if it does not match is it necessary to start searching in the tree again and not necessarily from the root of the tree.

In the primary approach described herein if a 1 GB file were to come up again it would only need to reference 1 block though this block would also increase the reference count of all blocks it refers to but this would be done while scanning the search tree . In the primary approach described herein the matching blocks would be found quite quickly as blocks will be found matching all hashes exactly.

This concepts described herein depend on being quickly able to scan a search tree. It is possible for there to be improvements in this area.

Storage is growing exponentially being able to reduce the storage required by both compression and single instancing at the same time is extremely valuable and saves money.

Any companies needing to store large amounts of data almost certainly store duplicates. The concepts described herein could be used by an operating system manufacturer creating a single instanced file system or by a backup to disk vendor. They could also be employed by database companies and search companies which need to store a lot of data which could repeat itself to minimize storage.

A memory only implementation of this is very viable and may work very well for storing texts emails especially when there is a whole email thread the memory used for the whole thread using this method should only be only slightly larger than the last email in the thread .

The media agent includes various components that perform various functions. These components include a data object identification component an identifier generation component an identifier comparison component and a criteria evaluation component . The file identification component identifies files or data objects such as in response to a storage operation. The identifier generation component generates a substantially unique identifier for the file or data object substantially unique identifiers are discussed in more detail below . The identifier comparison component performs comparisons of substantially unique identifiers of various files or data objects to determine if the files or data objects contain similar data for example the identifier comparison component can compare substantially unique identifiers of two or more files or data objects to determine if the files or data objects contain the same data metadata such as access control lists ACLs of the two or more files or data objects may differ. The criteria evaluation component evaluates aspects of files or data object against a set of criteria. The media agent may also contain other components that perform other functions.

The clients as part of their functioning utilize data which includes files directories metadata e.g. ACLs and any other streams associated with the data and other data objects. More details as to the storage operations involving ACLs may be found in the assignee s U.S. patent application Ser. No. 12 058 518 entitled SYSTEM AND METHOD FOR STORAGE OPERATION ACCESS SECURITY the entirety of which is incorporated by reference herein. The data on the clients is a primary copy e.g. a production copy . During a copy backup archive or other storage operation the clients send a copy of each data object in the data to the media agent . The media agent generates a substantially unique identifier for example a hash value message digest checksum digital fingerprint digital signature or other sequence of bytes that substantially uniquely identifies the file or data object for each data object. The word substantially is used to modify the term unique identifier because algorithms used to produce hash values may result in collisions where two different files or data objects result in the same hash value. However depending upon the algorithm or cryptographic hash function used collisions should be suitably rare and thus the identifier generated for a file or data object should be unique throughout the system.

After generating the substantially unique identifier for a data object the media agent determines whether it should be stored on the storage device . The storage device stores a secondary copy e.g. a backup copy of the data of the clients . To determine this the media agent accesses the single instance database to check if a copy or instance of the data object has already been stored on the storage device . The single instance database utilizes one or more tables or other data structures to store the substantially unique identifiers of the data objects that have already been stored on the storage device . If a copy or instance of the data object has not already been stored on the storage device the media agent sends the copy of the data object to the storage device for storage and adds its substantially unique identifier to the single instance database . If a copy or instance of the data object has already been stored the media agent can avoid sending another copy to the storage device . In this case the media agent may add a reference e.g. to an index in the single instance database such as by incrementing a reference count in the index to the already stored instance of the data object. As explained below adding a reference to the already stored instance of the data object enables storing only a single instance of the data object while still keeping track of other instances of the data object that do not need to be stored.

Instead of the clients sending the data objects to the media agent and the media agent generating the substantially unique identifiers the clients can themselves generate a substantially unique identifier for each data object and transmit the substantially unique identifiers to the media agent for lookup in the single instance database . If the media agent determines that an instance of a data object has not already been stored on the storage device the media agent can instruct the client to send it a copy of the data object which it then stores on the storage device . Alternatively the client itself can send the copy of the data object to the storage device . More details as to the generation of the substantially unique identifiers may be found in the assignee s U.S. patent application Ser. No. 12 058 367 entitled SYSTEM AND METHOD FOR STORING REDUNDANT INFORMATION the entirety of which is incorporated by reference herein.

The media agent can support encrypted data objects. For example one client could generate a substantially unique identifier for a data object and then encrypt it using one encryption algorithm. Another client could generate a substantially unique identifier for another data object and then encrypt it using another encryption algorithm. If the two data objects are identical meaning the two objects have the same data while their metadata such as ACLs or descriptors could be different they will both have the same substantially unique identifier. The media agent can then store both encrypted instances of the data object or only a single encrypted instance. The media agent can also support compressed data objects. In general the same compression algorithm may be used to compress data objects. Therefore the media agent can generate a substantially unique identifier for a data object before or after it has been compressed. More details as to how the media agent can support encryption and compression in a single instancing system may be found in the assignee s U.S. patent application Ser. No. 12 145 342 entitled APPLICATION AWARE AND REMOTE SINGLE INSTANCE DATA MANAGEMENT the entirety of which is incorporated by reference herein.

The above system may be incorporated within a data storage system and may be subjected to a data stream during a data copy operation. Referring to a block diagram illustrating components of a data stream utilized by a suitable data storage and recovery system is shown. The data stream may include client a media agent and a storage device such as a hard disk drive an optical disk drive a tape library and or a virtual tape library VTL etc. For example in storage operations the system may store receive and or prepare data to be stored copied or backed up at a server or client. The system may then transfer the data to be stored to media agent which may then refer to storage policies schedule policies and retention policies and other policies to choose a storage device . The media agent may include or be associated with an intermediate component to be discussed herein.

The storage device receives the data from the media agent and stores the data as a secondary copy such as a backup copy. Storage devices may include magnetic tapes optical disks USB and other similar media disk and tape drives and so on. Of course the system may employ other configurations of data stream components not shown in .

Referring to a block diagram illustrating an example of a data storage and recovery system is shown. Data storage systems may contain some or all of the following components depending on the needs of the system. and the discussion herein provide a brief general description of a suitable computing environment in which the system can be implemented.

For example the data storage system contains a storage manager one or more clients one or more media agents and one or more storage devices . Storage manager controls media agents which may be responsible for transferring data to storage devices. Storage manager includes a jobs agent a management agent a database and or an interface module . Storage manager communicates with client s . One or more clients may access data that is stored by the system from database via a data agent . The system uses media agents which contain databases to transfer and store data into storage devices. Client databases may contain data files and other information while media agent databases may contain indices and other data structures that assist and implement the storage of data in storage devices for example.

The data storage and recovery system may include software and or hardware components and modules used in data storage operations. The components may be storage resources that function to copy data during storage operations. The components may perform other storage operations or storage management operations other that operations used in data stores. For example some resources may create store retrieve and or migrate primary or secondary data copies. Additionally some resources may create indices and other tables relied upon by the data storage system and other data recovery systems. The secondary copies may include snapshot copies and associated indices but may also include other backup copies such as Hierarchical Storage Management HSM copies archive copies and so on. The resources may also perform storage management functions that may communicate information to higher level components such as global management resources.

In some examples the system performs storage operations based on storage policies as mentioned above. For example a storage policy includes a set of preferences or other criteria to be considered during storage operations. The storage policy may determine or define a storage location and or set of preferences about how the system transfers data to the location and what processes the system performs on the data before during or after the data transfer. In some cases a storage policy may define a logical bucket in which to transfer store or copy data from a source to a data store such as storage media. Storage policies may be stored in storage manager or may be stored in other resources such as a global manager a media agent and so on. Further details regarding storage management and resources for storage management will now be discussed.

Referring to a block diagram illustrating an example of components of a server or system used in data storage operations is shown. A server such as storage manager may communicate with clients to determine data to be copied to storage media. As described above the storage manager may contain a jobs agent a management agent a database an interface module and or other agents . Jobs agent may manage and control the scheduling of jobs such as copying data files from clients to media agents not shown . Management agent may control the overall functionality and processes of the data storage system or may communicate with global managers. Database or another data structure may store storage policies schedule policies retention policies or other information such as historical storage statistics storage trend statistics and so on. Interface module may interact with a user interface enabling the system to present information to administrators and receive feedback or other input from the administrators or with other components of the system such as via Application Programming Interfaces APIs .

From the foregoing it will be appreciated that specific examples of techniques for single instancing may have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. As an example although certain types of data storage operations may have been described the system may be used to perform many types of storage operations e.g. copy operations backup operations restore operations archival operations copy operations continuous data replication CDR operations recovery operations migration operations HSM operations etc. . As another example although it is described that for each byte in an input stream it is looked up whether there exists an entry in the search tree matching the hash of the minimum sequence this lookup may be performed for not every byte in the input stream.

More details as to single instancing may be found in one or more of the following commonly assigned U.S. patent applications 1 U.S. Pat. App. No. 61 180 791 entitled BLOCK LEVEL SINGLE INSTANCING U.S. patent application Ser. No. 12 145 347 entitled APPLICATION AWARE AND REMOTE SINGLE INSTANCE DATA MANAGEMENT or 3 U.S. patent application Ser. No. 12 145 342 entitled APPLICATION AWARE AND REMOTE SINGLE INSTANCE DATA MANAGEMENT 4 U.S. patent application Ser. No. 11 963 623 entitled SYSTEM AND METHOD FOR STORING REDUNDANT INFORMATION 5 U.S. patent application Ser. No. 11 950 376 entitled SYSTEMS AND METHODS FOR CREATING COPIES OF DATA SUCH AS ARCHIVE COPIES or 6 U.S. Pat App. No. 61 100 686 entitled SYSTEMS AND METHODS FOR MANAGING SINGLE INSTANCING DATA each of which is incorporated by reference herein in its entirety. Variable instancing generally refers to storing in secondary storage one or more instances but fewer than the total number of instances of each data block or data object in a set of data e.g. primary data . More details as to variable instancing may be found in the commonly assigned U.S. Pat. App. No. 61 164 803 entitled STORING A VARIABLE NUMBER OF INSTANCES OF DATA OBJECTS.

Unless the context clearly requires otherwise throughout the description and the claims the words comprise comprising and the like are to be construed in an inclusive sense as opposed to an exclusive or exhaustive sense that is to say in the sense of including but not limited to. As used herein the terms connected coupled or any variant thereof means any connection or coupling either direct or indirect between two or more elements the coupling or connection between the elements can be physical logical or a combination thereof. Additionally the words herein above below and words of similar import when used in this application refer to this application as a whole and not to any particular portions of this application. Where the context permits words in the above Detailed Description using the singular or plural number may also include the plural or singular number respectively. The word or in reference to a list of two or more items covers all of the following interpretations of the word any of the items in the list all of the items in the list and any combination of the items in the list.

The above Detailed Description of examples of the invention is not intended to be exhaustive or to limit the invention to the precise form disclosed above. While specific examples for the invention are described above for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. For example while processes or blocks are presented in a given order alternative implementations may perform routines having steps or employ systems having blocks in a different order and some processes or blocks may be deleted moved added subdivided combined and or modified to provide alternative or subcombinations. Each of these processes or blocks may be implemented in a variety of different ways. Also while processes or blocks are at times shown as being performed in series these processes or blocks may instead be performed or implemented in parallel or may be performed at different times. Further any specific numbers noted herein are only examples alternative implementations may employ differing values or ranges.

The teachings of the invention provided herein can be applied to other systems not necessarily the system described above. The elements and acts of the various examples described above can be combined to provide further implementations of the invention.

Any patents and applications and other references noted above including any that may be listed in accompanying filing papers are incorporated herein by reference. Aspects of the invention can be modified if necessary to employ the systems functions and concepts of the various references described above to provide yet further implementations of the invention.

These and other changes can be made to the invention in light of the above Detailed Description. While the above description details certain embodiments of the invention and describes the best mode contemplated no matter how detailed the above appears in text the invention can be practiced in many ways. Details of the system may vary considerably in implementation details while still being encompassed by the invention disclosed herein. As noted above particular terminology used when describing certain features or aspects of the invention should not be taken to imply that the terminology is being redefined herein to be restricted to any specific characteristics features or aspects of the invention with which that terminology is associated. In general the terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification unless the above Detailed Description section explicitly defines such terms. Accordingly the actual scope of the invention encompasses not only the disclosed embodiments but also all equivalent ways of practicing or implementing the invention under the claims.

While certain aspects of the invention are presented below in certain claim forms the applicant contemplates the various aspects of the invention in any number of claim forms. For example if one aspect of the invention is recited as a means plus function claim under 35 U.S.C 112 sixth paragraph other aspects may likewise be embodied as a means plus function claim or in other forms such as being embodied in a computer readable medium. Any claims intended to be treated under 35 U.S.C. 112 6 will begin with the words means for but use of the term for in any other context is not intended to invoke treatment under 35 U.S.C. 112 6. Accordingly the applicant reserves the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the invention.

From the foregoing it will be appreciated that specific embodiments of the invention have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims.

