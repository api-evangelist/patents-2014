---

title: Systems and/or methods for policy-based access to data in memory tiers
abstract: Certain example embodiments provide efficient policy-based access to data stored in memory tiers, including volatile local in-process (L1) cache memory of an application and at least one managed (e.g., non-volatile) in-memory (L2) cache. Operations include receiving an access request for access to a data element in L2; detecting whether a copy of the data element is in L1; if so, copying the data element and the access policy from L2 to L1 and providing the user with access to the copy of data element from L1 if the access policy allows access to the user; and if not, determining, by referring to a copy of the access policy stored in L1, whether the user is allowed to access the data element, and, if the user is allowed to access the data element, providing the user with access to the copy of the data element from the L1 cache memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465752&OS=09465752&RS=09465752
owner: Software AG USA, Inc.
number: 09465752
owner_city: Reston
owner_country: US
publication_date: 20141212
---
Certain example embodiments described herein relate to techniques for computer software processing. More particularly certain example embodiments relate to techniques for providing efficient policy based access to data stored in tiered memory structures.

In memory data platforms such as IMDGs In Memory Data Grids can serve as an operational store for applications that require low latency access to data at scale. Many in memory data platforms store large datasets and include a cluster of servers forming a grid.

Many applications leveraging such in memory data platforms store manage and analyze security sensitive data and it would be desirable to protect such data from unauthorized user and system access for example. Access control oftentimes is based on authenticated user credentials. Sometimes it is desired that contextual information associated to the caller e.g. user or device requesting access to the data is also used in making the access control determination.

Currently available in memory data platforms typically access an external server to look up authorization information for users requesting access to data stored in the in memory data platform. Thus additional latency typically is incurred when policy based authenticated access is required. It will be appreciated that it would be desirable to optimize the speed at which data in in memory data platforms is accessed e.g. by reducing the time associated with looking up such access policies.

In order to improve the speed of access to data stored in tiered memory such as in in memory data platforms certain example embodiments described herein provide a highly optimized approach to authorizing and protecting in memory data based on a requestor s role and contextual information. Certain example embodiments help optimize or otherwise improve role based access control without compromising the predictable and generally low latency provided by in memory based data access by bringing the access policies closer to the requestor process space.

In certain example embodiments there is provided a system for providing controlled access to data stored in a plurality of memory tiers including a volatile local in process L1 cache memory of an application executing on a first computing device and at least one managed e.g. non volatile in memory L2 cache on a second computing device distributed over a plurality of computing devices. The system includes one or more communication interfaces. A processing system includes at least one processor with the processing system being configured to control the system to access the L1 cache memory and to access the at least one L2 cache via the one or more communication interfaces and to perform operations comprising receiving an access request via the one or more communication interfaces requesting access for a user to a data element in the memory tiers wherein the L2 cache has stored therein the data element and an access policy detecting whether a copy of the data element is in the L1 cache memory in response to a detection that a copy of the data element is not in the L1 cache memory copying the data element and the access policy from the L2 cache to the L1 cache memory and providing the user with access to the copy of data element from the L1 cache memory if the access policy allows access to the user and in response to a detection that a copy of the data element is in the L1 cache memory determining by referring to a copy of the access policy stored in the L1 cache memory whether the user is allowed to access the data element and in response to a determination that the user is allowed to access the data element providing the user with access to the copy of the data element from the L1 cache memory.

In certain example embodiments a method for providing controlled access to data stored in a plurality of memory tiers distributed over a plurality of computing devices is provided. The tiers include a volatile local in process L1 cache memory of an application executing on a first computing device and at least one managed e.g. non volatile in memory L2 cache on a second computing device. An access request that requests access for a user to a data element in the memory tiers is received via one or more communication interfaces of the first computing device. The L2 cache has stored therein the data element and an access policy. A detection is made as to whether a copy of the data element is in the L1 cache memory. In response to a detection that a copy of the data element is not in the L1 cache memory the data element and the access policy is copied from the L2 cache to the L1 cache memory and the user is provided with access to the copy of data element from the L1 cache memory if the access policy allows access to the user. In response to a detection that a copy of the data element is in the L1 cache memory a determination is made by referring to a copy of the access policy stored in the L1 cache memory as to whether the user is allowed to access the data element and in response to a determination that the user is allowed to access the data element the user is provided with access to the copy of the data element from the L1 cache memory.

In certain example embodiments there is provided a non transitory computer readable storage medium having stored thereon instructions that when executed by a processor of a first computing device causes the first computing device to provide controlled access to data stored in a plurality of memory tiers including a volatile local in process L1 cache memory of an application executing on the first computing device and at least one managed e.g. non volatile in memory L2 cache on a second computing device. The instructions involve operations comprising receiving an access request via one or more communication interfaces of the first computing device requesting access for a user to a data element in the memory tiers wherein the L2 cache has stored therein the data element and an access policy detecting whether a copy of the data element is in the L1 cache memory in response to a detection that a copy of the data element is not in the L1 cache memory copying the data element and the access policy from the L2 cache to the L1 cache memory and providing the user with access to the copy of data element from the L1 cache memory if the access policy allows access to the user and in response to a detection that a copy of the data element is in the L1 cache memory determining by referring to a copy of the access policy stored in the L1 cache memory whether the user is allowed to access the data element and in response to a determination that the user is allowed to access the data element providing the user with access to the copy of the data element from the L1 cache memory.

According to certain example embodiments the at least one managed in memory L2 cache may be non volatile.

According to certain example embodiments the access policy may specify at least an entity or at least one type of entity for whom access to the data element is allowed and the determining may determine that the user is allowed to access the data element based upon evaluating the user as corresponding to the at least one entity or the at least one type of entity.

According to certain example embodiments the determining may comprise detecting one or more additional parameters associated with the access request the additional parameters being different from a unique identifier for the user and performing the determining based upon the one or more additional parameters and the unique identifier. For instance the one or more additional parameters may include at least one of device information associated with the user and a location of the user.

According to certain example embodiments in response to a detection that a copy of the data element is in the L1 cache memory the determining may include applying the access policy to at least one contextual parameter not expressly included in a payload of the access request.

According to certain example embodiments copying the data element may include storing the copy of the data element in the L1 cache memory in association with a corresponding key and the access policy.

According to certain example embodiments the corresponding key and a combination of the copy of the data element and the access policy may be stored in the L1 cache memory as a key value pair.

According to certain example embodiments the determining may include referring to the access policy specifically associated with the copy of the data element in the L1 cache memory and copies of other data elements in the L1 cache memory each may be associated with respective other access policies.

According to certain example embodiments an in memory data grid IMDG may be overlaid in the memory tiers and the IMDG may comprise the L1 cache memory and the L2 cache.

According to certain example embodiments the operations may further comprise updating a copy of the access policy in the L1 cache memory and after updating the copy of the access policy in the L1 cache memory causing a second processing system to update the access policy in the at least one L2 cache.

According to certain example embodiments the determining may refer to the copy of the access policy in the L1 cache memory without referencing the access policy in the at least one L2 cache.

According to certain example embodiments a second processing system including at least one processor may be provided with the second processing system being configured to control the at least one second computing device and to perform operations comprising receiving a request to update the data element and or the access policy causing at least the first processing system to lock the copy of the data element in the L1 cache memory updating the data element and or the access policy in the at least one L2 cache and synchronizing the data element and the access policy throughout the system.

These aspects features and example embodiments may be used separately and or applied in various combinations to achieve yet further embodiments of this invention.

As described above providing authenticated access to data stored in tiered memory structures such as in memory data platforms may involve looking up access policies associated with the data. In some conventional approaches accessing data in tiered memory structures such as in an IMDG incurs additional delays for looking up the associated access policies at a server that is external to the IMDG. Certain example embodiments described herein provide for eliminating or reducing the delay associated with authorized access to data stored in tiered memory data platforms such as but not limited to in memory data grids IMDGs .

Certain example embodiments optimize or otherwise improve access control for data stored in tiered memory data platforms by providing among other things a tiered storage of access policies. Certain example embodiments in line access policies so that they are primarily resident in memory for example by placing the access policies close to the user in the same address space as the application in order to achieve secure data access without sacrificing latency. The in lining of access policies in certain embodiments accounts for keeping the latency low and possibly even to a minimum and not having to incur the cost of looking up a policy from another repository. Consequently certain example embodiments by in lining access policies with the data provide faster authenticated access to data than conventional techniques that point to an external store where such access policies are persisted and referenced at runtime.

Certain example embodiments store the data in a key value pair store in tiered memory where lookups are highly efficient and provide a mechanism of faulting data when required from one tier to another. Certain example embodiments also may provide a capability to have a persistent store used for backup and restore. In addition certain example embodiments provide for leveraging rich contextual information regarding the user and or the user device in the access control determination. Contextual information may be highly relevant in the area of real time applications for example where tiered memory data platforms oftentimes are used.

According to certain example embodiments the access policies are in lined with data by placing them in the in process memory of the application. Consequently access to the in lined policies is independent of the operating system and is optimized or otherwise improved in ways pertinent to memory tier data platform behavior where predictable latency at any data scale is desirable.

In the schematic representation of the IMDG in a plurality of application servers are connected via a communication infrastructure to a plurality of storage nodes . Each application server and each storage node includes a processing system including at least one processor and memory and is configured to execute program code and to communicate with one or more other devices and or processes over the communication infrastructure. One or more storage nodes may also include disk or other persistent memory for storing programs and or data.

Each application server includes an L1 tier memory . Each storage node includes an L2 tier memory . Each storage node may also include a disk as backup for the L2 tier memory . In certain example embodiments each storage node may include a mirror which duplicates the corresponding L2 tier and disk if present .

In the illustrated IMDG the application servers may be physically separate from the storage nodes and the communication infrastructure may provide for communicating over a network such as a wide area network local area network or other high speed communication medium. In certain example embodiments the IMDG may be overlaid on a storage area network or server farm. These group of application servers and storage nodes that form an IMDG is sometimes referred to herein as a cluster.

A concept of the optimized or improved approach of certain example embodiments for access control to the data stored in an IMDG involves introducing an access policy in line with the stored data e.g. as opposed to having the access policy check performed using an external security repository. An access policy in this sense may among other things dictate which security roles have access to the data element. Such an access policy can be implemented as a data structure or a corresponding representation e.g. a file that is looked up in order to make a determination as to whether a user should be allowed access to certain data.

According to certain example embodiments policy enforcement is performed at the L1 tier which is in process of the client application. Because of the nature of certain tiered data storage e.g. in which the most used data will end up in L1 tier in lining of access policy will yield highly optimized or improved performance For example as illustrated in in an IMDG comprised of a set of interconnected nodes where a majority of the nodes with applications are equipped with the L1 tier and some nodes are equipped with the L2 tier L2 tier the majority of access decisions may be made using the L1 tier e.g. L1 memory because of the collocation of data and corresponding policies in the nodes in which the applications execute. In certain example embodiments the L2 tier is accessed only when a data item cannot be found in the L1 tier.

As illustrated each data element may be associated with a respective access policy. In the illustrated embodiment the access policy for a particular data element is in lines with the data by embedded in the corresponding key value pair such that when the key for the particular data element is accessed in the L1 tier the particular data element together with the embedded policy is obtained. When the key value pairs are stored in the L1 tier in in process memory of an application the access policy corresponding to the key value pair is obtained without a separate lookup in an external server.

The access policy may specify a combination of one or more roles e.g. a role assigned to a user and or a named user. In certain example embodiments in addition to simple user roles a set of well defined attributes that can be present in the request headers may also be part of the access policy. It will be appreciated however that the approach described herein is not limited to a particular type of access policy.

According to certain example embodiments an access engine is a runtime component for processing incoming request to the IMDG that among other things 1 returns a value for the given key element and 2 throws a predetermined exception e.g. an AccessViolationException described below when the requestor is not allowed the requested action according to the access policy.

Once configured the system will enforce the access policy on a data access request. For example when a request is received for the value of key key and key is found in the L1 tier a determination is made by reviewing the access policy embedded in element a which is associated with key. The access policy may list the user roles that are allowed access or alternatively be defined as a set of roles and actions allowed by those roles. So a SalesManager read update SalesRep read may indicate that a user who is in Sales Manager role can read and update the value of key but others cannot. In certain example embodiments the access engine determining the access control can be configured to return a decision based on a default policy scheme as well.

In addition to in lining the access policies with the data in the L1 tier certain example embodiments provide for parametric authorization using contextual information that may include attributes such as request headers e.g. header attributes that specify callers device information location coordinates etc. .

When an application executing on the application server requests access to a data element in the IMDG an access engine is invoked. The access engine may be configured in accordance with a configuration file which includes a default access policy. The access engine provides for first attempting to access the sought data element in the L1 tier and if it is not found in the L1 tier looking it up in the L2 tier .

Activity diagram illustrates the event flow between application access engine a default access policy and IMDG . Application may correspond to application access engine may correspond to access engine default policy may correspond may be included in configuration and IMDG may include L1 tier and L2 tier .

In order to access a data element with key kl at operation application transmits to the access engine a request to read key k. The request may be generated using any technique such as for example an application programming interface API call an inter process message etc. At operation upon receiving the request the access engine may be invoked e.g. if not already invoked and the default access policy may be read. The default access policy specifies access controls that should be applied to the requests if the particular data elements do not have their own access policies. The default access policy may specify for example if a non existence of policy constitutes a grant or a deny or whether all accesses to the data in the IMDG by any user other than an administrator are denied. However it will be appreciated that example embodiments are not limited to particular types of default access policies.

At operation the access engine obtains the access policy tied to the key from IMDG . This may include accessing only the L1 tier or first accessing the L1 tier and if the key k if not found in the L1 tier accessing the L2 tier . After reading the obtained access policy a determination is made if the request includes a user context that maps to a role present in the access policy. Thus because the system first seeks to find the key k in L1 and only thereafter seeks the key k in L2 the access decision or access policy enforcement may be considered as being made at L2 rather than at L1. In certain example embodiments if the access is denied based upon the access policy the data will not be faulted to the L1 tier as it is typically done when access is granted.

Alternatively based upon whether the key k is found and based upon the obtained access policy the access engine returns the data associated with key k or an indicator that an access violation occurred e.g. return an exception such as AccessViolationException indicating that there has been an access violation . In case the data requested is not present the access engine may be configured to generate an AccessViolationException to inform the user that the data being requested is not available. This behavior is configurable via a default access policy available to the access engine. As noted above the default access policy can be used to globally define the default access policy with respect to all data elements in the IMDG.

According to an example embodiment the default access policy can have a policy such as AuthenticatedRole read indicating to the access engine that all authenticated users can read any data from the IMDG.

The AccessViolationException exception which the access manager may be configured to raise as described above is an example of an exception that informs the client e.g. the entity executing the request for access that there has been violation and access has not been granted. A sample API may include for example public final Element get Object key throws IllegalStateException CacheException AccessViolationException.

Another benefit of performing policy enforcement at the L1 tier which at least in certain example embodiments is in process of the application is that it provides the capability for the access control technique to leverage contextual information related to the request. Request attributes may include contextual information that can be part of the policy decision. For example a request may consist of or comprise location and or device information that can be utilized as information in addition to the user identification and or roles to enforce access to given information within the IMDG.

The access policy can be extended to have such contextual information. According to an example embodiment the access policy defines contextual attributes such as the originating location the originating device and or the originating browser type e.g. request.location request.device request.browser type respectively etc. for the request. The policy enforcement point when it is at the L1 tier e.g. in in process memory of the application typically has access to this context information and can introspect the values in the current request and pass the relevant values of such contextual attributes to the access engine. The access engine can then review the access policy and make a determination based on the available context information in addition to the user information.

The use of contextual information according to an embodiment is illustrated in . is an example illustration when contextual information available to the access engine regarding the request is used in order to restrict access to sensitive data in an IMDG depending for example on whether a user logs in remotely via standard browser on a laptop or via a mobile device.

As illustrated in the figure a user via a mobile phone accesses the web application . The web application accesses an IMDG which includes the L1 tier and L2 tier for data. Based upon the request from the mobile telephone the web application requests the IMDG for access to key key.

The access engine upon receiving the request to access key key may read the default access policy . If the default access policy authorizes the user to access data in the IMDG the access engine attempts to find key in the IMDG.

According to this example key is found in the L1 tier by the access engine . The access engine then reviews the access policy associated with the key. For example key is identified in the L1 tier and the associated element c is obtained also from the L1 tier. In certain example embodiments the element c in the L1 tier has the access policy access policy c embedded in it. The embedding of the access policy in the data element may be configured such that when the application accesses the value associated with key in L1 the application is provided with access to the access policy.

In the illustrated example three key value pairs e.g. and are shown to be stored in the L1 tier . Each of the elements element a element b and element c may have embedded in it a respective access policy. Arrangement illustrates the key value pairs currently residing in the L1 tier and a more detailed illustration of the value part of each key value. As shown in the L1 tier element a includes a data value for element a and an access policy a pertaining to the data value for element a element c includes a data value for element c and an access policy a pertaining to the data value for element c and element b has no access policy currently associated with it.

The access policy may include a rule predicated on client type e.g. the type of device or user agent making the request making the request. Because the access engine is running in the same context as the L1 tier which includes access policy c it can retrieve relevant information from the request. For example the device type can be obtained from the servlet container e.g. httpServletRequest.getHeader user agent where the user agent is obtained from information in the request.

Once a determination is made that the user agent pertains to a mobile device access to key may or may not be allowed based upon contextual requirements if any in the access policy. For example if access policy c only authorizes users that are in a manager role and who are not making the access request from a device other than a mobile device e.g. a rule such as Manager Request.client mobile the access manager would deny the request made by the user from the mobile device .

On the other hand if the same user transmits the request for key using a laptop computer access to key will be allowed for the user. illustrates an example access policy included in access policy c.

According to certain example embodiments the management of access policies that determine access to data may be performed using standard APIs. The administration of the policies may also be provided using a user interface that provides administrators an ability to manage policies using the standard APIs. Certain example embodiments include an access policy manager that provides a set of APIs that provide for the management of access policies. Example operations may include adding a new access policy to a given key updating an existing access policy etc.

According to certain example embodiments the access policy for a data element is implemented as an access policy object that is associated with the key for the data element. The key used in the access policy object is the same identifier to the data element used in the IMDG. The access policy object e.g. when implemented in Java may include following instance variables 

At operation the administrator requests to update policy for key k . Upon receiving the request the admin UI at operation may check the administrator s credentials and invoke access manager APIs to get the associated access policy for key k .

Upon invocation or receiving a request from the admin UI for the access policy the access policy API at operation reads the access policy object from the IMDG .

At operation the access policy API returns an access policy object corresponding to the requested key k. At operation the admin UI and or access policy manager API may visually list all predicates and may also present the administrator with user role objects e.g. representing all possible roles that can be assigned from an identity store not separately shown .

At operation the administrator selects a new user role predicate supervisor role and selects save on the admin UI .

At operation the access policy manager API initiates adding the new user role predicate supervisor role to the access policy for key k.

When a data element is deleted in the IMDG so too will the associated access policy be deleted. In certain example embodiments the access policy may be persisted in the persistence store backing L2 e.g. disk in case the data needs to be bootstrapped from a system shutdown or refresh.

An example update access policy API according to certain example embodiments may be of the following form public static void AccessPolicyManager udpate Object key AccessPolicy aAccessPolicy throws AccessPolicyManagementException AccessViolationException. The Object Key is the key to the data element in the IMDG. AccessPolicy is an Object comprising of predicates like Rolename and well known context parameters. The specified access policy will overwrite the existing AccessPolicy object. AccessPolicyManagementException can be thrown in case when a policy does not already exist. AccessViolationException is thrown when the executing context is not authorized to manage policies.

An example API to create access policies according to certain example embodiments may be as follows public static void AccessPolicyManager create Object key AccessPolicy aAccessPolicy throws AccessPolicyManagementException AccessViolationException. The Object Key is the key to the data element in the IMDG. The AccessPolicy is an Object comprising of predicates like Rolename and well known context parameters. AccessPolicyManagementException can be thrown in case when a policy already exists. AccessViolationException can be thrown when the executing context is not authorized to manage policies.

An example API to delete an access policy may be as follows public static void AccessPolicyManager delete Object key throws AccessPolicyManagementException AccessViolationException. The Object Key is the key to the data element in the IMDG whose associated policy is to be deleted . The AccessPolicyManagementException can be thrown in case when a policy does not exist. AccessViolationException is thrown when the executing context is not authorized to manage policies.

An example API to read an access policy may be as follows public static AccessPolicy AccessPolicyManager read Object key throws AccessPolicyManagementException AccessViolationException. The Object Key is the key to the data element in the IMDG. AccessPolicy is an Object comprising of predicates like Rolename and other predefined context parameters. This is returned as a result. AccessPolicyManagementException can be thrown in case when a policy does not already exist. AccessViolationException is thrown when the executing context is not authorized to manage policies.

Certain example embodiments may also include techniques for controlling the runtime environment of the IMDG such that the consistency of the system is maintained while providing for the access policies to be in lined in L1 tier. The effect of runtime may be determined by the standard consistency modes of the IMDG. In certain example embodiments at least one of a non locking mode and a locking mode are supported.

The event flow illustrates the interaction between application servers and a storage device and associated example message flow between them during the updating of a policy. Each application server includes an L1 tier component of an IMDG. Storage device includes an L2 tier component of the IMDG.

In the illustrated example embodiment in an initial state before the event flow commences the L1 tier components and the L2 tier component has a copy of key k the associated value v and access policy p.

At operation the administrator requests the update of the access policy p to p at application server . In response in the IMDG the L1 tier of application server updates its copy of key k information to updated the associated access policy from p to p. At operation the IMDG updates the L2 tier at storage device to update its copy of key k and the associated access policy to replace p with p. In certain non locking mode embodiments the IMDG does not acquire locks of the L1 tier components and before updating L1 tier and L2 tier .

Consequently in the non locking mode a request to access data pertaining to key k at application servers or made simultaneously or near simultaneously with the request to update the access policy p at application server can result in returning the value based on a stale associated access policy p rather than the updated p.

A subsequent request after the synchronization operation is received at application server to access data pertaining to key k. At operation the request received at is sent to L2 where the access policy p is enforced.

The event flow illustrates the interaction between application servers and a storage device and associated example message flow between them during the updating of a policy. Application servers each includes an L1 tier component of an IMDG. Storage device includes an L2 tier component of the IMDG.

In the illustrated example embodiment in an initial state before the event flow commences the L1 tier components and the L2 tier component has a copy of key k the associated value v and access policy p.

At operation the administrator updates access policy p to p at application server . In response in the IMDG the L1 tier updates its copy of key k and associated data and access policy to replace p by p. At operation application server requests a cluster wide lock for key k and associated data element and access policy. The cluster wide lock may be acquired by the storage device upon being notified and or requested to perform as such by application server .

The storage device operates at operations and to cause the invalidation or deletion of the entries for key k in the respective L1 tiers at application servers and . After all the application servers other than the application server at which the administrator updated the entry for key k at operation the cluster wide lock is granted. In certain example embodiments during the period when the cluster wide lock is in place read write operations to k and its data or access policy are denied. Certain other example embodiments may permit read operations but disallow write operations.

At operation the key k entry at the storage device L2 tier is updated from access policy p to p. The cluster wide lock may be released after the L2 tier is updated.

At operation a read request is received at application server for which the processing is described in relation to .

At operation the application server requests a read lock e.g. transmits a read lock acquire request . At operation the read lock is granted. At operation the updated entry for key k is read from the L2 tier at the storage device based upon the updated access policy p associated with key k in the L2 tier. Subsequently the L1 tiers are updated with the same updated access policy p for future requests. For example a subsequent request to read key k received at application server results in the key k key value pair along with the updated associated access policy p being stored in the L1 tier at application server .

The above example embodiments are described primarily in relation to IMDG. However the teachings of this disclosure may be applicable to other tiered memory data platforms as well. For example certain embodiments may apply to tiered memory storage that includes at least one level of caching in addition to a persistent storage for data. Moreover although certain example embodiments have been described in connection with Java and like languages it will be appreciated that these languages are merely examples may or may not necessarily correspond to a programming language that is used or is to be used in a real system or all embodiments of this invention. Instead it will be appreciated that the example techniques described herein are not dependent on any specific programming language and or runtime environment.

It will be appreciated that as used herein the terms system subsystem service engine module programmed logic circuitry and the like may be implemented as any suitable combination of software hardware firmware and or the like. It also will be appreciated that the storage locations stores and repositories discussed herein may be any suitable combination of disk drive devices memory locations solid state drives CD ROMs DVDs tape backups storage area network SAN systems and or any other appropriate tangible non transitory computer readable storage medium. Cloud and or distributed storage e.g. using file sharing means for instance also may be used in certain example embodiments. It also will be appreciated that the techniques described herein may be accomplished by having a processor e.g. central processing unit CPU or specialized processor execute instructions that may be tangibly stored on a computer readable storage medium.

While the invention has been described in connection with what is presently considered to be the most practical and preferred embodiment it is to be understood that the invention is not to be limited to the disclosed embodiment but on the contrary is intended to cover various modifications and equivalent arrangements included within the spirit and scope of the appended claims.

