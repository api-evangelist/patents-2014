---

title: System and method for data structure synchronization
abstract: A system and method for data structure synchronization includes a control unit and a memory coupled to the control unit. The memory stores a first base data structure and a first digest data structure. The control unit maintains the first digest data structure based on the first base data structure and determines whether the first base data structure is in synchronization with a second base data structure. When the first and second base data structures are not in synchronization, the control unit receives a second digest data structure based on the second base data structure, attempts to synchronize the first base data structure to the second base data structure based on differences between the first and second digest data structures, and receives the second base data structure from the second computing device and replaces the first base data structure with the second base data structure when the attempt is not successful.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09633100&OS=09633100&RS=09633100
owner: DELL PRODUCTS, L.P.
number: 09633100
owner_city: Round Rock
owner_country: US
publication_date: 20140115
---
The present disclosure relates generally to information handling systems and more particularly to data structure synchronization.

As the value and use of information continues to increase individuals and businesses seek additional ways to process and store information. One option is an information handling system IHS . An IHS generally processes compiles stores and or communicates information or data for business personal or other purposes. Because technology and information handling needs and requirements may vary between different applications IHSs may also vary regarding what information is handled how the information is handled how much information is processed stored or communicated and how quickly and efficiently the information may be processed stored or communicated. The variations in IHSs allow for IHSs to be general or configured for a specific user or specific use such as financial transaction processing airline reservations enterprise data storage or global communications. In addition IHSs may include a variety of hardware and software components that may be configured to process store and communicate information and may include one or more computer systems data storage systems and networking systems.

Additionally some embodiments of information handling systems include non transient tangible machine readable media that include executable code that when run by one or more processors may cause the one or more processors to perform the steps of methods described herein. Some common forms of machine readable media include for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge and or any other medium from which a processor or computer is adapted to read.

Computer networks form the interconnection fabric that enables reliable and rapid communications between computer systems and data processors that are in both close proximity to each other and at distant locations. These networks create a vast spider web of intranets and internets for handling all types of communication and information. Making all of this possible is a vast array of network switching products that make forwarding decisions in order to deliver packets of information from a source system or first network node to a destination system or second network node. Due to the size complexity and dynamic nature of these networks sophisticated network switching products are often required to continuously make forwarding decisions and to update forwarding information as network configurations change. To provide redundancy and or fail over support in the network two or more network switching products in a network may provide backup or similar services for each other. In some examples two network switching products may be configured as a high availability pair where one network switching product may be configured to take over the responsibilities of a second network switching product when the second network switching product is unavailable due to maintenance and or failure. In some examples one network switching product may maintain duplicate copies of one or more data structures stored by a second network switching product. In order for the first network switching product to provide take over and or backup support the second network switching product it may be useful for the first network switching product to maintain synchronized copies of one or more data structures being created and or managed in the second network switching product. In many cases these data structures may be quite large in size storing thousands or even tens of thousands or more entries. Due to the size of these data structures it may not be practical to have the second network switching product forward a copy of the data structure to the first network switching product whenever synchronization between the data structures is desired.

Accordingly it would be desirable to provide improved methods and systems for synchronizing data structures between two devices such as two network switching products.

According to one embodiment a computing device includes a control unit and a memory coupled to the control unit. The memory stores a first base data structure and a first digest data structure. The control unit is configured to maintain the first digest data structure based on entries stored in the first base data structure and determine whether the first base data structure is in synchronization with a second base data structure stored in a second computing device. When the first base data structure is not in synchronization with the second base data structure the control unit is further configured to receive a second digest data structure based on the second base data structure from the second computing device attempt to synchronize the first base data structure to the second base data structure based on differences between the first and second digest data structures and receive the second base data structure from the second computing device and replace the first base data structure with the second base data structure when the attempt is not successful.

According to another embodiment a method of synchronizing base data structures includes maintaining a first digest data structure based on entries stored in a first base data structure determining whether the first base data structure is in synchronization with a second base data structure stored in a second computing device. When the first base data structure is not in synchronization with the second base data structure the method further includes receiving a second digest data structure based on the second base data structure from the second computing device attempting to synchronize the first base data structure to the second base data structure based on differences between the first and second digest data structures and receiving the second base data structure from the second computing device and replacing the first base data structure with the second base data structure when the attempt is not successful. The first base data structure is stored in a first computing device.

According to yet another embodiment a computing device includes a control unit and a memory coupled to the control unit. The memory stores a first base data structure and a first digest data structure. The control unit is configured to maintain the first digest data structure based on entries stored in the first base data structure and determine whether the first base data structure is in synchronization with a second base data structure stored in a second computing device. When the first base data structure is not in synchronization with the second base data structure the control unit is further configured to receive a second digest data structure based on the second base data structure from the second computing device determine a difference digest data structure based on differences between the first digest data structure and the second digest data structure identify one or more pure buckets in the difference digest data structure transmit an entry add or an entry remove request for the second base data structure to the second computing device for each of the one or more pure buckets and transmit the first base data structure to the second computing device when the difference data structure cannot be used to bring the second base data structure into synchronization with the first base data structure.

According to yet another embodiment an information handling system includes a network switching device. The network switching device includes a control unit and a memory coupled to the control unit. The memory stores a first base data structure and a first digest data structure. The control unit is configured to maintain the first digest data structure based on entries stored in the first base data structure and determine whether the first base data structure is in synchronization with a second base data structure stored in a second network switching device. When the first base data structure is not in synchronization with the second base data structure the control unit is further configured to receive a second digest data structure based on the second base data structure from the second network switching device determine a difference digest data structure based on differences between the first digest data structure and the second digest data structure identify one or more pure buckets in the difference digest data structure add or remove an entry from the difference digest data structure and add or remove an entry from the first base data structure for each of the one or more pure buckets and receive the second base data structure from the second network switching device and replace the first base data structure with the second base data structure when the difference digest data structure cannot be used to synchronize the first base data structure to the second base data structure. The network switching device is elected from a group consisting of a router a switch a hub and a bridge.

In the following description specific details are set forth describing some embodiments consistent with the present disclosure. It will be apparent however to one skilled in the art that some embodiments may be practiced without some or all of these specific details. The specific embodiments disclosed herein are meant to be illustrative but not limiting. One skilled in the art may realize other elements that although not specifically described here are within the scope and the spirit of this disclosure. In addition to avoid unnecessary repetition one or more features shown and described in association with one embodiment may be incorporated into other embodiments unless specifically described otherwise or if the one or more features would make an embodiment non functional.

For purposes of this disclosure an IHS may include any instrumentality or aggregate of instrumentalities operable to compute classify process transmit receive retrieve originate switch store display manifest detect record reproduce handle or utilize any form of information intelligence or data for business scientific control entertainment or other purposes. For example an IHS may be a personal computer a PDA a consumer electronic device a display device or monitor a network server or storage device a switch router or other network communication device or any other suitable device and may vary in size shape performance functionality and price. The IHS may include memory one or more processing resources such as a central processing unit CPU or hardware or software control logic. Additional components of the IHS may include one or more storage devices one or more communications ports for communicating with external devices as well as various input and output I O devices such as a keyboard a mouse and a video display. The IHS may also include one or more buses operable to transmit communications between the various hardware components.

As shown computing device includes a control unit coupled to memory and computing device includes a control unit coupled to memory . Each of control units and or may control the operation of its respective computing device and or . In some examples control units and or may each include one or more processors central processing units virtual machines microprocessors microcontrollers application specific integrated circuits ASICs field programmable gate arrays FPGAs and or the like.

Memory may be used to store one or more applications and one or more data structures such as a representative application and data structure . Similarly memory may be used to store one or more applications and one or more data structures such as a representative application and data structure . Memories and or may each include one or more types of machine readable media. Some common forms of machine readable media may include floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge and or any other medium from which a processor or computer is adapted to read.

The data structures and or may vary in size usage and or complexity depending upon the purposes of computing devices and or and or applications and or . In some embodiments when computing devices and or are network switching devices such as switches routers hubs bridges and or the like the data structures and or may include one or more tables with forwarding and or similar information. In some examples these tables may include one or more virtual LAN tables link aggregation group LAG tables layer 2 L2 next hop tables layer 3 L3 routing tables L3 forwarding information bases FIBs flow tables and or the like. Depending upon the networking environment of system and or the role of computing devices and or these tables may include anywhere from a few dozen entries to thousands or even tens of thousands or more entries.

Computing devices and are also coupled together using a network . Network may be any kind of network including a cable a local area network LAN such as an Ethernet and or a wide area network WAN such as an internet. Computing devices and through their applications such as applications and or may use network to exchange information and or to provide services for each other. In some examples computing device may be used to provide backup and or fail over services for computing device . In some examples computing device may be maintaining data structure as a synchronized copy of data structure .

There are several ways in which computing device may maintain data structure as a synchronized copy of data structure . In some embodiments computing device may periodically transmit a copy of data structure to computing device with the transmitted copy becoming data structure . For small and or even moderately sized data structures this may be a reasonable practice but as data structure increases in size the time and or bandwidth used to transmit a complete copy of data structure to computing device may become unreasonable.

In some embodiments computing device may forward any incremental changes to data structure to computing device so the incremental changes may be applied to data structure . In some examples this may include transmitting the equivalent of any operation that adds removes and or updates any entry in data structure to computing device so that the respective operations may also be applied to data structure . In some examples the incremental changes may be transmitted as differences and or diffs between data structure and data structure . However in order for incremental changes to work data structures and should remain in synchronization with data structure maintaining an accurate copy of data structure . As soon as data structure loses synchronization with data structure the incremental changes may further compound any differences between data structures and and are generally unable to reconcile data structures and back into synchronization. In some examples loss of synchronization may occur when incremental changes for data structure are lost damaged and or processed out of order on data structure .

One possible solution to the loss of synchronization between data structures and is to periodically check for synchronization between data structures and and when synchronization is lost retransmit a complete copy of data structure to computing device to replace the unsynchronized data structure . In some examples loss of synchronization between data structures and may be detected by exchanging checksums hashes and or the like between computing devices and . This solution however operates in an error detection mode where when an error loss of synchronization is detected recovery of synchronization is returned by transmitting a complete copy of the data structure .

A better solution would involve at least some level of error correction so that when loss of synchronization is detected it may be possible to reconcile or recover synchronization when the differences between data structure and are not too large. In some examples error correction and or reconciliation may involve more sophisticated mechanisms than checksums hashes and or the like. In some examples computing devices and may be able to provide some level of reconciliation by exchanging additional data structures that are smaller than data structures and yet provide the ability for data structure to be brought back into synchronization with data structure without having to transmit a complete copy of data structure to computing device . One such possible data structure for providing a partial solution to this problem is the invertible bloom filter IBF .

Each of the buckets through includes three elements as shown by a representative bucket . The three elements include an entry sum a hash sum and a count . When an entry is added or assigned to bucket each of the elements is updated accordingly. Entry sum includes the sum of the entries added or assigned to bucket . Entry sum is computed using exclusive or XOR arithmetic so that when an entry is added twice to entry sum the second addition cancels the first. This is useful for supporting removal of an entry from bucket . Hash sum includes the sum again using XOR arithmetic of a hash of each of the entries added or assigned to bucket . Count includes a count of the number of entries in bucket .

Several operations may be performed on IBF and buckets through that may be used to support synchronization and reconciliation of two data structures. These operations including adding entries to an IBF removing entries from an IBF determining the differences between two IBFs and using two IBFs to partially reconcile two base data structures used to compute the two IBFs. These operations are respectively shown in .

At a process an entry is received. The entry may be received for addition to an IBF using any suitable mechanism. In some examples the entry may be received as a parameter in an application programming interface API call that also identifies the IBF. In some examples when the IBF is implemented as an object in an object oriented language such as C or Java the entry may be received as a parameter of a member function.

At a process hash functions are applied to the entry to identify buckets. Each of the hash functions for the IBF such as hash functions are applied to the entry received during process . Each hash function identifies a corresponding bucket of the IBF filter into which the entry is to be added. In some examples each hash function may determine a hash value based on the entry which when taken modulo relative to the number of buckets of the IBF may identify the bucket number associated with the respective hash function.

At a process the entry sum for each identified bucket is updated. For each of the buckets of the IBF identified in process the corresponding entry sum such as entry sum is updated based on the value of the entry. In some examples the entry sum may be updated by adding the entry to the entry sum of the corresponding bucket using XOR arithmetic.

At a process the hash sum for each identified bucket is updated. For each of the buckets of the IBF identified in process the corresponding hash sum such as hash sum is updated based on a hashed value of the entry. In some examples the hash function used to hash the entry may be different than the hash functions used during process to identify the buckets. In some examples the hash sum may be updated by adding the hashed entry value to the hash sum of the corresponding bucket using XOR arithmetic.

At a process the count for each identified bucket is incremented. For each of the buckets of the IBF identified in process the corresponding count such as count is incremented. The corresponding count allows the IBF to keep track of how many entries have been added to the corresponding bucket.

At a process an entry is received. The entry may be received for removal from an IBF using any suitable mechanism. In some examples the entry may be received as a parameter in an API and or a member function call.

At a process hash functions are applied to the entry to identify buckets. Each of the hash functions for the IBF such as hash functions are applied to the entry received during process . Each hash function identifies a corresponding bucket of the IBF filter from which the entry is to be removed. In some examples each hash function may determine a hash value based on the entry which when taken modulo relative to the number of buckets of the IBF may identify the bucket number associated with the respective hash function.

At a process the entry sum for each identified bucket is updated. For each of the buckets of the IBF identified in process the corresponding entry sum such as entry sum is updated based on the value of the entry. In some examples the entry sum may be updated by adding the entry to the entry sum of the corresponding bucket using XOR arithmetic. In some examples by using XOR arithmetic the addition of the value of the entry to the corresponding entry sum cancels a previous addition of the same entry to the corresponding entry sum.

At a process the hash sum for each identified bucket is updated. For each of the buckets of the IBF identified in process the corresponding hash sum such as hash sum is updated based on a hashed value of the entry. In some examples the hash function used to hash the entry may be different than the hash functions used during process to identify the buckets. In some examples the hash sum may be updated by adding the hashed entry value to the hash sum of the corresponding bucket using XOR arithmetic. In some examples by using XOR arithmetic the addition of the hashed entry value of the entry to the corresponding hash sum cancels a previous addition of the same hashed value of the entry to the corresponding hash sum.

At a process the count for each identified bucket is decremented. For each of the buckets of the IBF identified in process the corresponding count such as count is decremented. Decrementing the count reduces by one the number of entries assigned to the corresponding bucket.

At a process a first and a second IBF are received. The first and second IBFs may be received by any suitable mechanism. In some examples the IBFs may be received as parameters in an API and or a member function call as operands to an overloaded subtraction operator and or the like. In some examples the second IBF may be subtracted from the first IBF to determine a third IBF that is the difference between the first and second IBFs.

At a process the difference between entry sums for each corresponding bucket in the first and second IBFs is determined. For each of the corresponding buckets of the first and second IBFs received during process the difference of the corresponding entry sums such as entry sum from the corresponding buckets is determined. Thus for IBFs with n buckets the differences between n corresponding pairs of entry sums is determined. In some examples the corresponding entry sums may be differenced by adding the corresponding entry sums together using XOR arithmetic. In some examples by using XOR arithmetic the addition of the corresponding entry sums acts as the equivalent of a subtraction operation.

At a process the difference between hash sums for each corresponding bucket in the first and second IBFs is determined. For each of the corresponding buckets of the first and second IBFs received during process the difference of the corresponding hash sums such as hash sum from the corresponding buckets is determined. Thus for IBFs with n buckets the differences between n corresponding pairs of hash sums is determined. In some examples the corresponding hash sums may be differenced by adding the corresponding hash sums together using XOR arithmetic. In some examples by using XOR arithmetic the addition of the corresponding hash sums acts as the equivalent of a subtraction operation.

At a process the difference between counts for each corresponding bucket in the first and second IBFs is determined. For each of the corresponding buckets of the first and second IBFs received during process the difference of the corresponding counts such as count from the corresponding buckets is determined. Thus for IBFs with n buckets the differences between n corresponding pairs of counts is determined. In some examples the corresponding counts may be differenced using subtraction.

As a result of performing the differencing operations of method the third or difference IBF contains a record of each of the buckets that are different between the first and second IBFs. For each of these buckets the entry sum includes a sum of any differences in the sum of the entry values added to the corresponding bucket in the first and second IBFs. Similarly for each of these buckets the hash sum includes a sum of any differences in the sum of the hashes of the entry values added to the corresponding bucket in the first and second IBFs. If the entries added to the corresponding buckets in the first and second IBFs are the same the entry sum and the hash sum of the difference will be zero. Additionally for each of these buckets the count includes a difference of the number of entries added to the corresponding buckets in the first and second IBFs. A count value greater than zero indicates that more entries were added to the corresponding bucket in the first IBF than in the second. A count value less than zero indicates that more entries were added to the corresponding bucket in the second IBF than in the first. When each of the buckets in the difference IBF includes an entry sum a hash sum and a count that are zero the first and second IBFs are the same. In some examples this may also indicate that the base data structures corresponding to the first IBF and the second IBF contain the same entries such that the base data structures are in synchronization.

At a process a first and a second IBF are received. The first and second IBFs may be received by any suitable mechanism. In some examples the IBFs may be received as parameters in an API and or a member function call as operands to an overloaded subtraction operator and or the like. In some examples the first IBF may be received at a first computing device and may be used to reconcile a base data structure corresponding to the second IBF to the base data structure corresponding to the first IBF.

At a process the first IBF is subtracted from the second IBF. Using a process similar to method the first IBF is subtracted from the second IBF to create a difference IBF. The difference IBF may be used to determine whether the first and second IBFs are the same and may further provide hints as to how to reconcile the base data structures corresponding to the first and second IBFs.

At a process a list of pure buckets is created. Each of the buckets in the difference IBF is examined to determine whether it is a pure bucket. A pure bucket is a bucket that may be used to identify an individual entry that was added to either the first of second IBF. When used in the context of reconciling the base data structure corresponding to the second IBF to the base data structure corresponding to the first IBF this may include the case where the entry was added to the first IBF and not added to the second IBF or the case where the entry was removed from the first IBF and not removed from the second IBF. In some examples a pure bucket may be identified based on the entry sum hash sum and count elements of the pure bucket. A count value of positive or negative one indicates that the first and second IBFs differ by one as to the number of entries added to the corresponding bucket. This may occur due to an actual difference in one entry or as a result of multiple differences such as two adding operations and one removing operation on one of the IBFs not reflected in the other. To confirm whether the difference is due to a single entry the hash function used for creating the hash values used in the hash sum is applied to the entry sum of the corresponding bucket and the result is compared to the hash sum in the corresponding bucket. When the two values are the same the corresponding bucket is a pure bucket that is added to the list of pure buckets.

At a process it is determined whether the list of pure buckets is empty. When the list of pure buckets is empty the difference IBF no longer contains any usable hints for reconciling the first and second IBFs and the corresponding base data structures. When the list of pure buckets is empty it is determined whether the first and second IBFs are reconciled using a process . When the list of pure buckets is not empty the reconciliation of the first and second IBFs continues beginning with a process .

At the process it is determined whether the difference IBF is zero. Each of the buckets in the difference IBF is examined to determine whether each of the corresponding entry sum hash sum and count elements is zero. When each of these is zero the first and second IBFs are reconciled and the corresponding base data structures are synchronized. More specifically the base data structure corresponding to the second IBF is now updated to contain the same entries as the base data structure corresponding to the first IBF. When any of the buckets of the difference IBF includes an element that is not zero the first and second IBFs are not reconciled and the corresponding base data structures are not synchronized. After completion to the determination of process method finishes.

At the process a pure bucket is extracted from the list of pure buckets. Each of the pure buckets in the list of pure buckets is processed in turn to either add or remove an entry from the second IBF and the base data structure corresponding to the second IBF. Once the pure bucket is extracted from the list of pure buckets it is removed from the list of pure buckets.

At a process it is determined whether the count element of the extracted pure bucket is positive or negative one. When the count element is positive one the second IBF includes an entry not found in the first IBF and the entry is removed from the difference IBF and the base data structure corresponding to the second IBF beginning with a process . When the count element is negative one the first IBF includes an entry not found in the second IBF and the entry is added to the difference IBF and the base data structure corresponding to the second IBF beginning with a process .

At the process the pure bucket entry is removed from the difference IBF. When the count element of the extracted pure bucket is positive one the second IBF and its corresponding base data structure include an entry that is to be removed. The entry to remove is identified by the entry sum element of the extracted pure bucket. In some examples the entry may be removed from the difference IBF using a process similar to method .

At a process the pure bucket entry is removed from the base data structure. To bring the base data structure corresponding to the second IBF closer to synchronization with the base data structure corresponding to the first IBF the entry from the extracted pure bucket as identified during process is removed from the base data structure corresponding to the second IBF. In some examples the APIs and or other mechanisms used by the base data structure may be used to remove the entry from the base data structure corresponding to the second IBF. The difference IBF is then checked for newly created pure buckets using a process .

At the process the pure bucket entry is added to the difference IBF. When the count element of the extracted pure bucket is negative one the second IBF and its corresponding base data structure are missing an entry that is to be added. The entry to add is identified by the entry sum element of the extracted pure bucket. In some examples the entry may be added to the difference IBF using a process similar to method .

At a process the pure bucket entry is added to the base data structure. To bring the base data structure corresponding to the second IBF closer to synchronization with the base data structure corresponding to the first IBF the entry from the extracted pure bucket as identified during process is added to the base data structure corresponding to the second IBF. In some examples the APIs and or other mechanisms used by the base data structure may be used to add the entry to the base data structure corresponding to the second IBF. The difference IBF is then checked for newly created pure buckets using a process .

At the process newly created pure buckets are added to the list of pure buckets. Whenever an entry is added to or removed from the difference IBF this may create additional pure buckets that may be used to reconcile the first and second IBFs and bring the base data structure corresponding to the second IBF closer to synchronization with the base data structure corresponding to the first IBF. Similar to process any buckets in the difference IBF with a count element of positive or negative one and an entry sum element whose hashed value is equal to the hash sum element are pure buckets and may be added to the list of pure buckets. In some examples each of the buckets altered by the remove or add operations of processes and or are checked during process to determine whether they have become pure buckets. The list of pure buckets in then checked to determine whether it is empty using process .

As discussed above and further emphasized here are merely example which should not unduly limit the scope of the claims. One of ordinary skill in the art would recognize many variations alternatives and modifications. In some embodiments digest data structures other than the invertible bloom filter may be used with the adding removing differencing and reconciling methods.

At a process a checksum and an entry count for a reference data structure is received. As a quick check to determine whether a duplicate data structure and a reference data are in synchronization basic comparative metrics on the reference data structure are received. The checksum and entry count may be received as parameters in an API and or member function call and or the like when the reference data structure and the duplicate data structure are stored on the same computing device. When the reference data structure and the duplicate data structure are stored on separate computing devices the checksum and entry count may be received at the computing device storing the duplicate data structure via a message passing protocol such as remote procedure call web services and or the like. In some examples the checksum and entry count may be received as a first part of an exchange of messages associated with a data structure synchronization operation. In some embodiments the checksum may be computed using any suitable checksum operation based on modulo arithmetic any suitable hash function such as a cyclic redundancy check CRC and or the like.

At a process it is determined whether the checksum and entry count of the reference data structure match the checksum and entry count of the duplicate data structure. The checksums and entry counts may be used as a quick check to determine whether the reference and duplicate data structures are synchronized. When the checksums of the reference and duplicate data structures are the same and the number of entries in the reference and duplicate data structures are the same the reference and duplicate data structures may be determined to be synchronized using a process . When either checksums and or the entry counts are not the same the reference and duplicate data structures are not in synchronization and are synchronized beginning with a process .

At the process it is determined whether the entry count differences are above a threshold. When the reference and duplicate data structures are fairly close to synchronization as suggested by respective entry counts that are similar in value it may be possible to synchronize the duplicate data structure with the reference data structure by using a more efficient reconciliation process based on making incremental changes to the duplicate data structure. In some embodiments the decision to use the more efficient incremental change process may be performed by comparing the absolute difference between the entry counts of the reference and duplicate data structures and a configurable threshold. In some examples the threshold may be set by a user and or an administrator of the data structure synchronization system. In some examples the threshold may be based on a fixed value such as 5 10 20 and so forth. In some examples the threshold may be set based on the percentage differences between the entry counts with the threshold being set at 1 5 or as much as 10 percent or more of the entry count for the reference data structure and or the entry count of the duplicate data structure. In some examples the threshold may be based on a number of buckets in an IBF used with method as discussed in further detail below with respect to processes . When the difference between the entry counts of the reference and duplicate data structures are above the threshold the reference data structure is received using a process . When the difference between the entry counts of the reference and duplicate data structures are below the threshold an attempt is made to reconcile the duplicate data structure to the reference data structure using IBFs beginning with a process .

At the process a reference IBF is received. A reference IBF corresponding to the reference data structure is received. Similar to the checksum and entry count received during process the reference IBF may be received as a parameter from a function call via message passing over a network and or the like. The reference IBF is generated from the reference data structure using the same hash functions and number of buckets as the corresponding duplicate IBF generated and or maintained based on the duplicate data structure. In some examples the reference and duplicate IBFs may be similar to IBF .

In some embodiments the reference and duplicate IBFs may be generated using any suitable number of hash functions and buckets. In some examples the number of hash functions and buckets may be selected to balance between the ability of the IBFs to reconcile the duplicate data structure to the reference data structure versus the computational cost of the IBFs the space used to store the IBFs and or the time used to transmit the IBFs between computing devices.

In some examples the hash functions and number of buckets may be configurable and may be set by a user and or administrator of the data structure synchronization system. In some examples the number of buckets may be selected to be 80 160 240 320 and or any other similar number of buckets. In some examples the number of hash functions may be two or more in number. In some examples the hash functions may be generated from two independent base hash functions using Equation 1 where m is the number of hash functions desired . . . . In some examples the base hash functions may be selected from the crc32 crc16 crc32 upper crc32 lower and or similar hash functions. hash base hash base hash1 2 3 . . . 1 

At a process the duplicate data structure is reconciled to the reference data structure using the reference IBF. Using the reference IBF received during process the duplicate IBF is reconciled to the reference IBF using a process similar to method where the reference IBF is the first IBF and the duplicated IBF is the second IBF. The method may also be used to concurrently move the duplicate data structure closer to synchronization with the reference data structure.

At a process it is determined whether the duplicate IBF is fully reconciled with the reference IBF. Using process to determine whether the difference IBF is zero it may be determined whether the duplicate IBF is fully reconciled with the reference IBF. When method is able to reduce the difference IBF to buckets with each of the elements being zero process was able to fully reconcile the duplicate IBF to the reference IBF and to bring the duplicate data structure in synchronization with the reference data structure. In some examples when process is able to fully reconcile the duplicate IBF with the reference IBF the reference IBF received during process may be used to replace the duplicate IBF. When the duplicate IBF is fully reconciled with the reference IBF the reference and duplicate data structures may be determined to be synchronized using process . When the duplicate IBF is not fully reconciled with the reference IBF the reference data structure is received using process .

At the process the reference data structure is received. Similar to the checksum and entry count received during process and the reference IBF received during process the reference data structure may be received as a parameter from a function call via message passing over a network and or the like. The received reference data structure becomes the duplicate data structure bringing the duplicate data structure into synchronization. In some examples the reference IBF may also be received during process and used as the duplicate IBF or a new duplicate IBF may be determined from the received reference data structure.

At the process the duplicate data structure is in synchronization with the reference data structure. In some embodiments method may be repeated for additional data structures to be brought into synchronization and or repeated periodically for the same one or more data structures.

As discussed above and further emphasized here is merely an example which should not unduly limit the scope of the claims. One of ordinary skill in the art would recognize many variations alternatives and modifications. In some embodiments additional message passing and or hand shaking operations may occur during method . In some examples the computing device performing method may transmit status information and or messages during the method to trigger sending of the reference IBF filter received during process and or the reference data structure received during process .

In some embodiments the synchronization of method may be modified to be performed in the computing device storing the reference data structure. In some examples process may be modified so that the checksum and entry count for the duplicated data structure may be received from the computing device storing the duplicate data structure. In some examples process may be modified so that the duplicate IBF may be received from the computing device storing the duplicate data structure and process may be modified so that the reference data structure is transmitted to the computing device storing the duplicate data structure. In some examples the reconciliation of process and method may be modified so that rather than making changes to the reference data structure during processes and or the updates to the duplicate data structure may be transmitted as add and or remove requests to the computing device storing the duplicated data structure.

In some embodiments in order to avoid inconsistencies during the synchronization of method one or more mechanisms may be used to prevent any changes being made to the reference data structure while the synchronization is being performed.

In some embodiments digest data structures other than the IBF may be used with process . As long as the other digest data structures support adding removing and differencing operations similar to those described in and support reconciliation through mechanisms similar and or equivalent to entry isolation using pure buckets these other digest data structures may be used with method .

Some embodiments of computing devices and or may include non transient tangible machine readable media that include executable code that when run by one or more processors e.g. one or more processors in control units and or may cause the one or more processors to perform the processes of methods as described above. Some common forms of machine readable media that may include the processes of methods are for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge and or any other medium from which a processor or computer is adapted to read.

Although illustrative embodiments have been shown and described a wide range of modification change and substitution is contemplated in the foregoing disclosure and in some instances some features of the embodiments may be employed without a corresponding use of other features. One of ordinary skill in the art would recognize many variations alternatives and modifications. Thus the scope of the invention should be limited only by the following claims and it is appropriate that the claims be construed broadly and in a manner consistent with the scope of the embodiments disclosed herein.

