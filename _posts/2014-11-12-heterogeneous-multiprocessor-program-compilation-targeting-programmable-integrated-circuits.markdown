---

title: Heterogeneous multiprocessor program compilation targeting programmable integrated circuits
abstract: OpenCL program compilation may include generating, using a processor, a register transfer level (RTL) description of a first kernel of a heterogeneous, multiprocessor design and integrating the RTL description of the first kernel with a base platform circuit design. The base platform circuit design provides a static interface within a programmable integrated circuit to a host of the heterogeneous, multiprocessor design. A first configuration bitstream may be generated from the RTL description of the first kernel using the processor. The first configuration bitstream specifies a hardware implementation of the first kernel and supporting data for the configuration bitstream. The first configuration bitstream and the supporting data may be included within a binary container.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09218443&OS=09218443&RS=09218443
owner: XILINX, INC.
number: 09218443
owner_city: San Jose
owner_country: US
publication_date: 20141112
---
This disclosure relates to integrated circuits ICs and more particularly to incorporating programmable ICs into a heterogeneous multiprocessor design.

A heterogeneous multiprocessor framework provides a standard that is cross platform and supports parallel programming of modern processors servers handheld embedded devices and the like. Open Computing Language referred to as OpenCL is an example of a heterogeneous multiprocessor framework for writing programs that may be executed across heterogeneous computing platforms. A heterogeneous computing platform may include a central processing unit CPU a graphics processing unit GPU a digital signal processor DSP or the like.

A heterogeneous multiprocessor program e.g. an OpenCL program includes a portion that executes on a host system and one or more other portions that execute on devices. Typically the host system includes the CPU while the devices may be implemented as GPUs DSPs etc. The portions that execute on devices which may be referred to as kernels may be coded in OpenCL OpenCL C or another high level programming language adapted to the heterogeneous multiprocessor framework or OpenCL. The portion that executes on the host may be programmed in C or C for example and controls the heterogeneous multiprocessor environment across the various devices.

While the environment described above is heterogeneous in nature each specific device whether a DSP or a GPU has a static architecture. By comparison a programmable IC such as a field programmable gate array FPGA has an extremely flexible hardware architecture that may be used for purposes of hardware acceleration. In order to utilize a programmable IC as a device however the circuitry implemented within the programmable IC must be able to interact with the host and operate within the context of the heterogeneous multiprocessor environment.

A method includes generating using a processor a register transfer level RTL description of a first kernel of a heterogeneous multiprocessor design integrating the RTL description of the first kernel with a base platform circuit design providing a static region within a programmable integrated circuit IC that provides an interface to a host of the heterogeneous multiprocessor design and generating from the RTL description of the first kernel and using the processor a first configuration bitstream specifying a hardware implementation of the first kernel and supporting data for the configuration bitstream. The method also includes including the first configuration bitstream and the supporting data within a binary container.

A method includes generating using a processor an RTL description of a first kernel of a heterogeneous multiprocessor design integrating the RTL description of the first kernel with a base platform circuit design providing a static interface within a programmable IC to a host of the heterogeneous multiprocessor design and generating from the RTL description of the first kernel and using the processor supporting data for the RTL description of the first kernel. The method also includes including the RTL description of the first kernel and the supporting data within a binary container.

A system may include a processor programmed to initiate executable operations. The executable operations include generating an RTL description of a first kernel of a heterogeneous multiprocessor design integrating the RTL description of the first kernel with a base platform circuit design providing a static region within a programmable IC that provides an interface to a host of the heterogeneous multiprocessor design and generating from the RTL description of the first kernel a first configuration bitstream specifying a hardware implementation of the first kernel and supporting data for the configuration bitstream. The method may also include including the first configuration bitstream and the supporting data within a binary container.

This Summary section is provided merely to introduce certain concepts and not to identify any key or essential features of the claimed subject matter. Other features of the inventive arrangements will be apparent from the accompanying drawings and from the following detailed description.

While the disclosure concludes with claims defining novel features it is believed that the various features described within this disclosure will be better understood from a consideration of the description in conjunction with the drawings. The process es machine s manufacture s and any variations thereof described herein are provided for purposes of illustration. Specific structural and functional details described within this disclosure are not to be interpreted as limiting but merely as a basis for the claims and as a representative basis for teaching one skilled in the art to variously employ the features described in virtually any appropriately detailed structure. Further the terms and phrases used within this disclosure are not intended to be limiting but rather to provide an understandable description of the features described.

This disclosure relates to integrated circuits ICs and more particularly to incorporating programmable ICs into a heterogeneous multiprocessor system. In accordance with the inventive arrangements described within this disclosure a programmable IC may be used within a heterogeneous multiprocessor design to implement one or more kernels. One or more of the kernels of the heterogeneous multiprocessor may be compiled and transformed into hardware that is implemented using the programmable circuitry of a programmable IC. In this regard a kernel implemented using a programmable IC is hardware accelerated because the kernel is implemented using circuitry as opposed to being implemented as executable program code that is offloaded for execution to a processor other than the central processing unit CPU . The kernel portion of the heterogeneous multiprocessor design being synthesized into hardware operates in cooperation with the host of the heterogeneous multiprocessor design.

In one aspect the programmable IC may provide a base platform. Kernel s may be implemented over and or in cooperation with the base platform. The base platform provides the infrastructure necessary for the kernels to communicate with a target platform to which the programmable IC is coupled and the host. The base platform for example may be implemented or determined by the vendor of the target platform. Thus the base platform may vary according to the particular model or type of programmable IC that is used and the model or type of target platform used with the programmable IC.

The inventive arrangements described herein may be implemented as a method or process performed by a data processing system. In one example the method may be directed to implementation of a heterogeneous multiprocessor design where one or more kernels are implemented in programmable circuitry of a programmable IC. In another example the method may be directed to operation e.g. runtime operation of a heterogeneous multiprocessor system that includes a kernel implemented using a programmable IC.

In another aspect the inventive arrangements may be implemented as a data processing system having a CPU. The data processing system may perform a method directed to implementation of a heterogeneous multiprocessor design e.g. a compile time method where one or more kernels are implemented in programmable circuitry of a programmable IC. The data processing system also may include a programmable IC. In that case the data processing system may perform a method directed to operation e.g. runtime operation of a heterogeneous multiprocessor design that includes a kernel implemented using a programmable IC.

In still another aspect the inventive arrangements may be implemented as an IC. The IC may include a base platform. The IC may also be configured to include one or more kernels implemented therein that operate cooperatively with the base platform. The IC may implement a runtime method of operating involving the kernel s implemented within the IC and or various host interactions.

In yet another aspect the inventive arrangements may be implemented as a non transitory computer readable storage medium storing program code that when executed causes a processor and or a system to perform and or initiate the various methods and or processes described herein.

For purposes of simplicity and clarity of illustration elements shown in the figures have not necessarily been drawn to scale. For example the dimensions of some of the elements may be exaggerated relative to other elements for clarity. Further where considered appropriate reference numbers are repeated among the figures to indicate corresponding analogous or like features.

As shown architecture includes several different types of programmable circuit e.g. logic blocks. For example architecture may include a large number of different programmable tiles including multi gigabit transceivers MGTs configurable logic blocks CLBs random access memory blocks BRAMs input output blocks IOBs configuration and clocking logic CONFIG CLOCKS digital signal processing blocks DSPs specialized I O blocks e.g. configuration ports and clock ports and other programmable logic such as digital clock managers analog to digital converters system monitoring logic and so forth.

In some ICs each programmable tile includes a programmable interconnect element INT having standardized connections to and from a corresponding INT in each adjacent tile. Therefore INTs taken together implement the programmable interconnect structure for the illustrated IC. Each INT also includes the connections to and from the programmable logic element within the same tile as shown by the examples included at the top of .

For example a CLB may include a configurable logic element CLE that may be programmed to implement user logic plus a single INT . A BRAM may include a BRAM logic element BRL in addition to one or more INTs . Typically the number of INTs included in a tile depends on the height of the tile. As pictured a BRAM tile has the same height as five CLBs but other numbers e.g. four also may be used. A DSP tile may include a DSP logic element DSPL in addition to an appropriate number of INTs . An B may include for example two instances of an I O logic element IOL in addition to one instance of an INT . As will be clear to those of skill in the art the actual I O pads connected for example to IOL typically are not confined to the area of IOL .

In the example pictured in a columnar area near the center of the die e.g. formed of regions and may be used for configuration clock and other control logic. Horizontal areas extending from this column are used to distribute the clocks and configuration signals across the breadth of the programmable IC.

Some ICs utilizing the architecture illustrated in include additional logic blocks that disrupt the regular columnar structure making up a large part of the IC. The additional logic blocks may be programmable blocks and or dedicated circuitry. For example an optional processor block depicted as PROC spans several columns of CLBs and BRAMs.

In one aspect PROC is implemented as a dedicated circuitry e.g. as a hardwired processor that is fabricated as part of the die that implements the programmable circuitry of the IC. PROC may represent any of a variety of different processor types and or systems ranging in complexity from an individual processor e.g. a single core capable of executing program code to an entire processor system having one or more cores modules co processors interfaces or the like.

In another aspect PROC is omitted from architecture and replaced with one or more of the other varieties of the programmable blocks described. Further such blocks may be utilized to form a soft processor in that the various blocks of programmable circuitry may be used to form a processor that can execute program code as is the case with PROC .

The phrase programmable circuitry refers to programmable circuit elements within an IC e.g. the various programmable or configurable circuit blocks or tiles described herein as well as the interconnect circuitry that selectively couples the various circuit blocks tiles and or elements according to configuration data that is loaded into the IC. For example portions shown in that are external to PROC such as CLBs and BRAMs are considered programmable circuitry of the IC.

In general the functionality of programmable circuitry is not established until configuration data is loaded into the IC. A set of configuration bits may be used to program programmable circuitry of an IC such as an FPGA. The configuration bit s typically are referred to as a configuration bitstream. In general programmable circuitry is not operational or functional without first loading a configuration bitstream into the IC. The configuration bitstream effectively implements or instantiates a particular circuit design within the programmable circuitry. The circuit design specifies for example functional aspects of the programmable circuit blocks and physical connectivity among the various programmable circuit blocks.

Circuitry that is hardwired or hardened i.e. not programmable is manufactured as part of the IC. Unlike programmable circuitry hardwired circuitry or circuit blocks are not implemented after the manufacture of the IC through the loading of a configuration bitstream. Hardwired circuitry is generally considered to have dedicated circuit blocks and interconnects for example that are functional without first loading a configuration bitstream into the IC e.g. PROC .

In some instances hardwired circuitry may have one or more operational modes that may be set or selected according to register settings or values stored in one or more memory elements within the IC. The operational modes may be set for example through the loading of a configuration bitstream into the IC. Despite this ability hardwired circuitry is not considered programmable circuitry as the hardwired circuitry is operable and has a particular function when manufactured as part of the IC.

In the case of an SOC the configuration bitstream may specify the circuitry that is to be implemented within the programmable circuitry and the program code that is to be executed by PROC or a soft processor. In some cases architecture includes a dedicated configuration processor that loads the configuration bitstream to the appropriate configuration memory and or processor memory. The configuration processor unlike PROC when included does not execute user program code. In other cases architecture may utilize PROC to receive the configuration bitstream load the configuration bitstream into appropriate configuration memory and or extract program code for execution.

In another aspect system may represent a runtime heterogeneous multiprocessor system where the processor functions as the host and the programmable IC implements one or more kernels. A heterogeneous multiprocessor system as defined herein is a computing system that includes two or more processors. The two or more processors may be different types of processors. For example the heterogeneous multiprocessor system may include a central processing unit CPU a graphics processing unit GPU a digital signal processor DSP a programmable IC such as an FPGA or the like. The heterogeneous multiprocessor system may be an OpenCL system.

As pictured system includes at least one processor e.g. a central processing unit CPU coupled to memory elements through a system bus or other suitable circuitry. System stores program code within memory elements . Processor executes the program code accessed from memory elements via system bus . In one aspect system is implemented as a computer or other data processing system that is suitable for storing and or executing program code. It should be appreciated however that system may be implemented in the form of any system including a processor and memory that is capable of performing the functions described within this disclosure. Further system may be implemented as one or more networked data processing systems e.g. servers.

Memory elements include one or more physical memory devices such as for example a local memory and one or more bulk storage devices . Local memory refers to random access memory RAM or other non persistent memory device s generally used during actual execution of the program code. Bulk storage device may be implemented as a hard disk drive HDD solid state drive SSD or other persistent data storage device. System may also include one or more cache memories not shown that provide temporary storage of at least some program code in order to reduce the number of times program code must be retrieved from bulk storage device during execution.

Input output I O devices such as a keyboard a display device and a pointing device optionally may be coupled to system . The I O devices may be coupled to system either directly or through intervening I O controllers. A network adapter may also be coupled to system to enable system become coupled to other systems computer systems remote printers remote storage devices and or a target platform through intervening private or public networks. Modems cable modems Ethernet cards and wireless transceivers are examples of different types of network adapter that may be used with system . A communication port such as a Universal Serial Bus port a FireWire port a Peripheral Component Interconnect PCI and or PCI Express PCIe port or the like also may be coupled to system to allow system to become coupled to another system such as any of the aforementioned systems including target platform .

In one aspect memory elements store an electronic design automation EDA application . EDA application may be stored for example in an implementation where system represents a compile time system. EDA application may include one or more different components or modules. EDA application being implemented in the form of executable program code is executed by system . As such EDA application is considered an integrated part of system . EDA application and any data items used generated and or operated upon by system while executing EDA application are functional data structures that impart functionality when employed as part of system . As a compile time system host application may be excluded from system .

In the case of a compile time system a user works through system executing EDA application . System may receive a heterogeneous multiprocessor design as an input and synthesize one or more kernels of heterogeneous multiprocessor design into circuitry that may be implemented within IC . System may generate and output a binary container . In one aspect binary container may include a description of the contents therein and one or more configuration bitstreams whether partial or full. In another aspect binary container may include a description of the contents therein one or more executable simulation files and or one or more register transfer level RTL files that may be simulated within an RTL or hardware description language simulator. In that case binary container may include in addition to the executable simulation file s and or the RTL file s one or more configuration bitstreams whether partial or full. Binary container may be stored in memory elements and or provided to another system by way of network adapter and or communication port .

In another aspect memory elements store a host application . Host application may be stored for example in an implementation where system represents a heterogeneous multiprocessor runtime system. Host application may include one or more different components or modules. Host application being implemented in the form of executable program code is executed by system . As such host application is considered an integrated part of system . Host application and any data items used generated and or operated upon by system while executing host application are functional data structures that impart functionality when employed as part of system . As a runtime system EDA application may be excluded from system .

System may be coupled to target platform through a communication link . In the case of a runtime system implementation target platform is coupled to or considered part of system . Thus it should be appreciated that in the case of a compile time system target platform may be excluded. Continuing with target platform communication link may be implemented as any of a variety of different wired and or wireless connections that are operable to couple to communication port and or network adapter .

Target platform may be implemented as a circuit board such as a printed circuit board having circuitry implemented thereon. Target platform may be implemented as a card that may be plugged into a mechanical connector for communication port e.g. within system or external to system . Target platform may include a connector that couples to communication link . The connector may be coupled using circuitry of target platform to an IC .

IC may be coupled to target platform using a socket a receptacle another mounting technique such as soldering IC directly to target platform or the like. IC couples to communication link through target platform . In one aspect IC is a programmable IC. IC for example may be implemented using the architecture described with reference to . In another aspect IC may be implemented as an SOC. IC may implement one or more kernels of a heterogeneous multiprocessor design as circuitry. The heterogeneous multiprocessor design may be an OpenCL design.

In the case of a runtime system processor may operate as the host. One or more kernels of a heterogeneous multiprocessor design may be implemented within IC . During operation new and or different kernels may be implemented within IC as needed since IC may be configured or re configured as the case may be dynamically while in operation without causing interruption to other portions of IC that are not being configured or re configured as the case may be.

IC includes a static region and a kernel region . In one aspect static region includes infrastructure IP needed to support the heterogeneous multiprocessor programming model. In one example the heterogeneous multiprocessor programming model is an OpenCL model. Static region for example communicatively links kernel region with other components located on target platform such as RAM and or other systems such as the host e.g. processor during runtime. Static region for example may implement a software interface used to communicate with the host. In one aspect static region may be a circuit implementation that is provided by the vendor and or manufacturer of target platform .

Kernel region represents the portion of IC where kernels are implemented. In one aspect kernel region may have a memory mapped interface with static region . Kernel region unlike static region may be dynamically generated and integrated with static region . For example different kernels and different combinations of kernels may be implemented at different times within kernel region during runtime.

Target platform software layer executing in circuitry of target platform communicates with static region through a target platform specific programming interface e.g. a hardware programming interface. Static region provides kernel region with clock and reset signals . Static region also provides information to kernel region through a memory mapped slave interface that is coupled to a control register not shown . Kernel region provides information to static region through a memory mapped bus master interface that is coupled to RAM .

As pictured static region may include a bus endpoint coupled to a bus direct memory access DMA controller . Bus DMA controller is coupled to interconnect . Interconnect couples to interconnect and to kernel region . Interconnect couples to kernel region and to memory controller . Memory controller couples to RAM which is implemented off chip IC .

Bus endpoint is configured to communicate over a bus with the host of the heterogeneous multiprocessor design. Bus DMA controller may be included to support DMA functionality between host RAM e.g. local memory and RAM on target platform . In one aspect bus DMA controller includes a master interface . Interconnect may include a slave interface and master interfaces and . As shown slave interface is coupled to master interface . Kernel region includes a slave interface and a master interface . Master interface of interconnect is coupled to slave interface of kernel region .

Interconnect includes slave interfaces and and a master interface . Memory controller includes a slave interface . As pictured master interface of interconnect is coupled to slave interface of interconnect . Master interface of kernel region is coupled to slave interface of interconnect .

Interconnects and are circuit blocks configured to couple two or more other circuit blocks together. In one aspect interconnects and may be implemented as circuit blocks that couple one or more memory mapped master devices with one or more memory mapped slave devices. An example of an interconnect circuit block implementation is one that conforms to the AMBA AXI version 4 specifications from ARM Ltd. of Cambridge UK. It should be appreciated however that other interconnect types and or technologies may be used to implement interconnects and . The disclosure is not intended to be limited by the exemplary interconnect circuit blocks provided.

Within the architecture illustrated in bus DMA controller and kernel region function as masters for memory controller . Interconnect allows the host for example to read and write RAM over the bus. Interconnect supports the creation of two bus masters i.e. bus DMA controller and kernel region for memory controller .

Kernel Region may initially be implemented as a container for compiled heterogeneous multiprocessor design kernels. In one aspect kernel region may be implemented as a hierarchical IP having a placeholder for compiled kernels. One or more kernels may be included within kernel region . In one example up to 16 kernels may be included in kernel region . Commands from the host may be received through slave interface . Kernel region may provide commands to memory controller through master interface . Clock and reset signals are provided to kernel region and to any kernels implemented therein through the connection between master interface and slave interface .

Kernel circuitries collectively illustrated as kernel circuitry through N may represent a plurality of instances of same kernel circuitry and as such a plurality of instances of a same kernel. In another example kernel circuitries may represent two or more different kernel circuitries. In still another example kernel circuitries may represent one or more instances of a first kernel circuitry and one or more additional different kernel circuitries. Interconnect has a slave interface that couples to a master interface and of each kernel circuitry . Interconnect includes master interface that couples to slave interface of interconnect .

In one aspect interconnects and may support up to 16 different instances of kernel circuitry 16 different kernel circuitries or a combination thereof not to exceed 16. As discussed the particular number of kernels and or kernel instances that may be implemented within kernel region is provided for purposes of illustration and not limitation.

Within a heterogeneous multiprocessor framework such as OpenCL parallel kernel invocation may be described as a 1 2 or 3 D index space referred to as an NDRange. The NDRange is subdivided into work groups. Work groups include multiple work items. For example each point in the NDRange is referred to as a work item.

The kernel of a heterogeneous multiprocessor design is compiled into one or more compute units. The system designer e.g. a user determines the number of compute units that are to be implemented in parallel for a given kernel. In one aspect the number of compute units for the kernel indicates the number of instances of the kernel circuitry implemented within kernel region and operating in parallel. Each compute unit is able to process one work group as determined and provided by the host.

In the example of each kernel circuitry block through N represents the circuitry of a work unit. Kernel circuitry blocks through N may represent work units of a same kernel e.g. multiple instances operating in parallel or work units of two or more kernels operating in parallel where one or more of the kernels are implemented within kernel region with multiple instances.

In block the system generates an RTL description of the kernel. The RTL description may be specified using a hardware description language HDL . As defined herein the term hardware description language or HDL is a computer language that facilitates the documentation design and manufacturing of a digital system such as an integrated circuit. An HDL combines program verification techniques with expert system design methodologies. Using an HDL for example a user can design and specify an electronic circuit describe the operation of the circuit and create tests to verify operation of the circuit. An HDL includes standard text based expressions of the spatial and temporal structure and behavior of the electronic system being modeled. HDL syntax and semantics include explicit notations for expressing concurrency. In contrast to most high level programming languages an HDL also includes an explicit notion of time which is a primary attribute of a digital system.

In block the system integrates the RTL description of the kernel with a base platform. In one aspect the base platform may be similar to or the same as the circuit design implemented within static region and described with reference to and or .

In block the system generates a configuration bitstream and supporting data. The configuration bitstream specifies a hardware implementation of the kernel e.g. the compute units as described with reference to . In one aspect the configuration bitstream may be a partial bitstream that specifies only the kernel or one or more kernels for example. In another aspect the configuration bitstream may be a full bitstream that specifies the kernel or kernels as the case may be and the base platform.

The supporting data describes the configuration bitstream and or the contents of the configuration bitstream. In one aspect the supporting data may specify a list of IP blocks and or cores included in the kernel implementation. In another aspect the supporting data may specify a two dimensional coordinate location within the programmable IC at which the hardware implementation of the kernel will be implemented when specified as a partial configuration bitstream.

In block the system includes the configuration bitstream and the supporting data within a binary container. In one aspect the binary container may include multiple individual files. For example the binary container may include one or more configuration bitstreams and one or more supporting data files.

In another aspect RTL descriptions of the kernel s may be included within the binary container. The RTL descriptions may then be used with an RTL simulator to test the kernel implementations as part of an overall heterogeneous multiprocessor design simulation. For example the host may provide the binary container including the RTL description s to the RTL simulator during a runtime simulation of the heterogeneous multiprocessor design. The RTL simulator may access the RTL descriptions from the binary container. In still another aspect an executable version of the kernel s may be included in the binary container that may be executed using a processor for testing and or simulation purposes. For example the host may provide the binary container including the executable version of the kernel to a simulator during a runtime simulation of the heterogeneous multiprocessor design. It should be appreciated that the executable version of the kernel may be an executable model of a hardware implementation of the kernel. The simulator may access the executable version of the kernel from the binary container. Thus the binary container supports multiple different kernel implementations whether as configuration bitstreams for runtime with a programmable IC executable versions for simulation on a data processing system and or RTL versions for simulation using an RTL simulator.

The binary container may include only configuration bitstream s only executable version s of the kernel s only RTL version s of the kernel s a configuration bitstream and an RTL version of the kernel a configuration bitstream and an executable version of the kernel an executable and RTL versions of the kernel s or a configuration bitstream an executable version of the kernel s and RTL versions of the kernel s . The supporting data also may be included for any of the aforementioned combinations of kernel versions implemented within the binary container. Existing containers used by CPU and or GPU vendors in heterogeneous multiprocessor designs and in particular OpenCL designs work with in memory and address mapped objects. Such containers do not support simulation versions of the kernel or multiple different kernel types within the same container.

While the binary container used may support multiple different types of kernel implementations in one aspect a first container may include a first type of kernel implementation e.g. a configuration bitstream an RTL description or an executable while a second binary container may include a different type of kernel implementation. In still another aspect a first container may include a partial configuration bitstream specifying a first kernel while a second container may include a partial configuration bitstream specifying a second and different kernel.

Standard APIs for a heterogeneous multiprocessor computing language such as OpenCL for communication between host and kernels support only binary object files. The binary container generated by the system complies with this binary requirement that all pre compiled kernels are to be accessible through a self contained object. The binary container generated in block may be used by the host to implement kernel circuitry e.g. compute units within the programmable IC during runtime.

As shown heterogeneous multiprocessor design e.g. also referred to as a heterogeneous multiprocessor application an OpenCL design or an OpenCL application may include host code and kernel . It should be appreciated that while one kernel is pictured heterogeneous multiprocessor design may include more than one kernel that may be implemented through process . Host code is the portion of heterogeneous multiprocessor design that executes in the host. Host code may be specified in a high level programming language such as C C or the like.

As defined herein the term high level programming language means a programming language or set of instructions used to program a data processing system where the instructions have a strong abstraction from the details of the data processing system e.g. machine language. For example a high level programming language may automate or hide aspects of operation of the data processing system such as memory management. The amount of abstraction typically defines how high level the programming language is. When a high level programming language the user need not contend with registers memory addresses etc. of the data processing system upon which the high level programming language will execute. In this regard a high level programming language includes little or no instructions that translate directly on a one to one basis into a native opcode of a data processing system. Examples of high level programming languages include but are not limited to C C SystemC or the like.

Host code is provided to C compiler or other high level language compiler. C compiler generates an object code version of host code depicted as App.o . Linker receives a heterogeneous multiprocessor runtime library app.o and generates a host application . Heterogeneous multiprocessor runtime library may include a common low level driver used to communicate with the target platform. Host application is executed by the CPU of a runtime heterogeneous multiprocessor system.

Heterogeneous multiprocessor high level synthesis block receives kernel and generates kernel.hdl . Kernel.hdl is an RTL version of kernel . System assembler receives kernel.hdl and base platform description . In one aspect base platform description may be a metadata file describing aspects of the actual base platform. As noted the base platform is the circuitry implemented within static region of programmable IC .

From base platform description system assembler for example determines the target platform and the particular type of programmable IC to be used for kernel implementation. For example system assembler may identify a directory that specifies implementation details about the base platform and the low level driver needed by the host to communicate with the target platform and base platform. The identified directory may include one or more packaged IPs of the base platform. System assembler may retrieve the packaged IPs of the base platform including interconnect IPs coupling the base platform with the kernel. The interconnect IPs for example may specify the various interconnect circuit blocks needed to integrate or incorporate kernel.hdl with the packaged IPs of the base platform. System assembler generates binary container . System assembler may generate a configuration bitstream specifying a hardware implementation of kernel that integrates with the base platform that is included in binary container .

Each configuration bitstream included in binary container for example may implement one or more compute units determined from kernel or kernel.hdl as the case may be. As discussed the system designer determines the number of compute units that are to be implemented in parallel for a given kernel.

System assembler depending upon user preference may include kernel.hdl e.g. an RTL version of kernel for RTL simulation and or an executable e.g. an object code version of kernel for simulation within binary container as previously described. System assembler also includes the supporting data not shown within binary container .

In one aspect system assembler integrates kernel with the base platform. System assembler having information specified in base platform description and kernel.hdl for example may integrate kernel with the base platform by performing functions such as technology mapping placement routing etc. resulting in a configuration bitstream. The configuration bitstream may be a full configuration bitstream specifying both the base platform and the kernel or a partial configuration bitstream specifying only the kernel. In any case system assembler uses the specified interconnect IPs to couple the base platform with the kernel.

In still another aspect system assembler may generate binary container to include files other than a configuration bitstream. For example as noted kernel may be provided to a heterogeneous multiprocessor compiler that generates a processor executable e.g. an object code version of kernel . The executable version of kernel e.g. an executable model of a hardware implementation of kernel may be provided to system assembler . System assembler may include the executable version of kernel within binary container in place of the configuration bitstream. In another example system assembler may include kernel.hdl within binary container in place of the configuration bitstream.

In block the system identifies and maps memory accesses of the kernel. The heterogeneous multiprocessor global memory may be mapped to a master memory bus. For example the OpenCL global memory may be mapped to an AXI master memory bus. Kernel parameters may be mapped to a slave control bus. For example the kernel parameters may be mapped to an AXI slave control bus.

In block the system identifies parameters utilized by the kernel and includes the parameters within a memory map for the hardware implementation of the kernel in the IC. In block the system correlates variables to memory structures of the IC as private memory for the kernel. In block the system correlates local memory instructions to memory structures of the IC as local memory for the kernel.

In block the system generates a control flow graph for the kernel. In one aspect the system converts the kernel into LLVM Intermediate Representation IR format. From the LLVM IR format the system generates the control flow graph by identifying data flows therein. In block the system identifies parallel regions of the kernel using the control flow graph. The parallel regions may be isolated in the control flow graph. For example for each parallel region in the control flow graph the region will have one control edge coming into the region and one control edge leaving the region.

In block the system optionally constructs a for loop around each parallel region. Identifying the parallel regions and representing each as a for loop allows the kernel which is a data parallel implementation to be represented as a sequential high level programming language such as C C or the like. In block the system generates a circuit description using pipelining. For example the system by representing the parallel region as a for loop may synthesis the region as a high level programming language such as C C or the like would be synthesized.

IC includes compute units and . While two compute units are pictured in IC it should be appreciated that IC may include fewer than two compute units or more than two compute units. Further the particular compute units and the particular number of compute units implemented within IC may change during runtime. Compute units and are implemented as part of kernel region . For purposes of illustration static region is not shown.

As pictured compute unit includes a local memory processing elements and and private memories and . Local memory is shared by processing elements and . Each of processing units and is coupled to an individual unshared one of private memories and . Compute unit includes a local memory processing elements and and private memories and . Local memory is shared by processing elements and . Each of processing units and is coupled to an individual unshared one of private memories and . Compute units and both have access to global memory and constant memory .

In one exemplary implementation host memory and global memory and constant memory may be implemented using RAM on the target platform host RAM and or one or more cache memories of the host. Local memories and for example may be implemented within IC using one or more BRAMs . Private memories and may be implemented using look up table RAMs included within CLBs .

The allocation of memory structures of IC to memories of memory architecture of is provided for purposes of illustration only. It should be appreciated that during synthesis one or more other memory structures of IC may be used to implement private memory and or local memory depending upon availability of the memory structures of IC and the amount of memory needed.

In another aspect illustrates processing performed in block of . In the example of the system determines that an identifier id is used as illustrated by the get local id 0 function. Pointers for example that are passed into the kernel from the host are specified within a register map implemented within the kernel. Data such as the id is written to the kernel by the host e.g. by the host application executing in the host during runtime. For example the host may write any necessary data such as the id to the appropriate register of the register map of the kernel circuitry .

The system further from analysis of the program code of the kernel identifies any implicit parameters used by the kernel. Examples of implicit parameters that may need to be provided to the kernel from the host include but are not limited to a size of an ND range a size of a work group or the like. In some cases implicit parameters may not be passed through the interface between the host and the kernel. Such parameters however may be passed through the register map.

The system identifies parallel regions of kernel as regions and . As part of recognizing parallelism in block the system may recognize specific instructions and or constructs that control parallelism. The system may identify instances of the barrier instruction within kernel . The barrier instruction for example indicates that all work items must reach the barrier instruction before any work items may proceed beyond the barrier instruction. The barrier instruction may be used as a memory fence or a synchronization mechanism. The system may identify instances of the async work group copy instruction referred to as async herein . The async instruction specifies that all work items must reach the copy with the same arguments. Thus in one aspect the system recognizes parallel regions of kernel by identifying instructions that control parallelism within kernel .

The heterogeneous multiprocessor execution and memory models guarantee that each of regions and may be implemented fully in parallel fully sequentially or in varying combination. The serialization that must be observed occurs with the instructions and or constructs that directly influence parallelism e.g. the barrier and or async instructions.

Heterogeneous multiprocessor HLS as described with reference to generates a custom register map as illustrated above for each kernel that is compiled into RTL. The host may use the register map to pass addresses of buffers e.g. OpenCL buffers in the device memory located on the target platform scalar arguments to the kernel and control signals to control the kernel. The register map may also be used by the host to pass a group id and a group offset to the kernel as required by the OpenCL specification. In one aspect the register map may be included within the binary container that is generated. For example the register map may be part of the supporting data that is incorporated into the binary container previously described.

In one aspect the platform metadata file illustrated above is an implementation of base platform description described with reference to and provided to system linker . As illustrated the platform metadata file specifies the type of target platform or board to which the programmable IC is coupled. Further the platform metadata file indicates the particular features of the programmable IC on the board e.g. the model and or type as well as clock frequencies of particular regions e.g. the static region. Linker may identify the target platform from the platform metadata file and access a directory structure named for the target platform specified in the platform metadata file.

The system may automatically locate any newly added target platform with the files being correctly packaged and added to a designated platform directory of the system. In the example shown driver file.so is the low level driver used by the host to communicate with the target platform over the bus. As illustrated driver file.so is located within the driver directory. The platform metadata file referred to as platform.xml in the example of is placed in the root directory. Any packaged IPs used in the static region of the IC as described with reference to and may be stored in the local lib directory. A base platform block diagram TCL file called bp.tcl and any top level design constraint files e.g. timing and or physical constraints on the static region circuit design are included in the ipi directory.

The common low level driver pictured as driver file.so in may include an API having a plurality of functions. The common low level driver API hereafter driver API allows the heterogeneous multiprocessor runtime program code executing in the host to communicate with the target platform. The driver API for example supports configuration bitstream download into the programmable IC allocating and or de allocating buffers migrating buffers from host memory to target platform memory migrating target platform memory to host memory and communicating with the kernel as implemented within the programmable IC through a control port of the kernel.

The driver API also supports address spaces. The address spaces may be used for accessing peripherals of the target platform. Each peripheral of the target platform for example may have its own memory mapped range of the address space. A target platform optionally may have a flat memory space that may be used to address all peripherals of the target platform.

The driver file.so may support various quantities such as the minimum size of buffer e.g. a DMA buffer that may be read or written on the target platform. Further one or more enumerated address spaces referred to as enums may be supported. Memory operations may use flat addressing or relative addressing. Exemplary enums may include but are not limited to XCL ADDR SPACE DEVICE FLAT XCL ADDR SPACE DEVICE RAM XCL ADDR KERNEL CTRL and XCL ADDR SPACE MAX.

The driver API supports configuration bitstream load operations with the operation int xclLoadBitstream xclDeviceHandle handle const char fileName . As such the host may initiate loading of a configuration bitstream whether full or partial into the IC to implement one or more different kernels in hardware as needed during runtime.

The driver API provides various operations for managing memory of the target platform. The vendor of the target platform for example is required to provide memory management with the following APIs 

The operation xclAllocDeviceBuffer allocates a buffer of the specified size on the target platform and returns the offset of the allocated buffer in the target platform RAM as a return value. The offset acts as buffer handle. The OpenCL runtime will subsequently pass the returned handle to the OpenCL kernel. The OpenCL kernel will use the returned handle to perform bus master read and or write operations on the allocated buffer in the target platform RAM. The host does not write to the target platform RAM directly. In the event that there are no free blocks remaining the function should return 1.

The operation xclFreeDeviceBuffer frees the memory previously allocated by xclAllocDeviceBuffer. The freed memory may be reused later for another call to xclAllocDeviceBuffer. An error condition results from passing a buffer handle not previously allocated by xclAllocDeviceBuffer.

The operation xclCopyBufferHost2Device copies the contents of the host buffer into a destination buffer resident on the target platform. The element src refers to the host buffer pointer and dest refers to the device buffer handle. An error results in passing a dest handle not previously allocated by xclAllocDeviceBuffer. The element seek specifies the offset in the dest handle. An error results from passing size where size plus seek is greater than the size of the device buffer previously allocated. In the examples provided a PCIe DMA is used to migrate the buffers.

The operation xclCopyBufferDevice2Host copies the contents from the target platform resident buffer to the host buffer. The element srs refers to the device buffer handle and the element dest refers to the host buffer pointer. An error results from passing a src handle not previously allocated by xclAllocDeviceBuffer. The element skip specifies the offset in src handle. An error results from passing size where size plus skip is greater than the size of device buffer previously allocated. In the examples provided a PCIe DMA is used to migrate the buffer.

The operation xclWrite copies the contents of the host buffer hostBuf to a specific location in the target platform address map. The contents of hostBuf is used to program peripherals of the target platform. For example the OpenCL runtime executing in the host uses this operation to send the arguments to the kernel within the programmable IC. The offsets are relative to the address space.

The operation xclRead copies data from a specific location in the target platform address map to the host buffer hostBuf. The operation is used to read the status of peripherals of the target platform. For example the OpenCL runtime library uses this operation to determine whether the kernel is finished running. The offsets are relative to the address space.

The operating system of the host needs a kernel DMA driver to communicate with the target platform. In one aspect the common low level driver API may be layered on top the kernel DMA driver to insulate the OpenCL runtime from the details of the driver. The driver should be multi threading safe. The OpenCL runtime optionally uses more than one thread to read and write to the device at the same time.

In another aspect the driver API may include interrupt functions. For example the register map for the kernel may include one or more memory locations at which a flag may be stored by the kernel. Detection of the flag at the designated memory location of the register map may cause the static region to trigger an interrupt to the host through a function provided as part of the driver API.

While the examples illustrated above are directed to an OpenCL implementation it should be appreciated that any heterogeneous multiprocessor computing language may be used and that the various operations described as part of the API may be adapted accordingly.

In block the host application is initialized. The host application includes the heterogeneous multiprocessor runtime library as illustrated in . In block the host application allocates buffers in host memory. In block the host application initiates a transfer to send the buffer contents from the host memory to the target platform memory.

In block the host application signals the kernel through the slave interface to start operating. In block the host application optionally starts polling the target platform to monitor for a done signal. In block the kernel i.e. the hardware implementation of the kernel executes or begins to operate. The kernel loads and stores data from the target platform memory. In block the kernel changes the status in the memory map register to done responsive to finishing processing or generates an interrupt. In block the host application transfers the updated buffer contents of the target platform memory i.e. the results to the host memory. In block the heterogeneous multiprocessor runtime e.g. executing in the host or host application reads the buffer from the host memory.

For purposes of explanation specific nomenclature is set forth to provide a thorough understanding of the various inventive concepts disclosed herein. The terminology used herein however is for the purpose of describing particular aspects of the inventive arrangements only and is not intended to be limiting.

As defined within this disclosure the terms a and an mean one or more than one. The term plurality as defined herein means two or more than two. The term another as defined herein means at least a second or more. The term coupled as defined herein means connected whether directly without any intervening elements or indirectly with one or more intervening elements unless otherwise indicated. Two elements may also be coupled mechanically electrically or communicatively linked through a communication channel pathway network or system.

As defined herein the term automatically means without user intervention. As defined herein the term user means a human being. The term and or as defined herein means any and all possible combinations of one or more of the associated listed items. The terms includes and or including when used in this disclosure specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof. Although the terms first second etc. may be used herein to describe various elements these elements should not be limited by these terms as these terms are only used to distinguish one element from another unless the context indicates otherwise.

As defined herein the term if means when upon in response to determining in response to detecting responsive to determining or responsive to detecting depending on the context. Similarly the phrase if it is determined or the phrase if a stated condition or event is detected as defined herein means upon determining in response to determining responsive to determining upon detecting the stated condition or event in response to detecting the stated condition or event or responsive to detecting the stated condition or event depending on the context.

Within this disclosure the same reference characters are used to refer to terminals signal lines wires and their corresponding signals. In this regard the terms signal wire connection terminal and pin may be used interchangeably from time to time within this disclosure. It also should be appreciated that the terms signal wire or the like may represent one or more signals e.g. the conveyance of a single bit through a single wire or the conveyance of multiple parallel bits through multiple parallel wires. Further each wire or signal may represent bi directional communication between two or more components connected by a signal or wire as the case may be.

One or more aspects described within this disclosure may be realized in hardware or a combination of hardware and software. One or more aspects may be realized in a centralized fashion in one system or in a distributed fashion where different elements are spread across several interconnected systems. Any kind of data processing system or other apparatus adapted for carrying out at least a portion of the methods described herein is suited.

One or more aspects further may be embedded in a computer program product which includes all the features enabling the implementation of the methods described herein. The computer program product includes a computer readable data storage medium. As defined herein the phrase computer readable storage medium means a storage medium that contains or stores program code for use by or in connection with an instruction execution system apparatus or device. As defined herein a computer readable storage medium is non transitory and as such is not a transitory propagating signal per se. Examples of a computer readable storage medium may include but are not limited to optical media magnetic media magneto optical media computer memory such as RAM a bulk storage device e.g. hard disk or the like.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various aspects of the inventive arrangements disclosed herein. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which includes one or more executable instructions for implementing the specified function s . It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

In one aspect the blocks in the flow chart illustration may be performed in increasing numeric order corresponding to the numerals in the various blocks. In other aspects the blocks may be performed in an order that is different or that varies from the numerals in the blocks. For example two or more blocks shown in succession may be executed substantially concurrently. In other cases two or more blocks may sometimes be executed in the reverse order depending upon the functionality involved. In still other cases one or more blocks may be performed in varying order with the results being stored and utilized in subsequent or other blocks that do not immediately follow.

The terms computer program software application computer usable program code program code executable code variants and or combinations thereof in the present context mean any expression in any language code or notation of a set of instructions intended to cause a data processing system to perform a particular function either directly or after either or both of the following a conversion to another language code or notation b reproduction in a different material form. For example program code may include but is not limited to a subroutine a function a procedure an object method an object implementation an executable application an applet a servlet source code object code a shared library dynamic load library and or other sequence of instructions designed for execution on a computer system.

Thus throughout this disclosure statements utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a data processing system e.g. a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and or memories into other data similarly represented as physical quantities within the computer system memories and or registers or other such information storage transmission or display devices.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed.

A method includes generating using a processor an RTL description of a first kernel of a heterogeneous multiprocessor design integrating the RTL description of the first kernel with a base platform circuit design providing a static region within a programmable IC that provides an interface to a host of the heterogeneous multiprocessor design and generating from the RTL description of the first kernel and using the processor a first configuration bitstream specifying a hardware implementation of the first kernel and supporting data for the configuration bitstream. The method also includes including the first configuration bitstream and the supporting data within a binary container.

In one example the heterogeneous multiprocessor design is an OpenCL design and the first kernel is specified in OpenCL.

In one aspect the supporting data includes a two dimensional location of the hardware implementation of the first kernel as implemented within the programmable IC.

The method may include loading the configuration bitstream of the first kernel creating an instance of the hardware implementation of the first kernel within the programmable IC during runtime of the heterogeneous multiprocessor design.

The method may also include loading the configuration bitstream of the first kernel creating a plurality of instances of the hardware implementation of the first kernel within the programmable IC during runtime of the heterogeneous multiprocessor design.

The method further may include including a second configuration bitstream specifying a hardware implementation of a second kernel of the heterogeneous multiprocessor design within a second binary container. At least one instance of the hardware implementation of the second kernel may be created within the programmable IC.

In one aspect generating the first configuration bitstream may include generating the first configuration bitstream as a partial configuration bitstream specifying kernel circuitry. In another aspect generating the first configuration bitstream may include generating the first configuration bitstream as a full configuration bitstream specifying the kernel circuitry and base platform circuitry.

A method includes generating using a processor an RTL description of a first kernel of a heterogeneous multiprocessor design integrating the RTL description of the first kernel with a base platform circuit design providing a static interface within a programmable IC to a host of the heterogeneous multiprocessor design and generating from the RTL description of the first kernel and using the processor supporting data for the RTL description of the first kernel. The method also includes including the RTL description of the first kernel and the supporting data within a binary container.

In one example the heterogeneous multiprocessor design is an OpenCL design and the first kernel is specified in OpenCL.

The method may include generating an executable version of the kernel and including the executable version of the kernel within the binary container.

The method may also include a host providing the RTL description from the binary container during runtime to an RTL simulator and simulating the RTL description of the kernel in the RTL simulator.

The method further may include including an RTL description of a second kernel of the heterogeneous multiprocessor design within a second binary container.

A system may include a processor programmed to initiate executable operations. The executable operations include generating an RTL description of a first kernel of a heterogeneous multiprocessor design integrating the RTL description of the first kernel with a base platform circuit design providing a static region within a programmable IC that provides an interface to a host of the heterogeneous multiprocessor design and generating from the RTL description of the first kernel a first configuration bitstream specifying a hardware implementation of the first kernel and supporting data for the configuration bitstream. The method may also include including the first configuration bitstream and the supporting data within a binary container.

In one example the heterogeneous multiprocessor design is an OpenCL design and the first kernel is specified in OpenCL.

The supporting data may include a two dimensional location of the hardware implementation of the first kernel as implemented within the programmable IC.

The executable operations may include loading the configuration bitstream of the first kernel creating an instance of the hardware implementation of the first kernel within the programmable IC during runtime of the heterogeneous multiprocessor design.

The executable operations may also include loading the configuration bitstream of the first kernel creating a plurality of instances of the hardware implementation of the first kernel within the programmable IC during runtime of the heterogeneous multiprocessor design.

The executable operations further may include including a second configuration bitstream specifying a hardware implementation of a second kernel of the heterogeneous multiprocessor design within a second binary container. The executable operations may include creating at least one instance of the hardware implementation of the second kernel within the programmable IC.

In one aspect generating the first configuration bitstream may include generating the first configuration bitstream as a partial configuration bitstream specifying kernel circuitry. In another aspect generating the first configuration bitstream may include generating the first configuration bitstream as a full configuration bitstream specifying the kernel circuitry and base platform circuitry.

The features described within this disclosure may be embodied in other forms without departing from the spirit or essential attributes thereof. Accordingly reference should be made to the following claims rather than to the foregoing disclosure as indicating the scope of such features and implementations.

