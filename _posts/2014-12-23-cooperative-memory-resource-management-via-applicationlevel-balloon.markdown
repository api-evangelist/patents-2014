---

title: Cooperative memory resource management via application-level balloon
abstract: Methods, systems, and computer programs for managing memory in a host where virtual machines (VMs) execute are presented. In one example, a method includes an operation for determining which amount of heap memory has been reserved in a Java virtual machine (JVM) that is in excess of the heap memory needed by the JVM. If there is excess heap memory, a Java balloon agent reserves a Java object in the heap memory. Typically, the Java object will be the size of one or more memory pages in the host. Further, the Java balloon agent loads the Java object with a certain value, for example, by zeroing out the page of memory. When a virtual machine monitor (VMM) in the host detects that a machine physical memory page associated with the Java object has the first value, then the VMM frees the machine physical memory page to make the memory available to other VMs or to other processes executing in the host.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09529611&OS=09529611&RS=09529611
owner: VMware, Inc.
number: 09529611
owner_city: Palo Alto
owner_country: US
publication_date: 20141223
---
This application is a continuation of U.S. patent application Ser. No. 12 826 389 filed Jun. 29 2010 which is related to U.S. Pat. No. 7 716 446 issued May 11 2010 U.S. Pat. No. 8 359 451 issued Jan. 22 2013 and U.S. Pat. No. 7 702 843 issued Apr. 20 2010. Each of the aforementioned patent application and patents is incorporated by reference herein in its entirety.

The present invention relates to methods for managing memory in a host and more particularly to methods systems and computer programs for cooperative memory management via application level balloons.

Virtual computing environments allow multiple virtual machine VM guests to be run on a single physical platform and to share physical resources. Some virtual computing environments allow configuring the VMs in a way where the total amount of memory designated for used by the VMs is bigger than the actual amount of memory available on the host. This is referred to as memory over commitment and it allows packing more VMs onto a single host.

Memory over commitment is one of the key benefits of virtualization. In some implementations if a VM is not using all of its allocated physical memory the VM is charged an idle tax so some physical memory is taken away from the VM and made available to others VMs or other processes in the host.

To achieve over commitment the virtual infrastructure gives a VM less memory than what the guest Operating System OS in the VM believes it has. This can be done by using what is called a balloon application. A balloon is a resource reservation application that runs as a guest application in the VM and that requests guest virtual memory from the guest operating system. By reserving guest virtual memory the balloon application assists with the reclamation of physical memory. In some implementations a balloon driver is installed in the guest OS to facilitate communications with the virtual infrastructure.

Another mechanism for memory management is called swapping where the virtual infrastructure transparently unmaps i.e. takes away machine memory pages from the guest OS swaps the content to disk and swaps the pages back to physical memory if the guest OS accesses these pages. Both ballooning and swap may impact the performance of applications inside the guest since there is less machine memory to use. However as long as an application s active working set fits into the VM s memory share the application will not suffer significant performance loss.

Unfortunately there are applications that do not work well with memory over commitment. Java Virtual Machine JVM is one of the most widely used applications in this category. JVMs have their own memory management mechanisms. Allocated Java objects sit in a JVM heap until JVM runs out of heap space and in this event Garbage Collection GC sweeps the heap and recycles dead objects which are the objects unreachable from the program. GC is notoriously bad for memory over commitment because the heap becomes cluttered and fragmented over time which means that there is no way of knowing which memory pages can be used for memory management. Attempts to over commit the memory may result in a lack of memory to back up the JVM heap causing a significant performance hit.

Java is widely deployed in production environments and there is an increasing demand to consolidate a large number of VMs running Java applications such as Apache Tomcat Servers on to a physical server. As these applications are typically lightly loaded the consolidation ratio can be very high leaving a small amount of physical memory for each VM.

Some commercial JVM implementations shrink the heap size when the application does not demand a high amount of memory. However their mechanisms are not collaborative. The system has to wait for JVM to voluntarily shrink its heap instead of having JVM reducing the heap upon request which does not perform well when using the balloon mechanism.

Embodiments of the present invention provide methods systems and computer programs for managing memory in a host where virtual machines VMs execute. An application level balloon also referred to herein as a Java balloon is deployed inside the Java Virtual Machine JVM . When the VM kernel needs to take memory away from the VM the Java balloon expands with the effect of making the JVM heap smaller at runtime. To avoid Out Of Memory OOM errors the Java balloon shrinks by returning memory back to the JVM heap when the Java application is under memory pressure.

It should be appreciated that the present invention can be implemented in numerous ways such as a process an apparatus a system a device or a method on a computer readable medium. Several inventive embodiments of the present invention are described below.

In one embodiment a method for managing memory in a host where VMs execute is provided. The method includes an operation for determining which amount of heap memory has been reserved in a JVM that is in excess of the heap memory needed by the JVM. If there is excess heap memory a Java balloon agent reserves a Java object in the heap memory. Typically the Java object will be the size of one or more memory pages in the host. Further the Java balloon agent loads the Java object with a certain value for example by zeroing out the Java object. When a virtual machine monitor VMM in the host detects that a machine physical memory page associated with the Java object has the first value then the VMM frees the machine physical memory page to make the memory available to other VMs or to other processes executing in the host. In another embodiment a computer program performs the method operations.

In another embodiment a method for managing memory in a host where VMs execute includes an operation for determining an amount of heap memory that has been reserved in a JVM and that is in excess of the heap memory needed by the JVM. A Java balloon agent reserves a Java object with a size equal to the size of one or more pages of memory in the host in the heap memory and then obtains the virtual address of the Java object. Additionally the method includes an operation for identifying the physical page number that corresponds to the virtual address. The physical page number is sent to a VMM which frees the machine physical memory page associated with the physical page number.

In yet another embodiment a system for managing memory in a host where VMs execute includes one or more VMs and a VMM. Each of the VMs includes a JVM and a Java balloon agent executing on the JVM. The Java balloon agent determines the amount of heap memory that has been reserved in the JVM and that is in excess of heap memory needed by the JVM. The Java balloon agent reserves in heap memory a Java object with a size equal to the size of one or more memory pages in the host. The Java balloon agent also loads the Java object with a first value such as by zeroing out the page of memory. Further the VMM frees the machine physical memory page associated with the Java object when the VMM detects that the machine physical memory page has the first value.

Other aspects of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of the invention.

Methods systems and computer programs for managing memory in a host where virtual machines VMs execute are provided. In one embodiment a method includes an operation for determining which amount of heap memory has been reserved in a Java Virtual Machine JVM that is in excess of the heap memory needed by the JVM. If there is excess heap memory a Java balloon agent reserves a Java object in the heap memory. Typically the Java object will be the size of one or more memory pages in the host. The Java balloon agent loads the Java object with a certain value for example by zeroing out the page of memory and when a virtual machine monitor VMM in the host detects that a machine physical memory page associated with the Java object has the first value then the VMM frees the machine physical memory page to make the memory available to other VMs or to other processes executing on the host.

It will be obvious however to one skilled in the art that the present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present invention.

In one embodiment the VM memory is controlled using a Java agent also referred to herein as a Java balloon or a Java balloon agent a Java Native Interface JNI library and a kernel driver. It should be noted that no modification to the guest OS or to the JVM is required. In operation a kernel balloon driver receives a balloon target from the hypervisor decides how much to shrink the Java heap and sets a Java balloon target. The Java agent which is attached to the running Java application via a management interface periodically checks this Java balloon target to determine if more or less balloon memory is required. The agent expands the balloon by allocating Java array objects also referred to herein as Java objects. Since the agent executes as a normal Java thread the objects are allocated from the Java heap effectively reducing the Java heap size. The agent then passes the Java object references to the JNI library which finds the virtual address of the array objects and passes the addresses to the hypervisor. The hypervisor then reclaims the memory pages used by these objects such as by sharing the reclaimed pages as Copy On Write COW pages.

COW is an optimization strategy where multiple callers ask for resources which are initially indistinguishable and where the multiple callers are given pointers to the same resource. This function can be maintained until a caller tries to modify its copy of the resource at which time a true private copy is created to prevent the changes from becoming visible to other callers. All of this is transparent to all the callers. The primary advantage of COW is that if a caller never makes any modifications no private copy needs to be created. COW finds its main use in virtual memory operating systems. When a process creates a copy of itself the pages in memory that might be modified by either the process or its copy are marked copy on write. When one process modifies the memory the operating system s kernel intercepts the operation and copies the memory so that changes in one process s memory are not visible to the other.

In one embodiment the Java objects requested by the Java balloon are managed using soft references. This means that a special class of memory is requested that JVM can take away from the Java application. The application can check if the memory is taken away by JVM via predefined interfaces. Thus when the Java heap is under memory pressure these objects will be automatically freed by the Java garbage collector to avoid out of memory errors. If the process loses the memory the process is notified when it tries to access the reclaimed memory.

In many embodiments system software typically is or at least typically includes an operating system OS which has drivers for controlling and communicating with various devices and with the disk . In VM the physical system components of a real computer are emulated in software that is they are virtualized. Thus VM will typically include virtualized guest OS and virtualized system hardware not shown which in turn includes one or more virtual CPUs virtual system memory one or more virtual disks one or more virtual devices etc. all of which are implemented in software to emulate the corresponding components of an actual computer.

The guest OS may but need not simply be a copy of a conventional commodity OS. Balloon driver is a driver installed in VM and is used for communications with the hypervisor enabling the implementation of balloon memory. In general VMs are intended to be capable of running various applications. illustrates a runtime environment running on top of guest OS . Runtime environment has its own memory manager that requests memory from guest OS which has its own methods for managing memory use over time. In one example the runtime environment is a Java Virtual Machine JVM which enables a set of computer software programs and data structures to use a virtual machine model for the execution of other computer programs and scripts. It should be appreciated that embodiments of the invention use JVM as an example Runtime Environment but the same principles can be applied to any application executing on top of the guest OS but has its own memory manager such as databases web servers etc. The embodiments presented should therefore not be interpreted to be exclusive or limiting but rather exemplary or illustrative.

Application executes on the runtime environment such as a Java program executing on a JVM. The interface between VM and the underlying host hardware is responsible for executing VM related instructions and for transferring data to and from the actual physical memory the processor s the disk s and other device s . One such interface between the VM and the underlying host system is often referred to as a Virtual Machine Monitor VMM also known as a virtual machine manager. Page sharing module manages the sharing of pages of memory assigned to VMs as described in more detail below.

Objects stay in young generation until they live long enough to be promoted into the old generation heap. Once the old generation heap runs out of space a major GC happens and live objects are copied and compacted within the old generation heap to create free space. The old generation is typically larger than the young generation so a major GC is usually costlier than a minor GC. In some GC algorithms the major GC is performed using multiple working threads parallel collector to reduce pause time. The heap size may change over time because JVM may only commit a portion of the total heap space to be used by memory users. However the maximum heap size is set statically when a JVM launches and does not change over time.

The example illustrated in is just one example of the OpenJDK Java heap and other JVM implementations may perform GC differently but the principles of the invention can be applied in any JVM implementation where the heap size stays constant independently on how GC is performed.

The balloon operation is described in more detail in U.S. Pat. No. 7 716 446 issued May 11 2010 and U.S. Pat. No. 7 702 843 issued Apr. 20 2010 which are incorporated here by reference. The balloon allows the kernel to reclaim memory from the guest indirectly by adding an additional consumer of memory inside the guest operating system the balloon . It should be noted that the balloon can be implemented as a balloon driver as depicted in or can be implemented as a separate application running on the VM.

As the balloon inflates it takes memory from the guest OS environment and makes the memory available for the hypervisor. Conversely if memory is available and needed by the guest OS the balloon can shrink allowing more memory to be allocated into the guest OS environment. The problem when using a JVM is that for the balloon mechanism to work the guest OS assumes a basic level of collaboration between the guest OS and the application. That is if the application needs more memory the application allocates memory from the guest OS and the guest OS recognizes if there is an ongoing need for that memory. If memory is no longer needed by the application the reduced need of memory is recognized by scanning the working set and by using the guest s OS mechanism to page out unused memory. Alternatively memory can be directly freed by the application.

Chart shows memory used which changes over time according to the applications needs. In the Example of the maximum use of memory is Mbut the JVM has reserved more memory up to M to have a margin of safety. Determining how much memory a process is going to need is usually a guessing game and that is why more memory than the memory required is reserved. Memory available for reassignment is theoretically upper bound as the difference between Mand the amount of memory being used at a given time. However using the balloon application to free all the available memory would cause a lot of additional processing by the memory management modules as they try to constantly free and allocate memory as the memory use changes. As a result the hypervisor uses a conservative approach by freeing pages of memory in incremental operations until the heap starts being under pressure for lack of memory. In one embodiment the Java balloon obtains an amount of memory close to the difference between Mand M although other policies are also possible.

In one embodiment an application level Java balloon agent is used for managing heap memory. Java balloon objects allocated inside the Java heap effectively reduce the heap space that can be used by the Java application. A smaller heap may cause GC to run more frequently which decreases throughput. However this use of Java balloon objects avoids more expensive disk swap activity. Further if the deployment includes Java applications in which the heap has been purposefully over provisioned the impact of the balloon objects on overall performance will be minimal.

Java balloon inflates and deflates by allocating and freeing large Java objects from the Java heap. Inside guest OS balloon driver communicates with resource manager in VMKernel and Java balloon . However when balloon driver receives instructions to inflate balloon driver requests Java balloon to inflate instead of asking for memory pages directly from guest OS . Java balloon inflates by allocating new objects and then communicating the addresses of these pages to VMKernel .

Java agents are public management interfaces that allow a management thread to attach to a running Java application. Java agents ease Java application instrumentation and their interfaces and features make them suitable to implement application level balloons. In one embodiment when Java agent starts operations a Java thread is created. In one embodiment this thread periodically polls for a new balloon target size from guest balloon driver . In another embodiment the communication between balloon driver and the Java balloon thread is through standard posix system calls.

To inflate the balloon the agent thread allocates new array objects dubbed balloon objects and adds them to a list. To deflate the agent simply removes an array from the list and the space is re claimed in the next GC. Object size is selected as 4 MB so that the physical frame numbers can be encoded in one page but other sizes are also possible. In general the size selected will be at least the size of one page of memory in the host and it will typically be the size of multiple pages of memory although any size can be used. The use of large objects reduces the number of objects the agent needs to handle for meeting a large balloon target. Once the Java balloon agent thread allocates a new balloon object the Java balloon agent needs to balloon the pages used by this object as a traditional balloon driver does. There are several embodiments for implementing runtime environment ballooning which are discussed below.

In one embodiment the information about pages of an object allocated by the Java agent is communicated to the VMM using existing backdoor calls between VMM and balloon driver . In regular application ballooning when a balloon driver expands it requests a page from the OS and passes the Physical Page Number PPN of this page to VMM through a backdoor call. To use the same backdoor calls the balloon objects need to be translated into a set of PPNs. This is accomplished using JNI library and a modified balloon driver .

JNI is a programming framework that allows Java code running in a JVM to call and to be called by native applications programs specific to a hardware and operating system platform and libraries written in other languages such as C C and assembly. As shown in when Java balloon agent allocates a balloon object it calls into the JNI library to get the virtual address of this balloon object via GetPrimitiveArrayCritical. This is a C function and it is used by the Java balloon because there is no utility in Java to obtain the address of Java objects.

The virtual address is then passed to the kernel balloon driver which translates the virtual address into PPNs and also pins the PPNs in guest memory e.g. using get user pages in Linux . The PPNs are enqueued in PPN queue and a separate worker thread passes the PPNs to page sharing module in VMM via backdoors. Using a separate thread allows to return from guest OS kernel sooner which is important because while the thread is in the VMKernel the JNI library disables GC to lock objects in Java heap in order to avoid race conditions.

It should be noted that if the JVM does not support pinning locking objects in the Java heap so their addresses do not change the get virtual address call may return a pointer to a copy of the array object instead of returning a direct pointer to the array. In some embodiments pinning is helpful for the call to properly return the virtual address of the Java object.

Java objects may be relocated during GC. Once a balloon object is moved because of GC the balloon object is no longer at the virtual address provided to VMM . To avoid this situation worker thread in VMkernel is notified before each GC to discard any unfinished work in queue . Otherwise worker thread may balloon out the pages of other Java objects. In addition the balloon objects need to be re checked after a GC to determine if they have been relocated and if so redoing the page sharing process. Garbage collector generates a GC event before each GC which is received by garbage collection intercept in Java Virtual Machine Tool Interface JVMTI .

JVMTI is an interface that allows a program to inspect the state and to control the execution of applications running in the JVM. JVMTI is designed to provide an Application Programming Interface API for the development of tools that need access to the state of the JVM. Examples for such tools are debuggers or profilers. The JVMTI is a native interface of the JVM. A library written in C or C is loaded during the initialization of the JVM. The library has access to the JVM state by calling JVMTI and JNI functions and can register to receive JVMTI events using event handler functions that are called by the JVM when such an event occurs. Upon receiving the GC event garbage collection intercept notifies worker thread which clears up queue in order to stop processing more resources to reallocate memory. Once the worker thread completes this task the GC takes place.

After giving memory pages away the pages are mapped to a special address which is referred to herein as the zero space or zero memory. In one embodiment if a zero memory is accessed by a process the hypervisor will allocate a new page of memory for that VM using the COW method described above.

In operation the virtual address is sent to the guest OS kernel and in operation the guest OS kernel gets the PPN corresponding to the virtual address obtained in operation . After operation the method continues in operation where the PPN is queued ready to be processed by worker thread .

Worker thread performs two processes. In the first process the worker thread gets a PPN from the queue of candidate PPNs in operation and then sends the PPN to the VMM for page sharing the PPM. On the other process worker thread detects when a garbage collection event is to take place in operation . In operation the worker thread empties the PPN queue and in operation garbage collection is enabled again.

A JVM heap has a static maximum limit set when the JVM launches. If a JVM cannot find free space to allocate a new object even after a full GC the JVM throws an Out of Memory OOM error which typically causes an application abort. Since ballooned objects effectively reduce the heap space that can be used by applications the ballooned memory could cause an OOM error.

To avoid OOM errors soft references are used to balloon objects when they are added to the list. In that case when the JVM needs space to allocate application objects the balloon objects are freed. After each garbage collection these references are checked to detect freed or moved balloon objects and bookkeeping is performed. Detecting freed balloon objects is a sign that the application is actively using memory. If the heap has no empty space for Java balloon objects the VMKernel is notified via the backdoor. The VMkernel then needs to use host swap to enforce the VM s memory share.

This method is simple however it has the drawback that it is undetermined how long it will take until the pages are picked up by VMkernel . It is important that the Java balloon can reach the balloon target in about the same time period as the traditional balloon. In one embodiment hints are passed from the Java balloon agent through JNI to balloon driver and resource manager in VMKernel .

In reference to the VMM thread the VMM checks for zero memory pages PPNs in operation to mark the pages as candidates for psharing. As previously described the VMM can blindly search for zero pages in memory or it can received hints from the VM to indicate which pages are candidates for psharing.

It should be appreciated that the use of a zero value in memory is an exemplary way of adding content to the page. In fact any value can be used as long as the VMM knows which value is being entered by the VM. The embodiments illustrated in should therefore not be interpreted to be exclusive or limiting but rather exemplary or illustrative.

Further the method flows from operation to operation where the zero pages are mapped to a share memory location. After a page has been remapped in operation the method frees the zero page in operation to make it available for other host processes. The VMM also detects writes during operation to any page that has been reallocated after psharing. In operation the VMM obtains a new PPN for the process trying to do a write and then assigns the newly obtained page to this process in operation .

Another embodiment for memory management in JVMs adds an additional backdoor call to serve as a hint to VMM for page sharing. The JNI directly calls this backdoor with a balloon object s virtual address. The VMM then walks the guest page table to find the PPNs and calls into VMkernel so that these PPNs become COW candidates. This scheme does not require a change to the kernel driver.

After operation the method continues to operation there the Java balloon agent loads the Java object with a first value. In one embodiment the first value is a page of zero values but other values are also possible. In operation the VMM detects that a machine physical memory page associated with the Java object has the first value. In operation the VMM frees the machine physical memory page detected in operation .

Embodiments of the present invention may be practiced with various computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a network.

The embodiments of the present invention can also be defined as a machine that transforms data from one state to another state. The transformed data can be saved to storage and then manipulated by a processor. The processor thus transforms the data from one thing to another. Still further the methods can be processed by one or more machines or processors that can be connected over a network. The machines can also be virtualized to provide physical access to storage arid processing power to one or more users servers or clients. Thus the virtualized system should be considered a machine that can operate as one or more general purpose machines or be configured as a special purpose machine. Each machine or virtual representation of a machine can transform data from one state or thing to another and can also process data save data to storage display the result or communicate the result to another machine.

The invention can also be embodied as computer readable code on a computer readable medium. The computer readable medium is any data storage device that can store data which can be thereafter be read by a computer system. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs magnetic tapes and other optical and non optical data storage devices. The computer readable medium can include computer readable tangible medium distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although the method operations were described in a specific order it should be understood that other housekeeping operations may be performed in between operations or operations may be adjusted so that they occur at slightly different times or may be distributed in a system which allows the occurrence of the processing operations at various intervals associated with the processing as long as the processing of the overlay operations are performed in the desired way.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications can be practiced within the scope of the appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

