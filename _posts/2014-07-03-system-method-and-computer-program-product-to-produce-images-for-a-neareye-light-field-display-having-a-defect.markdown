---

title: System, method, and computer program product to produce images for a near-eye light field display having a defect
abstract: A system, method, and computer program product are provided for producing images for a near-eye light field display. Defect information for a first pixel of a microdisplay of a near-eye light field display device is received and a second pixel of the microdisplay is identified, where the first pixel and the second pixel contribute to a portion of the retinal image. Based on the defect information, a value of the second pixel within an array of elemental images is modified to produce a corrected array of elemental images for display by the microdisplay. An optical apparatus of the near-eye light field display device may, for example, be a microlens of a microlens array positioned between a viewer and an emissive microdisplay or a pinlight of a pinlight array positioned behind a transmissive microdisplay relative to the viewer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09519144&OS=09519144&RS=09519144
owner: NVIDIA Corporation
number: 09519144
owner_city: Santa Clara
owner_country: US
publication_date: 20140703
---
This application is a continuation in part of U.S. Non Provisional application Ser. No. 14 160 497 filed Jan. 21 2014 which claims the benefit of U.S. Provisional Application No. 61 824 914 filed May 17 2013 the entire contents of these applications are incorporated herein by reference.

The present invention relates to a producing images and more specifically to producing images for a near eye light field display.

Near eye displays NEDs include head mounted displays HMDs that may project images directly into a viewer s eyes. Such displays may overcome the limited screen size afforded by other mobile display form factors by synthesizing virtual large format display surfaces or may be used for virtual or augmented reality applications. One type of NED is a near eye light field display that may be implemented as a thin lightweight head mounted display that includes microlenses configured between a viewer s eye and a microdisplay. Such a near eye light field display is capable of synthesizing light fields corresponding to virtual objects within a viewer s natural accommodation range.

As the pixel resolution of the microdisplay increases the quality of the synthesized light field increases. However the number of defective pixels in the microdisplay may also increase as the resolution of the microdisplay increases. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for producing images for a near eye light field display. Defect information for a first pixel of a microdisplay of a near eye light field display device is received and a second pixel of the microdisplay is identified where the first pixel and the second pixel contribute to a portion of the retinal image. Based on the defect information a value of the second pixel within an array of elemental images is modified to produce a corrected array of elemental images for display by the microdisplay. Values of one or more additional pixels within the array of elemental images may be modified to produce the corrected array of elemental images. An optical apparatus of the near eye light field display device may for example be a microlens of a microlens array positioned between a viewer and an emissive microdisplay or a pinlight of a pinlight array positioned behind a transmissive microdisplay relative to the viewer.

Reference will now be made in detail to the various embodiments of the present disclosure examples of which are illustrated in the accompanying drawings. While described in conjunction with these embodiments it will be understood that they are not intended to limit the disclosure to these embodiments. On the contrary the disclosure is intended to cover alternatives modifications and equivalents which may be included within the spirit and scope of the disclosure as defined by the appended claims. Furthermore in the following detailed description of the present disclosure numerous specific details are set forth in order to provide a thorough understanding of the present disclosure. However it will be understood that the present disclosure may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail so as not to unnecessarily obscure aspects of the present disclosure.

Some portions of the detailed descriptions that follow are presented in terms of procedures logic blocks processing and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. In the present application a procedure logic block process or the like is conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those utilizing physical manipulations of physical quantities. Usually although not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system. It has proven convenient at times principally for reasons of common usage to refer to these signals as transactions bits values elements symbols characters samples pixels or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present disclosure discussions utilizing terms such as displaying generating producing calculating determining radiating emitting attenuating modulating transmitting receiving or the like refer to actions and processes e.g. flowcharts of of a computer system or similar electronic computing device or processor e.g. computing system of . The computer system or similar electronic computing device manipulates and transforms data represented as physical electronic quantities within the computer system memories registers or other such information storage transmission or display devices.

Embodiments described herein may be discussed in the general context of computer executable instructions residing on some form of computer readable storage medium such as program modules executed by one or more computers or other devices. By way of example and not limitation computer readable storage media may comprise non transitory computer readable storage media and communication media non transitory computer readable media include all computer readable media except for a transitory propagating signal. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or distributed as desired in various embodiments.

Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM electrically erasable programmable ROM EEPROM flash memory or other memory technology compact disk ROM CD ROM digital versatile disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can be accessed to retrieve that information.

Communication media can embody computer executable instructions data structures and program modules and includes any information delivery media. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above can also be included within the scope of computer readable media.

As described herein near eye light field displays enable thin lightweight head mounted displays HMDs capable of presenting nearly correct convergence accommodation binocular disparity and retinal defocus depth cues. The near eye light field display device is positioned close to a user s eyes closer than a near focus plane defining the user s accommodation range. A near eye light field display allows a user wearing an eyeglass type apparatus to view a synthetic image that appears to be positioned within the user s accommodation range.

Typically objects positioned closer than a near focus plane appear blurry. However images displayed using the near eye light field display device may appear in focus to a viewer. Sharp images may be depicted by the near eye light field display device when light fields corresponding to virtual objects within the user s natural accommodation range are synthesized. Simply displaying existing two dimensional monoscopic stereoscopic and multiscopic content suitable intended for display by conventional display devices will not produce sharp images when displayed by the near eye light field display device.

Therefore existing two dimensional monoscopic stereoscopic and multiscopic content suitable for display by conventional display devices should be processed to produce an image or images for display by the near eye light field display device. An existing image that is desired to be displayed may be processed to generate a processed image that comprises an array of elemental images. Each elemental image is a view of the desired existing image corresponding to one microlens within a microlens array through which a user views the processed image. When the processed image is viewed through the microlens array the user sees the desired existing image mapped to a virtual display plane that is within the user s natural accommodation range.

An alternative to a microlens array based display device is a pinlight based display device. A pinlight see through near eye display combines a pinlight array including at least one pinlight and a compact optical see through display to produce a synthetic image in a viewer s field of view even when placed so close that the viewer s eyes cannot accommodate in terms of focusing i.e. the optical see through display is placed closer than the near focus plane . When a pinlight based near eye light field display device is used each elemental image is a view of the desired existing image corresponding to one pinlight within a pinlight array. The user views the pinlight array through a transmissive display layer that encodes the processed image i.e. light rays generated by the pinlight array are projected through the display layer . When the processed image is viewed through the transmissive display layer that is positioned in front of the pinlight array the user sees the desired existing image mapped to a virtual display plane that is within the user s natural accommodation range.

However when a pixel of the microdisplay that produces the processed image is defective the image seen by the viewer at the virtual display plane i.e. the virtual or synthesized image may not match the desired existing image. The elemental image that includes the defective pixel will contribute to a portion of the synthesized image and other elemental images in the elemental image array also contribute to the same portion of the synthesized image. Therefore values of pixels in the other elemental images may be modified i.e. changed or adapted to compensate for the defective pixel and improve the quality of the synthesized image. Because the redundancy of the elemental images may be exploited to compensate for defective pixels a less expensive microdisplay having more pixel defects may be used to produce a synthesized image of similar quality in terms of resolution to an image produced by a conventional display having fewer pixel defects. Conventional displays lack redundancy because each pixel of the conventional display uniquely controls the appearance of a point in a scene.

In one embodiment the microdisplay is an emissive display that is configured to be viewed through a two dimensional array of microlenses where each microlens is an optical apparatus that in combination with a pixel of the microdisplay may define a ray. The ray extends to a viewer s retina to produce a portion of a retinal image corresponding to a portion of the synthesized image that appears at a virtual display plane. In the context of the present description the virtual display plane is a virtual plane that appears to the viewer to be positioned at or beyond the near focus plane. In one embodiment the virtual display plane is in front of a far plane beyond which objects may appear out of focus to the viewer.

In the context of the following description an array of microlenses is a two dimensional array including at least two microlenses. In one embodiment the near eye light field display device is embodied in an eyeglass form factor that includes two microdisplays and two microlens arrays to form a binocular near eye light field display device where a first microdisplay and microlens array set is associated with a user s left eye and a second microdisplay and microlens array set is associated with a user s right eye. In another embodiment the near eye light field display device is embodied in an eyeglass form factor that includes one microdisplay and one microlens array to form a monocular near eye light field display device where the microdisplay and microlens array set is associated with either a user s left eye and or a user s right eye.

In another embodiment the microdisplay is a transmissive i.e. of variable opacity and color capable of becoming substantially transparent display that is positioned between a viewer and a two dimensional array of pinlights where each pinlight is an optical apparatus. The pinlight array is viewed through the microdisplay. A ray may be defined by a pixel of the microdisplay and a pinlight in the pinlight array.

In one embodiment the near eye light field display is implemented as a tensor display for example as described by Wetzstein et al Tensor Displays Compressive Light Field Synthesis Using Multilayer Displays with Directional Backlighting ACM Transactions on Graphics SIGGRAPH 2012 Conference Proceedings. Volume 31 Issue 4 July 2012. In one embodiment the near eye light field display is implemented using multiple light modulation layers for example as described by Maimone et al Computational Augmented Reality Eyeglasses Proceedings of the 2013 IEEE International Symposium on Mixed and Augmented Reality October 2013 pages 29 38. A display assembly may comprise a microdisplay and an optical apparatus where the optical apparatus may comprise one or more microlenses one or more pinlights one or more pinholes or one or more transmissive layers included in a tensor display assembly.

A first ray intersects the first pixel and a portion of a retinal image so that a value of the pixel e.g. color and or intensity contributes to the portion of the retinal image. At step a second pixel of the microdisplay is identified and the second pixel contributes to the same portion of the retinal image that the first pixel contributes to. In one embodiment the portion of the retinal image is a pixel or point of the retinal image and the first and second pixels of the microdisplay are superimposed at the portion of the retinal image when light projected from the first and second pixels intersects at the retina. A second ray intersects the second pixel and a portion of a retinal image so that a value of the pixel e.g. color and or intensity contributes to the portion of the retinal image. One or more additional pixels may also contribute to the same portion of the retinal image as the first and second pixels where additional rays defined by each of the additional pixels and optical apparatus e.g. lens pinlight or pinhole extends to the same portion of the retinal image.

At step based on the defect information a value of the second pixel within an array of elemental images is modified to produce a corrected array of elemental images for display by the microdisplay. The value of the second pixel is modified to at least partially compensate for the defective first pixel.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

The microdisplay is separated from a microlens array by a distance d. The microlens array is positioned at a distance dthat corresponds to an eye relief distance. A microdisplay image displayed by the microdisplay appears to the viewer to be mapped to a virtual display plane that is positioned at a virtual display distance dfrom the eye . The microdisplay image may be produced from an existing image. The distance dmay be different for each eye allowing for correction of the viewer s optical aberrations i.e. an eyeglass prescription . The width of the virtual display plane is wand the width of the microdisplay is w.

Typically a three dimensional scene will be rendered to generate a two dimensional 2D image for display by the microdisplay . A microdisplay image that is displayed by the microdisplay includes an elemental image corresponding to a view for each microlens in the microlens array . For example an elemental image is displayed at the elemental image region corresponding to the microlens . The elemental image region is a two dimensional region having a width of w and is defined as the intersection at the microdisplay of a projection from the pupil retina of the eye through the microlens . Each elemental image region and corresponding microlens e.g. elemental image region and microlens acts as an independent lens limited magnifier synthesizing an off axis perspective projection of a virtual image located a distance dfrom the eye i.e. at the virtual display plane . Portions of the virtual image are repeated across the different elemental image regions as shown in .

Rendering a 3D scene to produce a microdisplay image for display by the microdisplay requires rendering each elemental image that is included in the microdisplay image. In contrast only a single image is rendered for display by a conventional display device. In some cases the 3D scene is not available to be rendered such as for existing content comprising conventional 2D images. However the existing content intended for display by a conventional display device may be processed for display by the microdisplay . In particular existing stereoscopic image pairs are widely available for 3D television and the existing stereoscopic image pairs may be processed for display by the microdisplay .

A viewer looking through the near eye light field display device will perceive a rectangular virtual display surface at the virtual image plane onto which corresponding left and right eye views of an existing stereoscopic image pair are appear. To generate a pair of microdisplay images from an existing stereoscopic image pair the virtual image plane may be texture mapped with the left and right eye views and a pair of texture maps is stored for an existing stereoscopic image pair. The left and right eye frustums are indicated by dashed lines in . For a monoscopic existing image only one existing image is stored as a texture map that is used to determine pixel color for both the left microdisplay and the right microdisplay . The existing image is mapped as a texture onto the virtual display plane to produce a virtual image. Each pixel of the virtual image at the virtual display plane corresponds to a color defined by the existing image. The virtual image is then used to compute colors for each pixel of the left microdisplay and the right microdisplay . In simple terms a color of a pixel on a microdisplay is computed by casting a ray from the pixel on the microdisplay to intersect the virtual display plane and then calculating a color of the pixel on a microdisplay using one or more samples of the virtual image at the point of intersection.

The pseudo code shown in TABLE 1 may be included in a vertex shader program to map the existing image to the virtual display plane .

Rendering images for the near eye light field display device requires assigning the color of each pixel of the left microdisplay and right microdisplay such that the emitted light field approximates a virtual image at the virtual display plane . The virtual image may include objects such as the virtual object that appear at different depths relative to the virtual display plane . For a pixel located a distance xfrom the center of the left microdisplay ray tracing may be employed to compute a color. The virtual object appears displaced in front of the virtual display plane as intended by the existing stereoscopic image pair. The depth of the virtual object is not readily available after the 3D scene has been rendered to produce the existing stereoscopic image pair but the intended displacements are substantially retained when a microdisplay stereoscopic image pair is generated for the existing stereoscopic image pair.

The pixel of the left microdisplay is visible to the viewer s left eye through the left microlens array having an optical center that is laterally displaced by a distance xfrom the center of the left microdisplay . Any optical ray is defined by a point of a pixel on a microdisplay and a point at the optical center of the intersected microlens. As shown in the 3D coordinates of the center of the microlens and the pixel define an optical ray . Note that the distances are described in terms of the coordinate x and corresponding distances may also be defined in terms of the y coordinate to produce distances yand yrelative to a reference point on the left microdisplay . When the pixel is defective other pixels that contribute to the same portion of the virtual image at the virtual display plane may be modified to compensate for the defective pixel as described in conjunction with .

The pseudo code shown in TABLE 2 may be included in a fragment shader program to define the dimensions shown in and other system parameters as uniform variables.

The displacement xmay be evaluated for a texel having the texture map coordinates s t based on the microdisplay orientation and dimensions. The pseudo code shown in TABLE 3 may be included in a fragment shader program to compute the displacement for a pixel relative to a reference point on a microdisplay x microdisplayCoord .

The position of the optical center of the corresponding microlens xmay be evaluated based on the orientation of the microlens array and the displacement x. The pseudo code shown in TABLE 4 may be included in a fragment shader program to compute the optical center of the corresponding microlens x microlensCoord .

Then the horizontal coordinate or displacement of the point of intersection of the optical ray and the virtual display plane i.e. virtual image xmay be computed as 

The color of the pixel gl FragColor may be computed by converting the screen coordinates x y to texture map coordinates s t . Because artifacts can result when a portion of the virtual image is visible through peripheral microlenses pixels that are outside of the virtual display plane are set to black when the microlensExcludeBorder Boolean variable is TRUE.

Ray tracing provides a direct estimate of the color of the pixel for the left microdisplay . Casting a set of rays defined by each pixel located within the elemental image region corresponding to a microlens provides estimates of the color of each pixel in an elemental image. Casting sets of rays for each elemental image region corresponding to a microlens provides estimates of the color of each pixel in the microdisplay image for the left microdisplay and in the microdisplay image for the right microdisplay .

In one embodiment eye tracking information may be provided by one or more cameras positioned to view a portion of the eye and surrounding facial tissue. In addition to the one or more cameras a system may include possibly programmable illumination source s such as one or more light emitting diodes LED or other light sources. The one or more cameras and or one or more illumination sources may be further integrated into eyewear e.g. in eyeglasses rims frames and or temples . In one embodiment a system includes light sensitive elements e.g. photodiodes embedded into the display plane so that when viewed together with the microlens array create a thin lightweight light field camera array that is co located with the light field display. Such a bidirectional design allows direct viewing of the eye without additionally increasing the dimensions and or weight of the eyewear. Infrared sources may also be embedded in the display plane or display backlight to eliminate the need for additional light sources.

Typically the left microlens array and right microlens array each include more optical apparatus than are shown in so that multiple optical rays defined by pixels of the left microdisplay and the right microdisplay do intersect the retina and contribute to the portion of the virtual image .

Ray tracing may be used to identify each of the pixels that contribute to a pixel of the retinal image. A projection matrix P may be determined that defines the contribution of each microdisplay pixel to each retinal image point assuming there are no pixel defects . Note that each microdisplay pixel may not contribute equally to a particular retinal image point. The projection matrix may be used to modify values of pixels to compensate for defective pixels in the left microdisplay and the right microdisplay as described in conjunction with .

The left microdisplay and the right microdisplay are separated by a distance bmeasured from the right edge of the left microdisplay to the left edge of the right microdisplay . The interpupillary distance between centers of the pupils of the viewer s left and right eyes is b. The near eye light field display device emulates the appearance of a conventional stereoscopic display located a distance dfrom the viewer i.e. at the virtual display plane . In one embodiment bis a fixed average distance such as an interocular distance rather than a dynamically sampled interpupillary distance.

A viewer looking through the near eye light field display device will perceive a rectangular virtual display surface at the virtual image plane that is texture mapped with corresponding left and right eye views of an existing stereoscopic image pair. Therefore a pair of texture maps is stored for an existing stereoscopic image pair. In other embodiments the virtual display surface may be a different shape that is not necessarily rectangular. The left and right eye frustums are indicated by dashed lines in . For a monoscopic existing image only one existing image is stored as a texture map that is used to determine pixel color for both the left microdisplay and the right microdisplay . The existing image is mapped as a texture onto the virtual display plane to produce a virtual image. Each pixel of the virtual image at the virtual display plane corresponds to a color defined by the existing image. The virtual image is then used to compute colors for each pixel of the left microdisplay and the right microdisplay . In simple terms a color of a pixel on a microdisplay is computed by casting a ray from the pixel on the microdisplay to intersect the virtual display plane and then calculating a color of the pixel on a microdisplay using one or more samples of the virtual image at the point of intersection.

Once colors for the pixels of the microdisplay have been computed an array of elemental images is available that will produce the existing image when displayed on the microdisplay. When one or more pixels of the microdisplay are defective values of the pixels in the array of elemental images may be modified to compensate for the defective pixels. A ray defined by the defective pixel and a pinlight extends to intersect the virtual display plane and or to the pupil where the retinal image is produced to identify a point of the virtual image at the virtual display plane or the retinal image to which the defective pixel contributes. A set of rays may then be cast from the identified point of the virtual image or the that is intersected by the ray on the retinal image to identify other pixels of the microdisplay that also contribute to the point. Values of one or more of the other pixels may be modified to compensate for the defective pixel. In one embodiment the one or more pixels having values that are modified may be determined using eye tracking information. Values of one or more pixels that are immediately adjacent to the other pixels i.e. neighboring pixels may also be modified to compensate for the defective pixel.

As previously explained in conjunction with the pseudo code shown in TABLE 1 may be included in a vertex shader program to map the existing image to the virtual display plane . Rendering images for the near eye light field display device requires assigning the color of each pixel of the left microdisplay and right microdisplay such that the emitted light field approximates a virtual image at the virtual display plane . The virtual image may include objects such as the virtual object that appear at different depths relative to the virtual display plane . For a pixel located a distance xfrom the center of the left microdisplay ray tracing may be employed to compute a color. The virtual object appears displaced in front of the virtual display plane as intended by the existing stereoscopic image pair. The depth of the virtual object is not readily available after the 3D scene has been rendered to produce the existing stereoscopic image pair but the intended displacements are substantially retained when a microdisplay stereoscopic image pair is generated for the existing stereoscopic image pair.

The pixel is visible to the viewer s left eye at the left microdisplay having an optical center that is laterally displaced by a distance xfrom the center of the left microdisplay . Any optical ray is defined by a point of a pixel on a microdisplay and a point at the optical center of the intersected pinlight in the corresponding pinlight array. As shown in the 3D coordinates of the center of the intersected pinlight and the pixel define an optical ray . Note that the distances are described in terms of the coordinate x and corresponding distances may also be defined in terms of the y coordinate to produce distances yand yrelative to a reference point on the left microdisplay .

The displacement xmay be evaluated for a texel having the texture map coordinates s t based on the microdisplay orientation and dimensions. The position of the optical center of the corresponding pinlight x may be evaluated based on the orientation of the pinlight array and the displacement x. Then the horizontal coordinate or displacement of the point of intersection of the optical ray and the virtual display plane i.e. virtual image xmay be computed as 

A fragment shader program may be configured to compute the displacement for a pixel relative to a reference point on a microdisplay x microdisplayCoord the optical center of the corresponding pinlight x pinlightCoord and the horizontal coordinate x screenCoord .

The color of the pixel gl FragColor may be computed by converting the screen coordinates x y to texture map coordinates s t . Ray tracing provides a direct estimate of the color of the pixel for the left microdisplay . Casting a set of rays defined by each pixel located within the elemental image region corresponding to a pinlight provides estimates of the color of each pixel in an elemental image. Casting sets of rays for each elemental image region corresponding to a pinlight provides estimates of the color of each pixel in the microdisplay image for the left microdisplay and in the microdisplay image for the right microdisplay . The resulting array of elemental images may then be processed to modify values of the pixels to compensate for defective pixels of the microdisplay.

As shown in elemental images includes 25 different elemental images that each have a pixel contributing to the same portion of the existing image shown in . The portion of the existing image may be a single pixel or two or more neighboring pixels. When a contributing pixel in one of the elemental images is defective one or more of the other contributing pixels may be modified to compensate for the defective pixel. For example assume that the portion of the existing image should be gray with 50 values for each of the red green and blue subpixels. If the red subpixel of one pixel corresponding to the portion of the existing image is stuck on at 100 the value of the red subpixel of one or more of the 25 other pixels that also correspond to the portion of the existing image may be reduced to compensate for the defective pixel. In one embodiment neighboring pixels of the defective pixel and other contributing pixels may be modified to compensate for the defective pixel. In other words the array of elemental images effectively encodes redundant image data that may be used to compensate for pixel defects.

In one embodiment stereoscopic image pairs are assumed to be oversampled relative to the resolution of the near eye light field display device . Therefore to produce anti aliased elemental images for stereoscopic image pairs a low pass filter length circumflex over p may be determined by the size of the pixels of the microdisplay as magnified by projection into the virtual display plane . The parameter circumflex over p may be computed as 

The pseudo code shown in TABLE 7 may be included in a fragment shader program to perform preprocessing for anti aliasing. The variable antialiasLength is the parameter circumflex over p . As shown in the pseudo code in TABLE 7 p0 is ultimately assigned a new color during execution of a fragment shader program. The locations of neighboring pixels are stored in the temporary variable p and then the colors of the neighboring pixels are averaged to determine a color that is assigned to p0. While the pseudo code in TABLE 7 implements a separable filter that is commonly chosen for efficiency those skilled in the art will recognize that other filters including non separable filters are also possible.

As shown in the PPU includes an Input Output I O unit a host interface unit a front end unit a scheduler unit a work distribution unit a hub a crossbar Xbar one or more general processing clusters GPCs and one or more partition units . The PPU may be connected to a host processor or other peripheral devices via a system bus . The PPU may also be connected to a local memory comprising a number of memory devices . In one embodiment the local memory may comprise a number of dynamic random access memory DRAM devices.

The I O unit is configured to transmit and receive communications i.e. commands data etc. from a host processor not shown over the system bus . The I O unit may communicate with the host processor directly via the system bus or through one or more intermediate devices such as a memory bridge. In one embodiment the I O unit implements a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known interfaces for communicating with external devices.

The I O unit is coupled to a host interface unit that decodes packets received via the system bus . In one embodiment the packets represent commands configured to cause the PPU to perform various operations. The host interface unit transmits the decoded commands to various other units of the PPU as the commands may specify. For example some commands may be transmitted to the front end unit . Other commands may be transmitted to the hub or other units of the PPU such as one or more copy engines a video encoder a video decoder a power management unit etc. not explicitly shown . In other words the host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program executed by the host processor encodes a command stream in a buffer that provides workloads to the PPU for processing. A workload may comprise a number of instructions and data to be processed by those instructions. The buffer is a region in a memory that is accessible i.e. read write by both the host processor and the PPU . For example the host interface unit may be configured to access the buffer in a system memory connected to the system bus via memory requests transmitted over the system bus by the I O unit . In one embodiment the host processor writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the front end unit with pointers to one or more command streams. The front end unit manages the one or more streams reading commands from the streams and forwarding commands to the various units of the PPU .

The front end unit is coupled to a scheduler unit that configures the various GPCs to process tasks defined by the one or more streams. The scheduler unit is configured to track state information related to the various tasks managed by the scheduler unit . The state may indicate which GPC a task is assigned to whether the task is active or inactive a priority level associated with the task and so forth. The scheduler unit manages the execution of a plurality of tasks on the one or more GPCs .

The scheduler unit is coupled to a work distribution unit that is configured to dispatch tasks for execution on the GPCs . The work distribution unit may track a number of scheduled tasks received from the scheduler unit . In one embodiment the work distribution unit manages a pending task pool and an active task pool for each of the GPCs . The pending task pool may comprise a number of slots e.g. 16 slots that contain tasks assigned to be processed by a particular GPC . The active task pool may comprise a number of slots e.g. 4 slots for tasks that are actively being processed by the GPCs . As a GPC finishes the execution of a task that task is evicted from the active task pool for the GPC and one of the other tasks from the pending task pool is selected and scheduled for execution on the GPC . If an active task has been idle on the GPC such as while waiting for a data dependency to be resolved then the active task may be evicted from the GPC and returned to the pending task pool while another task in the pending task pool is selected and scheduled for execution on the GPC .

The work distribution unit communicates with the one or more GPCs via a XBar . The XBar is an interconnect network that couples many of the units of the PPU to other units of the PPU . For example the XBar may be configured to couple the work distribution unit to a particular GPC . Although not shown explicitly one or more other units of the PPU are coupled to the host unit . The other units may also be connected to the XBar via a hub .

The tasks are managed by the scheduler unit and dispatched to a GPC by the work distribution unit . The GPC is configured to process the task and generate results. The results may be consumed by other tasks within the GPC routed to a different GPC via the XBar or stored in the memory . The results can be written to the memory via the partition units which implement a memory interface for reading and writing data to from the memory . In one embodiment the PPU includes a number U of partition units that is equal to the number of separate and distinct memory devices coupled to the PPU . A partition unit will be described in more detail below in conjunction with .

In one embodiment a host processor executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the host processor to schedule operations for execution on the PPU . An application may generate instructions i.e. API calls that cause the driver kernel to generate one or more tasks for execution by the PPU . The driver kernel outputs tasks to one or more streams being processed by the PPU . Each task may comprise one or more groups of related threads referred to herein as a warp. A thread block may refer to a plurality of groups of threads including instructions to perform the task. Threads in the same group of threads may exchange data through shared memory. In one embodiment a group of threads comprises 32 related threads.

In one embodiment the operation of the GPC is controlled by the pipeline manager . The pipeline manager manages the configuration of the one or more TPCs for processing tasks allocated to the GPC . In one embodiment the pipeline manager may configure at least one of the one or more TPC s to implement at least a portion of a graphics rendering pipeline. For example a TPC may be configured to execute a vertex shader program on the programmable streaming multiprocessor SM . The pipeline manager may also be configured to route packets received from the work distribution unit to the appropriate logical units within the GPC . For example some packets may be routed to fixed function hardware units in the PROP and or raster engine while other packets may be routed to the TPCs for processing by the primitive engine or the SM .

The PROP unit is configured to route data generated by the raster engine and the TPCs to a Raster Operations ROP unit in the partition unit described in more detail below. The PROP unit may also be configured to perform optimizations for color blending organize pixel data perform address translations and the like.

The raster engine includes a number of fixed function hardware units configured to perform various raster operations. In one embodiment the raster engine includes a setup engine a course raster engine a culling engine a clipping engine a fine raster engine and a tile coalescing engine. The setup engine receives transformed vertices and generates plane equations associated with the geometric primitive defined by the vertices. The plane equations are transmitted to the coarse raster engine to generate coverage information e.g. an x y coverage mask for a tile for the primitive. The output of the coarse raster engine may transmitted to the culling engine where fragments associated with the primitive that fail a z test are culled and transmitted to a clipping engine where fragments lying outside a viewing frustum are clipped. Those fragments that survive clipping and culling may be passed to a fine raster engine to generate attributes for the pixel fragments based on the plane equations generated by the setup engine. The output of the raster engine comprises fragments to be processed for example by a fragment shader implemented within a TPC .

Each TPC included in the GPC includes an M Pipe Controller MPC a primitive engine an SM and one or more texture units . The MPC controls the operation of the TPC routing packets received from the pipeline manager to the appropriate units in the TPC . For example packets associated with a vertex may be routed to the primitive engine which is configured to fetch vertex attributes associated with the vertex from the memory . In contrast packets associated with a shader program may be transmitted to the SM .

In one embodiment the texture units are configured to load texture maps e.g. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs executed by the SM . The texture units implement texture operations such as filtering operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment each TPC includes four 4 texture units .

The SM comprises a programmable streaming processor that is configured to process tasks represented by a number of threads. Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular group of threads concurrently. In one embodiment the SM implements a SIMD Single Instruction Multiple Data architecture where each thread in a group of threads i.e. a warp is configured to process a different set of data based on the same set of instructions. All threads in the group of threads execute the same instructions. In another embodiment the SM implements a SIMT Single Instruction Multiple Thread architecture where each thread in a group of threads is configured to process a different set of data based on the same set of instructions but where individual threads in the group of threads are allowed to diverge during execution. In other words when an instruction for the group of threads is dispatched for execution some threads in the group of threads may be active thereby executing the instruction while other threads in the group of threads may be inactive thereby performing a no operation NOP instead of executing the instruction. The SM may be described in more detail below in conjunction with .

The MMU provides an interface between the GPC and the partition unit . The MMU may provide translation of virtual addresses into physical addresses memory protection and arbitration of memory requests. In one embodiment the MMU provides one or more translation lookaside buffers TLBs for improving translation of virtual addresses into physical addresses in the memory .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various GPCs . As shown each partition unit includes a portion of the L2 cache associated with a corresponding memory device . Lower level caches may then be implemented in various units within the GPCs . For example each of the SMs may implement a level one L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs . The L2 cache is coupled to the memory interface and the XBar .

The ROP unit includes a ROP Manager a Color ROP CROP unit and a Z ROP ZROP unit . The CROP unit performs raster operations related to pixel color such as color compression pixel blending and the like. The ZROP unit implements depth testing in conjunction with the raster engine . The ZROP unit receives a depth for a sample location associated with a pixel fragment from the culling engine of the raster engine . The ZROP unit tests the depth against a corresponding depth in a depth buffer for a sample location associated with the fragment. If the fragment passes the depth test for the sample location then the ZROP unit updates the depth buffer and transmits a result of the depth test to the raster engine . The ROP Manager controls the operation of the ROP unit . It will be appreciated that the number of partition units may be different than the number of GPCs and therefore each ROP unit may be coupled to each of the GPCs . Therefore the ROP Manager tracks packets received from the different GPCs and determines which GPC that a result generated by the ROP unit is routed to. The CROP unit and the ZROP unit are coupled to the L2 cache via an L2 XBar .

As described above the work distribution unit dispatches tasks for execution on the GPCs of the PPU . The tasks are allocated to a particular TPC within a GPC and if the task is associated with a shader program the task may be allocated to an SM . The scheduler unit receives the tasks from the work distribution unit and manages instruction scheduling for one or more groups of threads i.e. warps assigned to the SM . The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different warps scheduling the warps for execution and then dispatching instructions from the plurality of different warps to the various functional units i.e. cores SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core may include a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. The core may also include a double precision processing unit including a floating point arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 4008 standard for floating point arithmetic. Each SM also comprises M SFUs that perform special functions e.g. pixel blending operations and the like and N LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 192 cores SFUs and LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

The shared memory L1 cache is an array of on chip memory that in one embodiment may be configured as either shared memory or an L1 cache or a combination of both as the application demands. For example the shared memory L1 cache may comprise 64 kB of storage capacity. The shared memory L1 cache may be configured as 64 kB of either shared memory or L1 cache or a combination of the two such as 16 kB of L cache and 48 kB of shared memory.

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display .

An application writes model data for a scene i.e. a collection of vertices and attributes to a memory such as a system memory or memory . The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the one or more streams to perform operations to process the model data. The commands may reference different shader programs to be implemented on the SMs of the PPU including one or more of a vertex shader hull shader domain shader geometry shader and a pixel shader. For example one or more of the SMs may be configured to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the different SMs may be configured to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

This invention describes a method to render a near eye light field a set of rays emitted by a light field display in close proximity to the eye. The method allows more traditional image sources to be used to decide the color of each ray rather than using brute force ray tracing. Image sources could be monoscopic i.e. normal 2D images or stereoscopic one image for each eye rendering with correct binocular perspective or multiscopic where multiple views are rendered for a set of different viewing positions and camera orientations. Multiscopic data is the data format used by multiview 3D televisions but also encompassed other forms such as multiple panoramas provided by applications like Google Earth . A source image set in a variety of different data formats may be used to estimate the color of a ray given knowledge of how the source images were generated and configuration of the particular near eye light field display. In one embodiment a source image set is provided from a point light field camera or a camera array such as a stereoscopic pair of light field cameras configured to directly sample the rays depicted by a stereoscopic near eye light field display.

At step existing images are received for generation of microdisplay images that each include an array of elemental images. The existing images may be individual two dimensional images stereoscopic image pairs or multiscopic image sets. When eye tracking is used nearest match source images in a multiscopic image set may be selected for each eye. In one embodiment two or more source images of a multiscopic image set may be interpolated to produce a matching source image. At step the existing images are preprocessed when anti aliasing is enabled. In one embodiment the existing images are filtered using the low pass filter length circumflex over p . When anti aliasing is disabled step may be omitted. At step the preprocessed existing images are stored as texture maps.

At step a texel of a texture map corresponding to one of the existing images is mapped to a pixel on the microdisplay left microdisplay or right microdisplay . When the texture map corresponds to an individual two dimensional image the texel is mapped to a pixel on the left microdisplay and a pixel on the right microdisplay . When the texture map corresponds to the left eye image of a stereoscopic image pair the texel is mapped to a pixel on the left microdisplay . When the texture map corresponds to the right eye image of a stereoscopic image pair the texel is mapped to a pixel on the right microdisplay . Steps through shown as steps may be performed in parallel to process multiple pixels of the left microdisplay and right microdisplay . For example each thread may receive coordinates of a texel and may map the texel coordinates to coordinates of the left microdisplay or right microdisplay .

At step an optical apparatus e.g microlens in the microlens array left microlens array right microlens array pinlight in the left pinlight array or pinlight in the right pinlight array corresponding to the pixel on the microdisplay e.g. microdisplay left microdisplay right microdisplay left microdisplay or right microdisplay respectively is identified. At step a ray defined by the pixel and the optical apparatus is identified. For example when the optical apparatus is a microlens array the ray is defined by the x y z location of the pixel and the x y z location of the optical center of the microlens. When the optical apparatus is a pinlight array the ray is defined by the x y z location of the pixel and the x y z location of the center of the pinlight. At step the ray is intersected with a two dimensional virtual display plane to generate texture map coordinates corresponding to the pixel. At step a color for the pixel is computed based on the texture map coordinates. Multiple texels e.g. color samples may be read from the texture map and combined i.e. filtered to compute the color for the pixel. When steps through are performed in parallel each thread computes a color for the left microdisplay or the right microdisplay .

At step the computed colors for the pixels are stored to produce at least one microdisplay image. The colors may be stored in a data structure e.g. frame buffer for a microdisplay image in a memory. The pixel colors for the left microdisplay define a left microdisplay image and the pixel colors for the right microdisplay define a right microdisplay image. At step the shader program determines if another existing image should be processed and if not the shader program terminates. Otherwise steps are repeated to produce one or more additional microdisplay images.

As previously explained pixel values of an array of elemental images i.e. microdisplay image may be modified to compensate for one or more defective pixels of a microdisplay. The ability to compensate for defective pixels enables the use of larger and higher resolution microdisplays that may have defects for near eye light field display devices. In one embodiment a computationally efficient tomographic optimization framework may be used to exploit redundancy within the array of elemental images to compensate for defects.

The ISO 13406 2 standard identifies three types of flat panel display defects ISO 2000 . A type 1 defect corresponds to a hot pixel i.e. a group of color subpixels that are continuously illuminated . A type 2 defect is a so called dead pixel i.e. appearing continuously dark . Finally a type 3 defect is a single color subpixel that is either continuously on or off. ISO 13406 2 classifies flat panel displays by the maximum allowed density of such defects with additional constraints on the allowed spacing of clusters of various defect types.

An array of elemental images is displayed by a microdisplay of a near eye light field display device because the near eye light field display device includes multiple magnifiers e.g. microlenses pinholes or pinlights . In contrast an array conventional head mounted display designs employ simple magnifiers and without redundancy the ability to compensate for defects is very limited. Each of the microdisplay pixels in the near eye light field display device produces a distinct ray of the emitted light field. The resulting bundle of rays which passes through differing microlenses but within the viewing eye box converges close to the position of a point within a virtual image at the virtual display plane. For a diffuse point the radiances should be nearly identical even for specular points variation will be moderate due to the small solid angle defined by the viewing eye box and the virtual point . As a result redundancy in the array of elemental images provides a mechanism to compensate for display defects distributing the error due to any given defect among the microdisplay pixels corresponding with the same point in the virtual image.

In the following discussion the microdisplay pixels are represented as a column vector m of length N with each element mrepresenting the radiant emittance of a pixel. Similarly the ideal retinal image is modeled as a column vector r of length M. Note that the ideal retinal image corresponds to the virtual image including a virtual image that is computed using the method shown in .

In one embodiment the position x y z coordinates and size e.g. diameter of the viewer s pupil is known. As a result the irradiance rat a given point in the retinal image is modeled as a weighted summation of microdisplay pixel emittances corresponding with the integration of the set of optical rays entering the pupil and impinging on a portion of the retinal image e.g. point . The image formation model may be formally expressed as 

A defect correction algorithm provides a defect corrected microdisplay image circumflex over m such that the retinal image is optimally reproduced. In other words when the defect corrected microdisplay image circumflex over m is viewed using the near eye light field display device a corrected retinal image is produced that approximates the ideal retinal image r. In practice optimality should be defined using a perceptual error metric. However as described further herein a least squares criterion may be employed. For example the following constrained linear least squares formulation may be used 

Equation 1 can be efficiently solved using the simultaneous algebraic reconstruction technique SART developed by Andersen and Kak in 1984. The corrected microdisplay image circumflex over m at iteration k is given by the following update rule where defines the Hadamard element wise matrix product and the weight vectors w and v are defined as follows 

In experiments near eye light field displays appear particularly well suited for economical fabrication of large format microdisplays even if multi reticle manufacturing is required yield and cost can be controlled by exploiting redundancy within the element images. For example a microdisplay having 100 the defects of a class IV defect category per the ISO13406 2 standard may be used to produce an acceptable quality image when defect compensation techniques are used.

At step defect information for a microdisplay is received. In one embodiment the defect information is encoded as the vector d and matrix D. At step a projection matrix such as the matrix P is received. The projection matrix encodes the contribution of each pixel of the microdisplay without defects to a point of the virtual and or retinal image. The projection matrix is based on either the eyebox position or eye tracking information. Eye tracking information enables accurate prediction of the retinal image and therefore corresponding pixels. However in the absence of eye tracking information corresponding pixels can be identified by the geometry texture of the scene correspondences may be identified by inspecting the elemental image array . However without eye tracking information accurate mapping of pixels to rays that actually enter the eye at a given instance cannot be determined. As the accuracy of eye tracking information increases the set of rays entering the eye will be known with greater certainty. For instance knowing the position of the eye in the eyebox is very helpful knowing the pupil diameter is useful but not as critical. Finally knowing the plane of focus of the eye would be the last but least significant component of the eye tracking information.

At step an array of elemental images correspond to a retinal image r is received. The array of elemental images is the ideal array of elemental images i.e. microdisplay image and does not account for defects of the microdisplay. At step constraints that are imposed by the microdisplay are applied. Example constraints include the defect information and bounding the subpixel values computed for each pixel by 0 and 1. At step an equation such as equation 1 is solved to produce the corrected array of elemental images circumflex over m . The corrected array of elemental images i.e. the corrected microdisplay image includes one or more modified subpixel values for at least one pixel of the microdisplay. The one or more modified subpixel values may be increased or decreased compared with the original subpixel values in the retinal image r.

At step the shader program determines if another iteration will be performed and if so the shader program returns to step . Otherwise at step the shader program stores the modified values that were computed to generate the corrected array of elemental images circumflex over m . The corrected array of elemental images circumflex over m may then be displayed by the microdisplay to produce a corrected retinal image that substantially equals the retinal image r.

The pixel is magnified and projected to form the virtual image. The resolution of the virtual image may be 200 100 pixels when the elemental images are superimposed to form the virtual image. Therefore the resolution of the image that is used to produce the array of elemental images may have a similar resolution. In some cases a higher resolution image is filtered to generate a lower resolution image that is then processed to generate the array of elemental images.

However a higher resolution microdisplay e.g. 1280 720 pixels may be used when the generation of the elemental images accounts for the subpixel structure. More specifically the subpixel structure for a pixel may include the location of each subpixel shape of each subpixel the opaque region of the pixel the emissive profile of each subpixel e.g. luminance or brightness across the subpixel and the bit resolution of each subpixel. When the generation of the elemental images accounts for the subpixel structure the perceived resolution of the virtual image may be increased.

When the projection matrix accounts for the subpixel structure of the pixels comprising the microdisplay a high resolution image may be used to generate an array of elemental images. When viewed using the near eye light field display device the array of elemental images may superimpose the different elemental images in a manner that interleaves the different subpixel regions as shown in to improve the perceived resolution of the virtual image. As shown in the pixels and may each correspond to a different elemental image and the pixels and are superimposed to produce a portion of a virtual image. The subpixels within the pixels and are interleaved to produce a virtual image that seems to be higher resolution. The interleaving results from solving equation 1 using a projection matrix that accounts for the subpixel structure.

Processor generally represents any type or form of processing unit capable of processing data or interpreting and executing instructions. In certain embodiments processor may receive instructions from a software application or module. These instructions may cause processor to perform the functions of one or more of the example embodiments described and or illustrated herein.

System memory generally represents any type or form of volatile or non volatile storage device or medium capable of storing data and or other computer readable instructions. Examples of system memory include without limitation RAM ROM flash memory or any other suitable memory device. Although not required in certain embodiments computing system may include both a volatile memory unit such as for example system memory and a non volatile storage device such as for example primary storage device .

Computing system may also include one or more components or elements in addition to processor and system memory . For example in the embodiment of computing system includes a memory controller an input output I O controller and a communication interface each of which may be interconnected via a communication infrastructure . Communication infrastructure generally represents any type or form of infrastructure capable of facilitating communication between one or more components of a computing device. Examples of communication infrastructure include without limitation a communication bus such as an Industry Standard Architecture ISA Peripheral Component Interconnect PCI PCI Express PCIe or similar bus and a network.

Memory controller generally represents any type or form of device capable of handling memory or data or controlling communication between one or more components of computing system . For example memory controller may control communication between processor system memory and I O controller via communication infrastructure .

I O controller generally represents any type or form of module capable of coordinating and or controlling the input and output functions of a computing device. For example I O controller may control or facilitate transfer of data between one or more elements of computing system such as processor system memory communication interface display adapter input interface and storage interface .

Communication interface broadly represents any type or form of communication device or adapter capable of facilitating communication between example computing system and one or more additional devices. For example communication interface may facilitate communication between computing system and a private or public network including additional computing systems. Examples of communication interface include without limitation a wired network interface such as a network interface card a wireless network interface such as a wireless network interface card a modem and any other suitable interface. In one embodiment communication interface provides a direct connection to a remote server via a direct link to a network such as the Internet. Communication interface may also indirectly provide such a connection through any other suitable connection.

Communication interface may also represent a host adapter configured to facilitate communication between computing system and one or more additional network or storage devices via an external bus or communications channel. Examples of host adapters include without limitation Small Computer System Interface SCSI host adapters Universal Serial Bus USB host adapters IEEE Institute of Electrical and Electronics Engineers 1394 host adapters Serial Advanced Technology Attachment SATA and External SATA eSATA host adapters. Advanced Technology Attachment ATA and Parallel ATA PATA host adapters Fibre Channel interface adapters Ethernet adapters or the like. Communication interface may also allow computing system to engage in distributed or remote computing. For example communication interface may receive instructions from a remote device or send instructions to a remote device for execution.

As illustrated in computing system may also include at least one display device coupled to communication infrastructure via a display adapter . Display device generally represents any type or form of device capable of visually displaying information forwarded by display adapter . Similarly display adapter generally represents any type or form of device configured to forward graphics text and other data for display on display device . In one embodiment the display device may be the near eye light field display device or the binocular near eye light field display device shown in or D and one or more components shown in the computing system may be integrated into an eyeglass form factor of the near eye light field display device or the binocular near eye light field display device shown in or D. In one embodiment one or more of the components shown in the computing system are external to the eyeglass form factor and may be worn elsewhere by a user or may be entirely remote i.e. connected via a wireless or wired communication system . A power supply i.e. battery power source or power interface may be integrated into the eyeglass form factor or may be external to the eyeglass form factor.

As illustrated in computing system may also include at least one input device coupled to communication infrastructure via an input interface . Input device generally represents any type or form of input device capable of providing input either computer or human generated to computing system . Examples of input device include without limitation a keyboard a pointing device a speech recognition device an eye tracking system ambient light sensing system depth sensor light field camera environmental motion tracking sensor an internal motion tracking sensor a gyroscopic sensor accelerometer sensor an electronic compass sensor a charge coupled device CCD image sensor a complementary metal oxide semiconductor CMOS image sensor or any other input device. In one embodiment the input device may be configured to provide the pupil characteristics such as the diameter orientation and position to the processor . In one embodiment the input device may also receive communications from other near eye light field display devices i.e. near eye light field eyeglasses in the environment for example when multiple users of near eye light field display devices are nearby.

As illustrated in computing system may also include a primary storage device and a backup storage device coupled to communication infrastructure via a storage interface . Storage devices and generally represent any type or form of storage device or medium capable of storing data and or other computer readable instructions. For example storage devices and may be a magnetic disk drive e.g. a so called hard drive a floppy disk drive a magnetic tape drive an optical disk drive a flash drive or the like. Storage interface generally represents any type or form of interface or device for transferring data between storage devices and and other components of computing system .

In one example databases may be stored in primary storage device . Databases may represent portions of a single database or computing device or it may represent multiple databases or computing devices. For example databases may represent be stored on a portion of computing system . Alternatively databases may represent be stored on one or more physically separate devices capable of being accessed by a computing device such as computing system .

Continuing with reference to storage devices and may be configured to read from and or write to a removable storage unit configured to store computer software data or other computer readable information. Examples of suitable removable storage units include without limitation a floppy disk a magnetic tape an optical disk a flash memory device or the like. Storage devices and may also include other similar structures or devices for allowing computer software data or other computer readable instructions to be loaded into computing system . For example storage devices and may be configured to read and write software data or other computer readable information. Storage devices and may also be a part of computing system or may be separate devices accessed through other interface systems.

Many other devices or subsystems may be connected to computing system . Conversely all of the components and devices illustrated in need not be present to practice the embodiments described herein. The devices and subsystems referenced above may also be interconnected in different ways from that shown in . Computing system may also employ any number of software firmware and or hardware configurations. For example the example embodiments disclosed herein may be encoded as a computer program also referred to as computer software software applications computer readable instructions or computer control logic on a computer readable medium.

The computer readable medium containing the computer program may be loaded into computing system . All or a portion of the computer program stored on the computer readable medium may then be stored in system memory and or various portions of storage devices and . When executed by processor a computer program loaded into computing system may cause processor to perform and or be a means for performing the functions of the example embodiments described and or illustrated herein. Additionally or alternatively the example embodiments described and or illustrated herein may be implemented in firmware and or hardware.

For example a computer program for determining an image and or a mask to be encoded in a near eye display layer based on a target image may be stored on the computer readable medium and then stored in system memory and or various portions of storage devices and . When executed by the processor the computer program may cause the processor to perform and or be a means for performing the functions required for carrying out the determination of an image and or the mask encoding different attenuation patterns discussed above.

While the foregoing disclosure sets forth various embodiments using specific block diagrams flowcharts and examples each block diagram component flowchart step operation and or component described and or illustrated herein may be implemented individually and or collectively using a wide range of hardware software or firmware or any combination thereof configurations. In addition any disclosure of components contained within other components should be considered as examples because many other architectures can be implemented to achieve the same functionality.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

The process parameters and sequence of steps described and or illustrated herein are given by way of example only. For example while the steps illustrated andior described herein may be shown or discussed in a particular order these steps do not necessarily need to be performed in the order illustrated or discussed. The various example methods described and or illustrated herein may also omit one or more of the steps described or illustrated herein or include additional steps in addition to those disclosed.

While various embodiments have been described and or illustrated herein in the context of fully functional computing systems one or more of these example embodiments may be distributed as a program product in a variety of forms regardless of the particular type of computer readable media used to actually carry out the distribution. The embodiments disclosed herein may also be implemented using software modules that perform certain tasks. These software modules may include script batch or other executable files that may be stored on a computer readable storage medium or in a computing system. These software modules may configure a computing system to perform one or more of the example embodiments disclosed herein. One or more of the software modules disclosed herein may be implemented in a cloud computing environment. Cloud computing environments may provide various services and applications via the Internet. These cloud based services e.g. software as a service platform as a service infrastructure as a service etc. may be accessible through a Web browser or other remote interface. Various functions described herein may be provided through a remote desktop environment or any other cloud based computing environment.

The foregoing description for purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as may be suited to the particular use contemplated.

Embodiments according to the invention are thus described. While the present disclosure has been described in particular embodiments it should be appreciated that the invention should not be construed as limited by such embodiments but rather construed according to the below claims.

