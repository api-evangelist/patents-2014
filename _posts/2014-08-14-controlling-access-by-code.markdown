---

title: Controlling access by code
abstract: A novel code signing system, computer readable media, and method are provided. The code signing method includes receiving a code signing request from a requestor in order to gain access to one or more specific application programming interfaces (APIs). A digital signature is provided to the requestor. The digital signature indicates authorization by a code signing authority for code of the requestor to access the one or more specific APIs. In one example, the digital signature is provided by the code signing authority or a delegate thereof. In another example, the code signing request may include one or more of the following: code, an application, a hash of an application, an abridged version of the application, a transformed version of an application, a command, a command argument, and a library.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507920&OS=09507920&RS=09507920
owner: BlackBerry Limited
number: 09507920
owner_city: Waterloo, Ontario
owner_country: CA
publication_date: 20140814
---
This application is a continuation of Software Code Signing System And Method U.S. application Ser. No. 13 754 162 filed Jan. 30 2013 which claims priority to the following prior applications Software Code Signing System And Method U.S. application Ser. No. 10 381 219 filed Mar. 20 2003 now U.S. Pat. No. 8 489 868 Code Signing System And Method U.S. Provisional Application No. 60 234 152 filed Sep. 21 2000 Code Signing System And Method U.S. Provisional Application No. 60 235 354 filed Sep. 26 2000 Code Signing System And Method U.S. Provisional Application No. 60 270 663 filed Feb. 20 2001 and Code Signing System and Method International PCT Application No. CA 01 01344 filed Sep. 20 2001. The entire disclosures of each of the above referenced applications are hereby incorporated by reference hereinto in their entirety.

This invention relates generally to the field of security protocols for software applications. More particularly the invention provides a code signing system and method that is particularly well suited for Java applications for mobile communication devices such as Personal Digital Assistants cellular telephones and wireless two way communication devices collectively referred to hereinafter as mobile devices or simply devices .

Security protocols involving software code signing schemes are known. Typically such security protocols are used to ensure the reliability of software applications that are downloaded from the Internet. In a typical software code signing scheme a digital signature is attached to a software application that identifies the software developer. Once the software is downloaded by a user the user typically must use his or her judgment to determine whether or not the software application is reliable based solely on his or her knowledge of the software developer s reputation. This type of code signing scheme does not ensure that a software application written by a third party for a mobile device will properly interact with the device s native applications and other resources. Because typical code signing protocols are not secure and rely solely on the judgment of the user there is a serious risk that destructive Trojan horse type software applications may be downloaded and installed onto a mobile device.

There also remains a need for network operators to have a system and method to maintain control over which software applications are activated on mobile devices.

There remains a further need in 2.5G and 3G networks where corporate clients or network operators would like to control the types of software on the devices issued to its employees.

A code signing system and method is provided. The code signing system operates in conjunction with a software application having a digital signature and includes an application platform an application programming interface API and a virtual machine. The API is configured to link the software application with the application platform. The virtual machine verifies the authenticity of the digital signature in order to control access to the API by the software application.

A code signing system for operation in conjunction with a software application having a digital signature according to another embodiment of the invention comprises an application platform a plurality of APIs each configured to link the software application with a resource on the application platform and a virtual machine that verifies the authenticity of the digital signature in order to control access to the API by the software application wherein the virtual machine verifies the authenticity of the digital signature in order to control access to the plurality of APIs by the software application.

According to a further embodiment of the invention a method of controlling access to sensitive application programming interfaces on a mobile device comprises the steps of loading a software application on the mobile device that requires access to a sensitive API determining whether or not the software application includes a digital signature associated with the sensitive API and if the software application does not include a digital signature associated with the sensitive API then denying the software application access to the sensitive API.

In another embodiment of the invention a method of controlling access to an application programming interface API on a mobile device by a software application created by a software developer comprises the steps of receiving the software application from the software developer reviewing the software application to determine if it may access the API if the software application may access the API then appending a digital signature to the software application verifying the authenticity of a digital signature appended to a software application and providing access to the API to software applications for which the appended digital signature is authentic.

A method of restricting access to a sensitive API on a mobile device according to a further embodiment of the invention comprises the steps of registering one or more software developers that are trusted to design software applications which access the sensitive API receiving a hash of a software application determining if the software application was designed by one of the registered software developers and if the software application was designed by one of the registered software developers then generating a digital signature using the hash of the software application wherein the digital signature may be appended to the software application and the mobile device verifies the authenticity of the digital signature in order to control access to the sensitive API by the software application.

In a still further embodiment a method of restricting access to application programming interfaces on a mobile device comprises the steps of loading a software application on the mobile device that requires access to one or more API determining whether or not the software application includes a digital signature associated with the mobile device and if the software application does not include a digital signature associated with the mobile device then denying the software application access to the one or more APIs.

Referring now to the drawing figures is a diagram illustrating a code signing protocol according to one embodiment of the invention. An application developer creates a software application application Y for a mobile device that requires access to one or more sensitive APIs on the mobile device. The software application Y may for example be a Java application that operates on a Java virtual machine installed on the mobile device. An API enables the software application Y to interface with an application platform that may include for example resources such as the device hardware operating system and core software and data models. In order to make function calls to or otherwise interact with such device resources a software application Y must access one or more APIs. APIs can thereby effectively bridge a software application and associated device resources. In this description and the appended claims references to API access should be interpreted to include access of an API in such a way as to allow a software application Y to interact with one or more corresponding device resources. Providing access to any API therefore allows a software application Y to interact with associated device resources whereas denying access to an API prevents the software application Y from interacting with the associated resources. For example a database API may communicate with a device file or data storage system and access to the database API would provide for interaction between a software application Y and the file or data storage system. A user interface UI API would communicate with controllers and or control software for such device components as a screen a keyboard and any other device components that provide output to a user or accept input from a user. In a mobile device a radio API may also be provided as an interface to wireless communication resources such as a transmitter and receiver. Similarly a cryptographic API may be provided to interact with a crypto module which implements crypto algorithms on a device. These are merely illustrative examples of APIs that may be provided on a device. A device may include any of these example APIs or different APIs instead of or in addition to those described above.

Preferably any API may be classified as sensitive by a mobile device manufacturer or possibly by an API author a wireless network operator a device owner or operator or some other entity that may be affected by a virus or malicious code in a device software application. For instance a mobile device manufacturer may classify as sensitive those APIs that interface with cryptographic routines wireless communication functions or proprietary data models such as address book or calendar entries. To protect against unauthorized access to these sensitive APIs the application developer is required to obtain one or more digital signatures from the mobile device manufacturer or other entity that classified any APIs as sensitive or from a code signing authority acting on behalf of the manufacturer or other entity with an interest in protecting access to sensitive device APIs and append the signature s to the software application Y .

In one embodiment a digital signature is obtained for each sensitive API or library that includes a sensitive API to which the software application requires access. In some cases multiple signatures are desirable. This would allow a service provider company or network operator to restrict some or all software applications loaded or updated onto a particular set of mobile devices. In this multiple signature scenario all APIs are restricted and locked until a global signature is verified for a software application. For example a company may wish to prevent its employees from executing any software applications onto their devices without first obtaining permission from a corporate information technology IT or computer services department. All such corporate mobile devices may then be configured to require verification of at least a global signature before a software application can be executed. Access to sensitive device APIs and libraries if any could then be further restricted dependent upon verification of respective corresponding digital signatures.

The binary executable representation of software application Y may be independent of the particular type of mobile device or model of a mobile device. Software application Y may for example be in a write once run anywhere binary format such as is the case with Java software applications. However it may be desirable to have a digital signature for each mobile device type or model or alternatively for each mobile device platform or manufacturer. Therefore software application Y may be submitted to several code signing authorities if software application Y targets several mobile devices.

Software application Y is sent from the application developer to the code signing authority . In the embodiment shown in the code signing authority reviews the software application Y although as described in further detail below it is contemplated that the code signing authority may also or instead consider the identity of the application developer to determine whether or not the software application Y should be signed. The code signing authority is preferably one or more representatives from the mobile device manufacturer the authors of any sensitive APIs or possibly others that have knowledge of the operation of the sensitive APIs to which the software application needs access.

If the code signing authority determines that software application Y may access the sensitive API and therefore should be signed then a signature not shown for the software application Y is generated by the code signing authority and appended to the software application Y . The signed software application Y comprising the software application Y and the digital signature is then returned to the application developer . The digital signature is preferably a tag that is generated using a private signature key maintained solely by the code signing authority . For example according to one signature scheme a hash of the software application Y may be generated using a hashing algorithm such as the Secure Hash Algorithm SHA1 and then used with the private signature key to create the digital signature. In some signature schemes the private signature key is used to encrypt a hash of information to be signed such as software application Y whereas in other schemes the private key may be used in other ways to generate a signature from the information to be signed or a transformed version of the information.

The signed software application Y may then be sent to a mobile device or downloaded by the mobile device over a wireless network . It should be understood however that a code signing protocol according to the present invention is not limited to software applications that are downloaded over a wireless network. For instance in alternative embodiments the signed software application Y may be downloaded to a personal computer via a computer network and loaded to the mobile device through a serial link or may be acquired from the application developer in any other manner and loaded onto the mobile device. Once the signed software application Y is loaded on the mobile device each digital signature is preferably verified with a public signature key before the software application Y is granted access to a sensitive API library. Although the signed software application Y is loaded onto a device it should be appreciated that the software application that may eventually be executed on the device is the software application Y . As described above the signed software application Y includes the software application Y and one or more appended digital signatures not shown . When the signatures are verified the software application Y can be executed on the device and access any APIs for which corresponding signatures have been verified.

The public signature key corresponds to the private signature key maintained by the code signing authority and is preferably installed on the mobile device along with the sensitive API. However the public key may instead be obtained from a public key repository not shown using the device or possibly a personal computer system and installed on the device as needed. According to one embodiment of a signature scheme the mobile device calculates a hash of the software application Y in the signed software application Y using the same hashing algorithm as the code signing authority and uses the digital signature and the public signature key to recover the hash calculated by the signing authority . The resultant locally calculated hash and the hash recovered from the digital signature are then compared and if the hashes are the same the signature is verified. The software application Y can then be executed on the device and access any sensitive APIs for which the corresponding signature s have been verified. As described above the invention is in no way limited to this particular illustrative example signature scheme. Other signature schemes including further public key signature schemes may also be used in conjunction with the code signing methods and systems described herein.

In steps and the code signing authority reviews the software application Y to determine whether or not it should be given access to the sensitive API and either accepts or rejects the software application. The code signing authority may apply a number of criteria to determine whether or not to grant the software application access to the sensitive API including for example the size of the software application the device resources accessed by the API the perceived utility of the software application the interaction with other software applications the inclusion of a virus or other destructive code and whether or not the developer has a contractual obligation or other business arrangement with the mobile device manufacturer. Further details of managing code signing authorities and developers are described below in reference to .

If the code signing authority accepts the software application Y then a digital signature and preferably a signature identification are appended to the software application Y in step . As described above the digital signature may be generated by using a hash of the software application Y and a private signature key . The signature identification is described below with reference to . Once the digital signature and signature identification are appended to the software application Y to generate a signed software application the signed software application Y is returned to the software developer in step . The software developer may then license the signed software application Y to be loaded onto a mobile device step . If the code signing authority rejects the software application Y however then a rejection notification is preferably sent to the software developer step and the software application Y will be unable to access any API s associated with the signature.

In an alternative embodiment the software developer may provide the code signing authority with only a hash of the software application Y or provide the software application Y in some type of abridged format. If the software application Y is a Java application then the device independent binary .class files may be used in the hashing operation although device dependent files such as .cod files used by the assignee of the present application may instead be used in hashing or other digital signature operations when software applications are intended for operation on particular devices or device types. By providing only a hash or abridged version of the software application Y the software developer may have the software application Y signed without revealing proprietary code to the code signing authority. The hash of the software application Y along with the private signature key may then be used by the code signing authority to generate the digital signature. If an otherwise abridged version of the software application Y is sent to the code signing authority then the abridged version may similarly be used to generate the digital signature provided that the abridging scheme or algorithm like a hashing algorithm generates different outputs for different inputs. This ensures that every software application will have a different abridged version and thus a different signature that can only be verified when appended to the particular corresponding software application from which the abridged version was generated. Because this embodiment does not enable the code signing authority to thoroughly review the software application for viruses or other destructive code however a registration process between the software developer and the code signing authority may also be required. For instance the code signing authority may agree in advance to provide a trusted software developer access to a limited set of sensitive APIs.

In still another alternative embodiment a software application Y may be submitted to more than one signing authority. Each signing authority may for example be responsible for signing software applications for particular sensitive APIs or APIs on a particular model of mobile device or set of mobile devices that supports the sensitive APIs required by a software application. A manufacturer mobile communication network operator service provider or corporate client for example may thereby have signing authority over the use of sensitive APIs for their particular mobile device model s or the mobile devices operating on a particular network subscribing to one or more particular services or distributed to corporate employees. A signed software application may then include a software application and at least one appended digital signature appended from each of the signing authorities. Even though these signing authorities in this example would be generating a signature for the same software application different signing and signature verification schemes may be associated with the different signing authorities.

Software application Y is an example of a signed software application. Each signed software application preferably includes an actual software application such as software application Y comprising for example software code that can be executed on the application platform one or more signature identifications and one or more corresponding digital signatures . Preferably each digital signature and associated signature identification in a signed software application or corresponds to a sensitive API library or to which the software application X or software application Y requires access. The sensitive API library or may include one or more sensitive APIs. In an alternative embodiment the signed software applications and may include a digital signature for each sensitive API within an API library or . The signature identifications may be unique integers or some other means of relating a digital signature to a specific API library or API application platform or model of mobile device .

API library A is an example of an API library that exposes a sensitive API. Each API library and including a sensitive API should preferably include a description string a public signature key and a signature identifier . The signature identifier preferably corresponds to a signature identification in a signed software application or and enables the virtual machine to quickly match a digital signature with an API library or . The public signature key corresponds to the private signature key maintained by the code signing authority and is used to verify the authenticity of a digital signature . The description string may for example be a textual message that is displayed on the mobile device when a signed software application or is loaded or alternatively when a software application X or Y attempts to access a sensitive API.

Operationally when a signed software application respectively including a software application X Z or Y that requires access to a sensitive API library or is loaded onto a mobile device the virtual machine searches the signed software application for an appended digital signature associated with the API library or . Preferably the appropriate digital signature is located by the virtual machine by matching the signature identifier in the API library or with a signature identification on the signed software application. If the signed software application includes the appropriate digital signature then the virtual machine verifies its authenticity using the public signature key . Then once the appropriate digital signature has been located and verified the description string is preferably displayed on the mobile device before the software application X or Y is executed and accesses the sensitive API. For instance the description string may display a message stating that Application Y is attempting to access API Library A and thereby provide the mobile device user with the final control to grant or deny access to the sensitive API.

In step the virtual machine retrieves the public signature key and signature identifier from the sensitive API library. The signature identifier is then used by the virtual machine in step to determine whether or not the software application has an appended digital signature with a corresponding signature identification . If not then the software application has not been approved for access to the sensitive API by a code signing authority and the software application is preferably prevented from being executed in step . In alternative embodiments a software application without a proper digital signature may be purged from the mobile device or may be denied access to the API library exposing the sensitive API but executed to the extent possible without access to the API library. It is also contemplated that a user may be prompted for an input when signature verification fails thereby providing for user control of such subsequent operations as purging of the software application from the device.

If a digital signature corresponding to the sensitive API library is appended to the software application and located by the virtual machine then the virtual machine uses the public key to verify the authenticity of the digital signature in step . This step may be performed for example by using the signature verification scheme described above or other alternative signature schemes. If the digital signature is not authentic then the software application is preferably either not executed purged or restricted from accessing the sensitive API as described above with reference to step . If the digital signature is authentic however then the description string is preferably displayed in step warning the mobile device user that the software application requires access to a sensitive API and possibly prompting the user for authorization to execute or load the software application step . When more than one signature is to be verified for a software application then the steps are preferably repeated for each signature before the user is prompted in step . If the mobile device user in step authorizes the software application then it may be executed and linked to the sensitive API library in step .

At step a code signing authority for one target device receives a target signing request from the developer. The target signing request includes the software application or a hash of the software application a developer identifier as well as at least one target device identifier which identifies the target device for which a signature is being requested. At step the signing authority consults a developer database or other records to determine whether or not to trust developer . This determination can be made according to several criteria discussed above such as whether or not the developer has a contractual obligation or has entered into some other type of business arrangement with a device manufacturer network operator service provider or device manufacturer. If the developer is trusted then the method proceeds at step . However if the developer is not trusted then the software application is rejected and not signed by the signing authority. Assuming the developer was trusted at step the signing authority determines if it has the target private key corresponding to the submitted target identifier by consulting a private key store such as a target private key database . If the target private key is found then a digital signature for the software application is generated at step and the digital signature or a signed software application including the digital signature appended to the software application is returned to the developer at step . However if the target private key is not found at step then the software application is rejected at step and no digital signature is generated for the software application.

Advantageously if target signing authorities follow compatible embodiments of the method outlined in a network of target signing authorities may be established in order to expediently manage code signing authorities and a developer community code signing process providing signed software applications for multiple targets with low likelihood of destructive code.

Should any destructive or otherwise problematic code be found in a software application or suspected because of behavior exhibited when a software application is executed on a device then the registration or privileges of the corresponding application developer with any or all signing authorities may also be suspended or revoked since the digital signature provides an audit trail through which the developer of a problematic software application may be identified. In such an event devices may be informed of the revocation by being configured to periodically download signature revocation lists for example. If software applications for which the corresponding digital signatures have been revoked are running on a device the device may then halt execution of any such software application and possibly purge the software application from its local storage. If preferred devices may also be configured to re execute digital signature verifications for instance periodically or when a new revocation list is downloaded.

Although a digital signature generated by a signing authority is dependent upon authentication of the application developer and confirmation that the application developer has been properly registered the digital signature is preferably generated from a hash or otherwise transformed version of the software application and is therefore application specific. This contrasts with known code signing schemes in which API access is granted to any software applications arriving from trusted application developers or authors. In the code signing systems and methods described herein API access is granted on an application by application basis and thus can be more strictly controlled or regulated.

Where the device is enabled for two way communications the device will incorporate a communication subsystem including a receiver a transmitter and associated components such as one or more preferably embedded or internal antenna elements and local oscillators LOs and a processing module such as a digital signal processor DSP . As will be apparent to those skilled in the field of communications the particular design of the communication subsystem will be dependent upon the communication network in which the device is intended to operate. For example a device destined for a North American market may include a communication subsystem designed to operate within the Mobitex mobile communication system or DataTAC mobile communication system whereas a device intended for use in Europe may incorporate a General Packet Radio Service GPRS communication subsystem .

Network access requirements will also vary depending upon the type of network . For example in the Mobitex and DataTAC networks mobile devices such as are registered on the network using a unique identification number associated with each device. In GPRS networks however network access is associated with a subscriber or user of a device . A GPRS device therefore requires a subscriber identity module not shown commonly referred to as a SIM card in order to operate on a GPRS network. Without a SIM card a GPRS device will not be fully functional. Local or non network communication functions if any may be operable but the device will be unable to carry out any functions involving communications over network other than any legally required operations such as 911 emergency calling.

When required network registration or activation procedures have been completed a device may send and receive communication signals over the network . Signals received by the antenna through a communication network are input to the receiver which may perform such common receiver functions as signal amplification frequency down conversion filtering channel selection and the like and in the example system shown in analog to digital conversion. Analog to digital conversion of a received signal allows more complex communication functions such as demodulation and decoding to be performed in the DSP . In a similar manner signals to be transmitted are processed including modulation and encoding for example by the DSP and input to the transmitter for digital to analog conversion frequency up conversion filtering amplification and transmission over the communication network via the antenna .

The DSP not only processes communication signals but also provides for receiver and transmitter control. For example the gains applied to communication signals in the receiver and transmitter may be adaptively controlled through automatic gain control algorithms implemented in the DSP .

The device preferably includes a microprocessor which controls the overall operation of the device. Communication functions including at least data and voice communications are performed through the communication subsystem . The microprocessor also interacts with further device subsystems or resources such as the display flash memory random access memory RAM auxiliary input output I O subsystems serial port keyboard speaker microphone a short range communications subsystem and any other device subsystems generally designated as . APIs including sensitive APIs requiring verification of one or more corresponding digital signatures before access is granted may be provided on the device to interface between software applications and any of the resources shown in .

Some of the subsystems shown in perform communication related functions whereas other subsystems may provide resident or on device functions. Notably some subsystems such as keyboard and display for example may be used for both communication related functions such as entering a text message for transmission over a communication network and device resident functions such as a calculator or task list.

Operating system software used by the microprocessor and possibly APIs to be accessed by software applications is preferably stored in a persistent store such as flash memory which may instead be a read only memory ROM or similar storage element not shown . Those skilled in the art will appreciate that the operating system specific device software applications or parts thereof may be temporarily loaded into a volatile store such as RAM . It is contemplated that received and transmitted communication signals may also be stored to RAM .

The microprocessor in addition to its operating system functions preferably enables execution of software applications on the device. A predetermined set of applications which control basic device operations including at least data and voice communication applications for example will normally be installed on the device during manufacture. A preferred application that may be loaded onto the device may be a personal information manager PIM application having the ability to organize and manage data items relating to the device user such as but not limited to e mail calendar events voice mails appointments and task items. Naturally one or more memory stores would be available on the device to facilitate storage of PIM data items on the device. Such PIM application would preferably have the ability to send and receive data items via the wireless network. In a preferred embodiment the PIM data items are seamlessly integrated synchronized and updated via the wireless network with the device user s corresponding data items stored or associated with a host computer system thereby creating a mirrored host computer on the mobile device with respect to the data items at least. This would be especially advantageous in the case where the host computer system is the mobile device user s office computer system. Further applications including signed software applications as described above may also be loaded onto the device through the network an auxiliary I O subsystem S serial port short range communications subsystem or any other suitable subsystem . The device microprocessor may then verify any digital signatures possibly including both global device signatures and API specific signatures appended to such a software application before the software application can be executed by the microprocessor and or access any associated sensitive APIs. Such flexibility in application installation increases the functionality of the device and may provide enhanced on device functions communication related functions or both. For example secure communication applications may enable electronic commerce functions and other such financial transactions to be performed using the device through a crypto API and a crypto module which implements crypto algorithms on the device not shown .

In a data communication mode a received signal such as a text message or web page download will be processed by the communication subsystem and input to the microprocessor which will preferably further process the received signal for output to the display or alternatively to an auxiliary I O device . A user of device may also compose data items such as email messages for example using the keyboard which is preferably a complete alphanumeric keyboard or telephone type keypad in conjunction with the display and possibly an auxiliary I O device . Such composed items may then be transmitted over a communication network through the communication subsystem .

For voice communications overall operation of the device is substantially similar except that received signals would preferably be output to a speaker and signals for transmission would be generated by a microphone . Alternative voice or audio I O subsystems such as a voice message recording subsystem may also be implemented on the device . Although voice or audio signal output is preferably accomplished primarily through the speaker the display may also be used to provide an indication of the identity of a calling party the duration of a voice call or other voice call related information for example.

The serial port in would normally be implemented in a personal digital assistant PDA type communication device for which synchronization with a user s desktop computer not shown may be desirable but is an optional device component. Such a port would enable a user to set preferences through an external device or software application and would extend the capabilities of the device by providing for information or software downloads to the device other than through a wireless communication network. The alternate download path may for example be used to load an encryption key onto the device through a direct and thus reliable and trusted connection to thereby enable secure device communication.

A short range communications subsystem is a further optional component which may provide for communication between the device and different systems or devices which need not necessarily be similar devices. For example the subsystem may include an infrared device and associated circuits and components or a Bluetooth communication module to provide for communication with similarly enabled systems and devices.

The embodiments described herein are examples of structures systems or methods having elements corresponding to the elements of the invention recited in the claims. This written description may enable those skilled in the art to make and use embodiments having alternative elements that likewise correspond to the elements of the invention recited in the claims. The intended scope of the invention thus includes other structures systems or methods that do not differ from the literal language of the claims and further includes other structures systems or methods with insubstantial differences from the literal language of the claims.

For example when a software application is rejected at step in the method shown in the signing authority may request that the developer sign a contract or enter into a business relationship with a device manufacturer or other entity on whose behalf the signing authority acts. Similarly if a software application is rejected at step authority to sign the software application may be delegated to a different signing authority. The signing of a software application following delegation of signing of the software application to the different authority can proceed substantially as shown in wherein the target signing authority that received the original request from the trusted developer at step requests that the software application be signed by the different signing authority on behalf of the trusted developer from the target signing authority. Once a trust relationship has been established between code signing authorities target private code signing keys could be shared between code signing authorities to improve performance of the method at step or a device may be configured to validate digital signatures from either of the trusted signing authorities.

In addition although described primarily in the context of software applications code signing systems and methods according to the present invention may also be applied to other device related components including but in no way limited to commands and associated command arguments and libraries configured to interface with device resources. Such commands and libraries may be sent to mobile devices by device manufacturers device owners network operators service providers software application developers and the like. It would be desirable to control the execution of any command that may affect device operation such as a command to change a device identification code or wireless communication network address for example by requiring verification of one or more digital signatures before a command can be executed on a device in accordance with the code signing systems and methods described and claimed herein.

