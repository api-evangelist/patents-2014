---

title: Security model for a layout engine and scripting engine
abstract: Various embodiments provide an interface between a Web browser's layout engine and a scripting engine. The interface enables objects from the layout engine to be recognized by a memory manager in the scripting engine and interact in a streamlined, efficient manner. In accordance with one or more embodiments, the interface allows browser layout engine objects to be created as objects that are native to the scripting engine. Alternately or additionally, in some embodiments, the native objects are further configured to proxy functionality between the layout engine and the scripting engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582479&OS=09582479&RS=09582479
owner: Microsoft Technology Licensing, LLC
number: 09582479
owner_city: Redmond
owner_country: US
publication_date: 20141103
---
This application is a continuation of and claims priority under 35 U.S.C. 120 to U.S. patent application Ser. No. 13 656 156 filed on Oct. 19 2012 which is a continuation of and priority is claimed to U.S. patent application Ser. No. 13 149 582 filed on May 31 2011 which is a continuation of and priority is claimed to U.S. patent application Ser. No. 13 114 924 filed on May 24 2011 the entire disclosures of each of these applications being incorporated by reference herein in their entirety.

Over time Web pages have evolved to include complex operations that can alter and or modify a document being rendered in a host environment. In order to achieve some of these complex operations Web programmers can utilize scripting languages to work within the host environment and with the document being rendered. Many host environments distinguish between a layout engine which facilitates the rendering of a document and a scripting engine which executes script included in an associated Web page. Scripts running in the scripting engine can be designed to access not only the document being rendered in the layout engine but objects and or elements within the document. In some cases when a layout engine supports standardized document access such as a Document Object Model DOM a Web programmer can write a script to manipulate a document and its elements based upon this model.

A layout engine and a scripting engine provide different functionality from one another and as such they typically reside on some level in separate modules. This can range from a simple logical separation to a more complex separation between software and or hardware components. More often these engines reside in separate and or associated software modules that communicate with one another. One benefit of this separation is that it enables a layout engine to more easily support multiple scripting engines. However since the layout engine is separated on some level from a scripting engine communication mechanisms between the modules oftentimes limit what can be exposed between the modules can adversely affect runtime performance and can introduce unintended memory management issues.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Various embodiments provide an interface between a Web browser s layout engine and a scripting engine. The interface enables objects from the layout engine to be recognized by a memory manager in the scripting engine and interact with the scripting engine in a streamlined efficient manner. In accordance with one or more embodiments the interface allows browser objects to be created as objects that are native to the scripting engine. Alternately or additionally in some embodiments the native objects are further configured to proxy functionality between the layout engine and the scripting engine.

In some embodiments binding between the Web browser s layout engine and the scripting engine can include features configured to enable unified programming access between the layout engine and the scripting engine. The features can be configured to enhance memory management enable direct access between the layout engine and scripting engine and or enable mutability of a dual nature object.

Various embodiments can also provide a security model that enables secure interactions between scripting engines residing in separate domains. In some cases protections can be employed to prevent object access and or restrict access to type system information. Alternately or additionally functions that include cross domain access functionality can be marked as safe. In some embodiments a sub window proxy can provide secure transactions across multiple domains to one or more sub objects associated with a window.

Various embodiments provide an interface between a Web browser s layout engine and a scripting engine. Typically as an overview to an example process a user will open a Web browser and navigate to a Web page. The Web page can be configured to determine what version of the Web browser is running such as what features are supported. At some point while the Web page is being rendered a scripting engine can be created such as through a dynamic request for functionality e.g. IDispatchEx or through a script being parsed. In some embodiments creation and or initialization of the scripting engine can include registering a type system establishing various relationships between the scripting engine and the Web browser s layout engine as well as constructing bindings that are associated with the various relationships as will be described below in detail. In some cases the user may navigate to a second Web page. Upon transitioning to the second Web page the Web browser can be configured to create a new scripting engine associated with the second page transfer objects from the first scripting engine to the new scripting engine and then close the first scripting engine.

The interface and bindings enable various objects from the layout engine to be recognized by a memory manager in the scripting engine and interact with the scripting engine in a streamlined efficient manner. In accordance with one or more embodiments the interface allows browser objects to be created as objects that are native to the scripting engine. Alternately or additionally in some embodiments the native objects are further configured to proxy functionality between the layout engine and the scripting engine.

In some embodiments binding between the Web browser s layout engine and the scripting engine can include features configured to enable unified programming access between the layout engine and the scripting engine. The features can be configured to enhance memory management enable direct access between the layout engine and scripting engine and or enable mutability of a dual nature object.

Various embodiments can also provide a security model that enables secure interactions between scripting engines residing in separate domains. In some cases protections can be employed to prevent object access and or restrict access to type system information. Alternately or additionally functions that include cross domain access functionality can be marked as safe. In some embodiments a sub window proxy can provide secure transactions across multiple domains to one or more sub objects associated with a window.

In one or more embodiments extensions to an Interface Definition Language IDL can enable direct integration of a layout engine and a scripting engine. In some embodiments the extended IDL can enable generation of code configured to bridge the layout engine and scripting engine. Alternately or additionally hierarchical relationships between objects and their associated APIs can be described using the extended IDL. In some embodiments the extended IDL can include syntax to describe attributes of the objects and or the associated APIs.

In the discussion that follows a section entitled Operating Environment is provided and describes one environment in which one or more embodiments can be employed. Following this a section entitled Object Integration and Memory Model describes an architecture that enables objects from a Web browser s layout engine to be recognized by a memory manager in a scripting engine and further enables streamlined interactions between the engines. After this a section entitled Direct System Integration describes provided features that enable direct system integration between a layout engine and a scripting engine. Next a section entitled Security Model describes how security can be enforced in accordance with one or more embodiments. Following this a section entitled Interface Definition Language Integration describes how an interface definition language can be extended to define a hierarchy of objects and their associated APIs and or attributes. After this a section entitled Other Considerations describes additional considerations and or features. Last a section entitled Example System describes an example system that can be utilized to implement one or more embodiments.

Having provided an overview of various embodiments that are to be described below consider now an example operating environment in which one or more embodiments can be implemented.

In addition computing device includes a software application in the form of a Web browser . Any suitable Web browser can be used examples of which are available from the assignee of this document and others. Browser can include or utilize separate modules in its functionality such as layout engine and scripting engine s . Layout engine includes functionality that can among other things process marked up content such as HTML XML image files etc. and formatting information such as CSS XSL etc. to render and or display formatted content. Scripting engine s include functionality that can process and execute scripting language code. While illustrated as being incorporated into browser it is to be appreciated and understood that scripting engine s can be implemented as standalone components. Alternately or additionally scripting engine s can be implemented as part of applications and or part of the system s operating system.

Computing device also includes a binding module which includes functionality that enables layout engine and scripting engine to bind interface and or communicate with one another as described in more detail below.

In addition computing device also includes a security module which includes functionality that enables cross domain security to be enforced with scripting engine and or layout engine as well as for efficiencies to be enhanced for same origin requests as described below. In some embodiments security module includes features and or functionality incorporated into and or utilized by layout engine and or scripting engine as further described below.

In one or more embodiments computing device also includes one or more extended Interface Definition Language IDL files . An extended IDL file can include various extensions to an IDL that enable further description and or definition for objects and their associated Application Programming Interfaces APIs as further described below.

In addition environment includes a network such as the Internet and one or more Web sites from and to which content can be received and sent. Such content can include any type of content that is typically received and processed by browser .

Computing device can be embodied as any suitable computing device such as by way of example and not limitation a desktop computer a portable computer a handheld computer such as a personal digital assistant PDA cell phone and the like.

Having described an example operating environment consider now a discussion of object integration and a memory model that enables a Web browser s layout engine to interface with one or more scripting engines in an efficient and streamlined manner.

In accordance with one or more embodiments an interface between a Web browser s layout engine and scripting engine enables objects from the layout engine to be integrated into the scripting engine memory space. For example in some embodiments objects native to the scripting engine memory space can be bound to objects associated with the layout engine memory space. To access the layout engine objects the scripting engine can access the objects native to scripting engine memory space. The native objects can be further configured to proxy functionality between the layout engine and the scripting engine.

As an example consider which illustrates relationship block diagram depicting a relationship between a scripting engine the scripting engine side and a layout engine the layout engine side in accordance with one or more embodiments. The scripting engine side includes three functional blocks user code script program dynamic properties and JavaScript Type System . The layout engine side includes two functional blocks document management code illustrated here as Document Object Model DOM code and attribute storage elements . While this example illustrates the scripting engine as a JavaScript engine and the layout engine as including a DOM as its standardized document access it is to be appreciated and understood that any type of script language and or standardized document access could be utilized without departing from the spirit of the claimed subject matter.

In the illustrated and described embodiment one or more trampolines are logically interposed between the scripting engine and the layout engine. As will become apparent below the trampoline serves to enable the scripting engine and layout engine to communicate and call functionality between each other.

In the illustrated and described embodiment user script code comprises script code that can be interpreted and executed by the scripting engine as will be appreciated by the skilled artisan. In some embodiments user script code can include script code from Web pages. Among other things user script code can include script that enables interaction with a host environment rendering a particular Web page. Script code can be embedded in or included from HTML pages and can interact with the DOM of the Web page. Typical simple uses of script code include by way of example and not limitation opening or popping up a new window with programmatic control over size position and attributes validating input values of a Web form to ensure that the values are acceptable before being submitted to a server and changing images as the mouse cursor moves over them.

Dynamic properties enable an ability to set and or change properties of objects associated with the scripting language and or scripting engine dynamically. In addition to setting and or changing properties of scripting language objects dynamic properties include the ability to dynamically set and or change properties associated with objects in the layout engine such as by way of example and not limitation various DOM objects included in and or associated with document object management code . Alternately or additionally dynamic properties can include properties prototypes and or objects created through execution of user code . It should be noted that dynamic properties regardless of their associated object s can be stored entirely in memory that is managed through the scripting engine.

In one or more embodiments type system is configured to associate a type with an object and or value such that the value and or object can be properly accessed. For example a type system can ensure that a correct prototype is used for the object and or value. Alternately or additionally type system can be configured to dynamically type objects and or values. In some embodiments type system can include type system information associated with one or more objects in document object management code .

On the layout engine side document management code includes functionality that enables the layout engine to create manage and or render documents. Document management code can also enable external exposure and or access of or to document s . For example a Web page can include user script code that when running in a scripting engine can use the external access of a document to program interactive features onto the document. In the illustrated and described embodiment dynamic properties include dynamic properties of document management code and are stored in the scripting engine memory space. Conversely attributes storage as illustrated here utilizes layout engine memory space. Attributes storage can include static attributes and or elements associated with document management code .

In one or more embodiments trampoline s logically interposed between the scripting engine side and the layout engine side represents at least one bridge between the scripting engine and the layout engine. As illustrated trampoline can be logically positioned between the scripting engine and the layout engine and in at least some embodiments can be configured redirect a call from an object in the scripting engine memory space into a related object in the layout engine memory space as further discussed below. Thus the trampoline serves as a redirection mechanism in which the scripting engine can directly call a function associated with an object native to the scripting engine yet have the call redirected to the layout engine for actual workload execution. Such a redirection mechanism enables the two engines to communicate without the need to request interface pointers identification values and the like. Accordingly the scripting engine and the layout engine can now be more tightly bound and have a wider range of access to cross engine objects.

As an example consider which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method are performed by a system such as the system illustrated in .

Step creates at least one trampoline function. The trampoline function can be created in any suitable way such as through C source and header files as further described in a section entitled Interface Definition Language Integration below. Step logically interposes the trampoline function between a scripting engine and a layout engine. Interposing the trampoline function between the two engines enables an ability to call functionality across the engines. Using the trampoline function step enables direct access between the scripting engine and the layout engine. For instance the trampoline function can be configured to enable calls from the scripting engine to be redirected as appropriate to the layout engine as further described above and below in a section entitled Dynamic Type System Direct Functions .

Having described a relationship between a scripting engine a layout engine and trampoline functions consider now which illustrates object relationships in a memory model that includes scripting engine memory space designated JavaScript and layout engine memory space designated COM to represent a Component Object Model COM based layout engine .

The layout engine memory space includes a variety of objects including a CBase object that represents a COM based object with relationships to other objects such as CBase object Internal Layout Engine object and ActiveX BHO object where BHO stands for Browser Helper Object .

The scripting engine memory space includes a variety of objects such as root object object graph object and var objects . Root object represents a pinned object to which var object is rooted or attached and object graph represents an object relationship graph of objects in the scripting engine memory space that are managed by a memory system manager. The scripting engine memory space has access and or bindings to the layout engine memory space through access links such as links .

In the illustrated and described embodiment each side of the memory model includes at least some objects that are associated with at least one object on the other side of the memory model. For example CBase object is linked and or bound to var object through linkage and CBase object is similarly linked and or bound to var object through linkage . Various mechanisms can be used to link and or bind objects as further discussed below.

In some embodiments CBase objects contain actual implementations for functionality which can be accessed via direct functions and or type operations configured to proxy or forward requests from the scripting engine to the CBase objects . For example a script running in the scripting engine has access to var objects which are native to the scripting engine memory space. The script does not necessarily have to have knowledge of the associated CBase objects nor the associated linkages. Instead the script can access the var objects as native objects to access request and or make calls or requests associated with certain functionality and information. In turn direct functions and or type operations that can be associated with var objects can be configured to proxy and or forward the call to an associated CBase object for actual execution of the call or request. This relationship enables the existence of an object that is in a sense dual in nature. Specifically an object can exist in the layout engine and can have an associated native representation created and maintained in the scripting engine.

Part of managing an object s dual nature includes managing a so called lifetime relationship between an object in the scripting engine such as var object and the corresponding object in the layout engine such as CBase object . For example if var object is actively being used by a script corresponding CBase object will also be actively used.

In some cases the memory management system can implement automatic memory management also referred to as garbage collection which attempts to reclaim memory when the memory is determined to no longer be in use. A more manual method of memory management in a garbage collected system involves pinning an object such that the garbage collector is not allowed to reclaim the object memory space until the object is manually unpinned. If an object is reclaimed prematurely the linkage between the dual nature object can be broken. Conversely an object can be marked as active multiple times thus creating a potential memory leak meaning that the memory is not reclaimed if all of the multiple active markings are not properly cleared.

In some embodiments an object graph such as object graph can be maintained by a garbage collector to identify what may be a reclaimable object. An object can maintain active participation in the object graph and subsequently the garbage collector through the use of the var objects. This active participation enables an object to maintain its lifespan without requiring the object to be pinned.

In some embodiments when a scripting language object associated with a dual nature object is created its identity can be bound with the layout engine object using an object referred to herein as CustomExternalObject with expanded custom data described just below. Furthermore the CustomExternalObject can expose relationships to a garbage collector thus enabling the garbage collector to more accurately track when an object can be recycled.

As an example consider which illustrates an example CustomExternalObject in accordance with one or more embodiments. CustomExternalObject includes an object which represents the scripting language object or var being created. In some embodiments the scripting language object is associated with a dual nature object. In addition to object CustomExternalObject includes a number of pointers e.g. five pointers CBase pointer parent var pointer child var pointer previous var pointer and next var pointer . Through the use of the pointers contained within the CustomExternalObject relationships between two or more objects can be managed.

More specifically in this particular example CBase pointer is a code pointer that points back to a layout engine object associated with a dual nature object. This pointer enables access between the scripting engine and layout engine identities of the dual nature object. Parent var pointer is a relationship pointer configured to point to a parent var object of object . Similarly child var pointer is a relationship pointer configured to point to a child var object of object . Previous var pointer and next var pointer are additional relationship pointers that are configured to point to siblings of object such as for example one of five attributes of a parent. Through the use of the relationship pointers object relationships are exposed to the garbage collector. This not only enables the garbage collector to more accurately manage the lifespan of an object but to do so without requiring any of the objects to be pinned.

Consider now which illustrates how the relationship pointers contained within an expanded CustomExternalObject can be employed in accordance with one or more embodiments.

Relationships between the layout engine objects and their associated CustomExternalObjects and can be expressed in the scripting engine memory space through the use of the additional relationship pointers described above. For example CustomExternalObject is a child of CustomExternalObject which is expressed through linkage that points the child var pointer of CustomExternalObject to CustomExternalObject and through linkage which points the parent var pointer of CustomExternalObject to CustomExternalObject . Alternately or additionally sibling relationships of objects can be expressed and or exposed as illustrated through linkages . In this particular example CustomExternalObject is not only a child object of CustomExternalObject but it is also a sibling of CustomExternalObject . As such the next var pointer of CustomExternalObject points to its next sibling CustomExternalObject as illustrated with link . Additionally CustomExternalObject points to its previous sibling CustomExternalObject as further illustrated with link . Through the use of this multi dimensional doubly linked list objects can be exposed to the scripting engine memory manager without requiring all of the objects to be pinned. In some embodiments a head or main object can be pinned in memory to anchor the main object from unintended destruction and or recycling from the memory manager.

Additional objects can be rooted to the main object such as through the doubly linked list thus enforcing some protection against the objects being prematurely recycled. For example when an object is created it can call a function to determine whether it should be pinned in memory or rooted to another object. If it is determined that the object should be rooted to an object the associated relationship pointers can be set accordingly such as through functions that setup parent child relationships between objects or functions that setup sibling relationships between objects.

In some embodiments the layout engine can create a CustomExternalObject and pass the object to the scripting engine. For example the layout engine can support an API configured to be callable by the scripting engine. Through execution of API calls the layout engine can create at least one CustomExternalObject that is native to the scripting engine memory space include in the CustomExternalObject s information that enables the scripting engine to access the layout engine and return the CustomExternalObject s to the calling scripting engine. Alternately or additionally APIs can be configured to support an ability for elements and or objects to be inserted into and or removed from the doubly linked list supported within a CustomExternalObject.

Step creates a layout engine object. The creation of the layout engine object can be performed in any suitable manner such as through an API call at startup through receipt of a message and or event and the like. Alternately or additionally the layout engine object can be an object created by the layout engine that is independent of the layout engine application such as a document being rendered by the layout engine an element of the document and the like. Step creates a scripting language object. Any suitable object can be created such as a CustomExternalObject as described above. The scripting language object includes any object native to the scripting engine memory space that is accessible through native methods of the scripting language. Alternately or additionally an object native to the scripting engine can include any object managed by a memory manager of the scripting engine.

Step binds the layout engine object to the scripting language object. Any suitable method can be utilized examples of which are provided above and below.

Having considered object integration and a corresponding memory model consider now a discussion of features that enable direct system integration in accordance with one or more embodiments.

In some embodiments binding between the Web browser s layout engine and the scripting engine can include or otherwise utilize features that enable unified programming access between the layout engine and the scripting engine such as enabling a programmer to access each side of a dual nature object in a consolidated manner. The features can enhance memory management enable direct access between the layout engine and scripting engine and or enable mutability of a dual nature object such as the dual nature objects described above.

Binding module includes in this particular example one or more Dynamic Type System Deferred Initialization modules one or more Dynamic Type System Direct Functions modules one or more Dynamic Type System Object Proxy modules one or more Dynamic Type System Overlay modules one or more Dynamic Type System Re initialization modules one or more Accessor Property modules one or more Replacement Property modules and one or more Dead Code Elimination modules each of which is described below. As a somewhat high level overview of these features consider the following discussion which is then followed by a discussion of each feature under its own sub heading.

In one or more embodiments Dynamic Type System Deferred Initialization module enables one or more dynamic type system objects to be initialized when requested and or as needed as will become apparent below.

In some embodiments Dynamic Type System Direct Function module can be configured as a redirect structure such as Trampoline of . Dynamic Type System Direct Function module s enable one or more function instance to be built directly into a scripting engine as a native object. Alternately or additionally Dynamic Type System Direct Function module s can be configured to generate a call from the native object to a layout engine backing object. A backing object is an object that can implement enforce and or execute requested functionality.

In one or more embodiments Dynamic Type System Object Proxy module enables a backing object such as an object in a layout engine to override or alter the behavior of an associated scripting engine object.

In one or more embodiments Dynamic Type System Overlay module enables script running in a scripting engine to replace modify and or eliminate an API associated with a corresponding layout engine object as further described below.

In one or more embodiments Dynamic Type System Re initialization module is configured to enable re initialization of one or more cross boundary objects such as by way of example and not limitation object s that are transferred to a different type system.

In one or more embodiments Accessor Property module enables getter and setter functionality of a layout engine object to be exposed and integrated with an associated scripting language object in a manner that is native to the scripting language as further described below. Getter and setter functions can be configured to execute certain functionality when a variable or object is accessed.

In one or more embodiments Replacement Property module can be configured to enforce a read only property assignment to an object such that values associated with the object can be redirected to another associated object.

In one or more embodiments Dead Code Elimination module is configured to make code execution more efficient. In some embodiments Dead Code Elimination module can be configured to skip execution of code determined to have no intended recipient as will be described below.

Having described a high level overview of various features included in binding module consider now a more detailed discussion of each feature.

Some initialization systems can include a number of objects e.g. 500 objects and even more functions e.g. 3000 functions. In some approaches the entire dynamic type system can be loaded up front in the scripting engine. Needless to say the time taken to do so can take a significant amount of startup time. This time can be compounded when for example a Web page has many frames e.g. for ads and the like and each frame has to load the dynamic type system. In one or more embodiments a deferred type system initialization can be utilized to build the dynamic type system in an on demand fashion. Doing so can mitigate in the time impact of loading and entire dynamic type system upfront. Thus when no DOM APIs are utilized very little type system initialization cost is incurred. As each new type is needed by for example a return value the approaches described below can create the type and its dependent types and functions just before they are needed. This can amortize the initialization cost of used DOM types and can eliminate the costs entirely for unused types.

In some embodiments one or more types in a type system can be initialized in a cascaded as needed manner. For example a particular type in the type system can be initialized in multiple stages such that the particular type becomes accessible and substantiated in the type system after all stages have completed. Information concerning the types in the type system can be initially exposed declared or have an associated identifier such that the type system is aware of the types. However full initialization of the type s can be staggered and or deferred until the type s is are to be accessed. Alternately or additionally if a type does not get accessed it does not become fully substantiated thus reducing the number of objects created in memory. For example deferring initialization can reserve memory usage for only those objects being actively used.

In one or more embodiments a base set of information associated with at least one type can be exposed in a type system to a script and or scripting engine. The base set of information can be associated with any sort of type such as by way of example and not limitation an object method property prototype and the like. In some embodiments the base set of information comprises constructors associated with the type s . Based upon the information the script and or scripting engine can inspect the various types that are available for access. In some embodiments the script and or scripting engine can inspect the various types without dynamically querying and or binding to the types. For example the various types can initially be exposed in the type system at startup. Runtime performance can improve by reducing or eliminating the need for queries which can be a time consuming operation. Instead the script and or scripting engine can have knowledge of the various types through the initial information and access the types accordingly without further steps in the script.

Upon accessing a type associated with the base set of information constructors of the type can be configured to point and or link to associated prototype information. In some embodiments the constructors can be configured to point to parent sibling and or child associations. Alternately or additionally requesting a particular type or prototype can further enable associated prototypes such as parent or super prototypes of the particular type to become available for access. Linking prototype information of associated types can enable a series of relationships between a set of objects and or prototypes thus further reducing redundant code between the object s .

Responsive to pointing and or linking one or more particular prototype constant properties and or methods of the particular prototype s can be initialized. For example the properties and or methods can be created in memory and initialized with default values. Alternately or additionally the initialized properties and or methods can be attached to the particular prototype s .

Responsive to initializing the properties and or methods an instance type operation is created and tied to an associated object in the layout engine. For example the instance type operation can be configured to create a var object in the scripting engine environment and bind the var object to its associated layout engine object examples of which are provided above and below.

As an example consider which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method are performed by software such as a suitably configured binding module executing on a client device.

Step exposes a base set of information associated with one or more types to a type system. For example the base set of information can include one or more constructors associated with the type s . In some embodiments the base set of information can be exposed to the type system statically at startup.

Responsive to access to the base set of information step initializes at least one link to at least one prototype implementation associated with the one or more types. For example a constructor can be configured to point to an associated prototype implementation. Accessing the constructor can cause the link to the associated prototype implementation to be initialized.

Step initializes the associated prototype implementation and in some embodiments the initialized prototype implementation can be attached to the type being initialized.

Step creates an instance object associated with the initialized type and further binds the instance to a backing object such as an object in a layout engine. In some embodiments the instance object can reside in a scripting engine s memory space while the backing object resides in the layout engine as described above.

Deferring and or cascading initialization of types in a dynamic type system as described above enables the types to be built when accessed in an efficient manner in addition to reserving memory for objects being actively utilized. Having considered Dynamic Type System Deferred Initialization consider now a discussion of Dynamic Type System Direct Functions.

In some systems functions were previously treated as host objects and were queried using a particular interface in a two step process. First the name of the function was queried to retrieve an ID and then with the ID the function was invoked. This two step process was found to be very costly and inefficient especially when it was used repeatedly.

In one or more embodiments this two step process can be eliminated entirely for objects in the dynamic type system. Objects can be built directly as native scripting engine e.g. JavaScript objects and can be accessed using an associated internal lookup process. Function instances can also be built directly into the scripting engine and are looked up using the same process. When the direct function is obtained for example using the scripting engine lookup process its invocation generates a call to the DOM s trampoline. The trampoline is able to perform caller validation to take parameters that are passed in and the invoking object s to ensure that only objects of the correct type can perform the invocation. In one or more embodiments this can be done by casting to a base object retrieving the object s type ID information comparing against a set of allowed type IDs.

More specifically in some embodiments a bridge function also known as a direct function or a trampoline as mentioned above can be created to bridge calls between the scripting engine and the layout engine. A scripting language function can wrap the bridge function such that the scripting engine can look up and access the bridge function through methods used to access objects native to the scripting engine e.g. through its internal look up process mentioned above . The bridge function can be further configured to marshal incoming parameters to an associated layout engine object and call into one or more methods of the associated layout engine object. Alternately or additionally the bridge function can be further configured to enable validation of callers of the function such as validation of the callers being of the correct calling type as mentioned above.

Objects built directly into and or via the scripting engine can be accessed by the scripting engine using native methods. For example an object created via a scripting language can be accessed by the scripting engine using native look up methods as mentioned above. In some embodiments a scripting language function can wrap a bridge function thus enabling the scripting engine to access the bridge function via the wrapped function. Since the wrapped function is native to the scripting language it can be manipulated by the scripting language and or scripting engine as other native objects. For example in some embodiments the wrapped function can be attached and or rooted to other objects which in turn can attach the associated functionality to the other objects.

As an example consider which illustrates various relationships associated with a bridge function in accordance with one or more embodiments. White boxes represent functionality implemented in a scripting language while grey boxes represent functionality implemented outside of the scripting language for example in C . includes one or more scripting language wrapper functions one or more bridge functions one or more layout engine objects and one or more Marshal De Marshal modules . Additionally includes flows and which represent one or more calls into Scripting Language Wrapper function into Marshal De Marshal module and Layout Engine object s respectively. While the arrows are illustrated as a one way arrow for simplicity of description it is to be appreciated that the flow of function calls can be two way without departing from the scope of the claimed subject matter.

Scripting language wrapper function represents a scripting language function that wraps bridge function . Scripting language wrapper function is native to the scripting language thus allowing the scripting language to call and manipulate the function using standard procedures such as those described above. Scripting language wrapper function includes information that enables the wrapper function to call into bridge function .

Among other things bridge function can be configured perform various forms of validation. For example in some embodiments bridge function can be configured to perform caller validation. Caller validation ensures that only objects of the correct calling type are calling the function. This can be achieved in many ways such as by utilizing object type identification ID information. In some embodiments as noted above an object can be cast to a base object and its associated ID information can be compared against a set of allowed type IDs. The set of allowed type IDs can also be configured to reflect allowed types included in one or more hierarchical relationships. Alternately or additionally bridge function can be configured to validate one or more parameters being passed into the function.

Bridge function s can also be configured to direct calls into one or more associated layout engine objects. In some embodiments bridge function can direct a call to an associated layout object after validation has been performed and or passed examples of which are provided above. Furthermore the call to an associated layout object can be directed through any suitable method such as through one or more APIs of the layout object. Parameters can be passed by bridge function through the use of marshal de marshal module . Marshal de marshal module represents functionality that enables objects and or data to be transferred from one program to another such as from a scripting engine to a layout engine.

Layout engine object represents any sort of object function and the like associated with a layout engine. For example layout engine object could be a document rendered by a layout engine an element within the document and the like. Layout engine object includes externally exposed methods functions and other forms of access that enable objects external to layout engine object to request functionality from the layout engine object as well as exchange data. In some embodiments data can be exchanged through the use of marshal de marshal module .

Flows and represent one example of how the various functions and or modules can interact. Flow represents a call from a scripting engine to scripting language wrapper function . As discussed above the scripting engine can call scripting language wrapper function in any manner native to the scripting engine. Upon getting called as shown by flow scripting language engine wrapper function calls into bridge function . Upon determining parameters need to be passed in some embodiments bridge function can utilize or call marshal de marshal module as illustrated by flow . Marshal de marshal module in response can pass the parameters into layout engine object as illustrated by flow . Alternately or additionally bridge function can have direct access into layout engine via APIs which is not illustrated in .

Bridge functions in combination with scripting language wrapper functions facilitate efficient access between a layout engine and a scripting engine. Additionally the combination further enables objects to be requested in a manner native to scripting engine but validated via the layout engine as discussed above. Having described Dynamic Type System Direct Functions consider now a discussion of Dynamic Type System Object Proxies.

Some DOM objects have special capabilities beyond those available to native scripting engine objects. For example if a DOM supports a type of dynamic array whose contents change and update as page elements are added and or removed by moving DOM objects into the scripting engine via the dynamic type system these extra capabilities are not provided natively by the scripting engine. In order to facilitate these features via the scripting engine objects e.g. JavaScript objects a proxy wrapper known as the type operations is provided to all objects.

Thus various embodiments enable a layout engine object to override capabilities of an associated scripting engine object. In one or more embodiments the proxy wrapper can be provided to the scripting engine object such that generic or native scripting language operations can be associated with and or applied to the scripting engine object. In some embodiments the proxy wrapper can be modified by the layout engine object to include additional and or alternate behavior.

As discussed above a dual nature object can comprise a scripting language object and a layout engine object. The scripting language object can be embodied as any type of object native to the scripting language such as an object function and or prototype that can be created in the scripting language memory space. Similarly the layout engine object can be embodied as any type of object generated in and or by the layout engine in the layout engine memory space examples of which are provided above. In some embodiments the layout engine object can alter properties functions and or behavior associated with the scripting language object. For example type operations associated with the scripting language object can execute native behavior of the scripting language. In some cases the native behavior of the scripting language may be different or out of sync with behavior that is native to the associated layout engine. For instance some features or extra capabilities as noted above supported by layout engine may not have comparable native support in the scripting language. The layout engine object can alter a type operation of the scripting language object to include additional and or completely different behavior when called. Any suitable type of alteration can be included such as an ability to support a dynamic array as mentioned above where contents of the array can be updated added and or removed. Further examples include using type operations to provide overrides for getting and setting properties property detection as well as control over when the type operations should be used e.g. during the JavaScript lookup operation process or after it fails to locate a property via the same process. Through these alterations the layout engine object can modify or add behavior to the scripting language object to mimic its own native behavior.

Consider which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method are performed by suitably configured software executing on a computing device such as binding module layout engine and or scripting engine of .

Step creates a layout engine object. The creation of the layout engine object can be performed in any suitable manner. Any suitable type of layout engine object can be created examples of which are provided above. Step creates a scripting language object such as an object that is native to a scripting engine memory space. Step modifies a type operation associated with the scripting language object to model behavior native to the layout engine object examples of which are provided above and below.

Having described dynamic type system object proxies consider now a discussion of dynamic type system overlay.

APIs in the dynamic type system are mutable versus the legacy type system which was static and could only be altered in very limited ways. Thus JavaScript programs can replace built in DOM APIs with their own cache and call the APIs or even delete the APIs outright. In these instances this only affects the direct function entry points and not the static DOM which supports the code behind them.

In one or more embodiments the mutability or lack thereof is controlled via individual property s property descriptor. Property descriptors have meta information that is consumable by the scripting engine e.g. the JavaScript engine. Property descriptors provide control enumerability configurability e.g. whether an API can be changed or deleted and a write ability e.g. whether data properties or fields can have their values changed .

In one or more embodiments once the APIs have been initialized into the scripting engine e.g. JavaScript engine built in scripting engine APIs work on associated objects as if they are native objects. For example an operator known as instanceof checks whether a given instance is a member of a given type. The JavaScript implementation can query an instance s type and traverse an associated property s type chain comparing the right argument to the operator against each DOM type s prototype object. In one or more embodiments property descriptors are accessed and modified via the same JavaScript native APIs as any other JavaScript object. In this manner the JavaScript program can dynamically modify the DOM APIs without affecting the static DOM code. This integration allows greater integration and seamless behavior with less complication in overhead.

Consider which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method are performed by suitably configured software executing on a computing device such as binding module layout engine and or scripting engine of .

Step creates a layout engine object. The creation of the layout engine object can be performed in any suitable manner. Any suitable type of layout engine object can be created examples of which are provided above. Step creates a scripting language object such as an object that is native to a scripting engine memory space. Step modifies dynamically at least one API associated with the layout engine object through the scripting language object examples of which are provided above and below.

Having described dynamic type system overlay consider now a discussion of dynamic type system re initialization.

Various embodiments enable an object native to a scripting engine environment to be transferred to a second scripting engine and or type system. Such can mitigate security scenarios where for example an object s type can provide an inadvertent leak of information. In at least some embodiments information associated with at least one property and or prototype of the object can be transferred to the second scripting engine and or type system. In some embodiments an object that has changed from an initial state can be transferred with its state changes intact.

In operation an object can be created that is native to a scripting language environment. Such can occur for example by a scripting engine running a script through the layout engine returning a native scripting language object to the scripting engine and the like. At times the layout engine may desire to have an object that is native to the first scripting engine transferred or re initialized to another scripting engine. For example in some instances the layout engine may desire a scripting language object that has a dual nature as described above to be transferred to a second scripting engine. To do so attributes of the first scripting engine object can be copied and or translated to a second scripting engine object thus effectively transferring or re initializing the first scripting engine object to the second scripting engine. In this way bindings between a dual nature object can be preserved when transferring between multiple scripting engines. Additionally in some embodiments the first scripting language object can be removed or deleted without affecting the second scripting language object.

Additionally the scripting language can enable properties of the object to be dynamically changed such as prototypes functions inheritance and or property chain and the like. For example default values default properties default inheritance chains and the like can be dynamically altered over time. In some embodiments the altered properties of an object in the first scripting engine can be transferred to the corresponding object in the second scripting engine such as by copying them. In this manner static and dynamic changes associated with scripting objects can be preserved across several boundaries.

Consider which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method are performed by suitably configured software executing on a computing device such as binding module layout engine and or scripting engine of .

Step creates a first scripting language object that is native to a language of a first scripting engine. The creation of the first scripting language object can be performed in any suitable manner. Alternately or additionally any suitable type of scripting language object can be created examples of which are provided above. Step creates a second scripting language object that is native to a language of a second scripting language. In some embodiments the first and second scripting languages are not the same language. In other embodiments the first and second scripting languages are the same. Step copies at least in part attributes associated with the first scripting language object from the first scripting engine to the second scripting language object. Any suitable attribute can be copied such as a pointer a value a data structure and the like. In some embodiments bindings included in the first scripting language object can be copied to the second scripting language object. Alternately or additionally a translation and or transformation can be applied to an attribute to confirm to the second scripting language.

Accordingly scripting language objects can be transferred across boundaries of multiple scripting engines and or type systems while preserving properties of the objects such as inheritance prototypes and the like. Having described dynamic type system re initialization consider now a discussion of accessor properties.

Various embodiments enable direct access to getter and setter accessors of a dual nature object. Getter accessors can be called separately from setter accessors using unique signatures for each.

Accessors enable access to a property variable and or value without direct exposure of an associated object. For example a script can set a value or property of an object by calling a setter accessor without the script having direct access to the associated object or variable storing the value and or property. Similarly the script can get a value or property by calling a getter accessor. In some embodiments getter and setter functionality of the layout engine object can be exposed and integrated with an associated scripting language object in a manner that is native to the scripting language. For example direct functions can be used to integrate accessors associated with the layout engine object into the scripting engine.

In some embodiments each accessor can have a unique signature. For example different direct functions can be used for a getter and setter respectively. This enables a script object prototype and the like to call each getter and setter uniquely. Thus direct functions can be used to enable access from a scripting engine to accessors associated with layout engine objects. Through the use of unique direct functions for each setter and getter setter and getter functions can be called directly instead of passing one or more parameters to a shared function or ID in order to distinguish between the two.

Consider which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method are performed by suitably configured software executing on a computing device such as binding module layout engine and or scripting engine of .

Step creates a layout engine object. The creation of the layout engine object can be performed in any suitable manner. Any suitable type of layout engine object can be created examples of which are provided above. Step creates a scripting language object such as an object that is native to a scripting engine memory space. Step calls one or more accessors associated with the layout engine object through the scripting engine object without one or more parameters that are configured to distinguish between the one or more accessors. For example each accessor can be configured to have a unique signature as described above.

Various embodiments enable a read only property to be replaceable. Replace ability pertains to a situation in which a read only property is changed. Specifically when a read only property is assigned a value the original read only property is removed and the newly assigned property takes its place. In one or more embodiments this semantic is supported by assigning a put accessor value to the read only property. When it is then invoked an associated interface is used to create a new property on the calling instance object that then shadows the read only API. Using this technique future requests for the read only properly will correctly obtain the shadowed property instead. Furthermore if the shadowed property is ever deleted the original replaceable read only is once again accessible.

Thus in some embodiments a replaceable value can be a shadow value configured to virtually replace the read only property. Alternately or additionally a setter accessor associated with the read only property can be implemented to mimic read only behavior.

In some embodiments a read only property of a layout engine object can be configured to be replaceable in the manner just described. For example in a dual nature object such as those described above the scripting language object can be configured to virtually set the replaceable read only property value on the scripting engine side without physically replacing the layout engine object value. A shadow value can then be stored as a field on an instance object associated with the scripting language object. When a script or object queries the read only property the shadow value can then be returned. In one or more embodiments deleting the shadow value as mentioned above can then restore the read only property to an original value such as that of the layout engine object.

For example consider which illustrates a process diagram describing read only replaceable properties. When attempting to access a read only replaceable property the scripting language lookup path begins at instance object . From instance object the lookup path moves to associated prototype object . In some embodiments prototype object can comprise read only replaceable property which can be an accessor property. Each accessor e.g. getter and setter can be configured as a direct function into an associated layout engine object. Further setter direct function can be configured to create new field property associated and or attached to instance object when invoked with a value. In future calls through the scripting engine lookup path since instance object resides first in the path field property will be found first and the value returned.

As a further example consider which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method are performed by suitably configured software executing on a computing device such as binding module layout engine and or scripting engine of .

Step creates a layout engine object. The creation of the layout engine object can be performed in any suitable manner. Any suitable type of layout engine object can be created examples of which are provided above. Step creates a scripting language object such as an object that is native to a scripting engine memory space. Step virtually sets a replaceable read only property of the layout engine object through the scripting language object without physically replacing the layout engine object property such as through a shadow value as described above.

Various embodiments enable an evaluation of code usage and for efficiencies to be enhanced through so called dead code elimination. In some embodiments execution of the code can be prevented based upon this evaluation.

In one or more embodiments code can be evaluated to determine whether its associated output used. For example in some embodiments a function and or prototype can return data such as a value string object and the like to an intended recipient. Usage of the returned data can be evaluated and if it is determined that the returned data is not to be used execution of associated code can be prevented. For example if there is no such intended recipient for the returned data code that ordinarily converts the returned data can be skipped thus saving processing time and improving performance. If the returned data does have an intended recipient then the associated code is allowed to run.

Having discussed dead code elimination consider now a discussion of a security model in accordance with one or more embodiments.

Various embodiments enable secure interactions between scripting engines residing in separate domains. In some cases protections can be employed to prevent object access and or restrict access to type system information. Alternately or additionally in some embodiments functions that include cross domain access functionality can be marked as safe thus allowing cross domain access. In some embodiments a sub window proxy can provide secure access across multiple domains to one or more sub objects associated with a window.

As an example consider which illustrates an expanded view of features included in a security module such as for example security module of . In some embodiments the features described below can be part of an architecture designed to enforce security within a layout engine and or a scripting engine such as cross domain security. While illustrates security module including a combination of features and or modules it is to be appreciated and understood that any combination of features can be included and or excluded without departing from the claimed subject matter. Moreover while the illustrated features are shown as separate modules it is to be appreciated and understood that one or more feature can be implemented as one module separate modules or any combination thereof.

In the illustrated and described embodiment security module includes one or more static property descriptor modules one or more API restriction modules one or more safe API identification modules one or more reflect function modules one or more sub window proxy modules and one or more same origin optimization modules .

In one or more embodiments static property descriptor module enables configuration of access to a property descriptor as will be further discussed below.

In one or more embodiments API restriction module enables the ability to block access to internal library APIs of a scripting language. In some embodiments access to the APIs can be blocked based upon a current state of a caller such as whether the caller is in a same domain or a different domain.

In one or more embodiments safe API identification module enables the ability to mark one or more APIs as being safe APIs to call. At least some of the marked APIs can be APIs configured to enable cross domain access.

In one or more embodiments reflect function module enables function objects to be exchanged across domains without exposing associated type system information. The exchanged function objects can be configured to be created in a type system associated with a caller as will become apparent below.

In one or more embodiments sub window proxy module enables an ability to have sub windows that inherit security properties of a primary window. Security decisions of the sub window can be proxied and or deferred to the primary window.

In one or more embodiments same origin optimization module enables same origin security checks to be bypassed as will be further described below.

Having described an overview of various features included in security module consider now a more detailed discussion of each feature under its own respective sub heading.

Various embodiments enable an ability to configure access to a property descriptor. For example individual attributes associated with a property descriptor can be configured to allow and or disallow certain forms of access to the property descriptor. For example a property descriptor can be configured to be visible not visible writable mutable un mutable configurable and the like. In a dynamic type system when a property descriptor is marked as un mutable it cannot be dynamically changed effectively making the property descriptor static. Altering the property descriptor s accessibility and or configurability can restrict access and or alterations to the property descriptor.

In one or more embodiments during a definition phase of the property descriptor tags can be included in the definition to describe various attributes associated with the property descriptor. For instance meta data can be included and or associated with a property descriptor definition to define one or more attributes of the property descriptor as will be further described below. A scripting engine can then be configured to recognize support and or enforce the attributes as specified.

Utilizing configurable attributes as described above can prevent script from altering property descriptors thus ensuring a more secure environment. Having described static property descriptors consider a discussion of API restriction modules.

In one or more embodiments access to library functions of a scripting language can be altered or restricted to adhere to security policies. For example access to an API of the scripting language can be conditionally blocked and or restricted to prevent the API from working in cross domain conditions. The API can be any form of library function such as by way of example and not limitation defineProperty getOwnPropertyDescriptor HasAccessor getPrototypeOf and the like. A type operation of the API can be modified and or replaced to enforce security policies. For example when the API is called the modified type operation can determine whether access is to be granted or not based upon the security policies. In some embodiments when it is determined to not grant access access can be disabled and or an exception can be thrown.

Security policies can include any form of policy such as a policy that is associated with whether a caller of the library function is in the same domain or not. In some embodiments when the library function is called across separate domains access to the function can be blocked.

Restricting access to library functions of a scripting language can prevent unwanted cross domain access to objects and or type systems. Having described API restriction modules consider now a discussion of safe API identification modules.

Various embodiments enable functions to be configured as so called safe functions. An API included in a library and or associated with an object can be marked as safe while other associated functions and or properties are disallowed. In at least some embodiments functions can be selectively marked as allowable regardless of what type of information can be accessed via the function. For example a function that enables cross domain access can be marked as safe. Being marked as safe allows the function to execute regardless of what state it is being called in such as across multiple domains. For example tags and or attributes can be assigned to an API during its definition phase to mark the API as a safe API as further described below. In a dual nature object enforcement of the allowed and or disallowed API can occur on the layout engine side of the dual nature object.

In one or more embodiments a function object can be returned across one or more domains without divulging type system information associated with the function s origins. The function object can be wrapped with a function and or associated with a proxy object where the wrapped function and or associated proxy object is returned across the multiple domains. In some embodiments the wrapped function and or proxy object can be configured to be actualized in the type system of the receiving domain.

In one or more embodiments cross domain access to a function object can be allowed without divulging type system information of the function object s origins. For instance script residing in a first domain can request access to a function object in a second domain. The function object inherently includes type system information associated with its type system of origin. This inherent type system information can be obscured from external domains and or type systems such as through the use of a wrapper function and or proxy object. When a function object is requested across domains the wrapper function and or proxy object can be returned instead of the function object. The wrapper function and or proxy object can be further configured to direct calls to the function object thus enabling indirect access to the function object. For example the wrapper function and or proxy object can allow safe access to all of the associated capabilities of the function object such as call apply bind constructor and the like.

In some embodiments the wrapper function and or proxy object can direct calls without exposing type system information associated with the function object s origin. For example the wrapper function and or proxy object can be configured to instantiate in the type system of the calling type system. By instantiating in the type system of the calling system attempted access to type system information of the wrapper function and or proxy object yields type system information of the calling system. The calling system can call the wrapper function and or proxy object in methods native to the calling system for access to the original function object.

Through the use of wrapper functions and or proxy objects function objects can be accessed across multiple domains without exposing any type system information associated with the function objects. Having discussed reflect functions consider now a discussion of sub window proxies.

In one or more embodiments one or more sub window proxies can be associated with a primary type system window proxy. The sub window proxy can be configured to assert at least some security policies associated with the primary window proxy. Alternately or additionally the sub window proxy can exist independent of the primary window proxy.

At times a window associated with a window proxy can have objects underneath the window that are accessible. The window proxy enables multiple domain access to the associated window. For example the window proxy can proxy by way of example and not of limitation property detection built in read write execute requests user defined property read write execute requests library object access array index addressing custom name resolution enumeration and the like to the associated window. In some embodiments objects underneath the window can be accessed such as through a sub window proxy. For instance an object returned from a safe API as described above can be returned as a sub window proxy. As in the case of the window proxy the sub window proxy can be configured to proxy the capabilities of its corresponding object.

In some embodiments the sub window proxy can assert at least the security policies associated with its primary window proxy. For instance the sub window proxy can be configured to defer security decisions to its primary window proxy. Alternately or additionally the sub window proxy can exist independently of its primary window proxy. In some embodiments the sub window proxy can be configured to be dynamically updated to reflect contents of a new window s sub object.

Accordingly sub window proxies can enable cross domain access to objects that are sub objects associated with a window without exposing type system information associated with the sub objects. Having described sub window proxies consider now a discussion of global optimization for same origin requests.

Many websites use self referential properties to explicitly specify that they are requesting properties from a global namespace root e.g. window.document where window is a self reference to the implicit namespace root object. In one or more embodiments self referential properties to a global object such as a JavaScript global object return all proxies to that object in order to protect against accidental or willful disclosure of the global object. However due to the common practice of self referencing security checks can degrade performance even when they are not really necessary. In accordance with one or more embodiments to increase performance of the property request under these circumstances the proxy s caller and target can be preemptively checked to see if they are the same object. If so expensive security checks can be safely bypassed without sacrificing the security of the global object.

As such various embodiments can enable security checks to be bypassed such as when a caller and a target are of the same domain and or origin. If a caller and a target reside in the same domain then security checks such as those to protect cross domain access can be bypassed.

As an example consider the following. A secure window object such as a proxy object can be utilized and can call into a global object which in turn has access to various forms of information and or code execution such as a trusted window. Responsive to these calls a comparison can be made to determine whether a caller of the secure window object and the target of the call such as the trusted window reside in the same domain and or origin. If the caller and the target are determined to reside in the same origin security checks can be bypassed. In this instance bypassing the security checks can be done without risk of unintended exposure.

Bypassing security checks on same origin transactions can enhance runtime performance by preventing unnecessary code from executing. Having described global optimization for same origin requests consider now an example method in accordance with one or more embodiments.

Step creates a layout engine object. The creation of the layout engine object can be performed in any suitable manner. Any suitable type of layout object can be created examples of which are provided above. Step creates a scripting language object such as an object that is native to a scripting engine memory space. Step uses a security model to provide secure information transfer during access to the layout engine object and or the scripting language object examples of which are provided above.

Having described various security models in accordance with one or more embodiments consider now a discussion of various aspects of Interface Definition Language IDL integration in accordance with one or more embodiments.

In one or more embodiments extensions to an Interface Definition Language IDL can facilitate and enable direct integration of a layout engine and a scripting engine.

In one or more embodiments extended IDL code can be used in conjunction with an IDL compiler to enable generation of code configured to bridge the layout engine and scripting engine. Alternately or additionally hierarchical relationships between objects and their associated APIs can be described using the extended IDL. In some embodiments the extended IDL can include syntax to describe attributes of the objects and or the associated APIs.

As will be appreciated by the skilled artisan IDL code can be used to describe one or more interfaces between various software components such as interfaces between a layout engine and a scripting engine. Extensions to the IDL code as described herein can be included to further describe objects APIs defined on the objects relationships between the objects attributes associated with the objects and or APIs and the like. A compiler such as an IDL compiler can interpret the IDL code and generate corresponding functions header files and the like to enable the software components access to one another.

As an example consider which illustrates a relationship between extended IDL code a compiler and associated inputs and outputs. Here Property Description Language PDL file s and extended IDL file are received and processed by a compiler to produce trampoline function s trampoline definition s and per type initialization function s all of which are described below in more detail.

In the illustrated and described embodiment PDL files can include one or more files that define one or more layout engine programming objects and or their associated APIs. Any suitable type of programming object can be defined through a PDL file such as by way of example and not limitation a COM based object. In some embodiments PDL files can include one or more files that define one or more scripting language objects such as a dispatch object. Dispatch objects enable a scripting engine to lookup and or obtain objects from a layout engine object through dynamic binding such as through a dispatch method.

In one or more embodiments extended IDL file includes alternate descriptions of at least some of the APIs and objects included in PDL files . In some embodiments an extended property description language and or extended interface definition interface language is used to express these alternate descriptions. For example the extended language can include additional attributes that can be applied to an API and or object as further described below. In addition to including attributes extended IDL file can include hierarchical relationship information such as a hierarchical arrangement of APIs. The APIs can be arranged as objects based upon the hierarchical information thus reducing and or eliminating redundancy that would be generated from using PDL file s without the extended IDL file .

In the illustrated and described embodiment compiler accepts multiple input files such as PDL file s and extended IDL file and processes those files to produce trampoline function s trampoline definition s and per type initialization function s . While illustrated as one module in it is to be appreciated and understood that compiler can comprise multiple modules without departing from the spirit of the claimed subject matter.

In one or more embodiments trampoline function includes code that enables calls between software modules to be bridged such as dynamic type system direct functions as described above. In some embodiments trampoline function can be generated as source code such as C implementation files .cpp files . Of course other code types can be generated without departing from the spirit and scope of the claimed subject matter. Trampoline function can be partially or fully generated by compiler .

In addition to trampoline function s compiler can generate trampoline definition s . Trampoline definition s can include one or more definitions and or forward declarations of associated trampoline function s such as forward declarations included in a header file .h file .

In some embodiments per type initialization functions include instructions and or script written in a scripting language such as JavaScript and enable initialization of one or more types in a type system e.g. a dynamic type system deferred initialization as described above.

In addition to reducing and or eliminating code redundancy such as through object relationship information the combined use of PDL file s and extended IDL file enable resultant code to be inspectable by a human prior to further compilation. For example a developer can add delete and or modify attributes within the extended IDL file input the modifications to compiler and inspect the resultant source code file s prior to generating binary code. This iterative process can enable software deficiencies to be located earlier in a development cycle.

Having discussed PDL and extended IDL files and how they can be processed by a compiler consider now a discussion of an example extended IDL file in accordance with one or more embodiments.

In this particular example extended IDL file includes one or more annotation documentation attributes one or more global object extension attributes one or more code generation attributes and or one or more API availability attributes each of which is individually discussed below.

In one or more embodiments the annotation documentation attributes enable various forms of additional annotations and or documentation to be included in extended IDL file and or associated output files. Some annotation attributes can be used for hyper linking such as by including a Uniform Resource Locator URL . For instance attributes can include links associated with an interface and or property definitions such as associated specifications and or additional documentation on the interface and or property definitions. Other annotation attributes can be used to describe link and or point an interface and or property definition to an associated binary code representation. In some embodiments annotation attributes can be used to include release information such as API introduction dates and or times modification date and or times author revision number and the like. Alternately or additionally annotation attributes can include attributes that are used to extend a property with an associated attribute name and or Cascading Style Sheet CSS property. For example in some embodiments an annotation attribute can be used to include an alternate language name of the property. Other annotation attributes can be used to include testing identification references such as testing identification references that can be used to coordinate a public test suite of an associated API. In one or more embodiments an annotation attribute can be used to include tag identifiers that enable API categorization and search indexing.

In one or more embodiments global object extension attribute enables control of which interface can be used to extend a scripting engine s global object. For example global object extension attribute can identify one or more interface to be grafted as the global object. This can enable the existence of alternate forms of extended IDL file to support different global object integration.

In one or more embodiments code generation attribute enables control of how code is generated. For example some attributes can be used to control security aspects of a property and or API such as marking a property and or API as a Safe API as described above. Other attributes can be used to control default initialization of a property such as configuring the property to be locked down un mutable not enumerable and or not configurable. Through the use of the attributes properties can be configured independent from one another. For instance a first property described in extended IDL file can be configured to be mutable while a second property in extended IDL file can be configured to be un mutable.

Alternately or additionally attributes can be used to indicate entry points for associated code. For example attributes can be used to describe C entry points. Other attributes can be used to indicate default values to be used for optional pass in parameters.

In one or more embodiments API availability attribute enables configuration of API availability based upon a current environment. For example attributes can be used to enable one or more APIs to be available to a Web page running HyperText Markup Language HTML but be unavailable to a Web page running eXtensible Markup Language XML . In some embodiments an attribute can be used to mark an API as deprecated which can trigger removal of the API under XML based pages.

Having described various extensions that can be included in an IDL file consider now which illustrates a flow diagram that describes steps in a method in accordance with one or more embodiments. The method can be performed by any suitable hardware software firmware or combination thereof. In at least some embodiments aspects of the method are performed by software executing on a computing device.

Step receives one or more Property Description Language PDL files examples of which are provided above. Step receives at least one extended Interface Definition Language IDL file. As described above the extended IDL file can include any suitable combination of extended attributes such as annotation attributes global object extension attributes and the like. Step processes the PDL and extended IDL files to generate at least one header file and associated source code file. The header file and associated source code file are configured to enable binding of a scripting engine and a layout engine such as through direct type system direct functions. Step processes the PDL and extended IDL files to generate at least one type system initialization function. The type system initialization function can be configured to enable binding of the scripting engine and the layout engine such as through dynamic type system deferred initialization as described above.

Having described of interface definition language integration consider now a discussion of various aspects of other considerations in accordance with one or more embodiments.

In accordance with one or more embodiments other design consideration can be taken into account in designing a model to bind a layout engine with a scripting engine. Consider now the following discussion of a layout engine object and scripting language object integration model.

In one or more embodiments a dual nature object can be configured to be programmatically unified between its scripting engine side and its layout engine side. A scripting language object associated with the dual nature object can be extended from its default state to include additional properties and or prototypes associated with a corresponding layout engine object as well as properties and or prototype inherited from other objects. In some embodiments APIs of the layout engine object can be included in a lookup path of the scripting language object such that the APIs can be accessed in a manner native to the scripting language. In one or more embodiments a prototype object associated with an API can be created and attached to the scripting language object. For example APIs associated with a window object in the layout engine can be associated with a prototype object and attached to an associated scripting language object. Similarly a web worker s global object can be extended by attaching a prototype containing APIs associated with a layout engine s web worker global object. In this way the dual nature object can be integrated thus enabling unified programming access.

In some embodiments a proxy can be configured to forward requests to and from the scripting language object. For example a window proxy can be configured to broker calls to the scripting language object when security allows access. At times direct references to an object can be disallowed. For example in a dual nature object a direct reference to the underlying layout engine object can be forbidden. In these instances the window proxy can be returned instead of the direct reference thus enabling access to functionality without direct exposure of the object.

Having described an object integration model between a layout engine object and a scripting language object consider now a discussion of backwards compatibility support that is in accordance with one or more embodiments.

In one or more embodiments scripts running in the scripting engine can have access to layout engine objects via the dual nature object mentioned above. For instance scripts can have access to a var object that is associated with the layout engine object in order to gain access and or call APIs of the layout engine object. In some cases an alternate path can be used to call the APIs. In approaches that utilize a COM based model a COM based client can utilize methods such as iUnknown and or iDispatch to directly acquire identification and or invoke the APIs. Of course other approaches can be utilized without departing from the spirit and scope of the claimed subject matter. In other cases the COM based client can request more automated access such as through iDispatchEx as will be appreciated by the skilled artisan.

In COM based embodiments when the COM based client calls iUnknown and or iDispatch the calls can be forwarded to the layout engine. The layout engine is configured to dynamically support these calls. The layout engine can create a tear off object and or interface to return to the COM based client. The tear off object or interface enables dynamic binding for the requested functionality.

In one or more embodiments when the COM based client calls iDispatchEx the call can be forwarded around the scripting engine. In some embodiments a backchannel can be created between the scripting engine and a scripting engine object. The backchannel can be configured to enable private transactions between the scripting engine and the scripting engine object. For example through the backchannel the scripting engine can natively access functionality of the scripting engine object while appearing to support the iDispatchEx in a more traditional manner.

Having described backwards compatibility support consider now a discussion of support for multiple scripting engines in accordance with one or more embodiments.

In some embodiments a second scripting engine can be supported through an extension of a first scripting engine. In a dual nature system the first scripting engine can be configured to look internally first for name resolution. If name resolution is not found in the first scripting engine lookup process requests can be routed to the second scripting engine. The first scripting engine can be extended to support method invocations from the second scripting engine.

Having described other considerations consider now a discussion of an example system in accordance with one or more embodiments.

Computing device includes one or more processors or processing units one or more memory and or storage components one or more input output I O devices and a bus that allows the various components and devices to communicate with one another. Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. Bus can include wired and or wireless buses.

Memory storage component represents one or more computer storage media. Component can include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . Component can include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

One or more input output devices allow a user to enter commands and information to computing device and also allow information to be presented to the user and or other components or devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer readable storage media .

 Computer readable storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer readable storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

Various embodiments provide an interface between a Web browser s layout engine and a scripting engine. The interface enables objects from the layout engine to be recognized by a memory manager in the scripting engine and interact in a streamlined efficient manner. In accordance with one or more embodiments the interface allows browser layout engine objects to be created as objects that are native to the scripting engine. Alternately or additionally in some embodiments the native objects are further configured to proxy functionality between the layout engine and the scripting engine.

In some embodiments binding between the Web browser s layout engine and the scripting engine can include features configured to enable unified programming access between the layout engine and the scripting engine as well as secured access across multiple domains. The features can be configured to enhance memory management enable direct access between the layout engine and scripting engine and or enable mutability of a dual nature object.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

