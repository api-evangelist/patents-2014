---

title: Verification of computer-executable code generated from a model
abstract: A code verification tool verifies that code generated from a model represents all of the functionality of the model and does not contain any unintended functionality. The code verification tool may receive for examination a model or an intermediate representation (IR) of the model and the generated code or an intermediate representation of the generated code. The code verification tool may create further intermediate representations of the model and/or the generated code in order to compare the functionality presented in both.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274928&OS=09274928&RS=09274928
owner: The MathWorks, Inc.
number: 09274928
owner_city: Natick
owner_country: US
publication_date: 20140331
---
This application is a continuation of U.S. patent application Ser. No. 12 559 233 filed Sep. 14 2009 which claims the benefit of Provisional Patent Application No. 61 103 167 filed Oct. 6 2008 and Provisional Patent Application No. 61 103 161 filed Oct. 6 2008 the contents of which are incorporated herein by reference in their entirety.

Many organizations are embracing Model Based Design in their production processes of real world systems. Model Based Design is a practice of specifying analyzing testing and implementing systems using a common model and or a set of models and associated objects. System implementation may involve generating code from a model or some of its parts.

Graphical modeling environments are an example of software applications that may enable a user to create execute and analyze models. Graphical modeling environments may be used to model dynamic and or event based systems. Dynamic systems are systems whose outputs change over time.

A user may create a graphical model of a real world system using a graphical user interface such as a graphical model editor. Graphical models may depict temporal relationships between system inputs states parameters and outputs. The behavior of the dynamic system over a specified time period may be simulated using information entered into the graphical model. The graphical model may be used to compute and trace the temporal evolution of the dynamic system s outputs execute the graphical model and or to automatically produce either prototype software systems deployable software systems and or descriptions of hardware systems that mimic the behavior of either the entire model or portions of the model code generation . Simulink software from The MathWorks Inc. of Natick Mass. is one example of a graphical modeling environment that caters to various aspects of system design analysis simulation and implementation.

Model based design is not limited to dynamic models or indeed to graphical models. Model based design may also be accomplished with textual models or a combination of graphical and textual models. Such models may be dynamic models event based models etc. Models may be created within a modeling environment or realized as stand alone computer executable code.

In designing verifying and implementing systems using model based design users may need to verify that code generated from a model for example by a code generation tool properly represents the model and does not introduce any unintended side effects. Such code verification may be an important process step in safety critical software systems. Code verification may be required by various government industry or company wide standards and or it may be useful for testing or implementing the designed system using the generated code.

Verifying generated code by hand may be a costly and time consuming process. As the complexity of models used in industry grows so does the complexity of verifying the generated code. In addition to the automation of the verification a user may desire to do an additional manual review. Furthermore even if manual review is performed an automated review may be useful.

In an embodiment a code verification tool verifies that code generated from a model represents all of the functionality of the model and does not contain any functionality not in the model. The code verification tool may receive for examination a model which may be in an intermediate representation IR and the generated code which may be in an intermediate representation. The code verification tool may create further intermediate representations of the model and or the generated code in order to compare the functionality presented in both.

The code verification tool may create an element connectivity list ECL for the model. The ECL represents elements of the model and connections between them. The ECL may be created from a graphical model a textual representation of a graphical model and or from a textual model. The model may also comprise graphical and textual aspects. A graphical model may be a time based model an event based model etc. A time based model may be for example a graphical block diagram model and blocks may constitute elements of that model represented by entities in an ECL. An event based model may be for example a state chart and states may constitute elements represented by entities in an ECL.

The code verification tool may also receive or create an internal representation of the generated code. Such internal representation may be for example an abstract syntax tree AST generated according to the general principles known in the industry. The AST may represent statements data data flow and control flow within the generated code.

In order to verify the generated code the code verification tool may locate code components in an AST that correspond to entities in an ECL and note the correspondence or lack thereof. The code verification tool may also generate a report of verification details and verification failures if any. A verification failure may be signified for example by one or more AST components that are not identified as corresponding to one or more ECL elements and or by one or more ECL elements for which certain corresponding AST components have not been found.

In the code generation stage of the code generation tool optimization may be desirable. Optimization may remove some elements of the model. In addition a single statement of the generated code may represent functionality from multiple model elements. In order to provide meaningful verification of the generated code the code verification tool may use information regarding the kind of optimizations or transformations that may take place during the code generation process.

In an embodiment the code verification tool may support only a restricted subset of possible model elements and or a restricted subset of connections. The restricted subset may be determined based on the model elements that generate allowable patterns in the generated code and or based on the code verification considerations as determined by one of skill in the art.

A model received from the user may be checked for compliance with the restricted subset of possible model elements before during or after generating the ECL. If there are elements in the model that are not supported by the code verification tool or that are outside a particular restricted subset within which the verification tool is operating based on user settings the verification tool may report to the user the violations within the model. In an embodiment verification may be aborted or not started until all violations are removed. Alternatively verification may proceed only on the subset of the code generated from the portions of the model supported by the code verification tool and the remaining sections of the generated code may remain unverified or left for manual verification. The generated code the model or any of the intermediate representations may be marked up in accordance with the determinations made by the code verification tool.

Marking of the generated code model and or IRs may be performed in many different ways. In an embodiment color visualization may be used to differentiate sections of code corresponding to different sections of the model. For example green color may be used to mark portions of the generated code that correspond to portions of the model that have been verified by the code verification tool and are not found to contain errors red color may be used to mark errors located by the code verification tool another color may be used to mark portions of the generated code for which the presence or absence of errors could not be verified and yet another color may be used to mark portions of the generated code that correspond to portions of the model that are not supported by the verification tool. In an alternative embodiment mark ups may be shown through text and or visual clues. In yet another embodiment a user may be presented with a user interface for browsing the generated code according to what portions of the model it comes from and or according to mark ups.

In an embodiment a user may be able to review by hand the sections of the generated code that are not supported by the code verification tool. A user may then want to hand verify the sections of the generated code that correspond to sections of the model that fall outside of that predetermined set. An embodiment may be used to assist the user in locating and verifying the sections of the code that have not been verified by the code verifier.

As used herein the term generated code refers not only to the code generated from a model or a portion of a model but also to other intermediate representations. Executable code may be but is not limited to computer readable instructions in such languages as FORTRAN ADA Python C C Java Java bytecodes Assembly MATLAB programming language Structured Text as well as layout and design languages such as for example hardware description language HDL unified modeling language UML etc. The term generated code may also refer to internal and or intermediate representations used to execute or implement a model. Models need not be solely graphical models and may be textual models and or a combination of graphical and textual models.

In an embodiment the code verification tool may provide a mapping between elements of the model and portions of the generated code that have been verified to correspond to those elements. The code verification tool may also indicate sections where verification has been inconclusive or sections containing verification failures. The mapping between the model and the generated code may be bi directional. For example a graphical model may be mapped to generated code and vice versa. The bi directional mapping may facilitate graphical identification of portions of the graphical model that correspond to selected segments of the generated code. The bi directional mapping may also facilitate graphical identification of segments of generated code that correspond to selected portions of a graphical model.

A graphical model may represent a system such as a dynamic system and may be executable in the graphical modeling environment. A graphical model may be represented as for example a block diagram model data flow model state diagram model etc. Some possible examples of suitable graphical modeling environments that may be used to develop a graphical model in accordance with exemplary embodiments are but are not limited to Simulink software and or Stateflow software from the MathWorks Inc. of Natick Mass. LabVIEW or MATRIXx from National Instruments Inc. Mathematica from Wolfram Research Inc. SCADE suite from Esterel Technologies Inc. CoWare from CoWare Inc. Mathcad of Mathsoft Engineering Education Inc. Maple from Maplesoft a division of Waterloo Maple Inc. Dymola from Dynasim AB of Lund Sweden Extend from Imagine That Inc. of San Jose Calif. Scilab and Scicos from The French National Institution for Research in Computer Science and Control INRIA Le Chesnay Cedex France MSC.Adams from MSC.Software Corporation of Santa Ana Calif. modeling software from dSPACE of Paderborn Germany electronic design automation FDA software from Cadence of San Jose Calif. or Synopsis of Mountain View Calif. the BEACON software family from Applied Dynamics International of Ann Arbor Mich. etc. In addition modeling environments such as those that support modeling physics based domains Unified Modeling Language UML like Rhapsody from iLogix Inc. of Toronto Canada or Rational from International Business Machines Corporation of Armonk N.Y. or SysML like ARTiSAN Studio from ARTiSAN Software Tools Inc of Beaverton Oreg. or Rhapsody from iLogix Inc. AADL and MARTE or Green Hills GHS Event Analyzer etc. may be suitable for implementing a graphical model in accordance with the exemplary embodiments.

Exemplary graphical models may be developed based on a set of requirements that may be contained in one or more machine readable structures such as a text file a spreadsheet a word processing file a presentation application file database repository etc. which will generally be referred to as requirement documents for the model . The requirements may be subject to version control by a version control system to enable tracking of versions when the requirements change. In some instances the tracing to requirements may be included in the graphical model such that the traces to the requirements for the model and the design i.e. the graphical model are in the same location. The requirements may be traced to the graphical model and or generated code to facilitate identification of requirements that trace to graphical affordances in a graphical model and or segments in generated code.

Generated code may be generated in a programming language such as Sequential Function Chart Structured Text or another IEC 61131 language C C SystemC Java Javascript Python FORTRAN ADA an assembly language etc. a hardware description language HDL such as Verilog VHDL very high speed integrated circuit hardware description language etc. a register transfer language RTL etc. Implementations may further generate information about a graphical model using a programming language alone or in combination with the generated code discussed above. In one example an XML representation such as part of for example the Autosar standard may be used to include information and meta information about the model such as which functions should be called and in what order which task should be called and at what rate what types input arguments have etc.

When code is generated one or more intermediate representations IRs may be generated. An IR as used herein refers to a representation such as a data structure that is stored in memory a file a database or any other acceptable storage medium. The IR can be constructed from input data contained within a source language e.g. a language used by a graphical model and from which part or all of the target language information e.g. generated code is constructed. One example of an intermediate representation that can be used with exemplary embodiments is a control flow graph CFG . An IR may have meta tags to identify where the content of the IR is derived from. A meta tag associates the content of the IR with content that is used to generate the IR. The content of an IR may be derived from for example elements in a graphical model optimization rules model configuration options etc.

The environment allows a user to develop graphical models using the interface . The interface can be a graphical user interface that may include a canvas that is represented by a graphical area on the interface . The canvas may allow a user to develop and or view graphical models. For example a user can place elements and or on the canvas to create the graphical model . The interface may also provide options to allow the user to generate code and or a report from the graphical model . Interface may also allow a user or the environment to add elements delete elements replace elements etc. in the graphical model . For example a user may create the graphical model via the interface . The created graphical model may represent a model of a system such as a dynamic system and or another type of system. The user may use predefined elements e.g. system defined environment defined etc. or user defined elements to develop graphical model .

Elements and or may represent but are not limited to continuous and or discrete dynamics elements such as integration elements unit delay elements etc. algorithmic elements such as sum product lookup tables etc. and or structural elements such as multiplexers switches signal or bus selectors etc. Elements and or may also represent states where the graphical model may include a state diagram model. Elements and or may be used in the graphical model to develop a model of a system such as a dynamic system. Elements and or may be supplied by the environment . The environment may allow a user to alter environment supplied elements and or or create customized elements. In another implementation a user may supply one or more of elements and . For example a user may create elements and or thereby implementing user specified elements and or . The user supplied elements and or may contain programming language statements or instructions in a technical computing language.

Elements and may have parameters. Parameters may affect the functionality of the graphical model . Parameters that affect the functionality of the graphical model may be referred to as functional parameters. Some examples of functional parameters include for example a sample time parameter that determines when the elements and or execute scaling parameters that may affect the magnitude of an output of the element or data type that determines the format in which data is passed from one element to another etc. Parameters may also be nonfunctional in that they do not affect the functionality or execution of the graphical model. Some examples of nonfunctional parameters include for example an element name an element appearance annotated text that is associated with the element etc. Nonfunctional parameters may also be associated with characteristics such as power consumption execution time size and weight.

Elements and or may be connected to each other to pass signals in the graphical model . Signals may be passed to and or from elements in the graphical model . The signals can be represented by various types such as integer floating point double unsigned signed bytes or words etc. The signals may be contained in a bus format and or may use frames. A bus format as referred to herein provides a format for transmitting a collection of signals to and from elements in a graphical model. A bus format may have a bus width that indicates how many signals the bus contains. When signals are in a bus format the signals may be transmitted to the same element or may be transmitted to different elements that are connected to the bus. A bus may be hierarchical. A hierarchical bus provides a format for transmitting a collection that includes one or more buses.

The textual interface environment allows a user to develop a user specified element e.g. element with code in a textual language. Code developed using the textual interface may be included as for example the element in the graphical model . The textual interface may also facilitate debugging and profiling of graphical model or the environment may include a separate graphical debugger and profiler not shown in .

The execution engine may communicate with the interface . The execution engine can receive the graphical model which may represent for example a block diagram state diagram data flow diagram etc. that is generated using the interface . The execution engine may execute the graphical model in an embodiment. The execution engine may generate data from the execution of the graphical model . The data may be displayed to a user in a textual or graphical form. For example the data may be presented to the user in table form or in graph form. The environment may use a centralized data viewer to view the data generated by the execution engine .

The execution engine may use numerical integration methods to compute behavior for differential equation as well as difference equation models. These numerical integration methods may be explicit and implicit as well as fixed step or variable step. A zero crossing detection and location mechanism may be used by the execution engine to identify and locate times at which events occur such as a modeled collision between two rigid bodies. The execution engine may handle difference equations by precomputing a static schedule of times when values change. This static schedule may employ a base rate that is the greatest common denominator of all sample times that are scheduled for execution by the execution engine . The execution engine may handle discrete event systems based on a base rate or by using a dynamical scheduling mechanism such as an event calendar. The execution engine may employ any combination and or permutation of these features.

The code generation tool may generate code such as source code object code a compiled executable a library etc. for forming an executable representation of the graphical model provided by the interface . The code generation tool may also be used to generate a hardware description language HDL or a register transfer language RTL representation of the graphical model . The generated code may be stored in multiple files. For example part of the generated code may be stored in a header file while another part of generated code may be stored in a source file. To generate code the code generation tool may convert a source model language representation of the graphical model to a target language representation.

During the code generation process the code generation tool may generate one or more IRs prior to generating code from the graphical model . The IR may be a CFG that captures the semantics of the graphical model . An IR represented by a CFG may include nodes that represent algorithmic aspects of the graphical model and edges that indicate the flow of the algorithms.

The code generation tool may generate code for the execution of the graphical model . The code generation tool may also compile generated code into object code and build an executable program library or any other form of executable instructions. The generated code may be designed to run on any processor microprocessor dual core processor multi core processor cluster of processors digital signal processor DSP programmable logic device PLD system on chip SOC System in Package SiP reconfigurable signal conditioning hardware operating system computational hardware device component of a computational hardware device etc. Shown in are some examples of target hardware on which generated code may be deployed. Such examples include FPGA PLC ASIC ASIP FFT etc. In an embodiment generated code may include embedded code targeted to run on any type of embedded system. For example generated code may be implemented as firmware in an electronic system that uses a microprocessor or a microcontroller. Additionally the code generation tool may be configured to customize the generated code based on the target hardware platform. For example generated code may include fixed point code to run a fixed point processor or generated code may emulate fixed point behavior on a floating point processor.

The graphical model may include directives as to how code should be generated. For example the element in the graphical model may be directed to have a corresponding function method procedure etc. in order for it to be generated in generated code with an argument list and name as directed by the code generation tool . A function method procedure etc. as used herein refers to a segment of code that has a defined interface for passing arguments. For clarity the terms function method procedure etc. will be referred to hereinafter simply as a function. A function performs an operation that is defined by the content in the function. The function may or may not return a value when the operation is complete. The function may be reused by other graphical model elements e.g. elements etc. with the same or similar functionality.

Further optimizations such as expression folding function inlining function outlining constant propagation strength reduction loop unrolling etc. may be applied to generated code. Expression folding refers to reducing multiple expressions to a single expression in generated code. Function inlining refers to placing the contents of a function inline so that when a function is executed the function does not have to go to a call site that is external to the body of generated code to perform its operation. Function outlining refers to outlining an inlined function such that when the function is executed the function has to go to a call site that is not part of the body of generated code. Constant propagation refers to replacing variables that reference a constant with the constant. Strength reduction refers to replacing a computation with an equivalent but less expensive computation in terms of processor cost such as speed power usage etc. . Loop unrolling refers to making the iterations of a loop explicit so the looping construct can be removed.

The code generated by the code generation tool may be verified by a code verification tool . The code verification tool may verify that the code reproduces all of the functionality of the model and does not introduce any functionality that is not comprised by the model. The code verification tool may generate a report. The generated report may be for example a document structured with sections corresponding to different elements of the model and indications of whether any verification failures have been detected in those sections a report detailing use of the temporary variables a report detailing compliance of the code with the functionality of the model etc.

The generated report may use navigable links. For example the generated report may be in the form of a document in a mark up language such as for example HTML. The navigable links may contain information relating to the model settings of the code generation tool etc.

The programmable APIs can allow a user to interface the environment with an external browser and or viewer. The programmable API can allow the user to browse the generated code and or the model and to programmatically identify a code segment in generated code that corresponds to an affordance in the model or to programmatically identify a affordance in the model that corresponds to a segment in generated code using an external browser and or viewer. For example an identified affordance may include an element a signal an annotation etc. The programmable API can allow the external browsing or viewer to identify segments of generated code or portions of the model . An external code browser and or viewer can use tracing information and the programmable API to browse and or view the model and or generated code.

The viewer may be a debugger. An unverified code fragment may automatically set a breakpoint or control other configurations of a debugger. When generating an IR code a report etc. the environment may use transformation rules. Transformation rules for example may determine how an element is represented in the IR or generated code. For example there may be a transformation rule relating to the element for transforming the element into a section of the IR and there may be another transformation rule for transforming the section of the IR into generated code. The transformation rules may exist in a computer readable medium and may be contained in a file database repository etc. In some embodiments a graph rewriting system may be used to implement a transformation rule. Graph rewriting systems may also be referred to as using a graph grammar . Graph grammar may use pattern matching for replacing one graph structure with another. There are numerous ways to implement pattern matching. One common implementation is guided by heuristics to manage the computational complexity. Graph grammar may employ any number of rewriting rules transformation rules that can be extended by textual transformation information. Some embodiments may implement triple graph grammar or a higher order of graph grammar when generating an IR code a report etc. Transformation rules such as those implemented using triple graph grammar may allow for example mapping between a first entity e.g. an IR generated code a generated report etc. a second entity that is generated from the first entity and the information e.g. transformation rules used to generate the second entity.

The programmable APIs may also enable graphically identifying graphical affordances or segments of generated code that correspond to a graphical interface of a user specified element e.g. element . For example a user may define a function in a programming language such as MATLAB C C Java Javascript etc. and the user may incorporate the function into the graphical model . The code for the user specified element may be developed using the textual interface or any other application that allows a user to develop textual code such as a word processing application a code browser etc. The function can be represented by a graphical affordance that has a graphical interface. The graphical interface can represent for example inputs outputs triggers etc. and may enable other elements in the graphical model to connect to the element that represents the function.

One of ordinary skill in the art will also appreciate that the components of the environment may be provided on a single computing device as described below with reference to on multiple computing devices e.g. in a distributed configuration and or in other configurations e.g. a multi core implementation operating on one or more platforms . For example the environment may be at least partially provided as a service and or as a virtual machine.

The computing device may be electronic and may include a Central Processing Unit CPU memory storage an input control a modem a network interface a display processor and a graphical processing unit GPU . The CPU may control components of the computing device to provide the interface the textual interface the execution engine the code generation tool the report generating tool and or one or more programmable APIs . The memory may store instructions and data and may provide the instructions and data to the CPU . CPU may operate the computing device and may run the interface the textual interface the execution engine the code generation tool the report generating tool and or one or more programmable APIs based on the stored instructions.

Optionally the computing device may include multiple CPUs for executing software loaded in the memory and other programs for controlling system hardware. Each of the CPUs can be a single or a multiple core processor . The code loaded in the memory may run in a virtualized environment such as in a Virtual Machine VM . Multiple VMs may be resident on a single processor. Also part of the application may run in processor which may include for example a field programmable gate array FPGA programmable logic controller PLC an application specific integrated circuit ASIC an application specific instruction set processor ASIP a Fast Fourier Transform FFT processing device etc. Further part of the applications may be run on analog electronic optical or mechanical devices that may be included in the computing device . Other resources such as for example GPU may also be used to run part of the applications.

The storage may contain software tools for applications. The storage may include code for the operating system OS of the device code for applications running on the operating system including the applications for the interface the textual interface the execution engine the code generation tool the report generating tool and or one or more programmable APIs and data generated from the interface the textual interface the execution engine the code generation tool the report generating tool one or more programmable APIs and or other code. Portions of applications may be stored in the CPU cache memory and or elsewhere such as on a remote storage device connected to computing device via a network a bus a dedicated link etc.

The input control may interface with a data entry device such as a keyboard a pointing indexing device such as a mouse a microphone a camera such as a web camera and or other input devices such as an accelerometer a gyroscope a haptic device a touchscreen a neural interface etc. The computing device may receive through the input control input data such as the input data for developing graphical model . The computing device may display on the display user interfaces for displaying the data generated from the interface the textual interface the execution engine the code generation tool the report generating tool and or one or more programmable APIs .

The communication network may include Internet intranet Local Area Network LAN Wide Area Network WAN Metropolitan Area Network MAN wireless network e.g. using IEEE 802.11 IEEE 802.16 Bluetooth etc. etc. The communication network may use middleware such as Common Object Request Broker Architecture CORBA or Distributed Component Object Model DCOM to allow a computer e.g. client on the communication network to communicate directly with another computer or device e.g. client that is connected to the communication network . In addition the communication network may use RMI Remote Method Invocation or Remote Procedure Call RPC technology. RMI and RPI are exemplary technologies that allow functions methods procedures etc. to be called over the environment . For example the client may invoke a method that resides remotely on the client .

In environment the servers may provide the clients with software components or products under a particular condition such as a license agreement. The software components or products may include those for providing the interface textual interface the execution engine the code generation tool the report generating tool one or more programmable APIs etc. For example the client may perform the modeling of a dynamic system using a software component provided by the server and send the server the model for execution. The server may return the execution results to the client and the client may subsequently display the data to the user with the information on the data.

The code verification tool processes the model to create an element connectivity list ECL step . The ECL is an internal representation of the information from the original model. Such information may include information about each element from the model information about connectivity of the elements in the model information internal to the elements in the model etc. Information internal to the elements in the model may include element names element types parameters that are required by the elements parameter types size data types vector sizes and types of the input and output etc. In case of a block diagram model for example the ECL may include a list of all of the non virtual blocks contained within the model. A virtual block is a block that does not provide any arithmetic or logical actions and do not have any functionality beyond providing connectivity grouping containers or additional information for the blocks contained within them.

In an embodiment some of the information for the ECL may be derived from a compiled version of the model. A compiled model may be a model for which its attributes have been determined so that an executable representation may be derived. Determining model attributes may involve inferring sample times data types signal dimensions etc. for example by propagation in the model. That is the code verification tool may compile the model file or may get the information from the compiled version prepared by a model compiler. The code verification tool may extract from the compiled model information about data types and signal dimensions. In an alternative embodiment all information about the model that is used by the code verification tool may be received from the model file directly. Generation of the ECL is discussed in further detail in connection with below.

Before during or after generating the ECL the code verification tool also reads in the generated code that has been generated from the model step . The generated code may have been generated in the same modeling environment in which the code verification tool operates. Alternatively it may have been generated outside of the modeling environment. In yet another embodiment code generation may be initiated by a user in a sequence with code verification and the generated code may be provided to the code verification tool upon completion of the code generation or it may be made available incrementally. The generated code may contain artifacts or markers inserted in portions of the generated code that do not relate to execution by the code generation tool . The artifacts or markers may include links back to the original model or indication of where different code statements are derived from within the model.

An abstract syntax tree AST may be created from the generated code step . Alternatively the code may be provided to the verification tool already processed into an AST. The AST is a tree representation of the syntax of the generated code which relates to its functionality. Each component of the AST denotes a construct occurring in the generated code. Some constructs that appear in the generated code may not be represented in the AST. For instance the AST may exclude some grouping parenthesis of the source code and in the AST the grouping of the operands may be implicit in the tree structure. The AST may be built by a parser part of the verification tool or an external parser tool. Additional semantic analysis information may be added to the AST during or after its creation. For example the AST used by the verification tool may include a file location for the generated code and a list of temporary variables declared within the generated code source file.

In order to verify the code the code verification tool finds correspondences between entities in the ECL with nodes in the AST step . There may be a one to many correspondence between an entity in the ECL and components in the AST although the correspondence may also be one to one. Finding components in the AST that correspond to an entity in the ECL is described in further detail in conjunction with below.

In an embodiment for every entity in the ECL there must be corresponding components in the AST or for example information about transformations that may have resulted in the corresponding model element being removed by an optimization during the code generation. If a model element is found that does not have the proper corresponding component s in the AST or that matches the transformation for example for which there is no reason to expect it being removed by an optimization that lack of the correspondence may be considered to be a verification failure. The code verifier locates and reports at least one such verification failure in a report step .

Likewise the AST may be traversed to find any components that have not been associated with a corresponding entity in the ECL step . The traversal may be a top down traversal or may employ any kind of tree search or traversal techniques known to one of skill in the art. The components in the AST that do not have corresponding entities in the ECL or that are not traced to a particular model or model element setting may be considered to represent functionality that is not present in the original model and may thus also represent verification failures.

In an embodiment the verification tool may keep track of different types of verification failures and may generate a report step . The report may include indication of the failures and locations where they occur. In an alternative embodiment the failures may be marked on the generated code. The failures may also be marked on the model and or links may be provided between the elements of the model and the corresponding elements in the code. In yet another alternative embodiment the report may be a pass fail report representing whether the code overall has passed the verification.

Users may also be apprised of results of the code verification in many different ways. For example the code verification tool may keep statistics about the code examined and about the particular patterns found therein. The report may include information about temporary variables used in the generated code and where they are used. The report may be in a format prepared according to user s settings or specifications. There may be an application programming interface API for specifying what information to include in the generated report.

The ECL may be ordered based in part on the connectivity of the model and in part based on the arrangement of the generated code. For example portions of the model that are independent from each other from the standpoint of control and or data flow of execution may be arranged in multiple different ways in the generated code while still preserving the functionality of the model. As such there may be multiple different orderings of the entities in the ECL that also correctly represent the model functionality.

An unordered list or vector of entities is created first . Creating the unordered list is described in further detail in connection with below. An unordered list of entities may be represented using various data structures such as for example a linked list a vector an array a dictionary a set a collection of objects a heap etc.

The generated code is then scanned to locate one or more markers that identify locations of code components corresponding to model elements in the generated code . Such markers may be contained for example in comment sections of the code so that they are not processed by a compiler or an execution environment when the generated code is compiled or executed. The markers may be in any format appropriate as determined by one of skill in the art. In an embodiment the markers may mark both the beginning and end of the section supposedly containing code corresponding to one or more elements of the model. It should be noted that a section indicated by a marker may contain code corresponding to multiple model elements. Furthermore the code need not contain the statements appropriately corresponding to the model element indicated the code verification tool may identify this case. Therefore the markers in the code may be consulted in order to aid the verification process and not as means of verifying that the code within the marked section contains what the marker specifies it does. In an alternative embodiment the AST may include information related to the markers and the code components may be located by searching in the AST.

There may be some sections of the generated code that are not marked by any markers. Furthermore in some cases the markers may be incorrect in that they incorrectly identify a section of code as corresponding to a particular model element. Even in these cases the verification may still proceed because the code verification tool checks that the code reproduces the model functionality not that it is marked correctly. The code verification tool identifies correspondences between model elements and code components. In an embodiment the code verification tool may generate a report indicating these correspondences with more precision than the code markers inserted by the code generation tool . The unordered list of entities may be ordered using the connectivity of the elements in the model and markers in the generated code. . Ordering the unordered list of entities is described in further detail in connection with below.

The .mdl file may be scanned to locate a group of model elements to examine . For each model element in a group an object may be instantiated to hold information about that model element . An object may be of a class specifically designed to hold information about a model element. Such information may include information about the functionality of the element its settings its input and output parameters default options etc. An object may also be any other data structure employed to store information about one or more model elements. An object stored in an element connectivity list or a list that is to become an element connectivity list may be referred to as an entity of the ECL.

In an embodiment default model element parameters are applied and recorded for the model element . The actual model element parameter values may then be extracted and stored in the corresponding entity . Applying default model element parameters may be useful in case the actual model element parameters do not specify all of the possible parameters leaving the other ones to be set to defaults.

If there are model elements left to examine in the group the processing moves on to create objects for those model elements otherwise connections between model elements are examined one by one. Each identified connection is recorded in the appropriate entities. A single connection may need to be recorded in more than one object. In particular it may be noted in the source object which is then indicated as the source for the destination object as well as in the destination object which is then indicated as a destination for the source object. Other information about the connection such as the number and parameters it carries etc. may be recorded as well.

A connection may have properties such as an interface e.g. service interface specified. These properties may cause additional entities in the ECL to be created to capture the functionality. While there are connections left to examine they are processed one by one after which the processing moves on to the next group if any . In such a way the entire model file is processed to extract information about model elements and to create an unordered list of entities.

It should be noted that the textual representation of the model need not be as described above. In particular the model elements need not be grouped into distinct groups. So long as the model representation contains information about the model elements and connections between them it may be appropriately processed into a list of entities as implemented by one of skill in the art.

In other models it may be necessary to scan for additional markers to locate additional model elements and to order those model elements upstream from them. Thus if there are two or more sections of the model that are not dependent on each other in terms of an execution pattern e.g. an order of execution they may be ordered in the ECL based on the ordering in the generated code. However if the model imposes an ordering based on the execution patterns such order may be preserved in the resulting ECL.

In an alternative embodiment a structure different from the ECL may be used to hold an internal representation of the model for code verification so long as it is capable of being traversed in order to match model elements with their corresponding code components.

Model element functionality may be generally thought of as something requiring code functionality. Code functionality may be represented by one or more statements. Such statement may be an operator or a control. For example an adder model element may have among other functionalities the functionality of adding two or more inputs. However even though on the face of the model that may be all that the adder does its functionality may not be limited only to the addition. In some cases it may be necessary for example to modify parameters of input and or output in order to make sure that they are of the correct type as specified. Modifying model parameters may be performed by casting them and or setting appropriate overflows and other information relating to the parameter type.

Thus the extent of the entity functionality may be determined not only by what model element it corresponds to but also by what inputs and outputs are for that model element. It may also be affected by other model and code generation parameters. Whether any casting or any additional operations are required in the code to represent the functionality of the model element may be determined using parsers and or objects designed for each type of a model element. In addition one or more steering tables may be used to determine what additional operations if any are needed in the code to represent the model element functionality. Steering tables used for determining model element functionalities are discussed in further detail in connection with below.

For each functionality of a model element an operator or a control statement is determined . An operator may act upon operands. A control may be a statement directing control flow of the code such as for example loop commands case commands IF ELSE commands etc.

Depending on the operator or control there may be one or more operands that are needed for that operator . Those operands are determined based in part on the operator and based on what has already been determined for other entities. For example an operand for a plus operator may be an expression or a variable. Values of that expression and or variable may have been predetermined in conjunction with a previously verified model element. Therefore they can be retrieved from storage associated with an entity corresponding to that model element. As such the ordering of the entities in the ECL may be employed for traversal in order to match model elements with corresponding components in the code.

Once the operator operand combinations have been determined they are located in the generated code . As discussed above the generated code may be represented using an AST. However alternative representations may be possible so long as they permit searching and allow for locating of operator operand combinations. If the AST representation is used in an embodiment there may be search functions employed to locate the operator operand combinations as implemented by one of skill in the art.

The results of searching the AST are recorded to note whether the corresponding code has been found and where. Additional information from the code components may be recorded in the corresponding entities. Such information may be for example expressions and or values of the output of the operands temporary variables involved etc. The information may be recorded in the entities and or directly in a report or other memory structures holding information for the report.

Once the match information has been recorded if there is more model element functionality remaining to be examined the matching process proceeds to the additional functionality. Otherwise the matching process moves on to the next model element to examine until all model elements have been examined and matches with to code components have been attempted to be found.

The table is used based on the input and output data types of the model element and rounding method employed saturation on integer overflow setting etc. In each of the columns there may be values representing a particular selection for the variable of that column. For example in the input data types column there may be values representing double float int int int unsigned unsignedl unsigned Boolean etc. It should be noted that the values are shown only to illustrate the kind of input data type values that may be possible. The values need not be arranged in this precise order. Similarly present in the output data types column there may be values indicating data types . In an alternative embodiment additional data types may be considered.

In the rounding method column there may be values indicating ceiling simplest floor zero or nearest rounding methods. In the saturation on integer overflow column there may be values indicating whether the saturation is required or not. In an alternative embodiment there may be additional columns and or values based on which a functionality is looked up.

The steering table may provide a key into steering table that lists control values specifying which transformations if any are needed in order to make sure that an operation takes in appropriate input and outputs appropriate output. Additional steering tables may be used to determine other details about the generated code that need to be taken into account when matching the model elements with the code components.

A report may include a section reporting whether code patterns have been identified for each model element as well as an indication of whether all code components have been matched with an element . Any model elements and or code components that have not been matched may be reported specifically so that the user may be apprised of specifics of the verification failures.

The report may also include a description and or accounting of temporary variables usage in the generated code . The temporary variables may be listed with indication as to where they are used in the code.

The report may also go into additional details as determined by one of skill in the art. For example the code verification process may check whether the generated code provides an expected interface to the model and the results of this check may be reported to the user. Verifying the correct interface may also involve verifying that a reusable code interface is correctly contained in the generated code and the corresponding AST. If the model is indicated to contain non reusable code then the verification tool may verify that the non reusable code interface is contained in the generated code. In addition the verification tool may check that structures storing values during time steps e.g. DWORK structures are properly contained in the interface as well as that the model element I O structures are properly contained in the interface to the generated code. All of these interface details may be included in the report.

There may be also additional verifications that are performed by the code verification tool and the results of which are included in the report. For example verification tool may determine that all of the expected entry points into the generated code have been correctly generated by the code generation. A model may be processed in stages such as evaluating its output updating its state computing its derivatives etc. These stages may constitute entry points. Some models may also have a single step stage.

The model options settings such as for example code reuse exported functions combining model output and model update calls etc. may partially determine what code entry points are expected. In addition some model elements such as for example a rate transition element may require specific entry points into the generated code for example to evaluate functionality at different rates that may be in different paths. In addition the verification tool may determine whether there are unexpected entry points in the generated code. Such entry points may be determined based on scanning the AST for the entry points and determining whether they correspond to the expected entry points. Furthermore the report generation tool may determine whether all model element names have been generated correctly. In some embodiments these names may be mangled in some cases if the length of the name is restricted and there are unintentional matches and part of the verification activities may be determining that the mangled names have been generated correctly. The report may list these mangled names and or indicate whether they have been generated correctly.

Furthermore as part of the verification and or reporting activities the code verification tool may inspect the generated code to verify that in line and non in line model subsystems have been generated correctly. For in line model subsystems the corresponding code may need to be contained within the same file as the code for the rest of the model. For the non in line model subsystems the generated code may need to be contained in a separate file. In addition for the non in line model subsystems the generated code may need to have its own interface accessible from outside the model subsystem and it may be verified that this interface is called from within the generated code for the rest of the model. It may also be verified that the interface is external to the model.

The results of these and other verification activities may be reported to the user. The report may be provided as a document or a set of documents in whichever format determined appropriate by one of skill in the art. In an alternative embodiment there may be a user interface for viewing the code verification report and browsing corresponding code and or model sections where appropriate. In yet another embodiment the results of code verification activities may be reported visually in conjunction with the model. For example the model elements for which no corresponding code components have been found may be visually indicated as such to the user. In an alternative embodiment the report may be incrementally generated and displayed to the user as it is being created.

The code verification tool may support all of the features and elements allowed in a model in a particular modeling environment or it may only support a restricted subset of the model elements. is an illustration of a process of checking whether the model contains any elements that are not supported by the code verification tool . When the model source file is received by the code verification tool step an intermediate representation is generated step and is examined for compliance with a restricted subset of elements step . The compliance may be verified based on all elements belonging to the restricted subset of elements and or based on additional factors step .

If there are elements of the model that fall outside of the supported set the code generation tool may report non compliance to the user .

In an embodiment the verification results may be visually marked up for the user on the model and or code. In addition the user may be able to mark up the model and or code after receiving the verification report. is a flow chart illustrating the process of verifying code and marking it up in accordance with the verification results. After the code is verified step a report may be presented to the user or the user may be shown marked up code. The user may then choose to manually verify portions of the code whether those that have been verified by the code verification tool or not and to mark up the code in accordance with the manual verification. User generated mark ups may be stored and or reflected on the model or the code.

The present invention may be provided as one or more computer readable programs embodied on or in one or more mediums. The mediums may be but are not limited to a hard disk a compact disc a digital versatile disc a flash memory card a Programmable Read Only Memory PROM a Random Access Memory RAM a Read Only Memory ROM Magnetoresistive Random Access Memory MRAM a magnetic tape or even the genome in a cell nucleus. In general the computer readable programs may be implemented in any programming language. Some examples of languages that can be used include Python C C C Java Javascript etc. Further the computer readable programs can be implemented in a hardware description language or any other language that allows prescribing computation such as for example Deoxyribonucleic acid DNA . The software programs may be stored on or in one or more mediums as object code.

Certain embodiments of the present invention are described above. It is however expressly noted that the present invention is not limited to these embodiments but rather the intention is that additions and modifications to what is expressly described herein also are included within the scope of the invention. Moreover it is to be understood that the features of the various embodiments described herein are not mutually exclusive and can exist in various combinations and permutations even if such combinations or permutations are not made express herein without departing from the spirit and scope of the invention.

Since certain changes may be made without departing from the scope of the present invention it is intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative and not in a literal sense. Practitioners of the art will realize that the sequence of steps and architectures depicted in the figures may be altered without departing from the scope of the present invention and that the illustrations contained herein are singular examples of a multitude of possible depictions of the present invention.

