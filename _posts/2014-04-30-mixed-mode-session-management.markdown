---

title: Mixed mode session management
abstract: Systems and methods for managing multiple versions of applications executing on servers in a server pool are provided. A first server executing a first version of an application loads session data associated with a second, different version of the application. An error is detected based on the difference between the first version and the second version. A second server executing the second version of the application is selected by the first server in a server pool comprising one or more servers. The first server transmits a hypertext transfer protocol proxy request to the selected second server, which successfully processes the session data and handles the request without error.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09459860&OS=09459860&RS=09459860
owner: PAYPAL, INC.
number: 09459860
owner_city: San Jose
owner_country: US
publication_date: 20140430
---
The present disclosure generally relates to applications executing on servers and more particularly to a method and system for managing multiple application versions in a server pool.

More and more consumers are purchasing items and services over electronic networks such as for example the Internet. Consumers routinely purchase products and services from merchants and individuals alike. The transactions may take place directly between a conventional or on line merchant or retailer and the consumer and payment is typically made by entering credit card or other financial information. Transactions may also take place with the aid of an on line or mobile payment service provider such as for example PayPal Inc. of San Jose Calif. Such payment service providers can make transactions easier and safer for the parties involved. Purchasing with the assistance of a payment service provider from the convenience of virtually anywhere using a mobile device is one main reason why on line and mobile purchases are growing very quickly.

Transactions facilitated by a payment service provider may involve multiple steps or stages where each step takes place on a separate web page. Each web page may be provided by a server executing an application corresponding to that transaction. For reliability availability and other considerations many payment service providers use large numbers of servers in a server pool and each web page provided as part of a transaction may be provided by a different server in the server pool executing the application. However some payment service providers frequently upgrade the versions of applications executing on servers that facilitate the services of the payment provider. When a user s transaction with a payment service provider is handled by two or more servers with different versions of an application the user may experience an error and the user may have to restart the transaction.

Thus there is a need for an improved method and system for managing multiple versions of applications in a server pool.

Embodiments of the present disclosure and their advantages are best understood by referring to the detailed description that follows. It should be appreciated that like reference numerals are used to identify like elements illustrated in one or more of the figures wherein showings therein are for purposes of illustrating embodiments of the present disclosure and not for purposes of limiting the same.

The present disclosure provides systems and methods for managing two or more versions of an application executing on two or more servers. The servers may be part of a server pool in which all servers in the server pool are executing the same application. Different servers in the server pool may be executing different versions of the application. The application may be provided by a payment service provider to facilitate a particular transaction such as providing payment to purchase a product or transferring funds from a sender to a recipient. Session data from a user may be loaded at a first server executing a first version of an application. The session data may be associated with a second version of the application different from the first version. The session data may include data that identifies the session data as associated with the second version of the application as well as one or more class names for data elements and a session data size. An error may be detected by the first server based on the difference between the first version of the application executing on the first server and the second version of the application to which the session data is associated. For example the application executing the first version of the application may be unable to process the session data associated with the second version of the application because the session data includes a class not used by the first version of the application. The first version of the application may inspect or analyze the session data to identify the difference or may inspect a wrapper of the session data to identify a version number of the session data. A second server executing the second version of the application is selected in a server pool which includes one or more servers. The second server may be selected by consulting a metadata store that stores information of all servers in the server pool and the version numbers of applications executing on each server in the server pool. The session data may then be read by the identified second server to continue the user s transaction as the result of the first server submitting a proxy request to the second server.

Referring now to an embodiment of a networked system is illustrated. The networked system includes one or more client devices that are coupled to a network . A global traffic manager is coupled to the network and to an application router . The application router is coupled to one or more server pools and . Each server pool and may include one or more servers denoted as and that are each coupled through a local network e.g. a local area network LAN and respectively to a local traffic manager and respectively a metadata store and respectively and a session data store and respectively. Session data stores and may store session data for one or more transactions of a payment service provider as will be described further below. Each of the local traffic managers and are coupled to the application router .

In the embodiments discussed below each server pool may be used by a payment service provider to provide one or more payment service provider applications such as a checkout application money sending application and or other payment service provider applications known in the art. As such the server pools and and the application router may be part of a payment service provider system . Payment service provider system may provide multiple applications to consumers and businesses that facilitate a wide variety of transactions. However one of skill in the art in possession of the present disclosure will recognize that the systems and methods of the present disclosure will be beneficial to a wide variety of applications provided by a wide variety of different system providers. As such while specific references are made to a payment service provider providing the systems and methods of the present disclosure any system provider utilizing the teachings of the present disclosure to manage two or more versions of any type of application executing on two or more servers is envisioned as falling within the scope of the present disclosure.

The client devices global traffic manager application router servers local traffic manager and metadata store may each include one or more processors memories and other appropriate components for executing instructions such as program code and or data stored on one or more computer readable mediums to implement the various applications data and steps described herein. For example such instructions may be stored in one or more computer readable mediums such as memories or data storage devices internal and or external to various components of the system and or accessible over the network .

The client devices may be implemented using any appropriate combination of hardware and or software configured for wired and or wireless communication over network . For example in one embodiment the client devices may be implemented as a personal computer of a user in communication with the Internet. In other embodiments the client devices may be a smart phone laptop computer wearable computing device and or other types of computing devices.

The client devices may include one or more browser applications which may be used for example to provide a convenient interface to permit users to browse information available over the network . For example in one embodiment the browser application may be implemented as a web browser configured to view information available over the Internet.

The client devices may also include one or more toolbar applications which may be used for example to provide user side processing for performing desired tasks in response to operations selected by the user. In one embodiment the toolbar application may display a user interface in connection with the browser application.

The client devices may further include other applications as may be desired in particular embodiments to provide desired features to the client devices . In particular the other applications may include a payment application for payments facilitated by a payment service provider through the server pools and . The other applications may also include security applications for implementing user side security features programmatic user applications for interfacing with appropriate application programming interfaces APIs over the network or other types of applications. Email and or text applications may also be included which allow the user to send and receive emails and or text messages through the network . The client device include one or more user and or device identifiers which may be implemented for example as operating system registry entries cookies associated with the browser application identifiers associated with hardware of the client device or other appropriate identifiers such as a phone number. In one embodiment the user identifier may be used by the payment service provider server pools and .

The network may be implemented as a single network or a combination of multiple networks. For example in various embodiments the network may include the Internet and or one or more intranets landline networks local area networks wide area networks wireless networks and or other appropriate types of networks.

The global traffic manager may be provided by a third party service not affiliated with an individual user and may be used by many parties including payment service providers to direct user requests to servers or other computing resources that are located geographically closer to a particular user or computing resources that have capacity to handle user requests.

The application router may be part of a payment provider service system and may receive user requests and facilitate transactions with users by directing requests data for transactions and any other data to an appropriate server pool or individual server executing a particular application. For example application router may direct a request for a checkout application to a server pool having servers executing the checkout application.

As described above server pools and may include a plurality of servers and local traffic managers and and metadata stores and . As illustrated in different servers in the server pools and e.g. servers and may be executing a different version of a particular application e.g. version or version in the illustrated embodiment . Examples of applications include for example a purchasing application for purchasing a good or service from a merchant e.g. a checkout application a money sending application for sending money from one person or entity to another a donate application for donating money from a person or entity to a charity or any other application provided by a payment service provider. Furthermore as discussed above a wide variety of applications other than payment applications will benefit from the teachings of the present disclosure and are envisioned as falling within its scope. For example in servers and are executing version of a money sending application while servers and are executing version of that money sending application. Although two versions are illustrated in embodiments described herein may include servers in one or more server pools executed any number of versions of an application. Further the version of an application executing on any particular server may change if a new version of the application is installed on that server. Thus for example server may be upgraded to version of the application at some point in the future.

Local traffic managers and may receive requests from the application router and may select a server in their respective server pool that will handle the requests. The server selected to handle a request may be chosen by taking into consideration multiple factors such as for example a current workload of the servers in the server pool and or a variety of other request handling criteria known in the art.

The example applications described above may require multiple steps or stages each of which may presented to a user using one or more web pages having input fields and or other data to perform a transaction. In an embodiment each web page that is presented to the user and that corresponds to a step to perform the transaction may be provided by a different server in a server pool. For example a first web page corresponding to a first step of a money sending transaction may be provided by server a second web page corresponding to a second step of the money sending transaction may be provided by server and a third web page corresponding to a third step of the money sending transaction may be provided by server . Data spanning across multiple user requests for a single transaction may be referred to as session data and contains an accumulation of data transmitted between a client device and one or more servers and during multiple HTTP requests pertaining to a single transaction. Session data may be stored in for example a session data store or .

In a typical user transaction the user s session data is initiated while processing a request submitted at client device which may be routed to the application router by the global traffic manager . As described above the global traffic manager may be used by the payment service provider to direct user requests to server pools that are located geographically closer to a particular user. From global traffic manager the user s request then passes to application router which determines the application suitable for the user s transaction and forwards the user s request to a server pool such as server pool or with servers executing the appropriate application. The local traffic manager or of the server pool then forwards the user s request to one of the servers based on various criteria such as a current workload of each server. The selected server then facilitates the user s request storing information about the transaction into a persistent session store such as session data store holding the session data across multiple requests within the transaction. Session data is typically a list or a set of key value pairs where each pair stores data used by the transaction.

Payment service providers often use multiple servers executing the same application to provide high availability of the application. For example applications used by payment service providers that facilitate purchases or other transactions are desired to provide near 100 availability in order to allow users to purchase products or perform other transactions at any time of the day or night. The multiple servers which may constitute a server pool may all execute the same application and each server can handle one or more steps or stages of a transaction. Typically only one version of an application is executing on servers in a server pool at a given time. However there are certain times when two or more versions of an application may execute on servers in a server pool at a given time. For example during deployment of a new version of an application two versions of an application may be executing on servers in a server pool at the same time. Upgrading an application executing on a server to a new version may be difficult when applications require such high availability. Further complications may arise during the upgrade process on multiple servers when two different versions of an application are incompatible with each other.

For example version of a particular application may require three steps or stages and version of that application may require four stages. Elements of session data that are used by the application may differ from version to version . As one example a money sending application may allow a first user to send money to a second user. Version of the money sending application may include three steps 1 specify the recipient 2 specify the amount and source of funds and 3 confirm the transfer. Thus the session data for version of the money sending application may include key value pairs for at least the recipient amount and source information. Version of the money sending application may include four steps 1 specify the recipient 2 specify the date of transfer 3 specify the amount and source of funds and 4 confirm the transfer. Thus session data for version of the money sending application may include at least the recipient date of transfer amount and source information.

If the user s session begins on a server in a server pool executing version of the money sending application and at some point in the transaction the session is transferred to a server in the server pool executing version of the money sending application an error may occur. The error may occur in the above example because version of the money sending application requires the user to specify the date of transfer and such data may be provided by the customer and included in the session data but version of the application does not or cannot read process or otherwise handle that session data containing the date of transfer information. Such an error may be referred to as a deserialization exception. That is the earlier version of the application cannot or does not know how to process session data it does not expect to see because the new version of the application includes a new variable or may include a new class. Typically when such a deserialization exception occurs the user is presented with an error the user s attempted transaction fails and the user must restart the transaction from the beginning.

In the converse of the above example the user s session may begin on a server executing version of the money sending application and at some point in the transaction the session may be transferred to a server executing version of the money sending application and thus an error may occur in this situation as well. For example the server executing version of the money sending application will expect to see date of transfer information in the session data. However because such data is not required by version of the application that data will not be included in session data provided to the server executing version of the money sending application when the user session is transferred from that server from the server executing version of the money sending application. Thus a deserialization exception may occur in this example as well.

When upgrading multiple servers to execute a new version of an application one option is to deactivate multiple servers at the same time install the new version of the application and reactive the servers once the upgrade is complete on all servers. For example to upgrade servers every one of those servers may be taken offline or deactivated at the same time have version of an application installed and then be reactivated. Deactivating servers and upgrading the applications on those servers helps ensure that deserialization exceptions and other related errors do not occur. However deactivating multiple servers at once may affect availability of the application executing on the servers and may lead to a diminished user experience.

Instead of deactivating groups or pools of servers at the same time applications may be upgraded on individual servers in a server pool one at a time or in groups smaller than the total number of servers in the server pool. Such an upgrade strategy minimizes the unavailability of the application. Since only a portion of the servers in the server pool are deactivated at a time the other servers in the server pool can handle user requests without a large impact on application availability. Such an upgrade strategy may be known as a mixed mode deployment strategy. A mixed mode deployment strategy may also be used when testing a new version of an application on a limited number of servers in a server pool. However using such an upgrade strategy deserialization exceptions may occur when the different servers in the server pool have different application versions as a user s session can span multiple servers having different versions and lead to the problems discussed above.

One solution to the issues raised by a mixed mode deployment strategy is to utilize intelligent routing. That is a load balancer or other front end router such as local traffic manager or application router may be configured to analyze session data from a user and direct the request to an appropriate server executing the corresponding application version. Thus in the example above local traffic manager may analyze session data from the user s session determine that the session data is associated with version of the application and route the request to a server in server pool executing version of the application. However intelligent routing may slow the performance of the router load balancer and or other front end systems. Further intelligent routing may only be necessary when an application is being upgraded in the mixed mode deployment strategy and such upgrade events or roll outs may be infrequent. Additionally even when an application is being upgraded session deserialization exceptions themselves may occur infrequently. Thus the decrease in performance resulting from intelligent routing may not be commensurate with the benefit afforded by intelligent routing.

Embodiments described herein utilize additional features that may be executed as part of an application itself to handle deserialization exceptions by proxying a request to an appropriate server executing a compatible version of an application when a deserialization exception or other error occurs. Instead of presenting the user with an error message or having the user s transaction fail the request may be proxied from a server executing an incompatible version of the application to a server executing a compatible version of the application such that the server executing the compatible version of the application may process the user s session data. Accordingly the user s experience is improved. In one embodiment a metadata store such as metadata store or maintains information describing the versions of an application executing on various servers in a server pool. If a deserialization exception occurs in an application executing on a particular server based on a version incompatibility the application can consult the metadata store to identify another server executing the correct version of the application and transmit the request to that server. Thus the user s session can continue without interruption.

Referring now to an embodiment of a method for managing two or more versions of an application executing on two or more servers is illustrated. In the embodiments and examples discussed below a money sending application is used as an example of an payment application. However other payment applications are also possible including checkout applications donate money to charity applications and or a wide variety of other types of payment applications known in the art. Furthermore as discussed above a wide variety of non payment applications will benefit from the teachings of the present disclosure and are envisioned as falling within its scope. Such applications may be provided by a payment provider service or other system provider and or may include other applications that require high availability e.g. a stock trading or other financial services application .

The method begins at block where a hypertext transmission protocol request from a user is received at a server executing a version of an application. In one embodiment as part of processing the request the server may load or read session data from the session data store such as session data store associated with the user s request. The session data may be stored in the session data store from or during a prior request within the same transaction. The session data may be associated with a second version of the application which is a different version of the application than the version of the application that is currently executing on the server that receives the request. For example as described above the request may be received at server from a client device through a global traffic manager application router and local traffic manager . The session data read from the session data store while processing the request or an envelope around the session data may indicate that the session data is associated with version of the application while server is currently executing version of the application.

The method then continues to block where an error is detected. For example an error may be generated or thrown by the version of the application on the server in response to attempting to process the session data. In one embodiment the error may be a session deserialization exception. As described above a session deserialization exception occurs when one version of an application attempts to read or process data that is associated with a different version of the application. In the example given above the session deserialization exception may occur because version of the application that is executing on server cannot process session data associated with version of the application such as a class name or other data in the user s session data that was generated in response to the client device communicating with a server executing version of the application prior to the session data being read by the server

The method then continues to decision block where a determination is made as to whether the deserialization exception or other error occurred as a result of a version difference or is based on another error. For example the version number of the application and the version number of the session data may be compared for the determination at decision block . If the error was based on a version difference method proceeds to block . If the error was not based on a version difference method proceeds to block as is described below.

The version number of the session data may be identified by data in a wrapper or envelope around the session data. The session envelope may also include the name of a class used to serialize i.e. write the session. Further the session envelope may also include the size of the serialized session.

If the determination at decision block is that the error was based on a difference in version between the session data and the version of the application executing on the first server that received the request the method proceeds to block . At block the server e.g. server identifies a server in the server pool that is executing the version of the application that corresponds to the loaded session data. In one embodiment for example server may consult a metadata store such as metadata store to identify a server in the server pool that is executing a version of the application that is configured to process the loaded session data e.g. the loaded session data that was unable to be processed and resulted in the error at block .

Metadata stores may store for each server in a server pool a record that identifies a location of the server an application name of an application executing on the server a version number or build number of that application and the last time the record was updated. The data in the metadata store may be updated when an application is started on the server. Similarly when the application is shut down the record for the server may be deleted from the metadata store. On a periodic basis each server in the server pool may update its metadata store record. For example each server may update its corresponding metadata store record every 15 minutes. The update interval may be configurable depending on the payment service provider s or system provider s needs based on the application being executed by the servers in the server pool and or based on a variety of other update factors known in the art.

In one embodiment when the metadata store is queried records for servers having a last update time that exceed a threshold i.e. records older than the update interval of 15 minutes 60 minutes and or other thresholds known in the art may be removed from the metadata store. Such records may be referred to as stale metadata. Thus for example servers that crash or otherwise become unresponsive may have their associated metadata removed from the metadata store. The stale metadata interval may be configurable depending on the payment service provider s or system provider s needs or based on the application being executing by the servers in the server pool and or based on a variety of other stale metadata factors known in the art.

The method then continues to block . At block the request may be proxied to the server identified at block as executing the version of the application which corresponds to the loaded session data. In one embodiment a hypertext transfer protocol proxy forward request is used to transmit the request from the server that initially loaded the session data at block to the server determined to have the correct version of the application at block . The proxy request may submit a new GET or POST HTTP request to the server executing the correct version of the application. The server executing the correct version of the application may then process the user s session data which enables the user to continue the transaction. If the proxy forward request is successful the deserialization exception or other error may be suppressed the user is not informed of the error and the user s transaction appears to proceed normally to completion from the user s perspective.

In some embodiments more than one server may be identified at block as executing the correct version of the application. Accordingly in one embodiment the server to which the proxy request is transmitted at block may be selected on a random basis. For example the server to which the proxy request is transmitted at block may be selected based on a last update time that the metadata store record for that server. Thus for example servers that have more recently updated records in the metadata store may be chosen over servers with older records in the metadata store.

In certain cases at block the proxy request to the selected server may fail. This can occur for example if the selected server crashed in the time period between when it updated its metadata store record and the time when the metadata store was queried in block . Thus in one embodiment if the proxy request fails the metadata store may be queried to identify another server in the server pool to which the proxy request can be transmitted in substantially the same manner as discussed above with reference to block . In one embodiment the receiving server may query the metadata store following proxy request fails for multiple servers until a threshold number of servers have been attempted or until a specified time period has passed. For example the receiving server may query the metadata store following proxy request fails until up to 5 servers have been returned or may continue querying the metadata store following proxy request fails until 30 seconds or another time period has elapsed. If the threshold number of servers has been attempted or the time period has passed an error may be returned to the user and the transaction may fail.

As described above at decision block if the session deserialization exception occurs but is not based on a version difference method proceeds to block . At block an error may be returned to the user and the transaction may fail. For example the deserialization exception may occur based on a bug in the application or a server error and not because of a version difference.

Referring now to a swim lane diagram which begins at and continues to detailing the interaction between various systems and components described with reference to embodiments discussed above is illustrated. The example of illustrates the interactions between a client device servers and metadata store . In the example of server is executing version denoted as V of an application and server is executing version denoted as V of the application. Further in the example of server is initially executing version 1 of the application but is later updated to version of the application. In a checkout application is illustrated but the illustration is equally applicable to other types of applications.

Beginning on at event server may begin executing version of the checkout application. Accordingly server may update the metadata store with a record identifying the application being executed the version number of the application and the time the metadata store was updated. At event the metadata store may receive and store the record.

At event server may begin executing version of the checkout application. Accordingly server may update the metadata store with a record identifying the application being executed the version number of the application and the time the metadata store was updated. Further at event the metadata store may receive and store the record.

At event server which may have already been executing version of the checkout application is upgraded to version of the checkout application. Thus at event server transmits an updated record to metadata store updating at least the version number of its metadata record and the last update time. At event the metadata store may receive and store the record.

At event a user using client device may commence a checkout application transaction. At event server may receive the user s request for the transaction and any initial data for the transaction and write initial session data to the session data store for the transaction along with a session envelope that identifies the session data as corresponding to version of the checkout application. As described above server may receive the user s request for the transaction through global traffic manager application router and local traffic manager . At event server may also provide a web page corresponding to step of the checkout application to client device which receives the web page at event .

At event the user of client device enters data corresponding to step of the checkout application and submits the data in a request. At event server may receive the request and attempt to process the session data. As described above server may be chosen to receive the request and process the session data by for example local traffic manager . However at event when server attempts to process the session data it may generate or throw an error such as a deserialization exception because server is executing version of the checkout application while the session data is associated with version of the checkout application.

As discussed above with reference to block of the method at event server may submit a lookup request to metadata store for a server executing version of the application. At event metadata store receives the request from server and determines from the records in the metadata store any servers in the server pool executing version of the application such as server and . At event metadata store may transmit the identified servers to server

Continuing to at event server receives the data indicating that servers and are executing version of the application. Server may choose server to handle the request for example on a random basis and thus at event server submits a proxy request to server with data entered by the user. At event server may receive the proxy request and can then load and process the session data from session data store such that the user s transaction can continue at event . Once server processes the user s session data at event as part of the proxy request from server server may provide a web page for step of the transaction to server which receives the web page at event . At event server provides the web page for step to client device which receives the web page at event and the user can then continue the transaction.

In the embodiments and examples described above servers which can be candidates for proxy requests are restricted to those servers within the same server pool as a server receiving a request from a user. For example metadata store may only include application version information for servers within server pool . Additionally session data store may only store data for transactions which occur on servers within server pool . Thus only servers within server pool for example servers and may serve as candidate servers for a proxy request from another server in server pool such as server .

In one embodiment data may be replicated between metadata store and metadata store and thus servers in both server pool and may be candidate servers for proxy requests from servers in server pool and . In one embodiment session data may also be replicated between session data store and . In a further embodiment metadata stores and may be combined into a single metadata store accessible to both server pools and . Similarly session data stores and may be combined into a single session data store accessible to both server pools and . In such embodiments proxy requests may still be limited to servers within a same server pool for example using database lookup techniques.

In one embodiment an application upgrade strategy or rollout strategy may minimize the number of deserialization exceptions that occur. Such a rollout strategy may upgrade servers to new application versions in groups. In one embodiment a relatively small set of servers is upgraded followed by one or more relatively larger sets of servers and the rollout strategy may finish by upgrading one or two relatively smaller sets of servers. In one embodiment a waiting period approximately equal to the longest expected reasonable session duration may be allowed between the upgrade of two server groups to allow in progress sessions time to finish. The total time to upgrade a server pool to a new version of an application may be minimized since mixed mode management may increase the workloads of servers in the server pool.

Thus systems and methods for managing multiple versions of an application on multiple servers have been described that provide for high availability of the application while minimizing the occurrence of errors that result from the passing of intra session requests between servers executing different versions of that application. The systems and methods of the present disclosure provide substantial benefits over conventional solutions such as the intelligent routing solutions discussed above by for example only analyzing session data in response to a detected error rather than analyzing all session data for all requests received from users such that that requests can be directed to an appropriate server executing a correct application version. Further the systems and methods of the present disclosure provide substantial benefits over conventional solutions that in response to deserialization exceptions or other detected errors force the user of a client device to restart a transaction.

Referring now to an embodiment of a computer system suitable for implementing for example the client device application router servers and local traffic manager and and or metadata store and is illustrated. It should be appreciated that other devices utilized by customers merchants payment service providers and or system providers in the system discussed above may be implemented as the computer system in a manner as follows.

In accordance with various embodiments of the present disclosure computer system such as a computer and or a network server includes a bus or other communication mechanism for communicating information which interconnects subsystems and components such as a processing component e.g. processor micro controller digital signal processor DSP etc. a system memory component e.g. RAM a static storage component e.g. ROM a disk drive component e.g. magnetic or optical a network interface component e.g. modem or Ethernet card a display component e.g. CRT or LCD an input component e.g. keyboard keypad or virtual keyboard a cursor control component e.g. mouse pointer or trackball a location determination component e.g. a Global Positioning System GPS device as illustrated a cell tower triangulation device and or a variety of other location determination devices known in the art and or a camera component . In one implementation the disk drive component may comprise a database having one or more disk drive components.

In accordance with embodiments of the present disclosure the computer system performs specific operations by the processor executing one or more sequences of instructions contained in the memory component such as described herein with respect to the client devices servers and application router local traffic managers and and or metadata stores and . Such instructions may be read into the system memory component from another computer readable medium such as the static storage component or the disk drive component . In other embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the present disclosure.

Logic may be encoded in a computer readable medium which may refer to any medium that participates in providing instructions to the processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. In one embodiment the computer readable medium is non transitory. In various implementations non volatile media includes optical or magnetic disks such as the disk drive component volatile media includes dynamic memory such as the system memory component and transmission media includes coaxial cables copper wire and fiber optics including wires that comprise the bus . In one example transmission media may take the form of acoustic or light waves such as those generated during radio wave and infrared data communications.

Some common forms of computer readable media includes for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge carrier wave or any other medium from which a computer is adapted to read. In one embodiment the computer readable media is non transitory.

In various embodiments of the present disclosure execution of instruction sequences to practice the present disclosure may be performed by the computer system . In various other embodiments of the present disclosure a plurality of the computer systems coupled by a communication link to the network e.g. such as a LAN WLAN PTSN and or various other wired or wireless networks including telecommunications mobile and cellular phone networks may perform instruction sequences to practice the present disclosure in coordination with one another.

The computer system may transmit and receive messages data information and instructions including one or more programs i.e. application code through the communication link and the network interface component . The network interface component may include an antenna either separate or integrated to enable transmission and reception via the communication link . Received program code may be executed by processor as received and or stored in disk drive component or some other non volatile storage component for execution.

Where applicable various embodiments provided by the present disclosure may be implemented using hardware software or combinations of hardware and software. Also where applicable the various hardware components and or software components set forth herein may be combined into composite components comprising software hardware and or both without departing from the scope of the present disclosure. Where applicable the various hardware components and or software components set forth herein may be separated into sub components comprising software hardware or both without departing from the scope of the present disclosure. In addition where applicable it is contemplated that software components may be implemented as hardware components and vice versa.

Software in accordance with the present disclosure such as program code and or data may be stored on one or more computer readable mediums. It is also contemplated that software identified herein may be implemented using one or more general purpose or specific purpose computers and or computer systems networked and or otherwise. Where applicable the ordering of various steps described herein may be changed combined into composite steps and or separated into sub steps to provide features described herein.

The foregoing disclosure is not intended to limit the present disclosure to the precise forms or particular fields of use disclosed. As such it is contemplated that various alternate embodiments and or modifications to the present disclosure whether explicitly described or implied herein are possible in light of the disclosure. For example the above embodiments have focused on merchants and customers however a customer or consumer can pay or otherwise interact with any type of recipient including charities and individuals. The payment does not have to involve a purchase but may be a loan a charitable contribution a gift etc. Thus merchant as used herein can also include charities individuals and any other entity or person receiving a payment from a customer. Having thus described embodiments of the present disclosure persons of ordinary skill in the art will recognize that changes may be made in form and detail without departing from the scope of the present disclosure. Thus the present disclosure is limited only by the claims.

