---

title: Key management using quasi out of band authentication architecture
abstract: To provide key management layered on a quasi-out-of-band authentication system, a security server receives a request for activation of a user interface window for a particular user from a network device via a communication channel. It then transmits an activation PIN to an out of band authentication system for forwarding to the user's telephone via a voice or text message. It next receives the previously transmitted PIN from the network device via the communication channel, and authenticates the user based on the received PIN. After authenticating the user, it establishes a secure, independent, encrypted communication channel between the user interface window and the security server on top of the original communication channel. It then generates and transmits to the user interface window and/or receives from the user interface window via the secure communication channel, key material and certificate material for public key and/or symmetric key cryptography based operations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09197406&OS=09197406&RS=09197406
owner: AUTHENTIFY, INC.
number: 09197406
owner_city: Chicago
owner_country: US
publication_date: 20140221
---
This application is related to pending application Ser. No. 13 081 150 filed Apr. 6 2011 and entitled FLEXIBLE QUASI OUT OF BAND AUTHENTICATION ARCHITECTURE which claims priority based on Provisional U.S. Application Ser. No. 61 334 776 filed May 14 2010. This application is also related to pending application Ser. No. 13 081 067 filed Apr. 6 2011 and entitled SECURE AND EFFICIENT LOGIN AND TRANSACTION AUTHENTICATION USING IPHONES AND OTHER SMART MOBILE COMMUNICATION DEVICES which claims priority based on Provisional U.S. Application Ser. No. 61 327 723 filed Apr. 26 2010. This application is also related to pending application Ser. No. 12 938 161 filed Nov. 2 2010 and entitled A NEW METHOD FOR SECURE SITE AND USER AUTHENTICATION which claims priority based on Provisional U.S. Application Ser. No. 61 257 207 filed Nov. 2 2009 and entitled Project Seal . This application is also related to pending application Ser. No. 13 006 806 filed Jan. 14 2011 and entitled A NEW METHOD FOR SECURE USER AND SITE AUTHENTICATION which is a continuation of pending application Ser. No. 12 938 161. This application is also related to pending application Ser. No. 13 011 587 filed Jan. 21 2011 and entitled A NEW METHOD FOR SECURE USER AND TRANSACTION AUTHENTICATION AND RISK MANAGEMENT which claims priority based on Provisional U.S. Application Ser. No. 61 298 551 filed Jan. 27 2010 and entitled Authentication The Game Changer . This application is also related to application Ser. No. 13 011 739 filed Jan. 21 2011 and entitled A NEW METHOD FOR SECURE USER AND TRANSACTION AUTHENTICATION AND RISK MANAGEMENT which is a continuation in part of pending application Ser. No. 13 011 587. The contents of the above identified applications are hereby incorporated herein in their entirety by reference.

This invention relates to security and privacy. More particularly it relates to using the quasi out of band authentication QOOBA architecture for key management.

The increasing sophistication of site specific attacks based on man in the middle MITM and man in the browser MITB techniques has profound implications for our current authentication techniques. Specifically the strength of the initial login authentication is increasingly becoming less relevant as these attacks manipulate transactions after the legitimate user has provided the initial credentials to login. In reaction to this trend leading organizations have begun deploying transaction authentication systems such as EMV CAP based token authenticators or have been using out of band authentication OOBA techniques to ensure that the user actually intended the transaction being seen at the back end. However such approaches are inherently not easy to use and consequently even when deployed are generally used only for high risk transactions or occasional events like profile changes. For the vast majority of transactions no current authentication solution provides a reasonable point in the How easy How secure How costly trade off.

In prior work see the related applications identified above we described innovations that address some of the problems with conventional authentication systems. Specifically we introduced the notion of using QOOBA techniques to ensure that the user actually intended the transaction being seen at the back end. We also described how these techniques can be used to provide a user with a one time password OTP to enable login into a website i.e. authentication of the user to the website based on a secret shared between the web site and a QOOBA security server. Thus these techniques can be used to provide the security of one time passwords but do not require a per user shared secret which all prior one time password systems have required.

We also extended our prior work to address the issue of providing an authentication solution for the vast majority of transactions at a reasonable point in the How easy How secure How costly trade off.

Here we extend our prior work to consider solutions to the key management problem which surfaces in various contexts. Three of many potential examples include the following.

Below we will describe various examples of how key management can be beneficially layered on top of a QOOBA architecture. Our first example relates to digital signing. In applications that require digital signing a user needs to be provisioned a private key and a digital certificate i.e. a binding of the user s identity and public key as certified by a Certificate Authority. The use of such a private key which is not known to any 3party including the security server provides for strong non repudiation which is necessary for some applications. We follow the industry convention of referring to signatures created with public key cryptography as digital signatures . As will be understood by those skilled in the art signatures based on underlying symmetric cryptography with shared secrets like that which the QOOBA system as described above already provides are usually referred to as electronic signatures .

Our second example relates to encrypted document delivery. When an encrypted file is sent to a user for example a PDF of a brokerage statement the user needs to be provided with the key with which the file was encrypted.

Our third example relates token authenticators. When users are provisioned a token authenticator either for a one time password generator or a transaction authenticator the user s token needs to be provided with a shared secret key. Those skilled in the art will recognize that in this context the shared secret key is often characterized as a seed .

In all these examples key management adds directly to the cost of the system and indirectly effects the security. Keys need to be generated distributed and maintained in sync. As keys can get lost corrupted or stolen key management is usually a significant source of costs and a point of vulnerability in the system.

Accordingly it is an objective of the present invention to provide an innovative way to leverage the QOOBA system to perform key management for digital signing encryption and token seed management.

Additional objects advantages novel features of the present invention will become apparent to those skilled in the art from this disclosure including the following detailed description as well as by practice of the invention. While the invention is described below with reference to preferred embodiment s it should be understood that the invention is not limited thereto. Those of ordinary skill in the art having access to the teachings herein will recognize additional implementations modifications and embodiments as well as other fields of use which are within the scope of the invention as disclosed and claimed herein and with respect to which the invention could be of significant utility.

In accordance with certain preferred aspects of the invention a security server can be operated so as to provide key management layered on a quasi out of band authentication system. A request for activation of a user interface window for a particular user at a network device such as a desktop computer associated with that user is received from the network device via a communication channel. At this point the communication channel is non secure or what is sometimes referred to as clear . It will be recognized by those skilled in the art that having an non secure channel at this point in a communication protocol is not unusual. For example when a user initiates communications with an SSL protected website an insecure or clear TCP IP connection is initially set up and only later is SSL security established on top of the non secure or clear TCP IP connection.

Next to authenticate the user to the security server an activation PIN personal identification number is transmitted to an out of band authentication OOBA system for forwarding to the user s telephone via a voice or text message. For example the OOBA system may place a call to the user s home or cell phone and convey the PIN to the user verbally or may send a text message to the user s smart phone e.g. the user s IPhone or Blackberry and convey the PIN to the user in written form. In either case the user must enter i.e. copy the conveyed PIN into the user interface window so that it will be conveyed back to the security server. In this way the PIN previously transmitted by the security server to the OOBA system is received back by the security server from the user s network device via the communication channel and the user is authenticated or authentication is refused based on the returned PIN.

Subject to the user being authenticated by the security server a secure independent encrypted communication channel between the user interface window and the security server is established on top of the originally established communication channel. With this secure channel established key material and or certificate material for public key and or symmetric key cryptography based operations can be generated and or securely transmitted between the user interface window and the security server. It is perhaps worthwhile noting here that key material and certificate material are well understood terms in the art. For example key material often includes symmetric keys or asymmetric keys and certificate material often includes user identity and public key binding.

In implementations involving the generation and transmission of key material for public key cryptography the security server preferably receives a public key Pu of a private public key pair Du Pu associated with the user and previously generated by the user interface window. The public key Pu is received from the user interface window via the secure independent encrypted communication channel. In response the security server transmits a signed certificate which associates the user with the received public key Pu and instructions for storage of the certificate both going to the user interface window via the secure channel.

The certificate may be signed by the security server itself or by an external authenticating authority such as a third party certificate authority. If the security server acts as an Intermediate or Root Certificate Authority preferably the security server generates and signs the certificate using locally stored certificate authority key material. If on the other hand the certificate is signed by an external certificate authority the security server preferably sends an unsigned certificate to the external certificate authority and receives the signed certificate from the certificate authority. In such a case it is the certificate signed by the external certificate authority that is transmitted by the security server to the user interface window.

The transmitted storage instruction may depending on the implementation require storage of the user private key Du and signed certificate in memory on the user s network device or in the key store of an operating system such as the Windows operating system of the network device or both. Alternatively the transmitted storage instruction may explicitly or implicitly leave the storage decision to the user interface window. For example if no storage instruction is provided this may be considered by the user interface window to be an implicit instruction that it is up to the user interface window to decide where to store the user private key Du and signed certificate. Storage may be for the benefit of only the user interface window or it may additionally be for the benefit of other local applications which may include the browser application.

In implementations involving the generation and transmittal by the security server of key material for symmetric key cryptography operations the security server beneficially receives an authenticated request containing unique identifying information associated with the user or with a file i.e. a document such as an Adobe or WinZip file or document. This information may be received from the user interface window or from a third party network site such as a merchant or bank website. Irrespective of which entity the request is received from the security server generates a unique symmetric key K. The key K is generated using a one way function and the key s value is derived from the received unique identifying information and a secret known only to the security server. The security server transmits the symmetric key K to the requester i.e. the user interface window or the third party network site.

In implementations involving the security server performing public key cryptography operations to obtain a digital signature on a transaction the security server advantageously receives the transaction and a request for digital signing of the transaction from a third party network site such as a merchant or bank website. The security server transmits the transaction and a request for a digital signature to the user interface window via the secure channel. In response the security server receives from the user interface window a hash of the transmitted transaction digitally signed with the user s private key Du via the secure channel. The security server next transmits the received digitally signed hash of the transaction and a certificate to the third party network site. The security server also transmits instructions for the third party network site to verify the digital signature by recomputing the hash and comparing it with the hash that can be recovered from the transmitted digitally signed hash by applying the user s public key Pu included in the transmitted certificate to the transmitted digitally signed hash. This instruction can be explicit or implicit. For example the security server may provide no instruction regarding verification and this may be considered by the third party network site as an implicit instruction to perform verification in the manner described about.

Even if a digital signature is required it may be desirable to also obtain the user s electronic signature on the transaction. If so the security server can transmit to the user interface window for presentation to the user a personal identification number PIN with which to electronically sign the transaction presented in a browser window displayed at the user s network device. The PIN is transmitted via the secure independent encrypted communication channel. The user enters the transmitted PIN presented in the user interface window into a browser window which is communicating with the third party network site with which the user is transacting the business to electronically sign the transaction. It is highly preferable that the PIN corresponds to a secret shared by the security server and the third party network site but not by the user.

The transmitted transaction may or may not include an instruction to present the transaction to the user in the user interface window and or to obtain approval of the user prior to digitally signing of the transaction. Here again the instruction may be explicit or implicit. For example in the case of approval the user s approval of the transaction might require the user to click on an approved button presented in the user interface window prior to the user interface window digitally signing the transaction. Alternatively approval might be signaled by the user not rejecting the transaction presented on the user interface window within a predefined period of time after the transaction is first presented in the user interface window.

In the case of digital signatures the user interface window may manage storage of the user s private key Du and the signed certificate in memory or in the key store of an operating system of the network device or in both for the benefit of other local applications. The security server may also verify the digital signature before transmitting the received digitally signed hash of the transaction and the certificate to the third party network site. To verify the signature the security server recomputes the hash of the transaction and compares it with the hash recovered from the received digitally signed hash by applying the user s public key Pu included in the received certificate to the received digitally signed hash of the transaction.

In implementations involving the security server performing symmetric key cryptography based operations that include sharing encryption keys the security server receives a request for one or more encryption keys associated with particular combinations of sender identification recipient identification and document identification which are collectively referred to as DocumentID from a third party network site e.g. a merchant a bank the U.S. Government etc.

The security server then generates one or more symmetric encryption keys for each DocumentID. The symmetric encryption keys are generated based on a one way function the applicable DocumentID a secret known only to the security server and if desired other information commonly used to generate symmetric crypto keys and well known to those skilled in the art. The security server transmits the generated encryption keys to the third party network site with instructions to encrypt the document represented by the applicable DocumentID with the appropriate key s and to transmit the encrypted document to the user. Here again the instructions may be explicit or implicit.

The security server next receives a request for the one or more symmetric encryption keys required to decrypt a document represented by a particular applicable DocumentID. The request includes the applicable DocumentID and is received from software other than the user interface window which is operating on the network device and being used to open an encrypted document represented by an applicable DocumentID. For example the request may be received from Adobe or WinZip or browser software. It may in certain cases be preferable to receive the request directly from the software. However in other cases it may be preferable to receive the request from the software via a network site which is in communication with the software attempting to open the document.

The security server recomputes or receives the applicable one or more symmetric encryption keys. It then transmits the recomputed or received applicable encryption key s to the user interface window. Transmitted with the applicable key s are instructions to present the applicable key s to the user for copying i.e. entry into the software to decrypt the document represented by the applicable DocumentID. Here again the instructions to the user interface window can be explicit or implicit.

If received the applicable symmetric encryption key s are received from a network site in communication with the software attempting to open the document and the key s transmitted to the user interface window are the key s received by the security server from the network site. If recomputed the security server recomputes the applicable key s based on the one way function the applicable DocumentID the secret known only to the security server and the other information and the key s transmitted to the user interface window are the recomputed key s .

In implementations involving the security server performing symmetric key cryptography based operations to provide a seed for token authenticator hardware or software the security server receives a request for a token seed from the user interface window. Along with the token seed request it also receives a user identifier and or a token identifier for which the seed is requested.

The security server generates the seed based on a one way function the identifier or identifiers a secret known only to the security server and other information well known to those skilled in the art. It then transmits to the user interface window the generated seed with explicit or implicit instructions to either present the transmitted seed to the user on the user interface window display for entry by the user into a seeding interface of the token or to enter the transmitted seed into the seeding interface of the token directly without user intervention. This transmission is made to the user interface window via the secure independent encrypted communication channel. The transmitted seed may in certain implementations beneficially be an intermediate seed which will be processed by the token software to generate the final seed.

In prior work we have described how the introduction of a network based security server which has an independent channel to a window displayed on a user device can be used in conjunction with a user s browser computer software or smart phone or other mobile communications device application and the website they are visiting to provide user authentication for login or transaction authorization via one or more user network device.

QOOBA is an innovative approach to create a solution that can be used to authenticate every transaction in a manner that will feel natural to users. The central idea is to create a small secure window the QOOBA Window that has an independent encrypted channel to a secure server the QOOBA Server . The QOOBA Window can be implemented as a zero download browser pop up the QOOBA Pop up Window as a small desktop application the QOOBA Software Window or as an app on a smart phone the QOOBA Phone Window . An important aspect to the innovation is that unlike as with soft tokens the QOOBA Window does not require secure storage of long term secrets. Rather it is activated during login by using out of band authentication. As a user transacts at a web site e.g. a merchant or bank website that is part of the QOOBA Network the transactions that the web site believes the user intends are sent securely via the user s browser to the QOOBA Server which displays the transaction in the QOOBA Window. The user is also optionally shown a transaction signature that the user can cut and paste from the QOOBA Window into their browser to authenticate to the website for login or transaction authorization purposes.

The QOOBA solution has the following benefits in terms of ease of use total cost of ownership and of particular interest here security.

First with regard to ease of use the user has no new device to carry or password to remember beyond having access to the phone used for out of band authentication. The user does not have to enter any cryptic transaction code into a device and type the result into the browser. Instead the user sees the entire transaction in their QOOBA Window and can copy and paste the transaction signature with a few clicks.

Second with regard to total cost of ownership the QOOBA architecture significantly reduces total lifecycle costs. It requires no new hardware and unlike a soft token does not require per user provisioning and management of secrets. Further as all communications between the web site and the QOOBA server can occur via the browser the integration requirements at the web site are extremely light. The overall costs of the QOOBA solution are designed to be significantly less than an equivalent soft token deployment and far less than that of a physical token.

Finally in terms of security as will be further discussed below the level of assurance depends on the form factor of the QOOBA Window that is used. The smartphone based QOOBA Window i.e. the QOOBA Phone Window provides the highest assurance but even the zero download pop up i.e. the QOOBA Pop up Window significantly raises the bar for an attacker. The software QOOBA window i.e. the QOOBA Software Window is likely to be satisfactory for almost all risk levels.

In our prior work we have described how by implementing the QOOBA solution using a flexible QOOBA architecture the web sites in the QOOBA Network are allowed to request or select the form factor and a type of transaction approval appropriate for the transaction. For instance a user can simultaneously have a QOOBA Window on their smartphone as well as on their desktop. While most transactions can be sent to their desktop QOOBA Software Window which is far more convenient the highest risk transactions can be sent to their smartphone QOOBA Phone Window. A user can be requested to approve most transactions by simply clicking on an approval button but allowed to approve other transactions by simply taking no action and still other transactions by placing a secure electronic signature on the transaction.

Referring now to in accordance with the present invention the QOOBA system consists of a desktop personal computing device having the QOOBA

Window and a Browser Window executing and displayed thereon a QOOBA Server and Web Service which has the QOOBA Application Programming Interface API operable thereon. It should be understood that in a practical implementation there would typically be multiple websites. Also included in the system as shown is an OOBA Service which is utilized by the QOOBA Server to bootstrap authentication of the user using the user s phone which may be a landline cellphone or smartphone.

As described in more detail in the related applications referenced above the user activates the QOOBA Window typically by using out of band authentication via OOBA Service and establishes a session with the QOOBA Server . Web Service participates in the QOOBA Network and goes through a onetime set up process to establish a shared secret with the QOOBA Server which is not shared with or known by the user. When the user has an active session with the QOOBA Server via communication channel and is also at the Website via communication channel the Website can use the QOOBA API to request via back end communication channel transaction authentication by sending the transaction directly to the QOOBA Server . The QOOBA Server then displays the transaction to the user in the applicable QOOBA Window which is shown in to be Window .

The QOOBA Server can present various information to the user in the displayed QOOBA Window . For example as we have described in our prior work the QOOBA Server can display a transaction to the user in the QOOBA Window and if requested also display in the QOOBA Window a transaction i.e. electronic signature derived from the transaction the secret shared between the QOOBA Server and the Website and other information. This is accomplished via communication channel . The user is optionally given the choice of accepting or rejecting the transaction. Acceptance can be signaled passively by taking no action by clicking OK within the QOOBA Window and sending a signal via communication channel back to the QOOBA Server or by copying and pasting the transaction signature from the QOOBA Window into the web application displayed in the Browser Window and then sent back to the Web Service via communication channel . If the transaction signature from the QOOBA Window is pasted into the web application displayed in the Browser Window the Website can verify the signature using the transaction the secret shared between the QOOBA Server and the Web Service and other information.

Thus one approval type may be characterized as INFORM . The transaction is simply shown to the user and no confirmation is required. This is like an activity stream and can reassure the cautious user. Another approval type can be characterized as CONFIRM . The user is asked to confirm or deny the transaction within the QOOBA Window and this response is sent back to the Web Service via the QOOBA Server . A still further approval type can be characterized as SIGN . The QOOBA Server generates a personal identification number PIN which will serve as the transaction signature and shows it to the user within the QOOBA Window or a QOOBA Window not shown on the smartphone. The user copies this transaction signature into their browser window and sends it to the Web Service . As the PIN is derived from a secret shared between the QOOBA Server and the Web Service and never revealed to the user the Web Service can recalculate the transaction signature independently and thus confirm the transaction. It will be observed that this achieves the same security effect of a transaction authenticator system but there is no per user provisioning of secrets.

The user interface to the QOOBA Server remains largely constant regardless of the browser and or operating system OS being used and the form factor of the QOOBA Window . The only use case in which the user experience deviates is when the user is browsing on a smartphone where the QOOBA experience is optimized for the device.

As noted above the QOOBA Window can be implemented in one of at least three form factors a browser pop up which we commonly refer to as the QOOBA Pop up Window does not require any software download a small application that is installed on the desktop which we commonly refer to as the QOOBA Software Window or as a smart phone app which we commonly refer to as the QOOBA Phone Window.

The same user might well be using different form factors at different times. For instance a user who has the software QOOBA Window installed and uses that most of the time might use the browser pop up QOOBA Window while at some other desktop roaming . For certain high risk transactions the website might require showing the transaction on the smartphone QOOBA Window while most transactions are shown in the desktop window. The look and feel of the QOOBA Window is entirely customizable by the particular QOOBA Network. An implementation for a bank intended solely for its own websites might look and feel very different from an implementation by a payment service that offers authentication into various eCommerce web services like the Web Service . Although numerous elements are described it should be understood that most of them are optional.

Turning to central to the QOOBA system is the establishment of a secure encrypted and independent channel between the QOOBA Window on a user s desktop or the QOOBA Window on the user s smartphone not shown and the QOOBA Security Server . As described above the QOOBA Window is used to show the user transactions and provide them with the opportunity to confirm i.e. approve the transaction.

We now introduce into the architecture as shown in the QOOBA Key Management Logic Client KMLC on the user s desktop the QOOBA Key Management Logic Server KMLS on the QOOBA security server the QOOBA Key Management Logic API KMLAPI on the Web Service and the possibility of non browser desktop or smartphone software e.g. Acrobat Reader . KMLC and KMLS communicate over the secure QOOBA channel between the QOOBA Window and the QOOBA security server . KMLS and KMLAPI communicate over the back end communication channel between the QOOBA security server and the Web Service .

With further reference to within the above described framework key generation proceeds as follows. At some point after the QOOBA Window is activated the KMLC generates a private public key pair e.g. Du Pu and stores the private key Du securely typically in memory . KMLC sends the public key Pu to the QOOBA Server where the request is intercepted by the KMLS . A digital certificate Cert which includes the user s public key Pu is prepared by KMLS and one of two things happens.

If KMLS is capable of acting as an Intermediate or root Certificate Authority it signs the certificate and returns the signed certificate to KMLC which maintains it locally preferably in memory . For example KMLS could sign the Cert with the private key Ds of it s private public key pair Ds Ps such that Cert Ds is returned to KMLC .

On the other hand if KMLS acts as a registration authority it forwards the certificate request to an external Certificate Authority which creates the certificate and returns it to KMLS which in turn forwards the certificate back to which maintains it locally preferably in memory . In such a case the Cert will be signed by the Certificate Authority with the private key Dca of it s private public key pair Dca Pca such that Cert Dca is returned to KMLS . KMLS then forwards the received signed Cert i.e. Cert Dca to the KMLC .

temporary and coincident with the life of the QOOBA session itself. By making it simple to do key generation coincident with activation the need to store digital certificates and private keys locally over an extended period is avoided.

In some situations as will be discussed in more detail below the private key and certificate may be needed by other applications e.g. browsers or document processors on the same desktop or mobile device . If the underlying operating system supports standard key stores as MS Windows or Apple MacOS do then the KMLC can be tasked with committing the keys to the key store and deleting them when appropriate.

In addition to the above described generation of keys suitable for public key cryptography i.e. asymmetric keys the key management system can also generate and distribute symmetric keys. Central to this is a function Shared Secret Generator incorporated within KMLS that takes as input such factors as the UserID perhaps the user s hard line or cell phone number a long lived secret known only to the QOOBA Server and other miscellaneous parameters and produces as output the shared secret K. It is important to note that for a given set of inputs the same shared secret will be computed deterministically. Different authenticated entities can request the KMLS to provide them with the appropriate symmetric key by providing the KMLS the applicable input parameters.

Note that depending on the application QOOBA Key Management Logic may make use of one or both of the asymmetric i.e. public key cryptography or symmetric key cryptography capabilities described above. We have now described the key management system including its key generation capabilities and turn our attention to three example applications that make use of these capabilities.

As described earlier for certain applications digital signing using public key cryptography is considered more appropriate than electronic transaction signing. Digital signing is accomplished using the steps described below.

The end user browses in browser window and executes a transaction at a Web Service . The Web Service uses the KMLAPI to make a request for transaction signing with digital signing required. This request is sent over secure back end communication channel to KMLS . The request is then send from KMLS to KMLC via secure channel with an indication that a digital signature is required. The QOOBA transaction signature PIN is optionally generated by the QOOBA Server and sent along with the digital signature request. It should be understood that as described above the PIN could if desired be sent by the QOOBA Server to a QOOBA Window similar to QOOBA Window displayed on the user s smartphone not shown via a persistent connection similar to connection rather than to QOOBA Window displayed on the desktop as shown.

The QOOBA Window shows the user the transaction as usual and optionally requires the user to copy the transaction signature PIN i.e. the electronic signature into the browser window . In parallel the KMLC computes a hash on the transaction HashTran and computes a digital signature using the user s private key Du which was previously stored in memory the result being HashTran Du. This process could happen behind the scenes or by asking the user to agree to sign the transaction. In either case the digital signature Du is applied to the hashed transaction HashTran . The digitally signed hash of the transaction HashTran Du is then sent via secure channel from KMLC to KMLS along with the digital certificate Cert Ds or Cert Dca.

KMLS can optionally perform a validation of the signature by applying the user s public key Pu to the digital signature HashTran Du to obtain HashTran and comparing it to an independently generated HashTran. Whether or not validation is performed the KMLS forwards the signature to KMLAPI via secure channel .

KMLAPI can recompute the hash HashTran and verify the signature using the user s public key Pu included in the digital certificate Cert. Thus the KMLAPI applies the KMLS public key Ps to Cert Ds or the Certificate Authority public key Pca to Cert Dca to recover Pu. It then applies the recovered Pu to HashTran Du to recover HashTran and compares it to an independently generated HashTran to verify the signature.

Note that in the above description the hash is created at KMLC . However it could as easily be created at KMLAPI or KMLS though it is likely that each entity would recompute it to be assured of its authenticity.

In this example the entire transaction comes to the QOOBA Window . If on the other hand a document needs to be signed using this approach then it is possible to extend the functionality to have the KMLC commit the private key and public key to the key stores available on the user s desktop which would make the keys available to other applications e.g. browsers or non browser apps . KMLC would be responsible for deleting the user keys from the key store at the appropriate time.

It frequently happens that data is encrypted and forwarded to the recipient in a store and forward system such as email. For instance regulations require that documents such as financial statements or health records must be sent encrypted if sent as email attachments. Many applications e.g. WinZip and Acrobat Reader have built in password based encryption capabilities. The question then arises as to how the decryption password is sent to the user. One approach is to a priori agree on a shared password. Drawbacks of this approach are that a compromised password can be used to decrypt many documents and it is also difficult to require complex passwords as the user is likely to forget the password. Described below are three approaches of using the QOOBA Key Management system to solve this problem.

A document identified uniquely for instance by a unique DocumentID is encrypted with a key derived from a PIN e.g. an eight character alpha numeric PIN by a Web Service and then sent to a user e.g. via email. For purposes of this discussion a DocumentID is a unique value associated with particular combinations of sender identification recipient identification and document identification. When the user opens the document using some application typically a software application on their desktop e.g. WinZip and Acrobat Reader the program sends a signal to the Web Service indicating that the user is attempting to read the particular document. Although the application could be the browser for purposes of this discussion as shown in it is assumed to be other desktop software.

The Web Service retrieves the PIN with which that document referenced by DocumentID was initially encrypted and then uses KMLAPI to send the PIN to the QOOBA server . The QOOBA server using KMLS forwards the PIN to KMLC and the PIN is then displayed to the user within the QOOBA Window .

The user copies the PIN into the application and decryption proceeds as normal. It should be observed that in general no changes to the application are required. The ability to trigger a message to the Web Service when opened is functionality that is already built into many applications e.g. Adobe Reader .

One drawback of the above approach is that the Web Service has to maintain a list of DocumentIDs and PINs. One way to solve this problem is to have the key with which each document is encrypted be the result of a function which takes as input the DocumentID and a long term secret known only to the Web Service . This way the key can be generated dynamically after the user attempts to open the document as described in Approach .

A drawback of the above is that there is an assumption that the Web Service is available and on line when the document is opened. As some of the systems that generate and distribute documents are back end batch systems this assumption may not always be applicable. The QOOBA Key Management shared secret generation capability can be used to solve the problem as follows.

The Web Service sends the QOOBA Server either one at a time or more likely in a batch file the DocumentIDs it wants to encrypt. For purposes of this discussion it will be assumed that the file contains envelope information such as sender and recipient IDs. KMLS uses the Shared Secret Generator described above to compute encryption keys for each DocumentID. For example key K for one DocumentID K for another DocumentID K for another DocumentID etc. These keys are then returned by the KMLS to Web Service . The Web Service then encrypts each respective documents with the applicable key and sends the encrypted document e.g. via email to the respective applicable users.

The applicable user uses the other desktop software to open the document which triggers a request for a key directly to the QOOBA Server over a secure web connection which is another communication channel. It should be noted that this is a direct connection from the non browser software to the QOOBA Server and not through QOOBA Window .

This action results in the KMLS using the Shared Secret Generator to recompute the applicable encryption key e.g. K K K etc. The applicable key is then sent to KMLC and shown to the user in QOOBA Window for copying into the Non Browser Window as described earlier.

While we have described the above using a non browser software e.g. Acrobat Reader as our example the same functionality can be used for browser based web applications.

One time passwords OTPs and Transaction Authentication token authenticators e.g. hardware software smartphone apps etc. all require a key which is stored in the token and is also stored at the back end system. Managing these keys which are commonly referred to as seeds introduces costs and complexity. The QOOBA Key Management System can be used to greatly simplify this process.

For purposes of this discussion it is assumed that a token authenticator not shown is implemented as hardware software or as a mobile phone app. The token starts in an inactive state with no seed present or a seed refresh is required . A request is made either directly within the QOOBA Window by the user or directly from the token to the QOOBA Server or to an external Web Service requesting a seeding event. Some unique identifier identifying the UserID is provided to the QOOBA Server .

The KMLS within the QOOBA Server uses the unique UserID and other information including the long term secret known only to KMLS as inputs into the Shared Secret Generator to generate a unique seed for that user. This seed is sent back to KMLC via the secure channel and then shown to user in the QOOBA Window . The user enters the seed into the software or smartphone app token. We note that the actual seed may be generated by a function that transforms the seed the user enters. It will be recognized that for hardware this will only work if the token has a keypad which most transaction authenticators do indeed have.

As a variant of the above observe that the transaction authenticator can be built directly into the QOOBA Window as part of the functionality. While at first blush the rationale for this may not be obvious compatibility with existing systems such as EMV CAP provides the rationale for this approach. This on demand seeding of the transaction authenticators vastly simplifies the costs of provisioning.

