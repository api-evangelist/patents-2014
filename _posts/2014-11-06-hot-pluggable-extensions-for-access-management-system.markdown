---

title: Hot pluggable extensions for access management system
abstract: Embodiments described herein relate to extending the functionality of one or more access management servers, using plug-in files which may be uploaded while the servers are running. The plug-in files may be discovered in both the plug-in file's own class path and the server's class path, and then may be used in the server's authentication and other operations. In certain embodiments, the server's class path need not be modified during this process, and the server need not be shut down or restarted. Certain embodiments may implement a parallel class loader. Custom plug-in file code may be loaded by the parallel class loader, and the parallel class loader is started a container class loader may be made the parent of the parallel class loader.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09253265&OS=09253265&RS=09253265
owner: ORACLE INTERNATIONAL CORPORATION
number: 09253265
owner_city: Redwood Shores
owner_country: US
publication_date: 20141106
---
This application claims priority under 35 U.S.C. 120 as a continuation of U.S. application Ser. No. 13 674 758 filed Nov. 12 2012 titled HOT PLUGGABLE EXTENSION FOR ACCESS MANAGEMENT SYSTEM which claims priority under 35 U.S.C. 119 e to U.S. Provisional Patent Application Ser. No. 61 650 586 titled HOT PLUGGABLE EXTENSIONS FOR ACCESS MANAGEMENT SYSTEM filed May 23 2012 the entire contents of which are incorporated by reference herein.

The invention relates generally to secured computing and more generally to access management for computing systems.

Modern businesses rely on a variety of applications and systems that control and generate information that is critical to business operations. Different applications often provide different services and information and different users may require access to different levels of information within each system or application. The level of access that users are granted may depend on the role of the user. For example a manager may need access to certain information about employees that report to him but it may be improper for that manager to access the same information about those to whom he reports.

Earlier less sophisticated applications incorporated access management business logic directly into the application code. That is to say each application would require users to have a separate account separate policy logic and separate permissions for example. Furthermore when a user is authenticated by one of these applications this authentication remains unknown to other applications in the enterprise because the fact that authentication with the first application has taken place is not shared. Thus there is no concept of trust between applications using different systems for authentication and access control. Engineers quickly realized that having an access management system for each application in an enterprise was much like having a gas station for each car and determined that authentication and access control would be more efficiently implemented and managed as a shared resource. These shared resources became known as an access management systems.

Access management systems often use policies and other business logic to make a determination regarding whether a particular access request should be granted to a particular resource. Upon making a determination that access should be granted a token is provided to the requestor. This token is like a key that can be used to open a door that guards restricted data.

For example a user may attempt to access a human resources database to gather information about certain employees such as salary information. The user s web browser makes a request to the application which requires authentication. If the web browser does not have a token the user is asked to log in to the access management system. When the user is authenticated the user s browser receives a cookie that represents a token that may be used to access the human resources application.

An access management system may provide single sign on authentication authorization and auditing features. Some releases of access management systems have a specific set of features that include authentication modules authorization conditions etc. These features are shipped with the access management system software out of the box. However users of access management system software often desire features beyond those that are shipped with the access management system software. These users may desire customized authentication or authorization modules that are not shipped with the access management system software for example.

Typically while an access management system server is up and running it is desirable to leave it up and running Access management systems are supposed to be highly available. It is undesirable to take down the live access management system server for any reason. The undesirability of shutting down such a server even temporarily makes it inopportune to perform tasks such as access management system software updates that would typically require the server to be shut down at least temporarily.

In the following description for the purposes of explanation specific details are set forth in order to provide a thorough understanding of embodiments of the invention. However it will be apparent that the invention may be practiced without these specific details.

Users desire a hook by which they can plug in their own authentication modules or other kinds of modules into an existing server product while that server is running Users further want to be able to plug in a JAVA jar file in that server without requiring the server to be taken down or deactivated i.e. a hot plug in . Embodiments of the invention allow a plug in jar file which contains the code necessary for extending the functionality of an access management server to be uploaded while the server is still running The foreign plug in jar file is added in a class path of its own. The server subsequently recognizes the additional component even though the plug in jar file is not in the server s class path. The plug in jar file is discovered in both the plug in jar file s class path and the server s class path and is then able to be used in the server s authentication and other operations. In one embodiment of the invention the server s class path is not modified during this process and consequently the server does not need to be shut down or restarted which otherwise would be required in order to cause a server to recognize at run time a modified class path.

According to one embodiment of the invention changes are made to the class loading pattern of the JAVA Virtual Machine JVM . The class loading pattern determines how the classes are loaded. Whenever the JVM starts the JVM s own class loader component loads the classes. Certain embodiments of the invention implement a parallel class loader. Custom plug in jar file code is loaded by the parallel class loader. When the parallel class loader is started a container class loader is made the parent of the parallel class loader. Because the custom plug in jar file is loaded in a parallel system in the JVM the other classes at that point are still unaware of the classes within that plug in jar file. However because embodiments of the invention cause the container class loader to become a super class of the parallel class loader a connection can be made from the parallel class loader to the parent container class loader. Consequently components loaded by the parallel class loader become recognized by the parent container class loader.

Users of access management system servers desire to be able to add plug ins or server extensions to those servers. Users further desire to be able to use such plug ins to create features additional to those that came shipped out of the box with the access management system software. Users further desire to be able to build such features and workflows using modules that came shipped out of the box with the access management system software. Users further desire to be able to add to the access management system server plug ins that act as extension modules to the server. Furthermore users desire to be able to do all of the above without incurring any server downtime. It is desirable for each such plug in to have a state lifecycle that ensures security of the server environment which could be a JAVA Virtual Machine JVM for example. It is desirable for each such plug in to be easily manageable in a clustered environment.

In one embodiment of the invention a clustered environment includes an administration server and one or more managed server nodes. In one embodiment of the invention a shared memory infrastructure enables an event listener model for communication and transfer of code components among the server nodes in the clustered environment. In one embodiment of the invention an Open Services Gateway Initiative OSGI framework implementation dynamically and securely loads and unloads plug in code into the server environment which as discussed above may be a JVM. The OSGI framework is a module system and service platform for the JAVA programming language. The OSGI framework implements a complete and dynamic component model which typically does not exist in standalone JVM environments. Applications or components coming in the form of bundles for deployment can be remotely installed started stopped updated and uninstalled without requiring a reboot. Application life cycle management start stop install etc. can be performed via application programming interfaces that allow for the remote downloading of management policies. A service registry allows bundles to detect the addition of new services or the removal of services and adapt accordingly.

In cases in which the server environment is a JVM the plug in code may take the form of a JAVA jar file. According to an embodiment of the invention in order to accomplish the dynamic and secure loading and unloading of JAVA jar file plug ins the OSGI framework implementation includes a separate class loader per jar file plug in.

Certain embodiments of the invention include an extensibility framework that enables access management system server users to write their own customized server features as plug ins. The framework further enables these users to plug those customized plug ins into the server. It is desirable to manage the life cycle of these customized plug ins. Therefore certain embodiments of the invention enable customized plug ins such as customized authentication modules to be plugged in to the access management system. Certain embodiments of the invention enable the access management system to load or add such plug ins into the system and to use those plug ins without requiring the access management system to be restarted. Certain embodiments of the invention define and use startup parameters or other configuration data for such plug ins. Certain embodiments of the invention enable such configuration data to be pushed into a configuration store or pulled from a configuration store. Certain embodiments of the invention propagate plug in jar files from a single administrative server to each one of a plurality of access management system servers in a server cluster all without incurring any server downtime. Certain embodiments of the invention maintain a complete state lifecycle of each such access management server. Certain embodiments of the invention enable data representing such lifecycles to be propagated from the access management servers to the administrative server.

In one embodiment of the invention a custom class loading technique is used to dynamically load and activate customized plug in jar files on each of access management servers A N. In one embodiment of the invention this custom class loading technique is implemented using an OSGI framework. A default activator may be provided as a part of a lifecycle management framework for each of access management servers A N.

In one embodiment of the invention before a plug in is deemed to be usable on one of access management servers A N that plug in undergoes a series of tests or checks. Each test or check involves a condition. Unless the plug in satisfies the condition the plug in does not pass the test or check that involves that condition. In one embodiment of the invention if a plug in fails any of the tests of checks in the series then the plug in is not deemed to be usable and is not used.

In one embodiment of the invention the series of tests or checks involves a series of conditions as follows. The first condition requires that the plug in has been validated for security risks and compatibility issues. The second condition requires that the plug in is present on all of access management servers A N. In one embodiment of the invention a plug in becomes present on access management servers A N through the distribution of that plug in from administrative server . The third condition requires that the plug in has been loaded or activated on all of access managements servers A N after being distributed to those access management servers A N.

Traditionally a container class loader of the JVM was the only class loader. However in one embodiment of the invention the container class loader is made a parent of a parallel class loader. The parallel class loader loads classes in parallel to the container class loader. The parallel class loader does not need to be restarted as its parent is the container class loader. The parallel class loader is started with the container class loader as its parent. After the parallel class loader has loaded the desired classes from a customized plug in jar file the parallel class loader is instructed to overlay itself on its parent.

In one embodiment of the invention the parallel class loader runs concurrently with the parent container class loader. The parallel class loader can load jar files on the fly. When the parallel class loader does so the parallel class loader becomes a part of the parent container class loader so that the loaded classes can be introduced to other classes used by access management servers A N. Once the parallel class loader loads the classes the parallel class loader is made a child of the parent container class loader.

In one embodiment of the invention the parallel class loader initially starts running from the parent class loader but has the ability to run separately and in parallel with the parent class loader. Once the parallel class loader has finished loading all of the classes it hands control back to the parent container class loader. The parallel class loader essentially gives control back to the parent container class loader and becomes part of the parent container class loader itself.

Afterwards if another plug in needs to be added the parallel class loader can once again be run separately and in parallel with the parent container class loader. After the parallel class loader has finished loading classes the parallel class loader once again becomes a part of the parent container class loader.

In one embodiment of the invention after the parallel class loader has been made a child of the parent container class loader a second parallel class loader is executed to load a second set of customized classes that extend the server logic. In response to a determination that the loading of the second customized set of classes has been completed the second parallel class loader is also made a child of the container class loader.

In one embodiment of the invention each plug in has a life cycle. Commands which influence a plug in s lifecycle include upload distribute activate deactivate and remove. Additionally in one embodiment of the invention each plug in has a certain state at any given time the states collectively describe the plug in s life cycle. Commands may causes a plug in to leave one state and enter a different state in the plug in s life cycle.

Uploaded state serves as the starting point for the plug in life cycle. Uploaded state is reached as a result of the successful invocation and performance of the upload command. When a plug in is in uploaded state it means that the plug in jar file is present within a plug in repository which may reside within administrative server . The remove and distribute commands may be issued to plug ins that are in uploaded state .

When a plug in is in distributed state it means that instances of the plug in jar file are present and available on all of access management servers A N i.e. the plug in has been distributed from administrative server to all of access management servers A N . Distributed state can be reached from uploaded state after a successful performance of the distribute command or from distribute failed state after a successful performance of the distribute command. The activate and remove commands may be issued to plug ins that are in distributed state .

When a plug in is in distribute failed state it means that an issued distribute command has failed relative to one or more instances of that plug in on access management servers A N. Distribute failed state can be reached from uploaded state . The remove and distribute commands may be issued to plug ins that are in distribute failed state .

When a plug in is in activated state it means that instances of the plug in have been loaded into the JVM of all of access management servers A N. In one embodiment of the invention each plug in is associated with a separate class loader that is specific to that plug in. In one embodiment of the invention plug ins are loaded by the OSGI framework implementation. A plug in that is in activated state is available as an extension for use on the access management servers on which it resides. Activated state can be reached from distributed state after a successful performance of the activate command. Activated state also can be reached from deactivated state after a successful performance of the activate command. Activated state also can be reached from activate failed state after a successful performance of the activate command. In one embodiment of the invention while a plug in is in activated state that plug in cannot be removed because that plug in might be in use in some extended module. Therefore before the plug in can be removed the plug in is deactivated. After deactivation a removal attempt triggers checks to determine whether the plug in is being used by any extended modules and removal is allowed to proceed only if the plug in is not being so used. Therefore the deactivate command can be issued relative to a plug in that is in activated state .

When a plug in is in activate failed state it means that an issued activate command has failed relative to one or more instances of that plug in on access management servers A N. Activate failed state can be reached from distributed state . The remove and activate commands may be issued to plug ins that are in activate failed state .

When a plug in is in deactivated state it means that the plug in has been unloaded from the JVM of all of access management servers A N. The OSGI framework implementation maintained class loader that specifically corresponds to that plug in is used to unload the plug in. Although deactivated state is somewhat similar to distributed state in deactivated state OSGI implementations may contain the plug in code in their caches because the plug in has already been activated at least once. Deactivated state can be reached from activated state after successful performance of the deactivate command. Deactivated state can be reached from deactivate failed state after successful performance of the deactivate command. A plug in in the deactivated state can be removed or activated again so the activate and remove commands may be issued to plug ins that are in deactivated state .

When a plug in is in deactivate failed state it means that an issued deactivate command has failed relative to one or more instances of that plug in on access management servers A N. Deactivate failed state can be reached from activated state . The deactivate command may be issued to plug ins that are in deactivate failed state because the plug in may be in an inconsistent state and ought to be deactivated before it is removed.

When a plug in is in removed state it means that the plug in is present only in a backup directory of administration server and has been removed from all of access management servers A N. Removed state is the end state in a plug in s lifecycle and can be reached by a successful performance of the remove command from any of the other states except for activated state and deactivate failed state . In one embodiment of the invention no further commands are permitted relative to a plug in that is in removed state .

When a plug in is in remove failed state it means that an issued remove command has failed relative to one or more instances of that plug in on access management servers A N. Remove failed state can be reached by an unsuccessful performance of the remove command from any of the other states except for activated state and deactivate failed state . The remove action can be performed relative to plug ins that are in remove failed state .

The upload command imports a plug in jar file to the system specifically in one embodiment of the invention administrative server and validates that file. The upload command causes the plug in to be checked for compatibility versioning and potential security risks. After successful validation of the plug in a master entry for the plug in is made in the configuration store. The state of the plug in indicates uploaded state at this point. This task takes place on administrative server . Access management servers A N are unaffected. No command messages are sent to or by access management servers A N using the messaging mechanism discussed below. The only resulting state for the upload command is uploaded state . Any failure in validation or importing of the plug in prevents the creation of an entry in the configuration store so no failure state is required.

The distribute command can be invoked relative to a plug in if that plug in is in uploaded state or distribute failed state . The plug in code is distributed to access management servers A N using a distribution mechanism discussed below. The distribute command does not cause any messages to be sent from administrative server to any of access management servers A N. Access management servers A N in response to the distribute command copy the plug in code using the distribution mechanism discussed below and return to administrative server either a distribute success or distribute failed message depending on whether the copying was successful or not. After administrative server receives distribute success messages from all of the operating access management servers A N in cluster administrative server updates the status of the plug in to distributed state in the configuration store. If even one of access management servers A N returns a distribute failed message administrative server sets the status of the plug in to be distribute failed state .

The activate command can be invoked relative to a plug in if that plug in is in distributed state activate failed state or deactivated state . In response to this command administrative server check the current operational status of access management server A N in cluster . In one embodiment of the invention for this command to complete successfully at least one such access management server needs to be currently operational up and running Administrative server sends an activate command to access management servers A N using the messaging mechanism discussed below. Access management servers A N then load the plug in code into their JVMs using a separate class loader for each plug in using the OSGI framework implementation. Upon successful loading and activation of the plug in an access management server sends an activate success message to administrative server . After administrative server receives activate success messages from all of the operating access management servers A N in cluster administrative server updates the status of the plug in to activated state in the configuration store. If even one of access management servers A N returns an activate failed message administrative server sets the status of the plug in to be activate failed state .

The deactivate command can be invoked relative to a plug in if that plug in is in activated state or deactivate failed state . In response to this command administrative server check whether the plug in is currently being used by any extension module. If administrative server does not find any such usage then administrative server sends a deactivate message to each of access management servers A N. In response to receiving this message access management servers A N unload the plug in from their respective JVMs using the class loader corresponding specifically to that plug in. Again the plug in specific class loader is maintained by the OSGI framework implementation. Upon successful unloading of the plug in an access management server sends a deactivate success message to administrative server . After administrative server receives deactivate success messages from all of the operating access management servers A N in cluster administrative server updates the status of the plug in to deactivated state in the configuration store. If even one of access management servers A N returns a deactivate failed message administrative server sets the status of the plug in to be deactivate failed state .

The remove command can be invoked relative to a plug in if that plug in is in any state other than activated state or deactivate failed state . This command causes the target plug in code to be removed from all of access management servers A N and administrative server . The code can be stored elsewhere for audit purposes. Administrative server sends a remove message to each of access management servers A N. In response to receiving this message access management servers A N remove the plug in from their storage subsystems. Upon successful removal of the plug in code an access management server sends a remove success message to administrative server . After administrative server receives remove success messages from all of the operating access management servers A N in cluster administrative server then removes the plug in code from its own storage subsystem potentially storing that code elsewhere e.g. a backup drive and updates the status of the plug in to removed state in the configuration store. If even one of access management servers A N returns a remove failed message administrative server sets the status of the plug in to be remove failed state .

In one embodiment of the invention the commands are issued via calls to an application programming interface. In one embodiment of the invention a plug in s current state or status and the command most recently issued to the plug in are stored in a configuration store. In one embodiment of the invention only administrative server is permitted to change data stored in the configuration store. For example in one embodiment of the invention only administrative server is permitted to issue commands to access management servers A N and only administrative server is permitted to change the status of any plug in in the configuration store. In one embodiment of the invention administrative server maintains a runtime status of each plug in for each of access management servers A N in between state transitions. For example in between the time that administrative server issues a command and the time that administrative server updates a state change in the configuration store administrative server may maintain a runtime status of the plug in to which the command was issued until administrative server updates the state for that plug in in the configuration store.

In one embodiment of the invention administrative server performs the operations of various ones of blocks relative to each one of access managements servers A N that is currently operational. These operations may be performed concurrently relative to access management servers A N. Thus operations that involve administrative server sending a command to a plug in may involve administrative server sending that command concurrently to each instance of that plug in on all of access management servers A N that are currently operational.

In block administrative server sends a message specifying a command e.g. upload distribute activate deactivate or remove to an instance of the particular plug in on a particular one of one of access management servers A N. In block upon sending the message administrative server starts a configurable timer that is specific to the particular access management server to which the message was sent. In block administrative server determines whether a reply has been received from the particular access management server. If a reply has been received then control passes to block . Otherwise control passes to block .

In block administrative server determines whether the timer for the particular access management server has expired. If the timer has expired then control passes to block . Otherwise control passes back to block .

In block administrative server cancels the timer for the particular access management server. In block administrative server determines whether the reply indicates success or failure of the command relative to that instance of the particular plug in. If the reply indicates success then control passes to block . Alternatively if the reply indicates failure the control passes to block .

In block administrative server updates in the configuration store a runtime state entry corresponding to the instance of the particular plug in on the particular access management server. Administrative server updates a runtime status indicated in that entry to reflect a new state to which the successful performance of the command caused the instance of the particular plug in on the particular access management server to transition. For example if the command was distribute then administrative server changes the runtime status of the instance of the particular plug in on the particular access management server to distributed. Control passes to block .

Alternatively in block administrative server updates in the configuration store a runtime state entry corresponding to the instance of the particular plug in on the particular access management server. Administrative server updates a runtime status indicated in that entry to reflect a new state to which the failure to perform the command caused the instance of particular plug in on the particular access management server to transition. For example if the command was distribute then administrative server changes the runtime status of the instance of the particular plug in on the particular access management server to distribute failed. Control passes to block .

In block administrative server determines whether all of the runtime entries for all instances of the particular plug in on each of currently operational access management servers A N indicate a transition due to success or failure from their previous runtime states. If all of the timers on all of currently operational access management servers all of the runtime entries for all instances of the particular plug in on each of access management servers A N indicate a transition due to success or failure from their previous runtime states then control passes to block . Otherwise control passes back to block while administrative server waits for one or more runtime entries to indicate a transition from previous runtime states.

In block administrative server determines whether all of the runtime states for all instances of the particular plug in on all of currently operational access management servers A N indicate a successful transition. If all of the runtime states for all instances of the particular plug in indicate a successful transition then control passes to block . Otherwise technique terminates.

In block administrative server updates in the configuration store a master entry for the particular plug in including all instances thereof . Administrative server updates the master entry to indicate a new state resulting from the successful transition from the previous state. In block administrative server clears all of the runtime entries for all of the particular plug ins. Technique then terminates.

In one embodiment of the invention the configuration store and a plug in repository which also resides on administrative server in one embodiment are synchronized whenever a previously non operational one of access management servers A N becomes operational within cluster . That particular access management server picks up from the master entries in configuration store the statuses of the plug ins residing on that particular access management server.

In one embodiment of the invention whenever a new one of access management servers A N starts up all plug ins having a status of activated in the master entries stored in the configuration store are loaded into the JVM on that access management server using the OSGI framework. Therefore technique functions properly even when one or more of access management servers A N are down and even if a new access management server is started up within cluster .

In one embodiment of the invention a messaging mechanism and a distribution mechanism use a shared memory location called a channel. Each channel is identified by a unique name. A channel may be shared by multiple access management servers A N for performing various actions. In one embodiment of the invention events and actions that can be performed on a channel include write update read remove and obtain lock a distributed read write lock . In one embodiment of the invention event listeners and action listeners can be registered to a channel for the following actions and events write update read and remove. In one embodiment of the invention listeners are notified or triggered whenever a corresponding action or event occurs.

In one embodiment of the invention the distribution mechanism makes use of a single channel called the distribution channel for distributing plug in jar files to access management servers A N. These servers register write update event listeners for the distribution channel. Administrative server obtains a lock on the channel and writes to the channel with the plug in jar file. Each of access management servers A N is notified of the write update event and each such server reads the channel to copy the plug in jar file to a specified location called the plug in repository. Upon successfully copying the plug in jar file access management servers A N use the messaging mechanism discussed below to send a message to administrative server A updating the plug in state for those servers to distributed state . After administrative server A determines that all of access management servers A N have indicated that they are in distributed state administrative server A updates the status of the plug in in the master entry in the configuration store to distributed state .

In one embodiment of the invention one plug in jar file is distributed at a time. In such an embodiment the plug in jar file is not removed from the channel. The channel is updated with a new plug in jar file for the next distribute command.

In one embodiment of the invention a messaging mechanism uses N 1 channels for sending and receiving messages where N is the quantity of access management servers A N.

Each server in cluster registers a write update event listener for that server s own channel. That channel is called the node channel. Each node channel maintains a queue data structure for messages written to that node channel. When a message generating server tries to send a message to a message receiving server the message generating server first obtains a lock on the node channel of the message receiving node and writes the message to that node channel afterward. The message generating server obtains a lock on its own node channel and removes the queue of messages therein to process those messages. If a notification for a message in the queue arrives after the queue has been removed such that the queue for the node channel is empty then the notification is ignored since the message has already been processed. This phenomenon may occur when more than one server attempts to write to a message receiving server s node channel in sufficiently close succession. Removing and processing an entire queue at a time rather than one message per notification ensures faster processing of the messages. In one embodiment of the invention each message contains details about the sender and therefore can be tracked without waiting for its corresponding notification to arrive at the receiver s end. This feature may help to clear queues in case of lost event notifications.

In one embodiment of the invention administrative server uses the messaging mechanism to send command messages to access management servers A N. Access management servers A N perform the command actions specified in the messages upon receiving those messages. After completing a command action access management servers A N send back a command status message to administrative server . Administrative server maintains the status of each such server for the current command for a particular plug in. Upon receiving a command status message from one of access management servers A N administrative server updates the runtime plug in state in the runtime entry for that access management server.

Input may include input from a web application such as application or an agent such as agent in an embodiment. Agent may be configured to intercept access requests from a user such as an access request issued from a user s web browser software or other software or hardware. These requests may be directed in whole or in part to access management system in the form of input .

In an embodiment access management system includes an I O logic configured to receive input from I O interface . I O logic may be configured to store input or information associated with input in non transitory media such as volatile or non volatile storage media. For example I O logic may include logging logic. I O logic is communicatively coupled to service management logic metadata repository normalization logic and component management logic in an embodiment.

In an embodiment service management logic . Service management logic manages service entities associated with a service entities layer. These service entities may include protocol specific listeners that listen for requests of a particular type for example. When a request is received by a service entity that request is passed to normalization logic in an embodiment.

In an embodiment access management system includes normalization logic . Normalization logic implements the features discussed above with respect to a protocol binding layer. Normalization logic receives protocol specific requests from service management logic in an embodiment. Normalization logic then normalizes the request by providing only non protocol specific information to component management logic. In addition normalization logic may provide metadata from metadata repository to a component management system in order to describe the response details expected from component management engine in response to the normalized request. As used herein the term normalized request is a request that is different than the original request on which the normalized request is based. Metadata repository is used to store metadata and other data in an embodiment.

In an embodiment access management system includes component management logic . Component management system orchestrates the performance of all activities associated with incoming requests. Specifically component management system determines based on the information provided by normalization logic which functional components are required to satisfy a request and directs those components to perform their respective functions. Additional details pertaining to an example of access management system are disclosed in U.S. patent application Ser. No. 13 464 906 titled Access Management Architecture which is incorporated by reference herein for all purposes.

As shown system environment includes one or more client computing devices communicatively coupled with a server computer via a network . In one set of embodiments client computing devices may be configured to run one or more components of a graphical interface described above.

Client computing devices may be general purpose personal computers including for example personal computers and or laptop computers running various versions of Microsoft Windows and or Apple Macintosh operating systems cell phones or PDAs running software such as Microsoft Windows Mobile and being Internet e mail SMS Blackberry and or other communication protocol enabled and or workstation computers running any of a variety of commercially available UNIX or UNIX like operating systems including without limitation the variety of GNU Linux operating systems . Alternatively client computing devices and may be any other electronic devices capable of communicating over a network e.g. network described below with server computer . Although system environment is shown with four client computing devices and one server computer any number of client computing devices and server computers may be supported.

Server computer may be a general purpose computer specialized server computer including e.g. a LINUX server UNIX server mid range server mainframe computer rack mounted server etc. server farm server cluster or any other appropriate arrangement and or combination. Server computer may run an operating system including any of those discussed above as well as any commercially available server operating system. Server computer may also run any of a variety of server applications and or mid tier applications including web servers JAVA virtual machines application servers database servers and the like. In various embodiments server computer is adapted to run one or more Web services or software applications that provide the diagnostics functionality described above. For example server computer may be configured to execute the various methods described in the various flowcharts described above.

As shown client computing devices and server computer are communicatively coupled via network . Network may be any type of network that can support data communications using any of a variety of commercially available protocols including without limitation TCP IP SNA IPX AppleTalk and the like. Merely by way of example network may be a local area network LAN such as an Ethernet network a Token Ring network and or the like a wide area network a virtual network including without limitation a virtual private network VPN the Internet an intranet an extranet a public switched telephone network PSTN an infrared network a wireless network e.g. a network operating under any of the IEEE 802.11 suite of protocols the Bluetooth protocol known in the art and or any other wireless protocol and or any combination of these and or other networks. In various embodiments the client computing devices and server computer are able to access the database through the network . In certain embodiments the client computing devices and server computer each has its own database.

System environment may also include one or more databases . Database may correspond to an instance of integration repository as well as any other type of database or data storage component described in this disclosure. Database may reside in a variety of locations. By way of example database may reside on a storage medium local to and or resident in one or more of the computers . Alternatively database may be remote from any or all of the computers and or in communication e.g. via network with one or more of these. In one set of embodiments database may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers may be stored locally on the respective computer and or remotely on database as appropriate. In one set of embodiments database is a relational database such as Oracle 11g available from Oracle Corporation that is adapted to store update and retrieve data in response to SQL formatted commands. In various embodiments database stores data that is used for providing diagnostic capabilities as described above.

Bus subsystem provides a mechanism for letting the various components and subsystems of computer system communicate with each other as intended. Although bus subsystem is shown schematically as a single bus alternative embodiments of the bus subsystem may utilize multiple busses.

Network interface subsystem provides an interface to other computer systems networks and portals. Network interface subsystem serves as an interface for receiving data from and transmitting data to other systems from computer system .

User interface input devices may include a keyboard pointing devices such as a mouse trackball touchpad or graphics tablet a scanner a barcode scanner a touch screen incorporated into the display audio input devices such as voice recognition systems microphones and other types of input devices. In general use of the term input device is intended to include all possible types of devices and mechanisms for inputting information to computer system .

User interface output devices may include a display subsystem a printer a fax machine or non visual displays such as audio output devices etc. The display subsystem may be a cathode ray tube CRT a flat panel device such as a liquid crystal display LCD or a projection device. In general use of the term output device is intended to include all possible types of devices and mechanisms for outputting information from computer system .

Storage subsystem provides a non transitory computer readable storage medium for storing the basic programming and data constructs that provide the functionality of the present invention. Software programs code modules instructions that when executed by a processor provide the functionality of the present invention may be stored in storage subsystem . These software modules or instructions may be executed by processor s . Storage subsystem may also provide a repository for storing data used in accordance with the present invention. Storage subsystem may comprise memory subsystem and file disk storage subsystem .

Memory subsystem may include a number of memories including a main random access memory RAM for storage of instructions and data during program execution and a read only memory ROM in which fixed instructions are stored. File storage subsystem provides persistent non volatile storage for program and data files and may include a hard disk drive a floppy disk drive along with associated removable media a Compact Disk Read Only Memory CD ROM drive an optical drive removable media cartridges and other like storage media.

Computer system can be of various types including a personal computer a portable computer a workstation a network computer a mainframe a kiosk a server or any other data processing system. Due to the ever changing nature of computers and networks the description of computer system depicted in is intended only as a specific example for purposes of illustrating the preferred embodiment of the computer system. Many other configurations having more or fewer components than the system depicted in are possible.

