---

title: Human machine interface (HMI) system having elements with alarm border animation
abstract: A system manages human machine interface (HMI) applications for industrial control and automation. Software instructions stored on a tangible, non-transitory media and executable by a processor receive data indicative of a manufacturing/process control system being monitored and display a user interface indicative of a status of the manufacturing/process control system being monitored wherein the status is based on the received data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09612588&OS=09612588&RS=09612588
owner: Invensys Systems, Inc.
number: 09612588
owner_city: Foxboro
owner_country: US
publication_date: 20140305
---
This application is a nonprovisional patent application which claims the benefit of U.S. Provisional Patent Application Ser. No. 61 890 603 filed Oct. 14 2013 the entire disclosure of which is incorporated by reference.

The present invention generally relates of the fields of networked computerized industrial control automation systems and networked computerized systems utilized to monitor log and display relevant manufacturing production events and associated data and supervisory level control and manufacturing information systems. Such systems generally execute above a regulatory control layer in a process control system to provide guidance to lower level control elements such as by way of example programmable logic controllers or distributed control systems DCSs . Such systems are also employed to acquire and manage historical information relating to such processes and their associated output. More particularly the present invention relates to a human machine interface HMI system for a manufacturing and or process control system such as supervisory control and data acquisition SCADA and or manufacturing execution systems MES . Such systems generally execute above outside of a control layer of a manufacturing process control system to record production events and related event data and to provide guidance to lower level control elements such as by way of example programmable logic controllers.

Industry increasingly depends upon highly automated data acquisition and control systems to ensure that industrial processes are run efficiently safely and reliably while lowering their overall production costs. Data acquisition begins when a number of sensors measure aspects of an industrial process and periodically report their measurements back to a data collection and control system. Such measurements come in a wide variety of forms. By way of example the measurements produced by a sensor recorder include a temperature a pressure a pH a mass volume flow of material a tallied inventory of packages waiting in a shipping line or a photograph of a room in a factory. Often sophisticated process management and control software examines the incoming data produces status reports and in many cases responds by sending commands to actuators controllers that adjust the operation of at least a portion of the industrial process. The data produced by the sensors also allow an operator to perform a number of supervisory tasks including tailor the process e.g. specify new set points in response to varying external conditions including costs of raw materials detect an inefficient non optimal operating condition and or impending equipment failure and take remedial actions such as move equipment into and out of service as required.

Typical industrial processes are extremely complex and receive substantially greater volumes of information than any human could possibly digest in its raw form. By way of example it is not unheard of to have thousands of sensors and control elements e.g. valve actuators monitoring controlling aspects of a multi stage process within an industrial plant. These sensors are of varied type and report on varied characteristics of the process. Their outputs are similarly varied in the meaning of their measurements in the amount of data sent for each measurement and in the frequency of their measurements. As regards the latter for accuracy and to enable quick response some of these sensors control elements take one or more measurements every second. Multiplying a single sensor control element by thousands of sensors control elements a typical industrial control environment results in an overwhelming volume of data flowing into the manufacturing information and process control system. Sophisticated data management and process visualization techniques have been developed to handle the large volumes of data generated by such system.

Highly advanced human machine interface process visualization systems exist today that are linked to data sources such as the above described sensors and controllers. Such systems acquire and digest e.g. filter the process data described above. The digested process data in turn drives a graphical display rendered by a human machine interface. Examples of such systems are the well known Wonderware INTOUCH.RTM. human machine interface HMI software system for visualizing and controlling a wide variety of industrial processes and the ArchestrA e.g. the application server or AppServer for INTOUCH comprehensive automation and information software open architecture designed to integrate and extend the life of legacy systems by leveraging the latest open industry standards and software technologies.

An INTOUCH HMI process visualization application includes a set of graphical views of a particular process. Each view in turn comprises one or more graphical elements. The graphical elements are animated in the sense that their display state changes over time in response to associated linked data sources. For example a view of a refining process potentially includes a tank graphical element. The tank graphical element has a visual indicator showing the level of a liquid contained within the tank and the level indicator of the graphical element rises and falls in response to a stream of data supplied by a tank level sensor indicative of the liquid level within the tank. Animated graphical images driven by constantly changing process data values within data streams of which the tank level indicator is only one example are considerably easier for a human observer to comprehend than a stream of numbers. For this reason process visualization systems such as INTOUCH have become components of supervisory process control and manufacturing information systems.

The INTOUCH HMI empowers users to quickly and easily develop custom graphical views of their processes. Users can develop graphics with a variety of tools in WONDERWARE s WindowMaker graphical view editing program which includes standard graphical components displays animations bitmap images ActiveX controls a graphics library containing thousands of preconfigured industrial images SmartSymbol technology tag definitions I O configuration binding scripts alarm and history configurations.

Typically users use INTOUCH to develop supervisory control and data acquisition systems applications and HMI applications. Users use INTOUCH to develop their custom applications to visualize plant data and status in a real time manner by interfacing HMI software to sources of plant equipment such as PLCs. To develop INTOUCH applications users need to define real time data connectivity to PLC tag database graphics development graphics animation and alarms definition.

HMI applications have been used for supervisory controls panels and controls. HMI applications are developed using HMI application development utilities that allow users to create a specific configuration referred to herein as an HMI application for their own specific need application. Therefore HMI development utility software is designed and developed by a software vendor. Thereafter the HMI development utility is used by end users to render a potentially vast number of HMI applications including views and associated functionality for particularized needs of specific process automation and manufacturing information installations.

While it is important to innovate and provide new technological offerings it is also important to provide a migration path from existing technologies to the new offerings. HMI technologies and the systems within which they operate are constantly evolving. Typical manufacturing automation HMI application definitions consist of a number of configured elements including displays tags I O binding PLC connections animations scripts alarms and events history configuration. Therefore evolution of HMI technologies presents a potential problem for users that have created a large number of HMI applications using existing technologies.

To encourage users to adopt newer technologies HMI utility developers have provided migration paths that enable users to leverage their previously created HMI applications in systems that adopt newer platforms. The general approach of such developers is to provide tools that extract and convert the configured information of the existing HMI applications from existing HMI applications into HMI applications that will run on the new technological platforms.

An exemplary environment within which supervisory control and data acquisition SCADA and manufacturing execution system MES are potentially implemented is described for example in Krajewski III et al. U.S. patent application Ser. No. 10 943 301 which corresponds to US App. Pub. 2006 0056285 A1 and Krajewski et al. U.S. patent application Ser. No. 11 549 801 which corresponds to US App. Pub. 2008 0189637 A1 the contents of which are incorporated herein by reference in their entirety including any references contained therein. The MES is by way of example the Wonderware Operations Software formally known as Factelligence which provides a scalable and configurable Manufacturing Execution System MES designed to help manufacturers across a wide range of industries improve their operational efficiency manufacturing responsiveness and brand integrity a product of Invensys Systems Inc. The MES differs from the SCADA component in that it is not generally used to exert supervisory control over a plant manufacturing process. Instead the MES monitors production and records various production manufacturing events and applies known business rules to render decisions governing production operations carried out by the SCADA system. MES systems interface to higher level enterprise resource planning ERP systems.

In one form a system manages human machine interface HMI applications for industrial control and automation. Software instructions stored on a tangible non transitory media and executable by a processor receive data indicative of a manufacturing process control system being monitored and display a user interface indicative of a status of the manufacturing process control system being monitored wherein the status is based on the received data. In addition the instructions display graphic elements as part of the user interface. Each element is associated with and indicative of an alarm status of one or more aspects of the manufacturing process control system being monitored. The instructions are also responsive to user input for configuring a selected graphic element with a border. The border is selectively animated in response to the alarm status associated with the selected graphic element being in an alert condition. The animation indicates that the one or more aspects of the manufacturing process control system associated with the selected graphic element is not at an acceptable value.

In another form software instructions stored on a tangible non transitory media are executable by a processor. In another form a processor executable method is provided.

The following description is based on embodiments of the invention and should not be taken as limiting the invention with regard to alternative embodiments that are not explicitly described herein. By way of example the present invention is incorporated within a supervisory process control and manufacturing information application development and runtime environment wherein individual data sources e.g. process equipment and associated logic are represented by application objects. An example of such system is described in detail in Resnick et al. U.S. patent application Ser. No. 10 179 668 filed on Jun. 24 2002 which corresponds to US App. Pub. 20020198920 for SUPERVISORY PROCESS CONTROL AND MANUFACTURING INFORMATION SYSTEM APPLICATION HAVING A LAYERED ARCHITECTURE the contents of which are incorporated herein by reference in their entirety including the contents and teachings of any references identified contained therein. However as those skilled in the art will appreciate in view of the disclosed exemplary embodiments the present invention is potentially applicable to a variety of alternative supervisory process control and manufacturing information application development and runtime environments.

The disclosure herein is directed primarily to an infrastructure and related methods for centrally managing HMI applications e.g. INTOUCH applications within a supervisory process control and manufacturing information application environment comprising potentially many networked HMI nodes running separate instances of a previously defined HMI application. The disclosure includes a description of an HMI application encapsulated within a reusable HMI application template. Thereafter HMI application objects are instantiated from the HMI application template and installed on a designated networked HMI node.

A second aspect of centrally managing HMI applications disclosed herein relates to propagating changes to symbols making up a portion of the graphics of an HMI application template into a set of HMI application object templates. By way of example a symbol template is globally defined outside the HMI application. The symbol graphics are incorporated into HMI application templates via a reference to the centrally managed symbol template. The use of symbol templates to define symbol graphics for HMI applications facilitates propagating changes using the aforementioned cross reference lists to the symbol templates down to all child symbol templates as well as all HMI application templates that incorporate by reference the changed original and derived child symbol templates. Such relationships and propagation paths are described in US App. Pub. 2008 0189637 A1 with reference to is incorporated herein by reference.

A third aspect of centrally managing HMI applications disclosed herein relates to maintaining and graphically presenting a status for HMI objects in various views e.g. deployment derivation model etc. of the contents of the configuration database via the IDE . Examples of current status include checked in out deployed undeployed and changed. Each of these exemplary statuses enables users to make decisions with regard to distributing instances of an HMI application.

Yet another aspect of the disclosed central management arrangement is the ability of users to edit an existing HMI application definition template from a remotely deployed configuration tool such as an Integrated Development Environment IDE facility.

Referring to a schematic diagram depicts hosting hierarchical relationships of components within an exemplary distributed networked supervisory process control environment. In the exemplary network each of the multiple computing hardware nodes PCs run bootstrap software that operates as the host for subsequently loaded platform objects and a development tool referred to herein as the IDE facility. Thereafter platform object instances are installed on the PCs. Only one platform object can be installed on each PC. The platform objects host and provide services to subsequently installed engine objects. The engines objects in turn potentially operate as hosts to subsequently installed HMI device integration and application objects. The engine objects are distinguished by their differing services hosting capabilities and thus the type of objects they host. For example view engines host HMI object instances while application engines host device integration objects and application objects. The various types of objects mentioned above are described further herein below.

With continued reference to multiple PCs and run an integrated design and development tool IDE . The IDE is utilized by developers to configure and deploy components including application objects of a supervisory process control and manufacturing information system to designated PC nodes attached to an engineering network . The IDE is a utility comprising potentially multiple components from which process control and manufacturing information applications including application objects and engines are defined created and deployed to a variety of platforms engines including for example the application server PC . Developers of a supervisory process control and manufacturing information application through the IDE carry out a wide variety of application design functions including importing new object and template types configuring new templates from existing templates defining new application objects and deploying the application objects to the host application engines e.g. AppEngine1 on the application server PC . The IDE is also where HMI templates incorporating previously developed HMI applications are defined and resulting HMI objects are instantiated and deployed to target PCs having a previously installed view engine e.g. view engines and .

The IDE copies operate upon a set of object templates stored in a configuration database e.g. Galaxy database wherein the names of the defined object templates are maintained in a global name table . The global name table facilitates binding location independent object names to location derived handles facilitating routing messages between objects within the system depicted in . The configuration database stores for a configured application component object data as well as any code or documents associated with the configured objects. The configuration database stores both base object templates and derived templates for the various objects e.g. application engines application objects view engines and HMI objects depicted in . An exemplary visualization HMI application object derivation and instance creation scheme described in US App. Pub. 2008 0189637 A1 with reference to is incorporated herein by reference. In an exemplary embodiment the configuration database comprises a MICROSOFT SQL server.

The contents of the configuration database are accessed via a configuration database engine also known as a galaxy repository. The configuration database engine supports remote multi user access via the IDE copies through graphically presentable check in check out status descriptors for each defined object in the configuration database . The configuration database engine also supports deployment of objects and software from a centralized source to other nodes on the system.

In accordance with an illustrative embodiment a data quality and status behavior definition is stored within the configuration database . From this centralized location a global data distribution mechanism automatically delivers the new version of the definition to all the runtime nodes without further user intervention. The definition specifying animated graphical behaviors in response to data statuses is shared across the entire set of nodes and HMI applications that fall within the scope of the configuration database and is not specific to any individual node or HMI application.

In the illustrative embodiment the configuration database engine is hosted by a configuration database platform . The configuration database platform is generally the same as the other platforms installed on the PCs in the system. However the configuration database platform is assigned a unique status and corresponding name within the system as the platform associated with the single active configuration database . Thus the disclosed system includes a single centrally managed configuration database. In alternative embodiments multiple copies of the contents of the database are maintained e.g. a read only or backup copy of the contents of the database on multiple nodes in the system. In the illustrative embodiment the configuration database platform and the hosted configuration database engine perform the specialized functions of data software distribution maintaining the global name table resolving using the name table globally unique location independent reference strings to location derived handles for message exchange administering security limited access to resources in a multi user environment versioning centralized license management and importing exporting object templates and instances.

The IDE supports a variety of configuration operations involving the configuration database . By way of example engineers utilize the IDE to import new object templates into the configuration database via the configuration database engine configure new object templates and deploy the objects to designated PCs on the engineering network . As noted above multiple copies of the IDE residing on distinct network nodes are capable of accessing and editing the object definitions including HMI application definitions and symbol definitions that are potentially incorporated into the HMI application definitions templates .

In the illustrative example multiple HMI object instances are deployed on multiple hardware nodes PCs and . The HMI object instances described in US App. Pub. 2008 0189637 A1 with reference to is incorporated herein by reference provide a graphical view window representing a current status of a process plant or portion thereof based upon information obtained via device integration and application objects from devices controllers residing on a plant floor network . A single view engine hosts multiple distinct HMI object instances corresponding to various configured process plant views driven by information provided by for example a connected field device or PLC e.g. PLC . In the exemplary embodiment the HMI object instances are hosted by view engines described in US App. Pub. 2008 0189637 A1 with reference to incorporated herein by reference in a multi layered supervisory process control and manufacturing information system architecture. While only a single HMI object instance is shown for each view engine in each view engine is capable of simultaneously hosting multiple HMI object instances.

The hosted relationship between HMI object instances and corresponding view engines facilitate access to certain services supported by the view engines . By way of example the view engines support updating the hosted HMI object instances independently automatic change propagation when corresponding templates are updated . Also the view engines cache on the associated network node the displays associated with the HMI object instances .

Turning to the application server PC on the engineering network in the illustrative embodiment data sources are presented by way of example in the form of application objects . The application objects carry out a variety of functions including representing the status of process equipment and associated application logic. The application objects carry out any of a variety of monitoring control functions while positioned at an application level of the illustrated distributed hierarchical supervisory process control and manufacturing application architecture. Device integration objects and situated at an application level as well in the hierarchy represent data sources on a plant floor network such as PLCs PLC1 smart field devices and associated I O networks e.g. PLC1 network .

The application objects and device integration objects communicate with one another both locally within a single personal computer and through non local communications with objects hosted on personal computers attached to the engineering network .

The application objects are identified by way of example within the global name table maintained by the configuration database e.g. the WONDERWARE Galaxy Repository the contents of which are made available to a developer via for example the IDE and HMI object instances that by way of example incorporate INTOUCH applications and their associated displays. Thus in accordance with an embodiment of the present invention a dynamic graphical view of a plant process in the form of an INTOUCH application is initially created using for example the WINDOWMAKER utility. The entire INTOUCH application is thereafter incorporated into an HMI object template including necessary components for use in the multi leveled application execution environment described herein. The resulting HMI object template is stored maintained managed in the configuration database . Thereafter subsequent derived versions of the base template are maintained as children and retain an inheritance relation with the parent HMI object template. The original and derived templates are available for distribution via the IDE to appropriate nodes on the network containing a previously installed view engine e.g. view engine .

With continued reference to the application server PC executes a multi layered supervisory process control and manufacturing information application comprising a first portion . The application portion includes the application objects and device integration objects PLC1Network and PLC1 . The PLC1Network device integration object facilitates configuring a data access server e.g. OPC DAServer . The PLC1 device integration object operating as an OPC client accesses data locations within the buffers of the OPC DAServer . The data access server and the device integration objects cooperatively import and buffer data from external process control components such as PLCs e.g. PLC1 or other field devices not depicted on the plant floor network . An application engine hosts both the application objects and device integration objects and . The application engine as a host manages periodic event driven execution of the hosted application and device integration objects. The aforementioned components of the hierarchical hosting arrangement on the PC described in US App. Pub. 2008 0189637 A1 with reference to is incorporated herein by reference.

In the illustrative example requests for data are submitted via the data access server to retrieve data from the PLC1 . The retrieved data is thereafter used by the HMI object instances and to drive graphical displays representing for example the status of plant floor equipment. The data buffer of the data access server is accessed directly indirectly by the variety of application level objects e.g. application objects PLC1Network PLC1 etc. executing upon the personal computer . Examples of application objects represent data sources and logic including by way of example discrete devices analog devices field references events triggers production events etc. In an exemplary embodiment information obtained provided by the application level objects and is stored in a runtime Historian process information database not shown . The data is thereafter obtained by the HMI object instances to drive a display state of animated process graphics.

The data access server is by way of example an OPC Server. However those skilled in the art will readily appreciate the wide variety of custom and standardized data formats protocols that are potentially carried out by the data access server . Furthermore the exemplary application level device integration objects and through connections to the data access server represent a PLC network and the operation of the PLC itself. However the application level objects e.g. device integration and application objects hosted by the application engine comprise a virtually limitless spectrum of classes of executable objects that perform desired supervisory control and data acquisition integration functions in the context of the supervisory process control and manufacturing information application.

The supervisory process control and manufacturing information system is potentially integrated with a variety of processes plant information sources via a variety of communication channels. The exemplary system including the multi layered application comprising portion is communicatively coupled to the PLC1 . The PLC in turn receives plant equipment status information via the plant floor network . In a particular embodiment the PLC comprises a node on an Ethernet LAN to which the PC is connected. In other embodiments the PLC is linked directly to physical communication ports on the PC . In still other alternative embodiments the PC receives data from field I O modules that receive for example analog data from field devices that operate in a distributed regulatory control system.

Thus as illustrated in a system for managing human machine interface HMI applications for industrial control and automation is provided The system comprises a processor such as PC in combination with software instructions stored on a tangible non transitory media and executable by the processor. The instructions comprise instructions for receiving data indicative of a manufacturing process control system being monitored e.g. data stored in database and instructions for displaying a user interface indicative of a status of the manufacturing process control system being monitored e.g. application objects wherein the status is based on the received data.

It is noted that the system depicted in and described hereinabove is merely an example of a system including a multi layered hierarchical architecture for a supervisory process control and manufacturing information system. It is further noted that is presented as a logical view of the hosting and or containment interrelations between installed components including software and physical computing hardware. The system disclosed herein is suitable for virtually any network topology. For example the present invention is applicable to a system wherein both configuration utility and supervisory process control visualization applications run on a single computer system linked to a controlled process.

An alarm is an event that has a state and requires operator intervention. It requires an acknowledgement. Alarms are detected by software components and reported using alarm distribution mechanisms to be discussed later. Every alarm is reported or sent using a data structure that contains data fields that define the information for the alarms. The following list contains fields sent with an alarm notification. The alarm primitive which generates this message needs to support generation of these fields but may also have other attributes. Fields that are historized to event history are marked Historized .

Referring to TABLE 1 above the category labels are retrieved from a dictionary file by the UI clients and by the INTOUCH alarm provider since it requires these strings. These strings can be localized to other languages. The INTOUCH provider is to use the default galaxy language to retrieve these strings and send them to INTOUCH. Thus they will only appear in INTOUCH and INTOUCH history as the default galaxy language strings. The future view engine will use the locale of the client meaning only the category ordinal is to be historized. Historized .

On a global per galaxy basis the user of the IDE Integrated Development Environment of Archestra can edit the galaxy object to configure the mapping of alarm priority to severity and its associated settings.

Thus the user is given the actual flexibility in changing what these bands actually mean. So a particular project might define these Severities to be reversed from the defaults provided by Wonderware if they were interested in OPC compatibility more than INTOUCH compatibility. The Alarm Summary Display is configurable to sort from 1 to 999 or from 999 1 on Priority. By default it shows priority 1 alarms at top and 999 alarms at bottom the INTOUCH default . For example all non bold items in TABLE 2 below can be edited in the Galaxy object.

The mapping information is stored in a file named Data5.txt in the Global Data Cache and is automatically distributed from the GR to all platforms in the Galaxy.

Note In a multi Galaxy environment in which Galaxies are not sharing Global Data Cache information it is possible that one Galaxy may have a different Priority to Severity mapping than another. For example if Galaxy1 has alarms with Priorities 1 300 mapped to Severity 1 and Galaxy2 has alarms with Priority 1 200 mapped to Severity 1 then an alarm with Priority 250 will be mapped to Severity 1 on Galaxy1 and Severity 2 on Galaxy2.

The ITAlarmProvider reports Severity to the INTOUCH Distributed Alarm System AlarmMgr in the User data field. This field can be displayed on all INTOUCH alarm displays and on the ArchestrA Alarm Client EAC . The display client can be configured to label the column header as Severity .

To ensure that Alarmed attributes will always have current data the alarm primitive and the alarm extension primitive register a reference to the alarmed attribute. This will guarantee that message exchange will never suspend updates for this attribute. Even if alarms are disabled for a particular attribute the Scan On Demand feature will not be functional i.e. the attribute cannot be Suspended .

This section describes the system components that detect an alarm or event and also report that alarm or event. Alarms and events can be detected by software components in the system. Events can be reported by a larger variety of components than alarms. Events can be detected by virtually any component in the system including AutomationObjects SMC etc. Events are thus more general purpose than alarms and provide a means for any software component to indicate a condition or occurrence of interest to the event system. For example the SMC can report a user log in message as an event R0.5 . Several types of events can be reported as described earlier. When any component reports an event it uses an event API to do so. The component implementing the event API reports its event messages to Alarm Event distributors and History described later in this document. Events are sent to INTOUCH for real time display and for historization.

Alarms can only be detected by AutomationObjects. Any AutomationObject including Platforms Engines can detect and generate an alarm. To detect an alarm the AutomationObject must provide detection logic and set a Boolean Attribute flag to indicate whether the alarm is currently active or inactive.

If the alarm is associated with an attribute that supports buffered data the AutomationObject s detection logic must set the Buffer property of the Boolean condition Attribute with a VTQ array V being a Boolean representing whether or not the condition is true or false . There should be one VTQ for every VTQ in the base attribute s buffer so that when the alarm messages are composed PV can be extracted from the base attribute s buffer. Times for the corresponding elements in the base attribute s buffer and resulting Boolean condition attribute s buffer should match. Sequence of alarm state changes can be generated as a result of processing the condition buffer. A set of alarm messages corresponding to the alarm state changes will be composed and sent to the Notification Distributor.

The user can only acknowledge the current alarm. Alarm monitoring buffered attribute can be enabled silenced disabled inhibited. To report an alarm the AutomationObject must contain an Alarm Primitive. The Alarm Primitive examines the Boolean condition to determine whether the alarm is active. An Alarm Primitive is dedicated to reporting a single alarm condition s state. Alarm Primitives report their alarm messages to Alarm Event distributors described later in this document.

This section describes the impact of data quality on alarm reporting. Alarms are only reported when the data quality of the true Boolean condition flag is either Good or Uncertain.

Alarms are only cleared when the data quality of the false Boolean condition flag is either Good or Uncertain.

If the condition flag is Bad or Initializing quality the state of the condition flag is ignored and no new alarm reports or alarm clears occur. As an example assume the following occurs during normal execution of an object 

Some Objects and ArchestrA Graphics symbols such as those in the Situational Awareness Library SAL need an efficient and simple way to identify whether any alarms on an Object currently need attention what is the overall status of the most important of those alarms and how many alarms are presently active overall at each level of severity. In addition they need Alarm Aggregation described below to summarize all contained Objects following the Model View so that the alarm information represents the Object and all levels below it. This makes it possible for a user to drill down from one level to the next and use aggregation to search for the underlying cause of a complex Object s alarms.

As illustrated in and as illustrated in the alarm border animation support a system of the invention manages human machine interface HMI applications for industrial control and automation. Software instructions stored on a tangible non transitory media and executable by a processor receive data indicative of a manufacturing process control system being monitored and display a user interface indicative of a status of the manufacturing process control system being monitored wherein the status is based on the received data. In addition the instructions display graphic elements as part of the user interface. Each element is associated with and indicative of an alarm status of one or more aspects of the manufacturing process control system being monitored. The alarm status of each graphic element is a function of the status of its associated plurality of alarms. The instructions are also responsive to user input for configuring a selected graphic element with a border. The border is selectively animated in response to the alarm status associated with the selected graphic element being in an alert condition. The animation indicates that the one or more aspects of the manufacturing process control system associated with the selected graphic element is not at an acceptable value. The software instructions stored on a tangible non transitory media are executable by a processor. A processor executable method is provided.

Alarm border animation comprises processor executable software instructions stored on a tangible non transitory media e.g. a memory device and executed by a processor server by which a user can easily and quickly configure any graphic element e.g. object or group of elements to automatically visualize the alarming state of an entity within their platform application space. The user is provided with a user selectable border from a border library for a graphic object or group of elements such as illustrated in which automatically conforms to surround any object s shape configures itself to the connections surrounding the object and responds to the object s alarm information. A graphic element in the system can be configured with this border which is capable of changing state e.g. animating by blinking or flashing when certain conditions are met such as when any object within the border has an alarm.

In the past if a user wanted to put a border around something that would flash red there were a series of things the user needed to do. It took a while to craft that graphic element and then hook it up to the right thing. The alarm border animation software instructions create a native animation that can be attached to all the graphic objects. Using this native animation the alarm border animation software instructions can make the border of any graphic object blink based on certain stuff. For instance if the object has the most severe alarm the border of it will blink red. The border itself will conform to any irregular shape that it has taken on. Also based on the invention an object can have a blinking border when any object within it has a high severity alarm. Thus the processor executes instructions for specifying a user defined level of hierarchy for the plurality of alarms of each element instructions for specifying a user defined hierarchy level for each element above which an alarm is considered severe instructions for exposing a severe alarm above the user defined hierarchy level and instructions for exposing a severe alarm of a particular element when any sub element within the particular element has a severe alarm.

The border will be automatically drawn around whatever shape the user connects it to. It is not a separate element that the user has to draw. It is a new facet of every graphic element in the system automatically. The most powerful part is that it automatically configures the connection and automatically consumes alarm aggregation data from the application server providing the data from the manufacturing process control system being monitored by the MES.

One reason this is so important is because of the time savings to our users and the reduction of error rate in configuration of a system.

In the Wonderware Application Server the user s application is divided up into software entities called Objects.

This enables the user to prioritize which alarms to address first and to quickly locate where the corrections need to be made.

This new animation is introduced in ArchestrA and INTOUCH graphics that allows user to visualize the state of the alarm. The user is able to configure the alarm border animation on any graphic element. The animation can point to the alarm aggregated attributes and it will render the border and indicator base on the alarm states. Thus the processor executes instructions responsive to a user for configuring the animation of an element to point to an aggregated alarm attribute.

In the Wonderware Application Server also known as AppServer the user s application is divided up into software entities called Objects. Objects can be arranged in a hierarchy where 1 some Objects can contain other Objects 2 Objects can be grouped into Areas each of which contains many Objects and 3 an Area can also contain sub Areas.

Areas are a special kind of Object that can contain multiple Objects and other Areas. One of the purposes for an Area is to collect and cache all the information about the current alarms for all the Objects and sub Areas that it contains.

Application Objects also known as AppObjects are a specific kind of Object that can contain data in the form of Field Attributes. Field Attributes have a number of different behaviors that can be configured. An individual Analog Field Attribute can have several different alarms configured on it each with a different level of severity. So even within a single AppObject there might be multiple Field Attributes each with its own most urgent alarm.

The collection of AppObjects and Areas form a hierarchy tree which is called the Model View. Each AppObject has one parent. This parent may an Area or it may be another AppObject. But every AppObject must have a parent. An Area however can only be the child of another Area or it may have no parent at all.

Each individual alarm is handled by an Alarm Primitive. An alarm has multiple states and the processor executes instructions for selectively rendering a particular style of border or a particular type of animation for each state of an alarm.

These states are shown in INTOUCH in the alarm displays ActiveX Alarm Viewer Alarm DB Viewer and ArchestrA Embedded Alarm Client . The Current Alarms display shows only UNACK ALM ACK ALM and UNACK RTN. These are the alarm states that need attention. They need somebody to DO something either fix the problem acknowledge the alarm or both.

Drawn as a state diagram these states and transitions are illustrated in . When an alarm becomes active from normal the system transitions from state to state as illustrated by arrow . At state if the operator acknowledges the alarm the system transitions to state as illustrated by arrow . At state the system transitions to state as illustrated by arrow when the alarm returns to normal. At state if the alarm returns to normal before being acknowledged the system transitions to state as illustrated by arrow . At state the system transitions to state as illustrated by arrow after the operator acknowledges the alarm.

The Enable Silence Disable setting can be done at the Area level Object level and individual Alarm level.

In summary to monitor the alarm state s of a graphic element a user can configure an alarm border animation on the graphic element. The user can configure the animation to point to any aggregated alarm attributes. The animation will render the border around the graphic element. A different style of border can be rendered for each state of the alarm. These styles are defined in the Galaxy Style Library. Instructions executed by a processor of the system display graphic elements as part of the user interface so that each element is associated with and indicative of an alarm status of one or more aspects of the manufacturing process control system being monitored. Instructions executed by a processor of the system are responsive to user input for configuring a selected graphic element with a border which is selectively animated in response to the alarm status associated with the selected graphic element being in an alert condition indicating that the one or more aspects of the manufacturing process control system associated with the selected graphic element is not at an acceptable value. In various embodiments these instructions may be part of a system and or may be part of software instructions stored on a tangible non transitory media and executable by a processor and or may be a processor executable method.

The aspects of this feature are at least two fold The first is the way in which the system eliminates the need for tedious and error prone repetitive data entry tasks which normally need to be done by the user in order to realize this same level of functionality. And secondly without any additional input from the user the alarm border will draw itself around the element to which it is applied regardless of the shape size of the element.

Besides rendering the border the alarm border animation is also rendered an indicator on the left corner of the graphic element if user enables this functionality when configuring the animation. The default image of the indicators can be changed launching the Alarm Priority Mapping configuration dialog. When changing the indicators in the galaxy it will be propagated to runtime nodes without having to redeploy the application. The indicators may be indicative of a parameter associated with an alarm such as a hierarchy or level. Thus the processor executes instructions for selectively rendering in response to a user selection an indicator on or adjacent the graphic element wherein the indicator is indicative of a parameter associated with the alarm.

As illustrated in a system manages human machine interface HMI applications for industrial control and automation. Software instructions stored on a tangible non transitory media and executable by a processor receive data indicative of a manufacturing process control system being monitored and display a user interface indicative of a status of the manufacturing process control system being monitored wherein the status is based on the received data. In addition instructions display graphic elements as part of the user interface. Each graphic element is associated with and indicative of a status of a plurality of alarms of aspects of the manufacturing process control system being monitored. The alarm status of each graphic element is a function of and based on the status of its associated plurality of alarms. In various embodiments these instructions may be part of a system and or may be part of software instructions stored on a tangible non transitory media and executable by a processor and or may be a processor executable method.

Alarm aggregation collects and exposes via standard attribute interface a summary of the aggregate alarming states of an element in the physical equipment hierarchy including that of all elements below it in the hierarchy. Alarm aggregation comprises processor executable software instructions stored on a tangible non transitory media e.g. a memory device and executed by a processor server providing for a graphical object representing physical equipment organized within a hierarchy. The system collects and organizes alarms in a hierarchy. It exposes a severe alarm above a user defined level of hierarchy after the aggregated alarming state of the object is determined. This determination involves all sub objects below that object in the hierarchy reporting their alarm state severity which is determined in part by whether the alarm has been suppressed from the bottom up instead of analyzing the entire hierarchy from the top down as was done in the prior art. Thus the element may be an object and the processor executes instructions for determining sub objects below the object in the hierarchy reporting their alarm state severity from the bottom up instead of analyzing the entire hierarchy from the top down.

For Alarm Aggregation identification of the most urgent alarm s uses the following sorting precedence 

For example given the following three alarms the order of urgency is as follows UNACK ALM with Severity 3 ACK ALM with Severity 2 UNACK RTN with Severity 1.

The most urgent alarm on an Object is the one at the top of the sorting order as described above. If two or more alarms on an Object have the same most urgent combination of AlarmMode InAlarm status Acked status and Severity they have the same ranking for Alarm Aggregation.

In the Wonderware Application Server the user s application is divided up into software entities called Objects.

This enables the user to prioritize which alarms to address first and to quickly locate where the corrections need to be made.

A new animation is introduced in the ArchestrA graphic that allows user to visualize the state of the alarm. User is able to configure the alarm border animation on any graphic element. The animation can point to the alarm aggregated attributes and it will render the border and indicator base on the alarm states.

To support alarm aggregation on Objects each Object has a set of Attributes that summarize the overall status of all alarms on the Object and its descendants. These are as follows 

These Attributes are kept up to date at all times on each Object during runtime and are updated every Scan Cycle. These Attributes are updated every Scan Cycle to represent the current statuses of the alarms. At least one of the attributes are kept up to date on each object during runtime and the attributes are updated every scan cycle to represent the current statuses of the alarms. Update is done in two phases 

If there are no alarms configured on an Object or its descendants these attributes have the following default values 

Note If there are no alarms configured on an Object or its descendants then there are no Alarm Primitives executing to copy the Object s AlarmMode status to the AlarmMostUrgentMode attribute. However the post execute bubble up operation executes on all Objects whether they have alarms or not whether they are OnScan or not and makes sure AlarmMostUrgentMode is properly initialized every Scan Cycle.

Since alarms only update when an Object is OnScan if an Object is OffScan its own alarms will not contribute to the update of the aggregation values. However in the Model View hierarchy an Object and its descendants may be in different scan states so the statuses and data quality need to reflect this appropriately.

 Note The InAlarm flag always retains Good quality. This is a legacy flag that was in place for 10 years prior to the addition of the Alarm Aggregation feature. So to avoid breaking existing user applications the behavior of this flag s quality remains unchanged. 

If an Object with no descendants is OffScan the alarm aggregation statuses of the Object are the default values with Bad quality as follows 

Also note that for an Object that is OffScan all the Alarm Primitives on that Object are forced to the state InAlarm FALSE so the Object does not aggregate its own alarms which are all forced OFF. This is true whether the Object has descendants or not. For Objects with descendants the bubble up operation takes place even for Objects that are OffScan. Consequently the aggregation values represent the combined values of the Object and all its descendants.

If an Object with descendants is OffScan its own internal aggregation values are the defaults with Bad quality. The value and quality of the combined aggregation Attributes depend on whether the descendant Objects are OnScan or OffScan 

If an Object with descendants is OnScan then its own internal aggregation values are Good quality. Again the value and quality of the combined aggregation values depends on whether the descendant Objects are OnScan or OffScan 

Alarm Aggregation for an individual Analog Field Attribute is stored in the AnalogUtilities primitive that references the Field Attribute. The descriptions and statuses of the aggregation attributes are the same as for those in the Common Primitive except that they apply ONLY to the individual Field Attribute and there is no overall InAlarm status for the Field Attribute.

Alarm aggregation for an Area or pseudo Area includes all the alarms 1 on the Area Object itself 2 on all Objects assigned to the Area 3 all descendants of those Objects and 4 all sub Areas directly assigned to the Area in the Model View. The descriptions and statuses of the aggregation attributes are the same as for those in an Object as the same Common Primitive attributes are used.

The Quality for the alarm aggregation attributes on an Area is generally the same as for Objects with descendants with the following differences 

Alarm Aggregation may be disabled or enabled at an Area Level. The Notification Distributor primitive s AlarmAggregationStateCmd Boolean attribute will be true if aggregation is enabled and false if disabled. The default value of the attribute AlarmAggregationStateCmd is true which means the Alarm Aggregation feature is enabled for a given area and its child objects.

On Startup the Area primitive will retrieve the value of the AlarmAggregationStateCmd Boolean attribute in its Notification Distributor primitive. Based on the attribute s value the area will do the following 

User will be able to configure attribute AlarmAggregationStateCmd from the Area object editor. Platform Engine DI object editor will not have the option to Enable Disable Alarm Aggregation. Refer Area Object DFS for detail. User will not be able to change the attribute value at runtime.

As noted above some objects and ArchestrA graphics symbols such as those in the Situational Awareness Library SAL need an efficient and simple way to identify whether any alarms on an Object currently need attention what is the overall status of the most important of those alarms and how many alarms are presently active overall at each level of severity. In addition they need alarm aggregation to summarize all contained Objects following the Model View so that the alarm information represents the Object and all levels below it. This makes it possible for a user to drill down from one level to the next and use aggregation to search for the underlying cause of a complex Object s alarms.

In Summary alarm aggregation takes a specific item that the user can point at within the hierarchy of factory hardware represented by objects and indicates within that object and all of the objects within that object what is the most important or severe alarm that is happening right now The alarm aggregation software instructions do not scan to find the most urgent alarm instead the instructions notify the next layer up proactively what the most severe alarm is. The objects are proactively reporting changes in its alarm state up the hierarchy. Previous methods were to go from the top down to check severity on every little component. Some of the alarms could be suppressed at a lower level because there are different priority levels of alarms. The alarm severity and whether the alarm has been acknowledged can affect whether it is the most severe alarm.

Alarm Aggregation for an individual Analog Field Attribute is stored in the AnalogUtilities primitive that references the Field Attribute. The descriptions and statuses of the aggregation attributes are the same as those for an Object except that they apply ONLY to the individual Field Attribute and there is no overall InAlarm status for the Field Attribute.

For the ArchestrA Application Server all of the Objects in an Area are updated once per Scan Cycle. During a Scan Cycle all of the Objects are updates using data values and alarm statuses that were finalized at the end of the PREVIOUS Scan Cycle. Then at the end of the Scan Cycle the new data output values are published and the alarm statuses are updated. They will be used as calculation inputs during the next Scan Cycle.

For Alarm Aggregation during a Scan Cycle the aggregation statuses for each Object and each Area are held unchanged. As each Object is executed it generates a set of updated data and alarm statuses including an internal set of updated alarm aggregation values that represent the new statuses of the alarms. At the very end of the Scan Cycle a synchronization phase uses these internal aggregation values to calculate the new alarm aggregation statuses for all AppObjects in an Area and for the Area itself which will become the published alarm aggregation statuses for the next Scan Cycle.

As illustrated in also see the example of element styles user interface Appendix below and a system manages human machine interface HMI applications for industrial control and automation. is a screen shot of an interface for specifying an element style. In the element style for an unacknowledged critical alarm is selected. The style includes text elements Ts fill elements Fs and line elements Ls . It does not include outline elements Ol . There are no overrides as indicated in the preview window. Software instructions stored on a tangible non transitory media and executable by a processor receive data indicative of a manufacturing process control system being monitored and display a user interface indicative of a status of the manufacturing process control system being monitored wherein the status is based on the received data. In addition instructions define a set of user defined graphical element style standards granularly applicable to separate elements. Also instructions responsive to user input configure a plurality of separate elements to be referenced to a particular graphical object representing a process control device of the manufacturing process control system being monitored. The plurality of separate elements has the same user defined graphical element style standards. The properties of the plurality of separate elements are defined by the particular graphical object so that the user configures the plurality of separate elements without accessing each of the plurality of separate elements. In various embodiments these instructions may be part of a system and or may be part of software instructions stored on a tangible non transitory media and executable by a processor and or may be a processor executable method.

The graphic styles for all application elements in a galaxy are centrally managed and distributed. This enables a user to change the appearance of an application element without going into the application element and modifying specific properties of its graphic elements for example colors fonts or line.

Element styles comprises processor executable software instructions stored on a tangible non transitory media e.g. a memory device and executed by a processor server to provide a set of graphical element style standards granularly applicable to separate elements referenced to a graphical object representing a process control device such as a valve within a pump. The style standards prevent the user from having to modify colors or line widths manually. Any change to an element style results in an update to all references to the element style in the galaxy . User defined styles may be built upon default predefined styles. Instructions responsive to user input modify an element style of the particular graphical object and instructions change the element style of the plurality of separate elements to have the same user defined graphical element style standards as the modified element style of the particular graphical object.

The keyword here is standards . Element styles are a way for users to codify their graphic standards when it comes to color line thickness font font color line style etc. The way this comes together is by exposing the ability for the user to utilize a set of standard style names predefined . Some of these the user can change and some are locked down. Using our domain knowledge the software recommends styles for the user s graphic elements to apply as is suggested by the styles.

The user can change aspects of the style line thickness font font color etc. . The user can use the style name throughout the system in the same way. Styles are provided and propagated in unique ways. For example in one implementation if the user have a pump the pump may have 100 element styles. The user may want only the interior to go black based on one style. The user is provided with ways to granularly apply these styles to various elements. The user is also provided with defaults for various styles. This allows the user to assign different styles to different parts of the pump.

The styles have an order of precedence within the styles themselves. They fall back on one another in certain situations. Styles can build upon the existing styles that may be applied. In one form these are not cascading styles . The styles have defaults and allow building on styles. Upper level style changes are not pushed down to explicitly set styles at the lower level but it will push down to defaults.

Thus the element style feature provides the ability for the user to centrally manage the styles for all application in a galaxy. It enables user to change appearance of the application without going into the application and modifying specific properties of graphic elements for example colors fonts or line.

In one form the element style feature provides a set of predefined element styles. These styles can be used as standard styles that can be applied throughout the applications in the galaxy. A user is able to modify the properties of the predefined styles for building a element style to suit a need. A set of custom styles is also provided for the user to create customized styles. The style library configuration dialog can be launched from the IDE.

An element style can be exported from one galaxy and imported into another galaxy using the XML format. Validation is performed when importing an xml file to ensure the file contain the correct format. Thus objects are groups into galaxies and a processor executes instructions for exporting a user selected element style of objects in a first galaxy and for importing the user selected element style into a second galaxy using an XML format. The processor also executes instructions for validating the imported XML file to ensure the imported XML file contains a compatible format with the second galaxy.

Whenever a user is changing the properties of the element style in the style library the changes will be automatically be propagated to all runtime nodes so that the user does not have to redeploy the applications.

To use the element styles defined in the style library in the graphic editor the user can configure the graphic element to use the styles from the style library. The user also use element style animation to apply the styles from the style library in runtime.

In summary with the element style feature the user has the ability to utilize preexisting element styles or custom element styles that can be referenced in the user s graphics and animations. If the user changes the properties of the element in the galaxy all the graphics and animations referencing the element style will be updated to reflect the change.

As illustrated in a system manages human machine interface HMI applications for industrial control and automation. Software instructions stored on a tangible non transitory media and executable by a processor receive data indicative of a manufacturing process control system being monitored and display a user interface indicative of a status of the manufacturing process control system being monitored wherein the status is based on the received data. In addition instructions define a set of designer defined graphical element style standards granularly applicable to separate elements. Also instructions responsive to designer input configure a customized symbol wizard for use by the designer for generating symbols according to a customized designer defined template corresponding to at least one of the designer defined graphical element style standards. The software instructions stored on a tangible non transitory media are executable by a processor. A processor executable method is provided. In various embodiments these instructions may be part of a system and or may be part of software instructions stored on a tangible non transitory media and executable by a processor and or may be a processor executable method.

In summary the symbol wizard creator is a powerful and flexible tool that allows a symbol wizard designer to create a complex composite symbol wizard that exposes a configuration that allows a subsequent user to configure objects elements according to the subsequent user s specific needs within the parameters of the symbol wizard created by the symbol wizard designer. Using the Symbol Wizard subsequent users can create a customized symbol which has different locations of elements than other similar symbols within the parameters of the symbol wizard created by the symbol wizard designer.

Symbol wizards provide a configurable encapsulation of process graphic functionality which includes graphic elements scripting and process variables. The symbol wizard comprises processor executable software instructions stored on a tangible non transitory media e.g. a memory device and executed by a processor server formatting a wizard generator designed to provide the user with modifiable symbol generators. The symbol wizard creator enables the design and modification of a customized symbol wizard for generating symbols according to a customized user defined template which enables a higher level of involvement from a user without the need for knowledge of object oriented programming languages. The user is able to design each symbol wizard according to their own standards in terms of the elements scripts and process variables contained in each wizard.

A problem that users have faced in the past is that the user has low level tools to build graphics but the user who is assembling the graphics for a particular application does not have the time or desire to use such low level tools to maintain a consistent design. The user wants to visualize things on the factory floor and has been give premade symbols to use in the visualization. If they change a symbol they have drill down and get into lower granular graphic levels to make their changes. The symbol wizard makes it easier to consistently create similar symbols for a particular application. For instance with regard to a library provided pump symbol the user can configure whether the pump symbol displays a meter.

In the past users have made change by modifying programming languages and compiling the modified languages. At least some users have domain knowledge so that symbol wizards will allow them to craft their symbols with more options they can change without requiring programming. Symbol wizards also provide a tool for companies making their own symbols as well. A high end user can use symbol wizards design craft deploy and distribute the configurable wizards and then another level of users have the ability to use these symbol wizards to design the necessary symbols. The wizard designer builds all the logic of each symbol wizard through click and point. Then the symbol wizards are handed off to a application assembler who takes the symbol wizard from a toolbox of available symbol wizards and uses them in their application.

The symbol wizard enables user configurable encapsulation of process graphic functionality which includes graphic elements scripting and process variables. The symbol wizard functionality gives the symbol wizard designer the ability to create Graphic Symbol Wizards within the ArchestrA Graphics Editor that can represent any number of unique combinations of Graphic Elements scripts and process variables as a single symbol wizard.

This solves the problem of the designer being required to create multiple symbols for a complex process graphic. The symbol wizard enables the designer to create a single symbol wizard which encapsulates multiple process graphics.

A user of the symbol can drag and drop the symbol onto the user s drawing canvas and configures the wizard instance to match the user s specific needs. Wizard Layers are a means to group process graphic contents which define a specific subset of functionality to be encapsulated which can be enabled conditionally through wizard rules. The contents of a layer will be included in the runtime environment if it is enabled otherwise it is not included. This has the effect of greatly reducing the runtime system resource requirements and utilization on the visualization node.

Wizard Rules allow the designer to use wizard options to construct Boolean logic statements which enable or disable layers. Wizard options are created by the designer to allow the Application Engineer to selectively enable or disable encapsulated functionalities within the Symbol Wizard. Choice Groups are created by the symbol wizard designer to group one or more mutually exclusive choices. Choices are created by the symbol wizard designer to represent a single configuration related to a subset of functionality within the process graphic. Options are created by the symbol wizard designer to represent a Boolean toggle of a single configuration related to a subset of functionality within the process graphic.

In the graphic editor the wizard designer is able to design and create options and choices for a particular symbol wizard through a user interface. These options and choices will be exposed to a user of the particular symbol wizard as optional configurations. The designer can hide or show the options and choices by configuring a rule expression for each option that will be evaluated to true or false.

A layer concept is also introduced in the graphic editor to allow wizard designer to show and hide group of graphics and custom properties. The user can associate graphics to the layer by a drag and drop function. Beside graphics the user can also associate local custom properties and named scripts to the layers. Hiding or showing the layers is determined by the evaluation of the configured rule expression which driven by selection of choice or option that create by the wizard designer.

As illustrated in a system manages human machine interface HMI applications for industrial control and automation. Software instructions stored on a tangible non transitory media and executable by a processor receive data indicative of a manufacturing process control system being monitored and display a user interface indicative of a status of the manufacturing process control system being monitored wherein the status is based on the received data. In addition instructions display graphic elements as part of the user interface wherein each element is associated with and indicative of an alarm status of one or more aspects of the manufacturing process control system being monitored. Also instructions responsive to user input render a visualization window in a single trend line of blended data including 1 received real time data of a process variable of the manufacturing process control system being monitored and 2 historical data of the process variable of the manufacturing process control system being monitored. In various embodiments these instructions may be part of a system and or may be part of software instructions stored on a tangible non transitory media and executable by a processor and or may be a processor executable method.

A trend pen renders and enables visualization by a plant operator or other user of blended real time and historical data of a process variable in a single trend with minimum configuration. One benefit is its extremely high performance and the ability to support 100 s of trend pen elements displayed in a single process graphic window without performance degradation.

Trend pen is a real time trend with historical backfilling with any additional data needed with historical data for a historian server to define a single trend line comprising processor executable software instructions stored on a tangible non transitory media e.g. a memory device and executed by a processor server providing a process variable visualization tool designed to provide the user with a depiction of simplified trend data which requires minimum configuration. The user is able to configure the time period and whether the window remains fixed or moves as time progresses. Many other functional aspects of the tool are automatically configured resulting in ease of access by the user.

For example a user may have a level meter on a tank which changes in levels over 2 hours. It s being filled. The user is not going to stare at that meter and remember what the rate of change was. The user wants to just see a simple curve of where it s been in the last two hours. The trend pen is lightweight does not have an x y axis and does not have labels or scrollbars. It is a squiggly line that hangs off the side of a meter. Thus real time trending is heavy on information.

A standard use case might be that a user has 10 tanks on a screen that are holding oil. The system is able to provide a screen showing where each tank has been over a past time period. Data is typically collected when the screen is open but data is also collected in the historian. The trend pen will go to the historian and request the data from the desired period at the desired granularity for visualization. Thus the user doesn t have to leave the screen up and running all the time.

When the trend pen screen is opened it will determine what meters it needs to figure out trending for what time period to pull data from the historian how many data points are necessary to be useful for presenting a single line what scale to use etc. It presents it as a simple line that makes intuitive sense to the user based on what meter is being visualized.

The trend pen enables a plant operator or other user to visualize real time and historical data of a process variable in a single trend with minimum configuration. It is a high performance process graphic element that displays the performance of a process variable over a short period of time. Many trend pens can be displayed in a single process graphic window without performance degradation.

The trend pen element is configured to work with various type of meters such as flow meter. A user of trend pen can drag and drop the trend pen element onto the canvas and attach a meter symbol to it. The trend pen element configuration option allows the user to configure process variables to be monitored.

The trend pen automatically detects the historian server which attaches to the current platform. It makes a call in the background to retrieve historical data for the configured process variable and render the trend base on the historical data. This reduces the configuration effort since it may not know the name of the historian server. The trend will pick up the real time data from the configured process variable and plot it on the same axis together with the historical data for the configured time period. The advantage is the user will see trending for both the historical and real time data based on the configured time period.

Trend pen allows two operation modes one is a fixed window Absolute Time Range and the other is a moving or trending window Moving Window Time Range . The fixed window allows a user to enter a start and a end time. The time range is automatically calculated for the moving window mode.

A user is able to configure the time period for the trending window. The trend pen will retrieve the historical data based on the configured time period. The trend pen exposes start time and end time properties which are automatically calculated based on the time period. This allows users to configure the starting in the fixed window mode. The refresh cycle is automatically calculated based on the width of the trend pen visualization window configured by the user and the time period of the visualization window. For example the refresh cycle may be a percentage of the time period based on the width. As a specific example it the width is one inch which corresponds to a 10 refresh rate and the time period is one hour then the refresh rate would be six minutes or 10 of one hour. As another specific example it the width is three inches which corresponds to a 5 refresh rate and the time period is 2.5 hours then the refresh rate would be 7.5 minutes or 5 of 2.5 hours.

The trend pen provides users the ability to view real time and historical data replay together on the same trend. One objective of the trend pen is to provide additional information about the object e.g. meter or agitator which allows users better understanding the behavior of the process variable being visualized.

This trend pen is designed in such a way that a user only needs to perform minimum configuration. It will automatically detect the remote historian nodes where the process variable is historized. The trend pen provides the scalability and performance to have more than 100 to 200 trends on single a window. This solves the problem of maintaining separate trend for historian or real time and cumbersome process of picking reference in each database. Users can update the target reference and its period in runtime.

In the Absolute Time Range mode a graphic symbol is shown for the first time animation will get the data from historian based on the configured start time and end time. The data from that point in time forward is plotted using live data until the end time as illustrated in . For example illustrates a plot from left to right of the data beginning 8 00 am as of 8 15 am. illustrates a plot from left to right of the data beginning 8 00 am as of 8 30 am. illustrates a plot from left to right of the data beginning 8 00 am as of 8 45 am. illustrates a plot from left to right of the data beginning 8 00 am as of 9 00 am. As illustrated in trending halts at the end of a fixed time period e.g. 8 00 am to 9 00 am . Thus illustrates a plot from left to right of the data between 8 00 am and 9 00 am as of 8 15 am. In this regard instructions enable a user to configure a time period for the visualization window wherein the visualization window comprises a fixed time period having a start time and an end time specified by the user.

In the Moving Window Time Range mode a graphic symbol is shown for the first time trend tail animation will get the data from the historian based on the configured time period. From that point in time forward the trend is drawn using live data.

The trend pen also supports clipping and auto out of range capabilities with shading area under the curve. illustrates an exemplary layout of trend pen components. A Galaxy Reference Manager component supplies a historian connector component and a trend calculator component with reference information. The historian connector component and the trend calculator component may be reused in the INTOUCH system. A graphic library component supplies the historian connector component and the trend calculator component with a graphics library. The historian connector component supplies a historian client software development kit SDK component . The historian SDK component delivers a set of binary executables which expose a set of application programming interfaces APIs used by the Trend Pen animation to retrieve historical data for the trended process variable from the historian data storage system. The historian connector component is responsible for managing connections to historian servers and to get history data from connected historian servers. The trend calculator component is responsible for calculating the trend plot points by taking into account the trend animation parameters runtime data and history data. It outputs an array of points that will be used by the simple trend graphic element to render a curve. The trend calculator component is not dependent on the other assemblies except the required .Net Framework assemblies. The graphic library component supplies a local message exchange LMX component and an InTouch calibration component . The LMX component exposes a set of APIs and underlying services which provide access to locally cached process variables and system parameters at runtime subscription services for real time updates of the same and a robust discovery capability at both design time and runtime. The Trend Pen animation utilizes the discovery service to find the source of the trended process variable then uses the subscription functionality to register for real time updates for the trended process variable. Other optional parameters include 

Thus the trend pen is a powerful and flexible graphic element that allows designers to build and use Single PV Point of View or multiple PV trends with applied element styles which can be either included as part of existing graphics or shown as a pop up graphic to provide historical and real time trends and to allow the user to make informed decisions. This trend is primarily used by users to quickly understand the historical and real time behavior of a PV to detect the situation and guide the user about the variability of the PV and is usually used in meters e.g. a flow meter a miscellaneous meter and a pressure control meter which are set of advanced process graphics in the symbol library.

The Abstract and summary are provided to help the reader quickly ascertain the nature of the technical disclosure. They are submitted with the understanding that they will not be used to interpret or limit the scope or meaning of the claims. The summary is provided to introduce a selection of concepts in simplified form that are further described in the Detailed Description. The summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the claimed subject matter.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks. It is recognized however that such programs and components reside at various times in different storage components of a computing device and are executed by a data processor s of the device.

Although described in connection with an exemplary computing system environment embodiments of the aspects of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of any aspect of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with aspects of the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Embodiments of the aspects of the invention may be described in the general context of data and or processor executable instructions such as program modules stored one or more tangible non transitory storage media and executed by one or more processors or other devices. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. Aspects of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote storage media including memory storage devices.

In operation processors computers and or servers may execute the processor executable instructions e.g. software firmware and or hardware such as those illustrated herein to implement aspects of the invention.

Embodiments of the aspects of the invention may be implemented with processor executable instructions. The processor executable instructions may be organized into one or more processor executable components or modules on a tangible processor readable storage medium. Aspects of the invention may be implemented with any number and organization of such components or modules. For example aspects of the invention are not limited to the specific processor executable instructions or the specific components or modules illustrated in the figures and described herein. Other embodiments of the aspects of the invention may include different processor executable instructions or components having more or less functionality than illustrated and described herein.

The order of execution or performance of the operations in embodiments of the aspects of the invention illustrated and described herein is not essential unless otherwise specified. That is the operations may be performed in any order unless otherwise specified and embodiments of the aspects of the invention may include additional or fewer operations than those disclosed herein. For example it is contemplated that executing or performing a particular operation before contemporaneously with or after another operation is within the scope of aspects of the invention.

Throughout the specification and claims terms such as item element object etc. may be used interchangeably to generically describe or identify software or display features unless otherwise indicated.

When introducing elements of aspects of the invention or the embodiments thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

In view of the above it will be seen that several advantages of the aspects of the invention are achieved and other advantageous results attained.

Not all of the depicted components illustrated or described may be required. In addition some implementations and embodiments may include additional components. Variations in the arrangement and type of the components may be made without departing from the spirit or scope of the claims as set forth herein. Additional different or fewer components may be provided and components may be combined. Alternatively or in addition a component may be implemented by several components.

The above description illustrates the aspects of the invention by way of example and not by way of limitation. This description enables one skilled in the art to make and use the aspects of the invention and describes several embodiments adaptations variations alternatives and uses of the aspects of the invention including what is presently believed to be the best mode of carrying out the aspects of the invention. Additionally it is to be understood that the aspects of the invention is not limited in its application to the details of construction and the arrangement of components set forth in the following description or illustrated in the drawings. The aspects of the invention are capable of other embodiments and of being practiced or carried out in various ways. Also it will be understood that the phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting.

Having described aspects of the invention in detail it will be apparent that modifications and variations are possible without departing from the scope of aspects of the invention as defined in the appended claims. It is contemplated that various changes could be made in the above constructions products and methods without departing from the scope of aspects of the invention. In the preceding specification various preferred embodiments have been described with reference to the accompanying drawings. It will however be evident that various modifications and changes may be made thereto and additional embodiments may be implemented without departing from the broader scope of the aspects of the invention as set forth in the claims that follow. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense.

In this configuration a standard ArchestrA color selection dialog is included as shown in without the No Fill tab.

This is the launch point for Configure Galaxy Style Library dialog. The original Quality and Status Display . . . may be replaced as Galaxy Style Library . . . .

This is the dialog box to configure the Galaxy style library include the Quality and Status Element Style and other styles defined in the future.

The Quality and Status tab hosts the page used to define the Galaxy Quality and Status. The referenced Configure ArchestrA Graphic Quality and Status DFS defined configuration behavior of this page.

Click OK to save the settings for all pages and propagated the changes to Galaxy and then close this dialog.

The highlighted section of illustrates one example of a screen shot of the Element Styles tab of a Configure Galaxy Style Library Interface box when font override of the text tab has been selected for element style NS1 including text fill line and outline.

Referring to the left side is the grid showing an overview of the element styles available in the Galaxy. Each line represents one element style. The first column is the element style name. The check box can be displayed under each of the other columns when the property is configured Ts Text Style Fs Fill Style Ls Line Style and Ol Outline . Multiple element styles can be selected following standard Windows grid control selection pattern including but not limit to Shift click Ctrl click Shift Down Shift Up Shift Home Shift End.

The Reset to Default buttons can be used to set the selected element style to the same configuration as the product shipped.

When multiple element styles are selected everything on right hand side will be disabled except the Reset To Default button. Click on the button to reset all selected styles. The preview area will be cleared.

The bottom right is the configuration area which can be used to define the Text Style Fill Style Line Style and Outline of the selected element style. See below sections for detailed information.

Any changes in the configuration area will be reflected in the overview grid and preview area immediately.

This is used to configure the text style properties in the element style include Font Font Color and text blink properties.

The highlighted section of illustrates one example of a screen shot of the Element Styles interface text tab of a Configure Galaxy Style Library Interface box when font override font color override and blink of the text tab have been selected for element style NS1.

This is used to configure the Fill style properties in the element style include fill color and blink properties.

The highlighted section of illustrates one example of a screen shot of the Element Styles interface fill tab of a Configure Galaxy Style Library Interface box when fill color override and blink of the fill tab have been selected for element style NS1.

This is used to configure the Line style properties in the element style include line pattern line weight line color and blink properties.

The highlighted section of illustrates one example of a screen shot of the Element Styles interface line tab of a Configure Galaxy Style Library Interface box when line pattern override line weight override line color override and blink of the line tab have been selected for element style NS1.

See the same behavior in 4.2.2.4.3 Line Property Overrides in the referenced Configure ArchestrA Graphic Quality and Status DFS.

This is used to configure the Outline style properties in the element style include line pattern line weight line color and blink properties.

The highlighted section of illustrates one example of a screen shot of the Element Styles interface line tab of a Configure Galaxy Style Library Interface box when show outline and blink of the outline tab have been selected for element style NS1.

Whenever user is changing the properties of the element style in the style library the changes will be automatically propagated to all runtime nodes without having user to redeploy the applications.

To use the element styles defined in the style library in the graphic editor the application engineer can configure the graphic element to use the styles from the style library. He cans also use element style animation to apply the styles from style library in runtime.

With this element style feature the user has the ability to utility preexisting element styles or his custom element styles that can be referenced in his graphics and animations. If the user changes the properties of the element in the galaxy all the graphics and animations referencing the element style will be updated to reflect the change.

In normal operation user doesn t want to see many information on graphic like label PV value etc. but when alarm border is visible then the user may want to turn on this information.

