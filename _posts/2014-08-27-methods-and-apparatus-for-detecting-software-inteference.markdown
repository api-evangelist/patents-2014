---

title: Methods and apparatus for detecting software inteference
abstract: The present application relates to an apparatus for detecting software interference and the method of operating thereof. A processor and at least one shared resource form a computing shell to execute a first, functional safety critical application and at least one second application in time-shared operation. One or more performance counters are provided to adjust a counter value in response to a performance related event. A reference value storage stores one or more threshold values, each of which is associated with one of the performance counters. A comparator receives the performance counter values, compares the performance counter values with the respective threshold values and generates at least one comparison signal in response to results of the comparisons. An interference indication generator receives the at least one comparison signal and generates at least one interference indication in response to the at least one received comparison signal.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454424&OS=09454424&RS=09454424
owner: Freescale Semiconductor, Inc.
number: 09454424
owner_city: Austin
owner_country: US
publication_date: 20140827
---
The field of this invention relates to methods and apparatus for detecting application interference and in particular for detecting performance interference whilst for example processing a safety critical application.

Generally when executing software that requires different safety integrity levels measures need to be put in place to reduce a risk of interference. Typically issues of interference arise when one safety critical task interferes with a second safety critical task causing potentially dangerous malfunctions to software based processes due to reduced processing performance resulting in a reduced progressing progress of at least one of the safety critical tasks.

Worst case execution time WCET is typically used for understanding timing behaviour of software where it is important for reliability or correcting functional behaviour. Calculating WCET generally involves generating approximations which usually includes overestimation when there are uncertainties. Therefore in practice the exact WCET itself is often regarded as unobtainable. For modern systems utilising WCET can require a huge effort and can lead to inefficient implementations due to the involved approximations and worst case assumptions.

Targeting performance domain interference of software executed either in a time sharing manner by a single computing shell or on different computing shells integrated in a multiprocessor system requires quantifying disturbances that are due to interferences in the performance domain. Interferences can occur due to sharing of state based resources for example having bi stable elements or concurrent access to shared resources.

Current methods generally measure a time duration that a specific software task requires for execution. Unfortunately state of the art processing shells are less and less deterministic in the time domain and execution time relies heavily on executed instructions the processed data and the process circumstances. Therefore as a result time windows for time domain performance monitoring have to be ever wider and wider.

SnoopP is an on chip functional level non intrusive profiler for software applications running on soft core processors. SnoopP comprises a user specified variable number of segment counters that are used to measure a number of clock cycles spent in executing contiguous regions of memory. Each segment contains two comparators to check a value of the program counter between a specified low and high address. If the value of the program counter is presently accessing an address within these bounds then the counter value is incremented. A counter clocked by a central processing unit CPU clock and masked by logic is utilised to validate if a CPU program counter is within a given range. This enables the counter to assess the CPU time spend within the user specified address space.

In general this is used for profiling purposes to identify the code section that processing elements spend most of the CPU time. However it is known that this approach is sensitive to non deterministic behaviour e.g. data dependent execution time and therefore provides only a limited diagnostic coverage. As this approach only accumulates the total CPU time spend to process the instructions within a given instruction address range it is prone to all types of non determinism of computer processing. This approach does not differentiate the CPU time spend for example on only fetching data fetching instructions processing interrupts CPU stall cycles number of instructions completed number of memory accesses by type number of instruction or data cache misses number of cycles with multiple instructions issue number of instructions in a given class completed load store instructions branch subroutine return instructions integer floating point instructions etc. cache line fills and calling subroutines As these different CPU times are differently influenced by software interferences or hardware non determinism this approach does not allow to tailor the CPU timeout window to the specific indicators of a software interference.

In summary performance interference reduces the performance of a processing unit whilst processing a safety critical software task due to interference of a second software task having a different safety criticality. Current methods of performance interference monitoring are only generally handled by imprecise time based measurements.

Current methods generally measure a time duration a specific software task requires to complete its execution so called timeout watchdog or window watchdog . Unfortunately state of the art processing shells are becoming less and less deterministic in the time domain. A reason for the reduction of execution time determinism may be due to more and more speculative operations performed within a core. In the case that these speculations are correct the results are available earlier. However in the case that these speculations are incorrect the same instruction will take longer to process.

Further the hierarchical memory system cache may also attempt to speculatively pre fetch and store data and instructions. In the case that the speculative fetches were correctly predicted execution time will be fast. However performance may be significantly slowed down if the predicted behaviour did not correspond to the program behaviour.

The execution time relies heavily on the executed instructions processed data and the number of context switches interrupts etc. As a result the time windows for time domain performance monitoring have to be wider and wider.

The invention provides an apparatus and a method for detecting software interference of applications running within a computing shell as defined in the independent claims.

Specific embodiments of the invention are set forth in the dependent claims. These and other aspects of the invention will be apparent from and elucidated with reference to the examples described hereinafter.

Because the illustrated examples of the present invention may for the most part be implemented using electronic components and circuits known to those skilled in the art details will not be explained in any greater extent than that considered necessary as illustrated above for the understanding and appreciation of the underlying concepts of the present invention and in order not to obfuscate or distract from the teachings of the present invention.

Aspects of the present disclosure are best understood from the following detailed description when read with the accompanying figures. It is noted that in accordance with the standard practice in the industry various features are not drawn to scale. In fact the dimensions of the various features may be arbitrarily increased or reduced for clarity of discussion.

It is understood that the following disclosure provides many different examples capable of implementing different features. Specific examples of components and arrangements are described below to simplify and thus clarify the present disclosure. These are of course merely examples and are not intended to be limiting. In many instances the features of one example may be combined with the features of other examples. In addition the present disclosure may repeat reference numerals and or signs in the various illustrative examples and in particular same reference numerals and or signs may be used throughout the drawings. This repetition is for the purpose of simplicity and clarity.

Referring now to there is shown a simplified schematic diagram of a multi core system on chip having multiple processor cores . The multi core system on chip should be understood as one example of a data processing device or a data processing system in the context of the present application. As illustrated each of the processor cores is coupled to one or more levels of cache memory such as an L1 instruction cache I Cache L1 data cache D Cache and or L2 cache. While the processor cores may be identically designed or homogenous the multi core SoC may also include one or more cores having a different design. For example the depicted multi core SoC also includes an accelerator which may include one or more processor cores for supporting hardware acceleration for DFT iDFT and FFT iFFT algorithms and for CRC processing. Each processor core is coupled across an interconnect bus to one or more memory controllers which are coupled in turn to one or more banks of system memory not shown . The interconnect bus also couples the processor cores to a Direct Memory Access DMA controller network interface a high speed serial interface and to other hardware implemented integrated peripherals to . The interconnect bus may be a coherency fabric.

Each of the processor cores may be configured to execute instructions and to process data according to a particular instruction set architecture ISA such as x86 PowerPC SPARC MIPS and ARM for example. Those of ordinary skill in the art also understand the present invention is not limited to any particular manufacturer s microprocessor design. The processor core may be found in many forms including for example any 32 bit or 64 bit microprocessor manufactured by Freescale Motorola Intel AMD Sun or IBM. However any other suitable single or multiple microprocessors microcontrollers or microcomputers may be utilized. In the illustrated embodiment each of the processor cores may be configured to operate independently of the others such that all cores may execute in parallel. In some embodiments each of cores may be configured to execute multiple threads concurrently where a given thread may include a set of instructions that may execute independently of instructions from another thread. Such a core may also be referred to as a multithreaded MT core. Thus a single multi core SoC with four cores will be capable of executing a multiple of four threads in this configuration. However it should be appreciated that the invention is not limited to four processor cores and that more or fewer cores can be included. In addition the term core refers to any combination of hardware software and firmware typically configured to provide a processing functionality with respect to information obtained from or provided to associated circuitry and or modules e.g. one or more peripherals as described below . Such cores include for example digital signal processors DSPs central processing units CPUs microprocessors and the like. These cores are often also referred to as masters in that they often act as a bus master with respect to any associated peripherals. Furthermore the term multi core or multi master refers to any combination of hardware software and firmware that that includes two or more such cores e.g. cores and regardless of whether the individual cores are fabricated monolithically i.e. on the same chip or separately. Thus a second core may be the same physical core as first core but has multiple modes of operation e.g. a core may be virtualized .

As depicted each processor core e.g. processor core may include a first level L1 cache which includes a data cache D Cache and an instruction cache I Cache . In addition a second level of cache memory L2 may also be provided at each core though the L2 cache memory can also be an external L2 cache memory which is shared by one or more processor cores. The processor core executes instructions and processes data under control of the operating system OS which may designate or select the processor core as the control or master node for controlling the workload distribution amongst the processor cores . Communication between the cores may be over the interconnect bus or over a crossbar switch and appropriate dual point to point links according to for example a split transaction bus protocol such as the HyperTransport HT protocol not shown .

The processor cores and accelerator are in communication with the interconnect bus which manages data flow between the cores and the memory. The interconnect bus may be configured to concurrently accommodate a large number of independent accesses that are processed on each clock cycle and enables communication data requests from the processor cores to external system memory and or an on chip non volatile memory as well as data responses therefrom. In selected embodiments the interconnect bus may include logic such as multiplexers or a switch fabric for example that allows any core to access any bank of memory and that conversely allows data to be returned from any memory bank to any core. The interconnect bus may also include logic to queue data requests and or responses such that requests and responses may not block other activity while waiting for service. Additionally the interconnect bus may be configured as a chip level arbitration and switching system CLASS to arbitrate conflicts that may occur when multiple cores attempt to access a memory or vice versa.

The interconnect bus is in communication with main memory controller to provide access to the optional SOC internal memory or main memory not shown . Memory controller may be configured to manage the transfer of data between the multi core SoC and system memory for example. In some embodiments multiple instances of memory controller may be implemented with each instance configured to control a respective bank of system memory. Memory controller may be configured to interface to any suitable type of system memory such as Double Data Rate or Double Data Rate 2 or Double Data Rate 3 Synchronous Dynamic Random Access Memory DDR DDR2 DDR3 SDRAM or Rambus DRAM RDRAM for example. In some embodiments memory controller may be configured to support interfacing to multiple different types of system memory. In addition the Direct Memory Access DMA controller may be provided which controls the direct data transfers to and from system memory via memory controller .

The interconnect bus is in communication with storage HUB to provide access to mass storage not shown . The storage HUB may be configured to manage the transfer of data between the multi core SoC and mass storage units for example. The storage HUB may further include one or more interfaces specific for the technology used by the mass storage units. Herein the storage HUB is exemplarily illustrated to include a SD eMMC Interface which is provided to allow for access to SD Secure Data MMC MultiMediaCard cards not shown and or eMMC embedded MultiMediaCard not shown . Both storage technologies are implemented on the basis of non volatile flash memory technology. In some embodiments multiple instances of storage HUB and or interfaces provided with the storage HUB may be implemented with each instance configured to control a respective bank of system memory. Memory storage HUB may be configured to interface to any suitable type of mass storage interfacing standards including in particular flash memory storage standards SD MMC SAS Serial Attached SCSI SATA Serial ATA and the like.

The multi core SoC may comprise a dedicated graphics sub system . The graphics sub system may be configured to manage the transfer of data between the multi core SoC and graphics sub system for example through the interconnect bus . The graphics sub system may include one or more processor cores for supporting hardware accelerated graphics generation. The graphics generated by the graphics sub system may be outputted to one or more displays via any display interface such as LVDS HDMI DVI and the like.

As will be appreciated the multi core SoC may be configured to receive data from sources other than system memory. To this end a network interface engine may be configured to provide a central interface for handling Ethernet and SPI interfaces thus off loading the tasks from the cores. In addition a high speed serial interface may be configured to support one or more serial RapidIO ports a PCI Express Controller and or a serial Gigabit Media Independent Interface SGMII . In addition one or more interfaces may be provided which are configured to couple the cores to external boot and or service devices such as I O interrupt concentrators UART device s clock s timer s reset hardware semaphore s virtual interrupt s Boot ROM I2C interface GPIO ports and or other modules.

Instructions for the operating system applications and or programs may be in mass storage or memory which are in communication with processor cores through communications fabric . In these illustrative examples the instructions are in a functional form on a non transitory tangible medium such as a persistent mass storage. These instructions may be loaded into memory for running by processor cores . The processes of the different embodiments may be performed by processor unit using computer implemented instructions which may be in a memory. These instructions are referred to as program code computer usable program code or computer readable program code that may be read and run by one or more processor cores in the SoC . The program code in the different embodiments may be embodied on different physical or computer readable non transitory tangible storage media.

Program code may be in a functional form on computer readable medium that may be selectively removable and may be loaded onto or transferred to data processing system for running by the one or more processor cores. Program code and computer readable medium form computer program product in these examples. In one example computer readable medium may be computer readable non transitory tangible storage medium. Computer readable storage medium may include for example an optical or magnetic disk that may be inserted or placed into a drive or other device that may be part of persistent storage for transfer onto a mass storage device such as a hard drive that may be part of persistent storage. Computer readable storage medium also may take the form of a persistent storage such as a hard drive a thumb drive or a flash memory that may be operably coupled to data processing system. In some instances computer readable storage medium may not be removable from data processing system.

Alternatively program code may be transferred to data processing system using computer readable signal medium. Computer readable signal medium may be for example a propagated data signal containing program code. For example computer readable signal medium may be an electromagnetic signal an optical signal and or any other suitable type of signal. These signals may be transmitted over communications links such as wireless communication links optical fiber cable coaxial cable a wire and or any other suitable type of communications link. In other words the communications link and or the connection may be physical or wireless in the illustrative examples.

In some illustrative embodiments program code may be downloaded over a network to a persistent medium from another device or data processing system through computer readable signal medium for use within data processing system. For instance program code stored in a computer readable non transitory tangible storage medium in a server data processing system may be downloaded over a network from the server to data processing system. The data processing system providing program code may be a server computer a client computer or some other device capable of storing and transmitting program code.

The different components illustrated for data processing system are not meant to provide architectural limitations to the manner in which different embodiments may be implemented. The different illustrative embodiments may be implemented in a data processing system including components in addition to or in place of those illustrated for data processing system. The different embodiments may be implemented using any hardware device or system capable of running program code.

As another example a storage device in data processing system may be any hardware apparatus that may store data. Memory persistent storage and computer readable medium are examples of storage devices in a tangible form in particular in a non transitory tangible form. In another example a bus system may be used to implement communications fabric and may be comprised of one or more buses such as a system bus or an input output bus. Of course the bus system may be implemented using any suitable type of architecture that provides for a transfer of data between different components or devices attached to the bus system. Additionally a communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. Further a memory may be for example memory or a cache such as found in an interface and memory controller hub that may be present in communications fabric.

According to an example of the present invention an approach to introduce a performance domain measurement instead of a time domain measurement for detecting interferences during time shared execution of two or more application tasks in a common computing shell providing resources shared among the executed tasks is suggested. The term performance may be understood as the amount of useful work accomplished by the common computing shell compared to the time required for execution. Herein the term computing shell or shell should be understood to comprise all hardware components of a processing system which are involved when instructions are executed including for instance instruction memory data memory central processing unit bus matrix connecting memory and bus clock generation unit reset and power up circuit voltage regulators interrupt generation and handling circuit.

Those skilled in the art immediately understand that the performance of a computing shell is inter alia determined by a response time upon invocation of hardware functionality such as an interrupt call and throughput e.g. rate of processing. Delay in response time and or reduced throughput may be experienced in particular when two or more separate applications are executed in multitasking mode e.g. in accordance with a time shared scheduling scheme in a single common computing shell. The skilled person is aware that in the aforementioned case resources of the common computing shell are shared between the separate applications and application tasks which instructions thereof are executed in a timely sequence. Sharing of resources between separate tasks causes necessarily interferences in the execution of a task due to changes in the state of the shared resources by a previously executed task which results in delay s of the execution of the currently executed one. As long as the level of interferences is within a range the processing of each task progresses and the tasks perform the programmatic functionalities within the required time window. However in the case that the interference level is above a threshold the progress in the processing of one or more of the tasks may be delayed to such an extent that the programmatic functionalities are not performed anymore within the required time window.

In the field of hardware and software development the use of information collected by so called performance monitoring tools is known. The performance data collected by the performance monitoring tools enables the developers to better understand how the hardware elements within the computing shell operate and interoperate with the operating system and the separate applications and tasks thereof executed in multitasking mode. The performance monitoring tools is attributed to the computer devices having become increasingly more complex. This growing complexity increases the difficulty of analyzing and understanding the dynamic behavior of the computer devices. When computer devices are built with low integration components hardware monitoring techniques are able to access and analyze signals of interest for understanding the operation and performance of the computer devices during development of software. But as computer devices become more complex and highly integrated these signals of interest can become inaccessible many times being sealed within the packages of the components. Moreover simulations of computer device behavior are incapable of providing a complete understanding of the performance of the computer device. For one such simulations run at significantly lower speeds than actual computer device operation. Consequently these simulations are unable to run large real applications within a useful period of time. Further the simulations cannot aid in understanding flaws that are produced during the implementation of the design or during the manufacture of the computer device. In order to provide a window of visibility into the behavior of computer devices microprocessors have begun to include on chip performance counters for counting occurrences of important events during computer device operation. Important events can include for example cache misses instructions executed and I O data transfer requests. These counters can be set to interrupt the microprocessor upon a count overflow. Typically the microprocessors can also periodically examine the performance counters and thereby evaluate the performance of the computer device.

Referring now to a high level block diagram of an exemplary processing device of the present invention is illustrated which comprises at least one processor core for exemplarily describing detection of performance related events and generation of event signals in response thereto. In this example processor core has been implemented with an integrated safety interference unit to directly measure interference s occurring during simultaneous execution of tasks applications within the computing shell provided by the processor core . The safety interference unit will be described below in more detail. In some examples the safety interference unit may be situated outside of the processor core . The integrated safety interference unit may be operable to utilize data obtained by respective detector circuits which are implemented to detect and signalize performance related events.

For example a detector circuitry may be operably coupled to the instruction cache and instruction bus interface unit a detector circuitry may be operatively coupled to the data cache and data bus interface unit a detector circuitry may be operatively coupled to the memory management unit MMU a detector circuitry may be operatively coupled to the instruction decoding unit a context switch detector circuitry may be operatively coupled to the processor registers and a detector circuitry may be operatively coupled to a one or more processing units such as the floating point execution unit the inter execution unit and or the multiply unit.

For example the number of cache misses and hits may be detected using the detector circuitries and operatively coupled to the cache such that the detector circuitries and are enabled to detect cache misses and hits within the respective caches. The detectors are configured to signalized events relating to cache misses and hits within the respective caches.

For example the duration of bus arbitration delays may be detected using the detector circuitries and operatively coupled to instruction and data bus interface units such that the detector circuitries and are enabled to detect the bus interface being in waiting state for instance because at least one of the agents on the bus is not ready to participate in the communication. The detector circuitries are configured to signalize status events relating to bus arbitration delays in response to which the length of such delays can be measured for instance by using a gated counter configured to count the number of e.g. clock cycles which laps during a signalized status event relating to a bus arbitration delay.

For example the duration of context switching delays may be detected using the detector circuitry embedded in the context switching monitor and configured to signalize a context switch delay event. In analogy to the bus arbitration delay status event the detector circuitry is configured to signalize the status events relating to the context switch delays in response to which the length of such delays can be measured for instance by using a gated counter configured to count the number of e.g. clock cycles which laps during a signalized status event relating to a context switching delay.

For example the duration of a state change of the memory management unit MMU may be detected using the detector circuitry operatively coupled to the memory management unit such that the detector circuitry is enabled to signalize a state change event of the memory management unit MMU . In analogy to the bus arbitration delay status event the detector circuitry is configured to signalize the status events relating to the state changes in response to which the length of such delays can be measured for instance by using a gated counter configured to count the number of e.g. clock cycles which laps during a signalized status event relating to a state change.

For example the duration of power saving may be detected using the detector circuitry operatively coupled to power control unit of a processor processing core such that the detector circuitry is enabled to signalize a power saving state event. In particular the detector circuitry may be operatively coupled to a clock signal generation circuitry comprising a phase locked loop for clock signal generation. The detector circuitry is configured to determine a reduction of a clock frequency e.g. by modification of the clock divider and the detector circuitry supplies signal indicative of the power saving state event as long as the reduced clock cycle signal is active. In analogy to the aforementioned state events the detector circuitry is configured to signalize the status events relating to the state changes in response to which the length of such delays can be measured for instance by using a gated counter configured to count the number of e.g. clock cycles which laps during a signalized state event relating to a power saving state.

For example the latency of a service request interrupt may be detected using a detector circuitry operatively coupled to the interrupt controller. The latency of a service request interrupt may relate to the duration that is required after the service request interrupt has been registered at an interrupt controller and the corresponding routine thereof is processed. The detector circuitry operatively coupled to the interrupt controller is enabled to signalize active pending interrupt state events. In analogy to the aforementioned state events the detector circuitry is configured to signalize the status events relating to the active pending interrupts in response to which the length of such latency can be measured for instance by using a gated counter configured to count the number of e.g. clock cycles which laps during a signalized state event relating to active pending interrupts. Hence as long as one or more un serviced interrupts are active pending or scheduled the gated counter is enabled and the counter continues counting in accordance with the clock signal.

Referring now to schematic high level block diagrams of example event performance counters are illustrated.

An exemplary event performance counter implementation shown in may receive a plurality of event signals for example instruction data cache miss event signals instruction data cache hit event signals branch instructions and the like which may be operably coupled into a mask register for example a configurable mask register which may be utilised for selecting the event signals of interest for example using bitwise AND operations on the basis of a configurable selection register. The mask register may be operably coupled to a logic module for example a multiple input OR gate as exemplarily illustrated to combine the selected event signals. The combined signal outputted by the logic module is further supplied to one or more counter which are operably coupled to the logic module. Each combined signal outputted by the logic module increases or decreases the counter value by a predefined increment decrement value. The counter may be resettable and or pre settable. The count value of the counter may be further readable.

An exemplary state event performance counter implementation shown in may receive a plurality of state event signals for example bus arbitration delay state events context switching delay state events state change state events power saving state events and the like which may be operably coupled into a mask register for example a configurable mask register which may be utilised for selecting the state event signals of interest for example using AND operations on the basis of a configurable selection register. The mask register may be operably coupled to a logic module for example a multiple input OR gate as exemplarily illustrated to combine the selected state event signals. The combined signal outputted by the logic module is supplied to a further logic module which operably coupled to the logic module. The further logic module e.g. using AND operation logically combines the combined signals with a clock signal. The resultant clock combined signal outputted by the further logic module is supplied to one or more counters which increases or decreases the counter value by a predefined increment decrement value. As a result of the clock combined signal the counter is increased decreased with each cycle of the clock signal as long as the states signalized by the selected state events are valid or active or pending . The counter value represents a measure of the duration of the selected event states. The counter may be resettable and or pre settable. The count value of the counter may be further readable.

An exemplary service request interrupt counter implementation shown in may receive a plurality of signals relating to registered interrupt requests. The registered interrupt request signals may be operably coupled into a mask register for example a configurable mask register which may be utilised for selecting the event signals of interest for example using bitwise AND operations on the basis of a configurable selection register. The mask register may be operably coupled to a logic module for example a multiple input OR gate as exemplarily illustrated to combine the selected service request interrupt request signals. The combined signal outputted by the logic module is supplied as an enabling signal to one or more counters which operably coupled to the logic module. The combined signal outputted by the logic module is supplied to one or more counters which increases or decreases the counter value by a predefined increment decrement value in accordance with a clock signal supplied thereto. As a result of the combined signal the counter is increased decreased with each cycle of the clock signal as long as the selected service requests interrupts are active or pending . The counter value represents a measure of the active pending time of the selected service requests interrupts.

Referring to a schematic high level block diagram of example performance counter is illustrated which allows for determining execution time statistics of the instruction execution. The instructions decoded by the instruction decoder of a processor processor core may be latched and supplied to an instruction classifier which generates one or more instruction classification signals in accordance with a predefined classification definition applied to the latched decoded instruction. The instruction classifier may be configurable. The one or more instruction classification signals may be further supplied to a configurable mask register which may be utilised for selecting the instruction classification signals of interest for example using AND operations on the basis of a configurable selection register. The mask register may be operably coupled to a logic module for example a multiple input OR gate as exemplarily illustrated to combine the selected instruction classification signals. The combined signal outputted by the logic module is supplied to a further logic module which operably coupled to the logic module. The further logic module e.g. using AND operation logically combines the combined signals with a stall signal outputted by the instruction execution unit processing the decoded instructions. The resultant combined signal is supplied as an enabling signal to one or more counters which increases or decreases the counter value by a predefined increment decrement value in accordance with a clock signal supplied thereto. As a result of the combined signal the counter is increased decreased with each cycle of the clock signal as long as the instruction execution unit signalizes that the execution of the instruction is stalled. The instruction classifier may be applied to select instructions which are executed at one or more specific instruction execution units including for instance the integer execution unit the vector and floating point execution unit and the multiply unit. It is understood that the above described implementations described with regard to high level block diagrams are illustrative with regard to the basic functionality of performance counter implementations.

With regard to a further schematic high level block diagram of an example implementation of a configurable performance counter is illustrated. The performance counter unit is a representative example of each unit and in the processing device . The performance counter unit receives the performance related signals including in particular the aforementioned event signals state event signals service request interrupt signals and or signals relating to execution time statistics. The performance related signals are provided through an event bus or a data bus operating a protocol to transport the performance related signals.

The performance counter unit includes an event signal selector and event signal combine and counter . The event signal selector receives event signals from the processing system and issues signals to the event signal combiner . The event signal combiner is coupled to the counter by signals . The counter is coupled to the processing system by read write R W data line and interrupt line.

During the operation of the processing device instructions of an application program are executed. When a certain condition triggers a performance related event the processing device and detector circuitries thereof may generates an event signal on the bus . The performance counter unit receives the event signals generated by the processing system and detector circuitries thereof. Each other performance counter unit and may receive the same event signals as the performance counter unit . The event signal selector selects a subset of event signals from the event signals . The event signal selector may be configurable by software executed on the processing device to select a subset of zero one or more event signals from the event signals .

The event signal combiner receives the event signals of the subset selected by the event signal selector and combines these signals to produce new event signals that enables or triggers the counter to increase decrease by a predetermined increment decrement. An accumulated count associated with the new event signals is maintained in the counter . An underflow overflow detector operably coupled to the counter may issue an interrupt signal on an interrupt line when the accumulated count of the counter underflow or overflow. The processing device may read or write the counter via R W data lines to obtain an ongoing analysis of the performance of the computer system with respect to the new event signals . The processing device may also write to the counter such as to preset the counter to a predetermined value.

As briefly introduced above measures have to be put in place to reduce the risk of interference if software applications with different functional safety criticality is executed in one computing shell. Functional safety criticality is associated with a level of the safety integrity which is required in a specific use case. A performance interference may reduce the performance of the processing unit while processing a safety critical software application due to interference of a second software application having a different level of safety criticality. The present patent application suggests a methodology implemented in hardware detecting possible performance interferences such that measures can be taken to react or counteract within a short period of time in order to maintain and or restore the functionality of a functional safety circuital application.

Safety critical software application represents software an inadvertent action of which might be directly responsible for death injury occupational illness or significant operation or a result of an action of which would be relied on for decisions which might cause death injury or other significant actions. Safety critical application is typically operated in a safety critical environment which is one in which a computer software activity process functions etc. whose errors such as inadvertent or unauthorized occurrences failure to occur when required erroneous values or undetected hardware failures can result in a potential hazard or loss of predictability of system outcome.

Hence it is understood that an encapsulation of applications having different safety criticality is of increasing interest. An encapsulation in the address domain is for instance obtained by using memory protection units MPU or memory management units MMU . However encapsulation in the performance domain is currently handled by imprecise time based measures so called watchdogs. Watchdog timer require a periodic trigger. Within the critical task respective trigger points are included. At these trigger points the watchdog timer is software triggered. However the precision to trigger these timers is not very high as an application may take longer or shorter dependent on the data processed data dependent on instruction execution times input dependent data the number of loops to be passed etc.

The safety interference unit according to examples of the present patent application therefore introduces a measurement of inferences in the performance domain instead of the time domain. Such action allows for reducing the safety risk that one safety critical application interferes with a second application causing dangerous malfunction due to too low processing performance because of interference. By detecting interferences the processing system may be switched into a safe state before a malfunction thereof may result in harms of the health or the life of users. The detection of interference should be performed in a time span shorter than the time an erroneous system requires to endanger health of life of people the so called fault tolerant time interval. The performance of a computing shell is characterized by the amount of useful work accomplished by a computing shell compared to the time. For instance an embedded computing shell performance but not limited thereto involves in particular the following 

Targeting performance domain interference of applications executed in a time sharing environment by one computing shell requires quantifying disturbances due to interferences in the performance domain. In particular inferences occur due to sharing of state based resources.

The currently used called timeout watchdog or window watchdog to measure the time duration an application and a task thereof requires to complete its execution. However processing shells are less deterministic in the time domain for instance because of more and more speculative operations performed within a processor or processor core. In case the speculations are correct the results are available earlier however in case the speculations are wrong the same instruction requires longer. Further the hierarchical memory system including different levels of date and or instruction caches also tries to speculatively pre fetch and store data and instructions. In case the speculative fetches were correctly predicted execution time is fast however it may slow down significantly the performance in case predicted behavior did not meet the application behavior. The execution time relies heavily on the executed instructions the processed data the number of context switches interrupt etc. As a consequence the time windows for time domain performance monitoring using timeout watchdogs or window watchdogs have to be wider and wider.

Referring now to a block diagram of a safety interference unit according to an example of the present patent application is schematically illustrated. The safety interference unit comprises or has access to one or more performance counters to which have been described with references to various illustrative examples thereof. As exemplified above a logic in particular a configurable may be provided to detect event signals communicated over a bus are any other suitable one or more signal lines to an event signal selector and or event signal combiner which passes or generates clock enable signals for a respective one of the performance counters to which increase or decrease their counter values in response to the passed generated signals. Accordingly one or more performance related events are associated or associatable with an individual performance counter to . The performance related events are detected and signalized by detector circuitries provided at or within specific parts of the processing device as illustrated above with respect to the exemplary performance counters.

The values of the performance counters may be accessible for read and or write operations. A read access operation retrieves the current value of the performance register. A write access operation set resets and or initialize the performance counter to for instance a specific value which may be a predefined value or default value. Depending where the counters are located the value thereof may be read out either as a set of registers or as a set of memory locations through memory mapped registers MMR or memory mapped input output MMIO . The performance counters may be accessed by hardware and or software.

The performance counters to may be 32 bit counters. However in other examples other counter sizes may be used. The safety interference unit may for instance comprise a plurality of registers which are utilised as an interface to the performance counters to to count performance relevant events.

The safety interference unit may further comprise a counter selector which is in particular configurable to select one or more values retrieved from the performance counters to for being analyzed in order to detect any interferences on the basis of the values obtained from the performance counters to . The counter selector is operatively connected to the one or more performance counters to .

The selected performance counter values are supplied by the counter selector to a comparator operatively coupled thereto. The comparator is configured to analyze the performance counter values supplied thereto. The performance counter values to be analyzed may comprise counter values of one or more selected performance counters to . The comparator of the safety interference unit may be configurable. For instance the comparator may be configurable to compare the performance counter values supplied thereto with respective reference values which may be implemented as a set of registers of as a set of memory locations through memory mapped registers MMR or memory mapped input output MMIO . The reference values may be accessible for read and or write operations. A read access operation retrieves one or more reference values. A write access operation set resets and or initialize one or more references values to for instance specific values which may be predefined values or default values.

The comparator may be configured to compare the performance counter values with the respective reference values in order to detect whether the performance counter values are within boundary conditions defined on the basis of the reference values. In particular the comparator may be configured to detect overflow or underflow of the performance counter values with respect to respective reference values representing overflow and or underflow threshold values and to generate a detection signal in case a performance interference is detected. The detection signal is to be supplied to a signal generator generating an interference indication signal in response to the detection signalized by the comparator .

In a further example of the present application the comparator may be configured to calculate a convolution value of performance counter values of one or more selected performance counters and reference values. The reference values may be obtained during the development of the functional safety circuital application for instance by simulation runs in combination with one or more further applications. A convolution value calculated by the comparator below a threshold which is specific for the functional safety circuital application is indicative of a processing flow of the functional safety circuital application differing from the expected intended processing flow defined on the basis of the reference values. The convolution value may be understood to represent a value representative of the level of matching of the processing flow monitored on the basis of the performance counters and the values thereof. The higher the level of matching the more similar the processing flow with the expected intended one.

Schematic implementations of a convolution based comparator are exemplified with reference to . Performance counter values of one or more selected performance counters are convolved with reference values in particular predetermined reference values and the convolution result is compared with a threshold value in particular a predetermined threshold value. The convolution may be applied to performance counter values of one or more selected performance counters or the convolution may be applied to ratios determined from the performance counter values of one or more selected performance counters. The performance counter value ratios may be obtained by applying a base value or individual base values. The base values may be a time dependent value in order to obtain ratios representing time normalized performance counter values. For instance the ratios may be normalized with respect to a period of time over which the performance counters have been counted the signalized performance related events.

In case that the convolution value is below the threshold an indication signal may be generated which indicates that counter values of the selected performance counters differ from the expected intended counter values in turn may indicate that the processing flow e.g. the processing behavior of the application differs from the expected processing flow e.g. the expected processing behavior of the application . The threshold may be understood to define a degree of difference or degree of similarity and is in particular configurable. With respect to the examples of the reference values e.g. golden reference values the base values and or the threshold may be implemented as a set of registers of as a set of memory locations through memory mapped registers MMR or memory mapped input output MMIO .

The comparator may repeatedly perform the comparison operation in particular cyclically and more particularly periodically. The repetition of the comparison operation performed by the comparator may be configurable.

In case the detected performance interference determined by the comparator is out of bound e.g. too low interference or too high interference with respect to underflow and overflow thresholds respectively or the processing flow of an application does not show the expected behavior an interference indication signal in time domain or value domain signal may be generated and signalized by an interference signal generator of the safety interference unit . The interference signal generator operably coupled to the comparator may be arranged to generate different interference indication signals which comprises 

an interference indication signal may be a service request or may cause a service request which may be directed to the functional safety critical application which enabled the functional safety critical application to react and repair interference issues in real time for instance in that the functional safety critical application is executed at a higher priority level which enables the functional safety critical application to have assigned a larger share of the total processing time shared among the applications executed at the processing system 

an interference indication signal may be a hardware fault signal or may cause a hardware fault signal which switches the processing unit or processing system at which the functional safety critical application is executed into a failsafe state as the detected interference may infringe the safety function or safety requirements thereof 

an interference indication signal may be a hardware fault signal or may cause a hardware fault signal which triggers a reboot e.g. a reset of the processing device or processing system or components thereof at which the functional safety critical application is executed and

an interference indication signal may be a hardware fault signal or may cause a hardware fault signal which disables one or more components of the processing device or processing system at which the functional safety critical application is executed in particular one or more input output IO components may be disabled such as serial multiplexed bus communication e.g. CAN or FlexRay communication to mention some known communication standards.

The interference signal generator is configurable. In some examples the generator is configurable to generate signals dependent on one or more performance counter values on the basis of which the comparator has detected an interference.

It should be noted that configurability of the safety interference unit and components thereof should be understood in that a programming interface such as an application programming interface API is provided through which a configuration of the safety interference unit and components thereof is obtainable.

Moreover one or more components of the safety interference unit may be software implemented in particular one or more software implemented components of the safety interference unit may be executed as a privileged application at a same processor core or as an application at another processor core in order to ensure that the detection of application interferences is performed at a predefined reliability level with regard to its functionality and responsiveness.

Referring to a time sequence diagram schematically illustrating interference detection with regard to an example computing shell within which a functional safety critical application and a non functional safety critical application are executed. The non functional safety critical application should be understood to be representative of one or more application which are non functional safety critical or have a functional safety critical level lower than that of the functional safety critical application. The individual instructions of the applications are executed in time sharing at the same computing shell providing shared resources for the applications. The execution of the exemplified functional safety critical application may one or more sections of the execution flow subjected to functional safety criticality and one or more sections subjected to a functional safety criticality of a lower safety level including non safety relevant level. The interference detection is operated at least during the execution of execution flow sections subjected to a functional safety criticality.

As illustratively shown in at a stage the safety interference unit is configured which may include the configuration of the performance counters . The configuration may comprise a configuration in accordance with which performance counters are to be monitored by the safety interference unit and may further comprise a configuration of the performance counter logic to count the respective events. The configuration may be performed by the functional safety critical application. In particular functional safety critical application may configure the reference values base values and or thresholds of the safety interference unit e.g. through an application programming interface API .

The safety interference detection may be automatically started upon configuration of the safety interference unit or as illustratively shown upon an instruction e.g. from the functional safety critical application to the safety interference unit at stage . In conjunction with the instruction to start detection of interferences the performance counters the values of which are monitored by the safety interference unit may be set or reset to a predetermined values.

The safety interference unit then retrieves the performance counter values of the performance counter selected in accordance with the configuration in order to detect interferences on the basis of the comparison operation performed at the safety interference unit with respect to the reference values. As illustratively shown in the safety interference unit may repeatedly retrieve the performance counter values in accordance with detection intervals e.g. stage and . After each retrieval the selected performance counters may be again set or reset to predetermined values e.g. stages and .

The detection intervals may be equidistant in time for instance triggered by a timer internal or external to the safety interference unit . In general the detection intervals may have the same length in time or vary in length may be regular or may be periodically.

The monitoring and detection of interference events by the safety interference unit may be stopped or suspended upon an instruction e.g. from the functional safety critical application to the safety interference unit at stage .

During the monitoring of the performance counter values the safety interference unit may detect an interference event. As described above upon detection of an interference event by the safety interference unit an interference indication signal is generated and issued e.g. to the functional safety critical application as illustratively shown at stage .

With reference to the stages to an operation of an exemplary safety interference unit is illustratively shown which monitors the performance counter values normalized against time. Accordingly the performance counter values may be retrieved in accordance with a detection interval and normalized with respect to the detection time interval. A setting or resetting of the performance counter values may be omitted in this case.

Those skilled in the art understand on the basis of the above description that the properties and features described with respect to one or more examples may also apply to and or combinable with other examples.

According to an example of the present application an exemplary apparatus for detecting software interference comprises a processor and at least one shared resource forming a computing shell which is configured to execute a first functional safety critical application and at least one second application in time shared operation one or more performance counters each of which is configured to adjust a counter value in response to a performance related event detected at the apparatus in response to execution of the first and the at least one second applications a reference value storage which is configured to store one or more threshold values wherein each of the one or more reference values is associated with one of the one or more performance counters a comparator which is operatively coupled to the one or more performance counters and configured to receive the one or more counter values therefrom to compare the one or more counter values with the respective threshold value retrieved from the reference value storage and to generate at least one comparison signal in response to results of the one or more comparisons and an interference indication generator which is operatively coupled to the comparator to receive the at least one comparison signal and configured to generate at least one interference indication in response to the at least one received comparison signal.

According to an example of the present application the comparator is further configured to detect underflow and or overflow of the counter values with respect to the respective threshold value.

According to an example of the present application the comparator is further configured to calculate a convolution value on the basis of the one or more counter values received from the one or more performance counters and one or more reference value retrieved from the one or more reference value storage configured to store the one or more reference value.

According to an example of the present application the comparator is further configured to calculate counter value ratios on the basis of one or more base values wherein the one or more ratio base values comprises at least one or a period of time and one or more ratio base values each associated with one of the one or more performance counters. The comparator is also configured to compare the one or more counter value ratios with the respective threshold value retrieved from the reference value storage.

According to an example of the present application the interference indication comprises at least one of an interference indication to the functional safety critical application an interference indication to the processor for switching into a failsafe state an interference indication to trigger a reboot of the processor and an interference indication signal to disable one or more components of the processor.

According to an example of the present application the apparatus for detecting software interference further comprises a counter selector operably inter coupled between the performance counters and the comparator is configured to select a subset of performance counters form the one or more performance counters and to supply the counter values of the selected subset of performance counters to the comparator.

According to an example of the present application a method for detecting software interference between a first functional safety critical application and at least one second application executed in time shared operation in a computing shell formed of a processor and at least one shared resource is suggested. One or more performance counter values are received from one or more performance counters each configured to adjust a counter value in response to a performance related event detected at the apparatus in response to execution of the first and the at least one second applications. The one or more performance counter values are compared with the respective threshold value retrieved from a reference value storage configured to store the one or more threshold values wherein each of the one or more reference values is associated with one of the one or more performance counters. At least one comparison signal is generated in response to results of the one or more comparisons. And at least one interference indication is issued in response to the at least one received comparison signal.

Thus examples of the invention may be implemented in a computer program for running on a computer system at least including code portions for performing steps of a method according to the invention when run on a programmable apparatus such as a computer system or enabling a programmable apparatus to perform functions of a device or system according to the invention.

A computer program is a list of instructions such as a particular application program and or an operating system. The computer program may for instance include one or more of a subroutine a function a procedure an object method an object implementation an executable application an applet a servlet a source code an object code a shared library dynamic load library and or other sequence of instructions designed for execution on a computer system.

Thus the computer program may be stored internally on computer readable storage medium or transmitted to the computer system via a computer readable transmission medium. All or some of the computer program may be provided on computer readable media permanently removably or remotely coupled to an information processing system. The computer readable media may include for example and without limitation any number of the following magnetic storage media including disk and tape storage media optical storage media such as compact disk media e.g. CD ROM CD R etc. and digital video disk storage media non volatile memory storage media including semiconductor based memory units such as FLASH memory EEPROM EPROM ROM ferromagnetic digital memories MRAM volatile storage media including registers buffers or caches main memory RAM etc. and data transmission media including computer networks point to point telecommunication equipment and carrier wave transmission media just to name a few.

A computer process typically includes an executing running program or portion of a program current program values and state information and the resources used by the operating system to manage the execution of the process. An operating system OS is the software that manages the sharing of the resources of a computer and provides programmers with an interface used to access those resources. An operating system processes system data and user input and responds by allocating and managing tasks and internal system resources as a service to users and programs of the system.

The computer system may for instance include at least one processing unit associated memory and a number of input output I O devices. When executing the computer program the computer system processes information according to the computer program and produces resultant output information via I O devices.

Examples of the invention may also be implemented in a computer program for running on a computer system at least including code portions for performing steps of a method according to the invention when run on a programmable apparatus such as a computer system or enabling a programmable apparatus to perform functions of a device or system according to the invention.

A computer program is a list of instructions such as a particular application program and or an operating system. The computer program may for instance include one or more of a subroutine a function a procedure an object method an object implementation an executable application an applet a servlet a source code an object code a shared library dynamic load library and or other sequence of instructions designed for execution on a computer system.

The computer program may be stored internally on computer readable storage medium or transmitted to the computer system via a computer readable transmission medium. All or some of the computer program may be provided on computer readable media permanently removably or remotely coupled to an information processing system. The computer readable media may include for example and without limitation any number of the following magnetic storage media including disk and tape storage media optical storage media such as compact disk media e.g. CD ROM CD R etc. and digital video disk storage media non volatile memory storage media including semiconductor based memory units such as FLASH memory EEPROM EPROM ROM ferromagnetic digital memories MRAM volatile storage media including registers buffers or caches main memory RAM etc. and data transmission media including computer networks point to point telecommunication equipment and carrier wave transmission media just to name a few.

A computer process typically includes an executing running program or portion of a program current program values and state information and the resources used by the operating system to manage the execution of the process. An operating system OS is the software that manages the sharing of the resources of a computer and provides programmers with an interface used to access those resources. An operating system processes system data and user input and responds by allocating and managing tasks and internal system resources as a service to users and programs of the system.

The computer system may for instance include at least one processing unit associated memory and a number of input output I O devices. When executing the computer program the computer system processes information according to the computer program and produces resultant output information via I O devices.

In the foregoing specification the invention has been described with reference to specific examples of embodiments of the invention. It will however be evident that various modifications and changes may be made therein without departing from the broader spirit and scope of the invention as set forth in the appended claims.

Those skilled in the art will recognize that the boundaries between logic blocks are merely illustrative and that alternative embodiments may merge logic blocks or circuit elements or impose an alternate decomposition of functionality upon various logic blocks or circuit elements. Thus it is to be understood that the architectures depicted herein are merely exemplary and that in fact many other architectures can be implemented which achieve the same functionality.

Any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermediary components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

Furthermore those skilled in the art will recognize that boundaries between the above described operations merely illustrative. The multiple operations may be combined into a single operation a single operation may be distributed in additional operations and operations may be executed at least partially overlapping in time. Moreover alternative embodiments may include multiple instances of a particular operation and the order of operations may be altered in various other embodiments.

Also for example in one embodiment the illustrated examples may be implemented as circuitry located on a single integrated circuit or within a same device. For example the interference counter may be integrated within a processor core or be a separate module within a computing system operable to communicate with the processor core for example. Alternatively the examples may be implemented as any number of separate integrated circuits or separate devices interconnected with each other in a suitable manner.

Also for example the examples or portions thereof may implemented as soft or code representations of physical circuitry or of logical representations convertible into physical circuitry such as in a hardware description language of any appropriate type.

Also the invention is not limited to physical devices or units implemented in non programmable hardware but can also be applied in programmable devices or units able to perform the desired device functions by operating in accordance with suitable program code such as mainframes minicomputers servers workstations personal computers notepads personal digital assistants electronic games automotive and other embedded systems cell phones and various other wireless devices commonly denoted in this application as computer systems .

However other modifications variations and alternatives are also possible. The specifications and drawings are accordingly to be regarded in an illustrative rather than in a restrictive sense.

In the claims any reference signs placed between parentheses shall not be construed as limiting the claim. The word comprising does not exclude the presence of other elements or steps then those listed in a claim. Furthermore the terms a or an as used herein are defined as one or more than one. Also the use of introductory phrases such as at least one and one or more in the claims should not be construed to imply that the introduction of another claim element by the indefinite articles a or an limits any particular claim containing such introduced claim element to inventions containing only one such element even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an . The same holds true for the use of definite articles. Unless stated otherwise terms such as first and second are used to arbitrarily distinguish between the elements such terms describe. Thus these terms are not necessarily intended to indicate temporal or other prioritization of such elements. The mere fact that certain measures are recited in mutually different claims does not indicate that a combination of these measures cannot be used to advantage.

