---

title: Device security using an encrypted keystore data structure
abstract: Apparatus and method for data security through the use of an encrypted keystore data structure. In accordance with some embodiments, first and second sets of input data are respectively encrypted using first and second encryption keys to form corresponding first and second encrypted data sets. The first and second encryption keys are combined to form a string. A hidden key stored within a system on chip (SOC) is used to encrypt the string to form an encrypted keystore data structure, and the first and second encrypted data sets and the encrypted keystore data structure are stored in a memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09443111&OS=09443111&RS=09443111
owner: Seagate Technology LLC
number: 09443111
owner_city: Cupertino
owner_country: US
publication_date: 20140228
---
Various embodiments of the present disclosure are generally directed to data security in a data storage device.

In some embodiments first and second sets of input data are respectively encrypted using first and second encryption keys to form corresponding first and second encrypted data sets. The first and second encryption keys are combined to form a string. A hidden key stored within a system on chip SOC is used to encrypt the string to form an encrypted keystore data structure and the first and second encrypted data sets and the encrypted keystore data structure are stored in a memory.

In other embodiments an encryption engine uses first and second encryption keys to respectively encrypt first and second sets of input data to provide corresponding first and second encrypted data sets. A system on chip SOC integrated circuit device has an internal non volatile memory which stores a hidden encryption key. A keystore generation module combines the first and second encryption keys to form a string encrypts the string using the hidden encryption key to form an encrypted keystore data structure and jettisons the first and second encryption keys responsive to formation of the encrypted keystore data structure.

These and other features which characterize various embodiments of the present disclosure can be understood in view of the following detailed discussion and the accompanying drawings.

Data security schemes are used to reduce or eliminate unwanted access to data by unauthorized users of digital data storage systems. Data security schemes can employ a variety of security techniques such as data encryption and the generation of authorization hash codes.

Data encryption generally involves the transformation of an input data sequence plaintext to an encrypted output data sequence ciphertext using a selected encryption algorithm cipher . The cipher may utilize one or more pieces of auxiliary data keys to effect the transformation. In this context plaintext can include data that have been previously encrypted by an upstream encryption process.

Keyed message digest values can be used to ensure that a given set of data has not been altered by an attacker or process. Keyed message digest values can take a variety of forms such as but not limited to keyed hash message authentication codes HMACs etc. Generally a keyed message digest value is a code word that provides indications of tampering with e.g. changes to an associated data set. In some cases a hash can be applied to a set of data whether plaintext or ciphertext to generate a keyed digest value e.g. an HMAC etc. and both the data and the digest value can be stored to a memory. During an authentication operation the data can be retrieved and used to generate a new digest value that is compared to the original digest value. If the two digest values match it can be determined that no changes to the data have been made and the data can be safely used.

Some types of memory devices are configured to write each new version of a particular set of data to a different location within a memory such as in the case of flash memory arrays. Blocks of memory cells that store older versions of the data can be scheduled for erasure using a background garbage collection operation. If such erasures have not yet taken place at the time of a system attack an attacker may be able to locate multiple versions of the same data and or components of the security system e.g. encryption keys HMAC values etc. and use this information to access the stored data or perform other malicious actions.

Various embodiments of the present invention are generally directed to an apparatus and method for securing data stored to a memory of a data storage device. As explained below some embodiments provide a hidden encryption cryptographic key that is maintained in a secure internal location not normally available to an attacker. The hidden key may be provided within a system on chip SOC device such as an application specific integrated circuit ASIC using one time program OTP fuses or other internal non volatile memory.

A special keystore data structure also keystore value is encrypted by the hidden key and stored in a special non volatile memory location such as a serial flash memory of the data storage device. The keystore data structure incorporates various important system parameters such as encryption keys and counters used to protect other data stored within a main memory of the data storage device. The main memory may be a NAND flash memory rotatable memory etc.

The keystore data structure allows the data level encryption keys and other important system parameters to be stored in a single controlled location rather than distributing the system parameters across the device in different memory locations. This reduces access to both current and prior versions of the keys by an attacker making the data less susceptible to roll back attacks. A backup copy of the keystore data structure may be provided in another location within or outside the device.

When access to the system parameter information is required the system can forward the keystore data structure to the SOC for a decryption operation and the decrypted system parameter information from the keystore data structure can thereafter be used as needed by the system. The keystore data structure may be periodically updated in which case the previous version of the keystore data structure is removed from its memory location a secure erasure operation is applied to the memory location and the new keystore data structure is written to that memory location or to a new memory location. In this way only one version of the keystore data structure is normally available within the system.

Keyed message digest values such as but not limited to keyed hash message authentication codes HMACs are additionally employed by the system in some embodiments. Such codes generally operate to detect tampering alteration of a given data set. For example an HMAC value can be generated for and stored with the keystore data structure and used to authenticate the keystore data structure at times when the keystore data structure is accessed. Additional HMAC values or other types of digest values can be generated and distributed throughout the system to provide authentication of other data sets.

This provides a hierarchical security scheme organized to handle at least three different types of data within a data storage device 1 data for which no protection is provided 2 data for which authentication security is provided through the use of keyed message digest values e.g. the HMAC values and 3 data that is protected for confidentiality such as by being encrypted with one or more keys that are in turn protected via encryption. This latter category includes the keystore data structure itself as well as data sets that have been encrypted by the encryption keys embedded within the keystore data structure.

These and other features of various embodiments can be understood beginning with a review of which shows a generalized data storage device . The data storage device includes a controller and a memory module . The controller is a hardware based or programmable processor that provides top level control of the device . The memory module can take a variety of forms including solid state memory rotatable media flash memory spin torque transfer random access memory STRAM resistive random access memory RRAM etc. In some cases the functionality of the controller is directly incorporated into the memory module .

The data storage device is shown in to be operably connected to a host device . The host device can take a variety of forms such as a computer laptop tablet smart phone gaming console server controller or other interactive device. The data storage device provides data storage capabilities for the host device and to this end data access e.g. read write commands and data transfers may be exchanged between the host device and the data storage device .

The host device incorporates various operational elements including a processor and a memory. Of interest is an interface . A user of the host device and or internal processes of the system may use the interface to communicate with the data storage device such as through the entry of a user password during a boot initialization operation. The interface can take any number of suitable forms and may include user interface aspects such as a display keyboard touch screen mouse etc. and application programming interface API elements.

The various memory modules are illustrative of different types of memory modules that can be coupled to the SOC and not all of the memory modules shown in may be present in a given embodiment. For example a hard disc drive HDD embodiment may use rotatable media in the form of optical or magnetic recording media as a main memory store and omit the NAND flash memory and the NV RAM memory . A solid state drive SSD embodiment may omit the rotatable media and use the NAND flash memory and or the NV RAM memory as the main memory store. A hybrid embodiment may utilize each of the memories shown in . Other memory modules can be incorporated as well.

The SOC provides controller functionality for the data storage device . To this end the SOC includes an internal memory location to which is stored a hidden cryptographic key. The internal memory location may be formed of one time programmable OTP fusible links or may take some other form. The hidden key can be any suitable length and can be generated using a variety of methods. It is contemplated that the hidden key may be unique to the SOC and is generally not accessible outside the SOC .

As explained below the hidden key is used to generate a keystore data structure as an encrypted ciphertext string. The encrypted keystore data structure is stored in one or more suitable memory locations in the system. The example shown in stores the keystore data structure at a selected address of the serial flash memory . In some cases the serial flash memory is a 64 KB NOR flash memory with 16 slots e.g. rows or blocks of 4 KB each and the keystore data structure is written to a selected one of the available 4 KB slots. However other memory locations for the keystore data structure are readily contemplated including one or more of the other non volatile memory modules e.g. the NAND flash memory or the rotatable media . In other embodiments the keystore is stored internally within the SOC in a suitable programmable memory location such as a block of rewriteable STRAM memory. A backup copy of the keystore data structure can be stored in the serial flash memory or elsewhere as discussed below.

The cipher algorithm uses one or more key s as inputs to control the data transformation. Any number of encryption cipher algorithms such as symmetric encryption algorithms can be employed as desired in conjunction with a confidentiality mode such as cipher block chaining CBC XTS XOR encrypt XOR counter CTR etc. The encryption can involve tweak values seed values counter values initialization vectors etc. in addition to the key value depicted in .

A variety of different types of data sets are stored to the respective first and second memories . A first listed form of the data sets in includes basic unprotected data which comprises data to which security protection mechanisms such as encryption or keyed message digest values have not been supplied. The basic data are subjected to normal processing that may include other mechanisms such as error correction codes ECC metadata etc. and may be protected from the standpoint of system level protections e.g. device passwords . Nevertheless no specific security measures are taken to individually protect the basic data. It is contemplated that an unauthorized entity may be able to ascertain the bit sequence of the unprotected data through normal interrogation of the associated memory .

A second listed form of the data sets in is data protected by keyed message digest values in this example HMAC values . The HMAC protected data are similar to the unprotected data in that the HMAC protected data are not encrypted using security measures prior to being stored in the first memory . The bit sequence of the HMAC protected data might be discovered by an unauthorized entity as before. However HMAC values more generally keyed message digest values are generated and stored with the protected data and the HMAC values can be used to determine whether the protected data have been altered e.g. to detect tampering .

The HMAC values for the protected data referred to as HMAC PD in can be generated in a variety of ways. Any suitable cryptographic hash function such as a message digest algorithm e.g. MD5 a U.S. National Institute of Standards and Technology NIST secure hash algorithm e.g. SHA 1 SHA 256 etc. may be used to generate the HMAC PD value depending upon the level of security employed. Multiple layers of hash functions or other operations can be incorporated into the generation of the HMAC PD value. The HMAC calculation can be carried out within the SOC .

During a write operation to write a set of protected data to the memory an HMAC PD value is generated and stored with the protected data. The HMAC PD can be placed immediately adjacent the protected data or a pointer can be used to locate the HMAC PD value in another location within the memory.

During a read operation a copy of the protected data is retrieved from the memory and subjected to the hash function to generate a new HMAC value. The new HMAC value is compared to the existing HMAC value in memory. If these two values are identical the copy of the protected data is authenticated and used as required.

The HMAC protected data can comprise higher priority user data as well as important system data such as a device serial number system security critical data etc.

Continuing with encrypted data sets are also stored to the first memory . The encrypted data sets may represent high priority data such as certain forms of secure user data system control data a device password etc. In some cases all user data received by the data storage device is encrypted by the device to form encrypted data sets. In other cases the user or SOC designates some user data sets for encryption and other user data sets as unprotected data. HMAC values HMAC ED can be generated and stored for each of the encrypted data sets as shown in case a non authenticating symmetric encryption confidentiality mode is used.

The encrypted data sets are encrypted using one or more cryptographic encryption keys as discussed above in . The keys are not stored to the main memory . Rather the keys are combined concatenated along with other important system parameters as required into a data structure e.g. string that is encrypted to form the keystore data structure discussed above in using the hidden key within the SOC . As shown in the keystore data structure or just keystore is stored in the second memory .

Once the keystore is formed and stored the encryption keys are discarded and not retained in the memory e.g. memories . The encryption keys can be formed using key derivation functions random or pseudo random number generators that provide random or pseudorandom values etc. The mechanism s for forming the encryption keys can be provided within the SOC or in some other circuitry. In some cases some or all of the keys or portions used to form the keys can be supplied by a user of the device. Regardless it will be appreciated that once the keystore is generated and stored copies of the keys in unencrypted form are not retained in a location susceptible to discovery by an attacking party.

In at least some embodiments a special HMAC value for the keystore HMAC KS is also generated and stored in the second memory . The HMAC KS value can be generated as discussed above and can be stored along with the keystore or in another suitable memory location. Generally the HMAC KS value can be used to authenticate the keystore e.g. determine that the keystore has not been subjected to tampering . Although not separately shown in a backup copy of the keystore may be stored elsewhere in the system.

While not limiting the first key Key can be used to encrypt a first encrypted data set in the main memory the second key Key can be used to encrypt a different second encrypted data set in the main memory and so on. In other arrangements the keys in the keystore can be used to encrypt other keys that in turn are used to encrypt user data or other values. Similarly the first counter Counter can be an internal count associated with a number of system access operations of a first type and so on. The keys and counter values can be internally generated or externally supplied. The secure nature of the keystore allows important system parameters to be stored in a single location under the protection of encryption by the hidden key .

In the routine commences at step with a device initialization which can include the application of power to transition the associated data storage device from a non powered or low powered state to an operational state. During this operation the user of the device or a larger computer system with which the device is associated is prompted to enter a security password at step .

The routine passes to step where the keystore is retrieved from memory and supplied to the SOC for decryption using the hidden key in internal memory . This allows the authentic password to be recovered at step and the authentic password is compared to the entered password at step .

If the two passwords match decision step the flow passes to step where remaining aspects of the boot initialization routine are authorized to continue after which the device enters normal operation and the routine ends at step . On the other hand should the entered password not match the authentic password access is denied as shown by step and the device does not transition to the normal operational mode. It will be appreciated that any number of additional steps can be taken at this point such as prompting the user to enter a new password in which case the routine passes back to step to compare the newly entered password with the authentic password unlocked from the keystore. A counter can be initiated to track the total number of retries in order to set an upper limit such as 5 retries . If the upper limit is reached the device can be locked and made no longer responsive to attempts to reboot or otherwise access the system.

In some cases an unauthorized entity can attempt to power down and reinitiate the device boot sequence of after a number of failed password entries less than the upper limit in order to game the system and obtain additional attempts. The system can be configured such that after each unsuccessful retry a total count of unsuccessful retries during the current session is captured by a counter value and incorporated into a new keystore which is then written to non volatile memory prior to device shutdown. In this way even if the device is powered off and turned back on the password attempt history is retained and the rules governing the maximum number of permissible attempts are enforced.

While the routine of generally involves a boot initialization type operation the routine can be readily adapted for other types of access operations such as accessing password protected user data where prior to granting access a user or process enters a password or other key value to gain access to the protected data.

The HMAC protected data are retrieved at step and the associated HMAC value is retrieved at step . A new HMAC value is calculated at step using a key and optionally a counter value stored in the keystore for the data retrieved at step and the new HMAC value is compared to the retrieved HMAC value at step .

If the two HMAC values match decision step the flow passes to step where access to the retrieved data is authorized and the routine ends at step . In the case of keystore authentication the authenticated keystore can proceed to be decrypted by the hidden key and the decrypted contents from the keystore can be used as required. For example the password can be retrieved from the keystore and used for device access during a boot operation as described in . Alternatively a selected encryption key e.g. Key in can be released for use to decrypt previously encrypted data from the first memory once the keystore has been authenticated.

In the case of authenticated protected data the data can be released for transfer to a requesting host or other process once the HMAC values are found to match. Other alternative operations are contemplated and will readily occur to the skilled artisan in view of the present discussion.

Should the HMAC values not match the flow passes to step where access to the protected data is denied either temporarily or permanently. The fact that the HMAC values do not match indicates that some anomalous condition has arisen. In some cases the data retrieval steps and may be retried and a new HMAC value may be recalculated to account for inadvertent uncorrected errors in the retrieved data. Ultimately if the mismatch condition persists then some sort of tampering event may be declared and further access to the data in the current session will be denied. As desired a record of the mismatch can be generated and stored for future reference or analysis.

With reference to once it is determined that a new keystore is to be generated the existing keystore is retrieved from its existing memory location e.g. memory location and loaded to local DRAM e.g. DRAM in as shown by steps and . A new replacement keystore is generated at step . This can include replacing updating or adding additional data items to the string of important system parameters and then applying encryption using the hidden key within the SOC .

The newly generated keystore is stored in an appropriate non volatile memory location at step . In some cases a next available slot block of memory in the serial flash is selected for the storage of the updated keystore. As desired one or more backup copies of the keystore can also be stored at this time.

A secure erasure operation is applied to the memory location that stored the previous version of the keystore as shown at step . The secure erasure can include multiple write and erase operations to reduce the ability of an attacking party from discovering the bit sequence of the previous keystore. The previous version of the keystore in DRAM is also deleted at this time and as desired a new HMAC value for the new keystore is generated and stored. The routine then ends at step .

The routine commences at step where the encrypted data are retrieved from memory. As desired an associated HMAC value is also retrieved at step and a new HMAC value is generated at step . The two HMAC values are compared at step to authenticate the encrypted data set. If the two HMAC values match decision step the flow passes to step where the keystore is retrieved from memory and decrypted using the hidden key to retrieve the key for the encrypted data . It will be noted that failure of the HMAC authentication results in a denial of access step and termination of the routine at step . Thus while the HMAC authentication steps through are helpful in detecting tampering and avoiding an unnecessary decryption operation these steps can be omitted as desired.

Once the encryption key has been obtained from the keystore the retrieved key is used to decrypt the encrypted data set step . The decrypted data are thereafter returned to the requesting process at step and the routine ends at .

A feature of the SOC in is that both the hidden key and the keystore are not directly accessible outside the boundaries of the SOC and that the encryption operations are carried out internally.

In some cases the keystore generation module can further operate to encrypt various input data sets using respective encryption keys to provide encrypted data sets which are also stored in the memory and the HMAC generation module can be used to generate authorization codes e.g. HMAC values for the encrypted data sets.

Once the encrypted keystore data structure is generated the encryption keys are jettisoned so that the keys in unencrypted form are not retained by the device in a location accessible by an attacker e.g. the keys are not stored in the memory apart from being stored in encrypted from within the keystore . The keystore generation module and the HMAC generation module can be stand alone modules or incorporated into an SOC such as the SOC of .

The keystore generation module can further operate to decrypt the keystore to retrieve the contents of the originally generated string during an access operation. For example the keystore generation module can retrieve the original device password and compare this password to a password entered by a user during a boot initialization or other access operation as discussed above in .

While various embodiments of the present disclosure have been directed to the environment of a data storage device such is merely exemplary and not limiting. Any number of different types of systems including communication systems portable electronic systems medical devices etc. can incorporate the various features set forth herein.

It is to be understood that even though numerous characteristics and advantages of various embodiments of the present invention have been set forth in the foregoing description together with details of the structure and function of various embodiments of the invention this detailed description is illustrative only and changes may be made in detail especially in matters of structure and arrangements of parts within the principles of the present invention to the full extent indicated by the broad general meaning of the terms wherein the appended claims are expressed.

