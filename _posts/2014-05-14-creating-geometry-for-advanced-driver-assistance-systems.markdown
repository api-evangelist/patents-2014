---

title: Creating geometry for advanced driver assistance systems
abstract: A method and system for creating geometry for ADAS are described. Link chains, which are a sequence of segments, are created. The link chains are used to create 2D splines. The link chains, the 2D splines, and height data are used to create 3D splines. The 3D splines and possibly the 2D splines are converted to Bezier curves, which can be used to create a 2D polyline. ADAS applications can use the Bezier curves and the 2D polylines to provide ADAS functions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09068856&OS=09068856&RS=09068856
owner: HERE Global B.V.
number: 09068856
owner_city: Veldhoven
owner_country: NL
publication_date: 20140514
---
This application is a continuation under 37 C.F.R. 1.53 b and 35 U.S.C. 120 of U.S. patent application Ser. No. 12 540 704 filed Aug. 13 2009 which claims the benefit of U.S. Provisional Patent Application No. 61 101 752 filed Oct. 1 2008 and entitled CREATING GEOMETRY FOR ADVANCED DRIVER ASSISTANCE SYSTEMS. The full disclosures of U.S. Provisional Patent Application Ser. No. 61 101 752 and U.S. patent application Ser. No. 12 540 704 are incorporated herein by reference.

The present patent application is related to the copending patent application filed on Aug. 13 2009 Ser. No. 12 540 665 entitled BEZIER CURVES FOR ADVANCED DRIVER ASSISTANCE SYSTEM APPLICATIONS which is incorporated herein by reference.

The present invention relates generally to advanced driver assistance systems ADAS and more particularly relates to creating geometry for use in ADAS.

ADAS was developed to improve the comfort efficiency safety and overall satisfaction of driving. Examples of these advanced driver assistance systems include adaptive headlight aiming adaptive cruise control lane departure warning and control curve warning speed limit notification hazard warning predictive cruise control adaptive shift control as well as others. Some of these advanced driver assistance systems use a variety of sensor mechanisms in the vehicle to determine the current state of the vehicle and the current state of the roadway in front of the vehicle. These sensor mechanisms may include radar infrared ultrasonic and vision oriented sensors such as digital video cameras and LIDAR.

Some advanced driver assistance systems also use digital map data. These systems are sometimes referred to as map enhanced ADAS. The digital map data can be used in advanced driver assistance systems to provide information about the road network road geometry road conditions and other items associated with the road and terrain around the vehicle. Unlike some sensors the digital map data is not affected by environmental conditions such as fog rain or snow. In addition the digital map data can provide useful information that cannot reliably be provided by sensors such as curvature grade bank speed limits that are not indicated by signage lane restrictions and so on. Further digital map data can provide a predictive capability well beyond the range of sensors or even beyond the driver s vision to determine the road ahead of the vehicle around corners over hills or beyond obstructions. Accordingly the digital map data can be a useful addition for some advanced driver assistance systems.

The map enhanced advanced driver assistance systems commonly use data from a geographic database associated with a navigation system in a vehicle. The navigation system database contains data that represents the road network in the region such as the locations geographic coordinates including altitude of roads and intersections road names speed limits along roads turn restrictions at intersections addresses or address ranges along roads the number of lanes for each road lane width lane markings functional classes of roads the locations of medians and so on. The navigation system database may also contain information about other geographic features such as bodies of water parks administrative areas including municipal state and country boundaries and locations of points of interest such as businesses hospitals police stations and so on.

The navigation system database has much more data than an advanced driver assistance system needs. Additionally a geographic database designed for navigation may not have all the data and or may not have data with the accuracy levels needed by the advanced driver assistance system. As a result there has been some effort in designing a geographic database specifically for advanced driver assistance systems. For example U.S. Patent Publication No. 2006 0100780 describes a geographic database having a data storage format designed for a sensor device in a motor vehicle system. However there is room for improvement in a geographic database designed specifically for advanced driver assistance systems.

A method and system for creating geometry for ADAS are described. Link chains which are a sequence of road segments are created using a software routine. The software routine selects a first road segment having an associated functional class. At each node the software routine selects the next road segment to add to the link chain. The link chain continues to grow until finding a terminal node.

The link chains are fitted to create 2D B splines. The 2D B splines are manipulated to correct irregularities and alignment problems. Knots not needed to preserve the position curvature slope and or heading are removed to minimize storage requirements.

The link chains optimized 2D B splines and height data are used to create 3D splines. The height data is preferably obtained from GPS IMU traces collected as vehicles travel on roads represented by the road segments. The height data is corrected at crossing nodes to account for GPS height inaccuracies. The link chains are fitted to create an altitude B spline using the corrected height data. The 2D B spline and the altitude B spline are merged to obtain a 3D B spline Like the 2D B spline knots not needed to preserve the position curvature slope and or heading are removed from the 3D B spline to minimize storage requirements.

The 3D B splines and possibly the 2D B spines are converted to Bezier curves. The Bezier curves can be used to efficiently create 2D polylines and compute curvature slope and heading. ADAS applications can use the Bezier curves to provide ADAS functions and polylines for map matching.

These as well as other aspects and advantages will become apparent to those of ordinary skill in the art by reading the following detailed description with reference where appropriate to the accompanying drawings. Further it is understood that this summary is merely an example and is not intended to limit the scope of the invention as claimed.

The processor may be any type of processor controller or other computing device. For example the processor may be a digital signal processor. The processor receives inputs from the positioning system the geographic database the communication system the in vehicle data bus interface and other sources. The processor then processes the inputs using application software programs some of which are described with reference to .

The processor then provides outputs to the driver assistance applications via the in vehicle data bus interface and a data bus . Preferably the in vehicle data bus interface and the data bus are a Controller Area Network CAN interface and a CAN bus which are designed for automotive applications. The driver assistance applications may include adaptive headlight aiming adaptive cruise control obstruction detection obstruction avoidance collision avoidance adaptive shift control and others.

The positioning system may utilize GPS type technology a dead reckoning type system or combinations of these or other systems which are known in the art. The positioning system may also include suitable sensing devices that measure the traveling distance speed direction orientation and so on. For example the positioning system may include a GPS system and a gyroscope. The positioning system provides an output signal to the processor . Some of the application software programs that run on the processor use the output signal from the positioning system to determine the location direction orientation etc. of the MPE .

The geographic database is designed for ADAS applications. Like a navigation system geographic database the geographic database contains data about roads and intersections in a geographic region. For example the geographic database contains at least one database record also referred to as entity or entry for each road segment also referred to as a link . When the road segment is represented as B spline or Bezier curve s the road segment data record includes data providing the geographic coordinates e.g. the latitude longitude and altitude of control points. The end points also referred to as nodes of the road segment correspond to the first and last control points. Additionally the road segment data record may also contain a knot vector for B spline geometry.

When the road segment is represented as shape point geometry the road segment data record includes data providing the geographic coordinates e.g. the latitude longitude and altitude of the end points of the represented road segment. For curved segments the road segment data record also includes data providing the geographic coordinates e.g. the latitude longitude and altitude of the shape points used to characterize the polyline.

The geographic database may include higher quality i.e. more accurate data than the data typically contained in a navigation system geographic database. For example with respect to road geometry the data in the geographic database may be more accurate with respect to longitude latitude and or altitude. Also the starting and stopping locations of tunnels may be more accurately specified in the geographic database . Further the data in the geographic database may be more accurate with respect to derived information such as curvature.

The geographic database may also include more kinds of data e.g. more kinds of attributes than the data typically contained in a navigation system geographic database. For example the geographic database may include data about road objects such as signs and crosswalks including their positions along a road segment sign object type and sign text. Some of the data attributes found in the geographic database are described with reference to .

The map access application provides data access to the geographic database stored on physical storage media. The map access application receives a request for data from the processor and locates data responsive to the request on the physical storage media. The map access application preferably provides an application programming interface API for use by the processor and or the applications .

The map update application facilitates updates to the geographic database . The communications system receives one or more parcels that either add additional coverage to an existing database or replace existing parcels. A parcel is a unit of storage for storing geographic data in the geographic database on physical storage media. For new parcels the map update application stores the parcel on the physical storage media. For existing parcels the map update application replaces the old parcel with the new parcel on the physical storage media.

The vehicle positioning application determines the vehicle s position relative to a road network that is represented by data included in the geographic database . The vehicle positioning application uses the output from the positioning system and matches the output to data in the geographic database using a vehicle positioning algorithm which is sometimes referred to as a map matching algorithm.

The electronic horizon application determines an electronic horizon. An electronic horizon is a collection of roads and intersections leading out from the current vehicle position to an extent determined by the electronic horizon application . The collection of roads and intersections are potential paths that the vehicle may follow from the current vehicle position. The electronic horizon application determines extent using one or more costing functions. The costing functions are based on the needs of the driver assistance applications and may take into consideration various factors such as vehicle speed travel time and driving distance. An example electronic horizon application is described in U.S. Pat. No. 6 405 128 which is assigned to the same assignee as the current application and is hereby incorporated by reference in its entirety.

The interface application controls communications between the MPE and the driver assistance applications via the interface and the bus . Preferably the interface application is based on the CAN protocol which is a serial communication protocol for communicating between various electronic devices in the vehicle. In accordance with the CAN protocol the various electronic devices in the vehicle can be coupled to a single serial bus e.g. the bus such that messages and data can be sent from one electronic device in the vehicle to another. The CAN protocol is a message based protocol in which CAN frames are placed on a common CAN bus. The CAN bus may be a single wire or a differentially driven pair of wires.

The data also include control point data which identify the latitude longitude and altitude coordinate positions of control points that can be used to represent the shape of a straight or curved segment. While the data for two control points are shown in it is understood that a segment can contain more than one curve and the number of control points may depend on the number and shape of the curves in the segment. For example each cubic Bezier curve is represented by four control points but the last control point of a previous Bezier curve is the same as the first control point of the next Bezier curve. The road segment data record stores data for the number of control points equal to the number of Bezier curves multiplied by three plus one.

The data further include attributes for the segment. Some of the attributes of the segment are depicted in . The road segment data record may include additional data such as shape point data as well.

The control point attributes contain bit flags that provide additional information regarding control points to aid in the creation of curvature and slope profiles. For example the control point attributes may include a byte size flag per control point. One of the bits in the flag is assigned to curvature while another of the bits is assigned to slope. If the curvature bit flag is set to one then the control point is marked as part of the curvature profile. Similarly if the slope bit flag is set to one then the control point is marked as part of the slope profile.

The direction of travel attribute represents the allowed direction of traffic flow on a segment. For example the segment may represent a portion of a road network in which travel is permitted in both directions. Alternatively the segment may represent a portion of a road network allowing only one way travel. The direction of travel attribute identifies whether the segment allows bi directional travel or unidirectional travel and if unidirectional the direction of travel attribute also identifies the allowed direction of travel.

The speed category attribute represents the general speed trend of a road based on posted or implied speed limit. The speed category attribute contains data associated with a speed range. For example the speed category attribute may include a data representation of the integer 1 for speeds exceeding 80 mph the integer 2 for speeds in the range of 65 80 mph the integer 3 for speeds in the range of 55 64 mph and so on until the speed range includes 0 mph.

The lane category attribute represents the predominant number of lanes on a segment in one direction of travel. Preferably the lane category attribute does not include turn lanes. If the number of lanes is different for each direction the lane category attribute may represent the higher number.

The road type attribute represents the type of road and or functional class that the segment represents. For example the road type attribute may contain data associated with an interstate highway a controlled access highway a pedestrian walkway and so on.

The segment characteristic attribute contains bit flags that describe various characteristics of the segment. For example the segment characteristic attribute may identify whether a segment is paved a ramp a bridge a tunnel a roundabout and so on.

The access characteristic attribute contains bit flags that define the types of traffic allowed on the segment. For example the access characteristic attribute may identify whether cars buses trucks taxis emergency vehicles pedestrians and so on are allowed on the segment.

The tiles are formed in such a way that each tile contains approximately equal amount of nodes and shape points. The map surface is covered by an imaginary 2D rectangular grid with fine approximately 2 km by 2 km cells. Then the density of the nodes and shape points is computed by mapping the nodes and shape points in the geographic database onto the grid. The tiles are assembled from the grid cells.

In order to ensure that each tile has approximately equal number of nodes and shape points the whole grid is recursively subdivided in half along the grid lines both in horizontal and vertical directions in such a way that each of the two partitions contain an equal number of geometrical points. The process continues until the tiles contain an amount of nodes and shape points that is smaller than a predefined threshold. The direction of each subdivision is selected in such a way that the aspect ratio of the tiles is minimized.

At block the method creates link chains within each tile using data from the geographic database . The link chains are a sequence of segments with each of the segments having the same road type attribute . The sequence of segments is preferably made as long as possible. The link chains are used to perform a B spline fit to ensure smoothness across segment boundaries. The process of creating link chains is further described with respect to .

At block the method creates 2D B splines using the link chains created at block . At block the method creates 3D B splines using the link chains created at block the 2D B splines created at block and height data . The height data is preferably obtained from GPS IMU traces collected as vehicles travel on roads represented by the road segments. However the height data may be obtained from other sources and or sensors. The process of creating 2D B splines is described with respect to while the process of creating 3D B splines is described with respect to .

A spline refers to any composite curve formed with piecewise polynomial functions representing curve sections and satisfying specified conditions at boundaries of the sections. Thus there are many types of spline curves including B splines. A B spline has control points and knots. Knots are the points at which individual polynomial curve segments of a polynomial spline curve join together. The segments are joined in such a way as to provide smoothness of the complete curve. A knot vector is an ordered list of non decreasing floating point numbers that describe points along the spline curve where segments begin and end. Splines are well known in the art.

With splines map features including curving road portions are represented by polynomial equations whose coefficients have been determined so as to generate curves that match the shapes of the geographic features with the desired degree of accuracy. Thus splines are a means of describing the shape of the underlying road geometry by specifying the coefficients of a polynomial equation. As described in U.S. Pat. No. 7 084 882 splines have been used to represent shapes of road segments in navigation system databases. U.S. Pat. No. 7 084 882 is assigned to the same assignee as the current application and is hereby incorporated by reference.

At block the 2D B splines and the 3D B splines may be converted to Bezier curves. If a segment does not have height data the 2D B spline is converted to a Bezier curve. However if the segment does have height data the 2D B spline may only be used to create the 3D B spline at block .

Cubic Bezier curves are defined by two end points and two additional control points that are positioned along tangents to the curve at the end points. The cubic Bezier curve equation can be written in vector form as follows 1 3 1 3 1 where P P P and Pare the control points and t is the parameter. Bezier curves can be derived from B spline curves using known methods.

While spline geometry is useful for representing road segment geometry the use of B splines in the MPE increases the computational requirements for the vehicle positioning and the electronic horizon applications . The analytical B spline geometry is converted into a Bezier representation to facilitate real time derivation of a polyline representation by the vehicle positioning application and an electronic horizon by the electronic horizon application .

At block the Bezier curves are divided so that the vehicle positioning application can derive a 2D polyline representation in real time. The method assumes that the road geometry has Bezier curves such that when a point farthest from its chord is projected onto the chord line the point falls inside the chord. The Bezier road geometry is divided after identifying a point or possibly more than one point at a furthest distance or distances from the Bezier curve to a line connecting the end points of the curve i.e. the control polygon base chord right arrow over PP as shown in . Also seen in the furthest distance is generally not in the center of the curve.

The optimal subdivision point is the point on the Bezier curve that is the furthest from the control polygon base chord. The position of the point is obtained analytically from the condition that the 2D tangent to the Bezier curve B t at the point is parallel to the chord.

The expression above is reduced to a quadratic equation for the parameter t. For a general Bezier curve the quadratic equation may not have real roots in the interval 0 1 on which the parameter t is defined. However for well behaved Bezier curves the quadratic equation will have one or two real roots in the 0 1 interval. If the quadratic equation has two real roots two subdivision points are used to split the Bezier curve at two points. Once the point is obtained the Bezier curve is split in two using the de Casteljau subdivision algorithm. The resulting Bezier curves are stored in the geographic database .

At block the vehicle positioning application derives a 2D polyline representation in real time. An example polyline representation is depicted in . The vehicle positioning application derives the polyline representation by connecting the end points of the Bezier curves while ignoring the internal control points .

At block the link chain routine selects a segment to start the link chain. Each segment has two nodes also called end points . Not all nodes are at intersections. For example some nodes are used to encode changes in road attributes.

At block the link chain is grown in both directions by including neighboring segments. At block the link chain routine determines if the node is terminal and the link chain should stop in that direction at that node. The link chain routine uses rules for determining if a node is terminal or not. The rules to determine if the link chain should proceed through the node i.e. a non terminal node may include 

5. A link chain that contains roundabout segments i.e. segments associated with a roundabout attribute should not contain regular segments.

6. If the angle between two segments exceeds a predefined threshold then the segments should not form a link chain. This rule is not applicable to roundabout chains.

Other rules for identifying terminal nodes may also be used. If at block the link chain routine identifies a terminal node the link chain routine stops growing the link chain at block .

If at block the link chain routine does not identify a terminal node at block the link chain routine determines an optimal path through a node. At each node the link chain routine identifies the possible paths through the node that could be added to the link chain.

At block the link chain routine computes a path weight for each identified possible path. The path weight is determined using the lane category attribute the road type attribute and other attributes such as the angle of the path from the node and whether a road divider is located on the road represented by the segment. Additionally the path weight is determined in a manner to limit the amount of change in a direction through an intersection.

One way to determine which path to use for continuing the link chain is based on the combination of two factors the angle between the links and the difference in the number of lanes between the links. The probability of a link chain continuing onto a new link may be determined according to the following formula 

At every node where more than two links intersect the possible ways of forming a legitimate link chains are compared and ranked according to the calculated probability and the best choice is selected. Consequently the formation of the link chains does not depend on the order in which link chains are created.

At block the link chain routine determines whether to continue through the node based on the computed path weight at block . If the link chain routine decides to go through the node the path with the highest weight is chosen to be added to the link chain at block . If not the link chain routine stops growing the link chain at block .

At block the link chain routine splits link chains that are too long to be curve fitted in one operation. The determination may be made based on the length of the chain e.g. length exceeds 25 km the total number of nodes and shape points e.g. excess of 5000 and or other factors. Preferably the link chain routine splits the link chains close to the middle of the polyline length and where the link chain polyline is as straight as possible.

To achieve both objectives the link chain routine starts the search in both directions starting from the node that is located closest to the middle of the link chain. For every node considered the link chain routine builds a window around the node to determine if the node is located within a relatively straight segment. The link chain routine determines if a segment is straight by projecting the internal points on the segment formed by the two end points and verifying that the distances from points to the segment do not exceed a threshold and that the internal points project into the interior of the segment. The link chain routine continues the search in both directions until finding a node meeting the objectives. If the link chain routine does not find a good node for the split the link chain routine relaxes the straight segment criteria and repeats the search again.

At block the 2D B spline routine fits the link chains created by the method to a 2D B spline. The 2D B spline routine fits the 2D B spline to a single link chain including data points from the chain s neighboring link chains at both ends when possible. By including data points from neighboring link chains the 2D B spline routine causes successive curve fits to overlap which may ensure shape consistency at the boundary between curve fits. The decision for when to use data points from neighboring link chains is controlled by rules. A roundabout is an example of when data points from neighboring link chains are not used. The overlap of neighboring link chains may be significant typically several kilometers .

The 2D curve fitting technique iteratively determines the optimal local curve stiffness based on the specified curve fit tolerance. The 2D B spline routine uses calculus of variations to regularize the spline fit by minimizing the change of curvature along the spline. The curve fit is performed by minimizing the following functional 

Equation 1 Curve fitting minimization functional where v s expresses varying amount of regularization along the curve for iteration number j . v s may be a continuous function as a function of arc length along the curve or implemented discretely such as a unique value for each curve segment of the spline.

At block the 2D B spline routine aligns B spline ends that are mis aligned within a tile. While the spline fits are overlapping not all of the resulting B splines join perfectly at a node as shown in which depicts B spline ends that do not meet. To align two B splines at a node as shown in the B spline ends need to be aligned so that they meet at a common point in the XY plane with smooth tangent and curvature i.e. C2 continuity .

To align the B spline ends the 2D B spline routine uses a patch B spline to create a smooth transition between the two B splines. The 2D B spline routine projects a mid point on the patch B spline between the misaligned B spline ends . The 2D B spline routine splits the patch B spline and merges knot vectors to make each half of the patch B spline compatible to the misaligned B splines. The 2D B spline routine determines the parametric extent for the patch B spline to replace the existing B spline shape and copies the control points from the subdivided patch B spline for the replacement region into the B splines. The 2D B spline routine removes any unnecessary knots e.g. due to the knot merging step to make B splines compatible while ensuring good B spline quality e.g. within error tolerances for position heading and curvature error .

At block the 2D B spline routine aligns B splines across tile boundaries. The B splines between the tiles are aligned in a similar manner as described with reference to block . In this alignment the curve fit for the first B spline is within one tile the curve fit for the second B spline is within an adjacent tile and the patch B spline fits across the tile boundary. The B spline alignment across tiles creates a seamless C2 B spline joint at the tile boundary.

At block the 2D B spline routine aligns B spline ends at intersections where three or more roads meet. For each intersection the 2D B spline routine locates intersecting link chain B splines including self intersections. Techniques for identifying the intersection of two B splines including self intersecting B Splines are well known in the art. For each of the intersecting B splines the 2D B spline routine classifies the intersection as a crossing B spline i.e. four segments meeting at a single node a T junction or a multi intersection i.e. more than four segments meet at a single node . The 2D B spline routine joins the B splines representing these roads at a common node.

At block the 2D B spline routine determines an optimal split location for the splines. If the node is not at an intersection the 2D B spline routine projects the node onto the link chain B spline to identify the split location. If the node is an intersection node the 2D B spline routine determines the optimal split location based on the intersection classification described with reference to block .

At block the 2D B spline routine splits the link chain splines at the nodes using the split locations determined at block to form individual B splines one for each segment. For crossing B splines the 2D B spline routine splits the splines at the location where they intersect to create a common end point where the roads meet.

For T junctions due to the nature of the approximating B spline curve fitting technique the two link chain B splines may or may not intersect at the T junction. For intersecting T junction link chain B splines the 2D B spline routine truncates and discards any overlapping sections. For non intersecting T junctions the 2D B spline routine creates an intersection location by extending or snapping i.e. bending or shifting the terminating B spline for the attaching side road segment to the main road link chain B spline. The main road B spline is split at the location where the terminating B spline joins the main road B spline after being extended or snapped. Techniques for extending and adjusting the shape or position of B splines are well known in the art.

For multi link intersections where more than four segments meet at a single node the 2D B spline routine adjusts the 2D spline geometry so the segments meet at a common node. Due to the local support of B splines and the fact that they are invariant to affine transformation makes the B splines well suited for shape and position adjustments. Techniques for adjusting B spline geometry curves are well known in the art.

For each multi link intersection the 2D B spline routine determines the common 2D location of the intersection node. The optimal location depends on intersection geometry shape complexity and the surrounding link connectivity. The B splines are then shifted or their 2D shape adjusted in the vicinity of the intersection to align the splines without impacting the quality of their local curvature or heading. After the adjustment step the 2D B spline routine splits the B splines at the common intersection location.

At block the 2D B spline routine encodes 2D curvature information into the 2D B spline. The encoded curvature information identifies locations along the B spline where the curvature changes linearly with respect to arc length. In between each pair of encoded locations on the B spline the curvature is considered linear clothoidial since for each section the curvature changes linearly with respect to arc length. These cloithoidial locations are determined by first creating a curvature profile for the B spline which is a graph of curvature as a function of arc length. The curvature profile is then approximated by a polyline based on Douglas Peuker algorithm to approximate the curvature profile by linear curvature sections. The locations of the polyline vertices along the B spline are encoded into the B spline by inserting tagged knots at those locations.

At block the 2D B spline routine optimizes knot vectors. The knot vector used during the curve fit at block is not necessarily optimal with respect to the number of knots and the spacing of knots. The knot vectors are optimized to minimize storage space on the physical storage media while maintaining quality 2D position shape heading and curvature.

The 2D B spline routine locates optimal knot placement by identifying corresponding clothoid segments i.e. linear curvature regions along the 2D B spline determined at block . Long clothoid segments may be approximated by inserting knots at equal arc length intervals. These additional knots maintain B spline curve shape where the long clothoid segments may not be accurately represented with a single knot span.

The 2D B spline routine removes any knots not used to encode curvature at block or needed to keep the B spline within a 2D position shape heading and curvature tolerance of the original B spline. Optimal knot spacing is typically inversely proportional to curvature i.e. the higher the curvature the closer the knots are spaced .

At block the 2D B spline curve fit routine determines if there are any kinks in the link chain for all roads except certain functional class link chains e.g. highways major thoroughfares or for switchback link chains. A shape point is identified as a kink point if an angle between the link segments that meet at this shape point exceeds a kink threshold. For example the kink threshold may be set to 35 degrees.

For a spline curve to represent kinks the curve has discontinuous derivatives at the kink locations i.e. C0 continuity only . If one or more kinks in the link chain are detected at block the 2D B spline curve fit routine splits the link chain at each link location into individual sub link chains between the kinks at block . If no kinks are present in the link chain the 2D spline fit is performed on the entire link chain at block .

At block the 2D B spline curve fit routine curve fits each of the sub link chains with a 2D B spline using the 2D curve fitting technique described with reference to block . The resulting spline curves meet with C0 continuity at the kink locations.

At block since the link chain is now represented by multiple splines the 2D B spline curve fit routine stitches the sub link chains together into a single spline. In order to join the individual B Spline curves into a single continuous B spline curve the 2D B spline curve fit routine takes advantage of the non uniform B spline property that cubic non uniform B Splines have knot multiplicity of three at locations on the curve where it kinks i.e. where it only has C0 continuity .

The B spline curves are appended one at a time so that if multiple B spline curves need to be joined this is accomplished by appending the second curve to the first curve to form a single curve to which the next curve can be appended and so on. Techniques for joining B spline curves are well known in the art. Two non uniform cubic B spline curves with a common end point can be joined with C0 continuity by concatenating their control point arrays and adding their knot vectors.

At block the 2D B spline curve fit routine corrects B spline shape irregularities. The B spline shape irregularities may include bow outs and oscillations but can also include regions where there are other curve irregularities such as noisy curvature. Irregularities may occur when not enough shape points are used to define the curve of a segment or the road segment has poorly placed shape points. If the B spline is not straight where the underlying road geometry is known to be straight after adding the virtual shape points the 2D B spline curve fit routine can at block manipulate the control points to straighten the B spline. A similar technique may be used to smooth noisy curvature regions.

Returning to block if a link chain does not have kinks at block the 2D B spline curve fit routine determines whether the link chain contains a ramp at either end. At block if the link chain contains a ramp the 2D B spline curve fit routine performs ramp offset of the end node and shape points to ensure proper ramp shape and curvature. The nodes and shape points of the motorway are used in the spline fit as well as the nodes and shape points of the ramp link chain in order to achieve correct heading and curvature at the end of the ramp where it merges onto a motorway as shown in .

The 2D B spline curve fit routine assembles the points for the spline fit through the ramp as follows 

The length of the ramp offset vectors depicted in depends on known or estimated width of the motorway. An estimated width is determined based on the number of motorway lanes motorway restrictions on travel direction i.e. one way or two way and the number of lanes in the ramp the ramp is always assumed to be one way . To avoid the ramp spline curling towards the centerline of the motorway the 2D B spline curve fit routine ensures that the internal ramp shape points and or nodes are not closer to the motorway centerline than the offset motorway ramp common node. If some of the internal ramp shape points and or nodes are closer the 2D B spline curve fit routine projects the internal ramp shape points and or nodes on a line that is parallel to the motorway link segment away from the ramp motorway intersection node and that passes through the phantom node that results from offsetting the intersection node. shows the resulting ramp spline shape for a typical cloverleaf ramp.

At block the 2D B spline curve fit routine fits the link chains with a 2D B spline as described with reference to block . At block the 2D B spline curve fit routine corrects B spline shape irregularities as previously described.

Returning to block if the link chain is not a ramp at block the 2D B spline curve fit routine determines whether the link chain is a roundabout. If the link chain is a roundabout at block the 2D B spline curve fit routine extends the link chain to make three revolutions of the roundabout. Multiple revolution spline fits to roundabouts prevents tear drop shaped roundabout geometry. Later at block the appropriate sections of the overlapping roundabout spline are truncated to yield the individual splines for the roundabout.

The 3D B splines are created by combining 2D B splines obtained with the 2D B spline routine with 1D elevation splines. The 1D elevation splines are created by fitting splines to vehicle collected GPS data. Roads that require 3D splines are driven with the collection vehicle resulting in large quantities of sequential data points with associated latitude longitude height heading slope and or velocity data . The data points are collected with GPS and Inertial Measurement Units GPS IMU to maintain absolute and relative geo location accuracy. The height point datasets are filtered and adjusted to remove any data anomalies. The filtering cleans up any extraneous data due to gas stops off road driving turn around maneuvers and so on. The datasets are then grouped into smaller datasets based on spatial and time continuity.

At block to facilitate storage and geo referencing between datasets the height points are organized by projecting the points using 2D XY projection onto a database of known geometric 2D road centerlines. Each point is assigned to a specific road link and parameterized to a specific distance along the link. This association allows the elevation data to reference the existing information within the road database.

The 3D B spline routine performs point to 2D link projections by crawling along known road link paths road network and projecting the points onto each possible link path. The number of possible link paths is narrowed by the coded road restrictions in the database such as one way direction of travel limits and functional class level. To obtain the correct link path for the GPS point trace multiple paths are tested until a single correct path is found. If multiple valid paths are found a penalty criterion is computed based on the difference between the original GPS path shape and the link projected path shape the path with the minimal total 2D offset angle difference shape difference and or travel distance difference is chosen as the correct road link sequence. This sequence of links is referred to as the elevation link chain.

At block the 3D B spline routine fits 1D altitude B splines to the height points along the elevation link chain. This allows for a compact elevation representation which saves storage space and database I O bandwidth. The height points obtained at block are monotonically sorted along the elevation link chain based on the link chain order and the link parameter distance found from the 2D point link projection. The elevation link chain is traversed to compute the 2D arc length distance to each of the projected elevation points. This pair of data link chain arc length and elevation defines the dataset for computing the 1D elevation splines.

The 3D B spline routine divides the elevation link chain into smaller link chains before creating the 1D elevation splines. Although the goal is to create an individual spline for each road link an intermediate spline is generated over multiple link chain sections e.g. up to 1000 meters to maintain a smooth altitude B spline across link boundaries. The 3D B spline routine overlaps the larger link chains so that a smooth spline is also generated across the elevation link chain boundaries.

In some cases a single elevation spline fit is not desired across adjacent links. Therefore the 3D B spline routine further splits the larger link chains based on the underlying road database characteristics and drive path link chains are split at locations where the elevation may contain abrupt changes in slope or elevation. For example the chain is split when the path bends more than 80 degrees e.g. turning onto a different road and where the link chain contains a data gap. The 3D B spline routine then splits the 1D altitude B splines at the road link node locations.

The 3D B spline routine stores the resulting B splines in a database such that each spline is linked to a 2D road link reference. In addition two elevation traversals at the spline beginning and end points are saved in the database for each road link elevation spline. The elevation traversals store the altitude of the spline when it traverses across a road link node. A reference to the link node is stored. A single road link node will contain multiple elevation traversals where elevation splines overlap. This database of elevation traversals describes the possible crossing locations of elevation splines and allows the 3D B spline routine at block to efficiently query crossing locations and the differences in altitude between the crossing splines

In blocks and the 3D B spline routine associates the altitude B spline data to the road link map database such that previous knowledge of the road attributes may be added to the splines. This allows for intelligent processing of the altitude B splines such as knowing if the elevation data is at an intersection or on a ramp where crossing elevations are allowed to differ . Thus a more accurate elevation solution is possible.

At block the 3D B spline routine adjusts height data collected via a GPS IMU installed in a vehicle traveling along a road network. An example elevation correction routine is further discussed with reference to . Limits in the accuracy of GPS IMU geo referencing equipment may introduce some drift in the absolute altitude of the collected data points. As a result when two roads intersect each spline might incorrectly describe a slightly different height for the same intersection. Some spline crossing nodes have different elevations such as a bridge crossing over another road . Thus the elevation correction routine determines where the 3D splines intersect at grade. By taking advantage of the road map database associated with the altitude B splines using the B spline road link as the reference it is possible to know where the road links cross if they connect at the same level or if the link is an overpass or underpass. The database of elevation traversals was created in block for this purpose.

The elevation correction routine applies two operations to the altitude splines. First elevations are corrected vertically so that splines cross common road link nodes at the same elevation. Second multiple elevation splines are often available for a single road link. The elevation correction routine selects a single optimal altitude spline for each road link. The selected optimal altitude spline is then used for the rest of the altitude spline creation process.

To align the elevation at the road link nodes the elevation is changed as minimally as possible and an emphasis is placed on maintaining consistency in the data. The elevation data is very accurate relative to its surrounding chronologically local data. Due to drift however the absolute elevation may contain larger deviations. Therefore the alignment process maximizes the usage of contiguous data high relative accuracy and minimizes switching between different datasets absolute elevation dependent . Averaging of redundant elevation data is discouraged. Instead the elevation correction routine determines a node elevation by selecting the single best elevation from the best dataset. Ideally the same dataset is used for the maximum possible nearby elevation nodes to maintain consistency.

At block the elevation datasets are ranked based on how well they agree in elevation with other nearby dataset elevations the drive distance and the drive accuracy confidence. The rank controls the order that the drives are applied in the elevation correction routine . The order determines which elevations are assigned directly from the original elevation splines referred to as base node elevations and which elevations are adjusted corrected elevations to fit to existing elevation splines. In addition this order determines which elevation splines when there are multiple splines available for single road link are selected as the spline to use when generating the final altitude spline at block .

At block drives which fall outside of a minimum confidence level are excluded from the alignment process. This prevents unreliable data from causing unnecessary elevation offsets.

At block the highest ranked drive is chosen to initiate the elevation correction process. Since the initial drive does not overlap any existing base node elevations the initial drive does not need to be adjusted in elevation. Therefore at block the elevation correction routine assigns the nodes in the initial drive as base nodes without a correction curve. Any following splines from block that cross the initial drive are altered to align with the base nodes. In addition at block the elevation correction routine assigns the elevation splines from the drive as the optimal spline for the associated 2D road links.

At block the elevation correction routine selects the next best drive from the ranked list that intersects the previously fixed drive s base nodes. At block the elevation correction routine checks the elevation nodes to see which nodes correspond to previously fixed base nodes of a previous drive. Offsets are calculated to align the drive s nodes with the existing base node elevations.

In addition to adjusting the drive nodes to the existing base nodes the elevation correction is applied linearly between the base nodes. In order to preserve the original elevation data a virtual correction polyline is created instead of altering the original elevation spline. Super position of the original elevation spline and the virtual correction polyline results in a correctly aligned altitude spline. The virtual polyline is a linear shape that defines the elevation offsets needed to correct the original spline to fit to the other altitude spline s base nodes. Using a linear correction allows the elevation correction routine to precisely define the correction at exact locations i.e. no over shoot and also allows the elevation correction routine to linearly spread the correction over a large 2D distance.

A benefit of this process is that the database of elevation splines is never accessed there is no need to read alter and save the spline shapes. Since this process is a large global operation there is a significant savings of database I O and CPU requirements. The database activity is reduced to reading a minimal dataset only nodes that have multiple elevation traversals are considered. The write activity is reduced to two steps saving a single linear correction polyline for each drive and updating a status flag on elevation splines indicating if the spline is selected as the unique representative for the road link .

At block the elevation correction routine creates a virtual linear polyline that represents the calculated alignment offsets. The virtual polyline correction is employed to determine the corrected node heights of the non base nodes in the drive. At block the elevation correction routine adds the corrected height nodes to the list of fixed base nodes.

As each drive is applied the road links associated with the drive are checked to see if they have previously been assigned a unique optimal altitude spline from a previous drive. At block the elevation correction routine assigns links without an optimal spline an elevation spline from the current drive dataset. This results in a fixed elevation drive consistent set of altitude splines that provides a foundation for following elevation datasets.

At block the elevation correction routine checks to see if there are further drive datasets that overlap the existing base node elevations. If there are overlapping datasets at block the elevation correction routine selects the next best drive that overlaps the existing base nodes and the process repeats. When the overlapping drives have been processed at block the elevation correction routine checks if there are any remaining unprocessed drives. If unprocessed drives remain at block the elevation correction routine restarts a new alignment process on the remaining best drive.

The elevation correction routine is preferably repeated until all of the drives have been processed. After processing the elevation correction curves are stored in the database and a single unique elevation spline is assigned to associated road links.

Returning to at block the 3D B spline routine creates a single multi link altitude spline for the link chains created in the method . For each link road segment in the link chain the previously selected optimal altitude B spline at block is converted back into elevation points at for example every one meter of XY arc length. The correction polyline offset block is computed and added to each point. The result is a height aligned point set parameterized by the XY arc length of the link chain.

The 3D B spline routine fits a new altitude B spline to the list of elevation parameterized points for multiple links. Each successive curve fit overlaps the spline from the previous curve fit. The overlapping curve fits ensure shape consistency at a boundary between curve fits. The altitude curve fitting technique recursively determines the optimal knot vector based on the specified curve fit Z tolerance. The specified altitude curve fit tolerance is used to determine the knot vector spacing so that there are more knots when the altitude changes rapidly and fewer knots when the altitude changes slowly. Since the height points for the altitude B spline have been parameterized by link chain arc length the altitude B spline has a compatible knot vector parameter space with the 2D B spline which allows the B splines to be merged into a 3D B spline at block .

At block the 3D B spline routine merges the 2D B spline from the method and the altitude B spline from block to obtain a 3D B spline. The 3D B spline representation is created by adding the altitude B spline s Z component to the 2D B splines created by the 2D B spline routine . Since the parameter space for both the 2D B spline and the altitude B spline have been parameterized by the same XY link geometry arc length the B splines can be merged by merging their knot vectors.

The 3D B spline routine scales the knot vectors of each of the 2D and altitude B splines by the maximum knot value of both B splines. The 3D B spline routine then inserts the knots of the 2D B spline into the altitude B spline and the original knots of the altitude B spline into the 2D B spline using knot insertion. As a result both B splines have the same knot vectors and share the same parameter space.

The 3D B spline routine creates the 3D B spline from the 2D B spline by setting the 3D B spline s control points Z value equal to that of the Z value of the altitude B spline as shown as follows.

At block the 3D B spline routine encodes slope information into the 3D B spline. This is accomplished by tagging knots in the 3D B spline that may be used to generate the linear slope profile for the electronic horizon application . The specified elevation and slope tolerance is used to determine the encoded knot vector spacing so that there are more slope knots when the altitude changes rapidly and fewer knots when the altitude changes slowly. In addition more slope points are added at locations where slope inflections occur. The 3D B spline routine identifies the encoded slope knot locations using Douglas Peuker line approximation analysis based on elevation slope and slope change. The analysis is stopped once the data points are within the tolerance of the line approximation. The 3D B spline routine inserts a tagged slope knot at each Douglas Peuker polyline point along the altitude profile.

At block the 3D B spline routine optimizes size by evaluating the knot insertions at block . Since the resulting knot insertions may yield more knots than what is necessary to represent the 3D shape of the B spline the 3D B spline routine removes knots not needed to encode the slope profile and curvature profile or to maintain the B spline quality.

It is intended that the foregoing detailed description be regarded as illustrative rather than limiting and that it is understood that the following claims including all equivalents are intended to define the scope of the invention. The claims should not be read as limited to the described order or elements unless stated to that effect. Therefore all embodiments that come within the scope and spirit of the following claims and equivalents thereto are claimed as the invention.

