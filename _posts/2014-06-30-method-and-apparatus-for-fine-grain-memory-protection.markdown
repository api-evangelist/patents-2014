---

title: Method and apparatus for fine grain memory protection
abstract: An apparatus and method for fine grain memory protection. For example, one embodiment of a method comprises: performing a first lookup operation using a virtual address to identify a physical address of a memory page, the memory page comprising a plurality of sub-pages; determining whether sub-page permissions are enabled for the memory page; if sub-page permissions are enabled, then performing a second lookup operation to determine permissions associated with one or more of the sub-pages of the memory page; and implementing the permissions associated with the one or more sub-pages.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09335943&OS=09335943&RS=09335943
owner: INTEL CORPORATION
number: 09335943
owner_city: Santa Clara
owner_country: US
publication_date: 20140630
---
This invention relates generally to the field of computer processors. More particularly the invention relates to an apparatus and method for fine grain memory protection.

A virtual machine system is a computer system that includes a virtual machine monitor VMM supporting one or more virtual machines VMs . A Virtual Machine Monitor VMM is a software program that controls physical computer hardware and presents programs executing within a Virtual Machine VM with the illusion that they are executing on real physical computer hardware. Each VM typically functions as a self contained platform controlled by a guest operating system OS i.e. an OS hosted by the VMM which executes as if it were running on a real machine instead of within a VM.

To accomplish this simulation it is necessary for some operations within a VM e.g. attempts to configure device hardware to be trapped and emulated by the VMM which will perform operations to simulate virtual hardware resources e.g. a simulated device to maintain the illusion that the guest OS is manipulating real hardware. Thus in a virtual machine system transitions from a VM to the VMM and back will occur with some frequency depending upon the number of instructions and events that the VMM must emulate.

In a virtual memory system a memory address generated by software a virtual address is translated by hardware into a physical address which is then used to reference memory. This translation process is called paging and the hardware used to perform the translation is called the paging hardware. In many virtual memory systems the virtual to physical address translation is defined by system software in a set of data structures called page tables that reside in memory. Modern virtual memory systems typically incorporate into a system s central processing unit CPU a specialized caching structure often called a translation lookaside buffer TLB which stores information about virtual to physical address translations and which can be accessed far more quickly than memory.

When an OS stops executing one process and begins executing another it will typically change the address space by directing the hardware to use a new set of paging structures. This can be accomplished using a software or hardware mechanism to invalidate or remove the entire contents of the TLB. More frequent than changes between processes are transitions of control between a process and OS software. Because of this system performance would suffer significantly if the TLB were invalidated on each such transition. Thus modern operating systems are typically constructed so that no change of address space is required. One or more ranges of virtual memory addresses in every address space are protected so that only the OS can access addresses in those ranges.

Some virtual machine systems may support layers of VMMs. For example a single VMM sometime referred to as a virtual machine extension VMX root directly controls the CPU. This VMX root may support in guest VMs other guest VMMs that may themselves support guest VMs. The support for layering may be provided by software hardware or a combination of the two.

VMMs may monitor runtime data structure integrity at the page level. That is read write privileges and other memory policies are implemented at the granularity of a memory page which is typically 4 kBytes in size. An in band IB agent within the OS configures these policies via the VMX root. Write access on monitored pages generates Virtualization Exceptions VEs . With existing hardware this causes the IB agent to check white list the memory accessor. As a result of this architecture false shared data structures data on the same 4K page may cause a high volume of VE events that have to be brute force filtered by the IB agent. Other examples of use cases where sub page less than 4K region protection is applicable are memory mapped input output MMIO device memory areas for virtualization page table protection for sparse mappings in the page table checkpointing VM memory and any VMM architectures that support memory monitoring application programming interfaces APIs which are limited to a 4K granularity for VM introspection.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the invention described below. It will be apparent however to one skilled in the art that the embodiments of the invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the embodiments of the invention.

In a processor pipeline includes a fetch stage a length decode stage a decode stage an allocation stage a renaming stage a scheduling also known as a dispatch or issue stage a register read memory read stage an execute stage a write back memory write stage an exception handling stage and a commit stage .

The front end unit includes a branch prediction unit coupled to an instruction cache unit which is coupled to an instruction translation lookaside buffer TLB which is coupled to an instruction fetch unit which is coupled to a decode unit . The decode unit or decoder may decode instructions and generate as an output one or more micro operations micro code entry points microinstructions other instructions or other control signals which are decoded from or which otherwise reflect or are derived from the original instructions. The decode unit may be implemented using various different mechanisms. Examples of suitable mechanisms include but are not limited to look up tables hardware implementations programmable logic arrays PLAs microcode read only memories ROMs etc. In one embodiment the core includes a microcode ROM or other medium that stores microcode for certain macroinstructions e.g. in decode unit or otherwise within the front end unit . The decode unit is coupled to a rename allocator unit in the execution engine unit .

The execution engine unit includes the rename allocator unit coupled to a retirement unit and a set of one or more scheduler unit s . The scheduler unit s represents any number of different schedulers including reservations stations central instruction window etc. The scheduler unit s is coupled to the physical register file s unit s . Each of the physical register file s units represents one or more physical register files different ones of which store one or more different data types such as scalar integer scalar floating point packed integer packed floating point vector integer vector floating point status e.g. an instruction pointer that is the address of the next instruction to be executed etc. In one embodiment the physical register file s unit comprises a vector registers unit a write mask registers unit and a scalar registers unit. These register units may provide architectural vector registers vector mask registers and general purpose registers. The physical register file s unit s is overlapped by the retirement unit to illustrate various ways in which register renaming and out of order execution may be implemented e.g. using a reorder buffer s and a retirement register file s using a future file s a history buffer s and a retirement register file s using a register maps and a pool of registers etc. . The retirement unit and the physical register file s unit s are coupled to the execution cluster s . The execution cluster s includes a set of one or more execution units and a set of one or more memory access units . The execution units may perform various operations e.g. shifts addition subtraction multiplication and on various types of data e.g. scalar floating point packed integer packed floating point vector integer vector floating point . While some embodiments may include a number of execution units dedicated to specific functions or sets of functions other embodiments may include only one execution unit or multiple execution units that all perform all functions. The scheduler unit s physical register file s unit s and execution cluster s are shown as being possibly plural because certain embodiments create separate pipelines for certain types of data operations e.g. a scalar integer pipeline a scalar floating point packed integer packed floating point vector integer vector floating point pipeline and or a memory access pipeline that each have their own scheduler unit physical register file s unit and or execution cluster and in the case of a separate memory access pipeline certain embodiments are implemented in which only the execution cluster of this pipeline has the memory access unit s . It should also be understood that where separate pipelines are used one or more of these pipelines may be out of order issue execution and the rest in order.

The set of memory access units is coupled to the memory unit which includes a data TLB unit coupled to a data cache unit coupled to a level 2 L2 cache unit . In one exemplary embodiment the memory access units may include a load unit a store address unit and a store data unit each of which is coupled to the data TLB unit in the memory unit . The instruction cache unit is further coupled to a level 2 L2 cache unit in the memory unit . The L2 cache unit is coupled to one or more other levels of cache and eventually to a main memory.

By way of example the exemplary register renaming out of order issue execution core architecture may implement the pipeline as follows 1 the instruction fetch performs the fetch and length decoding stages and 2 the decode unit performs the decode stage 3 the rename allocator unit performs the allocation stage and renaming stage 4 the scheduler unit s performs the schedule stage 5 the physical register file s unit s and the memory unit perform the register read memory read stage the execution cluster perform the execute stage 6 the memory unit and the physical register file s unit s perform the write back memory write stage 7 various units may be involved in the exception handling stage and 8 the retirement unit and the physical register file s unit s perform the commit stage .

The core may support one or more instructions sets e.g. the x86 instruction set with some extensions that have been added with newer versions the MIPS instruction set of MIPS Technologies of Sunnyvale Calif. the ARM instruction set with optional additional extensions such as NEON of ARM Holdings of Sunnyvale Calif. including the instruction s described herein. In one embodiment the core includes logic to support a packed data instruction set extension e.g. AVX AVX and or some form of the generic vector friendly instruction format U 0 and or U 1 described below thereby allowing the operations used by many multimedia applications to be performed using packed data.

It should be understood that the core may support multithreading executing two or more parallel sets of operations or threads and may do so in a variety of ways including time sliced multithreading simultaneous multithreading where a single physical core provides a logical core for each of the threads that physical core is simultaneously multithreading or a combination thereof e.g. time sliced fetching and decoding and simultaneous multithreading thereafter such as in the Intel Hyperthreading technology .

While register renaming is described in the context of out of order execution it should be understood that register renaming may be used in an in order architecture. While the illustrated embodiment of the processor also includes separate instruction and data cache units and a shared L2 cache unit alternative embodiments may have a single internal cache for both instructions and data such as for example a Level 1 L1 internal cache or multiple levels of internal cache. In some embodiments the system may include a combination of an internal cache and an external cache that is external to the core and or the processor. Alternatively all of the cache may be external to the core and or the processor.

Thus different implementations of the processor may include 1 a CPU with the special purpose logic being integrated graphics and or scientific throughput logic which may include one or more cores and the cores A N being one or more general purpose cores e.g. general purpose in order cores general purpose out of order cores a combination of the two 2 a coprocessor with the cores A N being a large number of special purpose cores intended primarily for graphics and or scientific throughput and 3 a coprocessor with the cores A N being a large number of general purpose in order cores. Thus the processor may be a general purpose processor coprocessor or special purpose processor such as for example a network or communication processor compression engine graphics processor GPGPU general purpose graphics processing unit a high throughput many integrated core MIC coprocessor including 30 or more cores embedded processor or the like. The processor may be implemented on one or more chips. The processor may be a part of and or may be implemented on one or more substrates using any of a number of process technologies such as for example BiCMOS CMOS or NMOS.

The memory hierarchy includes one or more levels of cache within the cores a set or one or more shared cache units and external memory not shown coupled to the set of integrated memory controller units . The set of shared cache units may include one or more mid level caches such as level 2 L2 level 3 L3 level 4 L4 or other levels of cache a last level cache LLC and or combinations thereof. While in one embodiment a ring based interconnect unit interconnects the integrated graphics logic the set of shared cache units and the system agent unit integrated memory controller unit s alternative embodiments may use any number of well known techniques for interconnecting such units. In one embodiment coherency is maintained between one or more cache units and cores A N.

In some embodiments one or more of the cores A N are capable of multi threading. The system agent includes those components coordinating and operating cores A N. The system agent unit may include for example a power control unit PCU and a display unit. The PCU may be or include logic and components needed for regulating the power state of the cores A N and the integrated graphics logic . The display unit is for driving one or more externally connected displays.

The cores A N may be homogenous or heterogeneous in terms of architecture instruction set that is two or more of the cores A N may be capable of execution the same instruction set while others may be capable of executing only a subset of that instruction set or a different instruction set. In one embodiment the cores A N are heterogeneous and include both the small cores and big cores described below.

Referring now to shown is a block diagram of a system in accordance with one embodiment of the present invention. The system may include one or more processors which are coupled to a controller hub . In one embodiment the controller hub includes a graphics memory controller hub GMCH and an Input Output Hub IOH which may be on separate chips the GMCH includes memory and graphics controllers to which are coupled memory and a coprocessor the IOH is couples input output I O devices to the GMCH . Alternatively one or both of the memory and graphics controllers are integrated within the processor as described herein the memory and the coprocessor are coupled directly to the processor and the controller hub in a single chip with the IOH .

The optional nature of additional processors is denoted in with broken lines. Each processor may include one or more of the processing cores described herein and may be some version of the processor .

The memory may be for example dynamic random access memory DRAM phase change memory PCM or a combination of the two. For at least one embodiment the controller hub communicates with the processor s via a multi drop bus such as a frontside bus FSB point to point interface such as QuickPath Interconnect QPI or similar connection .

In one embodiment the coprocessor is a special purpose processor such as for example a high throughput MIC processor a network or communication processor compression engine graphics processor GPGPU embedded processor or the like. In one embodiment controller hub may include an integrated graphics accelerator.

There can be a variety of differences between the physical resources in terms of a spectrum of metrics of merit including architectural microarchitectural thermal power consumption characteristics and the like.

In one embodiment the processor executes instructions that control data processing operations of a general type. Embedded within the instructions may be coprocessor instructions. The processor recognizes these coprocessor instructions as being of a type that should be executed by the attached coprocessor . Accordingly the processor issues these coprocessor instructions or control signals representing coprocessor instructions on a coprocessor bus or other interconnect to coprocessor . Coprocessor s accept and execute the received coprocessor instructions.

Referring now to shown is a block diagram of a first more specific exemplary system in accordance with an embodiment of the present invention. As shown in multiprocessor system is a point to point interconnect system and includes a first processor and a second processor coupled via a point to point interconnect . Each of processors and may be some version of the processor . In one embodiment of the invention processors and are respectively processors and while coprocessor is coprocessor . In another embodiment processors and are respectively processor coprocessor .

Processors and are shown including integrated memory controller IMC units and respectively. Processor also includes as part of its bus controller units point to point P P interfaces and similarly second processor includes P P interfaces and . Processors may exchange information via a point to point P P interface using P P interface circuits . As shown in IMCs and couple the processors to respective memories namely a memory and a memory which may be portions of main memory locally attached to the respective processors.

Processors may each exchange information with a chipset via individual P P interfaces using point to point interface circuits . Chipset may optionally exchange information with the coprocessor via a high performance interface . In one embodiment the coprocessor is a special purpose processor such as for example a high throughput MIC processor a network or communication processor compression engine graphics processor GPGPU embedded processor or the like.

A shared cache not shown may be included in either processor or outside of both processors yet connected with the processors via P P interconnect such that either or both processors local cache information may be stored in the shared cache if a processor is placed into a low power mode.

Chipset may be coupled to a first bus via an interface . In one embodiment first bus may be a Peripheral Component Interconnect PCI bus or a bus such as a PCI Express bus or another third generation I O interconnect bus although the scope of the present invention is not so limited.

As shown in various I O devices may be coupled to first bus along with a bus bridge which couples first bus to a second bus . In one embodiment one or more additional processor s such as coprocessors high throughput MIC processors GPGPU s accelerators such as e.g. graphics accelerators or digital signal processing DSP units field programmable gate arrays or any other processor are coupled to first bus . In one embodiment second bus may be a low pin count LPC bus. Various devices may be coupled to a second bus including for example a keyboard and or mouse communication devices and a storage unit such as a disk drive or other mass storage device which may include instructions code and data in one embodiment. Further an audio I O may be coupled to the second bus . Note that other architectures are possible. For example instead of the point to point architecture of a system may implement a multi drop bus or other such architecture.

Referring now to shown is a block diagram of a second more specific exemplary system in accordance with an embodiment of the present invention. Like elements in bear like reference numerals and certain aspects of have been omitted from in order to avoid obscuring other aspects of .

Referring now to shown is a block diagram of a SoC in accordance with an embodiment of the present invention. Similar elements in bear like reference numerals. Also dashed lined boxes are optional features on more advanced SoCs. In an interconnect unit s is coupled to an application processor which includes a set of one or more cores A N and shared cache unit s a system agent unit a bus controller unit s an integrated memory controller unit s a set or one or more coprocessors which may include integrated graphics logic an image processor an audio processor and a video processor an static random access memory SRAM unit a direct memory access DMA unit and a display unit for coupling to one or more external displays. In one embodiment the coprocessor s include a special purpose processor such as for example a network or communication processor compression engine GPGPU a high throughput MIC processor embedded processor or the like.

Embodiments of the mechanisms disclosed herein may be implemented in hardware software firmware or a combination of such implementation approaches. Embodiments of the invention may be implemented as computer programs or program code executing on programmable systems comprising at least one processor a storage system including volatile and non volatile memory and or storage elements at least one input device and at least one output device.

Program code such as code illustrated in may be applied to input instructions to perform the functions described herein and generate output information. The output information may be applied to one or more output devices in known fashion. For purposes of this application a processing system includes any system that has a processor such as for example a digital signal processor DSP a microcontroller an application specific integrated circuit ASIC or a microprocessor.

The program code may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. The program code may also be implemented in assembly or machine language if desired. In fact the mechanisms described herein are not limited in scope to any particular programming language. In any case the language may be a compiled or interpreted language.

One or more aspects of at least one embodiment may be implemented by representative instructions stored on a machine readable medium which represents various logic within the processor which when read by a machine causes the machine to fabricate logic to perform the techniques described herein. Such representations known as IP cores may be stored on a tangible machine readable medium and supplied to various customers or manufacturing facilities to load into the fabrication machines that actually make the logic or processor.

Such machine readable storage media may include without limitation non transitory tangible arrangements of articles manufactured or formed by a machine or device including storage media such as hard disks any other type of disk including floppy disks optical disks compact disk read only memories CD ROMs compact disk rewritable s CD RWs and magneto optical disks semiconductor devices such as read only memories ROMs random access memories RAMs such as dynamic random access memories DRAMs static random access memories SRAMs erasable programmable read only memories EPROMs flash memories electrically erasable programmable read only memories EEPROMs phase change memory PCM magnetic or optical cards or any other type of media suitable for storing electronic instructions.

Accordingly embodiments of the invention also include non transitory tangible machine readable media containing instructions or containing design data such as Hardware Description Language HDL which defines structures circuits apparatuses processors and or system features described herein. Such embodiments may also be referred to as program products.

In some cases an instruction converter may be used to convert an instruction from a source instruction set to a target instruction set. For example the instruction converter may translate e.g. using static binary translation dynamic binary translation including dynamic compilation morph emulate or otherwise convert an instruction to one or more other instructions to be processed by the core. The instruction converter may be implemented in software hardware firmware or a combination thereof. The instruction converter may be on processor off processor or part on and part off processor.

One embodiment of the invention reduces the volume of memory violations due to page sharing using techniques which allow the VMM to write protect sub page regions of any page. In one embodiment each memory page is 4 k in size and the sub page regions are B. However the underlying principles of the invention are not limited to any particular sub page region or page size.

In one embodiment the permissions for each sub page region are maintained in a VMM managed table. With a B granularity for sub pages no write and no execute permissions may be expressed in a 64 bit value e.g. with 2 bits allocated to each sub page one indicating no write and one indicating no execute .

As a result instead of processing every VE event directed to a memory page the security agent is provided with information that allows it to process only those events e.g. write operations directed to specific sub pages within the memory page . For example in only the sub page s within the highlighted region of the memory page are relevant to the security agent . Thus the security agent processes VE events occurring within this region but filters out events occurring in the other regions e.g. because write permissions are set for those sub pages . Other memory views managed by the VMM represent standard memory page views traditionally provided by the VMM to guest systems e.g. such as kernel .

Additional details of one embodiment of the invention are illustrated in which shows a page table with mappings between memory page virtual addresses also sometimes referred to a linear addresses and physical addresses also sometimes referred to as real addresses . In one embodiment the page table comprises an extended page table EPT employed in current x86 architectures. Page walk logic may perform a page walk operation to access the page table using a virtual address and identify the physical address corresponding to that virtual address. In one embodiment the page walk logic comprises a page miss handler PMH integrated within the memory management unit of the processor. Once the physical address is identified the location of the memory page may be accessed at the specified physical location in memory.

Various other components commonly used for virtual to physical address translations are not illustrated in to avoid obscuring the underlying principles of the invention. For example page table entries may be cached in a translation lookaside buffer TLB within the processor for faster access. If a page table entry is located within the TLB the physical address of the page may be determined directly by the memory management unit MMU of the processor without the need for a page walk which typically involves accessing the page table from system memory and therefore consumes significantly more cycles . The underlying principles of the invention are the same regardless of whether information related to the page is retrieved from the TLB or directly from the page table .

In one embodiment of the invention a SPP enable bit included within each of the page table entries indicates whether sub page protection applies to the corresponding memory page. For example in the page table in the SPP enable bit is set to 1 for the entries associated with VA and VA. In one embodiment if SPP is enabled for a particular page then a sub page protection SPP module implements the techniques described herein to perform a lookup in one or more sub page protection tables . In one embodiment to perform the lookup the sub page protection module combines the physical address of the page provided from the page walk module or TLB with a sub page protection table pointer SPPTP which identifies the base location of the SPPT in memory. In one embodiment the SPPTP is a 64 bit field within the virtual machine control structure VMCS . However the SPPTP may be implemented in a variety of different ways while still complying with the underlying principles of the invention.

In one embodiment a write permission bit and potentially one or more other permission bits associated with each page may also be used to determine permissions for that page in combination with the sub page protection table s . For example in one embodiment the page level permissions are combined with the sub page write protections specified in the SPPT to determine the write permissions for each sub page. For example in one embodiment if the write permission for the page is set to 0 then writes are not permitted for sub pages unless the write permission bit is set to 1 in the sub page protection table. In another embodiment if the write permission for the page is set to 0 then writes are not permitted for sub pages regardless of the settings indicated in the sub page protection table. Similarly if the write permission for the page is set to 1 then writes are permitted for sub pages unless the write permission bit is set to 0 in the sub page protection table . In another embodiment if the write permission for the page is set to 1 then writes are permitted for all sub pages regardless of the settings indicated in the sub page protection table. Thus the write permission bit and sub page protection bit may be combined in various ways to determine write permissions for each sub page.

In one embodiment the SPPT comprises a hierarchy of tables each of which is indexed by a different portion of a memory page s physical address. A lookup according to one such embodiment is illustrated graphically in . As illustrated in this embodiment the SPPTP is combined with the highest physical address bits of the physical address to identify an entry in a level 5 L5 table. The address contained in that entry is the base address for the level 4 L4 table. The entry in the L4 table is located by combining the base address with bits of the physical address of the page. The L4 entry identifies the base address of the L3 table and is combined with bits of the physical address to identify the entry in the L3 table which contains the base address of the L2 table. Bits are then combined with this base address to identify the entry in the L2 table which identifies the base address of the L1 table. The 64 bit sub page SP vector containing all sub page permissions for the page is identified by combining the base address for the L1 table with bits of the physical address. The write permission bit is then identified within the 64 bit SP vector using physical address bits . In one embodiment the 64 bit SP vector contains two bits associated with each sub page one to indicate write permission e.g. 1 write permitted 0 write protected and the other to indicate one or more additional permissions for the sub page e.g. execute protection and or permissions .

It should be noted that the specific details are shown in for the purposes of explanation of one embodiment of the invention. However the underlying principles of the invention are not limited to the specific details shown in . For example the different address bits associated with each memory page may be combined in alternate ways to perform lookups in various different types of table structures non hierarchical as well as hierarchical while still complying with the underlying principles of the invention.

A method in accordance with one embodiment of the invention for determining sub page protection is illustrated in . The method may be implemented within the architectures described above but is not limited to any particular system architecture.

At the page table entry associated with a memory page is retrieved. For example as discussed above the page table entry may be read from the TLB or may be fetched from the page table stored in memory. At a determination is made as to whether sub page protection is enabled. For example as mentioned above a sub page protection bit may be set in the page table entry to indicate sub page protection. If sub page protection is not enabled then at only page level permissions protections are implemented.

If sub page protection is enabled then at a lookup is performed in a sub page protection table SPPT to determine permissions protections associated with each sub page. As mentioned above this may include write permissions execute permissions or any other permissions protections capable of being implemented with respect to a sub page. At the sub page protection indication is combined with page level permissions protections if any to arrive at a final set of permissions for each sub page.

The following specific details are implemented to provide sub page protections permissions in one embodiment of the invention. It should be noted however that the underlying principles of the invention are not limited to these specific details.

In one embodiment the SPP bit used in the page table comprises a bit which is defined only for EPT paging structure entries that map a page e.g. 4 KB extended page table EPT page table entries . The bit is ignored in other EPT paging structure entries.

As mentioned accumulated page level EPT write permissions protection may be combined with sub page write permissions protection to determine write permissions protections for that sub page. In one embodiment the processor checks this write permission and generates EPT violations as appropriate.

If an SPPT entry is not present this may cause a new virtual machine exit. In one embodiment this would occur only for lazy population of SPPT by VMM. On a miss in one embodiment the physical address may be saved in the VMCS to be used as a cache for subsequent requests . A VM exit would otherwise save data as EPT violations currently do e.g. NMI blocking IDT vectoring etc. 

If there is no miss then the SPPT walk may identify a 32 bit write permission bitmap for page. The processor may cache the bitmap in data translation lookaside buffer DTLB or related other structure for subsequent accesses.

In one embodiment the VMM may modify the sub page protection bits in the SPPT and may invalidate combined mappings via the INVEPT instruction. This also causes flush of cached sub page permissions. In one embodiment an extended page table pointer EPTP switch e.g. via execution of VMWRITE or VMFUNC instructions may cause flush of any information cached about sub page permissions. This may entail TLB flushing for address space ID ASID miss cases e.g. with a new ASID being allocated . In one embodiment entries are also invalidated in non ASID tagged structures e.g. the data TLB extended page directory pointer EPDP and extended page directory entry EPDE caches .

In one embodiment sub page protection SPP pages are considered read only for guest paging structures and virtualized advanced programmable interrupt controller APIC accesses. For Intel Architecture IA 32 A D bit updates a If a guest A D bit update is to be made to an SPP page an EPT violation is generated b the exit qualification is the same as if the page had been read only in the EPT no new data c the VMM can handle such EPT violations with existing mechanisms. For EPT A D bit architecture a if EPT A D bits are enabled guest page walks may be considered writes for EPT b if the EPT A D bits are enabled then a guest page walk to an SPP page causes an EPT violation c an enlightened OS that interfaces with a VMM to monitor OS page tables can use subpage protection efficiently by pre setting A D bits on pages containing critical mappings so that the VMM does not have to emulate A D updates on write protected pages that have sub page monitored regions.

One example of this is an 8 byte MOV that is 4 byte aligned within a page. In one embodiment the processor will check the writeability of both sub pages. If both sub pages are writeable the write is allowed. If either sub page is not writeable the write causes an EPT violation.

One example of this is an 8 byte MOV that is 4 byte aligned straddling the page boundary. In one embodiment the processor will check whether either page has sub page protections. If neither page has sub page protections the write is handled normally per the EPT. If either page has sub page protections the write causes an EPT violation.

One example of this is the FXSAVE instruction which may generate multiple writes to multiple pages. The processor may treat store probes just like any other store. In one embodiment the processor will generate an EPT violation if specific address probed is not writeable. This can result in EPT violations occurring after some data is written.

In one embodiment a change store probes to cause EPT violations if page probed has sub page protection. In one embodiment the processor probes high and low bytes before doing any writes.

Advanced Programmable Interrupt Controller APIC interactions may result if the VMM configures an EPT PTE so that the physical address is in the APIC access address and SPP 1. In one embodiment this is considered an invalid usage. The full APIC virtualization provides fine grained control without sub page protection.

In one embodiment the sub page protection table pointer SPPTP is not changed on an extended page table pointer EPTP switch. The current use case requires specific EPT hierarchies to have access to the W subpage. This is achieved via EPTE SPP bit set to 0 for these EPT hierarchies.

In one embodiment the SPPT may be switched via a new VMFUNC instruction that switches the following via a memory descriptor 

The architecture described above can be mapped to various implementations. A straight mapping of the proposed architecture to a processor implementation is one that performs a lookup of the SPPT due to the processor page miss handler PMH walking a paging structure that has the SPP bit set in the EPT structure. An alternate implementation embodiment which does not require the SPP bit in the EPT is as follows. The VMM allocates a chunk of contiguous memory area that it reserves for use as a sub page monitorable pool of pages. When the OS or an OS service wants a page that either requires subpage monitoring or is dynamically setup to be monitored at the subpage level the OS service requests that the VMM assign one of these pool pages. The VMM maps the global physical address GPA of the OS mapping in the OS PT to the assigned page s hidden physical address HPA from the pool of pages. In some environments the VMM may copy the contents from original GPA page to the page assigned from this pool. The VMM also programs one of the processor s range registers base and mask to cover the contiguous memory region. The range register allows the processor to detect when a RW or X access is made to one of the pages in the pool. The VMM additionally programs the SPPT as defined in the architecture above to specify the per page sub page policies for all pages within this pool. In one embodiment any RW or X access to any page within the memory region causes a processor microcode assist in which the CPU checks against the subpage policy for that HPA in the SPPT and allows or disallows the access.

In one embodiment when sub page permissions are desired for a set of pages the VMM populates the SPPT with mappings for this set of pages specifying the subpage permission bit vector for each page. For accesses falling within write disallowed sub page regions the VMM handles induced EPT violations or the guest software handles induced virtualization exceptions VEs . For accesses falling within write allowed sub page regions no induced EPT violation or VE is generated.

In one embodiment the root VMM may not be enabled for SPPT. In this case it doesn t expose it and does not virtualize it. In another embodiment the root VMM is enabled for SPPT but is not using the SPPT itself but is virtualizing it. In another embodiment the root VMM is enabled for SPPT and is using it itself but is not exposing it to guest entities. Here there are no SPPT nesting implications. In yet another embodiment the root VMM is enabled for SPPT is using it itself and is exposing it to guest entities e.g. virtualizing it . These last two embodiments are described in greater detail in the below sections.

In one embodiment the root VMM shadows the SPPT structure to keep all references to the HPA including the SPPT . Since the SPPT is accessed via general memory access instructions the root VMM will need to edit control SPPT guest memory pages. The guest VMM must perform an INVEPT instruction EPTP context after updating the SPPT which can be virtualized correctly by the root VMM. In one embodiment the INVEPT instruction clears any SPPT cache for the same scope global EPTP and specific address if supported .

In this embodiment the root VMM shadows the SPPT structure to keep all references to the HPA including the SPPT . For conflicting SPPT policies the root VMM may encode the most conservative combination into the SPPT used by the processor for violations due to guest SPPT. The root VMM may emulate VE VMexit to the guest VMM. Since the SPPT is accessed via general memory access instructions the root VMM will need to edit control the SPPT guest memory pages. The guest VMM may perform an INVEPT instruction EPTP context after updating the SPPT which can be virtualized correctly by the root VMM. In one embodiment the INVEPT instruction may clear any SPPT cache for the same scope global EPTP and specific address if supported .

Embodiments of the invention may include various steps which have been described above. The steps may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor to perform the steps. Alternatively these steps may be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

As described herein instructions may refer to specific configurations of hardware such as application specific integrated circuits ASICs configured to perform certain operations or having a predetermined functionality or software instructions stored in memory embodied in a non transitory computer readable medium. Thus the techniques shown in the figures can be implemented using code and data stored and executed on one or more electronic devices e.g. an end station a network element etc. . Such electronic devices store and communicate internally and or with other electronic devices over a network code and data using computer machine readable media such as non transitory computer machine readable storage media e.g. magnetic disks optical disks random access memory read only memory flash memory devices phase change memory and transitory computer machine readable communication media e.g. electrical optical acoustical or other form of propagated signals such as carrier waves infrared signals digital signals etc. . In addition such electronic devices typically include a set of one or more processors coupled to one or more other components such as one or more storage devices non transitory machine readable storage media user input output devices e.g. a keyboard a touchscreen and or a display and network connections. The coupling of the set of processors and other components is typically through one or more busses and bridges also termed as bus controllers . The storage device and signals carrying the network traffic respectively represent one or more machine readable storage media and machine readable communication media. Thus the storage device of a given electronic device typically stores code and or data for execution on the set of one or more processors of that electronic device. Of course one or more parts of an embodiment of the invention may be implemented using different combinations of software firmware and or hardware. Throughout this detailed description for the purposes of explanation numerous specific details were set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the invention may be practiced without some of these specific details. In certain instances well known structures and functions were not described in elaborate detail in order to avoid obscuring the subject matter of the present invention. Accordingly the scope and spirit of the invention should be judged in terms of the claims which follow.

