---

title: Synchronization framework that restores a node from backup
abstract: Architecture for restoring nodes. After restoring a node, fix-up occurs to make the node appear as a different node than before the restore operation. The node appears as a new node, which new node knows the data up to a certain point from when the new node had the prior identity. This enables new changes generated by the new node to flow to the other nodes in the topology, as well as have the changes that the prior identity sent to other nodes flow back to the new node. In other words, the architecture maintains information to create the new node in the topology while maintaining prior data knowledge. Additionally, item level metadata of associated data items is updated to correlate with the updated data items so that changes can be correctly enumerated and applied. This metadata update occurs across scopes of which the data items are included.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08977592&OS=08977592&RS=08977592
owner: Microsoft Corporation
number: 08977592
owner_city: Redmond
owner_country: US
publication_date: 20140112
---
This application is a continuation of co pending Non Provisional patent application Ser. No. 12 754 622 entitled SYNCHRONIZATION FRAMEWORK THAT RESTORES A NODE FROM BACKUP and filed Apr. 6 2010 now U.S. Pat. No. 8 630 980 issued Jan. 14 2014.

Data backup is essential to the individual user as well as to the corporate entity. Data stores can now be found on client machines as well as distributed corporate wide across servers. Thus consumers desire the capability to backup and restore both client side databases as well as server side database to guard against data loss related. Data loss can occur due to many reasons some of which include database corruption hardware failures unintended operations and disaster recovery.

Moreover the behavior of client side and server side stores can be different and as such result in a different set of requirements related to backup restore scenarios. Specifically client side stores typically share characteristics that include limited concurrency single user data access flexibility during downtime and limitations related to backup capabilities e.g. online incremental etc. . In contrast server side databases typically share characteristics that include a high degree of concurrency multi user user data access high availability and a wide array of backup capabilities.

Endpoint synchronization is a challenging prospect. One technique involves synchronization by maintaining version information about the data being synchronized. When an endpoint needs to be restored from backup due to hardware or software failure the version information for the data that lives on that node must be repaired to prevent post restore changes from being missed when sending changes to clients. However if a node is restored to a point in time that causes the local timestamp to go backward to a time prior then the node creates new changes that have a version which will look old to clients that were synchronizing with this node prior to restore causing non convergence.

The following presents a simplified summary in order to provide a basic understanding of some novel embodiments described herein. This summary is not an extensive overview and it is not intended to identify key critical elements or to delineate the scope thereof. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

The disclosed architecture is a versioning solution for synchronizing endpoints. After restoring an endpoint some fix up occurs to make that endpoint look like a different endpoint than before the restore operation. In this case the endpoint looks like a new endpoint that knows the data from its prior identity up to a certain point. This allows for new changes generated by the new endpoint to flow to the other endpoints in the topology as well as have the changes that the prior identity sent to other clients flow back to the new endpoint. More generally node data of an original node is to be restored the original node having an original identity. The original identity of the original node is changed to a new identity where the new identity of the original node enables the original node to appear as a new node to other nodes and the new node maintains the restored node data of the original node. Changes from the new node are synchronized to the other nodes and changes from the other nodes are synchronized to the new node based on the new identity.

In other words the architecture maintains information to create the new node in the topology while maintaining prior knowledge. Additionally item level metadata is updated to correlate with the updated knowledge so that changes can be correctly enumerated and applied.

To the accomplishment of the foregoing and related ends certain illustrative aspects are described herein in connection with the following description and the annexed drawings. These aspects are indicative of the various ways in which the principles disclosed herein can be practiced and all aspects and equivalents thereof are intended to be within the scope of the claimed subject matter. Other advantages and novel features will become apparent from the following detailed description when considered in conjunction with the drawings.

The disclosed architecture restores a node by changing the original node identity to a new identity and hence a new node which triggers synchronization between some or all of the nodes of not only prior node data stored on the other nodes for pre restore operations but also node data associated with the new identity post restore. This allows for new changes generated by the new node to flow to the other nodes in the topology as well as have the changes that the original identity sent to other clients flow back to the new node.

Reference is now made to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident however that the novel embodiments can be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

The identity component changes the identity of the node by increasing a local peer value of a key map associated with the node and updating key maps of all topology nodes based on the new identity . The synchronization component synchronizes data changes from the node to the other nodes Nand N and synchronizes changes from the other nodes Nand N to the node based on the new identity . The new identity is created as an incremental increase in a local peer value and new node identifier. The restore component restores data item metadata based on the restored node and data item metadata across scopes that include the data item.

Consider the topology of that includes three nodes node node N and node N . A replica key map for node can be 0 GuidA 1 GuidB 2 GuidC . This information indicates that there are three nodes in the topology the node having the GUID identifier GuidA node having the GUID identifier GuidB and node having the GUID identifier GuidC . The key value zero for node is the local peer value. Therefore the replica for node is GuidA.

The replica key maps for the remaining nodes are the following showing three positions 0 1 2 . The node has a replica key map denoted 0 GuidB 1 GuidC 2 GuidA reflecting that the replica is GuidB and the node has a replica key map denoted 0 GuidC 1 GuidA 2 GuidB reflecting that the replica is GuidC.

After performing a restore of the data the node replica is changed to reflect that this node is different the new node than the node that existed before restore. The reasons for doing this are so that data items altered by the new node appear to be new to all other nodes e.g. node and node and changes made by the old node old meaning the before restore replica that were not captured in the backup will flow back to the new node .

This is accomplished by redefining key zero in the replica key map to be a new replica. This is performed by shifting the existing entries in the replica key map to the right for example thereby increasing the map keys by one and then inserting the new replica GuidD at position zero.

Thus given the above example pre restore replica key map of node is 0 GuidA 1 GuidB 2 GuidC where GuidA is the local replica identifier. The post restore replica key map now include four positions 0 1 2 3 and is 0 GuidD 1 GuidA 2 GuidB 3GuidC where GuidD is now the local replica identifier.

Since the versions for data items are stored in terms of key tickcount where tickcount can be an integer all item level metadata needs to have its associated key incremented by one to reflect the shift in the key map. Therefore a data item that was created by replica GuidA and had a version of fifty is represented in the item metadata as 0 50 where zero is the old replica key of the node . After the shift this updated data item is reflected as 1 50 since GuidA is now at position one in the key map.

This re identification allows changes made by the new node replica GuidD to flow to other nodes since GuidD appears to represent be a new node with new changes. This re identification also allows changes made by the node having GuidA to flow back to the new node having replica GuidD thereby allowing the changes made after the backup of the node was taken to flow back and bring the restored node back up to date.

When a node needs to be restored from backup due to hardware or software failure the version information for the data that is stored on that node is repaired to prevent post restore changes from being missed when sending changes to other nodes. Consider a node A and that node A has sent out an item with version A 50 where fifty is a local timestamp for time at which the change was made. If node A is restored to a point in time that causes its local timestamp to go backward earlier in time so as to precede fifty such as A 49 then any new changes created on that node will have the version A 49 timestamp. This data then appears as old data to the other nodes that were synchronizing with this node prior to restore thereby causing non convergence.

This technique described above relative to node restore and updating applies as well to cross scope metadata by updating the knowledge vector for every scope on the node. That is redefine replica key zero to a new GUID increment the existing keys by one and then add one to all the key values that are stored in the side table.

When rows live in multiple scopes and changes were made in one scope these changes are migrated as being made locally. Consider the following example where the scopes are Sales with a pre remap key length of 4 0 remap value of 5 and Customers scope with a pre remap key length of 100 and 0 remap value of 101 where Ris a row and Sare the scopes 4 100 0 10 0 10 The row was actually changed in S therefore for the other scopes it appears the change came from the server 0 .

After restore the metadata will look like the following 100 where is the remapped 4 for 10 where is the remapped 0 for 10 where is the remapped 0 for

In order avoid storing versions of the metadata for each scope it is ensured that i j such that inferring the ID is consistent and correct across scopes. This can be guaranteed by inserting a new replica key in the map at position zero and shifting all other keys to the right. This consistently maps zero to one across all scopes 1 1 is scope number is the replica

Replica ID zero becomes one more generally key i becomes i 1. Accordingly in the example given above the results are the following 5 100 1 10 1 10 

In support of metadata updates a example tracking table knowledge vector can include the following per table metadata gets updated through triggers or as part of synchronization 

The system depicts three scopes a first scope a second scope and a third scope . The three scopes have corresponding tracking tables first tracking table second tracking table and third tracking table . Each scope is associated data for synchronization a first set of data a second set of data and a third set of data .

Here the nodes listed in association with the first scope include Node Node and Node which nodes will synch the first set of data . Similarly the nodes listed in association with the second scope include Nodeand Node which nodes will synch the second set of data . The nodes listed in association with the third scope include Nodeand Node which nodes will synch the third set of data . The tracking tables and track the knowledge vector and changes thereto for each respective scope and pre restore and post restore as facilitates by the restore component identity component and synch component .

Included herein is a set of flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While for purposes of simplicity of explanation the one or more methodologies shown herein for example in the form of a flow chart or flow diagram are shown and described as a series of acts it is to be understood and appreciated that the methodologies are not limited by the order of acts as some acts may in accordance therewith occur in a different order and or concurrently with other acts from that shown and described herein. For example those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events such as in a state diagram. Moreover not all acts illustrated in a methodology may be required for a novel implementation.

As used in this application the terms component and system are intended to refer to a computer related entity either hardware a combination of software and tangible hardware software or software in execution. For example a component can be but is not limited to tangible components such as a processor chip memory mass storage devices e.g. optical drives solid state drives and or magnetic storage media drives and computers and software components such as a process running on a processor an object an executable module a thread of execution and or a program. By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers. The word exemplary may be used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs.

Referring now to there is illustrated a block diagram of a computing system that executes node restoration and synchronization in accordance with the disclosed architecture. In order to provide additional context for various aspects thereof and the following description are intended to provide a brief general description of the suitable computing system in which the various aspects can be implemented. While the description above is in the general context of computer executable instructions that can run on one or more computers those skilled in the art will recognize that a novel embodiment also can be implemented in combination with other program modules and or as a combination of hardware and software.

The computing system for implementing various aspects includes the computer having processing unit s a computer readable storage such as a system memory and a system bus . The processing unit s can be any of various commercially available processors such as single processor multi processor single core units and multi core units. Moreover those skilled in the art will appreciate that the novel methods can be practiced with other computer system configurations including minicomputers mainframe computers as well as personal computers e.g. desktop laptop etc. hand held computing devices microprocessor based or programmable consumer electronics and the like each of which can be operatively coupled to one or more associated devices.

The system memory can include computer readable storage physical storage media such as a volatile VOL memory e.g. random access memory RAM and non volatile memory NON VOL e.g. ROM EPROM EEPROM etc. . A basic input output system BIOS can be stored in the non volatile memory and includes the basic routines that facilitate the communication of data and signals between components within the computer such as during startup. The volatile memory can also include a high speed RAM such as static RAM for caching data.

The system bus provides an interface for system components including but not limited to the system memory to the processing unit s . The system bus can be any of several types of bus structure that can further interconnect to a memory bus with or without a memory controller and a peripheral bus e.g. PCI PCIe AGP LPC etc. using any of a variety of commercially available bus architectures.

The computer further includes machine readable storage subsystem s and storage interface s for interfacing the storage subsystem s to the system bus and other desired computer components. The storage subsystem s physical storage media can include one or more of a hard disk drive HDD a magnetic floppy disk drive FDD and or optical disk storage drive e.g. a CD ROM drive DVD drive for example. The storage interface s can include interface technologies such as EIDE ATA SATA and IEEE 1394 for example.

One or more programs and data can be stored in the memory subsystem a machine readable and removable memory subsystem e.g. flash drive form factor technology and or the storage subsystem s e.g. optical magnetic solid state including an operating system one or more application programs other program modules and program data .

The one or more application programs other program modules and program data can include the entities and components of the system of the nodes and key maps of the entities and components of the system of and the methods represented by the flowcharts of for example.

Generally programs include routines methods data structures other software components etc. that perform particular tasks or implement particular abstract data types. All or portions of the operating system applications modules and or data can also be cached in memory such as the volatile memory for example. It is to be appreciated that the disclosed architecture can be implemented with various commercially available operating systems or combinations of operating systems e.g. as virtual machines .

The storage subsystem s and memory subsystems and serve as computer readable media for volatile and non volatile storage of data data structures computer executable instructions and so forth. The instructions can exist on non transitory media. Such instructions when executed by a computer or other machine can cause the computer or other machine to perform one or more acts of a method. The instructions to perform the acts can be stored on one medium or could be stored across multiple media so that the instructions appear collectively on the one or more computer readable storage media regardless of whether all of the instructions are on the same media.

Computer readable media can be any available media that can be accessed by the computer and includes volatile and non volatile internal and or external media that is removable or non removable. For the computer the media accommodate the storage of data in any suitable digital format. It should be appreciated by those skilled in the art that other types of computer readable media can be employed such as zip drives magnetic tape flash memory cards flash drives cartridges and the like for storing computer executable instructions for performing the novel methods of the disclosed architecture.

A user can interact with the computer programs and data using external user input devices such as a keyboard and a mouse. Other external user input devices can include a microphone an IR infrared remote control a joystick a game pad camera recognition systems a stylus pen touch screen gesture systems e.g. eye movement head movement etc. and or the like. The user can interact with the computer programs and data using onboard user input devices such a touchpad microphone keyboard etc. where the computer is a portable computer for example. These and other input devices are connected to the processing unit s through input output I O device interface s via the system bus but can be connected by other interfaces such as a parallel port IEEE 1394 serial port a game port a USB port an IR interface etc. The I O device interface s also facilitate the use of output peripherals such as printers audio devices camera devices and so on such as a sound card and or onboard audio processing capability.

One or more graphics interface s also commonly referred to as a graphics processing unit GPU provide graphics and video signals between the computer and external display s e.g. LCD plasma and or onboard displays e.g. for portable computer . The graphics interface s can also be manufactured as part of the computer system board.

The computer can operate in a networked environment e.g. IP based using logical connections via a wired wireless communications subsystem to one or more networks and or other computers. The other computers can include workstations servers routers personal computers microprocessor based entertainment appliances peer devices or other common network nodes and typically include many or all of the elements described relative to the computer . The logical connections can include wired wireless connectivity to a local area network LAN a wide area network WAN hotspot and so on. LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise wide computer networks such as intranets all of which may connect to a global communications network such as the Internet.

When used in a networking environment the computer connects to the network via a wired wireless communication subsystem e.g. a network interface adapter onboard transceiver subsystem etc. to communicate with wired wireless networks wired wireless printers wired wireless input devices and so on. The computer can include a modem or other means for establishing communications over the network. In a networked environment programs and data relative to the computer can be stored in the remote memory storage device as is associated with a distributed system. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.

The computer is operable to communicate with wired wireless devices or entities using the radio technologies such as the IEEE 802.xx family of standards such as wireless devices operatively disposed in wireless communication e.g. IEEE 802.11 over the air modulation techniques with for example a printer scanner desktop and or portable computer personal digital assistant PDA communications satellite any piece of equipment or location associated with a wirelessly detectable tag e.g. a kiosk news stand restroom and telephone. This includes at least Wi Fi or Wireless Fidelity for hotspots WiMax and Bluetooth wireless technologies. Thus the communications can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi Fi networks use radio technologies called IEEE 802.11x a b g etc. to provide secure reliable fast wireless connectivity. A Wi Fi network can be used to connect computers to each other to the Internet and to wire networks which use IEEE 802.3 related media and functions .

The illustrated and described aspects can be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules can be located in local and or remote storage and or memory system.

What has been described above includes examples of the disclosed architecture. It is of course not possible to describe every conceivable combination of components and or methodologies but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the novel architecture is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

