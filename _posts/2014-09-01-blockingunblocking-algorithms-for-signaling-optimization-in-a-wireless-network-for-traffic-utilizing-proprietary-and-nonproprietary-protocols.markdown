---

title: Blocking/unblocking algorithms for signaling optimization in a wireless network for traffic utilizing proprietary and non-proprietary protocols
abstract: According to one aspect, the subject matter described herein includes a method for signaling optimization in a wireless network utilizing proprietary and non-proprietary protocols. A first session is established between an application on a mobile device and a local proxy on the mobile device, a second session is established between the local proxy and a proxy server not located on the mobile device, and a third session is established between the proxy server and a content server. A byte stream present within the first and second sessions is monitored to identify patterns within the byte stream. If a pattern is found, the pattern is used to determine a behavior of the application. If that behavior is one that is a candidate for optimization, signaling optimization is performed between the application and the content server. Signaling optimization includes dismantling the second session, replaying the pattern to the application via the first session, and replaying the pattern to the content server via the third session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08918871&OS=08918871&RS=08918871
owner: Seven Networks, Inc.
number: 08918871
owner_city: San Carlos
owner_country: US
publication_date: 20140901
---
This application is a continuation of International Patent Application Serial No. PCT US14 40772 filed Jun. 3 2014 which claims the benefit of U.S. Provisional Patent Application Ser. No. 61 830 570 filed Jun. 3 2013 and U.S. Provisional Patent Application Ser. No. 61 836 096 filed Jun. 17 2013 the disclosures of each of which are incorporated herein by reference in their entireties.

This disclosure relates to signaling optimization in a wireless network. More specifically it relates to blocking unblocking algorithms for signaling optimization in a wireless network for traffic utilizing proprietary and non proprietary protocols.

An increasing amount of mobile traffic is moving to vendor specific proprietary protocols. Examples include Google s traffic over TCP port 5228 WhatsApp Urban Airship push notifications used by various application vendors Skype Yahoo Mail 2.0 etc. This means that more and more of the application traffic that causes signaling now includes significant contribution from proprietary protocols on top of traffic utilizing standardized protocols such as HTTP HTTPS. Conventional optimization of signaling relies upon some understanding of the protocol being used. Thus there is a clear need for the ability to optimize signaling even for arbitrary proprietary and or non standard protocols e.g. where the underlying protocol definition may be unknown.

The subject matter disclosed herein includes an architecture e.g. the distributed system comprised of the local proxy and or the proxy server to optimize signaling for arbitrary proprietary and or non standard protocols in addition to standard protocols such as HTTP or HTTPS via blocking and or unblocking algorithms.

According to one aspect the subject matter described herein includes a method for signaling optimization in a wireless network utilizing proprietary and non proprietary protocols. The method includes establishing a first session between an application on a mobile device and a local proxy on the mobile device establishing a second session between the local proxy and a proxy server not located on the mobile device and establishing a third session between the proxy server and a content server. The method also includes monitoring a byte stream present within the first and second sessions to identify patterns within the byte stream and in response to identifying a pattern within the byte stream determining a behavior of the application based on the pattern determining whether the behavior of the application is a candidate behavior for optimization and if so performing signaling optimization between the application and the content server where performing signaling optimization includes dismantling the second session replaying the pattern to the application via the first session and replaying the pattern to the content server via the third session.

According to another aspect the subject matter described herein includes a system for signaling optimization in a wireless network utilizing proprietary and non proprietary protocols. The system includes a mobile device that includes an application and a local proxy a proxy server not located on the mobile device and a content server. A first session is established between the application and the local proxy a second session is established between the local proxy and the proxy server and a third session between the proxy server and the content server. A byte stream present within the first and second sessions is monitored to identify patterns within the byte stream. If a pattern is identified the behavior of the application is determined based on that pattern. If that behavior is a candidate for optimization then a signaling optimization is performed between the application and the content server including dismantling the second session replaying the pattern to the application via the first session and replaying the pattern to the content server via the third session.

According to another aspect the subject matter described herein includes a computer program product for signaling optimization in a wireless network utilizing proprietary and non proprietary protocols. The computer program product includes a non transitory computer readable storage medium having computer readable code embodied therewith the computer readable code configured for establishing a first session between an application on a mobile device and a local proxy on the mobile device establishing a second session between the local proxy and a proxy server not located on the mobile device establishing a third session between the proxy server and a content server monitoring a byte stream present within the first and second sessions to identify patterns within the byte stream and in response to identifying a pattern within the byte stream determining a behavior of the application based on the pattern determining whether the behavior of the application is a candidate behavior for optimization and if so performing signaling optimization between the application and the content server where performing signaling optimization includes dismantling the second session replaying the pattern to the application via the first session and replaying the pattern to the content server via the third session.

The following description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding of the disclosure. However in certain instances well known or conventional details are not described in order to avoid obscuring the description. References to one or an embodiment in the present disclosure can be but not necessarily are references to the same embodiment and such references mean at least one of the embodiments.

Reference in this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the disclosure. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover various features are described which may be exhibited by some embodiments and not by others. Similarly various requirements are described which may be requirements for some embodiments but not other embodiments.

The terms used in this specification generally have their ordinary meanings in the art within the context of the disclosure and in the specific context where each term is used. Certain terms that are used to describe the disclosure are discussed below or elsewhere in the specification to provide additional guidance to the practitioner regarding the description of the disclosure. For convenience certain terms may be highlighted for example using italics and or quotation marks. The use of highlighting has no influence on the scope and meaning of a term the scope and meaning of a term is the same in the same context whether or not it is highlighted. It will be appreciated that same thing can be said in more than one way.

Consequently alternative language and synonyms may be used for any one or more of the terms discussed herein nor is any special significance to be placed upon whether or not a term is elaborated or discussed herein. Synonyms for certain terms are provided. A recital of one or more synonyms does not exclude the use of other synonyms. The use of examples anywhere in this specification including examples of any terms discussed herein is illustrative only and is not intended to further limit the scope and meaning of the disclosure or of any exemplified term. Likewise the disclosure is not limited to various embodiments given in this specification.

Without intent to limit the scope of the disclosure examples of instruments apparatus methods and their related results according to the embodiments of the present disclosure are given below. Note that titles or subtitles may be used in the examples for convenience of a reader which in no way should limit the scope of the disclosure. Unless otherwise defined all technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art to which this disclosure pertains. In the case of conflict the present document including definitions will control.

Existing signaling optimization systems and methods for reducing mobile network congestion can optimize mobile traffic over standard and non proprietary application level protocols including but not limited to Hypertext Transfer Protocol HTTP Hypertext Transfer Protocol Secure HTTPS File Transfer Protocol FTP Simple Mail Transfer Protocol SMTP Internet Message Access Protocol IMAP Post Office Protocol POP and the like. However many mobile applications are moving away from the standard protocols towards vendor specific proprietary protocols. For example Google utilizes a non standard Transmission Control Protocol TCP port 5228. By way of another example the WhatsApp mobile application uses a customized version of the Extensible Messaging and Presence Protocol XMPP . Similarly some applications such as Skype and Yahoo mail use their own proprietary protocols while others such as Urban Airship s push notifications protocol is used by various vendors.

Existing signaling optimization systems and methods replay or replicate entire transaction as instructed by a client which means that the server performing the signal optimization needs to establish any session TCP socket and any application level handshakes Secure Sockets Layer SSL etc. autonomously. However to do so the protocols must be well understood. For example the header and other protocol specific data must be known before any optimization can be performed. As proprietary protocols are not standardized and not well understood mobile traffic over such proprietary protocols cannot be optimized by existing optimization systems and methods.

Embodiments of the present disclosure include application blocking unblocking algorithms for signaling optimization in a wireless network for traffic utilizing both proprietary and non proprietary protocols. The disclosed technology includes an architecture e.g. a distributed system comprised of a local proxy and or a proxy server that optimizes signaling for arbitrary proprietary and or non standard protocols in addition to standard protocols such as HTTP HTTPS FTP SMTP IMAP POP XMPP and the like in one embodiment. In a further embodiment the disclosed technology provides a protocol agnostic systems and methods for signaling optimization for any traffic in a wireless network.

In one embodiment a Transmission Control Protocol TCP stream is passed as a byte stream from an application to a local proxy over a first session from the local proxy to a proxy server over a second TCP session and from the proxy server to a content server over a third TCP session. The local proxy observes and identifies patterns within the byte stream without being aware of the underlying protocol. Once a pattern is identified the second TCP session is torn down such that the first TCP session replays the pattern to the application and third TCP session replays the pattern to the content server. Once either side detects a change in the pattern the second TCP session is re established to deliver the changed content to the other end.

When it is not possible to identify a pattern within a byte stream and perform a direct replay of the binary transactions and or in addition to the TCP stream optimization the disclosed innovation herein provides application blocking unblocking strategies that can optimize signaling in the wireless network for traffic utilizing various proprietary and non proprietary protocols.

Embodiments of the present disclosure include systems and methods for optimizing signaling in a wireless network for traffic utilizing proprietary and or non proprietary protocols by blocking unblocking various types of applications and or traffic and triggering reconnecting of applications. These keepalive strategies facilitate management of traffic and or resource conservation between mobile devices e.g. wireless devices and a remote server such as an application server content provider or a messaging server e.g. Google Cloud Messaging GCM server Exchange ActiveSync EAS server via the distributed proxy system.

In the embodiment illustrated in host server includes a server cache for storing periodic and or often used signaling messages for example. In one embodiment a network subscriber may use a mobile device that includes its own local cache for storing periodic or often used signaling messages. Mobile device may include a user interface by which subscriber may use to configure mobile device appropriately. In the embodiment illustrated in for example mobile device may connect to mobile network through a cell phone tower or other network access equipment.

In the embodiment illustrated in mobile device includes both a proxy unaware mobile application and a proxy aware mobile application . The proxy aware mobile application communicates with local proxy via a proxy application programming interface API . In the embodiment illustrated in mobile device also includes an OS a context API a network interface that includes interface modules for SMS WiFi cellular etc. and a cache .

In the embodiment illustrated in local proxy includes a user activity module a caching policy manager that includes a application protocol module a traffic shaping engine that includes an alignment module and a batching module a connection manager that includes a radio controller and a heartbeat manager and a request transaction manager that includes an application behavior detector . In one embodiment application behavior detector includes a pattern detector an application profile generator and a prioritization engine .

In the embodiment illustrated in mobile device includes a proprietary non standard protocol adaptation engine and an application blocking unblocking module which are are described in more detail in .

In the embodiment illustrated in adaptation engine includes a transaction detection engine that includes a protocol analyzer a transaction pattern detection engine and a binary matching an normalization engine . Adaptation engine also includes a routing rule optimizer a pattern replay module an application byte stream generator a byte stream pattern recognition engine a pattern change detection engine a session manager a heartbeat manager and a protocol encoding decoding module .

In the embodiment illustrated in application blocking unblocking module includes a keepalive intensive application blocking unblocking module a least complaint blocking unblocking module a UDB traffic blocking unblocking module an idle application traffic blocking unblocking module and an application reconnect trigger module . The operation of application blocking unblocking module will be described in more detail below.

In the embodiment illustrated in both adaptation engine and application blocking unblocking module communicate with each other and both have access to local cache .

In the embodiment illustrated in a host server provides and controls access between mobile devices and various service providers such as an ad server A a promotional content server B an e coupon server and the like as well as other application server service provider s . Host server may also have access to a server cache .

In the embodiment illustrated in host server includes a network interface a connection and content metadata repository a device information repository a network service provider repository and a proxy server . In the embodiment illustrated in network interface includes interface modules for various networks network protocols including for example an SMS interface a WiFi interface and a cellular interface.

In the embodiment illustrated in proxy server includes an application tracking engine an HTTP access engine a proxy controller a traffic shaping engine a proprietary non standard protocol adaptation engine a caching policy manager and a connection manager . In one embodiment HTTP access engine includes a new data detector module . In one embodiment proxy controller includes an activity behavior awareness module a priority awareness module and a data invalidator module . In one embodiment traffic shaping engine includes a control protocol module and a batching module . In one embodiment caching policy manager includes an application protocol module . In one embodiment connection manager includes a radio controller an internet WiFi controller and a heartbeat manager .

In the embodiment illustrated in caching policy manager includes a metadata generator a local cache invalidator a poll schedule generator an application protocol module a cache look up engine an application cache policy repository a cache appropriateness decision engine and a cache or connect selection engine . In one embodiment local cache invalidator includes a time to live TTL manager A. In one embodiment poll schedule generator includes a schedule update engine A and a time adjustment engine B. In one embodiment cache appropriateness decision engine includes a timing predictor A a content predictor B a request analyzer C and a response analyzer D. In one embodiment cache or connect selection engine includes a response scheduler A. In the embodiment illustrated in metadata generator and cache look up engine within caching policy manager access cache .

In the embodiment illustrated in application behavior detector includes a poll interval detector a pattern detector an application profile generator a prioritization engine and an application profile repository . In one embodiment poll interval detector includes a long poll detector A which may include a request response tracking engine B and a long poll hunting detector C. In one embodiment application profile generator includes a response delay interval tracker A.

In the embodiment illustrated in caching policy manager and application behavior detector communicate with a blacklist manager which has access to both the application cache policy repository within caching policy manager and the application profile repository within application behavior detector .

In the embodiment illustrated in caching policy manager includes an identifier normalizer and a cache defeat resolution engine . In one embodiment identifier normalizer includes a cache defeat parameter handler and a hash engine . In one embodiment cache defeat resolution engine includes a pattern extraction module and a cache defeat parameter detector . In one embodiment cache defeat parameter detector includes a random parameter detector and a time date parameter detector .

In the embodiment illustrated in application behavior detector includes a pattern detector . In one embodiment pattern detector includes a pattern extraction module a random parameter detector and a time date detector .

In the embodiment illustrated in network configuration engine includes a wireless generation standard selector A a data rate specifier B an access channel selection engine C and an access point selector D.

In the embodiment illustrated in user activity module includes a user activity tracker A a user activity prediction engine B and a user expectation manager C. In the embodiment illustrated in application behavior detector includes a prioritization engine A a time criticality detection engine B an application state categorizer C and an application traffic categorizer D. In one embodiment application state categorizer C includes modules for detecting the state of both foreground and background applications. In one embodiment application traffic categorizer D includes modules for categorizing both interactive traffic and maintenance traffic.

When mobile application needs data from content server it sends a data request to local proxy which forwards the request or generates a new request to proxy server which forwards that request or generates its own new request to content server . Alternatively local proxy can send a request directly to content server bypassing proxy server . Content server sends a response which passes back to mobile application as messages and .

After one or more transactions have occurred local proxy may detect a transaction request response pattern block . In the embodiment illustrated in for example these transaction patterns may be detected by pattern detector module within request transaction manager or by another component within local proxy . Likewise proxy server may detect a transaction pattern block . In the embodiment illustrated in for example these patterns may be detected by activity behavior awareness module within proxy controller or by another component with proxy server .

In response to detecting these transaction patterns the second session is terminated . From this point on local proxy continues to replay the transaction response e.g. provide the previously captured response to mobile application and proxy server continues to replay the transaction pattern e.g. provide the previously captured request to content server . In this manner the interactions across the first session between mobile application and local proxy will be replicated as will the interactions across the third session between proxy server and content server without the need for the second session between local proxy and proxy server .

At step if heartbeats are received from the local proxy the process moves to step in which the session with the content server is disconnected and the process ends. If at step heartbeats are received from the local proxy the transaction pattern is replayed to the content server step and the process moves to step .

At step if a changed byte stream is detected the session with the local proxy is established step and the byte streams are passed to the local proxy content server step . In one embodiment the process returns to step and continues from there. If at step a changed byte stream is not detected the process returns to step and continues from there.

If at step the request is not found in the cache the request is sent step . When a response to the request is received step the response is checked to determine whether it is cacheable step . If at step the response is not cacheable the response is delivered step . If the response is cacheable the response is cached step the request is polled step and the response is delivered step . 

If at step the request is found in the cache the cache entry is checked for validity step . If at step the request is determined to be invalid the process goes to step and continues from there. If at step the request is determined to be valid the process checks that the request contains a validator step . If at step the request contains a validator then a validating response is formed step and delivered step . If at step the request does not contain a validator a response is formed from the cache step and delivered step . 

In the embodiment illustrated in home screen widget issues a data request to AS CP and AS CP sends a data response to home screen widget . In one embodiment both the data request and the data response travel through at least one of the local proxy caching proxy and host server . Local proxy may then issue a proxied data request to caching proxy which may respond with a proxied data response .

In the embodiment illustrated in home screen widget may then issue a monitor data request which is received by host server and forwarded or reissued as monitor data request to AS CP . AS CP may then issue the same response . If home screen widget issues a proxied data request local proxy may satisfy that request by issuing a response from local cache and thus avoid traffic between mobile device and server side components . Meanwhile host server may continue to issue periodic monitor data requests . If AS CP issues a changed response i.e. a response that is different from the previous response host server forwards the changed response Thus when home screen widget issues the next proxied data request local proxy will not respond from its local cache but will instead forward the data request to caching proxy and caching proxy will satisfy that request from its cache.

At step mobile application widget again polls application server content provider . At step local proxy intercepts the poll. At step local proxy detects that cache content is unavailable and decides to set up the polled source for caching. At step local proxy forwards the poll request to the source. At step application server content provider receives the poll request from the mobile application widget and provides a response to satisfy the current request. At step mobile application widget receives the response to satisfy the request from the application server content provider .

At step local proxy tracks polling frequency of the application and sets up a polling schedule for the server side entity. Server side entities include but are not limited to a host server a server cache and a caching proxy . At step local proxy sends the cache setup to the server side entity. At step the server side entity receives the cache setup including an identification of the application server content provider to be polled and a polling schedule. At step the server side entity polls the application server content provider to monitor the response to the request. At step application server content provider receives the poll from the server side entity and sends the response. At step the server side entity receives the same response and then polls the application server content provider again based on the polling schedule. At step application server content provider receives poll from the server side entity and sends the response. At step the server side entity detects changed or new response and notifies the local proxy that the response has changed since the last time. At step the server side entity stores the new or changed response in the server side entity. At step local proxy receives notification that new or changed data is available and in response invalidates the relevant cache entries.

At step mobile application widget polls application server content provider . At step local proxy determines that no valid cache entry is available and requests a response from the server side entity. At step the server side entity receives the request for the new response and sends the response to the local proxy . At step the request is satisfied from the server side entity e.g. the server side entity sends the response to mobile application widget .

At step mobile application widget polls application server content provider . At step local proxy determines that no valid cache entry is available and forwards the poll to the application server content provider . At step application server content provider receives the poll from local proxy and sends the response. At step the request from mobile application widget is satisfied by the application server content provider .

At step mobile application widget polls application server content provider . At step local proxy intercepts poll and proxy determines that a cache defeating mechanism is being employed by application server content provider . At step local proxy detects that cache content is unavailable and decides to setup the polled source for caching. At step local proxy extracts a pattern of an identifier of the request and tracks polling frequency of mobile application widget and sets up a polling schedule for the server side entity which may be a host server a server cache or a caching proxy for example. At step local proxy forwards the poll request to the source. At step application server content provider receives the poll request and provides a response to satisfy the current request. At step mobile application widget receives from the application server content provider the response to satisfy the request.

At step local proxy caches the response and stores a normalized version of the identifier in association with the received response for future identification and retrieval. At step local proxy sends the cache setup to the server side entity including the identifier or a normalized version of the identifier. At step the server side entity receives the cache setup including an identification of application server content provider to be polled and a polling schedule. At step the server side entity polls application server content provider to monitor the response to the request. At step application server content provider receives the poll from server side entity and sends the response. At step the server side entity receives the same response and pulls the application based on the polling schedule. At step application server content provider receives the poll from the server side entity and sends the response. At step the server side entity detects new or changed response and notifies local proxy . At step the server side entity stores new or changed response in the server side entity. At step local proxy receives notification that new or changed date is available and invalidates the relevant cache entries.

At step mobile application widget polls application server content provider . At step local proxy determines that no valid cache entry is available and retrieves the response from the server side entity. At step the server side entity receives request for the new response and sends the response to the local proxy . At step the request from mobile application widget is satisfied by the server side entity.

At step mobile application widget polls application server content provider . At step local proxy determines that no valid cache entry is available and forwards the poll to application server content provider . At step application server content provider receives the poll from local proxy and sends the response. At step the request from mobile application widget is satisfied by the application server content provider .

Once the response has been cached at least two events can occur. The first event is the detection of a subsequent request step . When this happens a cache look up is performed in the local cache to identify the cache entry to be used when responding to the subsequent request step and the response is served from the cache to satisfy the subsequent request step . The second event is an invalidation event in which case it is determined whether the response currently stored in the cache needs to be updated step . If so the response stored in the cache of the mobile device is invalidated and or removed from the cache step . 

In the embodiment illustrated in request analysis can include a number of tests. For example the request method may be identified step and the request may be deemed cacheable or not cacheable based on the method step . The size of the request may be checked step and a request may be cached if the request doesn t exceed a threshold size step . In one embodiment the periodicity of information between the request and other requests generated by the same client may be determined step and requests that are identified as periodic are cached while non periodic requests are not cached step . In one embodiment requests that satisfy a caching requirement may be cached step while those that do not satisfy any caching requirements are not cached step . In an alternative embodiment requests that fail any caching requirement are not cached i.e. they must meet all caching requirements before they are cached.

In the embodiment illustrated in response analysis can also include a number of tests to determine cacheability. For example a response may be identified as cacheable or not cacheable based on its status code steps and based on the size of the response steps and based on whether the response body includes dynamic content steps and and or whether or not transfer encoding is used in the response step . 

In the embodiment illustrated in request tracking may include determining if there are predictable patterns in the timing of the request step and or determining whether request intervals fall within a tolerance level step . If either test returns true the response content can be cached step otherwise the response is not cached step . 

In the embodiment illustrated in response tracking may include examining hash values generated from the response bodies of the responses step and or examining status codes associated with the responses step . If either test indicates that the responses are the same or that there is a similarity in the content of at least two of the responses step the response content can be cached step otherwise the response is not cached step . 

For example in the embodiment illustrated in if a response is received for a request that has been identified as being periodic step that response may be cached as a cache entry in a cache of the mobile device step . The host may be monitored at a rate to verify relevance or validity of the cache entry step after which the response may be served from the cache to satisfy a subsequent request step . In one embodiment step may be skipped.

Alternatively or in addition a rate to monitor a host may be determined from the request intervals step . After this the rate at which the given host is monitored to verify relevance or validity of the cache entry may be set or updated step . This value may be used by step . Alternatively after step a change in request intervals for requests generated by the client may be detected step which triggers computation of a different rate based on the change in request intervals step . 

In the embodiment illustrated in identification of the application is followed by categorizing the application step and then applying one or more tests to determine whether the new or changed data should be sent to the mobile device step followed by sub flow B which is shown in more detail in or suppressed i.e. not sent to the mobile device step followed by sub flow A which is shown in more detail in . For example the new or changed data may be sent to the mobile device if the application is in an active state and interacting with a user on the mobile device step or if the application is running in the foreground on the mobile device step while an application running in the background would be have its new or changed data suppressed step . 

In the embodiment illustrated in the determination of priority or time criticality is followed by categorizing the data step and then applying one or more tests to determine whether the new or changed data should be sent to the mobile device step or suppressed step . For example data may be sent if the data is high priority step if the data is time critical step or if the user is waiting for a response that would be provided in the data step otherwise the data would be suppressed.

In the embodiment illustrated in if an application is in an active state interacting with a user on the mobile device step or the user is waiting for a response that would be provided in data step an additional sub flow C may be performed. Sub flow C is shown in more detail in .

The operation of systems and methods according to embodiments of the subject matter described herein will now be described in detail.

In one embodiment the local proxy identifies keepalives e.g. heartbeats based on a combination of parameters including by way of example periodicity size thresholds similar repeating content and or based on knowledge of the actual application level protocol and or applications that are keepalive heavy e.g. applications that send keep alives frequently . The local proxy can then block applications that are keepalive heavy or any application that exhibits certain keepalive behavior for a given percent of keepalive periods e.g. via the application blocking unblocking module depicted in . In one implementation blocking the applications which blocks keepalive non interactive traffic and other traffic can include blocking specific ports for the given percent of keepalive periods. The blocking strategy can be managed via a policy enforcement module. This blocking strategy may have a user impact cause additional bytes and or cause impacts beyond keepalives. However the blocking strategy can be refined using some of the other keepalive optimization algorithms described below.

In one implementation the application can be blocked cyclically during the screen off period. In other words the application can be given access for limited periods during the screen off period.

In one embodiment applications that are inactive not much happening are identified and blocked. If for example a user is running Skype but the user has never received initiated a voice over Internet Protocol VOIP call and all his or her instant messages are clustered then the application can be selected for blocking when the screen is off. The user impact is minimized by this strategy since the blocking is based on the usage history behavior which indicates that the user has never depended on arrival of a call or IM when the screen is off. In addition to the probability of application use based on recent or historical behavior the blocking can be further based on delay time after screen is off cost of the application state of the mobile device resources and the like. In a further embodiment the least complaint blocking e.g. via the least complaint blocking unblocking module depicted in can be designed or customized to define a level of optimization desired. For example the local proxy can start with polling offload optimization perform smart connection alignment i.e. aligning transactions from different applications on the same radio connection and then add least complaint blocking to get the level of optimization desired.

In one embodiment signaling due to applications such as Skype that utilize the UDP protocol can be reduced or optimized by implementing a blocking strategy that blocks all UDP traffic entirely when the screen is off immediately or after a configurable delay e.g. via the UDP traffic blocking unblocking module depicted in . In one implementation a configuration option that blocks UDP e.g. Skype UDP traffic entirely without regard to the screen state can be provided to further reduce signaling due to applications with UDP traffic.

The UDP traffic can be blocked by using iptables rule. For example UDP traffic with the Skype app UID can be dropped. To block the UDP the iptables rule that was added in blocking period can be deleted.

In one implementation UDP traffic can be blocked when certain conditions are satisfied. For example when the user is in optimization mode when the application e.g. Skype is detected or available for optimization when the screen is off and or a grace period since turning off of the screen is reached the UDP traffic can be blocked. To unblock the UDP traffic one or more conditions may need to be satisfied. Conditions for unblocking can include screen turn on application optimization off optimization mode off application uninstall or upgrade and or a combination thereof.

In one embodiment signaling due to certain applications e.g. Spotify can be reduced by blocking application client generated packets when the application is completely idle or not active or performing its function e.g. when Spotify is not actively playing audio e.g. via the idle application traffic blocking unblocking module depicted in . The application client generated traffic can be unblocked when the application moves to the foreground or starts performing its function e.g. Spotify starts playing audio . In one implementation the complete idle state can be detected based on keepalive pattern e.g. 10 successive keepalives detected when screen is off when typically the client sends a keepalive every one minute . The application traffic can be blocked using iptables rule and unblocked by removing iptables rules. The blocking can be triggered when the optimization mode is on the application blocking is on and when the screen is off for example. The unblocking can be triggered when one or more conditions including screen on optimization off application blocking off or application uninstalled or upgraded is true.

In one implementation the signaling optimization of an application e.g. the Spotify application can be enabled or disabled by using the Policy Management System PMS configuration . In some cases the heartbeat or keepalive pattern from the application side may vary. For example the interval of heartbeats from the application side would be increased if there were multiple server side initialized heartbeats though they are 11 bytes also. The complete idle state can then be detected using time threshold. For example if continuous 11 bytes heartbeat either in 10 times or 10 minutes in screen off is observed block the traffic. Or b if continuous 11 bytes heartbeat either in 12 times or 12 minutes regarding the screen status is observed flag it as blocking and start to block it immediately if it enters into screen off. The logic may be applied in the Wi Fi network and or the mobile network. An example logic for detecting a new pattern of the application e.g. Spotify in every configurable duration e.g. 2 min to a default of 5 min may include 

For mobile platforms such as the Android platform which provide a service to monitor the status of an audio playback the heartbeats can be monitored and a timer grace period timer can be started only when audio playback is inactive. In some embodiments the playback service status can be used to detect whether a media or any other application such as the Spotify application is in an idle state. While blocking of application client generated traffic has been described with Spotify as an example the disclosed technology may be generalized and may be applicable to various other applications.

In some applications e.g. Twitter users may not expect notification while the screen of their wireless devices is off. The disclosed innovation can identify such applications and block data access while the screen is off i.e. user presence is not observed . When the screen is on or user presence is detected the application can be unblocked and an intent in Android based systems can be sent to the application or broadcast to cause the application to reconnect and sync e.g. via the application reconnect trigger module depicted in . In one implementation the connectivity intent can be sent or broadcast on a radio up event.

To reduce signaling due to certain applications e.g. WhatsApp Viber a blocking strategy can be implemented where when the application moves to the background all client generated traffic can be blocked and all server connections can be closed. The application can be unblocked when either the application moves to the foreground or a push message e.g. Google Cloud Messaging GCM push message is received. When unblocking a timer can be started. If the application stays in the background beyond a configurable timeout value the blocking of the application can be resumed.

In one embodiment applications such as Viber and Whatsapp can be blocked whenever the screen is off or after grace off period of 10 seconds . In one implementation any existing connection initiated by the applications can be terminated when screen is switched off to ensure that they do not keep using existing socket connections.

In a further implementation to further optimize signaling an application that has been blocked can be unblocked when a GCM push message targeted for that application e.g. WhatsApp Viber is detected or received. In one embodiment whenever there is incoming traffic for Google GCM port 5228 network traffic for the applications e.g. Whatsapp Viber etc. is allowed for a grace off period e.g. 10 seconds 20 seconds or other configurable period even when the screen is off thus allowing them to fetch any incoming data if they receive GCM notification. When the screen is on traffic for the applications e.g. Viber and Whatsapp can be allowed.

The application blocking unblocking can be illustrated with an example use case where a user is using a phone actively the screen is on and Viber keeps TCP socket open. When the user stops using phone screen goes off. The disclosed system after grace off period a sets firewall rule to block any socket connection by either Viber or Whatsapp b terminates any existing socket connection initiated by either Viber or Whatsapp. When there is some incoming traffic e.g. for Viber the disclosed system a detects that there is incoming traffic for Google GCM connection port 5228 b allows traffic removed firewall rule to block traffic for Viber and Whatsapp for short period of time c Viber is able to connect and receive incoming traffic during this time window d Viber and Whatsapp connections are terminated and firewall rules are re enabled until either screen goes on or there is incoming traffic at GCM connection port 5228 .

In one embodiment the distributed proxy or the local proxy can be configured to allow traffic on GCM notifications for particular applications only instead of any incoming GCM traffic. The local proxy for example can react only to notification to the particular apps being optimized by decoding the GCM traffic. Opening the window for traffic when there is GCM traffic should not cause any additional connections radio is up anyways and actually the application does not necessarily use the window.

In one embodiment a generic application handlers framework can be created to optimize signaling behavior of applications such as Viber Whatsapp etc. The framework can be implemented on the client side with limited or no server dependencies. For example on the server side Policy Management System PMS and PCF can be configured. The framework can be application agnostic configurable and or extendable. Scripts defined by entrance conditions and actions and optional exit condition s and action s can be used. Various conditions may be supported and all of the conditions or in some cases some of the conditions may need to be met for an action trigger. Example conditions include timer initiated for entrance by the exit event and vice versa radio timer same as timer radio aware screen state on off traffic triggered by interception of TCP data meeting the defined filter media state on off heartbeat state on off or the like. Actions may include activate deactivate the rule group s by given name s and drop sessions meeting the defined filter.

Moreover while embodiments have been described in the context of fully functioning computers and computer systems those skilled in the art will appreciate that the various embodiments are capable of being distributed as a program product in a variety of forms and that the disclosure applies equally regardless of the particular type of machine or computer readable media used to actually effect the distribution.

Further examples of machine readable storage media machine readable media or computer readable storage media include but are not limited to recordable type media such as volatile and non volatile memory devices floppy and other removable disks hard disk drives optical disks e.g. Compact Disk Read Only Memory CD ROMS Digital Versatile Disks DVDs etc. among others and transmission type media such as digital and analog communication links.

Unless the context clearly requires otherwise throughout the description and the claims the words comprise comprising and the like are to be construed in an inclusive sense as opposed to an exclusive or exhaustive sense that is to say in the sense of including but not limited to. As used herein the terms connected coupled or any variant thereof means any connection or coupling either direct or indirect between two or more elements the coupling of connection between the elements can be physical logical or a combination thereof. Additionally the words herein above below and words of similar import when used in this application shall refer to this application as a whole and not to any particular portions of this application. Where the context permits words in the above Detailed Description using the singular or plural number may also include the plural or singular number respectively. The word or in reference to a list of two or more items covers all of the following interpretations of the word any of the items in the list all of the items in the list and any combination of the items in the list.

The above detailed description of embodiments of the disclosure is not intended to be exhaustive or to limit the teachings to the precise form disclosed above. While specific embodiments of and examples for the disclosure are described above for illustrative purposes various equivalent modifications are possible within the scope of the disclosure as those skilled in the relevant art will recognize. For example while processes or blocks are presented in a given order alternative embodiments may perform routines having steps or employ systems having blocks in a different order and some processes or blocks may be deleted moved added subdivided combined and or modified to provide alternative or subcombinations. Each of these processes or blocks may be implemented in a variety of different ways. Also while processes or blocks are at times shown as being performed in series these processes or blocks may instead be performed in parallel or may be performed at different times. Further any specific numbers noted herein are only examples alternative implementations may employ differing values or ranges.

The teachings of the disclosure provided herein can be applied to other systems not necessarily the system described above. The elements and acts of the various embodiments described above can be combined to provide further embodiments.

Any patents and applications and other references noted including any that may be listed in accompanying filing papers are incorporated herein by reference. Aspects of the disclosure can be modified if necessary to employ the systems functions and concepts of the various references described above to provide yet further embodiments of the disclosure.

These and other changes can be made to the disclosure in light of the above Detailed Description. While the above description describes certain embodiments of the disclosure and describes the best mode contemplated no matter how detailed the above appears in text the teachings can be practiced in many ways. Details of the system may vary considerably in its implementation details while still being encompassed by the subject matter disclosed herein. As noted above particular terminology used when describing certain features or aspects of the disclosure should not be taken to imply that the terminology is being redefined herein to be restricted to any specific characteristics features or aspects of the disclosure with which that terminology is associated. In general the terms used in the following claims should not be construed to limit the disclosure to the specific embodiments disclosed in the specification unless the above Detailed Description section explicitly defines such terms. Accordingly the actual scope of the disclosure encompasses not only the disclosed embodiments but also all equivalent ways of practicing or implementing the disclosure under the claims.

While certain aspects of the disclosure are presented below in certain claim forms the inventors contemplate the various aspects of the disclosure in any number of claim forms. For example while only one aspect of the disclosure is recited as a means plus function claim under 35 U.S.C. 112 6 other aspects may likewise be embodied as a means plus function claim or in other forms such as being embodied in a computer readable medium. Any claims intended to be treated under 35 U.S.C. 112 6 will begin with the words means for . Accordingly the applicant reserves the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the disclosure.

