---

title: Resource management in a processor
abstract: A processor system is arranged to execute user selected applications. A manager module is configured to detect a user selection of an application and configured to initiate a launch process. A supervisor module is configured to intercept the launch process initiated by the manager module and detect whether the application is a trusted application or an untrusted application. Trusted applications have a privilege to access resources without authorization, and untrusted applications do not have the privilege. The supervisor module has the privilege to access the resources. When the application is untrusted, the application is launched in a container, and at least one of the resources is delivered to the untrusted application in the container.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09552477&OS=09552477&RS=09552477
owner: STMICROELECTRONICS ASIA PACIFIC PTE, LTD.
number: 09552477
owner_city: Singapore
owner_country: SG
publication_date: 20140318
---
In computer devices such as tablets smartphones etc. a user can install and launch applications to be executed by a processor of the device. In order for an application to execute it requires a set of resources to be delivered from the processor. These resources may be hardware or software resources. Access to some resources may involve the application interacting with other parts of the processor system software or hardware in such a way that security issues could be affected.

Embodiments of the present invention ameliorate security risks when applications are requesting resources.

According to the disclosure there is provided a processor for executing a plurality of user selected applications each application comprising a computer program executable by the processor a processor comprising 

The supervisor module can be configured on interception of the launch process to execute a resource client to identify said at least one resource for the container.

In one example the application is a browser and the resource is an IP Internet Protocol address for establishing a connection with the application. The supervisor module is configured to dynamically allocate IP addresses and wherein the container of the untrusted application is statically configured with an IP address obtained by the supervisor module.

The supervisor module is preferably configured to deliver the resource to the container prior to executing the application.

In the processor it is possible that at least one of said plurality of user selected applications is detected as trusted. In that case it is launched with privileges to access resources for executing the application.

The processor can comprise a resource manager under the control of the supervisor module wherein the resource manager manages resources for the trusted and untrusted application.

Where there are trusted and untrusted applications the resource manager is configured under the control of the supervisor module to dynamically allocate IP addresses for use by the supervisor module in the static configuration of containers for untrusted applications and directly obtainable by trusted applications.

Embodiments also provide a method of managing resources for a plurality of user selected applications executable by a processor wherein each application comprises a computer program the method comprising 

If it is detected that the application is trusted the application is launched with privileges to access resources.

In the embodiment a resource manager allocates resources to trusted applications directly and to applications executing in containers only via the supervisor module.

Embodiments also provide a computer program product comprising a transitory or non transitory e.g. volatile or non volatile media holding computer instructions which when executed implement the method defined above.

There is a set of trusted applications and a set of untrusted applications. Among trusted applications there are the supervisor application and also the broadcast middleware. One example of an untrusted application could be a browser because it has access to the web. Each application has its own window which is managed by a window manager described later . The supervisor is the master of the window manager whereas other applications are slave. Each application communicates with the supervisor and window manager using a mechanism based on a unique identifier for each application.

The application manager is responsible for maintaining an application list and providing an interface to access this list to the core . The concept of trusted untrusted will be explained in more detail hereinafter.

A resource manager defines the various shared resources an application can use. These can for example be physical resources such as the communication resource e.g. territorial satellite cable tuner video instances graphics display ports e.g. GDP2 etc. In any physical system access to resources is inherently limited and it is the responsibility of the resource manager to manage the limited resources so that each application can function effectively. Before launching an application will acquire the resources that it needs for its proper operation before it can be launched. This is accomplished through the resource manager. The resource manager maintains the resource list and provides an interface to the core to access this list.

A windows manager is connected to the core and communicates directly with a frame buffer which forms part of the window manager . In the window manager is shown as two separate components a manager and a frame buffer . The window manager and its components can be a known window manager system cooperating with the kernel in a known way to control a display. The windows manager which forms part of the supervisor application provides a special display control function which will be described more fully later. In brief it maintains and draws four separate windows on a display screen via the frame buffer . It also provides an interface to display text for warning messages and displays a CPU status. A user interface module operates under the control of the core and can control the browser environment to draw an application launch bar.

In an alternative embodiment shown in a mechanism creates a hole in a window and handles the display inside the window by some hardware components. A hardware compositor component manages the composition between the output of the frame buffer and those components. Two frame buffers can be mixed together by this hardware compositor. A video plan can also be mixed in. Thus the four separate windows are not necessarily managed only by the frame buffer.

A CPU monitoring module is responsible for grabbing the CPU status periodically and that status can be displayed through the windows manager . A wrapper module is executed on top of the manager of the window manager . It provides a linking interface between code executed in the manager and in the core . This allows different computing environments to be interconnected through the wrapper.

A command module is similarly provided as an interfacing module between the core and applications executing in an application environment as shown in volume . As described in more detail later volume can be considered to comprise containers for untrusted applications.

As mentioned earlier a hardware compositor can drive the display with two frame buffer and two video plans mixed together.

Each application constitutes a program or code sequence which is executed by a CPU forming part of the processor system. The architecture described herein provides a secure run time environment for multiple applications which in particular allow advantage to be taken of a variety of different application frameworks. The architecture does not itself provide a new application framework but provides the infrastructure and tools to facilitate the build of such a framework and or to make it easier to integrate legacy middleware along with an existing application framework. A first concept supported by the architecture described herein is to denote an application as trusted or untrusted. This is determined during installation of an application. On installation the application manager checks the application certificate. If the certificate is valid the application is regarded as trusted else it is regarded as untrusted. Trusted applications are loaded and executed normally that is directly between the supervisor application and the window manager . They have access privileges to directly access resources required for their execution these resources are managed by the resource manager which also manages resources for untrusted applications but through the supervisor application. In contrast untrusted applications are started in a container which provides an environment that is capable of isolating processes from the main system and limiting the resources usage thus providing a certain level of security from malicious programs. The concept of a container is known from the open source environment of Linux where untrusted applications are started in a Linux container as a non root user. Resource usage is provided in the Linux context via the c group mechanism where c group is a control group representing a collection of processes bound by the same criteria . An alternative construction is offered by UNIX in the form of Logical Domains LDOMs .

The processor system described herein uses the concept of containers. A container identifier identifies the container itself. An application identifier identifies the application. By hosting untrusted applications in a respective container a first level of security is provided. The architecture allows a number of different application environments to be hosted. When the manager detects that a user has selected an application to be launched at the display the wrapper intercepts the launch process and advises the core to determine the status of the application that has been selected. All selected applications are considered in the first place to be trusted and so have an identifier which would denote a trusted status. When the core in conjunction with the application manager detects that the application is not trusted it sets a container identifier to a non trusted identifier and allocates an application identifier associated with the container identifier. Moreover the browser executable is not called directly with a start command. There are two possibilities mentioned herein for allowing the application to access resources even though it is untrusted. In a first possibility a script file is called to run a container for the browser noting that the container identifier is untrusted. The script file calls a client before running the browser executable. Although the container is started as untrusted the client needs trusted privileges to obtain resources for example an IP address or dynamic access to hardware resources like audio and video decoders. This can be achieved by setting an application identifier bit for the client beforehand indicating a trusted status for the client even if not for the browser executable or the application which will be run behind the client . This allows the browser executable to be started as untrusted in the container and able to obtain an IP address dynamically using the client. According to the second possibility which is more secure the core can run a check for available IP addresses prior to starting the container. It can then use this IP address and statically configure the container before starting it. In this case it removes the requirement to run the client with trusted privileges within a container and is therefore more secure.

Note that for applications run inside a container process identifiers which are allocated within a container are unique only within the container itself. This can create a difficulty when applications are launched substantially simultaneously. Under usual circumstances if a user launches trusted applications A and B together both applications A and B will start at their own pace in a common environment. The manager will detect that the applications are required to be launched trigger the launch function and the new process identifiers are captured together with a unique application identifier. This identifier is the identifier which is used for applications to communicate with one another. It is also used to identify applications in the frame buffer. As the process identifier is unique in the common environment for each newly captured process identifier it can determine whether the process identifier belongs to application A or application B and update the application manager for future references.

However if a user launches untrusted application A which will launch in a container and untrusted application B which will launch in a container both applications A and B will again start at their own pace. When an application starts to execute it obtains a process identifier from its operating environment in this case a container and supplies it to the manager . However in this case when the launch process is triggered at the manager based on the newly captured process identifier the core is unable to determine whether the new process identifier belongs to application A or application B as the process identifier is unique only within the container itself and not between containers .

This difficulty is overcome in the following way. Applications which are selected more or less simultaneously by a user are sequentially launched by restricting user control in the following manner. If a user launches an application A any application B will not be allowed to start regardless whether it is trusted or untrusted until a launch command for application A implemented at the manager causes a new process identifier value to be captured. As at this time it is sure that the process is for application A the process identifier is updated in the application manager accordingly. A unique application ID is stored as well. So in any future reference in subsequent launch commands the unique ID is used as the identifier.

An application can launch multiple processes each having a process identifier sequentially generated by the application unique within a container for untrusted applications . These process identifiers are held in association with the unique identifier at the superior module.

If no launch command which captures a new process identifier value occurs within ten seconds it is assumed that an error has occurred and application A will be stopped. This will allow the user to launch any application B.

Utilizing the architecture described earlier in the embodiment of the resource manager within system A does not manage the resources applicable for system A. Instead these are managed by the resource manager of system B. Thus system B represents an architecture similar to that described in . A virtual frame buffer is implemented by dedicated memory space which interacts directly with the kernel. The virtual frame buffer has a memory space dedicated to the management of the screen on the display as governed by system A. This memory space is isolated from the rest of the system and is controlled in a dedicated fashion by the supervisor application . The operation of the supervisor module allows the display of system A to be controlled using the hardware resources available to system B. This is accomplished through the resource manager . Using the windows manager and hardware compositor the display output from system A can be drawn into one of the four windows on the display as shown in even though system A considers that it is operating in full screen mode.

The window manager creates a hole in a window. Then the display is managed by the hardware compositor as an overlay solution. The supervisor is responsible to create the window and the hole then to program the hardware compositor through the virtual frame buffer and it is transparent for system A. System A acts as if it is displaying on a single window of a frame buffer.

System A then drives the virtual frame buffer as allocated to it by the supervisor application. The virtual frame buffer FB is below FB so the final output which drives the display via the kernel is the composite of the contents of FB and FB as managed by the hardware compositor . The supervisor application allocates the virtual frame buffer resource FB to system A when an application is launched in system A that will access to the display as a resource. The supervisor application can also be configured to monitor the application and to detect when the size of the application has changed. The application can then drive the kernel to change the size of the virtual frame buffer.

The above described embodiments of the present disclosure provide a processor system which delivers a toolbox that improves time to market allowing different stack porting for dedicated applications. The toolbox gives the flexibility to run concurrently several applications and interface frameworks for example the different frameworks as shown in volume . The toolbox further provides support for secure content between applications based on the unique application identifier.

It will be appreciate that the embodiments have been described only by way of example. Other variants may be implemented by a person skilled in the art given the disclosure herein. The scope of the invention is not limited by the described embodiments.

The various embodiments described above can be combined to provide further embodiments. These and other changes can be made to the embodiments in light of the above detailed description. In general in the following claims the terms used should not be construed to limit the claims to the specific embodiments disclosed in the specification and the claims but should be construed to include all possible embodiments along with the full scope of equivalents to which such claims are entitled. Accordingly the claims are not limited by the disclosure.

