---

title: Writing back data to files tiered in cloud storage
abstract: Systems and methods are provided herein for writing back data to files tiered in cloud storage. Files tiered to cloud storage can be stored in chunks where each chunk is stored as a distinct cloud object and where each cloud object is mapped to known offset regions of a file and the mapping is stored in local storage within a stub file. If the file is modified locally, e.g., a write has occurred, the offset range associated with the write can be used to determine which cloud object associated with the file is being modified. A new cloud object can be stored with the write data, while the previous cloud object is retained in cloud storage. The mapping, stored within the stub file can updated to reference the new cloud object for the region of the file that was modified. In addition, mapping can be retained for the previous version of the file allowing for efficient recall of past versions of files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09503542&OS=09503542&RS=09503542
owner: EMC Corporation
number: 09503542
owner_city: Hopkinton
owner_country: US
publication_date: 20140930
---
This application is related to co pending U.S. patent application Ser. No. 14 501 881 for DATA AND METADATA STRUCTURES FOR USE IN TIERING DATA TO CLOUD STORAGE and filed concurrently herewith which is incorporated herein by reference for all purposes and to co pending U.S. patent application Ser. No. 14 501 700 for TIERING DATA TO A CLOUD STORAGE SYSTEM USING PAGE BLOBS and filed concurrently herewith which is incorporated herein by reference for all purposes and to co pending U.S. patent application Ser. No. 14 501 806 for GARBAGE COLLECTION OF DATA TIERED TO CLOUD STORAGE and filed concurrently herewith which is incorporated herein by reference for all purposes and to co pending U.S. patent application Ser. No. 14 501 958 for TIERING DATA TO CLOUD STORAGE USING CLOUDPOOLS AND POLICIES and filed concurrently herewith which is incorporated herein by reference for all purposes and to co pending U.S. patent application Ser. No. 14 501 928 for USING A LOCAL CACHE TO STORE ACCESS AND MODIFY FILES TIERED TO CLOUD STORAGE and filed concurrently herewith which is incorporated herein by reference for all purposes

This invention relates generally to storing data and more particularly to systems and methods relating to tiering data from private data storage infrastructure to a public cloud provider.

With the advent of cloud storage and the associated proliferation of cloud storage providers organizations and individuals alike with data storage needs both large and small have begun to assess the feasibility of utilizing cloud storage. For example an organization that maintains a privately owned data center that hosts data of the organization may wish to tier data to the cloud depending on issues such as price ease of access data security etc. While cloud storage can provide benefits to organizations with varied data storage needs some organizations may not want to compromise on issues like for example data security by moving their entire set of data to a cloud storage provider.

One way an organization could potentially reduce their private data storage costs may be to tier some of their data to a public cloud while still maintaining a set of data in their private data center. In deciding to tier some data to the cloud it may be advantageous to still have a inventory and accounting of all data tiered to the cloud within the private data center while providing easy means to restore tiered cloud data to the private data center upon demand. For example if your private data center storage interface was unaware of the data the organization is also storing in a public cloud an information technology professional or end user may have to search for and or use the data utilizing at least two separate and distinct interfaces. Thus there exists a need to manage data both stored in a private data center and data tiered from the private data center to a public cloud from a single interface.

In addition to managing both privately hosted data and public cloud data from a common interface a public cloud data tiering solution may also need to reduce external dependencies on the public cloud storage provider by creating and utilizing data structures necessary to pass data to and from the cloud storage provider based on the needs of the data storage client. For example data must be able to be both readable and writable from and to the public cloud. In another example data storage services such as snapshots and backup must remain compatible with data tiered to the cloud. It can be appreciated that a litany of issues must be addressed to eliminate performance bottlenecks and create a scalable and efficient solution for data storage customers.

The following presents a simplified summary of the specification in order to provide a basic understanding of some aspects of the specification. This summary is not an extensive overview of the specification. It is intended to neither identify key or critical elements of the specification nor delineate the scope of any particular embodiments of the specification or any scope of the claims. Its sole purpose is to present some concepts of the specification in a simplified form as a prelude to the more detailed description that is presented in this disclosure.

In accordance with an aspect a request can be received from a client to read a file wherein the request includes a file offset range. It can be determined whether the file is a stub file. In response to determining the file is a stub file a set of cloud objects associated with the file offset range can be determined based on a mapping associated with the stub file. It can be determined whether cloud objects in the set of cloud objects are stored within a local cache. In response to determining at least one cloud object in the set of cloud objects is not stored within the local cache the at least one cloud object can be retrieved from a cloud storage location and the at least one cloud object can be stored in the local cache wherein the cloud storage location is associated with the stub file. The set of cloud objects can be returned to the client as the file wherein returning the set of cloud objects as the file is transparent to the client.

In accordance with an aspect in response to returning the set of cloud objects to the client as the file a write request can be received from the client associated with the file wherein the write request includes a write offset range and a write data. A data lock can be activated on the stub file. The write offset range as dirty. The write data can be written to the local cache based on the write offset range. The file can be added to a sync queue. The data lock on the stub file can be deactivated.

In accordance with an aspect a synch file can be received from a sync queue. A synch lock can be activated on the stub file. The mapping of the stub file can be updated based on the write offset range. At least the write data can be stored in the cloud storage location as a new cloud object based on the cloud object identifier the index number and the chunk number. The synch lock on the stub file can be deactivated. The synch file can be removed from the sync queue.

The following description and the drawings set forth certain illustrative aspects of the specification. These aspects are indicative however of but a few of the various ways in which the principles of the specification may be employed. Other advantages and novel features of the specification will become apparent from the detailed description of the specification when considered in conjunction with the drawings.

The innovation is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of this innovation. It may be evident however that the innovation can be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the innovation.

The term cloudpool as used herein refers to a pool of cloud storage accounts in which data can be tiered to from private storage infrastructure. It can also refer to a cloud storage provider instance for example a Microsoft Azure storage subscription and Amazon S3 account or an EMC Isilon RAN namespace access point. A single cloudpool can contain accounts from multiple cloud providers and or multiple accounts from a single cloud provider.

The terms primary storage or local storage or private storage refer to a data storage system that is the primary access point for stored data. In most implementations primary storage is private infrastructure operated on the premises of the data storage customer. In one implementation the primary storage can be an EMC Isilon Cluster.

The term stub or stub file as used herein refers to the remnant of a file in local storage after its data content is moved to cloud storage. The stub can contain original system metadata user metadata additional metadata necessary to manage the stub file and associated data objects mapping information which provides a location of the cloud data objects which contain the original file content. In some implementations the stub can contain locally cached data obtained from the cloud. It can be appreciated that until all the content of the file is fully reconstituted from cloud storage the file can remain a stub. The stub file can contain information about the tiered data s compression state and or encryption state. In one implementation the stub file can contain mappings to one cloud object containing the metadata e.g. Cloud Metadata Object as defined below 

The term local data cache or local cache or locally cached data refers to data obtained from cloud storage and stored in local storage that is associated with a stubbed file. A local data cache can be a specific area of storage space within a clustered file system and does not refer to a specific type of storage device such as solid state storage flash storage or magnetic storage.

The term inode or logical inode LIN as used herein refers to in memory representation of on disk data structures that may store information or meta data about files and directories such as file size file ownership access mode read write execute permissions time and date of creation and modification file types data protection process information snapshot information hash values associated with location of the file a flag indicating the LIN is associated with a stub file mappings to cloud data objects pointers to a cloud metadata objects etc. In one implementation LINs may be in a known location in a file system for example residing in cache memory for fast and or efficient access by the file system. Before or in conjunction with performing a file system operation on a file or directory a system call may access the contents of the LIN and or the contents of the file in determining how to process the system call. For example the LIN can be examined to determine if a flag within the LIN indicates the LIN is a stubbed file. In some implementations a data structure explicitly named inode or LIN may be absent but file systems may have data structures that store data similar to LINs and may provide capabilities similar to LINs as described herein. It can be appreciated that the concepts and implementations as provided herein are functional using data structures not termed LINs or inodes but that offer the same functionality to the file system.

The term Cloud Metadata Object or CMO refers to the cloud object containing metadata information relating to tiered data. The CMO can contain reverse links to the original file in local storage the same mapping information that is stored in the stub file pertinent policy information related to the file such as retention period encryption information compression information and original file system metadata information. In one implementation the CMO can also itself be encrypted and or compressed. One example CMO data structure includes an encrypted file path a compression flag the local storage LIN of the stub the local file path statistical information on the file a checksum mapping information e.g. includes cloud storage account object identifier snapshot identifier index number length size of the object etc. .

The term Cloud Data Object or CDO refers to the cloud object containing the actual tiered content data. A cloud data object is generally limited to a chunk size as described below. Depending on the size of the file being tiered to the cloud and the size of the chunk in many examples there can be multiple CDOs representing an individual file. CDOs can be associated with a unique object identifier a cloud account identifier and can be associated with sub chunks.

The term garbage collection as used herein refers to the action of removing cloud objects no longer referenced by local files e.g. stub files. In some implementations the action of garbage collection does not occur until retention periods have expired.

Referring now to there is illustrated an example local storage system including cloud tiering components and a cloud storage location in accordance with implementations of this disclosure. Client can access local storage system . Local storage system can be a node and cluster storage system such as an EMC Isilon Cluster that operates under OneFS operating system. Local storage can also store the local cache for access by other components. It can be appreciated that the systems and methods described herein can run in tandem with other local storage systems as well.

As more fully described below with respect to redirect component redirect component can intercept operations directed to stubbed files. Cloud block management component garbage collection component and caching component may also be in communication with local storage system directly as depicted in or through redirect component . A client administrator may use an interface to access the policy component and the account management component for operations as more fully described below with respect to these components. Data transformation component can operate to provide encryption and compression to files tiered to cloud storage. Cloud adapter component can be in communication with Cloud Storage and Cloud Storage N where N is a positive integer. It can be appreciated that multiple cloud storage locations can be used for storage including multiple accounts within a single cloud storage location as more fully described in implementations of this disclosure.

Cloud block management component manages the mapping between stub files and cloud objects the allocation of cloud objects for stubbing and locating cloud objects for recall and or reads and writes. It can be appreciated that as file content data is moved to cloud storage metadata relating to the file for example the complete inode and extended attributes of the file still are stored locally as a stub. In one implementation metadata relating to the file can also be stored in cloud storage for use for example in a disaster recovery scenario.

Mapping between a stub file and a set of cloud objects models the link between a local file e.g. a file location offset range and a set of cloud objects where individual cloud objects can be defined by at least an account a container and an object identifier. The mapping information can be stored as an extended attribute directly in the file. It can be appreciated that in some operating system environments the extended attribute field can have size limitations. For example in one implementation the extended attribute for a file is 8 kilobytes. In one implementation when the mapping information grows larger than the extended attribute field provides overflow mapping information can be stored in a separate system b tree. For example when a stub file is modified in different parts of the file and the changes are written back in different times the mapping associated with the file may grow. It can be appreciated that having to reference a set of non sequential cloud objects that have individual mapping information rather than referencing a set of sequential cloud objects can increase the size of the mapping information stored. In one implementation the use of the overflow system b tree can limit the use of the overflow to large stub files which are modified in different regions of the file.

File content can be mapped by the cloud block management component in chunks of data. A uniform chunk size can be selected where all files that tiered to cloud storage can be broken down into chunks and stored as individual cloud objects per chunk. It can be appreciated that a large chunk size can reduce the amount of objects needed to represent a file in cloud storage however a large chunk size can decrease the performance of random writes. For example if a chunk size of 100 MB is chosen and an application is writing 8 KB of data somewhere within the chunk the cloud block management component could need to fetch a 100 MB object from the cloud first in order to overwrite the whole object chunk. It can also be appreciated that the chunk size cannot be too small as the smaller the chunk size the more chunks will need to be passed between local storage and cloud storage possibly creating additional performance costs and network bandwidth costs. In one implementation a chunk size of 1 MB is used. In some implementations chunks can be broken up into sub chunks as separate objects. For example in an implementation with a chunk size of 1 MB sub chunks of 128 KB can be used to form 8 sub chunks for each chunk.

The Account management component manages the information for cloud storage accounts. Account information can be populated manually via a user interface provided to a user or administer of the system. Each account can be associated with account details such as an account name a cloud storage provider a uniform resource locator URL an access key a creation date statistics associated with usage of the account an account capacity and an amount of available capacity. Statistics associated with usage of the account can be updated by the cloud block management component based on list of mappings it manages. For example each stub can be associated with an account and the cloud block management component can aggregate information from a set of stubs associated with the same account. Other example statistics that can be maintained include the number of recalls the number of writes the number of modifications the largest recall by read and write operations etc.

In one implementation the account management component can periodically synchronize information with the cloud storage provider for example the amount of free capacity remaining on the account. It can be appreciated that periodic synchronization may correct any differences between the inventory kept by the cloud block management component and the cloud provider.

In one implementation multiple accounts can exist for a single cloud service provider each with unique account names and access codes.

The Cloud adapter component manages the sending and receiving of data to and from the cloud service providers. The Cloud adapter component can utilize a set of Application Programming Interfaces API . For example each cloud service provider may have provider specific API to interact with the provider. In one implementation two different sets of APIs can be utilized. One set of APIs can be data access APIs that can assist in pass through input output with the cloud provider data recall from the cloud provider and file stubbing. A second set of APIs can be configuration APIs that assist in synchronizing configuration data primarily the free space available on the account and the account access key.

In one implementation cloud adapter component can relay a not found error message to the local file system when an IO request is received for a cloud data object that the cloud adapter cannot find in the location where the data object should be. It can be appreciated that the not found message can indicate a lack of data consistency for the object and data still residing in local cache can be used to reestablish consistency with cloud storage.

A policy component enables a set of policies that aid a user of the system to identify files eligible for being tiered to cloud storage. A policy can use criteria such as file name file path file size file attributes including user generated file attributes last modified time last access time last status change and file ownership. It can be appreciated that other file attributes not given as examples can be used to establish tiering policies including custom attributes specifically designed for such purpose. In one implementation a policy can be established based on a file being greater than a file size threshold and the last access time being greater than a time threshold.

In one implementation a policy can specify the following criteria stubbing criteria cloud account priorities encryption options compression options caching and IO access pattern recognition and retention settings. For example user selected retention policies can be honored by garbage collection component . In another example caching policies such as those that direct the amount of data cached for a stub e.g. full vs. partial cache a cache expiration period e.g. a time period where after expiration data in the cache is no longer valid a write back settle time e.g. a time period of delay for further operations on a cache region to guarantee any previous writebacks to cloud storage have settled prior to modifying data in the local cache a delayed invalidation period e.g. a time period specifying a delay until a cached region is invalidated thus retaining data for backup or emergency retention a garbage collection retention period backup retention periods including short term and long term retention periods etc.

The policy component can also identify files that satisfy the policies by scanning local storage. It can be appreciated that repeatedly scanning the entirety of local storage can provide performance penalties for regular users of local storage due to the computing resources used in the scanning. Thus in one implementation the policy component can schedule the scanning to occur at specific times over specific time intervals or in limited parts of the local storage system. In one implementation the scanning can occur asynchronously over time where once files are identified for tiering by the policy component they can be tiered to cloud storage prior to later than and or contemporaneously with ongoing scanning. In one implementation policies provide the ability to do either namespace based scanning or LIN tree based scanning.

The policy component can also establish and enforce recall policies. For example policy driven automatic recall can recall the entire content of a stubbed file from the cloud and turn it back into a local file. Recall policies can be established using for example the percentage of the file that is locally cached data the total access times read write over a custom time period etc. Thus similar to the scanning relating to identifying files for tiering scanning can occur in a similar manner for determining files to recall. In one implementation recall scanning and recall activities can occur asynchronously over time where once files are identified for recall by the policy component they can be recalled to local storage prior to later than and or contemporaneously with ongoing scanning. In one implementation recall policies provide the ability to do either namespace based scanning or LIN tree based scanning.

A garbage collection component can be used to determine which files objects data constructs remaining in both local storage and cloud storage can be deleted. In one implementation the resources to be managed for garbage collection include CMOs CDOs local cache data and cache state information. For example when a file is recalled back to local storage the objects e.g. CMO and CDO corresponding to the file will remain in cloud storage after the recall operation is performed. It can be appreciated that it may be advantageous for data integrity and as a failsafe to retain the cloud objects in cloud storage relating to a recalled file for a certain period of time prior to permanently deleting the object. It can also be appreciated that retaining cloud objects for previously recalled files in perpetuity may lead to unnecessary storage costs to a user who may be paying the cloud storage provider based on the amount of data stored.

Generally for normal file system operations a user choosing to delete a file does not necessarily mean the data of the file can be removed permanently from local storage. For example if a snapshot e.g. the state of a file at a particular point in time is still referencing the now deleted file the file should be maintained in local storage until the all snapshots referencing the deleted version of the file are inactive. In another example deduplicated files may share commonality with other files that are saved as a single instance in local storage to conserve storage space. Thus even if a user desires to delete a file if another file shares commonality with the deleted file the file should be maintained in local storage until all deduplicated files that share the same commonality are deleted.

A redirect component can be used to redirect all input and output requests associated with cloud storage activities to user space from the kernel. For example normal read requests would generally occur within the kernel. However in one example a read request associated with a stubbed file can be redirected to the components described herein to operate on the request. Types of operations that can be redirected by the redirector component include creating a stub file reading a stubbed file writing to a stubbed file updating file links to stubbed files creating deleting modifying cloud objects garbage collection etc.

A caching component can be used to facilitate efficient caching of data to help reduce the bandwidth cost of repeated reads and writes to the same portion e.g. chunk or sub chunk of a stubbed file can increase the performance of the write operation and can increase performance of read operations to portion of a stubbed file accessed repeatedly. As stated above with regards to the cloud block management component files that are tiered are split into chunks and in some implementations sub chunks. Thus a stub file or a secondary data structure can be maintained to store states of each chunk or sub chunk of a stubbed file. States can include a cached data state meaning that an exact copy of the data in cloud storage is stored in local cache storage a non cached state meaning that the data for a chunk or over a range of chunks and or sub chunks is not cached and therefore the data has to be obtained from the cloud storage provider a modified state or dirty state meaning that the data in the range has been modified but the modified data has not yet been synched to cloud storage a sync in progress state that indicates that the dirty data within the cache is in the process of being synced back to the cloud and a truncated state meaning that the data in the range has been explicitly truncated by a user. In one implementation a fully cached state can be flagged in the stub associated with the file signifying that all data associated with the stub is present in local storage. This flag can occur outside the cache tracking tree in the stub file and can allow in one example reads to be directly served locally without looking to the cache tracking tree.

The caching component can be used to perform at least the following seven operations cache initialization cache destruction removing cached data adding existing file information to the cache adding new file information to the cache reading information from the cache updating existing file information to the cache and truncating the cache due to a file operation. It can be appreciated that besides the initialization and destruction of the cache the remaining 5 operations can be represented by four basic file system operations Fill Write Clear and Sync. For example removing cached data is represented by clear adding existing file information to the cache by fill adding new information to the cache by write reading information from the cache by read following a fill updating existing file information to the cache by fill followed by a write and truncating cache due to file operation by sync and then a partial clear.

In one implementation the caching component can track any operations performed on the cache. For example any operation touching the cache can be added to a queue prior to the corresponding operation being performed on the cache. For example before a fill operation an entry is placed on an invalidate queue as the file and or regions of the file will be transitioning from an uncached state to cached state. In another example before a write operation an entry is placed on a synchronization list as the file and or regions of the file will be transitioning from cached to cached dirty. A flag can be associated with the file and or regions of the file to show that it has been placed in a queue and the flag can be cleared upon successfully completing the queue process.

In one implementation a time stamp can be utilized for an operation along with a custom settle time depending on the operations. The settle time can instruct the system how long to wait before allowing a second operation on a file and or file region. For example if the file is written to cache and a write back entry is also received by using settle times the write back can be requeued rather than processed if the operation is attempted to be performed prior to the expiration of the settle time.

In one implementation a cache tracking file can be generated and associated with a stub file at the time it is tiered to the cloud. The cache tracking file can track locks on the entire file and or regions of the file and the cache state of regions of the file. In one implementation the cache tracking file is stored in an Alternate Data Stream ADS . It can be appreciated that ADS are based on the New Technology File System NTFS ADS. In one implementation the cache tracking tree tracks file regions of the stub file cached states associated with regions of the stub file a set of cache flags a version a file size a region size a data offset a last region and a range map.

In one implementation a cache fill operation can be processed by the following steps 1 an exclusive lock on can be activated on the cache tracking tree 2 it can be verified whether the regions to be filled are dirty 3 the exclusive lock on the cache tracking tree can be downgraded to a shared lock 4 a shared lock can be activated for the cache region 5 data can be read from the cloud into the cache region 6 update the cache state for the cache region to cached and 7 locks can be released.

In one implementation a cache read operation can be processed by the following steps 1 a shared lock on the cache tracking tree can be activated 2 a shared lock on the cache region for the read can be activated 3 the cache tacking tree can be used to verify that the cache state for the cache region is not not cached 4 data can be read from the cache region 5 the shared lock on the cache region can be deactivated 6 the shared lock on the cache tracking tree can be deactivated.

In one implementation a cache write operation can be processed by the following steps 1 an exclusive lock on can be activated on the cache tracking tree 2 the file can be added to the synch queue 3 if the file size of the write is greater than the current file size the cache range for the file can be extended 4 the exclusive lock on the cache tracking tree can be downgraded to a shared lock 5 an exclusive lock can be activated on the cache region 6 if the cache tracking tree marks the cache region as not cached the region can be filled 7 the cache tracking tree can updated to mark the cache region as dirty 8 the data can be written to the cache region 9 the lock can be deactivated.

In one implementation data can be cached at the time of a first read. For example if the state associated with the data range called for in a read operation is non cached then this would be deemed a first read and the data can be retrieved from the cloud storage provider and stored into local cache. In one implementation a policy can be established for populating the cache with range of data based on how frequently the data range is read thus increasing the likelihood that a read request will be associated with a data range in a cached data state. It can be appreciated that limits on the size of the cache and the amount of data in the cache can be limiting factors in the amount of data populated in the cache via policy.

A data transformation component can encrypt and or compress data that is tiered to cloud storage. In relation to encryption it can be appreciated that when data is stored in off premises cloud storage and or public cloud storage users can require data encryption to ensure data is not disclosed to an illegitimate 3party. In one implementation data can be encrypted locally before storing writing the data to cloud storage.

In one implementation an external key management system can be used where each stub and its associated cloud objects retain an initialization vector to retrieve a key from a secure key management system. For example RSA Key Manager could be used as the external key management system. In one implementation a pool of current keys can be used which are associated with an expiration date for encrypting new data. In one implementation there can be a limit placed on the number of files that share the same key. In one implementation key selection from the pool can be random. In one implementation a limit can be established for the number of new keys consumption rate. An example process for encryption at the time data is written to cloud storage can include 1 getting a new key and a key identifier 2 using the key to encrypt the data 3 storing the key identifier and an encrypted data encryption key to the stub and 4 storing the key identifier in the associated CMO and or CDO. An example process for decryption at the time data is recalled from cloud storage can include 1 verify the key identifier 2 get the key using the key identifier and decrypt the data encryption key and 3 decrypt the data using the key. In one implementation AES 256 is used as the encryption algorithm.

In one implementation a key can be generated for each stub and the generated key can be used to encrypt the data. The data key can be encrypted with a master encryption key MEK . The data encryption key can be stored within the cloud object. At the time of decryption the MEK can be used to decrypt the data encryption key and the data encryption key can be used to decrypt the data.

In implementations involving compression data can be compressed before being stored in cloud storage. It can be appreciated that by compressing data prior to storage in cloud storage cloud storage costs and transfer costs may be reduced. In one implementation compression can occur at the chunk and or sub chunk level. It can be appreciated that by compressing objects at the chunk level partial retrievals of a file e.g. retrieval of less than all the chunks that make up the file can be possible as each chunk can be decompressed independently of other chunks.

It can be appreciated the steps as illustrated in can be accomplished through distributed processing where steps are performed by any number of threads on different nodes a distributed computing cluster. For example one node in a cluster can perform at least one thread either synchronously or asynchronously with another node in the cluster performing at least one thread.

At a request to tier a file in a local storage device to cloud storage can be received wherein the file is stored within local storage and wherein the file is associated with a LIN a local file path an offset and an offset range. It can be appreciated that the request can be a manual request from a user or an automated request generated via policy. The local file path can retain where in the file system hierarchy the file is located for example noting a parent LIN. The offset and the offset range can denote a specific location in the local storage device where the file data is stored. For example the offset can be the beginning block offset of the file data and the range can be a length in blocks of the file data. In another example the file data can be spread among multiple storage devices in the same node or among multiple nodes in a cluster. Thus file data can include multiple offsets and offset ranges for portions of data stored on various storage devices among the storage system cluster.

At a set of chunks can be generated based on the offset the offset range and a chunk size wherein a chunk in the set of chunks is associated with a chunk offset and a chunk length. It can be appreciated that a uniform chunk length can be chosen so that the majority of chunks can maintain the same length. In one implementation the chunk length is 1 MB. For example a 7.5 MB file could be split into seven 1 MB chunks and an eighth chunk that is 0.5 MB. Thus each chunk can be specified a length and the chunk offset can specify where on disk or in cache the chunk begins. It can be appreciated that by knowing the offset and offset range of the file the size of a file can be determined and an amount of chunks can be generated based on the amount of data and the chunk length.

At a cloud object identifier an index number and chunk number for chunks among the set of chunks can be generated based on a cloud object prefix the chunk offset and the chunk length. In one implementation the cloud object prefix is based on applying a hashing algorithm to the LIN associated with the file. In one implementation the cloud object identifier is generated by using the cloud object prefix along with the chunk number as a suffix. Thus all chunks for a single file will share the same prefix within their object identifier. In one implementation all chunks for a single file will share the same index number. It can be appreciated that as new versions of the file are written to cloud See for more detail the index number can change to reflect a new version of the file.

At the set of chunks can be stored in a cloud storage location as a set of cloud objects based on the cloud object identifier the index number and the chunk number wherein the cloud storage location is associated with a cloud storage account and a cloud storage container identifier. In some implementations the cloud objects can be encrypted and or compressed prior to being stored in the cloud storage location.

At a mapping of cloud objects in the set of cloud objects to the file can be generated wherein the mapping contains a mapping offset a mapping length for each cloud object in the set of cloud objects the cloud storage container identifier the cloud object identifier the index number and a total number of cloud objects. For example the mapping offset can be the original offset within the original file thus the file can begin at an offset of zero. Cloud objects that share the same cloud identifier can be sequenced by chunk number and the length of each chunk so that when a local client requests access to a portion of the file it can first be determined at what offset in the file the client is requesting and then a corresponding chunk e.g. cloud object can be determined that has the data requested by the client. In one implementation a mapping entry can include a cloud object id a cloud storage account a cloud storage container a cloud index number an offset length and a cloud snapshot identifier for each cloud object. The mapping entry can then be keyed to a file offset and or offset range to which the mapping entry represents.

At the mapping can be stored as a stub file in place of the local file in the local storage device. It can be appreciated that the LIN and the local path can be determined by the stub file s namespace data itself. In one implementation the stub file can also include an active stub flag. For example when the local storage system attempts to access the file after the data has been tiered to the cloud an active stub flag would alert the local storage system that the content of the file has been tiered to the cloud and redirect the access request to the cloud storage system using methods as described within this specification. In one implementation the stub file can also be stored in the cloud storage location. For example having a copy of the stub file in cloud storage may assist in disaster recovery or backup operations if the stub file in local storage is lost.

At data associated with the file can be removed from the local storage device wherein removing data retains the stub file. It can be appreciated that the stub file remains associated with the LIN of the file that as discussed above remains to redirect attempts to access the file to the cloud. The actual data of the file that has been tiered to cloud storage can be removed from local storage and or freed for other purposes. It can be appreciated that by maintaining the stub file associated with the LIN of the file attempts to access the file by a client of the local storage system can remain transparent to the actual data of the file being stored in cloud storage.

At the iterative loop beings where the next chunk of a file is requested. As stated above with respect to a stub file will be associated with mapping that has mapped chunks of the file to specific objects within cloud storage. However prior to retrieving chunks from cloud storage at it can first be determined whether the chunk at issue has already been cached in local cache storage. It can be appreciated that by checking first whether the chunk is already available in local cache storage unnecessary cloud I O and network traffic can be minimized. If the chunk is in local cache storage the chunk can be read from local cache storage at . If the chunk is not in local cache storage at the chunk can be retrieved from cloud storage using for example the mapping information associated with the stub file. In one implementation retrieving a cloud object from cloud storage can include receiving at least one cloud object checksum with the object. The at least one cloud object checksum can be compared with a checksum associated with the stub file data for that chunk. The contents of the chunk can then be validated by comparison. It can be appreciated that the stub file can be associated with a checksum where the association was made at the time the file was stored in the cloud. Thus the checksum validation can be used to ensure data integrity for files returning back to local storage from cloud storage. In one implementation in response to storing the at least one cloud object in the local cache at least one of decompressing or decrypting the cloud object can occur. Thus data that was compressed and or encrypted prior to being stored within cloud storage can be decrypted and or decompressed after being returned from cloud storage.

At the retrieved chunk can be stored in local cache storage and the method can proceed to step where the chunk is read from local cache storage. In one implementation the chunk is read from local storage only if permitted by the policy and the file system state. At if there are more chunks to be read the loop can restart at step . If there are not more chunks to be read the read request can be completed at step .

If at the file associated with the write request is determined to be a stubbed file at a data lock can be activated on the stub file. It can be appreciated that by locking the file it will prevent other file system operations from performing operations on the data while the lock is active. At an impacted offset range can be determined for the write request. For example some write requests may be only for a small portion of a file while other write requests may want to overwrite the entirety of the file. At the offset range corresponding to the write request can be marked as dirty. It can be appreciated that by marking the offset range as dirty later read requests to the same offset range will be aware that the data in cloud storage representing this offset area is not current preventing a data inconsistency.

At cloud object chunks can be retrieved from cloud storage corresponding to the offset range and stored in local cache. For example the write request may cover only portions of individual chunks so it can be desirable to preload the entire chunk in cache prior to writing the data so that chunk integrity is maintained when storing the updated file data back into cloud storage.

At the data can be written into the local cache. At the updated file can be added to the synch queue. It can be appreciated that by doing asynchronous writes that is by first updating local cache and then queuing the update in a sync queue to be performed later serial writes to the same data can operate within the local cache and minimize I O and network traffic to the cloud storage provider. At the data lock can be deactivated.

Returning to step if there are no additional dirty ranges to process at new mapping information can be determined and the mapping information associated with the stub can be updated to incorporate the new mapping information. For example previous versions of objects may remain in the cloud for backup or snapshot purposes thus the new mapping information can reference the unchanged chunks from the previous version as well as updated chunks that are stored as new cloud objects. In another example it is possible two stubs may reference the same cloud object as a chunk in their respective associated mappings. Thus if only one of the files is being synched with new data it is necessary to retain the original data object still being actively mapped by the second file. It can be appreciated that garbage collection processes can function to remove data objects from cloud storage based on myriad of factors including whether a cloud object is still being referenced by any active stubs or active snapshots.

At the stub state can be marked and or updated as described supra. At the synch lock and be unlocked. At the file can be removed from the synch queue.

In one implementation a check point can be used when a new round of synchronization is initialized. As the synch process progresses the check pointing can record the actions taken in cloud storage. For example creating a CDO creating a master CDO taking a snapshot renaming a CDO etc. The check pointing can also record the positional information within cloud objects of the sync process. It can be appreciated that the check pointing can be used to for example when a process fails due to a network or system error resume a writeback from the last place it was interrupted. In another example the check point process can identify objects created in the cloud but abandoned after a process failure e.g. a new object was created when restarting the process. In one implementation at the beginning of a writeback process check pointing information can be used to determine whether to resume a previously started writeback or to begin anew.

At an iterative loop can begin that retrieves the chunks of the file. At non cached portions of the chunk can be retrieved from the cloud. At the chunk can be cached. At it can be determined whether there are additional chunks to retrieve and the loop can restart at step if there are. If there are not any more chunks to retrieve the data can continue to reside in the local cache the LIN can be updated to reflect the offset locations in local cache where the data is stored and mapping information and other portions of the stub can be deleted returning the file to a local file. It can be appreciated that the data need not be moved from local cache to local storage as the local cache is a part of local storage.

At a master CDO can be generated wherein the master CDO is comprised of a set of file data CDO ordered sequentially and wherein file data CDO in the master CDO are preceded by a custom CDO header and wherein the custom CDO header contains encryption compression and checksum data associated with the file data CDO. For example the master CDO can be generated as a page blob and as stated below with respect to step file data CDO can be generated at specific offsets within the page blob. In one implementation more than one master CDO can be used for a file and or data object if the file is bigger than the size of the page blob. At the set of file data CDO can be generated based on the offset the offset range and a page blob size wherein a file data CDO in the set of file data CDO is associated with a file offset and an offset length. In one implementation the page blob s page size is 512 kilobytes.

At the master CDO can be stored as one page blob in cloud storage wherein file data CDO in the master CDO are stored within the master CDO using a set of continuous pages. At a first snapshot identifier can be assigned to the master CDO. It can be appreciated that the snapshot identifier can be a cloud snapshot identifier provided as a service by the cloud provider that can be native to the cloud storage platform.

At a mapping of file data CDO in the master CDO with the offset and offset range of the file can be generated wherein the mapping contains a sequential page blob index and the first snapshot identifier. At the mapping can be stored as a stub file in place of the file in the local storage device. In one implementation the stub file further contains an active stub flag. At data associated with the file can be removed from the local storage device wherein removing data retains the stub file.

At a set of dirty file data CDO associated with the set of dirty offset ranges can be determined. At a master prime CDO can be generated wherein the master prime CDO is comprised of a set modified file CDO and a subset of the set of file data CDO ordered sequentially and wherein modified file CDO and the subset of set of file data CDO are preceded by the CDO header. At the set of modified file CDO can be generated based on the synch request and the set of dirty file data CDO. For example the subset of the set of file data CDO are the CDO from the original file that are not modified by the write and the set of modified file CDO are the CDO that have been modified. It can be appreciated in that in some implementations all CDO may be modified and the subset of the set of file data CDO may not be included in the master prime CDO. At a second snapshot identifier can be assigned to the master prime CDO. At a prime mapping of the set of modified file CDO and the subset of file CDO in the master CDO with the offset and offset rang of the file can be generated wherein the mapping contains a sequential page blob index and the second snapshot identifier. At the prime mapping can be stored as a second stub file in place of the file in the local storage device. In one implementation storing the second stub file can further include retaining the master CDO as a snapshot of the file. It can be appreciated that the master CDO retained can be used to restore a previous version of the file e.g. the file prior to portions of the file being overwritten during the synch process.

The flow diagram method can now proceed with Step to process delete requests associated with a stubbed file or with Step to determine whether the cloud data object can be removed from cloud storage.

At a delete request targeted to a stubbed file can be intercepted wherein the stubbed file is associated with a stubbed LIN. At a request can be sent to a kernel operation of a local storage system to delete the stubbed file based on the stubbed LIN. At in response to the sending the request at step a linking status of the stubbed LIN can be received from the kernel. In one implementation the linking status includes active snapshot links associated with the LIN. At the cloud object index can be updated based on the linking status and the LIN. In one implementation updating the cloud object index includes removing the stubbed LIN as a link to the set of cloud data objects associated with the stubbed LIN.

At it can be determined whether a cloud data object in the cloud object index is linked to in an active LIN. At it can be determined whether the expiration data associated with the cloud data object has expired. At in response to determining that the cloud data object is not linked to the active LIN and that the expiration date associated with the cloud object has expired the cloud data object can be removed from cloud storage. It can be appreciated that removing the cloud data object from cloud storage can involve sending a request using the cloud adapter component to the account associated with the cloud object using the proper API for the cloud storage provider.

At a set of recall policies can be generated. At a set of stub files can be scanned based on the set of recall policies wherein stub files in the set of stub files that meet the set of recall policies are added to a recall list. In one implementation the set of recall policies include a locally cached data percentage threshold total access amount threshold and a time period threshold. For example a locally cached data percentage threshold can relate to the total percentage of the file that is locally cached. The total access amount threshold can relate to the total number of times a file and or chunks of the file have been accessed over a certain period of time. The time period threshold can relate to the total amount of time the file and or chunks of the file have remained on cloud storage.

At files on the recall list can be recalled. Recalling a stub file on the recall list can include steps . At step a set of chunks associated with the stub file can be determined. At a set of non cached chunks in the set of chunks can be determined wherein the set of non cached chunks are not in a local cache storage. At the set of non cached chunks can be read from cloud storage based on the stub file. At the set of non cached chunks can be stored in the local cache storage. At the stub file can be converted into a normal file. It can be appreciated that a normal file is a non stubbed file where the local file cluster hosts the file data.

At a fill request associated with a set of regions of the stub file can be received. At an exclusive cache tracking tree lock can be activated on the cache tracking tree wherein the set of cache flags are set to indicate the activating. In some implementations a shared lock on the cache tracking tree can be used. It can be appreciated that an exclusive lock can create more performance penalties on a file system than a shared lock and thus a shared lock is favored but an exclusive lock is necessary to increase concurrency. Thus in one implementation the lock is first made shared and only upgraded to exclusive when a concurrency threshold is met.

At a cached state associated with the set of regions of the stub file can be determined. At in response to determining the cached state associated with the set of regions of the stub file are not dirty downgrading the exclusive cache tracking tree lock to a shared cache tracking tree lock wherein the set of cache flags are set to indicate the downgrading. At the cached states associated with the set of regions can be updated to cached.

At a shared region lock can be activated for the set of regions wherein the set of cache flags are set to indicate the shared region lock. In one implementation the exclusive region lock is only applied when waiting for data. For example when the cached state of a region has been updated to cached an exclusive lock can be activated until the data is actually filled in the steps below.

At file data can be read from cloud storage associated with the set of regions. At the file data can be stored in local cache storage based on the cache tracking tree. At the shared cache tracking tree lock and the exclusive region lock can be deactivated.

At a read request associated with a set of regions of the stub can be received. At a shared cache tracking tree lock can be activated on the cache tracking tree wherein the set of cache flags are set to indicate the cache tracking tree shared lock. At a shared region lock for the set of regions can be activated wherein the set of cache flags are set to indicate the shared lock. At the cache state associated with the set of regions of the stub file can be determined. At in response to determining the cached state associated with the set of regions of the stub file are not not cached the shared region lock can be upgraded to an exclusive region lock. At file data can be read from the set of regions. At the change shared cache tracking tree lock and at least one of the shared region lock or the exclusive region lock can be deactivated.

At a write operation associated with a set of regions of the stub file and a set of write data can be received. At an exclusive lock can be activated on the cache tracking tree wherein the set of cache flags are set to indicate the exclusive lock. At in response to determining that the file size of the write is greater than the file size at least one of the file size the last regions and the range can be updated. At the exclusive lock can be downgraded to a cache tracking tree shared lock wherein the set of cache flags are set to indicate the cache tracking tree shared lock. At an exclusive region lock for the set of regions can be activated wherein the set of cache flags are set to indicate the exclusive region lock. At in response to determining that regions of the set of regions are not cached regions of the set of regions can be filled. At the cached states of the set of regions can be updated to dirty. At the write data can be written into the set of regions. At the cache tree share lock and the exclusive region lock can be deactivated.

The illustrated aspects of the disclosure can be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules can be located in both local and remote memory storage devices.

The systems and processes described above can be embodied within hardware such as a single integrated circuit IC chip multiple ICs an application specific integrated circuit ASIC or the like. Further the order in which some or all of the process blocks appear in each process should not be deemed limiting. Rather it should be understood that some of the process blocks can be executed in a variety of orders that are not all of which may be explicitly illustrated herein.

What has been described above includes examples of the implementations of the present disclosure. It is of course not possible to describe every conceivable combination of components or methods for purposes of describing the claimed subject matter but many further combinations and permutations of the subject innovation are possible. Accordingly the claimed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Moreover the above description of illustrated implementations of this disclosure including what is described in the Abstract is not intended to be exhaustive or to limit the disclosed implementations to the precise forms disclosed. While specific implementations and examples are described herein for illustrative purposes various modifications are possible that are considered within the scope of such implementations and examples as those skilled in the relevant art can recognize.

In particular and in regard to the various functions performed by the above described components devices circuits systems and the like the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. a functional equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary aspects of the claimed subject matter. In this regard it will also be recognized that the innovation includes a system as well as a computer readable storage medium having computer executable instructions for performing the acts and or events of the various methods of the claimed subject matter.

