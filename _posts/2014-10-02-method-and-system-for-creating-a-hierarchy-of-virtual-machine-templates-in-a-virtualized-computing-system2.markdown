---

title: Method and system for creating a hierarchy of virtual machine templates in a virtualized computing system
abstract: A virtualized computing system supports the execution of a plurality of virtual machines, where each virtual machine supports the execution of applications therein. Each application executes within a container that isolates the application executing therein from other processes executing on the computing system. A hierarchy of virtual machine templates is created by instantiating a parent virtual machine template, the parent virtual machine template having a guest operating system and a container. An application to be run in a container is determined, and, in response, the parent virtual machine template is forked to create a child virtual machine template, where the child virtual machine template includes a replica of the container, and where the guest operating system of the parent virtual machine template overlaps in memory with a guest operating system of the child virtual machine template. The application is then installed in the replica of the container.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09652273&OS=09652273&RS=09652273
owner: VMware, Inc.
number: 09652273
owner_city: Palo Alto
owner_country: US
publication_date: 20141002
---
Recently the use of application containers has become prevalent as a way of executing applications on a host computer. A container provides for the isolation of a group of processes from the others on an operating system. By making use of existing operating system functionality such as Linux name spaces containers maintain their own private view of the operating system file system structure and network interfaces. Containers share the operating system kernel with other processes but can be constrained to some extent to use an amount of resources such as the central processing unit CPU random access memory RAM or input output I O devices. Containers have proven advantageous because they typically have a small system footprint. That is containers provide a relatively thin encapsulation layer above and beyond any applications contained therein. Thus instantiation and deployment of containers is relatively quick.

Virtual machines on the other hand tend to deploy more slowly than containers. This is due to the fact that virtual machines are a software abstraction of a physical computer. Thus a virtual machine typically includes a guest operating system and a virtual hardware platform. These virtualized system components are not present in containers.

However virtual machines are advantageous because a higher degree of isolation and security may be achieved between virtual machines as opposed to the degree of isolation that may be achieved between containers. This is due to the filet that containers run on the same kernel thus problems from one container may infect other containers. In addition while containers may be configured to use a certain amount of system resources it is possible for a malicious application executing in a container to circumvent such restrictions and monopolize CPU storage or I O resources. By contrast virtual machines allow system administrators to separately configure each virtual machine in a cloud environment to receive a predefined allocation of system resources. For example in some cases a virtual machine may be configured to receive a guaranteed minimum allocation of CPU resources. In other cases a virtual machine may be configured to receive a constant relative share of available CPU resources. This isolation and security provided by virtual machines is especially important in multi tenant cloud based computing environments.

Further because the application programming interface API that a hypervisor uses to execute a virtual machine is more limited than the API of a general purpose kernel operating system virtual machines tend to have a smaller attack surface than a shared kernel. Thus it is generally more difficult to compromise a virtual machine executing under control of a hypervisor than it is to compromise a container running under the control of a shared kernel. Further even if a virtual machine is compromised superior isolation of virtual machines prevents the compromised virtual machine from affecting other virtual machines. Finally there exists a rich set of management tools directed to virtual machine environments that is lacking in containerized environments.

Therefore cloud based computing environments are often faced with a choice between rapidly deployable but weakly isolated and unsecure containers and strongly isolated and highly secure but slowly deployed virtual machines.

In a first embodiment a method of creating a hierarchy of virtual machine templates in a virtualized computing system is provided the virtualized computing system supporting the execution of a plurality of virtual machines and each virtual machine supporting the execution of one or more applications therein. Each application executes within a container that isolates the application executing therein from other processes executing on the virtualized computing system. The method comprises the steps of instantiating a first parent virtual machine template having a guest operating system and a first container and determining a first application to be run in a container. The method further comprises the steps of forking the first parent virtual machine template to create a first child virtual machine template the child template virtual machine including a replica of the first container wherein the guest operating system of the first parent virtual machine template is mapped to a memory location that overlaps with a memory location of a guest operating system of the first child virtual machine template. The method further comprises the step of installing the first application in the replica of the first container.

A second embodiment provides a non transitory computer readable medium that includes instructions that when executed enable a host computer to implement one or more aspects of the above method.

In a third embodiment a method of deploying containerized applications for execution within virtual machines is provided the virtual machines executing in a virtualized computing system each virtual machine supporting the execution of one or more containerized applications therein and each application executing within a container that isolates the application executing therein from other processes executing on the virtualized computing system. The method comprises the steps of receiving from a requestor a request to execute an application and locating a first virtual machine template that includes a container configured to execute the application. The method further includes the steps of forking the first virtual machine template to create a first child virtual machine that includes a replica of the container and launching the application to execute within the first child virtual machine.

As shown in VM executes a guest operating system OS . Guest OS is an operating system capable of being executed in a virtualized computing environment and which supports application containers described in more detail below . Examples of guest OS include for example versions of the Linux operating system.

When guest OS executes within VM portions of the operating system code and associated data are allocated memory pages in system random access memory or RAM depicted as RAM in . Conceptually the allocation of RAM to guest OS may be depicted as a segment of RAM. Thus guest OS is depicted as being allocated segment in should be noted that the allocation of physical memory for guest OS is not necessarily a contiguous range of physical memory addresses. Rather the depiction of segment as a contiguous block of memory is for illustrative purposes. In embodiments instructions and data for guest OS are loaded into RAM typically through execution of a hypervisor not shown configured to manage the execution of virtual machines where the instructions and data are fetched from segment to be executed on a central processing unit CPU when VM is allocated processing time on the CPU.

VM also executes container daemon . Container daemon which runs as a virtualized application under the control of guest OS is a process that enables the creation deletion and management of container objects or containers for VM . Containers are software instances that enable virtualization at the operating system level. That is with containerization the kernel of an operating system that manages a host computer is configured to provide multiple isolated user space instances. These instances referred to as containers appear as unique servers from the standpoint of an end user that communicates with the containers. However from the standpoint of the operating system that manages the host computer on which the containers execute the containers are user processes that are scheduled and dispatched by the operating system.

According to one or more embodiments container daemon communicates with local or remote processes according to a client server model. For example a client process e.g. a system administration process may transmit a request to container daemon to instantiate a new container or to install a new application in an already existing container. Further another client process may transmit a request to container daemon to quiesce or destroy a container.

As was the case for guest OS program instructions that correspond to container daemon are loaded after translation of virtual addresses to physical addresses into RAM and subsequently executed from RAM . As shown in container daemon is allocated segment in RAM . Segment is depicted as a contiguous block of physical RAM. However the depiction is for illustrative purposes. That is instructions and data corresponding to container daemon may be loaded into non contiguous portions of RAM .

It should be noted that container daemon executes as a part of VM and runs in a virtualized manner under the control of guest OS . Thus container daemon executes system calls and requests operating system services and VM resources from guest OS . Guest OS allocates virtual resources to container daemon which correspond to physical computing resources such as physical memory in RAM . The physical resources are allocated by a hypervisor that manages the execution of VM as well as all other virtual machines executing within the particular host computer on which VM runs.

Referring to VM also includes a container that executes therein depicted as container . Container is instantiated on VM by container daemon . An instantiated container executes in a state where an application may be installed therein. Container also executes under the control of guest OS . As shown instructions and data corresponding to container which executes in a virtual address space are loaded into segment of physical RAM .

As previously mentioned fork operation creates a child VM i.e. VM based on parent VM . In embodiments a system administrator initiates fork operation using a system management software platform. In other embodiments fork operation is initiated automatically by system management software upon detection of a condition on the host computer on which the VMs execute. In addition the parent VM may itself initiate fork operation . The forking of a VM is similar in spirit to the forking of a process such as performed by the fork system call in the Unix operating system. When a parent VM issues a fork call one or more clones of the parent VM referred to as child VMs are created. Each child VM replicates all of the running processes and threads executing in the parent VM and executes on the same host computer that the parent VM executes on. When a child VM is created the child VM has an identical view of the host computer on which the parent VM is running. Indeed once a child VM is created as a result of a fork operation executed by a parent VM the child VM starts executing at the instruction that immediately follows the fork operation executed in the parent. Each child VM has a different and unique identifier which allows each to be distinguished from the other child VMs and from the parent. Each child VM executes independent of the parent VM and from other child VMs.

At the time a child VM is created the memory image of the child VM i.e. the instructions and data stored in RAM maps to the same memory locations in RAM as the memory image of the parent VM. Indeed the VM fork operation results in the creation of a stateful clone of the parent VM meaning that at the time of the VM fork operation the current state of the child VM including the memory state of the child VM is the same as that of the parent VM. However as a child VM begins to execute and attempt to modify the memory pages that are shared with the parent VM those memory pages are first copied to a different region of memory e.g. RAM the child VM s virtual memory is then altered to map to the copied pages and the copied pages are then modified by the child VM. Such a scheme is referred to as copy on write COW . Embodiments of the present invention implement a COW scheme such that the memory state of the parent VM is not disturbed by memory writes issued by corresponding child VMs.

Thus as shown in when VM is created by forking operation the guest OS executing in VM denoted also by guest OS maps to segment of RAM which is the same segment of RAM that guest OS of VM maps to. Similarly container daemon executing in VM maps to segment of RAM which is the same segment of RAM that container daemon that is executing in VM maps to.

At the time that VM is created by forking process VM includes container which maps to the same physical memory location i.e. segment as does container executing in VM . It should be noted that container is an empty container which does not have any applications installed therein. However once an application is installed in a container e.g. by a system administrator the memory image of the container changes i.e. the container grows in size and the data stored therein changes because additional application instructions and data are stored with the container. Thus as shown in application is depicted as having been installed into container of VM . Due to the COW semantics reined to above once application is installed in container container no longer maps to segment . This is due to the fact that when application is installed segment is insufficient to support the increased memory required to execute application within container . Further because application installation changes the memory to which container is mapped COW requires container to be mapped to a different memory segment. Thus in order to accommodate the increased memory needs of application container guest OS allocates additional virtual memory for application container which is mapped by a hypervisor that manages physical RAM for VM to segment of RAM . Although segment is depicted as being completely separate from segment it should be noted that the two segments may in fact partially overlap. That is some instructions and data pertaining to container may also remain unchanged as a result of the execution of application container . Thus the portion of RAM that corresponds to these instructions and data may be shared by VMs and . In such a case only the additional instructions and data for application and any container data that application changes as a result of executing would be located in a portion of RAM that does not overlap with segment .

Containerized applications that run within virtual machines provide a number of benefits. Application containers have the benefit of being lightweight and having low startup times. In addition application containers are able to execute under the direct control of a native operating system or a guest operating system of a virtual machine. However application containers do not provide the same level of isolation as do virtual machines which is important in multi tenant cloud based computing environments. Further containers are difficult if not impossible to manage using existing virtual machine management and monitoring tools. On the other hand virtual machines which each include a guest operating system executing therein tend to have larger memory footprints and higher startup times. Thus containerized applications executing within virtual machines that have low startup times are advantageous.

As shown in management server coordinates the creation of VMs and the addition of the created VMs to VM templates . Management server creates a base VM depicted as VM which includes a guest OS similar to guest OS in . According to embodiments guest OS is capable of executing in a virtual machine i.e. under the control of a hypervisor and is capable of supporting execution of application containers. When management server creates VM management server records information about VM in a registry . Registry is a database that stores information pertaining to virtual machines such as virtual machine identifiers network addresses e.g. media access control MAC addresses and Internet Protocol IP addresses as well as identifiers of application containers that the virtual machines execute. In one or more embodiments this information enables an application server described below in response to an application request to locate an appropriate template VM in the hierarchy and to create a child VM based on the template that is responsive to the needs of the application requestor.

Management server instructs VM to perform a VM fork operation similar to fork operation in in order to create VM immediately after the fork VM includes guest OS which is shared with VM . After creation management server instantiates a container in VM which runs under the control of guest OS . It should be noted that container does not contain any applications. Management server then registers VM in registry .

Management server then continues creating VM templates by instructing VM to perform two fork operations in order to create VMs and respectively. At the time of creation both VMs and are exact copies of VM . That is both VMs and have the same state as VM execute all of the same processes as VM and include a container that shares the same memory location as container . However as shown in management server installs application into the container of VM . This container is referred to as container because container after installation of application no longer shares the same state including memory location as that of container of VM . Similarly management server installs application into the container of VM which is referred to as container in . After creating both VMs and management server registers both VMs in registry .

It should be noted that VMs each shares from a memory standpoint the same guest OS . However each of containers is stored in a different part of system RAM such as RAM in .

Although it is often advantageous to execute a single application container within a virtual machine it is at times desirable to have more than one application container execute in a virtual machine. This is especially true when the applications need to communicate with each other with minimal latency. Thus continuing with the creation of the hierarchy represented by VM templates management server instructs VM to perform fork operations to create VMs and . Immediately after each of VMs and is created these VMs are exact copies of VM . Thus each of these VMs includes guest OS and container with application executing therein. However as shown in the figure management server proceeds to instantiate container on VM and container on VM . Moreover management server installs application in container and application in container . Management server also registers both VMs and in registry .

It should be noted that container in VM and container in VM are identical in terms of memory state at the time each of these VMs is created as a result of the forking of VM . However VMs and are independent virtual machines. This means that should either virtual machine execute application then the respective containers would cease to be exact replicas of container of parent VM . This results in unintended memory usage as additional memory would be required by each of the independently executing application containers of VMs and . Indeed this holds true for any of the applications containers and guest OS of any child VM. Thus in order to avoid containers applications and any operating system software in a child VM from changing from any corresponding software in a parent VM management server stalls the execution each of the virtual machines in VM templates once that virtual machine has been created by a forking operation and once a container or application has been installed on the virtual machine. Thus referring to once management server completes creating each of VMs and completes instantiating on child VMs new containers and installing applications into those newly instantiated containers management server stalls execution of each of the VMs in VM templates to ensure that the underlying state including the memory state of each VM is preserved.

Therefore once management server finishes creating VMs in VM templates each of VMs and has a warmed up application container i.e. an application container that upon being deployed in a forked virtual machine is immediately executable . Further VM has a warmed up application container VM has a warmed up application container and VM has a warmed up application container . Further each of VMs and is registered as having executing therein the aforementioned containers as illustrated in .

As shown in the figure three application requestors requestors generate application requests and transmit those requests to application server . Requestors may be client processes that require performance of discrete transactions by a remote application such as for example a database query . In such a case requestors transmit requests to application server . Application server creates one or more virtual machines by instructing a template virtual machine to perform a fork operation . The forked virtual machines execute to service the request and application server returns results either synchronously or asynchronously to the requestor whose request has been serviced.

In other cases requestors may require continuing access to a newly created containerized application. In such cases application server instructs a template virtual machine to perform a fork operation and then after the virtual machine is forked application server returns a handle to the forked virtual machine to the requestor . This enables the requestor to interact with the forked virtual machine on a continuing basis.

In still other cases any of requestors may have an application that requires execution in an application container. In such a case the requestor invokes application server and passes a copy of the application or a pointer to the application to application server or alternatively specifies the name of the application as a parameter that is passed to application server . In such a case application server forks a containerized VM template that executes in VM templates . Application server then installs the application passed from the requestor into a container executing within the forked VM and launches the application. Other patterns for invoking application server are possible and within the scope of the present disclosure.

For example referring to requestor transmits an application request to application server . The request of requestor includes an application that requestor requires to be executed in a container in a virtual machine. In response to receiving the request from requestor application server performs a lookup function in registry in order to locate a VM template that includes a container into which the application may be installed i.e. an empty container . Application server locates VM because VM includes empty container . Application server then instructs VM to perform a fork operation which creates VM . Upon creation of VM the VM includes guest OS and container . Application server then installs application which is the application that requestor passes to application server into container of VM . Once application is installed in container in one or more embodiments application is launched. In addition according to embodiments application server transmits a handle to VM back to requestor which enables requestor to interact with VM .

Still referring to requestor transmits a second application request to application server . The request transmitted by requestor does not include a copy of or a pointer to an application. Rather the request transmitted by requestor indicates application and optionally includes parameters to be passed to that application. In response to receiving the request from requestor application server locates in registry VM as a template virtual machine that executes a container that includes application . Therefore application server instructs VM to perform a fork operation. This results in the creation of VM which as shown includes container which itself contains application . After creation of VM containerized application is launched parameters if required are passed to application and results from application are returned to requestor . In other embodiments once VM is created by the fork operation application server returns a handle to the forked VM to requestor .

Still referring to requestor transmits a third application request to application server . The request transmitted by requestor indicates that requestor requires access to two applications namely applications and each of which executes in a separate container. In response to the request from requestor application server locates VM in registry because VM includes containers and each of which includes respectively application and . Application server then instructs VM to perform a fork operation to create VM . As shown VM includes container which executes application and container which executes application . After creation of VM application server launches containerized applications and passes parameters if required to the applications and returns any results generated by the launched applications to requestor . In other embodiments once VM is created by the fork operation application server returns a handle to the forked VM to requestor which enables requestor to communicate with containerized applications and on an ongoing basis.

It bears mentioning that when each of VMs is created by a corresponding fork operation each of the VMs is an exact replica i.e. has identical state as its parent VM i.e. VM and respectively . However after applications are installed or launched in each of the forked VMs the states of the child and parent VMs become different and each child VM executes independent of the corresponding parent VM.

Method begins at step where management server instantiates a parent VM on a host computer. The parent VM includes a guest OS where the guest OS is capable of executing one or more application containers. An example of such a parent VM is VM depicted in .

Once the parent VM is instantiated method proceeds to step . At step management server instructs the parent VM to perform a forking operation to create a child VM where after forking management server starts a container daemon on the child VM and instantiates an empty application container on the child VM. The child VM created at step is referred to as a container VM template. An example of a container VM template is VM depicted in .

After the parent VM and container VM template are created at steps and management server registers both the parent VM and container VM template at step . As previously mentioned the registering of template VMs in a hierarchy such as VM templates depicted in enables for example an application server to locate a VM in that hierarchy in order to appropriately service application requests. Registration of the parent VM and the container VM template is accomplished in embodiments by updating a centralized registry such as registry shown in . According to embodiments management server stores for each registered VM a virtual machine identifier a network address and one or more application identifiers that correspond to applications that execute in the registered VM.

At step management server stalls execution in both the parent VM and container VM template. The stalling step is performed to prevent updates to the state including the memory state of each of these VMs. As mentioned above. VM templates that are instantiated in a hierarchy through a forking process share one or more segments of RAM. This memory sharing scheme provides for consistency among VMs in the hierarchy and conserves scarce memory resources. According to one or more embodiments the stalling is performed by preventing any VM template from executing instructions that would modify any of its shared memory segments.

At step the administrative software i.e. management server performing method determines a next application that is to be executed in a container. According to one or more embodiments management server maintains a list of applications that are required by one or more end users to run in an application container. It is advantageous to run some of these applications in a single container virtual machine while it may be advantageous to execute other applications in a multi container virtual machine.

Accordingly once management server determines the next application to be run in a container method proceeds to step . At step management server determines whether the next application is to run in a VM with any other containerized applications.

If the next application is to be run in the same VM with other containerized applications then method proceeds to step . At step management server locates a VM template in the hierarchy that contains the applications with which the current application is to execute. Management server locates an appropriate VM template by performing a lookup to the registry i.e. registry . After locating a VM template that has the required containerized applications method proceeds to step where management server instructs the located VM template to perform a fork operation thereby creating a replica of the VM template in the hierarchy. As previously mentioned at the time that the replica of the VM template is created the VM replica executes with identical state as the parent VM template and execution of the VM replica begins at the instruction immediately following the fork operation executed by the parent VM template.

Referring back to step if management server determines that the next application is to run in a container standalone in a virtual machine then method proceeds to step . At step management server instructs the container VM template e.g. VM in which has a single empty container to perform a fork operation thereby creating a replica of the container VM template in the hierarchy where the state of the VM replica is identical at the time of the fork as the state of the parent VM template.

Next at step management server instantiates a new container if needed on the forked VM and installs the application in the container. It should be noted that anew container would need to be instantiated in the case of a multi container VM. However if the application is to run in a single container VM then the application is installed in the empty container that is copied due to the fork operation from the container VM template. Further once an application is installed in the empty container that container with the application installed therein occupies a segment of RAM that is different from the segment occupied by the empty container. This is shown in by containers and . It should be noted that due to COW semantics once an application is installed in a container the virtual memory of the forked VM is remapped so that the physical memory pages allocated to the application container are no longer the same as the physical memory pages allocated to the empty container of the parent VM template.

Once the application is installed to the container in the forked VM management server then registers and stalls the execution of the forked VM as a new VM template at step . The registration of the forked VM specifies in embodiments an identifier and network address for the new VM template as well as an inventory of all application containers installed therein. The stalling of the execution of the new VM template ensures that its state is preserved.

Once step is complete the hierarchy e.g. VM templates shown in includes a new VM template with one or more warmed up containerized applications ready for rapid deployment. Management server then determines at step whether there are more applications that are required to be run in a container. If there are more applications that require execution in a container then method proceeds back to step where management server determines a next application. Management server then performs steps as set forth above. However if management server determines that there are no more applications that require execution in a container then method terminates.

Method begins at step where application server receives an application request. Application requests include for example an identifier for an application one or more parameters for the application as well as an address where results from execution of the application are to be returned. In addition the application request may include a copy of or a pointer to an application that a requestor requires to be executed in a container.

Thus at step application server determines whether the request includes the application to be executed. If the request does include a copy of or pointer to the application to be executed then method proceeds to step . At step application server forks a container VM template or alternatively instructs a container VM template to execute a fork operation such as the container VM template described in connection with method in . As previously mentioned such a container VM template is a virtual machine template that executes a single empty container. After executing the fork operation a forked VM template is created where the forked VM template has identical state as the parent VM template. Further once created the forked VM template is a fully initialized and executing virtual machine that begins execution at the instruction immediately following the fork operation executed by the parent VM template. Once application server forks the container VM template method proceeds to step .

At step application server installs the application provided with the application request into the container of the forked VM template created at step . As previously mentioned as a result of COW installation of the application at step causes the virtual memory of the forked VM template corresponding to the container to be remapped so that the container of the forked VM template no longer overlaps in physical memory with the container of the parent VM template. Thus after step a VM is instantiated with a warmed up application where the application is the one provided in the request received at step . Method then proceeds to step .

However referring back to step if the received request does not include a copy of the application or pointer to the application then method proceeds to step . At step application server locates a VM template in the hierarchy that includes the application specified in the received request. According to embodiments the request may specify a particular application with a unique application identifier. In response application server performs a lookup in a centralized registry such as registry in to locate a VM template that includes a container that executes the specified application.

Application server determines at step whether such a VM template has been located. If application server does not locate an appropriate VM template then method proceeds to step where an error is returned to the application requester. Method then terminates.

However if application server is able to locate an appropriate VM template then method proceeds to step . At step application server forks the located VM template to produce a child VM that includes the containerized application that was specified in the request. Then at step the forked VM is launched to process the received request. It should be noted that step is reached from step when the request includes the application to be run and from step when the request does not include the application to be run . Processing of the request at entails in embodiments the launching of the forked VM the invoking of one or more containerized applications in the forked VM and the passing of parameters received in the request to the containerized applications.

After the request is processed at step method proceeds to step . At step results if any from executing the containerized application are obtained and returned to the requestor. In other embodiments a handle to the forked VM is returned to the requestor which enables the requestor to conduct ongoing communication with the forked VM.

After step method proceeds to step . At step application server having returned results to the requestor determines that the forked VM is no longer needed and in order to conserve system resources kills all processes executing on behalf of the forked VM. However in other embodiments application server receives an indication from a requestor that the forked VM is no longer required before proceeding to kill the forked VM.

Although one or more embodiments have been described herein in some detail for clarity of understanding it should be recognized that certain changes and modifications may be made without departing from the spirit of the disclosure. The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing yielding identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the disclosure may be useful machine operations. In addition one or more embodiments of the disclosure also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present disclosure may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present disclosure have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Many variations modifications additions and improvements are possible. Plural instances may be provided for components operations or structures described herein as a single instance. Boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the disclosure s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claim s .

