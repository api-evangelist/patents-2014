---

title: Package design and generation
abstract: Solution packages for a product for deployment on a collection of servers can be designed using one or more designers that provide user interfaces for visually arranging and configuring elements of the product. A package object model includes a managed object model that represents a package or feature manifest as defined by a product manifest XML schema. The object model can be used to create references to other project item and feature definitions. The extended object model can be used to generate an equivalent package or feature manifest XML file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582257&OS=09582257&RS=09582257
owner: Microsoft Technology Licensing, LLC
number: 09582257
owner_city: Redmond
owner_country: US
publication_date: 20140207
---
This application is a continuation of and claims the benefit of and priority to U.S. patent application Ser. No. 13 858 093 entitled Package Design And Generation filed Apr. 8 2013 by Phillip Michael Hoff et. al. the entire contents of which are expressly incorporated by reference. That application is a continuation of and claims the benefit of and priority to U.S. patent application Ser. No. 12 472 380 entitled Package Design And Generation filed May 27 2009 by Phillip Michael Hoff et. al. U.S. Pat. No. 8 418 165 the entire contents of which are expressly incorporated by reference.

When deploying applications to a number of locations or when some of the deployed files encode the relationships between the files it is usually not recommended to simply copy files from one location to another. Instead it is often better to create and deploy packages. A package is a set of code files and other resources that are used to create an application. Often creating packages for deployment is a complex task that involves a variety of tools and involves labor intensive error prone tasks such as hand editing complex documents and maintaining long lists of files to be included in the package. For example application and server platforms often have very specific and complex standards for the deployment and installation of new components that make manually creating packages difficult.

User interfaces for visually arranging and configuring software packages and an object model for representing the software package is provided for designing and generating software packages for deployment on a collection of server computers. The object model is generated using a domain specific language DSL . The object model is exposed to a managed extensibility platform and allows project extensions to manipulate a package outside of the user interfaces. A package design and generation tool can be employed to customize packages to determine and collect all the files needed for the package to generate a manifest that indicates where each of the files will reside on the web server and to bundle all these components into a package solution in the expected format for deployment.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Microsoft SharePoint is a collection of products and software elements that comprise a server development platform that includes browser based collaboration functions process management modules search modules and a content management platform. SharePoint is a web server application that can be used to create and host one or more web sites that access shared workspaces information stores and documents. SharePoint can also be used to host defined applications such as web workflows wilds blogs and so on. SharePoint is an application built on top of a web server that facilitates the creation of individual sites on a number of servers that house libraries of documents lists and data etc. accessible via a web interface in a browser.

Currently to create a SharePoint solution package for deployment to a collection of web servers a user has to manually perform a number of steps that are both labor intensive and error prone. First the user creates a new project in his integrated development environment. He then adds web pages web parts template files code and so on. These files are added in a particular folder structure that matches their ultimate location within the software package. Next he creates additional manifest files which indicate to SharePoint how the files within the software package should be deployed. He then creates a directive file which indicates to the compression tool which files to include in the software package.

In accordance with aspects of the subject matter disclosed herein a package design and generation tool is provided that enables the user to customize the appearance and layout of elements of a software package. For example the package design and generation tool can be employed to include a customized workflow in a particular feature of the package to determine and collect all the files needed for the workflow to generate a manifest that indicates where each of the files will reside on the web server and to bundle all these components into a package solution in the expected format for deployment. It will be appreciated that while the subject matter disclosed herein is described within the specific setting of SharePoint the subject matter or aspects thereof can be applied to any software created for deployment on a collection of servers.

System may include one or more of a processor such as processor a memory and a software package designer and generator . Other components well known in the arts may also be included but are not here shown. It will be appreciated that software package designer and generator can be loaded into memory to cause one or more processors such as processor to perform the actions attributed to the software package designer and generator . Software package designer and generator in accordance with aspects of the subject matter disclosed herein may receive a project system input and produce a solution package for deployment. Software package designer and generator may receive a package definition file and produce a customized package definition in response to user input.

Software package designer and generator which can also be referred to as a software package design and generation tool or software package design and generation module can include one or more of the following a validator represented in a by validator a package designer represented in by package designer a feature designer represented in by feature designer a visualizer represented in by visualizer a package generator represented in by package generator and an object model represented in by object model . In operation software package designer and generator may receive project system and produce solution package . A manifest can also be generated. Manifests include package manifests which list the features in the package among other things feature manifests which list the project items in the feature and element manifests which list the individual files that make up the project item . A user s customized manifest may be merged with a package provided manifest to produce a merged manifest that is included in the solution package . Solution package can represent any software including software deployed to a collection of server computers such as a collaborative server application such as but not limited to Microsoft s SharePoint.

Validator checks for errors that would prevent creation of a correct or working solution package . In accordance with some aspects of the subject matter disclosed herein before the rest of the packaging process commences a series of rules are executed. Each rule or combination of rules in the set of validation rules may check a particular component in the package. For example one rule may check that there are no duplicate project items in the same feature. Another example of a rule may check for compatibility between the project item and the feature in which the project item is placed. If a rule is violated an appropriate error or warning can be reported to the user visually on a display or in printed form. The errors or warnings can be received by the user who then has an opportunity to make changes to package components using the designers. Rules can be extensible. Rules can target individual features or the package as a whole. The validator can use the managed extensibility framework MEF to locate and instantiate a core set of rules shipped with the product as well as additional rules defined by third parties via a public application programming interface API .

The package design and generation tool can include designers for arranging and configuring packages and features. A package designer can be used to configure features within a package combine combinations of features into the package set properties on the package visualize defined features in the project add a feature to the package remove a feature from the package resort features within the package modify aspects of a future installation of the package or modify an uninstallation of the package and so on based on directives received from user input. A feature designer based on user input can configure project items within a feature combine combinations of project items into a feature set properties on a feature visualize defined project items in the project add a project item to a feature remove a project item from a feature.

In accordance with some aspects of the subject matter disclosed herein the designers are Microsoft Visual Studio designers that visually arrange and configure SharePoint packages and features via drag and drop operations click and drop or via other well known methodologies. A user can customize an object model via the designers by adding or removing defined elements in the object model. The designers can be built atop a domain specific language designer. A domain specific language or DSL is a programming language or specification language dedicated to a particular problem domain a particular problem representation technique and or a particular solution technique. The designers may but do not necessarily use the design surface associated with the DSL. Instead these designers may integrate UI user interface elements based on a different UI technology such as but not limited to Windows Presentation Foundation WPF with the DSL UI framework and may embed WPF based UI elements. The UI elements presented to the user when a designer is opened may be extensible. For example the Managed Extensibility Framework MEF can be used to identify and instantiate from the set of all views in the system only the set of views associated with a particular component e.g. package or feature within the package object model.

Package designer receives user input provided to arrange features within a package to combine combinations of features into a package to set properties on packages to see the defined features in the project to add or remove features from the package to resort features within the package to modify the way the installation or uninstallation of a package is handled e.g. a user can change the order in which features included in the package are activated when the package is installed on the server etc. and so on to customize packages. Feature designer receives user input provided to arrange project items within a feature to set properties on features to see the defined project items in the project to add or remove project items from the feature and to customize project items to modify the way the installation or uninstallation of a feature is handled and so on. In accordance with aspects of the subject matter disclosed herein when changes are made via the designers the changes are made to an object model . When the changes to the object model are saved the changes to the object model are converted back into a serialized format e.g. such as but not limited to an XML file .

The software package designer and generator can include a visualizer that displays the structure of the packages in a view. For example in accordance with some aspects of the subject matter disclosed herein the visualizer is a Visual Studio tool window that displays the structure of the SharePoint packages in a tree view. The user can select an item within the tool window and view and or change its settings in a Visual Studio properties window. The user can also move items from one location in a SharePoint package to another using a drag and drop or click and drag operation or via any well known technique.

The software package designer and generator can include a package generator that generates the software package . For example a package generator such as package generator can extend the project build process in order to allow a user to generate the SharePoint package designed in the designers described above. Custom MSBuild tasks and targets can automatically extract the SharePoint package and feature definitions use the definitions to generate the appropriate package and feature manifest XML files e.g. manifest and bundle them with associated project item files into a format such as but not limited to a compressed format having the .wsp extension expected by SharePoint deployment software on the collection of servers to which the solution package is deployed. Package generation can be executed via menu items within Visual Studio or on the command line. Packaging is described more fully below with respect to

An object model such as object model can represent one or more packages of the project. The object model may represent a managed object model that represents one or more SharePoint packages or features. The object model may be modeled after manifest schemas such as the SharePoint manifest XML schemas. The object model can be defined and generated using a Domain Specific Language DSL framework. Instances of elements of the object model can be added and or removed via the designers described above. Other components such as definitions and project items including but not limited to other SharePoint feature definitions and project items both within the current project and well as within other projects in the IDE can be referenced as described more fully below with respect to . For example components within the current Visual Studio project as well as in those in other projects in the Visual Studio solution may be referenced. The object model so defined can be used to generate an equivalent package component e.g. an equivalent SharePoint package or feature manifest XML file by mapping types and properties in the object model to elements and attributes in a manifest XML schema. Additionally an instance of the object model can be created from an existing package or feature manifest file. Transformation between files and object model is described in more detail below with respect to

Similarly project can include one or more package definitions such as package definition etc. one or more feature definitions such as feature definition etc. and one or more project item definitions such as project item definition etc. Project can also include one or more packages such as package etc. defined by package definition etc. one or more features such as feature etc. defined by feature definition etc. one or more project items such as project item etc. defined by project item definition etc. Package etc. may include one or more references to features such as feature reference etc. Feature reference etc. may point to or reference feature etc. Similarly feature may include one or more references to project items such as project item reference etc. Project item reference etc. may point to or reference project item etc. Project item etc. may include one or more references to files such as item file reference etc. Item file reference etc. may point to or reference a file such as item file .

As described above the project can include one or more project items. A project item such as project item can be one of many kinds of tangible byproducts produced during the development of an application. An project item can be one of a set of components extensions some of which can be shipped with the product e.g. web part list definition content type etc. and which can be added to by a third party. Files such as project item file that are referenced in the project item can be any appropriate file including but not limited to an element manifest a schema a bit map image a document and so on.

A feature reference in a package in project can reference a feature in project indicated by line in and vice versa. A project item referenced in project can reference files within its parent e.g. project . A project such as project or project can be any software created for deployment on a collection of servers. More particularly a project can be a collaborative server application such as but not limited to a SharePoint application as described above. The package definition refers to one or more features that may reside in the current project or may be in another project in the solution. The feature similarly has references to one or more of the project items that are included in the solution either in the current project or in another project in the solution. A project item such as project item etc. may include a number of files each of which has to go to a particular location on a server in the collection of servers.

Once the individual project items of a software application have been created method can be called. Method in accordance with some aspects of the subject matter disclosed herein receives a project to be used by a development environment including but not limited to Visual Studio. The project can include logic for workflows defined list definitions and so on. Once the project has been loaded customization of the design of the software package can commence at .

Customization can be performed using the designers described above. It will be appreciated that customization with or without the use of the designers is an optional step. That is if for example the package design is already in a desired state no customization has to be performed before package creation at . Creating the package may comprise creating a single compressed and or bundled package such as but not limited to creating a solution package such as a Windows Solution Package .wsp file that includes the resources for a SharePoint product or products.

Creating the package can include one or more of the following enumeration of the files and data to be included in the package transformation token replacement layout and bundling and possibly the compression of the components into a solution package at . The created solution package can then be deployed onto one or more servers. Creating the package can also include a step preceding the enumeration step in which the package is validated as described above.

Enumeration includes examining each of the files in the project and determining the files and data to be included in the solution package. In operation enumeration may include traversing a package definition of one or more packages in a project to reach a feature reference traversing the feature reference in the package to reach a feature traversing a project item reference in the feature to reach a project item traversing a file reference in the project item to reach a file. Well known tree traversal techniques can be used to determine a complete list of files and data to include in the solution package e.g. creating a manifest or master list of elements to be included in the package . Once the list of files and data for the package has been determined the act of transformation can commence. Transformation includes using the files determined in the enumeration step and data associated with the files to generate one or more manifest files in a format that is compatible with the product packaging schema mapping types and properties in the object model to elements and attributes in the manifest XML schemas.

At token replacement is performed. Token replacement refers to a selection by the user of one set of a plurality of sets of provided variable names for use within one or more of the transformed files. The variable names that are replaced may represent values which are difficult or impossible for the user to know until the packaging process has begun. The variable names may refer to values which frequently change so that token replacement frees the user from updating the values manually. During the token replacement phase a subset of the files included in the package are processed and replacement of variable names with variable values can be performed. In accordance with aspects of the subject matter disclosed herein files with extensions matching a configurable list of extensions will have token replacement performed e.g. .xml .aspx etc. . At the layout step involves creating a preview of the structure of the package on disk. A hierarchy of directories is created and the enumerated and transformed files are placed in locations relative to the hierarchy. The layout step provides the user with an opportunity to perform additional customization. At using the directory hierarchy and all the files in the directory hierarchy elements of the package are bundled into one file. In accordance with some aspects of the subject matter disclosed herein the file is compressed into the CAB compression format.

When the objects in the object model are changed via the designers the objects so modified are serialized into the definition file e.g. .feature and .package files when the object changes are saved in the designers. Once the object model has been created the transformation step of can serialize the object model and perform the transformation of step of on the deserialized object model. In accordance with aspects of the subject matter disclosed herein the transformation process can include deserializing the definition file e.g. using the DSL s proprietary XML format into an instance of the object model transforming the object model according to the packaging items enumerated in the previous act adding the appropriate entries to the object model for each file included in the feature or package and serializing the object model to a manifest file e.g. using SharePoint s XML format . These actions can occur for each feature included in a package as well as for the package itself. At this point the bundling and or compression acts described above can be performed.

In order to provide context for various aspects of the subject matter disclosed herein and the following discussion are intended to provide a brief general description of a suitable computing environment in which various embodiments may be implemented. While the subject matter disclosed herein is described in the general context of computer executable instructions such as program modules executed by one or more computers or other computing devices those skilled in the art will recognize that portions of the subject matter disclosed herein can also be implemented in combination with other program modules and or a combination of hardware and software. Generally program modules include routines programs objects physical artifacts data structures etc. that perform particular tasks or implement particular data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. The computing environment is only one example of a suitable operating environment and is not intended to limit the scope of use or functionality of the subject matter disclosed herein.

With reference to a computing device for package design and generation in the form of a computer is described. Computer may include a processing unit a system memory and a system bus . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit . The system memory may include volatile memory and nonvolatile memory . Nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM or flash memory. Volatile memory may include random access memory RAM which may act as external cache memory. The system bus couples system physical artifacts including the system memory to the processing unit . The system bus can be any of several types including a memory bus memory controller peripheral bus external bus or local bus and may use any variety of available bus architectures.

Computer typically includes a variety of computer readable media such as volatile and nonvolatile media removable and non removable media. Computer storage media may be implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer .

It will be appreciated that describes software that can act as an intermediary between users and computer resources. This software may include an operating system which can be stored on disk storage and which can control and allocate resources of the computer system . Disk storage may be a hard disk drive connected to the system bus through a non removable memory interface such as interface . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It will be appreciated that computers can be implemented with various operating systems or combinations of operating systems.

A user can enter commands or information into the computer through an input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone and the like. These and other input devices connect to the processing unit through the system bus via interface port s . An interface port s may represent a serial port parallel port universal serial bus USB and the like. Output devices s may use the same type of ports as do the input devices. Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers that require particular adapters. Output adapters include but are not limited to video and sound cards that provide a connection between the output device and the system bus . Other devices and or systems or devices such as remote computer s may provide both input and output capabilities.

Computer can operate in a networked environment using logical connections to one or more remote computers such as a remote computer s . The remote computer can be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . Remote computer s can be logically connected via communication connection . Network interface encompasses communication networks such as local area networks LANs and wide area networks WANs but may also include other networks. Communication connection s refers to the hardware software employed to connect the network interface to the bus . Connection may be internal to or external to computer and include internal and external technologies such as modems telephone cable DSL and wireless and ISDN adapters Ethernet cards and so on.

It will be appreciated that the network connections shown are examples only and other means of establishing a communications link between the computers may be used. One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard the subject matter disclosed herein man pertain to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. Aspects of the subject matter disclosed herein may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. Aspects of the subject matter disclosed herein may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

A user can create and or edit the source code component according to known software programming techniques and the specific logical and syntactical rules associated with a particular source language via a user interface and a source code editor in the IDE . Thereafter the source code component can be compiled via a source compiler whereby an intermediate language representation of the program may be created such as assembly . The assembly may comprise the intermediate language component and metadata . Application designs may be able to be validated before deployment.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus described herein or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing aspects of the subject matter disclosed herein. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects e.g. through the use of a data processing API or the like may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the subject matter disclosed herein has been described in connection with the figures it is to be understood that modifications may be made to perform the same functions in different ways.

