---

title: System and method for secure multi-tenancy in an operating system of a storage system
abstract: Exemplary methods for providing secure multi-tenancy in a Purpose Built Backup Appliance include creating a set of tenant-units (TUs), associating file system management objects (FSMOs) and users with the TUs. The methods further include maintaining a protocol config-metadata store based on the association of the FSMOs and users with the TUs. In one embodiment, in response to a first request from a first user to access a first FSMO of a first TU, the methods include determining whether the first user is authorized to access the first FSMO based on information of the protocol config-metadata store, and in response to the protocol config-metadata store indicating the first user is authorized to access the first FSMO, allowing the first user to access the first FSMO.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471803&OS=09471803&RS=09471803
owner: EMC Corporation
number: 09471803
owner_city: Hopkinton
owner_country: US
publication_date: 20140807
---
Embodiments of the present invention relate generally to data storage systems. More particularly embodiments of the invention relate to providing secure multi tenancy at a Purpose Built Backup Appliance PBBA .

Multi tenancy refers to a technology wherein a single storage appliance e.g. a Purpose Built Backup Appliance is deployed to serve multiple customers each customer using the same storage appliance for their protection storage requirements. A storage system which supports multi tenancy must satisfy the security and isolation requirements. Here the security and isolation requirements refer to the requirements that each customer s dataset must be secured and isolated from the other customers on the storage appliance. The security and isolation requirements apply to data access. For example a customer must not be able to read or write to datasets that belong to another customer. The security and isolation requirements can also refer to control access. For example an administrator of one customer must not be able to perform system configuration monitoring etc. of the datasets that belong to another customer. Thus although the customers may share the same storage appliance for backup restore or replicating their datasets none of the customers can be aware of the presence of other customers in the storage appliance.

Other than the security and isolation requirements there were some other obvious problems in deploying multi tenancy on a single storage appliance. For example a conventional PBBA does not include a mechanism in its Operating System through which the system administrator could track the system resources allocation and usage for each customer. Deploying multi tenancy on a PBBA especially in a service provider SP environment also presents a problem of administrative scaling. For example if tens or hundreds of customers are deployed in the same PBBA and if none of these customers own administrators could perform self administration then for each and every administrative requirement the customers would be dependent on the system administrator. Thus the system administrator would face a problem as the number of customers increase.

A conventional storage appliance does not natively support multi tenancy in such a manner that satisfies the security and isolation requirements. As illustrated in Purpose Built Backup Appliance PBBA has been deployed with two customers i.e. customer A and customer B. PBBA includes file system management objects FSMOs . FSMOs are allocated to customer A and FSMOs are allocated to customer B. Conventional PBBA however does not natively provide a mechanism in which FSMOs are securely isolated from customer B and FSMOs securely isolated from customer A. Further conventional PBBA does not provide a mechanism for each customer to have its own administrator who can only administer objects belonging only to the customer. Thus all administration must be performed by a single system administrator. In order for customer A and customer B to manage their respective allocated FSMOs the credentials of system administrator must be provided to both customer A and customer B. In such a scenario each customer would be able to access and manage datasets that belong to the other customer. Alternatively all system configuration and management can be performed by a third party without providing the credentials of system administrator to customer A and customer B. This approach however is not feasible in cases where the PBBA is deployed to many customers. Thus there is a need for a storage system to natively support multi tenancy by providing mechanisms within its operating system to secure and isolate the datasets of each customer.

Various embodiments and aspects of the inventions will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However in certain instances well known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.

References in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

Bracketed text and blocks with dashed borders e.g. large dashes small dashes dot dash and dots may be used herein to illustrate optional operations that add additional features to embodiments of the invention. However such notation should not be taken to mean that these are the only options or optional operations and or that blocks with solid borders are not optional in certain embodiments of the invention.

In the following description and claims the terms coupled and connected along with their derivatives may be used. It should be understood that these terms are not intended as synonyms for each other. Coupled is used to indicate that two or more elements which may or may not be in direct physical or electrical contact with each other co operate or interact with each other. Connected is used to indicate the establishment of communication between two or more elements that are coupled with each other.

Techniques for providing SMT with security and isolation to tenants are herein described. is a block diagram illustrating an example of a storage system e.g. a PBBA according to embodiment. In the illustrated example storage system has associated FSMOs with tenant unit Tu A and associated FSMOs with Tu B. As used herein a Tu refers to the highest unit of abstraction for providing security and isolation in the operating system. A Tu also acts as the highest abstraction for allocating and tracking resource utilization by a tenant. Here a FSMO refers to a unit of storage allocation that presents a unique and self contained namespace for a tenant. Each tenant can be allocated one or more FSMOs. Tenant unit A and tenant unit B have been assigned the Tu names TuA and TuB respectively. TuA is allocated to tenant A and TuB is allocated to tenant B. As used herein a tenant can be a business unit within a large enterprise e.g. a finance department marketing department etc. . A tenant can also refer to an enterprise e.g. when a storage appliance is deployed by a service provider . TuA and TuB have been assigned the Tu IDs of Tu IDA and Tu IDB respectively. FSMOs have been assigned the FSMO IDs of FSMO ID FSMO ID respectively. Further FSMOs have been assigned the FSMO paths mtree10 mtree13 respectively. These IDs and paths are shown for illustrative purposes and not intended to be limitations of the present invention. The configuration shown in shall be referenced throughout the description. Throughout the description references are made to IDs for users Tus and FSMOs. It shall be understood that these IDs are Universally Unique IDs UUIDs .

Contrary to a conventional PBBA storage system of the present invention only allows tenant A to access FSMOs associated with its tenant unit e.g. FSMOs and only allows tenant B to access FSMOs associated with its tenant unit e.g. FSMOs . FSMOs can be accessed by tenants A and B using various protocols. For example tenants A and B can access FSMOs using the 1 DDBoost protocol available from EMC Corporation of Hopkinton Mass. in which case FSMOs are known as storage units 2 Network File System NFS or Common Internet File System CIFS protocol in which case FSMOs are known as Mtrees 3 Virtual Tape Library VTL protocol in which case FSMOs are known as VTL pools or 4 Protection Point protocol in which case FSMOs are known as Vdisks. Various other protocols can be used without departing from the broader scope and spirit of the present invention.

Further by using the mechanisms of the present invention storage system enables tenants A and B to have their own respective tenant admins and thus do not rely on system admin . As used herein a system admin is an administrator authorized to perform all operations at the storage system. A tenant admin on the other hand is only authorized to perform a subset of the operations that are available to the system admin. A tenant admin is also distinguished from a system admin in that a tenant admin can only access objects that are associated with the Tu that the tenant admin has been allocated. A tenant user can only perform a subset of the operations that are available to the tenant admin. Various mechanisms of the present invention shall become apparent through the description of other figures below.

Storage system may include any type of server or cluster of servers. For example storage system may emulate a storage server used for any of various different purposes such as to provide multiple users with access to shared data and or to back up mission critical data. Storage system may be for example a file server e.g. an appliance used to provide network attached storage NAS capability a block based storage server e.g. used to provide SAN capability a unified storage device e.g. one which combines NAS and SAN capabilities a nearline also known as an archive storage device a direct attached storage DAS device a tape backup device or essentially any other type of data storage device. Storage system may have a distributed architecture or all of its components may be integrated into a single unit. Storage system may be implemented as part of an archive e.g. Extended Retention Tier and or backup system such as a deduplicating storage system available from EMC Corporation of Hopkinton Mass.

In one embodiment storage system includes but is not limited to backup restore engine deduplication storage engine and one or more storage devices communicatively coupled to each other. Storage devices may be implemented locally e.g. single node operating environment or remotely e.g. multi node operating environment via interconnect which may be a bus and or a network. In one embodiment one of the storage devices operates as an active storage to receive and store external or fresh user data while the other storage devices operates as a target storage device to periodically archive data from the active storage device according to an archiving policy or scheme. Storage devices may be for example conventional magnetic disks optical disks such as CD ROM or DVD based storage magnetic tape storage magneto optical MO storage media solid state disks flash memory based devices or any other type of non volatile storage devices suitable for storing large volumes of data. Storage devices may also be a combination of such devices. In the case of disk storage media the storage devices may be organized into one or more volumes of Redundant Array of Inexpensive Disks RAID .

In response to a data file to be stored in storage devices deduplication storage engine is configured to segment the data file into multiple chunks according to a variety of segmentation policies or rules. Deduplication storage engine may choose not to store a chunk in a storage device if the chunk has been previously stored in the storage device. In the event that deduplication storage engine chooses not to store the chunk in the storage device it stores metadata enabling the reconstruction of the file using the previously stored chunk. As a result chunks of data files are stored in a deduplicated manner either within each of storage devices or across at least some of storage devices . Data stored in the storage devices may be stored in a compressed form e.g. lossless compression Huffman coding Lempel Ziv Welch coding delta encoding a reference to a chunk plus a difference etc. . In one embodiment different storage devices may use different compression methods e.g. main or active storage device from other storage devices one storage device from another storage device etc. .

The metadata such as metadata may be stored in at least some of storage devices such that files can be accessed independent of another storage device. Metadata of each storage device includes enough information to provide access to the files it contains. In one embodiment metadata may include fingerprints contained within data objects where a data object may represent a data chunk a compression region CR of data chunks or a container of one or more CRs. Fingerprints are mapped to a particular data object via metadata enabling the system to identify the location of the data object containing a chunk represented by a particular fingerprint. When an active storage device fails metadata contained in another storage device may be utilized to recover the active storage device. When one storage device is unavailable e.g. the storage device has failed or is being upgraded etc. the system remains up to provide access to any file not stored in the failed storage device. When a file is deleted the metadata associated with the files in the system is updated to reflect that the file has been deleted.

In one embodiment the metadata information includes a file name a storage device where the chunks associated with the file name are stored reconstruction information for the file using the chunks and any other appropriate metadata information. In one embodiment a copy of the metadata is stored on a storage device for files stored on a storage device so that files that are stored on the storage device can be accessed using only the information stored on the storage device. In one embodiment a main set of metadata information can be reconstructed by using information of other storage devices associated with the storage system in the event that the main metadata is lost corrupted damaged etc. Metadata for a storage device can be reconstructed using metadata information stored on a main storage device or other storage device e.g. replica storage device . Metadata information further includes index information e.g. location information for chunks in storage devices identifying specific data objects .

In one embodiment the storage system as shown in may be used as a tier of storage in a storage hierarchy that comprises other tiers of storage. One or more tiers of storage in this hierarchy may utilize different kinds of storage devices and or may be optimized for different characteristics such as random update performance. Files are periodically moved among the tiers based on data management policies to achieve a cost effective match to the current storage requirements of the files. For example a file may initially be stored in a tier of storage that offers high performance for reads and writes. As the file ages it may be moved into a tier of storage according to one embodiment of the invention. In various embodiments tiers include different storage technologies e.g. tape hard drives semiconductor based memories optical drives etc. different locations e.g. local computer storage local network storage remote network storage distributed storage cloud storage archive storage vault storage etc. or any other appropriate storage for a tiered data storage system.

According to one embodiment backup restore engine is responsible for backing up data from remote clients e.g. clients to one or more local storage devices e.g. storage devices . Backup restore engine is also responsible for restoring and or replicating data from one or more local storage devices to the remote clients.

In one embodiment storage system includes SMT engine configured to provide security and isolation to each tenant. For example SMT engine is configured to allocate Tus to tenants by managing various config metadata. Protocol engine is configured to use these config metadata to determine whether tenants may perform data access of FSMOs at storage system . Role based access control RBAC is configured to use the config metadata to determine whether tenants may perform control access of the FSMOs and various other resources at storage system .

Referring now to . In one embodiment DM is configured to manage DM config metadata store for associating mapping FSMO IDs to FSMO paths. In one embodiment DM config metadata store includes but not limited to one or more sets of elements. Each set includes but not limited to the elements of FSMO ID path. In one set of element is shown FSMO ID path . FSMO ID contains the ID of a FSMO. Path contains the path of a FSMO. In some embodiments the FSMO name specified by the user e.g. as part of the request to access a FSMO is in the same format as the FSMO path required by DM . In some alternative embodiments the specified FSMO name may need to be converted to a FSMO path. As used herein a specified FSMO name refers to the FSMO name specified by the user as part of a user request to access the FSMO. For example in some of the protocols supported by protocol engine described further below the specified FSMO name is the same as the FSMO path. In other protocols the specified FSMO name must be converted to a FSMO path in order for DM to understand it as a path. In one such example the specified FSMO name must be prepended with a predetermined path e.g. data col1 in order to be consistent with the path format understood by DM . Each set of elements associates a FSMO ID with a FSMO path. Thus in this example DM may configure FSMO ID to include FSMO ID and path to include the path mtree10 or data col1 mtree10 . It shall be understood that DM config metadata store includes at least one set of elements FSMO ID path for each FSMO in the system. DM config metadata store may also be managed by a system admin via a system configuration interface not shown .

According to one embodiment a system admin associates the Tus to tenant users admins by configuring SMT config metadata store via a system configuration interface. In one embodiment SMT config metadata store includes but not limited to Tu config metadata store security config metadata store and name service config metadata store .

In one embodiment Tu config metadata store includes information for associating mapping Tu names to Tu IDs. Tu config metadata store includes but not limited to one or more sets of elements. Each set includes but not limited to the elements of Tu name Tu ID. In one set of element is shown Tu name Tu ID . Tu name contains the name of a Tu. Tu ID contains the ID of a Tu. Each set of elements associates the named Tu with the identified Tu. Thus in this example a system admin may configure Tu name to include the name TuA and Tu ID to include the ID Tu IDA . It shall be understood that Tu config metadata store includes at least one set of elements Tu name Tu ID for each Tu in the system.

Although Tu config metadata store has been described as being configured by a system admin it shall be understood that Tu config metadata store can be configured using other mechanisms. For example Tu config metadata store may be configured by SMT engine automatically when a new Tu is created described in further details below .

In one embodiment security config metadata store includes but not limited to one or more sets of elements. Each set includes but not limited to the elements of user name user ID Tu ID operation ID user role. In one set of element is shown user name user ID Tu ID operation ID user role . User name contains the name of a user. User ID contains the ID of a user. Tu ID contains the ID of a Tu. Operation ID contains one or more IDs identifying one or more operations. User role contains the role of a user e.g. system admin tenant admin tenant user etc. Each set of elements associates the named identified user with the identified Tu user role and identified set of operations. The operation ID element includes one or more IDs identifying one or more operations e.g. a self service operation that the named identified user can perform. The user role element allows storage system to bypass certain checks during a control access request when the requesting user is a system admin described in further details below . In this example a system admin may configure user name to include the name of TuA admin user ID to include the ID of TuA admin Tu ID to include Tu IDA and operation ID to include the ID s of operation s that TuA admin may perform. It shall be understood that security config metadata store includes at least one set of elements user name user ID Tu ID operation ID for each user in the system.

Although security config metadata store has been described as being configured by a system admin it shall be understood that security config metadata store can be configured using other mechanisms. For example config metadata store may be configured by SMT engine automatically when a new user is created and associated with a Tu.

In one embodiment SMT engine associates FSMOs to Tus by configuring DM attribute store . In one embodiment DM attribute store includes but not limited to one or more sets of elements. Each set includes but not limited to the elements of FSMO ID Tu ID. In one set of element is shown FSMO ID Tu ID . FSMO ID contains one or more IDs of one or more FSMOs. Tu ID contains the ID of a Tu. Each set of elements associates the identified FSMO s with the identified Tu. In one embodiment in response to a request to associate a FSMO with a Tu SMT engine requests DM to provide the FSMO ID of the specified FSMO name which may need to be converted to a path as described above . As used herein a specified FSMO name refers to the name provided by the user as part of the request to associate the FSMO with the Tu. In response to the request DM uses the specified FSMO name path to lookup the associated FSMO ID in DM config metadata store . For example DM may determine that path contains the specified FSMO name path and provides the ID contained in the associated FSMO ID element to SMT engine . In this example path may contain the path mtree10 and FSMO ID may contain FSMO ID .

Further in response to a request to associate a FSMO to a Tu SMT engine uses the specified Tu name to lookup the Tu ID in Tu config metadata store . As used herein the specified Tu name refers to the name provided by the user as part of the request to associate the FSMO to the Tu. For example in response to determining Tu name contains the specified Tu name SMT engine obtains the Tu ID contained in the associated Tu ID . In this example Tu name may contain TuA and Tu ID may contain Tu IDA . In one embodiment SMT engine associates the specified FSMO to the specified Tu by atomically storing the obtained FSMO ID and the obtained Tu ID in DM attribute store via a DM attribute interface not shown . For example SMT engine atomically stores the ID obtained from FSMO ID e.g. FSMO ID in FSMO ID and the ID obtained from Tu ID e.g. Tu IDA in Tu ID . In this example the result is that FSMO is associated with TuA. It shall be understood that DM attribute store includes at least one set of elements FSMO ID Tu ID for each FSMO in the system. Element Tu ID however does not contain a valid ID unless the FSMO has been allocated to i.e. associated with a Tu.

Although DM attribute store has been described as being configured by SMT engine it shall be understood that DM attribute store can be configured using various other mechanisms. For example DM attribute store can also be configured by a system admin via a system configuration interface not shown .

According to one embodiment SMT engine updates protocol config metadata store based on metadata contained in security config metadata store and DM attribute store . Alternatively SMT engine may update protocol config metadata store independently using the same mechanism for updating DM attribute store and security config metadata store without having to rely on DM attribute store and security config metadata store . Further protocol config metadata store can be configured by a system admin.

According to one embodiment protocol config metadata store includes but not limited to one or more sets of elements. Each set includes but not limited to the elements of user name user ID Tu ID FSMO ID. In one set of element is shown user name user ID Tu ID FSMO ID . User name contains the name of a user. User ID contains the ID of a user. Tu ID contains the ID of a Tu. FSMO ID contains one or more IDs of one or more FSMO. Each set of elements associates the named identified user with the identified Tu and associates the identified Tu with the identified FSMO s .

According to one embodiment SMT engine updates protocol config metadata store by replicating information from DM attribute store and security config metadata store . For example elements of security config metadata store may be replicated to elements of protocol config metadata store . Further SMT engine may use either Tu ID or replicated Tu ID to lookup the associated FSMO ID s in DM attribute store . In this example Tu ID or replicated Tu ID matches Tu ID of DM attribute store and thus SMT engine determines that FSMO ID is associated with Tu ID or replicated Tu ID . In response to this determination SMT engine replicates FSMO ID to FSMO ID . Thus continuing on with the above example user name now contains the name of TuA admin user ID contains the user ID of TuA admin Tu ID contains TuA and FSMO ID contains FSMO ID. The result is that TuA admin is associated with TuA and can access FSMO . It shall be understood that protocol config metadata store includes at least one set of elements user name user ID Tu ID FSMO ID for each user in the system.

In one embodiment storage system includes protocol interface configured to receive one or more data access requests from one or more tenants using the Remote Procedure Call RPC protocol. Here a data access request can be a read write or replicate request. Protocol interface processes the protocol specific header of the request and forwards the request to protocol engine after removing at least some of the networking stack related information from the request. Protocol engine processes the request and forwards it to one of the protocol servers not shown implemented as part of protocol engine . The protocol server can be for example a Network File System NFS server Server Message Block SMB server Likewise Common Internet File System CIFS server virtual tape library interface VTL server and Protection Point server DDBoost or any combination thereof. The protocol server of protocol engine authenticates the data access request by validating the credentials of the user that initiated the request for example by looking up protocol config metadata store .

The protocol server of protocol engine determines whether the user is authorized to access the data by looking up protocol config metadata store to determine which FSMO s the user is authorized to access. For example the protocol server uses the specified user name to lookup the associated user ID in protocol config metadata store . As used herein a specified user name refers to the name which is provided by the user e.g. as part of a login process or as part of the request itself . The protocol server then uses the determined user ID to obtain an associated Tu ID from protocol config metadata store . The protocol server then uses the obtained Tu ID to determine one or more of the associated FSMO IDs. These associated IDs identify the FSMOs that the user is authorized to access.

By way of example the protocol server may determine that the specified user name e.g. TuA Data Access user s user name matches the user name contained in user name which is associated with the ID contained in user ID . The protocol server uses the user ID contained in user ID to obtain the Tu ID contained in the associated Tu ID . The protocol server uses the Tu ID to determine that the user is authorized to access the FSMO s identified by the ID s contained in the associated FSMO ID . In this example FSMO ID contains the FSMO ID. Thus TuA Data Access user is authorized to access FSMO .

According to one embodiment the protocol server then determines whether the FSMO for which the access is being requested is one of the authorized FSMOs. For example the protocol server requests DM to provide the FSMO ID associated with the specified FSMO name. For example DM may determine that path contains the specified path and provides the FSMO ID contained in FSMO ID to the protocol server. This FSMO ID identifies the FSMO for which the request is being made.

In one embodiment the protocol server determines that the user is authorized to access the requested object if the FSMO ID of the requested FSMO matches one of the FSMO IDs the user is authorized to access e.g. the FSMO IDs contained in FSMO ID element . In response to determining FSMO ID contains the FSMO ID of the requested FSMO the protocol server grants the access request. Otherwise the protocol server denies the request. Note that in some embodiments the protocol server may have to convert the specified FSMO name to a FSMO path for example by prepending the specified FSMO name with a predetermined path e.g. data col1 . In alternative embodiments the specified FSMO name is the same as the FSMO path supported by DM . As described above FSMO ID elements e.g. FSMO ID element contains one or more IDs identifying one or more FSMOs that the user is authorized to access. In cases where the user is associated with multiple FSMOs the requested FSMO is compared against all the FSMOs associated with the requesting user and if there is any match the data access request is authorized.

In response to determining the user is authenticated and authorized to access the data the protocol server forwards the request to file service interface . File service interface requests DM to update or fetch depending on whether the access is a write or read metadata concerning the file being accessed. DM maintains file abstraction for the underlying deduplicated segments of the files stored at storage system . DM maintains all the metadata for the files including file names file IDs and various other file attributes.

File service interface then requests content store to perform the authorized request. Content store provides a stream abstraction for the underlying deduplicated data segments. The stream abstraction provided by content store ensures segment locality in order to provide better throughput for data access. In one embodiment content store is configured to segment the files in the case of a write access into variable length segments based on a variety of rules or considerations. For example the files may be broken into segments by identifying segment boundaries using a content based technique e.g. a function is calculated at various locations of a file when the function is equal to a value or when the value is a minimum a maximum or other value relative to other function values calculated for the file a non content based technique e.g. based on size of the segment or any other appropriate technique. A segment is restricted to a minimum and or maximum length to a minimum or maximum number of segments per file or any other appropriate limitation.

Content store requests deduplication storage engine to perform the data access for example writing the deduplicated segments of the file to disk in the case of a write or reading deduplicated segments from disk in the case of a read request. Note that by natively supporting multi tenancy the present invention enables data from multiple FSMOs belonging to the same or different tenants to be deduplicated resulting in a much more efficient use of the physical storage device. For example data from FSMO belonging to tenant A may be deduplicated with data from FSMO belonging to tenant B . Thus only one copy of a data segment that is common among FSMOs and are actually stored in the physical storage device. It shall be noted that this implies security and isolation are provided logically at the FSMO level but not physically at the storage device level.

Note that some or all of the components shown as part of storage system in may be implemented in software hardware or a combination thereof. For example some or all of the shown components may be implemented in a form of executable instructions that can be stored in a machine readable storage medium which when executed loads the components into an operating system of storage system . Some or all of the components shown in may also be stored as part of a persistent storage device e.g. storage devices . For example protocol config metadata store DM attribute store and or SMT config metadata store may be stored as part of a persistent storage device and loaded into memory during operation.

Referring now to . System control interface receives one or more control access requests from one or more users using the Remote Procedure Call RPC Hypertext Transfer Protocol Secure HTTPS Representational State Transfer REST protocol or any combination thereof. Here a control access request refers to a request to perform an operation on an object. An operation includes but not limited to 1 listing the FSMOs associated with a tenant unit 2 listing deduplication statistics for the FSMOs associated with a tenant unit 3 listing the files directories that are associated with the FSMOs that are associated with a tenant unit 4 associating disassociating FSMOs with from a tenant unit 5 listing the users groups associated with a tenant unit 6 associating disassociating users groups associated with from a tenant unit 7 listing the notification groups associated with a tenant unit and 8 associating disassociating notification groups with from a tenant unit.

The definition of an object depends on the operation that is being requested. For example an object can be a 1 FSMO 2 user group where a user can be a local user e.g. user definitions stored in the storage system operating system or name service user e.g. Active Directory AD Network Information Service NIS etc. users can be classified as either management users i.e. admins who perform control management operations or as data access users i.e. users who only access data note that groups may be defined in some name service such as AD NIS wherein the same groups can be associated with a tenant unit with the roles of tenant admin tenant User if any user logs in to the system which is part of such a group that user will have the assigned tenant admin tenant user role 3 notification group which includes but not limited to a list of alert classes and severities and email addresses notification group information is looked up in order to determine where to send an alert notification when an alert is generated in the system.

In one embodiment in order to provide security and isolation the control operations which may be performed by the requesting user depends on his her role. For example while a system admin may perform all operations a tenant admin may only be authorized to perform a subset of the operations on a subset of the objects. A tenant user may be allowed to perform only a subset of the operations and or subset of the objects that are available to the tenant admin. The operations which are available to the roles are defined through the various config metadata described in further details below.

In response to a control access request system control interface requests pluggable authentication module PAM to authenticate the control access request. PAM processes the authentication request and if successful forwards the request to Role Based Access Control RBAC . RBAC determines whether the requesting user is authorized to perform the requested operation on the object based on the config metadata stored at storage system .

According to one embodiment RBAC determines the role of the requesting user by using the specified user name to lookup security config metadata store . For example if user name element contains the specified user name RBAC obtains the ID contained in the associated user ID element . Using the obtained user ID RBAC determines the associated user role which in this example is contained in user role element . If RBAC determines that the requesting user is a system admin RBAC grants the request without further processing. Otherwise RBAC determines whether the requesting tenant admin user is authorized to perform the self service control operation. Here a self service control operation refers to an operation which is being requested by a tenant admin user as opposed to an operation being requested by a system admin.

In order to determine whether a self service operation is authorized RBAC uses the user ID associated with the specified user name to lookup security config metadata store to obtain the operations that are associated with the user. Continuing on with the above example RBAC uses the obtained user ID to obtain the ID s contained the associated operation ID . The operation ID s contained in operation ID identify the operation s that the user is authorized to perform.

In order to determine whether a self service operation is authorized RBAC compares the ID of the requested operation against all the operation ID s that the user is authorized to perform. The ID of the requested operation may be included as part of the control access request. If the ID of the requested operation matches at least one of the authorized operation ID s RBAC determines that the user is authorized to perform the requested operation. After determining that the user is authorized to perform the requested operation RBAC determines whether the user is authorized to access the object on which the requested operation is to be performed.

In one embodiment in order to determine whether the user is authorized to access the requested object RBAC uses the user ID associated with the specified user name to lookup security config metadata store to obtain the Tu ID that is associated with the user. The Tu ID obtained from security config metadata store identifies the Tu that can be accessed by the associated user. RBAC uses this obtained Tu ID to access an object to Tu config metadata store corresponding to the same object type as the object on which the operation is to be performed. Each object to Tu config metadata store includes object IDs that identify the objects which can be accessed by a user who is authorized to access the associated Tu.

Storage system stores the object to Tu association in a distributed manner. By way of example if the object type is a FSMO then the object to Tu association is contained in DM attribute store . For other object types such as notification groups the object to Tu association is contained in their respective config metadata not shown in .

By way of example assume that the object is a FSMO. In this case RBAC may determine that user ID contains the ID of the requesting user and obtains the Tu ID contained the associated Tu ID element from security config metadata store . RBAC then uses the obtained Tu ID to lookup the object to Tu association in DM attribute store . RBAC may determine that Tu ID element contains the same Tu ID as the Tu ID obtained from security config metadata store . In that case RBAC obtains the FSMO IDs contained in the associated FSMO ID element . In this example FSMO ID element contains the IDs that identify all the FSMOs i.e. objects that the user may access. RBAC then compares the FSMO IDs obtained from DM attribute store against the ID of the requested FSMO object. The ID of the requested FSMO may be provided by DM as described above. Alternatively the FSMO ID of the requested object may be included as part of the user request. If the FSMO ID of the requested object matches at least one of the FSMO IDs obtained from DM attribute store then the user is authorized to access the requested object. In response to determining the user is authorized to perform the requested operation and authorized to access the object on which the requested operation is to be performed RBAC grants the control access request. Otherwise the request is denied.

Note that some or all of the components shown as part of storage system in may be implemented in software hardware or a combination thereof. For example some or all of the shown components may be implemented in a form of executable instructions that can be stored in a machine readable storage medium which when executed loads the components into an operating system of storage system . Some or all of the components shown in may also be stored as part of a persistent storage device e.g. storage devices . For example protocol config metadata store DM attribute store and or SMT config metadata store may be stored as part of a persistent storage device and loaded into memory during operation.

Referring now to . At block a storage system receives a request to create a tenant unit. For example storage system receives a request from a system admin to create TuA for tenant A. At block the storage system determines the requesting user is a system admin and grants the request by proceeding to block . For example storage system determines that the user role element e.g. user role associated with the requesting user indicates the user is a system admin. In one embodiment only the system admin is authorized to create Tus. Thus if at block the storage system determines that the user is not a system admin the request is denied and method is completed.

At block the storage system determines that the specified Tu name complies with a predetermined Tu naming convention. For example storage system determines that the specified Tu name TuA complies with a Tu naming convention that had previously been configured as part of a naming policy stored at storage system .

At block the storage system determines that a Tu with the same name does not already exist in the system. For example storage system iterates through Tu config metadata store to determine that none of the Tu name elements contain the name TuA . At block the storage system generates a Tu ID for the new Tu. For example storage system generates a UUID for the new Tu. At block the storage system atomically stores the generated Tu ID and the specified Tu name in the Tu config metadata store. For example storage system atomically stores the name TuA in Tu name and the generated UUID in Tu ID of Tu config metadata store .

Referring now to . At block a storage system receives a request to remove a Tu from the storage system. For example storage system receives a request from a system admin to remove TuA from the system. At block the storage system determines the requesting user is a system admin and grants the request by proceeding to block . For example storage system determines that the user role element e.g. user role associated with the requesting user indicates the user is a system admin. In one embodiment only the system admin is authorized to remove Tus. Thus if at block the storage system determines that the user is not a system admin the request is denied and method is completed.

At block the storage system determines that the specified Tu name complies with a predetermined Tu naming convention. For example storage system determines that specified name TuA complies with a Tu naming convention that had previously been configured as part of a naming policy stored at storage system .

At block the storage system determines that a Tu with the same name exists in the system. For example storage system iterates through Tu config metadata store to determine that at least one Tu name element contains the specified name TuA . As part of block the storage system obtains the Tu ID from the Tu ID element which is associated with the Tu name element that contains the specified Tu name. For example in response to determining Tu name contains the specified name TuA storage system obtains the ID from the associated Tu ID .

At block the storage system determines whether the specified Tu is associated with any protection storage resource or attributes. For example storage system iterates through name service config metadata store security config metadata store and DM attribute store to determine whether the Tu ID obtained at block exists in Tu ID elements and or . At block in response to determining the Tu ID obtained at block is associated with a protection storage resource or attribute the storage system denies the request to remove the Tu. For example in response to determining the obtained Tu ID exists in Tu ID and or storage system denies the request to remove the Tu.

At block in response to determining the Tu ID obtained at block is not associated with any protection storage resource or attribute the storage system atomically removes the specified Tu name and associated Tu ID from the Tu config metadata store. For example in response to determining the obtained Tu ID does not exist in Tu ID or storage system atomically removes TuA from Tu name and the ID from Tu ID .

Referring now to . At block a storage system receives a request to rename a Tu at the storage system. For example storage system receives a request from a system admin to rename TuA to TuC. At block the storage system determines the requesting user is a system admin and grants the request by proceeding to block . For example storage system determines that the user role element e.g. user role associated with the requesting user indicates the user is a system admin. In one embodiment only the system admin is authorized to rename Tus. Thus if at block the storage system determines that the user is not a system admin the request is denied and method is completed.

At block the storage system determines that the specified new Tu name complies with a predetermined Tu naming convention. For example storage system determines that the new name TuC complies with a Tu naming convention that had previously been configured as part of a naming policy stored at storage system .

At block the storage system determines that the specified current Tu name exists in the system. For example storage system iterates through Tu config metadata store to determine that at least one Tu name element contains the specified current name TuA . As part of block the storage system obtains the Tu ID from the Tu ID element which is associated with the Tu name element that contains the specified current Tu name. For example in response to determining Tu name element contains TuA storage system obtains the Tu ID contained in Tu ID element .

At block the storage system determines that a Tu with the same new Tu name does not already exist in the system. For example storage system iterates through Tu config metadata store to determine that none of the Tu name elements contain the new name TuC . At block the storage system atomically updates the Tu config metadata store with the new Tu name for the obtained Tu ID. For example storage system atomically updates Tu name with the new name TuC and Tu ID with its current ID value.

Referring now to . At block a storage system receives a request to associate disassociate a FSMO with from a Tu. For example storage system receives a request from a system admin to associate disassociate FSMO from TuA. At block the storage system determines the requesting user is a system admin and grants the request by proceeding to block . For example storage system determines that the user role element e.g. user role associated with the requesting user indicates the user is a system admin. In one embodiment only the system admin is authorized to associate disassociate a FSMO with from a Tu. Thus if at block the storage system determines that the user is not a system admin the request is denied and method is completed.

At block the storage system determines that the specified FSMO name and the specified Tu name comply with a predetermined FSMO and Tu naming convention respectively. For example storage system determines that the specified FSMO name mtree10 complies with a FSMO naming convention and the specified Tu name TuA complies with a Tu naming convention that had previously been configured as part of a naming policy stored at storage system .

In some embodiments the FSMO name specified by the system admin as part of the request to associate disassociate a FSMO is in the same format as the FSMO path required by the storage system. In other embodiments the specified FSMO name may need to be converted to an FSMO path. For example in some of the protocols supported by protocol engine the specified FSMO name is the same as the FSMO path. In other protocols the specified FSMO name must be converted to a FSMO path in order for DM to understand it as a path. In one such example the specified FSMO name must be prepended with a predetermined path e.g. data col1 in order to be consistent with the path format understood by DM . Accordingly at optional block the storage system converts the specified FSMO name to a FSMO path e.g. by prepending data col1 to the specified FSMO name.

At block the storage system determines that the specified FSMO and Tu exist in the system. For example DM may use the specified FSMO path to lookup DM config metadata store to determine whether the specified FSMO exists in the system. By way of further example SMT engine may use the specified Tu name to lookup Tu config metadata store to determine whether the specified Tu exists in the system.

At block the storage system obtains the Tu ID for the specified Tu name from the Tu config metadata store. For example SMT engine may determine that Tu name element contains the specified Tu name and obtains the Tu ID contained in the associated Tu ID element .

At block the storage system obtains the FSMO ID from the DM using the specified FSMO path. For example DM may determine that path element contains the specified path i.e. the path specified as part of the request and obtain the ID contained in the associated FSMO ID element .

Note that block is optional because the existence of the specified FSMO and Tu in the system is also verified by blocks and . In other words the fact that the FSMO ID and Tu ID can be obtained confirms the existence of the FSMO and Tu in the system. The advantage of determining the existence at block however is that it requires fewer resources. For example to determine whether the FSMO exists DM can just lookup a hash table and determine if the FSMO exists. However in order to retrieve the ID DM has to reach the leaf page of a B Tree and fetch the ID. Thus in the case where the FSMO or Tu does not exist resources can be saved by not attempting to obtain the respective IDs.

At block the storage system determines whether the request is to associate or disassociate the FSMO. At block in response to determining the request is to associate the FSMO with the Tu the storage system atomically stores the obtained Tu ID as a DM attribute for the obtained FSMO ID through the DM attribute interface. For example DM stores the FSMO ID obtained at block in FSMO ID and the Tu ID obtained at block in Tu ID . At block the storage system atomically updates the protocol config metadata store to include the FSMO ID for the TU ID. For example DM stores the FSMO ID obtained at block in FSMO ID and the Tu ID obtained at block in Tu ID . The result is that the specified FSMO is associated with the specified Tu.

At block in response to determining the request is to disassociate the FSMO with the Tu the storage system atomically removes the obtained Tu ID as a DM attribute for the obtained FSMO ID through the DM attribute interface. For example DM removes the FSMO ID obtained at block from FSMO ID and the Tu ID obtained at block from Tu ID . At block the storage system atomically updates the protocol config metadata store to remove the FSMO ID for the TU ID. For example DM removes the FSMO ID from FSMO ID . The result is that the specified FSMO is no longer associated with the specified Tu.

Referring now to . At block a storage system receives a request to associate disassociate a user with from a Tu. For example storage system receives a request from a system admin to associate disassociate a user from TuA. At block the storage system determines the requesting user is a system admin and grants the request by proceeding to block . For example storage system determines that the user role element e.g. user role associated with the requesting user indicates the user is a system admin. In one embodiment only the system admin is authorized to associate disassociate a user with from a Tu. Thus if at block the storage system determines that the user is not a system admin the request is denied and method is completed.

At block the storage system determines that the specified user name and the specified Tu name comply with a predetermined user and Tu naming convention respectively. For example storage system determines that the specified user name complies with a user naming convention and the specified Tu name TuA complies with a Tu naming convention that had previously been configured as part of a naming policy stored at storage system .

At block the storage system determines that the specified user and Tu exist in the system. For example storage system may use the specified user name to lookup security config metadata store to determine whether the specified user exists in the system. By way of further example storage system may use the specified Tu name to lookup Tu config metadata store to determine whether the specified Tu exists in the system.

At block the storage system obtains the Tu ID for the specified Tu name from the config metadata store. For example storage system may determine that Tu name element contains the Tu name specified as part of the request and obtains the Tu ID contained in the associated Tu ID element .

At block the storage system obtains a user ID for the specified user name from the security config metadata store. For example storage system may determine that user name contains the user name specified as part of the request and obtains the user ID contained in the associated user ID .

Note that block is optional because the existence of the specified user and Tu in the system is also verified by blocks and . In other words the fact that the user ID and Tu ID can be obtained confirms the existence of the user and Tu in the system. The advantage of determining the existence at block however is that it requires fewer resources. For example to determine whether the user exists storage system can simply lookup a hash table and determine if the user exists. However in order to retrieve the ID storage system has to reach the leaf page of a B Tree and fetch the ID. Thus in the case where the user or Tu does not exist resources can be saved by not attempting to obtain the respective IDs.

At block the storage system determines whether the request is to associate or disassociate the user. At block in response to determining the request is to associate the user with the Tu the storage system atomically updates the security config metadata store to include the Tu ID with the user ID. For example storage system updates security config metadata store to include the specified user name in user name the obtained user ID in user ID and the obtained Tu ID in Tu ID .

At optional block the storage system atomically updates the protocol config metadata store to include the Tu ID with the user ID. For example storage system updates protocol config metadata store to include the specified user name in user name the obtained user ID in user ID and the obtained Tu ID in Tu ID . Note here that the operations of block are performed if the user to be associated disassociated is a data access user.

At block in response to determining the request is to disassociate the user from the Tu the storage system atomically updates the security config metadata store to remove the Tu ID from the user ID. For example assuming user name contains the specified user name storage system updates security config metadata store to remove the Tu ID from Tu ID . Storage system may also optionally remove the user name from user name and user ID from user ID .

At optional block the storage system atomically updates the protocol config metadata store to remove the Tu ID from the user ID. For example assuming the user name contains the specified user name storage system updates protocol config metadata store to remove the Tu ID from Tu ID . Storage system may also optionally remove the user name from user name and the user ID from user ID . Note here that the operations of block are performed if the user to be associated disassociated is a data access user.

Referring now to . At block a storage system receives a request from a user to perform a self service operation on a Tu. At block the storage system obtains a user ID for the specified user name from the security config metadata store. For example storage system may determine that user name contains the specified user name and obtains the user ID contained in the associated user ID .

At block the storage system obtains the Tu ID s associated with the obtained user ID from the security config metadata store. For example storage system may determine that user ID contains the obtained user ID and obtains the Tu ID contained in the associated Tu ID .

At block the storage system obtains the operation ID s from the security config metadata store using the obtained user ID wherein the operation ID s obtained from the security config metadata store identifies the operation s that the specified user is authorized to perform. For example storage system may determine that user ID contains the obtained user ID and obtains the operation ID s contained in the associated operation ID . At block the storage system obtains the object ID s from the object to Tu config metadata store corresponding to the requested object type using the obtained Tu ID wherein the object ID s obtained from the corresponding object to Tu config metadata store identify the objects s that the specified user is authorized to access. For example assuming the object type is FSMO storage system may determine that Tu ID contains the Tu ID obtained at block and obtains the FSMO ID s contained in the associated FSMO ID . These FSMO ID s identify all the FSMOs i.e. objects that the user is authorized to access.

At block the storage system determines whether the operation ID of the requested operation matches any of the obtained authorized operation ID s . As part of block the storage system also determines whether the object ID of the requested object matches any of the obtained authorized object ID s .

For example storage system compares the operation ID of the requested operation against the operation ID s obtained at block . If there is at least one match storage system determines that the user is authorized to execute the requested operation. Otherwise storage system determines that the user is not authorized to execute the requested operation. By way of further example storage system also compares the ID of the requested object against the object ID s obtained at block . If there is at least one match storage system determines that the user is authorized to access the requested object. Otherwise storage system determines that the user is not authorized to access the requested object. In one embodiment the ID of the requested operation is provided as part of the request. The ID of the requested operation however can be obtained using any mechanism. In one embodiment the ID of the requested object is provided as part of the request. The ID of the requested object however can be obtained using any mechanism.

In response to determining the user is authorized to perform the requested operation and also authorized to access the object on which the operation is to be performed the storage system transitions to block and grants the request. Otherwise the storage system transitions to block and denies the request.

Referring now to . At block a storage system receives a request from a user to access statistics of a Tu. At block the storage system determines whether the requesting user is a system admin. In response to determining the user is not a system admin the storage system transitions to block . At block the storage system determines whether the tenant admin user is authorized to perform the requested operation and also authorized to access the object on which the operation is to be performed. For example block may be implemented using operations similar to those described in method .

At block in response to determining the tenant admin user is not authorized to perform the operation or not authorized to access the object on which the operation is to be performed the storage system transitions to block and denies the request. Alternatively in response to determining the tenant admin user is authorized to perform the operation and authorized to access the object on which the operation is to be performed the storage system grants the request and transitions to block .

Referring now back to block . In response to determining the user is a system admin the storage system grants the request and transitions to block . At block the storage system determines that the specified Tu name complies with a predetermined Tu naming convention. At block the storage system determines that the specified Tu exists in the system. At block the storage system obtains the Tu ID for the specified Tu name from the config metadata store. For example SMT engine may determine that Tu name element contains the specified Tu name and obtains the TU ID contained in the associated Tu ID element .

At block the storage system obtains the FSMOs that are associated with the Tu ID from the DM attribute store. For example storage system may determine that Tu ID contains the Tu ID obtained at block and obtains the FSMO ID s contained in FSMO ID . At block the storage system obtains the statistics e.g. quotas usage performance etc. associated with the FSMOs identified by the FSMO IDs obtained at block . At block the storage system provides the statistics to the requesting user for example via a graphical user interface GUI .

Referring now to . At block a storage system receives a request from a user to access data of a Tu. Here data access can be a read write or replicate operation. At block the storage system obtains a user ID for the specified user name from the protocol config metadata store. For example storage system may determine that user name contains the specified user name and obtains the user ID contained in the associated user ID .

At block the storage system obtains the Tu ID s associated with the obtained user ID from the protocol config metadata store. For example storage system may determine that user ID contains the obtained user ID and obtains the Tu ID contained in the associated Tu ID .

At block the storage system obtains the FSMO ID from the DM using the specified FSMO path. For example DM may determine that path element contains the specified path i.e. the path specified as part of the request and obtain the ID contained in the associated FSMO ID element .

At block the storage system determines whether the protocol config metadata store indicate that the FSMO IDs associated with the Tu IDs that are associated with the user ID match the FSMO ID obtained from the DM. For example DM may determine that path contains the specified FSMO path and obtains the ID contained in the associated FSMO ID element . Assume that user ID element contains the user ID obtained at block . In such an example storage system compares the ID contained in FSMO ID against all the ID contained in FSMO ID . If there is at least one match storage system determines that protocol config metadata store indicates the user is authorized to access data from the specified FSMO and transitions to block to allow the access. Otherwise the storage system transitions to block and denies the request to access data from the specified FSMO.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as those set forth in the claims below refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the invention also relate to an apparatus for performing the operations herein. Such a computer program is stored in a non transitory computer readable medium. A machine readable medium includes any mechanism for storing information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices .

The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software e.g. embodied on a non transitory computer readable medium or a combination of both. Although the processes or methods are described above in terms of some sequential operations it should be appreciated that some of the operations described may be performed in a different order. Moreover some operations may be performed in parallel rather than sequentially.

Embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

