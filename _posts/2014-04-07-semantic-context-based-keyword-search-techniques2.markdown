---

title: Semantic context based keyword search techniques
abstract: Provided are semantic context based keyword search techniques. A query with one or more keywords, one or more relevant words, and one or more selected services is received. A general relevance indicator for services in a category is calculated based on keyword relevance indicators of the one or more keywords in the query for each service among services in the category and relevant word relevance indicators of the one or more relevant words in the query for the services in the category. The services in the category are ranked based on the general relevance indicator for each service. In response to determining that at least one of the selected services is not ranked high with reference to the ranked services in the category, at least one of: one or more additional keywords, one or more additional relevant words, and one or more additional services to provide as recommendations are identified.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09589050&OS=09589050&RS=09589050
owner: International Business Machines Corporation
number: 09589050
owner_city: Armonk
owner_country: US
publication_date: 20140407
---
The amount of digital content available on the internet is enormous and it increases at a very fast pace. To be efficient and productive most web users rely on web search engines to search for useful web pages through keyword search.

SOA and Cloud Computing rely on the underlying technologies to expose computing resources applications and data sources as services or utilities. Like web pages the number of services exposed to the service users can be very large.

To facilitate the integration of computing systems to access data stored in different organization databases and other information silos through the internet and to provide richer content to end users new web technologies have been introduced such as ones developed for cloud computing e.g. Software as a Service SaaS and Data as a Service DaaS . Some of these technologies are RESTful Representational State Transfer web services and web services based on Simple Object Access Protocol SOAP and Web Service Definition Language WSDL .

For example a company may create a marketplace web site for different vendors to sell their products. Examples of web services include the web site s flexible fulfillment web service and payments web service which are utilized to integrate the marketplace web site with the information systems of those vendors.

To facilitate publishing and searching web services a Universal Description Discovery and Integration UDDI standard was developed for SOAP based web services. The UDDI standard defines how to create a web service UDDI registry to enable web service providers to publish their web services and to enable web service consumers to search and use these published web services.

Ontology is used to describe knowledge as a set of concepts and their relationships in a knowledge domain. In ontology reasoning may be used with formal logic rules to derive more knowledge from existing knowledge. To facilitate the description of concepts their properties and relationships shared vocabulary and taxonomies are defined in a specific ontology domain. Web Ontology Language OWL as well as its newer version OWL 2 is an ontology standard which was originally developed in academic research to present data on the web in a machine understandable format.

A non UDDI based web service registry may offer web service governance features and semantic web technologies. Such web service registries or repositories store additional web services related metadata to govern the life cycles of web services. OWL may be used to organize the web service related metadata in such a web service registry.

In conventional systems keyword search is used by a web service consumer to find web services in a web service registry. The keywords of a web service can be manually specified by a web service provider. An automatic keyword generation process may be used to generate keywords from web service metadata. The combination of the manual approach and the automatic approach such as letting the provider verify or modify the generated keywords may also be used.

Existing web service registries provide query Application Programming Interfaces APIs and or Graphical User Interfaces GUIs to enable web service consumers to search for the web services published in the registry. With these query interfaces users provide keywords strings or other data in specific web service metadata fields to conduct the search and manually analyze the search result. These query APIs assume that the users have sufficient knowledge about what and how service metadata are stored in the registry and or the exact keywords used by the services to specify metadata fields in a query and to carry out keyword searches. Also the keywords may be ambiguous and service providers may use different naming conventions.

For example a UDDI client may query a UDDI registry to find web services by providing the partial or full name of the web service the business entity to which it belongs and the category into which it falls. It also allows the user to search web services with composite queries. The search result of such a query may be the intersection or union of the collection of the search results of the simple queries of which the composite query is made.

An existing solution evaluates the keywords provided by user and ranks them with respect to the number of their appearances in the relevant categories.

Provided is a method for semantic context based keyword search techniques. The method comprises receiving with a processor of a computer a query with one or more keywords one or more relevant words and one or more selected services calculating a general relevance indicator for each service among services in a category based on keyword relevance indicators of the one or more keywords in the query for the services in the category and based on relevant word relevance indicators of the one or more relevant words in the query for the services in the category ranking the services in the category based on the general relevance indicator for each of the services and in response to determining that at least one of the selected services is not ranked high with reference to the ranked services in the category identifying at least one of one or more additional keywords one or more additional relevant words and one or more additional services to provide as recommendations.

Provided is a computer system for semantic context based keyword search techniques. The computer system comprises one or more processors one or more computer readable memories and one or more computer readable tangible storage devices and program instructions stored on at least one of the one or more computer readable tangible storage devices for execution by at least one of the one or more processors via at least one of the one or more memories to perform receiving a query with one or more keywords one or more relevant words and one or more selected services calculating a general relevance indicator for each service among services in a category based on keyword relevance indicators of the one or more keywords in the query for the services in the category and based on relevant word relevance indicators of the one or more relevant words in the query for the services in the category ranking the services in the category based on the general relevance indicator for each of the services and in response to determining that at least one of the selected services is not ranked high with reference to the ranked services in the category identifying at least one of one or more additional keywords one or more additional relevant words and one or more additional services to provide as recommendations.

Provided is a computer program product for semantic context based keyword search techniques. The computer program product comprising a computer readable storage medium having program code embodied therewith the program code executable by at least one processor to perform receiving by the at least one processor a query with one or more keywords one or more relevant words and one or more selected services calculating by the at least one processor a general relevance indicator for each service among services in a category based on keyword relevance indicators of the one or more keywords in the query for the services in the category and based on relevant word relevance indicators of the one or more relevant words in the query for the services in the category ranking by the at least one processor the services in the category based on the general relevance indicator for each of the services and in response to determining that at least one of the selected services is not ranked high with reference to the ranked services in the category identifying by the at least one processor at least one of one or more additional keywords one or more additional relevant words and one or more additional services to provide as recommendations.

The descriptions of the various embodiments of the present invention have been presented for purposes of illustration but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to best explain the principles of the embodiments the practical application or technical improvement over technologies found in the marketplace or to enable others of ordinary skill in the art to understand the embodiments disclosed herein.

Embodiments provide a technique of discovering services such as web services. In embodiments services mentioned herein refer to any services implemented on an information system and that can be accessed from telecommunication networks. Services include but are not limited to web services.

A keyword is used in the domain of information retrieval. A keyword may be used to identify the key message or key concept of a document. However as part of a natural language the meaning of a keyword may be ambiguous. Its meaning may depend on the context in which the keyword appears. With embodiments relevant words are employed to capture the context of these keywords. This is similar to ontology where the context of a concept may be described as the properties of the concept or its relationship to other concepts.

In certain embodiments the service client may interact with the service registry server through one or more user interfaces provided by the semantic word matching system .

The semantic word matching system provides an integrated and iterative process to generate and identify more accurate or descriptive keywords and more accurate or descriptive relevant words found in the context of a service or services published in a service registry and the identified words are used to improve a query. For example the semantic word matching system identifies inaccurate keywords and inaccurate relevant words and provides more accurate keywords and more accurate relevant words. The semantic word matching system not only distinguishes the keywords that identify a service and the relevant words that defines the context of a service but also provides a technique that combines a service keyword search i.e. keywords provided in a search for the service and a service context relevant word search in an integrated manner.

The semantic word matching system has four components a keyword and relevant word database a keyword and relevant word preprocessor a semantic keyword and relevant word matching engine matching engine and a thesaurus and ontology database . In certain embodiments there may be a separate thesaurus database and a separate ontology database.

The semantic word matching system utilizes the iterative keyword and context based process to discover for example web services available in service oriented information systems and networks. In alternative embodiments the semantic word matching system may discover items other than web services.

The service registry enables service providers to publish services and enables service consumers to search and use these published services. The service registry stores the information of the published services.

The matching engine provides a mechanism to integrate keyword search and context matching into a mutual correction and self correction search process by allowing users to provide feedback. The mutual correction correction by a user at the service client and by the semantic word matching system is performed with an iterative process.

The keyword and relevant word database holds the information of the keywords and relevant words of services provided by service providers or generated from service metadata. The information in the keyword and relevant word database is retrieved or derived from the service information stored in the service registry .

In certain embodiments the relationship information between a word and a query or service is defined as a general relevance indicator which is a weight of a word associated with a query and referred to herein as a general word relevance indicator or which is a weight of a query associated with a service and referred to herein as a general query relevance indicator .

The keyword and relevant word preprocessor is employed to verify that the keywords and relevant words are valid. The thesaurus and ontology database is employed in the process for identifying keyword synonyms. With reference to synonyms the meaning of words depends on the context in which they are used. For example the terminologies used by the service provider may be different from the terminologies used by the service client .

Services may be grouped into classifications. Classifications may be created by standard bodies and may have clearly defined and well understood names for subcategories. These classifications may be plugged into a service registry if they are not a built in feature. As a categorization mechanism classification and its relationship with services keywords and relevant words may be integrated within the keyword search technique.

The communication between the service client and the semantic word matching system is an iterative process. The service client and the semantic word matching system pass keyword and relevant words back and forth one or more times to identify the more accurate or descriptive keywords and relevant words used in the context of the services that a user at the service client is trying to identify.

When the service client communicates with the semantic word matching system the keyword and relevant word preprocessor receives a query first from the service client and examines the keywords and relevant words to make sure the keywords are valid e.g. no spelling errors no stop words correctly spelled e.g. based on checking a dictionary . If the keyword and relevant word preprocessor identifies an error in the keywords the keyword and relevant word preprocessor informs the matching engine and the matching engine forwards the information to the service client in a message sent back to the service client .

The matching engine is the component implementing the matching techniques. The matching engine receives the preprocessed query from the keyword and relevant word preprocessor retrieves keywords and relevant words of services from the keyword and relevant word database fetches synonyms and related words of keywords and relevant words from the thesaurus and ontology database compares the keywords and relevant words in the query and the ones in the services and generates an updated version of a keyword list and a relevant word list. The matching engine renders the modified keyword list and relevant word list back to the service client for further feedback and adjustment.

The keyword and relevant word database is the data store in which the keywords and relevant words for each service are stored. The semantic word matching system calculates the general relevance indicator of every keyword for each category and stores these general relevance indicator values in the keyword and relevant word database .

The thesaurus and ontology database has a thesaurus that is utilized by the matching engine to find synonyms between two sets of words. In certain embodiments two keywords or relevant words are synonyms if they have a same or a very similar meaning. The thesaurus and ontology database also has an ontology database that contains the information about concepts i.e. objects and the categories to which they belong or classes defined in an object oriented environment their properties and their relationships. Keywords are mapped to the name of concepts and the relevant words are generated from identifying the names of the concept s properties and relationships.

The semantic word matching system enables service consumers to identify services published in a service registry by specifying or selecting a number of keywords and a number of relevant words. In particular the matching engine identifies the more accurate or descriptive keywords and the relevant words that the best fit services have e.g. for an initial or modified set of keywords and or relevant words provided by the service user . The synonym issue and ambiguity of the meaning of words are addressed with the thesaurus and ontology database . The semantic word matching system allows service users to retrieve a list of candidate services at the end of process.

In certain embodiments the semantic word matching system provides assistance on keyword and context based relevant word selection for both service consumers and providers. The semantic word matching system facilitates the service searching process by ranking the services and guiding service users to make correct keyword and relevant word selections.

With the semantic word matching system intelligence is built in to utilize not only the relationships between queried keywords and service key words but also the relationship of these keywords and the relevant words. It gives the user recommendations i.e. suggestions and analyzes the user s feedback to do a more effective search.

The semantic word matching system provides a process to collect and utilize the relationships between service keywords and the relevant words in the context of these keywords. The same concept may be applied to other context related service metadata in a service registry as well.

More specifically by comparing the keywords supplied by a user in a query from the service client and the relevant words associated with these keywords the matching engine may quickly identify the more accurate or descriptive keywords and the related services with additional help from the thesaurus and ontology database and the feedback from the user. The user s feedback includes providing selecting keywords and relevant words about the service iteratively.

It is not efficient or effective to require users to give detailed information about the services they seek in a service registry if there are millions or more services published in the registry. Instead it may be more practical to allow the users to give a number of keywords and relevant words and then make refined selections based on recommended keywords and relevant words provided by the matching engine . That is with the semantic word matching system it is the task of the matching engine to help identify the best candidate services for the users.

The semantic word matching system enable users to search services published in a registry in a manner similar to how a web search engine may be used to search web pages with limited or no prior knowledge about the registry structure and the exact details of the services published in the registry.

By the same token the keyword and context information improvement techniques employed by the semantic word matching system can not only help service consumers to search services but also help service providers to document and classify their services.

A keyword of a query or a service is one of the words to define or describe the query or service. A relevant word of a query or a service is one of the related words used to describe the details or the context of the query or the service. Although keywords may be included as part of relevant words for a query or service in certain embodiments keywords and relevant words of a query or a service are mutually exclusive.

In certain embodiments when a service is published in the service registry the service provider provides the keywords and relevant words of the service. In addition existing solutions may be used to facilitate the creation of these keywords and relevant words.

Typically a user searches for services in a particular domain or category. Service providers may specify the categories to which their services belong in order to facilitate the user s search. For instance if an auto insurance quote service is published in the registry the service provider may specify that this service belongs to category Insurance Agencies Brokerages in the North American Industry Classification System. This category is a subcategory of category Insurance Carriers and Related Activities which in turn is a subcategory of category Finance and Insurance . Embodiments describe a technique to use keywords and relevant words to search services within a domain or category.

A general relevance indicator may be described as a weight to measure how relevant two documents are. Each of the documents contains a set of keywords and a set of relevant words. In certain embodiments a document may be a single keyword or multiple keywords with a number of relevant words a service or a query.

In particular a query with a list of keywords and a list of relevant words may be viewed as a document. A service containing a collection of keywords and relevant words may also be viewed as a document. Different schemes to measure similarity of documents based on the weight of their keywords have been developed in the information retrieval research such as cosine similarity Euclidean distance Dice coefficient and Jaccard index. Some of these schemes may be employed to measure the similarity between a query and a service. In conventional information retrieval systems the weights of the keywords used in some of these schemes are computed using a Term Frequency Inverse Document Frequency TF IDF based technique.

The relevance indicator RI is a measure similar to TF IDF which is a weighting scheme used to evaluate how important a term is to a document in a collection of documents.

Keyword Frequency KWF of a keyword associated with a service is similar to Term Frequency TF . KWF measures how often a keyword appears in a service. In certain embodiment KWF is defined as the reciprocal of all the keywords the service has if the server has this keyword. Equation 1 specifies KWF 

In Equation 1 KWFis the keyword frequency for keyword i in service j Mis the total number of keywords in the service j kis 1 if service j in the category has keyword i and kis 0 if service j in the category does not have keyword i.

The uniqueness measure of a keyword in a collection of services like Inverse Document Frequency IDF is called Keyword Inverse Service Frequency KISF . In certain embodiments KISF is defined as the log of the quotient of total number of services and the number of services containing the keyword published in a certain category in the service registry. Equation 2 specifies KISF 

In Equation 2 KISFis the inverse service frequency for keyword i in a specific category of a classification system kis 1 if service j has keyword i and kis 0 if service j does not have keyword i and N is the total number of services registered in the category.

KRIis the keyword relevance indicator of keyword i associated with a service. Equation 3 specifies KRI KRI KWF KISF

On the same token Relevant Word Frequency RWF of a relevant word i associated with a service can be defined as the following Equation 4 

In Equation 4 ris 1 if service j in the category has relevant word i and ris 0 if service j in the category does not have relevant word i. Also Mis the total number of relevant words in the service j.

Relevant word Inverse Service Frequency RISF the uniqueness measure of a keyword in a collection of services is defined as the following Equation 5 

In Equation 5 RISFis the inverse service frequency for relevant word i in a specific category of a classification system ris 1 if service j has relevant word i and ris 0 if service j does not have relevant word i and N is the total number of services registered in the category.

RRIis the relevant word relevance indicator of relevant word i associated with a category. Equation 6 specifies RRI RRI RWF RISF

GRIis the query general relevance indicator of a query associated with a service in a category to measure the similarity between the query and the service. GRIof a query containing a plurality of keywords and relevant words is an aggregation of the keyword relevance indicators and relevant words associated with this service. Since relevant words may be less important than keywords for query and service matching in certain embodiments a relevant factor e.g. a weight is introduced. The relevant factor is a real number between 0 and 1. In certain embodiments similar to the cosine similarity used with the vector space model developed in information retrieval research GRIis the cosine of the angle between two multidimensional vectors representing the query and the service. Equation 7 specifies GRI 

In Equation 7 KRIis the keyword relevance indicator of keyword i associated with the service Mis the total number of keywords in the query RRIis the relevant word relevance indicator of relevant word i associated with the service Mr is the total number of relevant words in the query is the relevant factor for relevant word i and has a value between 0 and 1 .

Since Equation 7 based on a vector space model may generate overly small GRIvalues for large services with a large number of keywords and relevant words the value of GRIis adjusted in certain embodiments if the number of keywords and relevant words of the services under comparison are significantly different.

A simple case illustrating the above concept is shown in . A query looking for car insurance quote has three keywords Car Insurance and Quote. The query has five relevant words Maker Model Year Address and Driver. By the same token two services published in a service registry have 3 keywords each. The first service auto insurance quote service has nine relevant words. The second service auto repair quote service has eight relevant words.

The thesaurus and ontology database may identify that Car and Auto are synonyms. So the keyword Car in the query is replaced with Auto before the calculation of GRI for these two services.

For simplicity assume that Keyword Inverse Service Frequency for each keyword has the same value 10 and that Relevant word Inverse Service Frequency for relevant words also has the same value 10. Assume the relevant factor a for each relevant word has the same value 0.5.

The three keywords of query for car insurance quote match all three of the keywords of auto insurance quote service and match two of the three keywords of auto repair quote service . The five relevant words of the query for the car insurance quote match four relevant words of a total of nine relevant words of auto insurance quote service and match five relevant words of a total of eight relevant words of auto repair quote service . The general relevance indicators of the query associated with each service are 

The semantic word matching system processes a query received from the service client . The matching process is an iterative process between the service client and the semantic word matching system . The semantic word matching system returns the updated keyword and relevant words to the service client at the end of each iteration. The service client may then provide feedback by selecting displayed keywords and relevant words and the selected words are used in the next iteration. The query improvement process employed by the semantic word matching system may iterate multiple times before the service client is satisfied with the query result or quits the process.

Processing begins at block with the semantic word matching system receiving a query with one or more keywords zero or more relevant words and zero or more selected services from the service client . The keywords in the query may be referred to as query keywords while the relevant words in a query may be referred to as query relevant words.

In certain embodiments in the first iteration the query generated by the service client may include the keywords and may or may not include the relevant words specified by the service client and may not include any selected services. However at the end of the first iteration and each subsequent iteration the semantic word matching system may recommend additional keywords and relevant words and the service client may select or confirm one or more of the keywords and relevant words to be included in the query as keywords and relevant words. The service client may select one or more services returned by semantic word matching system as the most relevant services. In certain embodiments each query in subsequent iterations contains the keywords and the relevant words specified or confirmed by the service client .

In certain embodiments if the service client changes one or more keywords in the query by itself i.e. not the recommended changes suggested by the semantic word matching system the query may be treated as a new query by the semantic word matching system .

In block the keyword and relevant word preprocessor receives the query and preprocesses the keywords and relevant words. If the keyword and relevant word preprocessor identifies a spelling error or a stop word the keyword and relevant word preprocessor informs the matching engine to ignore the wrongly spelt word or stop word and to forward the information to the service client to correct the query.

In block the matching engine calculates the general relevance indicator of the query GRI with respect to each of the services in a specific search domain or category. In certain embodiments the hierarchy of search domains and categories are predefined. The granularity of the search domains may be predefined or may be adjusted based on the average value of the general relevance indicator of the query GRI within a domain and its sub domains. In this case the hierarchy of the search domains is traversed to locate the most relevant and specific domain for the query. The general relevance indicator of a query for a service describes how closely the service is related to a query e.g. how similar they are in term of the keywords and relevant words they have in common . In block the matching engine also ranks the services based on their calculated general relevance indicators.

In block the matching engine determines whether each selected service in the query ranked higher than the ranked services in the specific search domain or category others based on the ranking in block . If so the processing continues to block otherwise processing continues to block . In certain embodiments if the query has no selected service and it is the first iteration of the query processing the processing continues to block . In certain embodiments if the query has no selected service and it is not the first iteration of the querying process it indicates that the service client did not select any service in the previous re turned service result and the processing continues to block .

In block the matching engine sends the unchanged keywords and relevant words as well as the newly ranked service list to the service client to enable the service client to select or verify new services. From block processing continues to block . In block the matching engine determines whether the user has provided input e.g. new keywords relevant words and or services or selections from the returned keywords relevant words and or services . If so processing continues to block otherwise processing is done.

If there are one or more selected services that are not top ranked processing continues block . This is caused by the mismatch between the keywords and relevant words specified by the service client and the keywords and relevant words associated with the related services. In block the matching engine identifies synonyms of keywords and relevant words that may be used to substitute corresponding keywords and relevant words in the query. In particular the matching engine identifies keywords and relevant words not associated with non top ranked selected services to match ones associated with non top ranked services that may be used to replace the keywords and relevant words in the query. A non top ranked selected service may be described as a selected service whose query general relevance indicator value is not among the highest in block .

To identify the synonyms the matching engine fetches the keywords belonging to the non top ranked selected services in the query from the keyword and relevant word database . Then the matching engine locates the service keywords associated with the non top ranked services but not in the query and vice versa i.e. locates the keywords in the query but not in the non top ranked services . The matching engine also fetches synonyms from the thesaurus and ontology database and identifies any synonyms between these two groups of keywords i.e. keywords and service keywords . If a pair of synonyms are identified one from each group i.e. one from the keywords and one from the service keywords the recommendation is created to suggest to that the service client replace i.e. substitute the keyword in the query with the synonym belonging to the non top ranked selected service. For example assume that the non top ranked selected service is auto insurance quote service . The keyword auto is a keyword of auto insurance quote service but not in the query for car insurance quote . On the other hand the keyword car is in query Q but a keyword auto insurance quote service . The thesaurus and ontology database indicates that auto and car are synonyms. Therefore a recommendation is created to suggest that the service client substitute the keyword car in the query with the keyword auto .

In block the matching engine identifies new keywords and relevant words in the non top ranked services that may be added to the query. In particular for the keywords and relevant words in the non top ranked service if they are not in the query and no synonyms for them are found at block a recommendation is created to suggest that the service client add these new keywords and relevant words in the query. In certain embodiments the recommendation is provided from block when the service mismatch occurs between the choices of the service client and the ranking of the matching engine . As an example the keyword premium may be identified as such a relevant word and a recommendation is created for the service client to add the relevant word premium into the query.

In block the matching engine identifies new relevant words that may be added to the query. In particular for each keyword matching engine retrieves the names of properties and the name of relationships of the concept identified by the keyword in thesaurus and ontology database as candidate relevant words. If these candidate relevant words are not in the query and no synonyms for them are found from thesaurus and ontology database a recommendation is created to suggest that the service client add these new relevant words in the query. In certain embodiments the recommendation is provided from block when the service mismatch occurs between the choices of the service client and the ranking of the matching engine . As an example matching engine uses the keyword insurance to identify policy as a relevant word candidate based on the ontology information of concept insurance stored in thesaurus and ontology database . A recommendation is created for the service client to add the relevant word policy into the query for car insurance quote .

In block the matching engine identifies the keywords and relevant words that are candidates to be removed from the query. In particular the matching engine examines the keywords and relevant words in the query and locates ones not associated with the non top ranked services and associated with top ranked but not selected by the service client services. If no synonyms in the non top ranked services are found for these keywords and relevant words at block a recommendation is created to suggest that the service client remove these keywords and relevant words in the query.

From block processing continues to block . In block the matching engine provides the keyword and relevant word change recommendations and the ranked service list to the service client e.g. via the user interface . The service client may then provide feedback block by selecting keywords and relevant words to be used in the next iteration of query. Service client also selects the best fit services in the ranked service list as feedback.

Embodiments provide effective search and retrieval of relevant entries in a service repository given a user query consisting of one or more keywords and relevant words. Embodiments take into consideration the synonyms of words and association of words represented by ontology relationships among concept words.

With embodiments users do not need to have detailed knowledge about what and how service metadata are stored in the service registry and or the exact keywords or relevant words used by the services in the first place to specify keywords and relevant words to carry out effective searches.

Embodiments of the invention relate to semantic based keyword and ontology search for distributed computing systems and network environments and more specifically for any network based services.

Embodiments are provided for generating recommendations for service query enhancements and query result ranking improvements. A service query with keywords and relevant words is received in an iterative process. In response to calculating the ranks of queried services a query general relevance indicator of the query is evaluated using individual queried services using keyword and relevant word general relevance indicators and the ranked query results are provided for use in selecting new keywords and relevant words to be submitted with the query in the next iteration.

Certain embodiments provide a technique for utilizing an iterative context based search according to the mutual refinements of both keyword and ontology based semantic context for a service by responsive to receiving a search query from a user with keywords for a service identifying a semantic context using relevant words for the search query searching for services according to the keywords and context assigning for each service Si a ranking called general relevancy indicator Ri iteratively identifying new keywords according to the context and refining the context according to the new keywords as well as adjusting Ri based on an applied analytical analysis and presenting a service Si with a higher ranking Ri before a service Sj with a lower ranking Rj.

With embodiments the service is a network based service published with other services in the form of Software as a Service SaaS Data As a Service Daas Representational State Transfer Restful Web Services Simple Object Access Protocol SOAP based Web Services and etc.

With embodiments the semantic context is based on ontology utilizing a number of relevant words selected from a group consisting of a thesaurus and an ontology database.

With embodiments a user interface UI is provided to allow a user at the service client select and adjust keywords relevant words and services to refine the search query.

Embodiments iteratively improve the keywords and relevant words of a service query. The keywords present the meaning and purpose of the query. The relevant words present the semantic context of the query. The combination of the keywords and relevant words helps describe queries and the corresponding services in an unambiguous way. Embodiments utilize both the feedback from the user who submits the query and the thesaurus and ontology database to refine the query in a mutual correction process. Instead of existing approaches where the service consumer has to figure out the exact matching keywords to find the desired services embodiments allows the user to locate the desired services published in a service registry quickly by identifying better keywords and relevant words intelligently. The relationships among keywords relevant words queries and services are measured by relevance indicator and the general relevance indicator which are weights indicating the similarity between these artifacts. The keyword search is integrated with the semantic context search into a mutual correction and self adjusting search process.

It is understood in advance that although this disclosure includes a detailed description on cloud computing implementation of the teachings recited herein are not limited to a cloud computing environment. Rather embodiments of the present invention are capable of being implemented in conjunction with any other type of computing environment now known or later developed.

Cloud computing is a model of service delivery for enabling convenient on demand network access to a shared pool of configurable computing resources e.g. networks network bandwidth servers processing memory storage applications virtual machines and services that can be rapidly provisioned and released with minimal management effort or interaction with a provider of the service. This cloud model may include at least five characteristics at least three service models and at least four deployment models.

On demand self service a cloud consumer can unilaterally provision computing capabilities such as server time and network storage as needed automatically without requiring human interaction with the service s provider.

Broad network access capabilities are available over a network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms e.g. mobile phones laptops and PDAs .

Resource pooling the provider s computing resources are pooled to serve multiple consumers using a multi tenant model with different physical and virtual resources dynamically assigned and reassigned according to demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction e.g. country state or datacenter .

Rapid elasticity capabilities can be rapidly and elastically provisioned in some cases automatically to quickly scale out and rapidly released to quickly scale in. To the consumer the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.

Measured service cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service e.g. storage processing bandwidth and active user accounts . Resource usage can be monitored controlled and reported providing transparency for both the provider and consumer of the utilized service.

Software as a Service SaaS the capability provided to the consumer is to use the provider s applications running on a cloud infrastructure. The applications are accessible from various client devices through a thin client interface such as a web browser e.g. web based email . The consumer does not manage or control the underlying cloud infrastructure including network servers operating systems storage or even individual application capabilities with the possible exception of limited user specific application configuration settings.

Platform as a Service PaaS the capability provided to the consumer is to deploy onto the cloud infrastructure consumer created or acquired applications created using programming languages and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including networks servers operating systems or storage but has control over the deployed applications and possibly application hosting environment configurations.

Infrastructure as a Service IaaS the capability provided to the consumer is to provision processing storage networks and other fundamental computing resources where the consumer is able to deploy and run arbitrary software which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems storage deployed applications and possibly limited control of select networking components e.g. host firewalls .

Private cloud the cloud infrastructure is operated solely for an organization. It may be managed by the organization or a third party and may exist on premises or off premises.

Community cloud the cloud infrastructure is shared by several organizations and supports a specific community that has shared concerns e.g. mission security requirements policy and compliance considerations . It may be managed by the organizations or a third party and may exist on premises or off premises.

Public cloud the cloud infrastructure is made available to the general public or a large industry group and is owned by an organization selling cloud services.

Hybrid cloud the cloud infrastructure is a composition of two or more clouds private community or public that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability e.g. cloud bursting for load balancing between clouds .

A cloud computing environment is service oriented with a focus on statelessness low coupling modularity and semantic interoperability. At the heart of cloud computing is an infrastructure comprising a network of interconnected nodes.

Referring now to a schematic of an example of a cloud computing node is shown. Cloud computing node is only one example of a suitable cloud computing node and is not intended to suggest any limitation as to the scope of use or functionality of embodiments of the invention described herein. Regardless cloud computing node is capable of being implemented and or performing any of the functionality set forth hereinabove.

In cloud computing node there is a computer system server which is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with computer system server include but are not limited to personal computer systems server computer systems thin clients thick clients handheld or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputer systems mainframe computer systems and distributed cloud computing environments that include any of the above systems or devices and the like.

Computer system server may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types. Computer system server may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

As shown in computer system server in cloud computing node is shown in the form of a general purpose computing device. The components of computer system server may include but are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to processor .

Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus.

Computer system server typically includes a variety of computer system readable media. Such media may be any available media that is accessible by computer system server and it includes both volatile and non volatile media removable and non removable media.

System memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . Computer system server may further include other removable non removable volatile non volatile computer system storage media. By way of example only storage system can be provided for reading from and writing to a non removable non volatile magnetic media not shown and typically called a hard drive . Although not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to bus by one or more data media interfaces. As will be further depicted and described below memory may include at least one program product having a set e.g. at least one of program modules that are configured to carry out the functions of embodiments of the invention.

Program utility having a set at least one of program modules may be stored in memory by way of example and not limitation as well as an operating system one or more application programs other program modules and program data. Each of the operating system one or more application programs other program modules and program data or some combination thereof may include an implementation of a networking environment. Program modules generally carry out the functions and or methodologies of embodiments of the invention as described herein.

Computer system server may also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with computer system server and or any devices e.g. network card modem etc. that enable computer system server to communicate with one or more other computing devices. Such communication can occur via Input Output I O interfaces . Still yet computer system server can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted network adapter communicates with the other components of computer system server via bus . It should be understood that although not shown other hardware and or software components could be used in conjunction with computer system server . Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems etc.

Referring now to illustrative cloud computing environment is depicted. As shown cloud computing environment comprises one or more cloud computing nodes with which local computing devices used by cloud consumers such as for example personal digital assistant PDA or cellular telephone A desktop computer B laptop computer C and or automobile computer system N may communicate. Nodes may communicate with one another. They may be grouped not shown physically or virtually in one or more networks such as Private Community Public or Hybrid clouds as described hereinabove or a combination thereof. This allows cloud computing environment to offer infrastructure platforms and or software as services for which a cloud consumer does not need to maintain resources on a local computing device. It is understood that the types of computing devices A N shown in are intended to be illustrative only and that computing nodes and cloud computing environment can communicate with any type of computerized device over any type of network and or network addressable connection e.g. using a web browser .

Referring now to a set of functional abstraction layers provided by cloud computing environment is shown. It should be understood in advance that the components layers and functions shown in are intended to be illustrative only and embodiments of the invention are not limited thereto. As depicted the following layers and corresponding functions are provided 

Hardware and software layer includes hardware and software components. Examples of hardware components include mainframes in one example IBM zSeries systems RISC Reduced Instruction Set Computer architecture based servers in one example IBM pSeries systems IBM xSeries systems IBM BladeCenter systems storage devices networks and networking components. Examples of software components include network application server software in one example IBM WebSphere application server software and database software in one example IBM DB2 database software. IBM zSeries pSeries xSeries BladeCenter WebSphere and DB2 are trademarks of International Business Machines Corporation registered in many jurisdictions worldwide .

Virtualization layer provides an abstraction layer from which the following examples of virtual entities may be provided virtual servers virtual storage virtual networks including virtual private networks virtual applications and operating systems and virtual clients.

In one example management layer may provide the functions described below. Resource provisioning provides dynamic procurement of computing resources and other resources that are utilized to perform tasks within the cloud computing environment. Metering and Pricing provide cost tracking as resources are utilized within the cloud computing environment and billing or invoicing for consumption of these resources. In one example these resources may comprise application software licenses. Security provides identity verification for cloud consumers and tasks as well as protection for data and other resources. User portal provides access to the cloud computing environment for consumers and system administrators. Service level management provides cloud computing resource allocation and management such that required service levels are met. Service Level Agreement SLA planning and fulfillment provide pre arrangement for and procurement of cloud computing resources for which a future requirement is anticipated in accordance with an SLA.

Workloads layer provides examples of functionality for which the cloud computing environment may be utilized. Examples of workloads and functions which may be provided from this layer include mapping and navigation software development and lifecycle management virtual classroom education delivery data analytics processing transaction processing and query processing.

Thus in certain embodiments software or a program implementing query processing in accordance with embodiments described herein is provided as a service in a cloud environment.

In certain embodiments the service client and or service registry server has the architecture of cloud computer node In certain embodiments the service client and or service registry server is part of a cloud environment. In certain alternative embodiments the service client and or service registry server is not part of a cloud environment.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

