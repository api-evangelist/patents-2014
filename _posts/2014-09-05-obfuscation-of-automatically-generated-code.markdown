---

title: Obfuscation of automatically generated code
abstract: A method is provided for obfuscating code generated from a block diagram model in a graphical programming environment. The obfuscation may be removed through the use of a password. Incorporating the obfuscated code in a block diagram allows for code to be generated from the block diagram incorporating the obfuscated code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09183360&OS=09183360&RS=09183360
owner: The MathWorks, Inc.
number: 09183360
owner_city: Natick
owner_country: US
publication_date: 20140905
---
The present application is a continuation of U.S. application Ser. No. 12 732 551 filed Mar. 26 2010 which is a continuation of U.S. application Ser. No. 11 038 608 filed Jan. 18 2005 now U.S. Pat. No. 7 689 969 entitled Obfuscation of Automatically Generated Code the contents of which are herein incorporated by reference.

The present invention relates to a graphical modeling environment for modeling a dynamic system. More particularly generating and obfuscating code from a model of a dynamic system

Many organizations are embracing the paradigm of Model Based Development in their production processes. Model Based Development refers to the practice of specifying analyzing and implementing systems using a common model consisting of a set of block diagrams and associated objects. System implementation typically consists of automatically generating code for portions of the model particularly portions corresponding to the system s control algorithm.

Graphical modeling environments are programs that enable a user to construct and analyze a model of a process or system. Examples of graphical modeling tools include time based block diagrams such as Simulink from The MathWorks Inc. discrete event diagrams and reactive state machine diagrams such as those found within Stateflow also available from The MathWorks Inc. data flow diagrams such as LabVIEW available from National Instruments Corporation and software diagrams and other graphical programming environments such as Unified Modeling Language UML diagrams.

Some graphical modeling environments also enable simulation and analysis of models. Simulating a dynamic system in a graphical modeling environment is typically a two step process. First a user creates a graphical model such as a block diagram of the system to be simulated. A graphical model may be created using a graphical user interface such as a graphical model editor. The graphical model depicts relationships between the systems inputs states parameters and outputs. After creation of the graphical model the behavior of the dynamic system is simulated using the information entered into the graphical model. In this step the graphical model is used to compute and trace the temporal evolution of the dynamic systems outputs execute the graphical model and automatically produce either deployable software systems or descriptions of hardware systems that mimic the behavior of either the entire model or portions of the model code generation .

Block diagrams are graphical entities having an executable meaning that are created within graphical modeling environments for modeling a dynamic system and generally comprise one or more graphical objects. For example a block diagram model of a dynamic system is represented schematically as a first collection of graphical objects such as nodes that are interconnected by another set of graphical objects generally illustrated as lines which represent logical connections between the first collection of graphical objects. In most block diagramming paradigms the nodes are referred to as blocks and drawn using some form of geometric object e.g. circle rectangle etc. . The line segments are often referred to as signals . Signals correspond to the time varying quantities represented by each line connection and are assumed to have values at each time instant when connected to an enabled node. Each node may represent an elemental dynamic system and the relationships between signals and state variables are defined by sets of equations represented by the nodes. Inherent in the definition of the relationship between the signals and the state variables is the notion of parameters which are the coefficients of the equations. These equations define a relationship between the input signals output signals state and time so that each line represents the input and or output of an associated elemental dynamic system. A line emanating at one node and terminating at another signifies that in terms of computational causality the output of the first node is an input to the second node. Each distinct input or output on a node is referred to as a port. The source node of a signal writes to the signal at a given time instant when its system equations are solved. The destination node of this signal read from the signal when their system equations are being solved. Those skilled in the art will recognize that the term nodes does not refer exclusively to elemental dynamic systems but may also include other modeling elements that aid in readability and modularity of block diagrams.

It is worth noting that block diagrams are not exclusively used for representing time based dynamic systems but also for other models of computation. For example in Stateflow flow charts are block diagrams used to capture behavior of reactive systems and the flow of discrete state changes. Data flow blocks are block diagrams that describe a graphical programming paradigm where the availability of data is used to initiate the execution of blocks where a block represents an operation and a line represents execution dependency describing the direction of data flowing between blocks.

From the block diagrams source code can be generated using a tool such as the Real Time Workshop tool for Simulink models. In this mode the engine upon the behest of the user translates a selected portion of the block diagram or the entire block diagram itself into code. Such code could be in a number of possible forms. The code may be instructions in a high level software language such as C C Ada etc. hardware descriptions of the block diagram portions in a language such as HDL or custom code formats suitable for interpretation in some third party software. Alternatively the code may be instructions suitable for a hardware platform such as a microprocessor microcontroller or digital signal processor etc. a platform independent assembly that can be re targeted to other environments or just in time code instructions that corresponds to sections of the block diagram for accelerated performance. Provided with the Simulink product family is the Target Language Compiler TLC . This technology enables the creation of active scripts that control how the generated code is produced for a block diagram. Using TLC one can tailor the generated code to suite their specific needs.

In some instances a user may wish to share source code generated from a model with a third party. While the third party may need the source code for compilation the user may not wish for the third party to be able to read or understand the source code. Thus what is needed is a method for providing generated code that is unintelligible to a human but is still intelligible to a compiler.

The present invention provides a method of obfuscating code for a block diagram such that it is unintelligible to a human but is intelligible to a compiler and still retains the original code s behavior. Thus the obfuscated code may be used in the context of another block diagram.

In accordance with a first aspect in a graphical programming environment a method comprises providing a block diagram model of a dynamic system and generating obfuscated code from the block diagram and incorporating obfuscated code into a block diagram model.

In accordance with another aspect a medium for use with a computational device holding instructions executable by the computational device for performing a method. The method comprises the steps of providing a block diagram model of a dynamic system and generating obfuscated code from the block diagram.

In accordance with another aspect a medium for use with a computational device holding instructions executable by the computational device for performing a method. The method comprises the steps of providing obfuscated code for a model and incorporating obfuscated code into a block diagram model.

In accordance with another aspect a system for generating and displaying a graphical modeling application comprises user operable input means for inputting data to the graphical modeling application a display device for displaying a graphical model and a computational device including memory for storing computer program instructions and data and a processor for executing the stored computer program instructions the computer program instructions including instructions for providing a block diagram model of a dynamic system and generating obfuscated code from the block diagram.

In accordance with another aspect a system for generating and displaying a graphical modeling application comprises a distribution server for providing to a client device obfuscated code generated from a block diagram and a client device in communication with the distribution server.

In accordance with another aspect in a network having a server executing a graphical modeling environment and a client device in communication with the server a method comprising the steps of providing at the server a block diagram model of a dynamic system and receiving at the server from the client device a request to generate code from the block diagram and receiving at the client device from the server obfuscated code

An illustrative embodiment of the present invention relates to generating and using obfuscated code. The present invention will be described relative to illustrative embodiments. Those skilled in the art will appreciate that the present invention may be implemented in a number of different applications and embodiments and is not specifically limited in its application to the particular embodiments depicted herein.

For example the memory holds a diagramming application capable of creating and simulating electronic versions of system diagrams such as time based block diagrams state diagrams signal diagrams flow chart diagrams sequence diagrams UML diagrams dataflow diagrams circuit diagrams ladder logic diagrams kinematic element diagrams or other models which may be displayed to a user via the display device . In the illustrative embodiment the diagramming application comprises a block diagram environment such as Simulink or another suitable graphical modeling environment. As used herein the terms block diagram environment and graphical modeling environment refer to a graphical application where a model is translated into executable instructions. Examples of suitable diagramming applications include but are not limited to MATLAB with Simulink from the MathWorks LabVIEW DasyLab and DiaDem from National Instruments Corporation VEE from Agilent SoftWIRE from Measurement Computing VisSim from Visual Solutions SystemVIEW from Elanix WiT from Coreco Vision Program Manager from PPT Vision Khoros from Khoral Research Halcon from MVTec Software and numerous others. The memory may comprise any suitable installation medium e.g. a CD ROM floppy disks or tape device a computer system memory or random access memory such as DRAM SRAM EDO RAM Rambus RAM etc. or a non volatile memory such as a magnetic media e.g. a hard drive or optical storage. The memory may comprise other types of memory as well or combinations thereof.

In an alternative embodiment the electronic device is also interfaced with a network such as the Internet. Those skilled in the art will recognize that the diagrams used by the diagramming application may be stored either locally on the electronic device or at a remote location interfaced with the electronic device over a network. Similarly the diagramming application may be stored on a networked server or a remote peer.

The diagramming application of an illustrative embodiment of the invention includes a number of generic components. Although the discussion contained herein focuses on Simulink from The MathWorks Inc. of Natick Mass. those skilled in the art will recognize that the invention is applicable to other software applications. The generic components of the illustrative diagramming program include a block diagram editor for graphically specifying models of dynamic systems. The block diagram editor allows users to perform such actions as construct edit display annotate save and print out a graphical model such as a block diagram that visually and pictorially represents a dynamic system. The illustrative diagramming application also includes graphical entities such as signal lines and buses that represent how data is communicated between functional and non functional units and blocks . As noted above blocks are the fundamental mathematical elements of a classic block diagram model. A block diagram execution engine also implemented in the application is used to process a graphical model to produce simulation results or to convert the graphical model to executable code. For a block diagram graphical model the execution engine translates a block diagram to executable entities following the layout of the block diagram as provided by the user. The executable entities are compiled and executed on a computational device such as a computer to implement the functionality specified by the model. Typically the code generation preserves a model hierarchy in a call graph of the generated code. For instance each subsystem of a model in a block diagram environment can map to a user specified function and the generated code. Real Time Workshop from the MathWorks Inc. of Natick Mass. is an example of a suitable execution engine for generating code.

In the illustrative embodiment the diagramming program is implemented as a companion program to a technical computing program such as MATLAB also available from the MathWorks Inc.

The block diagram editor is the user interface component that allows a user to create and modify a block diagram model representing a dynamic system in step . The blocks in the electronic block diagram may model the behavior of specialized mechanical circuit or software components such as motors servo valves power plants blocks tires modems receivers and other dynamic components. The block diagram editor also allows a user to create and store data relating to graphical entities . In Simulink a textual interface with a set of commands allows interaction with the graphical editor. Using this textual interface users may write special scripts that perform automatic editing operations on the block diagram. A user generally interacts with a set of windows that act as canvases for the model. There is generally more than one window for a model because models may be partitioned into multiple hierarchical levels through the use of subsystems.

A suite of user interface tools within the block diagram editor allows users to draft a block diagram model on the corresponding windows. For example in Simulink the user interface tools include a block palette a wiring line connection tool an annotation tool a formatting tool an attribute editing tool a save load tool and a publishing tool. The block palette is a library of all the pre defined blocks available to the user for building the block diagram. Individual users may be able to customize this palette to a reorganize blocks in some custom format b delete blocks they do not use and c add custom blocks they have designed. The palette allows blocks to be dragged through some human machine interface such as a mouse or keyboard from the palette on to the window i.e. model canvas . The graphical version of the block that is rendered on the canvas is called the icon for the block. There may be different embodiments for the block palette including a tree based browser view of all of the blocks.

A block diagram model of a dynamic system created during step is generally represented schematically as a collection of interconnected graphical objects such as blocks ports and lines which represent signals. illustrates an example of a block diagram created using the diagramming application . Each block in the block diagram represents an elemental dynamic system. Each signal denoted by lines connecting the blocks represents the input and or output of an elemental dynamic system. The illustrative block diagram includes a subsystem block a source block and a destination block . A line emanating at one block and terminating at another signifies that the output of the first block is an input to the second block. Ports such as input port and output port of the subsystem block refer to a distinct inputs or outputs on a block. Signals correspond to the time varying quantities represented by each line connection and are assumed to have values at each time instant when their connected blocks are enabled. The source block for a signal writes to the signal at a given time instant when its system equations are solved. As shown the signal from the source block passes to the subsystem . The signal outputted from the subsystem passes to the destination block . The destination block for a signal reads from the signal when the system equation is being solved. As shown the signal represents the output of the subsystem . One skilled in the art will recognize that the block diagram is merely illustrative of a typical application and is not intended to limit the present invention in any way.

Once a block diagram model or other graphical model has been constructed using the editor in step the execution engine simulates the model by solving equations defined by the model to trace the system outputs as a function of time in steps . The solution of the model which may be referred to as model execution is carried out over a user specified time span for a set of user specified inputs.

The compile stage in step marks the start of model execution and involves preparing data structures and evaluating parameters configuring and propagating block characteristics determining block connectivity and performing block reduction and block insertion. The compile stage involves checking the integrity and validity of the block interconnections in the block diagram. In this stage the engine also sorts the blocks in the block diagram into hierarchical lists that are used when creating the block method execution lists. The preparation of data structures and the evaluation of parameters create and initialize basic data structures needed in the compile stage. For each of the blocks a method forces the block to evaluate all of its parameters. This method is called for all blocks in the block diagram. If there are any unresolved parameters execution errors are thrown at this point.

The compilation step also determines actual block connectivity. Virtual blocks play no semantic role in the execution of a block diagram. During compilation the virtual blocks and signals such as virtual bus signals in the block diagram are optimized away removed and the remaining non virtual blocks are reconnected to each other appropriately. This compiled version of the block diagram with actual block connections is used from this point forward in the execution process.

In the link stage in step the execution engine uses the result of the compilation stage to allocate memory needed for the execution of the various components of the block diagram. The linking stage also produces block method execution lists which are used by the simulation or linearization of the block diagram. Included within the link stage is the initialization of the model which consists of evaluating setup methods e.g. block start initialize enable and constant output methods . The block method execution lists are generated because the simulation and or linearization of a model must execute block methods by type not by block when they have a sample hit.

The compiled and linked version of the block diagram may be directly utilized to execute the model over the desired time span in step . In step the execution engine may choose to translate the block diagram model or portions of it into either software modules or hardware descriptions broadly termed code . The code may be instructions in a high level software language such as C C Ada etc. hardware descriptions of the block diagram portions in a language such as HDL or custom code formats suitable for interpretation in some third party software. Alternatively the code may be instructions suitable for a hardware platform such as a microprocessor microcontroller or digital signal processor etc. a platform independent assembly that can be re targeted to other environments or just in time code instructions that corresponds to sections of the block diagram for accelerated performance.

Source code for a model can be generated using a tool such as the Real Time Workshop tool for Simulink models. Using such a tool the engine upon the behest of the user translates a selected portion of the block diagram or the entire block diagram itself into code. Such code could be in a number of possible forms. Provided with the Simulink product family is the Target Language Compiler TLC . This technology enables the creation of active scripts that control how the generated code is produced for a block diagram. Using TLC one can tailor the generated code to suite one s specific needs.

An example of a block diagram model of a dynamic system can be seen in . Here the block diagram model is an algorithm designed by the user using gain blocks and integrator blocks that receives two inputs and provides two outputs . It will be understood that this is but one example of any number of possible block diagrams. Other systems will be apparent to one skilled in the art given the benefit of this disclosure.

After designing the algorithm of a user may wish to share the model with a third party without letting the third party know anything about the algorithm. The third party will need the source code to be able to compile the model for use. Thus obfuscated code is generated .

In certain embodiments the obfuscated code is generated by selecting a target that generates obfuscated code. This may be performed using a graphical interface. An example of this can be seen in . Here the graphical user interface is a system target file browser provided with the Target Language Compiler TLC which is used to select a system target file which in this case is an S function target with code obfuscation. The browser also provides the user with the path name of the target the Template make file and the Make command .

Using the S function target you can build an S function component and use it as an S Function block in another model. The S function code format used by the S function target generates code that conforms to the Simulink C MEX S function application programming interface API . S functions use a special calling syntax that enables interaction with Simulink equation solvers. This interaction is very similar to the interaction that takes place between the solvers and built in Simulink blocks. The form of an S function is very general and can accommodate continuous discrete and hybrid systems.

Traditionally an S function target can be used to protect designs and algorithms. By generating an S function from a proprietary model or algorithm and compiling it into a binary form one can share the model s functionality without providing the source code. While this may be a satisfactory solution for a typical simulation scenario it is wholly unsatisfactory if you need to generate code and cross compile a model on an independent platform. In such a case the source code for the S Function is required. But by appropriately obfuscating the generated S Function target code the source code for an S function can be provided to a third party for purposes of simulation and code generation.

It will be understood that this is but one example of any number of possible ways of initiating the generation of code. Other implementations and methodologies will be apparent to one skilled in the art given the benefit of this disclosure.

In certain embodiments the obfuscation is performed in a deterministic method. This means a symbol will always be obfuscated in the same obfuscated string. In certain embodiments the user provides a password that breaks the determinism of the obfuscation. This may be done using a graphical interface such as that provided by the Target Language Compiler TLC for setting configuration parameters an example of which is shown in . Here an Obfuscator Password field is provided for the user to enter a password . Using this password allows a user to break the determinism of the obfuscation.

In certain embodiments when the obfuscated code is generated the related files necessary for compiling the code such as the library and header files are also obfuscated. depicts a flow chart of one exemplary method of generating obfuscated code as shown in . The first step in the method involves gathering all the required libraries in a first directory step . In this case for example the first directory may be a designated non obfuscated code directory. The next step is generating non obfuscated code in the first directory step . As in the first step the code may be placed in the designated non obfuscated code directory. Finally the non obfuscated code in the first directory is converted to obfuscated code in a second directory step . In this case for example this involves converting the C text files of the non obfuscated code as well as non system header files required by the C text files. The second directory where the obfuscated code is placed may be a designated obfuscated code directory. It will be understood that this is but one possible method of generating obfuscated code. For example a user may be only provided with obfuscated code and not the non obfuscated code. Other embodiments and implementations will be apparent to one skilled in the art given the benefit of this disclosure.

The process of removing comments and formatting from the code process serves to eliminate features from the code that increase readability and possibly indicated structure for a human reader but are not necessary for compiling.

The process of converting the strings into different numbering system process serves to decrease the readability for a human but does not effect the compiling of the code. In certain embodiments the strings may be converted to a base 8 numbering system octal . In other embodiments the strings may be converted to a base 16 numbering system hex . Other possible numbering systems will be apparent to one skilled in the art given the benefit of this disclosure.

The process of converting remaining non system header files process also serves to decrease readability. By giving non system header files meaningless names the likelihood of discerning functionality is reduced because possibly descriptive names that could indicate functionality have been removed. Again this only decreases readability for a human it does not affect compiling.

The process of replacing numeric constants with obfuscated names process is another measure to reduce readability by humans. To do this the numeric constants are placed in a header file and are assigned a macro name. For example the constant 2.0 may be placed in a header file as follows 

The optional process of removing loops process is again another way to eliminate features from the code that could possibly indicate structure for a human reader but are not necessary for compiling. This technique may also be performed with other types of flow control such as if then statements and switches.

It will be understood that the flow chart shown here represents just one of several possible orderings of processes. One skilled in the art would recognize that listed processes can be performed in any number of combinations before the hash function is applied. It is also understood that other processes may be performed. Other possible processes will be apparent to one skilled in the art given the benefit of this disclosure.

The process of applying a one way hash function process is the final step in obfuscating the code. Preferably the applied hash function is MDS. Hash functions are well known in the art and other suitable hash functions will be apparent given the benefit of this disclosure.

After the non obfuscated code has been converted to obfuscated code the resulting designated obfuscated code directory contains all the necessary files needed by a third party to compile a version of the model that will work on there system. The resulting model from the obfuscated code generated from the model depicted in can be seen in . Here is the model is used as an S Function. The third party may make calls to the resulting model just as they would to non obfuscated S Function. This S function can thus be used in block diagrams from which source code both obfuscated and non obfuscated can be generated.

To better understand the process of obfuscation it may be helpful to look at examples of generated non obfuscated code and the corresponding obfuscated code. Below is a snippet of non obfuscated code that is generated in the method of from the model depicted in .

As the obfuscation is deterministic in some embodiments in certain embodiments for the purpose of debugging the user may be provided with an option of generating a symbol table that lists the original symbols and their obfuscated names.

It should also be understood that in some embodiments only portions of the generated code may be obfuscated while other portions are not obfuscated. The portion of the generated code that is obfuscated can be automatically selected based on functional criteria of the block diagram model the functional criteria of the generated code or selected by the user. The criteria may be any of the semantic and syntactic notions that affect the execution and editing of the model or generation of code. Examples include components that contain look up tables or exported global variables.

In other embodiments portions of code may be obfuscated separately and require a different password to break the obfuscation for each portion. Further more layers of obfuscation may be employed. For example the entire code may be obfuscated using one password while portions of code within the entire code may be independently obfuscated using separate passwords.

The examples to this point have focused primarily on the system where the graphical modeling environment was on a local computational device in one embodiment an electronic device. The graphical modeling environment may of course also be implemented on a network as illustrated in having a server and a client device . Other devices such as a storage device may also be connected to the network.

In one such embodiment a system for generating and displaying a graphical modeling application comprises a distribution server for providing to a client device obfuscated code generated from a block diagram and a client device in communication with the distribution server. Here the distribution server provides a client device such as an electronic device discussed above with obfuscated code. The client may then use the obfuscated code to compile a model for use at the client device. In some embodiments the obfuscated code may be used as part of block diagram model. In such cases code may also be generated from this block diagram.

In another embodiment a user may then interact with a graphical modeling interface on the server through the client device. In one example of such a system a server and client device are provided. The server is capable of executing a graphical modeling environment. The client device is in communication with the server over a network. The server receives from the client device a request to generate code from the block diagram. The server generates obfuscated code from the block diagram. The client device then receives from the server the obfuscated code.

It will be understood by one skilled in the art that these network embodiments are exemplary and that the functionality may be divided up in any number of ways over a network.

The present invention has been described relative to illustrative embodiments. Since certain changes may be made in the above constructions without departing from the scope of the invention it is intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative and not in a limiting sense.

It is also to be understood that the following claims are to cover all generic and specific features of the invention described herein and all statements of the scope of the invention which as a matter of language might be said to fall therebetween.

