---

title: Hierarchical rule development and binding for web application server firewall
abstract: At least one of an HTTP request message and an HTTP response message is intercepted. A corresponding HTTP message model includes a plurality of message model sections. A representation of the at least one of an HTTP request message and an HTTP response message is parsed into message sections in accordance with the message model sections of the HTTP message model. A plurality of security rules are bounds to the message model sections. The plurality of security rules each specify at least one action to be taken in response to a given condition, which is based, at least in part, on a corresponding given one of the message sections. The at least one of an HTTP request message and an HTTP response message is processed in accordance with the plurality of security rules. Techniques for developing rules for a web application server firewall are also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09237130&OS=09237130&RS=09237130
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09237130
owner_city: Armonk
owner_country: US
publication_date: 20140106
---
This application is a continuation of U.S. patent application Ser. No. 13 114 315 filed May 24 2011 the complete disclosure of which is expressly incorporated herein by reference in its entirety for all purposes.

The present invention relates to the electrical electronic and computer arts and more particularly to web infrastructures and the like.

In a typical Web application a client such as a browser interacts with a Web server by exchanging a series of messages that are made up of hypertext transfer protocol HTTP requests and responses. An attacker often exploits vulnerabilities that exist in a Web application to launch attacks. Some of the predominant types of attacks against Web applications include Cross Site Scripting XSS SQL Injection SQL I and Cross Site Request Forgery CSRF attacks.

Principles of the invention provide techniques for hierarchical rule development and binding for a web application server firewall. In one aspect an exemplary method for operating a web application server firewall includes the steps of intercepting at least one of an HTTP request message and an HTTP response message and identifying a corresponding HTTP message model based on the intercepting step. The HTTP message model includes a plurality of message model sections. Additional steps include parsing a representation of the at least one of an HTTP request message and an HTTP response message into message sections in accordance with the message model sections of the HTTP message model and binding a plurality of security rules to the message model sections. The plurality of security rules each specify at least one action to be taken in response to a given condition. The given condition is based at least in part on a corresponding given one of the message sections. A further step includes processing the at least one of an HTTP request message and an HTTP response message in accordance with the plurality of security rules.

In another aspect an exemplary method for developing rules for a web application server firewall includes the steps of anticipating at least one of an HTTP request message and an HTTP response message likely to be processed by the web application server firewall and building a corresponding HTTP message model based on the anticipating step. The HTTP message model includes a plurality of message model sections. An additional step includes developing a plurality of security rules each specifying at least one action to be taken in response to a given condition. The given condition is based at least in part on a corresponding section of an actual message. A further step includes binding the plurality of security rules to the message model sections. In some cases rather than carrying out the anticipating step such step is performed externally and the method includes building the HTTP message model based on the at least one of an HTTP request message and an HTTP response message anticipated from the externally performed step as likely to be processed by the web application server firewall.

As used herein facilitating an action includes performing the action making the action easier helping to carry the action out or causing the action to be performed. Thus by way of example and not limitation instructions executing on one processor might facilitate an action carried out by instructions executing on a remote processor by sending appropriate data or commands to cause or aid the action to be performed. For the avoidance of doubt where an actor facilitates an action by other than performing the action the action is nevertheless performed by some entity or combination of entities.

One or more embodiments of the invention or elements thereof can be implemented in the form of a computer program product including a computer readable storage medium with computer usable program code for performing the method steps indicated. Furthermore one or more embodiments of the invention or elements thereof can be implemented in the form of a system or apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps. Yet further in another aspect one or more embodiments of the invention or elements thereof can be implemented in the form of means for carrying out one or more of the method steps described herein the means can include i hardware module s ii software module s stored in a computer readable storage medium or multiple such media and implemented on a hardware processor or iii a combination of i and ii any of i iii implement the specific techniques set forth herein.

Techniques of the present invention can provide substantial beneficial technical effects. For example one or more embodiments may provide one or more of the following advantages 

These and other features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof which is to be read in connection with the accompanying drawings.

Cloud computing is a model of service delivery for enabling convenient on demand network access to a shared pool of configurable computing resources e.g. networks network bandwidth servers processing memory storage applications virtual machines and services that can be rapidly provisioned and released with minimal management effort or interaction with a provider of the service. This cloud model may include at least five characteristics at least three service models and at least four deployment models.

On demand self service a cloud consumer can unilaterally provision computing capabilities such as server time and network storage as needed automatically without requiring human interaction with the service s provider.

Broad network access capabilities are available over a network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms e.g. mobile phones laptops and PDAs .

Resource pooling the provider s computing resources are pooled to serve multiple consumers using a multi tenant model with different physical and virtual resources dynamically assigned and reassigned according to demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction e.g. country state or datacenter .

Rapid elasticity capabilities can be rapidly and elastically provisioned in some cases automatically to quickly scale out and rapidly released to quickly scale in. To the consumer the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.

Measured service cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service e.g. storage processing bandwidth and active user accounts . Resource usage can be monitored controlled and reported providing transparency for both the provider and consumer of the utilized service.

Software as a Service SaaS the capability provided to the consumer is to use the provider s applications running on a cloud infrastructure. The applications are accessible from various client devices through a thin client interface such as a web browser e.g. web based email . The consumer does not manage or control the underlying cloud infrastructure including network servers operating systems storage or even individual application capabilities with the possible exception of limited user specific application configuration settings.

Platform as a Service PaaS the capability provided to the consumer is to deploy onto the cloud infrastructure consumer created or acquired applications created using programming languages and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including networks servers operating systems or storage but has control over the deployed applications and possibly application hosting environment configurations.

Infrastructure as a Service IaaS the capability provided to the consumer is to provision processing storage networks and other fundamental computing resources where the consumer is able to deploy and run arbitrary software which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems storage deployed applications and possibly limited control of select networking components e.g. host firewalls .

Private cloud the cloud infrastructure is operated solely for an organization. It may be managed by the organization or a third party and may exist on premises or off premises.

Community cloud the cloud infrastructure is shared by several organizations and supports a specific community that has shared concerns e.g. mission security requirements policy and compliance considerations . It may be managed by the organizations or a third party and may exist on premises or off premises.

Public cloud the cloud infrastructure is made available to the general public or a large industry group and is owned by an organization selling cloud services.

Hybrid cloud the cloud infrastructure is a composition of two or more clouds private community or public that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability e.g. cloud bursting for load balancing between clouds .

A cloud computing environment is service oriented with a focus on statelessness low coupling modularity and semantic interoperability. At the heart of cloud computing is an infrastructure comprising a network of interconnected nodes.

Referring now to a schematic of an example of a cloud computing node is shown. Cloud computing node is only one example of a suitable cloud computing node and is not intended to suggest any limitation as to the scope of use or functionality of embodiments of the invention described herein. Regardless cloud computing node is capable of being implemented and or performing any of the functionality set forth herein.

In cloud computing node there is a computer system server which is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with computer system server include but are not limited to personal computer systems server computer systems thin clients thick clients handheld or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputer systems mainframe computer systems and distributed cloud computing environments that include any of the above systems or devices and the like.

Computer system server may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types. Computer system server may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

As shown in computer system server in cloud computing node is shown in the form of a general purpose computing device. The components of computer system server may include but are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to processor .

Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus.

Computer system server typically includes a variety of computer system readable media. Such media may be any available media that is accessible by computer system server and it includes both volatile and non volatile media removable and non removable media.

System memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . Computer system server may further include other removable non removable volatile non volatile computer system storage media. By way of example only storage system can be provided for reading from and writing to a non removable non volatile magnetic media not shown and typically called a hard drive . Although not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to bus by one or more data media interfaces. As will be further depicted and described below memory may include at least one program product having a set e.g. at least one of program modules that are configured to carry out the functions of embodiments of the invention.

Program utility having a set at least one of program modules may be stored in memory by way of example and not limitation as well as an operating system one or more application programs other program modules and program data. Each of the operating system one or more application programs other program modules and program data or some combination thereof may include an implementation of a networking environment. Program modules generally carry out the functions and or methodologies of embodiments of the invention as described herein.

Computer system server may also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with computer system server and or any devices e.g. network card modem etc. that enable computer system server to communicate with one or more other computing devices. Such communication can occur via Input Output I O interfaces . Still yet computer system server can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted network adapter communicates with the other components of computer system server via bus . It should be understood that although not shown other hardware and or software components could be used in conjunction with computer system server . Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems etc.

Referring now to illustrative cloud computing environment is depicted. As shown cloud computing environment comprises one or more cloud computing nodes with which local computing devices used by cloud consumers such as for example personal digital assistant PDA or cellular telephone A desktop computer B laptop computer C and or automobile computer system N may communicate. Nodes may communicate with one another. They may be grouped not shown physically or virtually in one or more networks such as Private Community Public or Hybrid clouds as described hereinabove or a combination thereof. This allows cloud computing environment to offer infrastructure platforms and or software as services for which a cloud consumer does not need to maintain resources on a local computing device. It is understood that the types of computing devices A N shown in are intended to be illustrative only and that computing nodes and cloud computing environment can communicate with any type of computerized device over any type of network and or network addressable connection e.g. using a web browser .

Referring now to a set of functional abstraction layers provided by cloud computing environment is shown. It should be understood in advance that the components layers and functions shown in are intended to be illustrative only and embodiments of the invention are not limited thereto. As depicted the following layers and corresponding functions are provided 

Hardware and software layer includes hardware and software components. Examples of hardware components include mainframes in one example IBM zSeries systems RISC Reduced Instruction Set Computer architecture based servers in one example IBM pSeries systems IBM xSeries systems IBM BladeCenter systems storage devices networks and networking components. Examples of software components include network application server software in one example IBM WebSphere application server software and database software in one example IBM DB2 database software. IBM zSeries pSeries xSeries BladeCenter WebSphere and DB2 are trademarks of International Business Machines Corporation registered in many jurisdictions worldwide .

Virtualization layer provides an abstraction layer from which the following examples of virtual entities may be provided virtual servers virtual storage virtual networks including virtual private networks virtual applications and operating systems and virtual clients.

In one example management layer may provide the functions described below. Resource provisioning provides dynamic procurement of computing resources and other resources that are utilized to perform tasks within the cloud computing environment. Metering and Pricing provide cost tracking as resources are utilized within the cloud computing environment and billing or invoicing for consumption of these resources. In one example these resources may comprise application software licenses. Security provides identity verification for cloud consumers and tasks as well as protection for data and other resources. User portal provides access to the cloud computing environment for consumers and system administrators. Service level management provides cloud computing resource allocation and management such that required service levels are met. Service Level Agreement SLA planning and fulfillment provide pre arrangement for and procurement of cloud computing resources for which a future requirement is anticipated in accordance with an SLA.

Workloads layer provides examples of functionality for which the cloud computing environment may be utilized. Examples of workloads and functions which may be provided from this layer include mapping and navigation software development and lifecycle management virtual classroom education delivery data analytics processing transaction processing and mobile desktop.

One or more embodiments provide techniques for design and implementation of hierarchical rules for a web application server firewall. A Web Application Server Firewall WASF is a firewall that is enabled inside a Web Application Server such as a Tomcat server available from the Apache software foundation to filter unwanted messages and protect Web applications running on the server. Unlike other kinds of firewalls a WASF can exploit the richer semantics of the Web applications and thereby provide a fine grain protection. One or more embodiments herein provide design and implementation of a fine grain and hierarchical rule development for a WASF. There are two parts to hierarchical rule development 1 Hierarchical rule schema and 2 Rule development tool. The hierarchical rule schema supports a number of features including late binding of rules with messages and ability to handle URI templates and RESTful requests REST representational state transfer a RESTful web service or RESTful web API is a simple web service implemented using HTTP and the techniques of REST . To improve the usability of developing and deploying firewall rules one or more embodiments provide a Rule Development Tool RDT that provides several capabilities for developing and deploying rules searching for similar rules analyzing conflicts among rules transforming rules from one format to another one and interactive virtual patching. One or more embodiments of WASF are suitable for deployment in products and in a cloud environment.

As noted above in a typical Web application a client such as a browser interacts with a Web server by exchanging a series of messages that are made up of hypertext transfer protocol HTTP requests and responses. An attacker often exploits vulnerabilities that exist in a Web application to launch attacks. Some of the predominant types of attacks against Web applications include Cross Site Scripting XSS SQL Injection SQL I and Cross Site Request Forgery CSRF attacks.

A Web Application Server Firewall WASF is a piece of software installed inside a Web Application Server WAS such as a WebSphere Application Server registered mark of International Business Machines Corporation Armonk N.Y. USA hereinafter IBM or a Tomcat server to filter inbound and outbound Web content of the WAS using filter or firewall rules. Unlike a typical network or proxy server firewall a WASF can exploit the richer semantics of the underlying Web applications to provide fine grain protection of the Web applications running on the server.

A significant aspect in WASF is how and at what level of Web application semantics can be exploited without modifying the Web application itself. Imagine that a Web application developer has released a Web application but has found vulnerability in the application. Unfortunately due to the release cycle the developer cannot modify the application. One significant question is whether WASF can be used to provide fine grain protection of the vulnerable application without any loss of functionality of the application. Modern Web applications that are based on AJAX asynchronous JavaScript and XML and REST contain rich content services and hierarchical resources. A skillful attacker can launch sophisticated attacks targeting specific vulnerable resources and services. Coarse grain firewall protection can often filter such attacks but it can also prevent rich functionality provided by the underlying applications.

One or more embodiments provide fine grain hierarchical rule development for a WASF referred to herein as Web Application Security Protection WASP to address the problem of fine grain protection of Web applications without modifying the vulnerable application and preventing loss of any its functionality. One exemplary solution includes two significant parts 1 a Hierarchical Rule Schema HRS for writing flexible fine grained and hierarchical firewall rules and 2 a Rule Development Tool RDT to quickly develop rules to protect against zero day attacks. The RDT provides several capabilities to the application developer and security administrator to develop including searching for similar rules parsing and modeling Web application configurations which often contain the application layout integration with black box testing tool such as AppScan available from IBM transforming rules from ModSecurity well known open source web application firewall to the HRS and the like.

Note that WASP is a non limiting example of a web application firewall such firewalls per se are known to the skilled artisan and given the teachings herein the skilled artisan will be able to implement aspects of the invention in one or more web application firewalls.

In one or more embodiments the HRS is based on two design principles 1 ability to support fine grain rules to protect hierarchical Web resources and services and 2 late binding of rules to message types. A typical Web applications based on AJAX and REST maintains a large collection of hierarchical resources and services. A fine grain hierarchical rule schema is necessary for effectively handling RESTful requests. Consider the example in .

A RESTful Web application that processes the GET requests for the URLs will typically not create one static page for each resource. The Web application will construct a layout for the URLs using a URI Template mechanism described using configuration files or annotations. A URI Template is a mechanism that allows one to specify a URL to include parameters that is substituted before the URL is resolved. Using a URI Template mechanism an application can create the template for the example where pid and tid are resource variables that map to 1 and 3 respectively for the first URL and will map to 3 and 4 respectively for the second URL . To handle such URI template based HTTP requests requires the ability to model hierarchical rules and also an understanding of the back end application structure. Using RDT in one or more embodiments parse and explore the configuration files and deployment descriptor of a back end application and model the underlying hierarchical application structure.

In one or more embodiments using hierarchical rule language model the above URI Template obtained by parsing configuration files as at which represents the instance of Hostname. Pizza pid topping and tid are instances of FilePathNode. For resources pid and uid also set the attribute is Variable to be true and the variableExpression is set 0 9 indicating that it matches numerical value pattern. Another point is to set the attribute inheritParent to the node tid which means the rule bound to the parent node such as topping will be inherited and applied to the child node. The above URI Template is then represented using JSON JavaScript Object Notation . JSON is a simple and flexible language that is used in one or more embodiments for representing not only core elements of the rule language meta information about various parts of the rule elements that provide additional capabilities can also be expressed.

The HRS allows late binding of rules with message components on which the rules operate. To further elaborate the late binding principle consider a typical HTTP GET request. It includes several components such as headers URL cookies and the like. One or more rules can be bound to each of these components. A rule includes two parts condition and action. A rule typically has to be bound to a message before it can be triggered. In other words an unbounded rule can typically never be triggered even if its condition is true always. Now when a condition of a bounded rule is true then the corresponding action is executed. Using RDT a security administrator can develop new rules and bind existing rules to different components of a message. Late binding provides flexibility wherein a security administrator can decide how the rules are bound to messages.

A non limiting exemplary embodiment implements WASP using a J2EE JAVA enterprise edition framework and so the exemplary WASP can potentially be deployed inside any J2EE Web application server. In non limiting experiments WASP has been integrated into Web Sphere application server WAS and Tomcat server and has also been deployed in a Cloud environment. Several empirical results that highlight different features of WASP including results that compare and contrast WASP with ModSecurity and various performance results are presented herein.

The exemplary design of WASP provides a flexible WASF for new enterprise models such as the Cloud environment. shows the overall system architecture of WASP. The exemplary WASP embodiment includes WASP Server WASP Client and WASP Central Processor .

WASP Server The WASP Server processes HTTP request and response messages and applies rules to filter bad messages and allow good messages. The basic filtering process includes first intercepting the HTTP request response messages constructing WASP internal message objects based on a message model as described in below and applying filtering rules deployed inside the engine. The WASP Server shown in in turn includes a connector which essentially captures the HTTP requests and responses and then forwards them to the message handler . A non limiting exemplary embodiment supports Tomcat server and WebSphere Application Server not separately numbered in block . In some cases WASP can be employed in IBM WebSphere proxy server and Apache server and in these deployments can be used as a proxy firewall that does not exploit the richer application semantics. One or more embodiments do not modify the original messages but instead create a copy of the message and forward to the Message Handler .

The Message Handler parses the messages forwarded by the Connector and creates the WASP message object described in detail below . For each request response message multiple sections will be created based on the HTTP message protocol including the Header Section Cookie Section Query String Section Body Section and so on. Some encoded characters such as base64 value Hex value and so on still can launch the XSS attack especially when these characters are embedded in a requested URL as the query string. Thus the decoder module is used to sanitize the input values if it contains different encoding characters.

The Runtime Engine is a significant module that processes the request response based on the security rules. The RESTful rewriting module is used to support RESTful URL and URI templates. To obtain the context of the RESTful requests one or more embodiments import and analyze the application configuration files such as web.xml application.xml and the like to create the regex regular expression pattern for the RESTful URLs and URI templates. Then based on the URL regex pattern map the dynamic RESTful URL to the common static one then index the rules based on the common static one. In this manner there is no need to create the security rules for each dynamic URL which has the same URL pattern so that the rule configuration cost can be reduced. After indexing the rules based on the request URL pattern process each section in the request response message based on the security rules. If one rule is triggered the corresponding actions defined in the rule will be enabled such as denying the request logging responding with a friendly error message and so on.

WASP Client One salient feature of WASP is that in the new enterprise model client side applications are considered as part of the enterprise model. WASP Client provides a number of capabilities such as user friendly error report when requests are blocked client pre checking of rules and the like.

WASP Central Processor The WASP Central Processor is where offline analysis rule development rule testing and rule deployment are performed. The Central Processor includes Kernel Services Store House Analysis Engine and Rule Management .

Kernel Services A Cloud environment will typically host many different kinds of application services with different security requirements. The Kernel Services provide user centric access to WASP internals so that firewall rules and other log information for one application is not exposed to users of another application.

Store House In one or more embodiments the Store House stores all of the relevant information including rules analysis results abstraction of application configuration and so on. One or more embodiments store most of the information as resources using JSON and or XML extensible markup language and provide a RESTful API application program interface to access and update the resources. Some embodiments use APACHE WINK as the RESTful framework. As an example a rule can be obtained with the specified ID as rule ruleID or get all the rules in the ruleset with the specified ruleset ID as ruleset rulesetID rules. Also for the rules binding to the different sections of the WASP message the rules can be obtained from the interface as message messageID section rules. The interface message 95601 header rules means it can get all the rules that are bound to the header section in the message with the message ID 95601.

Rule Management Rule Management includes the Rule Modeler module and Rule Analysis module . The Rule Modeler is used to model the HRS including the message model and rule model which is discussed further below.

Rather than developing a new surface syntax to express rules in one or more embodiments WASP uses JSON JavaScript Object Notation as the underlying representation for rules. One or more embodiments also support XML schema representation. The HRS includes 1 HTTP Message Model as seen in that defines the core model of the HTTP message structure 2 Rule Model of that can be used for writing firewall rules and 3 Message Rule Binding of which is desirable to determine the set of rules that should be triggered at runtime for a given message. In one or more embodiments the basic format of HTTP request and response messages includes 1 the initial line 2 a sequence of header lines 3 a new blank line and 4 the body. The initial line for a request message typically contains one of the HTTP methods such as GET POST HEAD and the like . The initial line for a response message typically contains status information that includes status code. illustrates an example of a POST request.

It is worth noting at this point that are pages from an exemplary web application the WASP console of . This application can be implemented for example in JSP Java Servlet and HTML. shows exemplary detailed definition of one rule. shows rule binding the right block indicates how to bind rules or rulesets onto http message sections while the left block shows the hierarchy structure in URL i.e. who is the parent FilePathNode and whether inherit rules from parent .

The overall HTTP message model using UML Unified Modeling Language is shown in . The root of the HTTP message model is the abstract element called Message . The RequestMessage and ResponseMessage are concrete types of Message element and they correspond to HTTP request and HTTP response messages. Recall that the initial line of an HTTP request contains method URL and version these are represented as Method URLTemplate and Version elements . The Version element is used to represent HTTP version number in both HTTP request and response and so it is part of in the Message element denoted using solid diamond symbol . A Method element can be one of GET POST PUT DELETE and HEAD. The URLTemplate element is split into HostName element a sequence of FilePathNode elements and a QueryString element . Notice that URLTemplate is part of RequestMessage denoted by solid diamond symbol whereas URLTemplate is referenced by ResponseMessage denoted by plain diamond symbol . The distinction is appropriate for indexing rules when response messages are processed.

Recall that each HTTP request and response includes a header section and this can be modeled using the Header element . The Header element can be considered to be a set of name value pair represented as a set of Parameter elements . Notice that in the model cookies are modeled using the Cookie element and the reason for this is that they typically contain significant elements such as session information and authentication information that are needed for writing filtering rules against cookies. Once again a Cookie element includes a set of name value pairs and so they are modeled as a set of Parameter elements. The QueryString element which is part of the URLTemplate element is also modeled as a set of name value Parameter elements. Finally when the value of the Content Type defined in the HTTP request header is application x www form urlencoded the message body will also be name value pairs and therefore they are modeled as a set of Parameter elements. In an exemplary WRS different types are handled for the body. The Content Type element defines the content type of the body. Unlike the RequestMessage element the ResponseMessage element includes a ResponseStatus element . The statusCode attribute can be any of the status code as defined by the well known IETF HTTP protocol standard. The ResponseMessage element also includes Header element Version element and Body element .

Consider the URL elements of an HTTP request which can be modeled as a URLTemplate element. As shown in each URLTemplate element includes three parts 1 Hostname element 2 sequence of FilePathNode elements and 3 QueryString element . The QueryString includes Parameter element that represents the name value pairs. Now consider the HTTP request URL . Element is an instance of the Hostname element. The resources Account and transferMoney.php are instances of the FilePathNode element. Finally acct BOB amount 100 is an instance of QueryString. Notice that QueryString includes two name value pair of Parameter elements separated by acct BOB and amount 100.

Each FilePathNode includes several attributes such as is Variable variableExpression and inheritParent explained below. To summarize in one or more embodiments the HTTP message model is concise and is semantically rich for developing rule models. The example in illustrates a JSON representation of an HTTP message model instance for the example shown in .

Whenever the condition holds true the corresponding action is executed. The following is an example of a rule R01 

In the above rule Request.Header.Parameter Content Length identifies a particular header parameter and a check is made whether its string length is greater than 100. Notice the way the HTTP message model elements are accessed. Recall from that Parameter is a name value type of model element and Content Length is the name and the notation Parameter Content Length returns its value. An instance of a Rule element typically has three main parts 1 a Rule identifier that identifies the rule such as R01 2 a Condition such as NUM.GT STR.Length Request.Header. Parameter Content Length 100 and 3 Action such as Action.Log. In one or more embodiments the WASP rule schema contains several pieces of meta information such as name  id  description and the like those are useful for writing rules and JSON is used to write rules. One or more embodiments group together a set of rules that have some common purpose using RuleSet elements.

Condition and Action Element One or more embodiments use the Condition element to model rule conditions. One or more instances support a number of different condition operators such as regex matching numeric or string comparison. One or more cases use the Action element to model actions of a rule. A rule can trigger more than one action when the corresponding condition of the rule is satisfied. The attribute actionType is used to represent the action type. The action types such as Block Allow and Log are straightforward to understand. The Record variable value is useful when the runtime engine wants to manage state across different rule executions for instance supposing it is desired to know if a particular rule R01 had fired previously. In this case when rule R01 is fired its status will be recorded in a variable using Record variable value action. The action type Execute path will execute an external command referenced by a fully qualified path. The action type Rewrite is useful to rewrite values of certain elements such as rewriting the URL value. See generally block .

In this section two concepts are discussed the first is hierarchical rule binding and the second is rule inheritance.

Rule Binding Based on the HTTP message model and the rule model the next concept that is significant for a security administrator is to understand how to bind rules to HTTP messages. In one or more embodiments of WASP a rule can triggered only if it is bound to some message element. In other words unbounded rules can never be fired even if the condition of the rule is always true. A security administrator can use the RDT to bind rules to HTTP message models. illustrates a screen shot of rule binding using RDT illustrates binding using JSON format . The first step in the RDT is to create a new template based on the HTTP message model. The RDT will present the new template of the HTTP message model to a security administrator and the template will highlight all the elements of the HTTP message model. There are one or more entries for each element that can be filled in by the security administrator. For instance for the URLTemplate element the security administrator can fill in a URL that includes host name and file path nodes. The file path node could contain resource variables such as pid as discussed above . One or more embodiments use the URLTemplate instance as an index or key during runtime to retrieve the current HTTP model and or template instance. For the Header element one or more embodiments also create the set of headers that are allowable for the current HTTP model instance. Once the instances of all the elements of a new template are created the security administrator can then bind or associate one or more rules to each element by either using a pre existing set of rules or by developing new rules. For instance assume that Content Length header element is created for the following URL template instance .

At run time retrieve the HTTP message template instance using the aforementioned URL as index and then fire all the rules that are bound to various element instances. It should be noted that normalization of the message contents are usually required to be implemented in the WASF engine before executing the rules.

Web application developers often want the ability to express the layout of URLs that their application can respond to. To further elaborate consider the URLs that a particular Web application will handle. The Web REST application that processes the GET requests for the URLs will typically not create one static page for each resource. The Web application will construct a layout for the URLs and using URLTemplate the template can be created as at where pid and tid are resource variables. Model the above URLTemplate using the model as follows URL represents the instance of Hostname pizza pid topping and tid are instances of FilePathNode. For resources pid and uid also set the attribute is Variable to be true and the variableExpression is set to 0 9 indicating that it matches the numerical value pattern. The aforementioned URLTemplate can be represented using JSON as shown in .

Rule Inheritance Next consider how to inherit rules that are written for parent parts of the HTTP model. To understand the notion of parent use a URL structure to build a URL tree model. The motivation for inheritance is that most Web applications have a hierarchical structure. For instance the web.xml file which contains the configuration of a Web application describes a tree like structure for a Web application. To illustrate this further consider the URLs that are part of a sequence of HTTP messages.

A security administrator can write a set of rules for the resource pizza and this set of rules could apply to all descendants of the pizza node in the above URLs. In other words both order.php and enquire.php can inherit this rule. Now when an HTTP message with URL arrives construct an instance of the HTTP message model. The run time will then use the URL to access the message model for enquire.php and if the inheritParent attribute is set to true for the file path node enquire.php the rule bound to pizza will be inherited and applied to HTTP message model elements.

A second kind of rule inheritance that is supported in one or more embodiments is called the parameter inheritance. To further explain parameter inheritance consider a Web application that provide the three related URLS . The first of these URLs is the base URL that provide base query opportunity function. The second and third of these URLs with different stype provide two different techniques for a querying opportunity say stype 1 is a query by name and stype 2 is a query by time. From a business logic point of view the functions corresponding to the second and third of the URLs are subtype functions of the first URL. Thus from a security point of view the second and third URLs can inherit rules from the base URL. One or more embodiments model such rule inheritance for parameters by modeling parameters as a hierarchical structure.

One or more embodiments of WASP currently provide capabilities to transform rules from the ModSecurity format to HRS and also from HRS to the IBM DataPower firewall rule format. shows the HRS for the ModSecurity security rules shown in . The rule chaining in HRS is more expressive than the linear chaining rule in ModSecurity. In HRS one or more embodiments follow the classical forward chaining semantics where one or more conditions that are shared between rules are considered to be chained. Rules are chained in a tree like fashion using trigger action type. An action can contain more than one TRIGGER action. One or more embodiments share the conditions between chained rules and therefore the same condition is evaluated once for all rules. The ModSecurity chain rule for disruptive actions such as deny action is restricted to the first rule in the chain thereby creating unexpected side effects. For instance in ModSecurity a request will be denied only when all three rules in the chain trigger and all three non disruptive actions that set variables will be executed. In one or more embodiments the deny action is the last rule of the chain. In HRS all actions are performed as though they are standalone rules. This allows one to compose rules via chaining. One or more embodiments separate the deny rule R04 and its condition is set to true as seen in . Recall that for a rule to be triggered it should also be bound to a message. For HRS rule chaining only the first rule in the chain R01 needs to be bound to a message part such as content and the rest of the rules in the chain are triggered as a consequence of the chaining.

By way of a non limiting exemplary evaluation of the functionality of WASP compare WASP with two open source WAFs namely the Tomcat 7 filter and the aforementioned ModSecurity. First evaluate the architecture design the limitation for application code development if enabling WASF function and the capability to prevent new vulnerability. As shown in the table of it has been found that for WASP and ModSecurity the rule definition is independent of the rule engine. It is possible to create or update the rules to prevent a new vulnerability in WASP and ModSecurity and the firewall function is transparent to the applications meaning that no modification to application codes is needed. For the Tomcat 7 filter the security protection is implemented as multiple filters and the application developer needs to follow the framework to enable the security filters in the application codes. No rules definition is enabled in the Tomcat 7 filter.

Second evaluate the capability for the rules definition. Comparing to ModSecurity rules a significant feature for WASP HRS is the ability to support the RESTFul URL pattern definition and the validation for the dynamic input values embedded in the RESTful URL. Meanwhile HRS can support the URL based rule inheritance by defining the inheritParent attribute to the URL path node.

Third the virtual patching capability is implemented in WASP by using application context information and the AppScan tool. Then it is possible to further re test the rules using the RDT testing tool. The RDT is implemented as the RESTful service which provides the RESTful API for users to manage JSON based rule files in the WASP store house.

This section first compares the functionality for the Tomcat 7 filter ModSecurity and WASP and then describes non limiting exemplary experiences with WASP focusing on performance evaluation and usability for user experience.

To evaluate the performance impact of WASP experiments were conducted on 3 node machines connected via a high speed LAN. As shown in the table of one of the nodes is an Intel Core2 6700 2.66 GHz 3G RAM machine with the Windows server 2003 operating system. Two of the nodes are Intel Xeon 2 CPU 2.80 GHz 4G RAM machines with SUSE LINUX Enterprise Server 9. The nodes are connected to the Internet through a 1000M bps connection. The node with the Windows system is deployed with LoadRunner version 8.0 and mimics client browsers simulating multiple users by sending concurrent HTTP requests to the server application. Two of the nodes with SUSE are used on the server side to process HTTP requests. WASP is deployed on one of the nodes in the WebSphere proxy server version 7 and the other node is deployed with a WebSphere application server version 7 and IBM DB2 server version 9.0 registered mark of IBM . No other tasks were running on each node.

Based on the performance metric for application firewalls three metrics namely Maximum New Connections per Second Maximum Throughput per Second and Average Response Time are used for the performance impact evaluation. According to the WASP architecture shown in the design of the test cases is based on estimation of the potential major bottlenecks in the WASP runtime. Based on the analysis of the WASP runtime code structure the following four points are identified to be potential performance root causes and are tested in detail.

The setting of the test cases is shown in the table of . shows the average response time is 567 milliseconds without enabling rules in the WASP runtime engine and the average response time will increase to 195 milliseconds after enabling all the modules in WASP including the condition operator codecs module RESTful rewriting module and response handler. Meanwhile the maximum new connections per second will decrease 22 percent with all the modules enabled in WASP as in . plots the cumulative completed transaction ratio against time. Contrasting their performances it can be seen that after 1000 ms the success transaction completed ratio decreases from 100 for no rule enabled to 92 for all the modules enabled.

Due consideration has been given to the firewall rule language defined in DataPower ModSecurity and the like as well as the UML model defined in the WADL specification. One or more embodiments provide a WASP rule language HRS. One or more embodiments provide an HTTP message model defined in HRS which supports URLTemplate which can validate the dynamic input value embedded in dynamic URL to support more REST message s . HRS can express hierarchical fine grain and semantically rich rules to prevent a broad class of attacks in HTTP request and response. Based on HRS one or more embodiments implement the WASP rule management tool as a RESTful service to manage the JSON based rule files. In addition a rule transformation engine is implemented in the rule development tool which can transform the WASP rules to IBM DataPower rules.

In one or more embodiments four steps enable the virtual patching for firewall rules. Create the WASP rule template based on HRS and application context information. From application context information such as web.xml struts.xml or WADL file retrieve the URLTemplate especially for the dynamic RESTful URL. For the rule generation parse the XML report of a security testing tool AppScan to generateWASP messages and rules which will be processed by the runtime WASP engine.

One or more embodiments bridge the gap between the firewall and back end applications. For example in some current techniques when a non compliant character is detected in a server side firewall a static error page is thrown out to the end user which breaks the consistency of application logic and induces a bad user experience. The mechanism of smart error reporting according to one or more embodiments is different from these works and is enabled in a runtime firewall engine to protect on boarding applications. One or more embodiments are consistent with the existing application logics and no modification of application codes is required. Instead of throwing out a static error page to end users when some violation is detected in a runtime WASP engine a friendly error message and input backfill mechanism is designed to improve the user experience.

One or more embodiments provide a WASP rule language and meta model to handle most aspects of HTTP requests and responses including the application context. The application context is often encoded in one or more configuration files and or annotations that are part of the backend methods. One or more embodiments use the application context to develop fine grained and semantically rich WASF rules. Meanwhile a rule development tool is provided in one or more embodiments to illustrate how to develop security rules based on the WASP rule language.

Virtual patching is a process in which a security administrator will develop and deploy one or more rules on a Web Application Firewall WASF to prevent any exploitation of application vulnerability. One or more embodiments provide a mechanism for provisioning rules using application context and testing tool results for interactive virtual patching. An experimental prototype of has been developed in the context of a WASP project. Meanwhile the smart error reporting mechanism in the context of WASP is provided by one or more embodiments. Rather than simply throwing out a static error page to end users when a violation is detected in the firewall one or more embodiments provide usable security that provides friendly error messages with a backfill mechanism. The experimental evaluation shows that in one or more embodiments the user experience is improved by smart error reporting. Also this mechanism is consistent with the existing application logic and no modification of application codes is required in at least some instances.

Reference should now be had to the flow chart of which begins in step . Given the discussion thus far it will be appreciated that in general terms an exemplary method for operating a web application server firewall includes the step of intercepting at least one of an HTTP request message and an HTTP response message as well as the step of identifying a corresponding HTTP message model based on the intercepting step. The HTTP message model includes a plurality of message model sections. Further step includes parsing a representation of the HTTP request or response message into message sections in accordance with the message model sections of the HTTP message model. In the general case the representation could be the actual message but in a preferred approach the representation is a copy of the message copied by the connector and forwarded to the message handler as described above.

Additional step includes binding a plurality of security rules to the message model sections. The plurality of security rules each specify at least one action to be taken in response to a given condition. The given condition is based at least in part on a corresponding given one of the message sections i.e. the rule is applied by seeing if the corresponding sections in the actual message meet the condition specified for such sections in the rule itself . A further step includes processing the at least one of an HTTP request message and an HTTP response message in accordance with the plurality of security rules typically filtering bad messages and allowing good messages through .

Optional additional steps in the operating method include step building the corresponding HTTP message model and step developing the plurality of security rules.

In some instances steps and or further include causing at least one given one of the plurality of security rules which is written for a parent portion of the HTTP message model to be inherited for a child portion of the HTTP message model.

In some instances steps and or further include chaining at least two given ones of the plurality of security rules together based on at least the given condition being common to both of the at least two given ones of the plurality of security rules.

As will be discussed further below in some cases the method further includes providing a system wherein the system includes distinct software modules each of the distinct software modules being embodied on a computer readable storage medium. The modules can include for example a connector module a message handler module a rule development tool RDT module and runtime engine module . In such cases step is carried out by the connector module executing on at least one hardware processor steps and are carried out by the message handler module executing on the at least one hardware processor steps and are carried out by the rule development tool module executing on the at least one hardware processor and step is carried out by the runtime engine module executing on the at least one hardware processor. At least one hardware processor includes for example all steps executing on a single processor or for example steps and running on one processor and steps and running on another.

Continued reference should be had to the flow chart of . Given the discussion thus far it will be appreciated that in general terms an exemplary method for developing rules for a web application server firewall includes the step of anticipating at least one of an HTTP request message and an HTTP response message likely to be processed by the web application server firewall for example by a human expert . A further step includes building a corresponding HTTP message model based on the anticipating step. The HTTP message model includes a plurality of message model sections. Another step includes developing a plurality of security rules each specifying at least one action to be taken in response to a given condition. As discussed above the given condition is based at least in part on a corresponding section of an actual message. A further step includes binding the plurality of security rules to the message model sections.

In some cases the anticipation of at least one of an HTTP request message and an HTTP response message could be carried out externally and step could be based on externally supplied information about such anticipated message s .

In some instances steps and further include causing at least one given one of the plurality of security rules which is written for a parent portion of the HTTP message model to be inherited for a child portion of the HTTP message model.

In some instances steps and further include chaining at least two given ones of the plurality of security rules together based on at least the given condition being common to both of the at least two given ones of the plurality of security rules.

As will be discussed further below in some cases the method further includes providing a rule development tool system wherein the rule development tool system includes distinct software modules each of the distinct software modules being embodied on a computer readable storage medium. The modules can include for example a message modeling module a rule modeling module and a message rule binding module . In such cases step is carried out by the message modeling module executing on at least one hardware processor step is carried out by the rule modeling module executing on the at least one hardware processor and step is carried out by the message rule binding module executing on the at least one hardware processor.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

One or more embodiments of the invention or elements thereof can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps.

One or more embodiments can make use of software running on a general purpose computer or workstation. With reference to such an implementation might employ for example a processor a memory and an input output interface to a display and external device s such as a keyboard a pointing device or the like. The term processor as used herein is intended to include any processing device such as for example one that includes a CPU central processing unit and or other forms of processing circuitry. Further the term processor may refer to more than one individual processor. The term memory is intended to include memory associated with a processor or CPU such as for example RAM random access memory ROM read only memory a fixed memory device for example hard drive a removable memory device for example diskette a flash memory and the like. In addition the phrase input output interface as used herein is intended to contemplate an interface to for example one or more mechanisms for inputting data to the processing unit for example mouse and one or more mechanisms for providing results associated with the processing unit for example printer . The processor memory and input output interface can be interconnected for example via bus as part of a data processing unit . Suitable interconnections for example via bus can also be provided to a network interface such as a network card which can be provided to interface with a computer network and to a media interface such as a diskette or CD ROM drive which can be provided to interface with suitable media.

Accordingly computer software including instructions or code for performing the methodologies of the invention as described herein may be stored in one or more of the associated memory devices for example ROM fixed or removable memory and when ready to be utilized loaded in part or in whole for example into RAM and implemented by a CPU. Such software could include but is not limited to firmware resident software microcode and the like.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual implementation of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during implementation.

Input output or I O devices including but not limited to keyboards displays pointing devices and the like can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

As used herein including the claims a server includes a physical data processing system for example system as shown in running a server program. It will be understood that such a physical server may or may not include a display and keyboard.

As noted aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon. Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

It should be noted that any of the methods described herein can include an additional step of providing a system comprising distinct software modules embodied on a computer readable storage medium the modules can include for example any or all of the elements depicted in the block diagrams and or described herein. The method steps can then be carried out using the distinct software modules and or sub modules of the system as described above executing on one or more hardware processors such as 16. Further a computer program product can include a computer readable storage medium with code adapted to be implemented to carry out one or more method steps described herein including the provision of the system with the distinct software modules.

In any case it should be understood that the components illustrated herein may be implemented in various forms of hardware software or combinations thereof for example application specific integrated circuit s ASICS functional circuitry one or more appropriately programmed general purpose digital computers with associated memory and the like. Given the teachings of the invention provided herein one of ordinary skill in the related art will be able to contemplate other implementations of the components of the invention.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

