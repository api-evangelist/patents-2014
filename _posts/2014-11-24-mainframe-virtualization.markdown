---

title: Mainframe virtualization
abstract: Request data is identified that describes a request of a second program by a first program intercepted by a first exit in the first program. Response data is identified that describes a response by the second program to the request as intercepted by a second exit in the first program. A virtual service configured to model operation of the second program is instantiated based on the request data and response data. In another aspect, a request by the first program to the second program is intercepted by the first exit and the request is redirected to the virtual service. A response is received as generated by the virtual service and the response is returned to the first program using the second exit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09229766&OS=09229766&RS=09229766
owner: CA, INC.
number: 09229766
owner_city: Islandia
owner_country: US
publication_date: 20141124
---
This application is a continuation and claims the benefit of priority under 35 U.S.C. 120 of U.S. application Ser. No. 13 775 035 filed Feb. 22 2013 now issued as U.S. Pat. No. 8 898 681 and entitled MAINFRAME VIRTUALIZATION. The disclosure of the prior application is considered part of and is incorporated by reference in the disclosure of this application.

The present disclosure relates in general to the field of computer development and more specifically to testing involving a constrained system that may not always be available for use during testing.

Modern software systems continue to evolve and become more sophisticated with some systems and programs designed to interoperate with consume data or services from or otherwise depend on other programs or applications. However in instances whether the other programs or applications are not under the control of the entity controlling the particular program or application or otherwise constrained such other programs and applications may not be available to the entity when testing of the particular program or application is desired. For example an airline may be reluctant to test a new reservation application or client against the airline s live production database in order to avoid negatively impacting e.g. in terms of database record values or database response time actual consumer transactions that will be taking place at the same time as testing. Similarly in order to reduce costs a financial institution may wish to minimize interactions between a new credit card application system and a partner service due to per transaction fees such as those that are charged for each credit check charged by the partner service. In yet another example the constrained service may still be in development and thus not yet available to interact with the application under test.

According to one aspect of the present disclosure request data can be identified that describes a request by a first program to a second program the request data based on an interception by a first exit in the first program of a call to the second program by the first program. Response data can be identified that describes a response by the second program to the request the response data based on an interception of the response by a second exit in the first program. A virtual service can be instantiated based on the request data and response data. When executed the virtual service can model operation of the second program.

In another aspect of the present disclosure a call by a first program to a second program can be intercepted using a first exit of the first program associated with the call. The call can include a request of the second program and the request can be redirected to a virtual service configured to model operation of the second program. A response can be received to the call that was generated by the virtual service and the response can be returned to the first program using a second exit of the first program associated with the call.

As will be appreciated by one skilled in the art aspects of the present disclosure may be illustrated and described herein in any of a number of patentable classes or context including any new and useful process machine manufacture or composition of matter or any new and useful improvement thereof. Accordingly aspects of the present disclosure may be implemented entirely in hardware entirely software including firmware resident software micro code etc. or combining software and hardware implementations that may all generally be referred to herein as a circuit module component or system. Furthermore aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable media having computer readable program code embodied thereon.

Any combination of one or more computer readable media may be utilized. The computer readable media may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an appropriate optical fiber with a repeater a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable signal medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present disclosure may be written in any combination of one or more programming languages including an object oriented programming language such as Java Scala Smalltalk Eiffel JADE Emerald C CII VB.NET Python or the like conventional procedural programming languages such as the C programming language Visual Basic Fortran 2003 Perl COBOL 2002 PHP ABAP dynamic programming languages such as Python Ruby and Groovy or other programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider or in a cloud computing environment or offered as a service such as a Software as a Service SaaS .

Aspects of the present disclosure are described herein with reference to flowchart illustrations and or block diagrams of methods apparatuses systems and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable instruction execution apparatus create a mechanism for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that when executed can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions when stored in the computer readable medium produce an article of manufacture including instructions which when executed cause a computer to implement the function act specified in the flowchart and or block diagram block or blocks. The computer program instructions may also be loaded onto a computer other programmable instruction execution apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatuses or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring now to is a simplified block diagram illustrating an example computing environment including a virtual service system and mainframe systems . Mainframe systems can include high performance computers providing high volume processor intensive computing. In some implementations mainframe systems can be used within resource intensive business and scientific processes and can execute multiple programs and large amounts of data concurrently at a high speed. In other instances a mainframe system can also include lower power computing devices and be characterized by the architecture or operating system of the computing system such as systems employing or implemented using Customer Information Control System CICS middleware the IBM System z platform z OS z VSE UniKix Transaction Processing Environment and other transaction processing environments TPEs among other examples. Indeed principles of this description can be applied to other computing devices and systems not traditionally classified as a mainframes per se such as computing devices utilizing operating platforms and programs that apply features of architectures platforms and operating systems utilized in more traditional mainframes or including features similar to those described below. Indeed use of the term mainframe within this disclosure should be understood to cover or apply to such systems.

Further mainframe systems and other computing devices can include or host one or more software components such as various programs scripts objects applications modules among other software. In some implementations software components of mainframe systems may be designed so as to function collaboratively with or be otherwise dependent on other software components even software components hosted on other remote computing devices including other mainframe systems web servers and other sources over one or more networks . Such other software components can be implemented in some cases using different architectures operating systems and software platforms and can be in some instances controlled or owned by other entities.

Virtual service system can be used to generate and run virtual services modeling software components including software components of mainframe systems . Such virtual services can simulate operation of and act as stand ins for one or more software components within a test development educational training or other environment such as test environment provided using testing system .

In some implementations a virtual service can model software components not readily available for use with another software component upon which the other software component depends or with which the other software component is to interact. For instance the use of a particular software component modeled by a corresponding virtual service may be desirable in connection with testing or development of the other software component. Where the particular software component is constrained in that it is not available e.g. offline under maintenance under development etc. or when it would otherwise not be desirable to utilize the actual particular software component a corresponding virtual service can possess functionality allowing the virtual service to effectively stand in for the particular software component. For instance such virtual services can be configured to generate value and state aware responses to requests received from a real world software component such as a software component hosted by another mainframe system e.g. as well as model the performance characteristics of the modeled software component among other examples.

Further in some instances applications and other software components including software components of mainframe systems can additionally function to provide graphical user interfaces for users to interface with the application using one or more user computing devices e.g. . Further user computing devices e.g. can also be used to interface with virtual service system for instance to coordinate edit and provide further inputs in connection with the generation and maintenance of virtual service models simulating operation of one or more software components. For instance users can edit the models change assumptions or data relied upon by the models among other examples. Additionally user computing devices can be used to select particular software components to be virtualized using virtual services generated by virtual service system as well as select generated virtual services for deployment in one or more environments including testing environments hosted by testing system among other examples.

In general servers clients computing devices mainframes network elements hosts system type system entities user devices and systems etc. e.g. etc. in example computing environment can include electronic computing devices operable to receive transmit process store or manage data and information associated with the computing environment . As used in this document the term computer processor processor device or processing device is intended to encompass any suitable processing device. For example elements shown as single devices within the computing environment may be implemented using a plurality of computing devices and processors such as server pools including multiple server computers. Further any all or some of the computing devices may be adapted to execute any operating system including z OS z VSE Linux UNIX Microsoft Windows Apple OS Apple iOS Google Android Windows Server etc. as well as virtual machines adapted to virtualize execution of a particular operating system including customized and proprietary operating systems.

Further servers clients network elements systems and computing devices e.g. etc. can each include one or more processors computer readable memory and one or more interfaces among other features and hardware. Servers can include any suitable software component or module or computing device s capable of hosting and or serving software applications and services including distributed enterprise or cloud based software applications data and services. For instance in some implementations a virtual service system testing system or other sub system of computing environment such as an environment in which models are to be instantiated and run can be at least partially or wholly cloud implemented web based or distributed to remotely host serve or otherwise manage data software services and applications interfacing coordinating with dependent on or used by other services and devices in environment . In some instances a server system subsystem or computing device can be implemented as some combination of devices that can be hosted on a common computing system server server pool or cloud computing environment and share computing resources including shared memory processors and interfaces.

While is described as containing or being associated with a plurality of elements not all elements illustrated within computing environment of may be utilized in each alternative implementation of the present disclosure. Additionally one or more of the elements described in connection with the examples of may be located external to computing environment while in other instances certain elements may be included within or as a portion of one or more of the other described elements as well as other elements not described in the illustrated implementation. Further certain elements illustrated in may be combined with other components as well as used for alternative or additional purposes in addition to those purposes described herein.

In some instances a first software component can be dependent on another software component or system of software components. When the other software components are unavailable or otherwise constrained use of the first software component can be impeded. For instance if operation of the first software component in a test a training environment or development environment is to rely at least in part on the first software components interactions and interoperation with the other software component the test training session etc. can be jeopardized by the unavailability of the other software component. In traditional systems stubs or piecemeal responders could be manually developed by a team in an attempt to partially model responses of the unavailable software component. The development of such models however can be a time intensive and expensive process as the entity conducting the testing training development etc. is forced to divert valuable resources to the development of a stand in component. Further traditional stubs or responders are limited in their functionality in that they typically provide dumb or canned responses to requests among other limitations. Additionally in one example services implemented in a CICS transaction server or mainframe can be difficult to simulate. Services implemented in CICS can span multiple CICS regions. Automating the generation of a model of the services and software components within a CICS or other mainframe environment can be particularly difficult among other issues.

At least some of the systems described in the present disclosure such as the systems of can at least partially address at least some of the above discussed issues as well as others not explicitly described. For instance turning to the example of a simplified block diagram is shown illustrating an example environment including a virtualization engine adapted to generate service models that can be deployed as virtual services modeling one or more software components e.g. programs hosted by mainframes etc. . A virtual service engine can also be provided through which the virtual services e.g. can be instantiated. Such virtual services can be used for instance in a test facilitated using a testing engine among other examples.

An example virtualization engine can include in some implementations one or more processor devices e.g. one or more memory devices e.g. and other hardware and software components including for instance service model generator a virtual service instantiation engine among other example components including components exhibiting other functionality or components combining functionality of two or more of the above components among other examples. A virtualization engine can be used to generate and manage virtual services. Service models can be generated in some implementations for processing by a virtual service engine using for instance a service instantiator to construct a virtual service e.g. from service models e.g. generated by virtualization engine . The virtual service can be executed and hosted within a virtual service environment such as a virtual service environment implemented using one or more virtual machines or another environment. A virtual service engine can include one or more processor devices and memory elements among other software and hardware components. In some implementations functionality of virtual service engine can be combined with or included in functionality of the virtualization engine . For instance in some implementations virtualization engine can both construct service models as well as instantiate virtual services e.g. from those service models among other potential implementations that may be used in the generation of virtual services.

In one example service models can be generated by virtualization engine e.g. using service model generator based on detected requests and responses exchanged between two or more software components or systems such as programs and . Such request and response information can be captured for instance using agents e.g. deployed for instance in a region e.g. of a mainframe e.g. among other examples. Data describing such requests and responses as well as characteristics of the requests and responses can be embodied for example in transaction data . In some implementations service model generator can build service models from transaction data .

In one particular example a service model generator can generate and store information in service models identifying one or more characteristics of the transactions described in transaction data . Such information can include performance information describing performance characteristics of the transactions and the programs to be modeled such as timing information identifying times at which particular requests and or responses are detected or sent e.g. in order to identify the delay between when the request was detected and or sent and when the associated response was detected and or sent information identifying current bandwidth usage of a network on which the traffic is being conveyed information identifying current processor and or memory usage on one or both of the computing devices implementing a corresponding requester software component and server software component and the like. Virtual services instantiated from such service models can embody the performance characteristics captured or defined in the service model including response times network bandwidth characteristics processor usage etc.

In one example a service model generator can be configured to identify requests and responses from transaction data in each of a variety of different protocols and to extract and record the pertinent information from each. Thus service model generator can include configuration information identifying the basic structure of requests and responses for each of several supported communication protocols. When generating service models service model generator can access the appropriate configuration information in order to process the observed traffic. Depending upon the protocol in use for instance requests can take the form of method calls to an object queue and topic type messages e.g. such as those used in Java messaging service JMS requests to access one or more web pages or web services database queries e.g. to a structured query language SQL or Java database connectivity JDBC application programming interface API packets or other communications being sent to a network socket and the like. Similarly responses can include values generated by invoking a method of an object responsive messages web pages data state values e.g. true or false and the like.

Transaction data can be collected from one or more monitoring tools e.g. agents agent managers etc. configured to gather data from logic such as CICS or other exits logically inserted within a communication pathway between a transacting client or requester software component and a server or responding software component. Transaction data can also be obtained through other monitoring techniques including the monitoring of appropriate queue s and topics for new messages being exchanged between a requester component and responding component communicating via messaging intercepting method calls to a particular server component e.g. object and so on. Further monitoring tools can also intercept responses from the responding software component and corresponding information in transaction data can be generated that identifies those responses as corresponding to requests of a particular requester component among other examples. Indeed in some implementations transaction data can be generated from an image captured by an agent e.g. that identifies a request response pair among other examples.

Transaction data can further document attributes of requests and responses detected within a particular transaction. For example a request can include an operation and one or more attributes. As an example transaction data can identify a command to perform a login operation as well as attributes that include the user name and password to be used in the login operation. Accordingly service model generator can also parse requests identified in transaction data in order to identify whether any attributes are present and if so to extract and store information identifying those attributes. Thus information identifying a request in a corresponding service model e.g. can include information identifying a command as well as information identifying any attributes present within the request. Similarly for responses a service model generator can parse transaction data to identify responses and response attributes e.g. using protocol specific configuration information in order to determine how to locate the attributes within the response and incorporate such information in service models identifying the response.

Service models can be used as the basis of virtual services modeling the software components providing the requests and or responses modeled in the service models . Virtual services can capture and simulate the behavior data and performance characteristics of complete composite application environments making them available for development and testing at the request of a user or system and throughout the software lifecycle among other advantages. In some instances a virtualization engine can include functionality for the creation of complete software based environments using virtual services that simulate observed behaviors stateful transactions and performance scenarios implemented by one or more software components or applications. Such virtual services provide functionality beyond traditional piecemeal responders or stubs through logic permitting the recognition of input requests and generation of outputs responses that are stateful aware of time date and latency characteristics support such transaction features as sessions SSL authentication and support string based and dynamic request response pairs among other features. Service virtualization and other virtual models can be leveraged for instance when live systems are not available due to project scheduling or access concerns. In cases where components have not been built yet environments can employ virtual services to rapidly model and simulate at least some of the software components to be tested within an environment. Virtual services can be invoked and executed in a virtual environment implemented for instance within on premise computing environments in private and public cloud based lab using virtual machines traditional operating systems and other environments among other examples. In some implementations virtualization system and virtual services e.g. and other supporting components can utilize or adopt principles described for example in U.S. patent application Ser. No. 13 341 650 entitled Service Modeling and Virtualization incorporated herein by reference in its entirety as if completely and fully set forth herein.

In some implementations when a service model is used to instantiate a virtual service the virtualization process can involve comparing new requests generated by a requester e.g. a client application under test or development to the request information stored in a corresponding service model. For example if a new request containing a particular command and attribute is received the service model can be searched for a matching request that contains the same command and attribute. If a matching request is found the virtualization process returns the response as identified by information stored in service model associated with the matching request to the requester.

In many situations the requests provided to a virtual service will not be exactly the same i.e. containing the same request as well as the same attribute s as the requests identified in service model. For example a request provided to the corresponding virtual service may contain the same request but a different attribute or set of attributes. A service model can further include information usable to handle these requests. For instance transactions containing requests that specify the same command can be identified as being of the same transaction type. Alternatively a set of transactions can be identified as being of the same type if all of those transactions have requests that include the same command as well as the same number and type of attributes. The particular technique used to identify whether two or more transactions are of the same type can be protocol specific in some embodiments e.g. classification of transactions can be at least partially dependent upon the particular communication protocol being used between the requester and the server .

For each unique type of transaction included in a service model some implementations of a service model can further provide information or instructions for use by a virtual service in generating responses to requests with unknown attributes e.g. an unknown attribute that was not observed as part of the monitored traffic or even specified by a user during a manual service model building process . Further service models can also include information describing how to respond to an unknown request e.g. a request that contains a command that was not observed as part of the monitored traffic . As an example the request portion of this service model information can indicate e.g. through the use of a wildcard command identifier that all unknown types of requests that are not otherwise identified in service model should match this request. The response portion of the generated information can include an appropriate response among other examples.

In addition to adding information describing unknown transactions of known and unknown types some implementations of service models can support time sensitive responses. In such embodiments response information in the server model can facilitate substitution of time sensitive attributes for actual observed attributes. For instance an actual attribute 10 59 PM Oct. 1 2009 can be replaced with a time sensitive value such as SYSTEM CLOCK 11 HOURS . When the service model is used to generate responses by the virtual service the time sensitive value can be used to calculate the appropriate attribute to include in each response e.g. based on the current system clock value . To illustrate in this particular example if the service model is being used by a virtual service and the response attribute includes the time sensitive value SYSTEM CLOCK 11 HOURS the response generated based upon the service model will include the value generated by adding 11 hours to the system clock value at the time the request was received. In general time sensitive values specify an observable time such as a time value included in a request or the current system clock time and a delta such as an amount of time to add or subtract from the specified observable time. Time sensitive values can be included in the response information for all types known and unknown of transactions.

In some implementations a service model can further include information facilitating the use of request sensitive values to be included in responses generated by the virtual service using the service model. A request sensitive value can link an attribute included in the request to a value to be included in the response. For example response information in a service model can indicate that a particular request attribute be used as the basis of a particular attribute of the response to be returned in response to the request.

When the model is used the response generated by the virtualized service will include the value indicated by the request sensitive value. For example the model can include three known transactions of a given transaction type as well as one unknown transaction of that type. The information describing the unknown transaction can indicate that the single response attribute is a request sensitive attribute that should be the same as the first attribute of the request. A request of that type that contains an unknown first attribute i.e. an attribute that does not match the attribute s stored for the three known transactions of that type in the model can be sent to the virtualized service. In response to receiving this request and accessing the request sensitive value specified in the response information for the unknown transaction the virtualized service returns a response that includes the value of the first attribute that was contained in the received response. As an example if the information describing a known transaction of type A indicates that the request includes the string UserID as the first request attribute and that the corresponding response includes the string UserID as its second response attribute a request sensitive value specifying REQUEST ATT 1 first request attribute can be generated for the second response attribute in the service model among many other potential examples including more complex examples with more complex dependencies defined in the service model between certain request attribute and request sensitive response attributes.

A service model can include still additional information. For example a service model can identify characteristics of each transaction in order to identify availability windows for a corresponding software component modeled by the service model load patterns for the software component and the like. For example if an access window is identified for a particular type of transaction a corresponding service model can be generated to include a characteristic indicating that a response or a particular type of response will only be generated if the request is received during the identified access window among many other potential examples.

Turning briefly to a simplified block diagram is shown representing an example view of an example service model . For instance shows information that can be maintained as part of a service model. In this particular example service model can include a row for each of several transactions. Each row of service model can identify a command zero or more attributes zero or more characteristics and one or more response attributes. This service model can be stored in a spreadsheet table database or any other data structure.

In this example transaction A can be a transaction that was an observed transaction that actually occurred between a requester and a server component being modeled as detected for instance by an agent or other tool. The information describing transaction A can include request information which includes command and zero or more defined attributes . The information describing transaction A can also include response information describing the expected response that corresponds to the request. This response information can also include one or more attributes. Characteristics can include zero of more characteristics of transaction A observed during monitoring of the transaction. These characteristics can include timing information describing a threshold delay of a response to a request or the like as described above.

Transaction B can be of the same transaction type as transaction A since both transactions included a request that contained command . Transaction B is described by attributes which can have values that differ from those attributes defined in the request of transaction A characteristics which can again differ from those for transaction A and response which can also have a value that differs from the response defined for transaction A .

In this example information describing n an integer number known transactions of the same type as transactions A and B can be stored in service model . As part of the model building process information describing an n 1th transaction of the same type has been added to service model by the service model generator. This n 1th transaction labeled transaction 1 can describe an unknown transaction of a known type of transaction. Such an unknown transactions is of a known type because it has the same command command as the other transactions of this type. However unlike the other known transactions of this type unknown transaction 1 can be used to respond to requests containing command and unknown attributes that do not match those known attributes stored for transactions A not shown . The information describing transaction 1 thus includes information e.g. wildcard information identifying unknown attributes 1 such that any request that includes command and an attribute that does not match the defined attributes stored for the actual transactions e.g. such as transactions A and B will match the request information for transaction 1 . The information describing transaction 1 can also include default characteristics 1 and default response 1 . These default values can be copied from the corresponding fields of an actual response of the same type.

Information describing another set of transactions of a different type can also be stored within the service model for a particular software component. As shown m 1 transactions including transaction A B and 1 of a type of transaction in which the request includes command can be stored in service model . Like transactions A and B transaction A can be another transaction observed through monitoring of a particular software component or set of transactions involving the particular software component. Further the information describing this transaction can also include the corresponding command attributes if any defined characteristics if any and corresponding response .

In some instances a model generator can automatically generate a set of requests and responses together with corresponding attributes and characteristics of the requests and responses based on transaction data provided to the model generator. In some implementations a user can supplement the transaction defined by the model generator with one or more user specified transactions for instance to capture a nuance not adequately detected and captured by the model generator among other examples. For instance a user can enter the information describing such a transaction via a user interface. The information describing transaction B can include command zero or more user specified attributes zero or more user specified characteristics and a user specified response . In some embodiments the user is prompted for entirely new information for each of these user specified fields. In other embodiments the user can be allowed to select an existing field e.g. of another user specified transaction or of an automatically detected transaction to copy into one or more of these fields. It is noted that a user can also create a user specified transaction by modifying information describing an actual transaction. As shows user supplied transaction information can be stored in the same model as transaction information generated from parsing of image or transaction data received for instance from monitoring of programs and transaction in a mainframe system.

In some instances a service model can also include information describing an unknown transaction 1 . The information describing transaction 1 was added to service model after m an integer number which does not necessarily have the same value as n known transactions were described by the model. The information describing this unknown transaction 1 can be used to handle requests of the same type e.g. containing command that specify unknown attributes. Accordingly the information describing transaction 1 can include command unknown attributes 1 i.e. attribute information that will match any attributes not identified in the known attributes stored for the other m transactions of this type default characteristics 1 and default response 1 . Further transactions of an unknown transaction of unknown type e.g. can also be defined in a service model . For instance the information describing transaction can be used to respond to any request of a type not already described by another row of service model . Accordingly a request containing a command other than commands and could be responded to using the information describing transaction among other examples. As shown the information describing transaction includes unknown command information which is configured to match any command not already specified in service model unknown attribute information which is configured to match all attributes if any associated with unknown commands default characteristics and a default response . As with the default characteristics and responses associated with unknown transactions of known type transaction s default characteristics and response can be user specified.

Turning now to a simplified block diagram is shown illustrating representing example features of an example service model for use in virtual services supporting stateful and stateless transactions. Statefulness of a transaction can be identified from parsing of observed transaction data to generate a service model supporting the modeling of such stateful transactions. In the example of a data model is shown that includes five data patterns traffic pattern conversation pattern transaction pattern request pattern and response pattern . Each service model can include a single instance of traffic pattern . As shown traffic pattern includes created field which stores date information identifying when the service model of that particular application was initially created. Traffic pattern also includes lastModified field which stores date information identifying the most recent time at which any of the information in the service model of the particular service was modified.

Traffic pattern can also include an unknownResponse field . UnknownResponse field can store information identifying the particular instance of the response pattern that stores information identifying the response to use for unknown transactions of unknown types. Accordingly in embodiments employing the data pattern of if an unknown transaction of unknown type is detected by a request processing module the request processing module will use the response pattern instance identified in unknownResponse field to generate a response.

Traffic pattern includes conversations field . Conversations field can identify one or more instances of conversation pattern . Conversation pattern stores information representing a set of two or more stateful transactions. Such a set of stateful transactions is referred to herein as a conversation. The instance s of conversation pattern identified in conversations field identify all of the conversations for the application to be modeled. If the particular service does not include any stateful transactions e.g. if no stateful transactions are identified from transaction data describing the observed transactions conversations field will not identify any instances of conversation pattern .

Traffic pattern can additionally include statelessConversation field . This field can identify one or more instances of transaction pattern . Transaction pattern stores information representing a transaction. Each instance of transaction pattern identified in statelessConversation field stores information identifying a stateless transaction. StatelessConversation field can identify instances of transaction pattern associated with both known and unknown transactions of known types. If the particular service being modeled does not include any stateless transactions statelessConversation field will not identify any instances of transaction pattern . Type field can store one of two values INSTANCE or TOKEN that identifies the type of stateful transactions if any provided by the service being modeled.

As noted above conversation pattern can store information identifying a set of stateful transactions. A given service model can include n instances of conversation pattern where n is an integer that is greater than or equal to zero. Conversation pattern can include a starter field . This field stores information identifying an instance of transaction pattern associated with a starter transaction. The starter transaction is a transaction that acts as the first transaction in a stateful series of transactions e.g. a login transaction . In at least some embodiments all starter transactions can be unknown transactions of known type as will be described in more detail below. The particular transaction type to use as a starter transaction can be specified by the model generator or a user during the service model configuration process.

Conversation pattern also includes reset field . Reset field stores information identifying one or more instances of transaction pattern each of which is associated with a reset transaction such a reset transaction can be a known or unknown transaction . The value of reset field can be provided by a user e.g. the user can be prompted to identify the reset transaction s for each conversation . A reset transaction is a transaction that if detected causes the flow of the conversation to return to the point just after performance of the starter transaction. Conversation pattern also includes a goodbye field . This field stores information identifying an instance of transaction pattern associated with one or more goodbye transactions of known or unknown type for the conversation. A goodbye transaction is a transaction that causes the conversation to end. To reenter the conversation after a goodbye transaction is performed the starter transaction for that conversation would need to be re performed.

Transaction pattern stores information identifying a transaction. Transaction pattern includes request field responses field parent field children field and matchTolerance field . Transaction pattern can be used to store stateful and stateless transactions in some instances the same transaction can occur both within a conversation and in a stateless situation where no conversation is currently ongoing . Transactions that are always stateless will not include values of parent field children field or matchTolerance field .

Request field identifies the instance of request pattern that stores information identifying the request e.g. by command and attributes portion of the transaction. Similarly responses field identifies one or more instances of response pattern that store information identifying the response s that are part of that transaction. Each instance of response pattern stores one response attribute e.g. like those shown in and thus if responses field identifies multiple response patterns it indicates that each of the identified response patterns should be used to generate a response when the corresponding request is received.

Parent field stores a value identifying the instance of transaction pattern associated with the transaction that occurs immediately before the current transaction in a conversation. Thus if transaction pattern stores information identifying the second transaction in a conversation where the starter transaction is the first transaction in the conversation parent field can identify the instance of transaction pattern associated with the starter transaction. Similarly children field can store information identifying each instance of transaction pattern associated with a child transaction of the current transaction. Thus if transaction pattern stores information identifying the second transaction in a conversation children field can store information identifying the instance of transaction pattern that stores the third transaction in the conversation. It is noted that children field can identify more than one transaction.

MatchTolerance field can store one of three values STRICT CLOSE or LOOSE. The stored value indicates the match tolerance for a request received immediately subsequent to the current transaction. Strict tolerance indicates for instance that if a conversation is ongoing the request received immediately after the current transaction is only allowed to match transactions identified in the current transaction s children field . If instead close tolerance is specified the request received immediately after the current transaction can match any of the current transaction s children as well as any of the current transaction s sibling transactions. Further if loose tolerance is specified even more transactions are candidates for matching the next received request and so on.

Request pattern can include a command field attributes field and characteristics field . Each instance of request pattern stores information identifying a particular request. A service model generator can allocate an instance of request pattern for each transaction of known or unknown type. Command field can store a string that identifies the command contained in the request. Attributes field can store a parameter list that includes zero or more parameters each of which represents an attribute of the request. Characteristics field can store a parameter list identifying zero or more characteristics associated with the request. Each parameter in the list can identify a different characteristic. Examples of characteristics can include the time at which the request was sent the system clock time at which the request was received by the service being modeled network and or system conditions that were present when the request was received and the like. The parameters stored in characteristics field can be used to generate time sensitive values as well as to model actual conditions such as response timing and availability window among other examples.

Response pattern can include an attribute field and a characteristics field . Attribute field stores a string that represents a response attribute. As noted above a given transaction can have multiple response attributes e.g. responses field of transaction pattern can identify multiple instances of response pattern and thus generating a response can involve accessing multiple response patterns in order to include the string identified in each of the response patterns attribute field in the response. Attribute field can store a response attribute as well as values like request sensitive values and time sensitive values generated by the service model generator. Characteristics field can store a parameter list containing zero or more parameters. Each parameter can identify a characteristic of the response such as the system clock time when the response was sent to the requester by the service network and or system conditions that were present when the response is to be sent and the like.

Returning to the discussion of example computing environment can include one or more computing devices such as mainframes hosting one or more programs that can be virtualized through the monitoring of requests and responses transactions involving the respective program using one or more agents e.g. . A mainframe can include one or more processor devices and one or more memory elements e.g. . A mainframe in one example can include one or more logical partitions LPARs e.g. that logically divide processor memory and storage resources that can be utilized independently with its own operating system instances and programs. Further one or more regions e.g. can be included within a mainframe . A region e.g. can be a collection of mainframe resources controlled as a unit and used within the system to perform one or more tasks. Such resources can include for example programs e.g. Basic Mapping Support BM map sets transactions terminals files transient data queues temporary storage queues among other examples.

In some implementations mainframe programs e.g. can include one or more commands and one or more user exits or exits . Such exits can be a point within a program at which control can be transferred to another program e.g. in connection with a call or other command . An exit can also be used to return control when the other program has finished its work. For instance in the particular example of CICS a LINK command can be used to invoke a call of one program to another program including programs on other CICS regions other LPARs or other mainframe machine. In one example the LINK command can be preceded and followed by respective exits such as the CICS XPCREQ exit and CICS XPCREQC exit.

In one implementation specialized exits can be defined and installed onto a program to be monitored and virtualized. The specialized exits can monitor characteristics of a call being made to another program e.g. through a CICS LINK command as well as the response to the call. The exits or other logic can observe and record transaction information describing the nature of the request s and response s passing through the exits. Further exits can provide such transaction information to one or more agents e.g. . An agent manager e.g. can collect such transaction information from the agents on a particular LPAR or mainframe device and communicate this information to virtualization engine as transaction data e.g. for use by the virtualization engine in generating a service model and virtual service to model one or more of the mainframe programs involved in the observed transactions among other examples.

In some example implementations a testing engine can be used in connection with the execution of a virtual service e.g. . An example testing engine can include for example one or more processor devices e.g. and one or more memory elements e.g. for use in executing one or more components tools or modules or engines such as a test instantiator and testing environment among other potential tools and components including combinations or further compartmentalization of the foregoing. Test instantiator can be used to load one or more predefined test sets that include for instance data for use in causing a particular software component under test to send a set of requests to a server software component. In some instances the server software component or server system hosting the server software component can be replaced by one or more virtual services provided through virtualization engine . Test sets can include additional instructions and data to cause the one or more virtual services to be automatically instantiated e.g. using virtual service instantiation engine and or virtual service engine etc. for use in the test. Further test sets can also identify particular conditions to be applied in the tests of the particular software component including the identification of particular performance characteristics to be used to model particular conditions within the test among other examples.

Turning to a simplified block diagram is shown illustrating an example of a virtualization engine in connection with one or more CICS mainframes and one or more clients . In the particular example of each mainframe can include one or more LPARs . Each LPAR can have one or more regions e.g. . Programs and other software components can be implemented in the regions . Further each region can be provided with an agent e.g. such as CICS LINK agents that can function in connection with exits or other logic employed in connection with a CICS LINK command to intercept or record request and response information as well as other transaction information relating to a call from one program to another using the LINK command. Such LINK commands can involve calls from one program in one region e.g. to another program in another CICS region including regions e.g. within the same LPAR or regions e.g. of another LPAR e.g. or mainframe device e.g. .

Agents can collect transaction data and communicate the transaction data to an LPAR agent or LPAR agent manager e.g. corresponding to the agent s respective LPAR e.g. . The agent manager can in some implementations serve as a clearinghouse for all transaction data collected by agents e.g. on their respective LPAR e.g. that is to be communicated to virtualization engine for use by the virtualization engine in generating virtual services from the transaction data. In some implementations virtualization engine can be implemented on computing devices remote from mainframes . In such instances transaction data collected by agents can be routed through respective agent managers for transmission using a central socket e.g. of the agent manager to one or more computing systems hosting the virtualization engine . While in other embodiments each agent can include its own socket and agent managers can be omitted such implementations may be problematic in systems utilizing an aggressive firewall or other network security policies and protections. For instance security policies of a particular mainframe may make it difficult for multiple different sockets to be opened each pointed toward virtualization engine without raising an alert or otherwise complicating administration of the overall mainframe system among potentially other issues.

Multiple clients can have access to and consume services of a virtualization engine . Each client e.g. can initiate recording of various transactions involving various programs on regions of various CICS mainframes. Indeed such recordings can be carried out concurrently and transaction data generated during the recordings of such transactions can be communicated over sockets to virtualization engine for processing. Further clients can also be used to deploy virtual services generated through virtualization engine . For instance various clients e.g. can each request that a respective virtual service be instantiated in a virtual service engine for use by the CICS programs. For instance different CICS users can use the clients to perform varying tasks e.g. testing development trainings etc. utilizing different virtual services simulating different programs including programs of mainframes all provided through virtualization engine among other examples.

Turning to simplified block diagrams are shown illustrating example techniques included in the virtualization of an example mainframe program. For instance in two regions of one or two mainframes are shown. The first region includes a program that makes a call to another second program on the second region . In some implementations transactions between the first program and second program can be monitored to automatically generate a service model that can be used to instantiate a virtual model to simulate the operation of the second program . For instance in the particular example of a call from program to program can invoke an exit to transfer control to a communication or function call command e.g. CICS LINK CICS XCTL and others that will facilitate the call of the second program . Included in the call can be a request including an operation and one or more attributes as well as potentially additional or other characteristics. The exit can be configured to capture an image e.g. of the call including the request . Data describing the image can be communicated or otherwise made available to agent . The request can proceed to the second program through the function control command. The second program can in turn process the request and generate a response . In some implementations the second program can make calls of its own to still other programs not shown in connection with the generation of the response . The response can be returned to the first program through an exit . The exit can also be configured to capture an image e.g. of the response communication that can be communicated to the agent .

Exits can be configured to operate in multiple different modes. Agent in some implementations can be configured to pass or otherwise communicate an instruction for use by the exits to indicate the mode the exits are to operate in within a particular transaction or set of transaction. For instance exits can operate in any one of a recording mode playback mode and pass through mode. In the case of a recording mode exits can operate as illustrated in allowing function calls requests and responses to proceed while monitoring and recording characteristics of the requests and responses and reporting this information to an agent e.g. . The agent in the particular example of can obtain or generate transaction data from the images e.g. recorded by the exits and communicate this transaction data to agent manager to be forwarded to a virtualization engine . In other instances the transaction data can include the image data itself. The virtualization engine can utilize the transaction data e.g. stored as transaction data to generate a service model from which a virtual service can be instantiated.

When exits operate in playback mode the exits can function to allow the first program to operate with a virtual service simulating operation of the second program . For instance turning to a virtual service is instantiated in a virtual environment of virtual service engine from a service model documenting one or a plurality of transactions requests and responses observed between programs and e.g. according to the techniques shown and described in connection with . In one example a user can request virtualization of the second program using virtual service in response to determining that program is unavailable or otherwise constrained. The user request can cause the agent to set exits in playback mode. Program can function as before and make a function call to program . However with exit in playback mode exit can capture an image of the request included in the call and communicate the request to agent . The agent can forward the request through agent manager to the virtual service rather than program . The exit can accomplish this for instance by invoking a bypass of the function call. Such bypass functionality can be a standard operation capable of being performed by a base version of an exit such as the CICS XPCREQ exit among other potential example exits that provide an option to bypass a command for security load balancing system maintenance or other reasons. This bypass functionality can be leveraged in a specialized exit adopting some or all of the functionality of these base versions of an exit but further adapted to operate with an agent virtualization engine virtual service engine etc. For instance the bypass can cause the request to be held and not delivered to the second program so as to allow the request to be redirected for servicing by a virtual service modeling the second program among other examples.

Upon being passed data identifying the request and its respective operation attributes parameters and other characteristics virtual service can operate to intelligently mimic the functionality of the second program including simulating performance characteristics of the program among other features captured from transaction data resulting from the monitoring of transactions involving program . The virtual service can further generate a simulated response e.g. applying at least some of the features described elsewhere herein that can be passed to agent manager . Agent manager can identify the agent e.g. to which the response applies e.g. the agent from whom the corresponding request was received and pass the response to the agent . Further exit operating in playback mode can identify the response through agent and provide the response to the first program as if the response had actually been provided by the second program . In other words the first program can be completely ignorant of the use of virtual service in the place of second program . Indeed first program can accept the response and continue operation in some cases further operating upon the data included in the response among other examples.

In addition to operating in recording and playback mode exits can additionally operate in other modes including a pass through mode. In pass through mode for instance exits can effectively turn off their specialized functionality and function as traditional exits for use with a function call e.g. as typical XPCREQ and XPCREQC exits . In pass through mode exits can be used to pass control to a LINK command for instance allowing requests and responses to be passed between programs without recording of the transactions or reporting the transactions to the agent among other examples.

Turning to a simplified block diagram is shown of an example implementation of an agent and mainframe in a CICS mainframe. While the example of is specific to CICS it should be appreciated that principles of this example as well as others can be applied to other non CICS implementations. In the particular example of a CICS region e.g. can be provided in a z OS LPAR . Agent can be a CICS LINK agent and each CICS region e.g. can include an agent e.g. . Further LPAR can include an LPAR agent or agent manager that can receive transaction data collected at multiple different CICS regions by respective CICS LINK agents. In the example of specialized exits e.g. can be installed in the region . In some cases specialized exits can exist in addition to instances of a XPCREQ and XPCREQC exit included in the programs of region . XPCREQ virtualization exit and XPCREQC virtualization exit can be provide functionality such as described in the examples of for capturing information concerning request and responses communicated in connection with a CICS EXEC LINK command in a corresponding program. Initialization of the exits and agent can be started during CICS startup program list table PLT processing in some instances. In other instances agent and exits can be installed and initialized by manually invoking the install exits transaction among other examples.

In addition to installing specialized exits installation transaction can act to install an agent on the region together with an exit global work area or work area . The work area can function as a mailbox in which messages and other data can be passed between exits and agent . For instance specialized exits can capture requests and responses between two programs as images e.g. . Such images can be recorded and grouped together by transaction simplifying the association of a request with its response e.g. for inclusion in a corresponding service model . Further exits can operate to pass an image it records and continue with the transaction being monitored while the agent asynchronously obtains and processes the information included in the image. Indeed in some instances images captured by a single pair of LINK exits e.g. can be queued in work area . The agent can monitor progress of a transaction through data deposited in work area and wait for a response image to be returned by an exit e.g. that corresponds to an earlier captured request image returned by exit . The agent can then access the images in the work area process the images and pass corresponding transaction data describing the images request s and response s to LPAR agent manager . In some implementations agent can utilize configuration information to identify the LPAR agent manager and also assist the LPAR agent manager in identifying the agent as responsible for the monitoring and virtualization of this transaction. The LPAR agent manager can communicate the received transaction data over TCP IP to a mainframe bridge facilitating communication of the transaction data to a virtualization engine e.g. .

Specialized exits can also be used to facilitate communication and interoperation between a program and one or more virtual services generated from transaction data obtained through the specialized exits resulting from the monitoring of observed transactions involving the program and a second program virtualized using the virtual service s . A playback image can be captured by exit when in playback mode and the playback image can be made available through work area . The agent can obtain the playback image describing the request and communicate the request to the virtual service through LPAR agent manager and mainframe bridge . The instantiated virtual service can receive the request and generate a response based on the request. Further the response of the virtual service can be transmitted through mainframe bridge to LPAR agent manager for forwarding on to agent . The agent can pass the virtual service s response or construct an image describing the response and make the response available to the exit through work area . The exit can access the virtual service s response and provide the response to the requesting program to simulate the response of the software component modeled by the virtual service.

In some installations and embodiments features can be included to assist CICS administrators in monitoring the health of their system and the effect of the specialized exits work area agent etc. on the overall operation and health of the system e.g. . For instance an example monitor transaction can be provided that allows an administrator to view aspects of the work area and agent s operation. For instance the administrator using monitor transaction can view the status of the agent and exits the work area recording and playback counts start and stop agent and exits and check the respective depths of queue such as a recording queue of recorded images e.g. a playback queue of playback images e.g. to be sent to the LPAR agent manager and an LPAR agent manager queue of playback images e.g. waiting for a response from the LPAR agent manager e.g. as received from a virtual service among other information and functionality.

An administrator can seamlessly remove specialized exits work area agent etc. from a program and region for instance through a simple remove exits transaction among other implementations. For instance an administrator can conclude for example through information obtained from monitor transaction that it is no longer appropriate to utilize the specialized exits and related functionality. Further in response the administrator can cause a remove exits transaction to be performed to restore the program to its original form prior to the installation of the specialized exits e.g. through install exits transaction .

Turning to simplified block diagrams are shown illustrating a more specific example of the virtualization of a particular program or software component e.g. in a CICS environment. In many respects the examples of build upon at least some of the principles illustrated in the preceding examples of B and . In the particular example of an LPAR implementing z OS includes at least two CICS regions e.g. . A first region can include one or more software components such as programs applications scripts or other software based modules including software components . Software component DEMOINQ can interact with software component and CICS transaction gateway among potentially other software components and resources. DEMOINQ can further interact with and send requests to other software components e.g. within the same region using a CICS LINK command. Some software components e.g. of region can interface with databases e.g. virtual storage access method VSAM store while others e.g. can provide one or more user interfaces e.g. at user terminal as a front end to the tasks to be performed using programs of the region and CICS mainframe.

In addition to interfacing with other software components in the same region example software component DEMOINQ can additionally include calls to and interactions with software components of other regions. For instance DEMOINQ can call using CICS LINK commands any one of software components etc. of a second region including software components interfacing with other data stores e.g. . Using specialized exits and coordinating CICS LINK agents in one implementation transactions between the DEMOINQ software component and anyone of software components can be monitored and resulting transaction data describing requests and responses between the software components can be used to generate virtual services for any one or all of the software components with which software component interacts using a LINK command.

In one particular example access to a data store may be known to be constrained. This can also constrain access to the full functionality of software component DEMOGETB that relies on data store . Accordingly in one example a user may initiate recording of transactions between the DEMOINQ software component and the DEMOGETB software component e.g. when data store DEMOBAL is online in order to collect transaction data that can be used to virtualize the functionality of the DEMOGETB software component including its use of the data store .

Turning to specialized exits can be provided in connection with the LINK call from DEMOINQ to DEMOGETB . Similar exits can be provided in connection with each of the LINK commands included in any one of software components etc. allowing monitoring and thereby virtualization of transactions involving the software components. In recording mode exits can record transactions between DEMOINQ and DEMOGETB including the requests sent from DEMOINQ to DEMOGETB and the responses sent from DEMOGETB to DEMOINQ among other information. Multiple different transactions involving varying operations and attributes can be monitored between DEMOINQ and DEMOGETB utilizing exits and agent . Information describing these requests and responses can be communicated to the agent for forwarding on to LPAR agent manager for communication and use by a virtual service system including a virtualization engine e.g. . A virtual service can then be generated to simulate and stand in for software component DEMOGETB allowing software component DEMOINQ to be tested or otherwise used when data store or software component DEMOGETB are unavailable. Indeed in examples where virtual services have been generated and are available for each of software components each of these respective virtual services can be instantiated to allow software component to simulate any of its respective calls to programs within region among other examples.

Virtual services can be used to virtualize various portions of a system. The examples of include simplified block diagrams illustrating an example virtualization of a program in another region similar to the examples of . In a program can be designed to make a function call to a program . Transactions can be completed between the programs that can be monitored by exits used in connection with the function call and at least one agent e.g. . As shown in monitored transactions can be used to virtualize the program using a virtual service engine running virtual service . Indeed in some instances this can allow tests of program involving transactions with program even when program or region is unavailable.

Turning to virtualization can also allow virtualization of responding or server software components hosted on separate computing devices LPARs and the like. For instance in the example of a program in a region of a first LPAR can call another program hosted in a region of a different LPAR for instance using one or more networks e.g. . As in other examples described herein transactions between the software components and can be monitored e.g. using agent and specialized exits in program to generate a virtual service e.g. simulating the program as shown in . This can allow testing and other tasks to be performed using program even in the unavailability of LPAR region program network etc.

Turning to example screenshots are shown illustrating additional features of at least some implementations of the concepts and systems above. For instance in the example of a screenshot is shown of a graphical user interface GUI of an example virtualization engine that can be presented to a user through a display of a user device such as a touchscreen monitor or other device. The GUI of screenshot can be used for instance by a user to initiate recording of a particular software component that the user desires to virtualize through one or more virtual services. The user can select a particular software component for instance from a directory of files and specify a location to save a service model of the particular software component. Further the user can specify aspects of the service model to be generated from transaction data resulting from the recording. For instance the user can specify the type of monitoring or service model for instance according to the transport protocol utilized in requests to the particular software component. For instance a user can select such protocols as CICS LINK Hypertext Transfer Protocol Java Methods Java Message Service JMS Transport Control Internet Protocol TCP IP messages Java Database Connectivity JDBC database calls Distributed Relational Database Access DRDA database calls among others.

Turning to the example of a screenshot of another GUI is shown. The example GUI of can allow a user to select an existing virtual service that can be deployed to simulate operation of a particular software component or system of software components . The user can also specify various performance parameters to be adopted by the virtual service during its deployment such as timing and delay characteristics among other examples. Further in some implementations a user can select to deploy a virtual service in connection with a test training session or other session among other examples.

Turning now to an example view of an image captured by a specialized exit in a mainframe program is shown. For instance in a CICS environment data can be passed by a requesting program to a responding program in a CICS COMMAREA. The format and layout of the COMMAREA data can be embodied in a copybook member and the image captured by a specialized exit can be an image conforming to the format of the copybook. The image can be passed to an agent or to the virtualization engine to be processed. An image can be processed by parsing the associated copybook to identify its structure as represented in the hierarchical diagram of . Indeed in some implementations a GUI can be presented that includes a graphical representation of a parsed copybook image. Further parsing of the copybook can allow for the identification of a request and or response any operations included in the request attributes included in the request and or response and so on.

Turning to the example of a call can be intercepted from a first program to a second program. The intercepted call can include a request and can be intercepted using a specialized exit included in the first program and associated with the call e.g. a modified XPCREQ exit preceding a CICS LINK command . The intercepted request can be communicated or otherwise provided for instance to an agent operating in conjunction with the specialized exit and facilitating redirection of the request to a virtual service configured to simulate operation of the second program. After the request has been redirected to the virtual service a response can be received to the request that was generated by the virtual service. The response can be provided to the first program for instance by a specialized exit associated with the call e.g. a modified XPCREQC exit following the CICS LINK command . The first program can consider the response to be from the second program although the response was in fact generated by the virtual service modeling the second program.

In the example of request data can be received from a mainframe that describes an intercepted request by a first program to a second program. The request can be intercepted in connection with a call of the second program by an exit of the first program associated with the call e.g. a modified XPCREQ exit preceding a CICS LINK command . The request described in the request data can be provided to a virtual service configured to model the second program. The virtual service can be caused to execute and process the request to generate a simulated response of the second program to the request. The simulated response can be sent to the mainframe for instance to an agent or agent manager on the mainframe allowing the response to be provided to the first program e.g. through a modified XPCREQC exit following the CICS LINK command as a response to the request of the first program.

The flowcharts and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various aspects of the present disclosure. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular aspects only and is not intended to be limiting of the disclosure. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of any means or step plus function elements in the claims below are intended to include any disclosed structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present disclosure has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the disclosure in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the disclosure. The aspects of the disclosure herein were chosen and described in order to best explain the principles of the disclosure and the practical application and to enable others of ordinary skill in the art to understand the disclosure with various modifications as are suited to the particular use contemplated.

