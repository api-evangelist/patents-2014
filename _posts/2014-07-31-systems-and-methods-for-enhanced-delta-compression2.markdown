---

title: Systems and methods for enhanced delta compression
abstract: Systems and methods for reducing file sizes for files delivered over a network are disclosed. A method comprises receiving a first file comprising sequences of data; creating a hash table having entries corresponding to overlapping sequences of data; receiving a second file comprising sequences of data; comparing each of the sequences of data in the second file to the sequences of data in the hash table to determine sequences of data present in both the first and second files; and creating a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09621666&OS=09621666&RS=09621666
owner: CITRIX SYSTEMS, INC.
number: 09621666
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20140731
---
The present application is a continuation in part of and claims priority to and benefit of U.S. Non provisional application Ser. No. 11 439 003 entitled Method and System For Object Prediction and filed on May 22 2006 which claims priority to and benefit of U.S. Provisional Application No. 60 685 260 entitled Advanced Data Optimization and filed May 26 2005 and the present application is also a continuation in part of and claims priority to and benefit of U.S. Non provisional application Ser. No. 12 790 400 entitled Method and Systems For Efficient Delivery Of Previously Stored Content and filed on May 28 2010 which is a continuation of and claims priority to and benefit of U.S. Non provisional application Ser. No. 11 428 058 entitled Method and Systems For Efficient Delivery Of Previously Stored Content and filed on Jun. 30 2006 and now issued as U.S. Pat. No. 7 756 826 all of which are incorporated herein by reference in their entirety for all purposes.

The present application is directed to Internet and computer network content delivery and more particularly to systems and methods for reducing file sizes for files delivered over a network.

The Internet allows for vast amounts of information to be communicated over any number of interconnected networks computers and network devices.

In many network environments bandwidth is a scarce resource. Bandwidth may be limited by the connection infrastructure of the environment or the maximum transmission or reception speeds of devices on the network. Where bandwidth is scarce significant improvements in transmission time can be achieved by reducing the size of files transmitted over a network.

Another common feature of networks including the internet and the World Wide Web is the transmission of redundant data. For example often a client may request the same file on different days to observe any changes that have taken place. A large portion of the file data may be redundant in that it has already been transmitted to the user. For example if the file is the web page of a newspaper the headings and formatting information will remain constant. As another example a client may load a file several times within a single hour for example if the file is a web page listing updated sports scores. In this example the only data that changes from viewing to viewing may be the scores themselves and the team names logos and formatting will remain unchanged.

Several systems and methods already exist for taking advantage of this redundancy to reduce the size of transmitted files. Many web browsers store images from sites a user has already visited so that they do not need to be retransmitted if the user returns to the site. While this method is effective it is typically limited only to standard image files and cannot reduce file sizes for pages comprising large amounts of text scripts or formatting information. Many web sites utilize frames applets or scripts to control web pages so that only the portion of a page that has changed will be retransmitted. The drawback of this approach is that programming a site to use these techniques often requires substantial developer time and resources and may require recoding previously existing files. Thus there exists a need for means to leverage the redundancy found in many network transmissions to reduce the size of transmitted files that may be easily applied to both presently existing and future files.

Typically information or content is located at websites on one or more servers and a user can retrieve the content using a user agent such as a web browser running on a client device. For example the user can input a webpage address into the web browser or access a web link which sends requests to a server to access and provide the content on the respective website. This type of communication is commonly referred to as web browsing. 

Web browsing is enjoyed by millions of users on the Internet. However accessing content on a network that is constrained by bandwidth and latency can make web browsing less enjoyable. Bandwidth is the measurement of the speed of a network link. Lower bandwidth network links take more time to transfer content than higher bandwidth links. Latency is a measurement of the responsiveness of a network link. Higher latency networks take more time than lower latency networks to send a single byte of data over a network link.

Many networks can suffer from low bandwidth and or high latency problems that degrade the enjoyment of web browsing for users. Wireless wide area networks WANs such as GPRS or CDMA 1xRTT wireless networks are just a few networks along with traditional plain old telephone POTS dialup networks that can exhibit bandwidth and latency problems. These networks may take 50 to 100 seconds to download content from a web page due to bandwidth and latency constraints whereas a high speed local area network LAN may be less prone to such constraints and can download the same content in 5 to 10 seconds. Waiting a long time to view content for a web page is annoying to users and inefficiently utilizes the network.

Utilizing a network efficiently is also a particular concern for network providers who must share limited resources among many users. For example wireless WAN providers share very expensive and limited spectrum among all of its data and voice subscribers. Thus efficient use of the spectrum frequencies is imperative. Furthermore in a wireless WAN environment data transmission is more susceptible to interference and noise in contrast to a wired environment. Interference and noise delay the data transmission process and more importantly cause variability and unpredictability in the delay. A web site that may download objects in 50 seconds the first time may download the same objects in 100 seconds the next time. Thus in order to address these concerns network providers must efficiently use existing network infrastructure to provide the most efficiency to a user when downloading content.

Furthermore the manner in which information is transferred on a network plays an important role in the network s efficiency. Referring to the World Wide Web WWW the Hypertext Transfer Protocol HTTP sets forth the rules for transferring content such as files or objects on the web. This protocol uses requests and responses for transferring content. For example a user agent e.g. a web browser sends a request to the content server for a particular file or object of a web page and the server of the web page queries the object in a database and sends back the object as part of a response to the user agent. This process continues until every object in the web page has been downloaded to the user agent.

As web pages have become more complex a common web site may contain hundreds of objects on its web pages. Such objects may include text graphics images sound etc. The web pages may also have objects located across multiple servers. That is one server may provide dynamic content e.g. content that remembers the last books ordered by a user for a web page whereas other servers may provide static but rotating content such as an advertisement and still others provide the static content of the site. As such before a user can view a web page hundreds of objects may require downloading from multiple servers. Each server however may take a different amount of time to service a request for an object contributing to latency. Thus the latency for each server may vary with different levels of magnitude e.g. one server may respond in milliseconds whereas another server may respond in seconds.

Latency constraints however should not be confused with bandwidth constraints. illustrates the retrieval sequence for objects on a bandwidth constrained network using HTTP over TCP IP. In this illustration each request for an object requires a connection to be established between a client and a server with an exchange of SYN and ACK messages necessary for TCP IP. Due to the relatively small latency of the network and the responsiveness of the server the ACK message is sent back to the client quickly. However because the network is bandwidth constrained a response back to the client takes a relatively long time. This is exacerbated if the object for the request is large in nature and must be broken into many packets as shown in . As a result the overall download time for each request response is dominated by the time it takes to download all the packets of the individual objects on a network link. Such download time can be calculated by adding the size of each of the individual objects and dividing the aggregate size by the link bandwidth.

Unfortunately user agents are in fact a source of latency when downloading an object. This latency is a result of the user agent processing the downloaded objects and attempting to display these objects in the manner the web page designers intended. Web page designers use a multitude of different standards to instruct the user agents how a web page is supposed to look once rendered. The number of standards is increasing over time and include markup languages e.g. Hyper Text Markup Language HTML Extensible HTML XHTML Wireless Markup Language WML objects that define the overall style of the page e.g. Cascading Style Sheets CSS objects that are executed by the user agent e.g. JavaScript and image objects e.g. JPEG GIF PNG . After downloading each object the user agent needs time to process and determine the impact of each object on the displayed web page. The processing time of each object may impact the download of subsequent objects. For CPU constrained devices e.g. phones the latency from browser processing time can contribute significantly to the overall download time of a web page. Also for poorly implemented user agents certain objects may significantly impact the time to render a web page. Even over a high bandwidth and low latency network the implementation of the user agent can result in these object processing times severely impacting the download time of the web page. number of standards is increasing over time and include markup languages e.g. Hyper Text Markup Language HTML Extensible HTML XHTML Wireless Markup Language WML objects that define the overall style of the page e.g. Cascading Style Sheets CSS objects that are executed by the user agent e.g. JavaScript and image objects e.g. JPEG GIF PNG . After downloading each object the user agent needs time to process and determine the impact of each object on the displayed web page. The processing time of each object may impact the download of subsequent objects. For CPU constrained devices e.g. phones the latency from browser processing time can contribute significantly to the overall download time of a web page. Also for poorly implemented user agents certain objects may significantly impact the time to render a web page. Even over a high bandwidth and low latency network the implementation of the user agent can result in these object processing times severely impacting the download time of the web page.

Some embodiments of the present solution provides an efficient mechanism by which the transmitted file sizes can be significantly reduced for files comprising data that has previously been transmitted. The invention may make this reduction possible without the need for file specific application specific or network specific solutions and thus may not require substantial developer investment.

In one aspect the present solution is a method for creating efficient updates to a previously stored file. The method comprises receiving a first file comprising sequences of data creating a hash table having entries corresponding to overlapping sequences of data receiving a second file comprising sequences of data comparing each of the sequences of data in the second file to the sequences of data in the hash table to determine sequences of data present in both the first and second files storing representations of lengths and locations of said sequences of data present in both the first and second files and creating a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files.

In another aspect the present solution is a method of receiving efficient updates to previously stored files. The method comprises receiving a first file comprising sequences of data receiving a second file comprising sequences of data and representations of locations and lengths of sequences in the first file and executing a Javascript function to create a third file comprising sequences of data from the second file and sequences in the first file indicated by the second file.

In yet another aspect the present solution is a computer system for creating efficient updates to a previously stored file. The system comprises a transceiver which receives a first and second file each file comprising a respective plurality of sequences of data a hash engine which communicates with said transceiver and computes hash values for sequences of data in the first and second file wherein at least two of said sequences overlap and determines sequences of data present in both the first and second files a storage element in communication with said hash engine which stores representations of the lengths and locations of said sequences present in both the first and second files and a processor in communication with said storage element which creates a third file comprising sequences of data from the second file and representations of lengths and locations of said sequences present in both files.

In some aspects the present solution is directed to an enhanced efficient updates to objects and or files on a client. The method may include receiving by a device intermediary to a plurality of clients and a server a response from the server to a request for a web page by a client of the plurality of clients. The device may store a first file comprising a first plurality of sequences of data from a previous response served by the server. The method may include generating by the device an object list identifying object data within the response that is to be downloaded to the client. The method may also include maintaining by the device a hash table having a plurality of entries each of the plurality of entries corresponding to a respective one of a first plurality of sequences of data in the first file. At least two of the entries may correspond to overlapping sequences of data. The method may further include computing by the device hash values of a second plurality of sequences of data from the response for a second file and comparing each of the second plurality of sequences of data with sequences from the first plurality of sequences having the same hash value to determine sequences of data present in both the first file and second file The method may include creating by the device a third file comprising sequences of data from the second file and a representation of a location and a length of a first sequence of data present in both the first file and second file. The representation of the location may identify a number of bytes between the first sequence of data and a second sequence of data present in both the first file and the second file and the length may identify a number of matching bytes of the first sequence of data. The device may transmit the third file and the object list to the client.

In some embodiments the method includes determining by the device whether each object data within the response is to be downloaded to a user agent of the client and generating the object list based on the determination. In some embodiments the method includes receiving by the device request object data constructed by the client using the object list. The request object data includes a request object list identifying object data and freshness data indicating that the object data is one of fresh or stale. In some embodiments the method includes determining by the device whether object data within the response matches object data of the request object data.

In some embodiments the method includes indicating by the device that the object data is to be downloaded if the object data within the response does not match the object data of request object data. In some embodiments the method includes determining by the device whether object data of the request object data is indicated by freshness data to be fresh or stale responsive to the object data within the response matching the object data of the request object data. In some embodiments the method includes verifying with the server the request object data is fresh or stale if the request object data is indicated by the freshness data to be stale. In some embodiments the method includes indicating that the object data is to be downloaded if the request object data is verified to be stale.

In some embodiments the method includes creating the third file comprising sequences of data from the second file and representations of locations and lengths of sequences present in both the first file and the second file wherein the locations are represented as a relative distance from a location in the first file. In some embodiments the method includes creating the third file comprising sequences of data from the second file and representations of locations and lengths of sequences present in both the first file and the second file. The third file may be translated into a byte sequence using a byte encoding protocol.

In some aspects the present solution is directed a system comprising a device intermediary to a plurality of clients and one or more servers. The device may be configured to receive a response from the server to a request for a web page by a client of the plurality of clients and configured to store a first file comprising a first plurality of sequences of data from a previous response served by the server. A generator of the device may be configured to generate an object list identifying object data within the response that is to be downloaded to the client a hash engine of the device configured to maintain a hash table having a plurality of entries. Each of the plurality of entries corresponding to a first plurality of sequences of data in the first file and at least two of the entries correspond to overlapping sequences of data. The hash engine may be configured to compute hash values of a second plurality of sequences of data of the response for a second file. The device may be further configured to compare each of the second plurality of sequences of data with sequences from the first plurality of sequences having the same hash value to determine sequences of data present in both the first file and the second file and create a third file comprising sequences of data from the second file and a representation of a location and a length of a first sequence of data present in both the first file and the second file. The representation of the location identifies a number of bytes between the first sequence of data and a second sequence of data present in both the first file and the second file. The length identifying a number of matching bytes of the first sequence of data. The device is also configured to transmit the third file and the object list to the client.

In some embodiments the generator is further configured to determine whether each object data within the response is to be downloaded to a user agent of the client and generating the object list based on the determination. In some embodiments the device is further configured to receive request object data constructed by the client using the object list. The request object data includes a request object list identifying object data and freshness data indicating that the object data is one of fresh or stale. In some embodiments the device is further configured to determine whether object data within the response matches object data of the request object data. In some embodiments the device is further configured to indicate that the object data is to be downloaded if the object data within the response does not match the object data of request object data.

In some embodiments the device is further configured to determine whether object data of the request object data is indicated by freshness data to be fresh or stale responsive to the object data within the response matching the object data of the request object data. In some embodiments the device is further configured to verify with the server the request object data is fresh or stale if the request object data is indicated by the freshness data to be stale. In some embodiments the device is further configured to indicate that the object data is to be downloaded if the request object data is verified to be stale.

In some embodiments the device is further configured to create the third file comprising sequences of data from the second file and representations of locations and lengths of sequences present in both the first file and the second file wherein the locations are represented as a relative distance from a location in the first file. In some embodiments the device is further configured to create the third file comprising sequences of data from the second file and representations of locations and lengths of sequences present in both the first file and second the second file wherein the third file is translated into a byte sequence using a byte encoding protocol.

Reference will now be made in detail to the exemplary embodiments implemented according to the present solution the examples of which are illustrated in the accompanying drawings. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts.

User agent is a client application used with a network protocol. For example user agent could be a web browser a search engine crawler a screen reader or a Braille browser and the user agent could be used to access the Internet. User agent can be a software program that transmits request data e.g. an HTTP WAP request data to a web server and receives response data in response to the request data. For example user agent can send request data to the content servers for a particular file or object data of a web page identified by a URL and the content server of the web page can query the object data in a database and can send back the object data as part of the response data e.g. HTTP WAP response data to the user agent. This process continues until every object in the web page has been downloaded to the user agent.

Client device is a computer program or terminal that can access remote services. Client device can receive request data from the user agent can transmit the request data to the content servers and can receive response data in response to the request data. For example the client device can be Bytemobile Optimization Client Software. Client device s functionality is further described below. In some embodiments user agent and client device can be housed in the same device such as a computer a PDA a cell phone a laptop or any device accessing the Internet. Furthermore client device can be embedded within user agent .

Gateway is a device that converts formatted data provided in one type of network to a particular format required for another type of network. Gateway for example may be a server a router a firewall server a host or a proxy server. The gateway has the ability to transform the signals received from client device into a signal that network can understand and vice versa.

Networks and can include any combination of wide area networks WANs local area networks LANs or wireless networks suitable for networking communication such as Internet communication.

Optimization server OS is a server that provides communication between gateway and content servers . For example OS could be a Bytemobile Optimization Services Node. OS can optimize performance by enabling significantly faster and more reliable service to customers. OS s can include optimization techniques which are further described below.

Content servers are servers that receive the request data from the user agent processes the request data accordingly and return the response data back to the user agent . For example content servers can be a web server an enterprise server or any other type of server. Content servers can be a computer or a computer program that is responsible for accepting HTTP requests from the user agent and serving the user agents with HTTP responses.

Domain Name System DNS server is a server that associates many types of information to domain names. DNS server maps the fully qualified domain name FQDN of a URL to the IP address associated with the FQDN. For example DNS server makes it possible to attach hard to remember IP addresses such as 209.10.233.130 to easy to remember domain names such as bytemobile.com. . DNS server can also list mail exchange servers accepting e mail for each domain.

Data cache is a storage device that stores web documents to reduce bandwidth usage and web page access times. Data cache stores copies of object data requested and received by the user. Subsequent web page requests may be satisfied by accessing the data cache if certain conditions are met. Such conditions may include whether the object data is located in the data cache and whether the object data is deemed fresh or stale. For example the freshness of the object data can be defined by the definition of fresh and stale in RFC 1945 and RFC 2616.

Rendering engine can be a software application that enables a user agent to display and interact with text images and other information located on a webpage. When a user types in a web address or URL into the user agent the rendering engine uses Hypertext Transfer Protocol HTTP to initiate the request with the content server e.g. content server . Although rendering engines can be used to access the Internet they can also be used to access data provided by web servers in private networks or content in file systems.

Cookie cache is a device that stores data relating to cookies. In some embodiments cookie cache is located on the hard drive on the client device that the user agent runs. Cookie cache can include cookies which can include among other things user IDs passwords preference data etc.

Client device may include among other things a request monitor a request generator a freshness cache a predicted response cache a response monitor a DNS cache and an interface .

Request monitor can be a software program or a hardware device that receives or intercepts the request data such as an HTTP request from the rendering engine . Request monitor can identify the embedded request object data e.g. embedded URLs located with the request data and create a request object list that includes the request object data the freshness data of the request object data FQDN of the request object data and or any cookie data associated with the request object data. Request monitor has the ability to communicate with user agent to determine whether the request object data and any cookie data associated with the request object data are stored in the user agent and if so whether the request object data is fresh or stale. Request monitor has the ability to forward to OS the request data and if available the request object list.

Request generator can be a software program or a hardware device that constructs predicted request data. Request generator constructs predicted request data by accumulating object data mapping data linking the FQDN of the object data to an IP address of the FQDN and cookie data associated with the object data. This allows request generator to mimic as closely as possible subsequent request data. Furthermore request generator may use a user agent string and other request data headers to help mimic the subsequent request data. In some embodiments request generator flags the predicted request data to indicate that it is a predicted request and not an original request. Request generator has the ability to forward the predicted request data through OS to content servers .

Freshness cache is a device that stores the freshness data of object data that the user agent has determined to be stale. For example freshness cache can be a list an array a database a cache etc. When the client device receives request data from the user agent and the request data includes request object data that is stale the freshness cache can be accessed to determine whether that stale object data is actually fresh. If the stale object data is indeed fresh client device can inform the user agent that the object data stored in the data cache is fresh. Freshness cache receives freshness data from response monitor when optimized data includes the freshness data.

Predicted response cache is a storage device that stores for a configurable amount of time predicted response data and stored predicted request data that identifies the predicted response data. Predicted response cache can provide predicted response data to the request monitor if the request data for a particular web page from the user agent matches stored predicted request data identifying the predicted response data stored at the predicted response cache . This stored predicted request data can be matched to request data received by the request monitor and acts as a cross reference to the predicted store data. For example the predicted response cache can receive request object data cookie data of the request object data data cache parameters and the user agent making the request to determine whether the request data matches the stored request data identifying the predicted response data. After a configurable amount of time has elapsed the predicted response cache can discard portions of the unused predicted response data and the stored predicted request data. Predicted response cache receives response data corresponding to a stale request object data from response monitor when optimized data includes this response data.

Response monitor can be a software program or a hardware device that receives optimized data from the OS . The optimized data can include among other things response data received from a content server response object list providing response object data any mapping data any freshness data for a request object data that was marked as stale and verified by the content server to be fresh fresh stale object data and or response data corresponding to a stale request object data. After receiving the optimized data the response monitor separates the optimized data and processes the separated data accordingly. Response monitor is communicatively coupled to DNS cache freshness cache predicted response cache and user agent .

DNS cache is a data storage device that stores mapping data linking the FQDN of the object data to an IP address of the FQDN. DNS cache receives mapping data from response monitor when the optimized data includes the mapping data. Additionally DNS cache allows client device and user agent the ability to map the FQDN of the URL to the IP address without having to access the DNS server . By providing mapping data to the response monitor the mapping data assists the request generator in constructing the request.

Interface is a software program or a hardware device that communicatively couples the client device to the communication means e.g. wireless and or wired connecting the client device and the OS . Interface is configured to receive the request data from the request monitor translate the request data and transmit the translated request data to the OS . Further interface is configured to receive information from the communication means connecting the client device and the OS . In some embodiments the interface can include encryption means and or decryption means to encrypt communication leaving from and decrypt communication coming into client device .

Optimization server OS may include among other things an OS monitoring device a generator a comparator a scheduler and a plurality of interfaces and .

OS monitoring device is a software program or a hardware device that monitors the request data received through the interface from the client device . In some embodiments the request data may include additional appended data such as the request object list identifying request object data the freshness data of the request object data and any cookie data associated with the request object data. In some embodiments the request object list includes the object data the freshness data and the cookie data. When the OS monitoring device receives the request data the OS monitoring device can extract any appended data from the request data and transmit the original request data from the user agent through interface to the content server . OS monitoring device can provide the extracted appended data to comparator .

Generator is a software program or a hardware device that receives the response data from content server . Generator can analyze the response data and determine if the response data contains references to embedded response object data that user agent would have to download. For example a GIF image would not contain references to other content data for a rendering engine to download while a markup language e.g. WML HTML XHTML etc. can have references to other response object data that rendering engine would have to download. Generator could then have the ability to generate a response object list that identifies the response object data and the FQDN of the response object data.

Comparator is a software program or a hardware device that receives request object list from OS monitoring device and response object list from generator and compares them. An exemplary comparing method is further described below in . Based on the comparison the comparator can update the response object list. After the comparison the comparator can transmit optimized data which can include among other things response data received from the content server response object list providing response object data any mapping data any freshness data for a request object data that was marked as stale and verified by the content server to be fresh fresh stale object data and or response data corresponding to a stale request object data.

Scheduler is a software program or a hardware device that receives a response data and or predicted response data from content server and schedules the response data back to the client device . For example the scheduler may give preferences to response data over predicted response data from the request generator . Another example may include the scheduler giving preference to object data appearing earlier in the response data over object data appearing later in the response data.

Interfaces and are similar to interface of the client device . Each interface has the ability to communicate with the elements of the optimization server translate the communication so that the communication means can utilize the data and transmit the translated communication across the corresponding communication means. Like interface interfaces and may have encryption and decryption means.

After the query the rendering engine transmits the request data e.g. HTTP request of the URL to the content server . The request monitor at the client device can receive or intercept the request data. Alternatively in some embodiments the user agent can send the request data over a wireless link. The request monitor forwards the request data to the OS . The request data can be directed explicitly to a gateway or proxy and then to the OS or it can be directed to the content server and the request can be intercepted transparently by an inline proxy or gateway. The OS analyzes the request data and determines whether the request is transmitted from either a user agent e.g. user agent or a client device e.g. client device that contains the client hardware software understanding the prediction protocol. As in this case the OS determines that the client device has the capabilities and forwards the request data to the appropriate content server . Consequently the content server provides response data e.g. HTTP response of the requested URL associated with the request data to the generator of the OS .

After the generator has received the response data generator analyzes the response data to determine if the response data includes references to embedded response object data e.g. embedded URLs within the HTTP response that the rendering engine would have to download. For example a GIF image might be compressible by the proxy but it does not contain references to other content that a web browser would have to download while a markup language can have references to other response object data that the web browser would have to download. The generator can parse through the response data and create a response object list that identifies embedded response object data within the response data. For example the response object list can include the URL response data and the embedded URL data. In some embodiments the identification of the embedded response object data can be dependent upon the capabilities of the user agent and or client device .

When the response object data is a URL generator can analyze the URL to determine if the URL includes a fully qualified domain name FQDN different from an FQDN associated with the URL of the request data The FQDN associated with the URL of the request data is copied by the OS prior to transmitting the request data to content server . In this exemplary embodiment the FQDN of the URL is different and consequently the generator queries the DNS server . The generator transmits the different FQDN to the DNS server and the DNS server returns mapping data associated with the different FQDN to the generator . The mapping data e.g. IP address maps the different FQDN to the IP address associated with the different FQDN.

After the generator has received the mapping data from the DNS server generator forwards optimized data to the client device . In this exemplary embodiment the optimized data can include among other things the response data the response object list identifying the response object data and the mapping data associated with the response object data. The response monitor of the client device receives the optimized data and separates the optimized data into the response data the response object list and the mapping data.

After the optimized data has been separated the response monitor can transmit the response data to the rendering engine of the user agent so that a user can view the web page that was originally requested. Further the response monitor transmits the mapping data to the DNS cache wherein the DNS cache stores the mapping data for a configurable amount of time. When the user agent requests the mapping data corresponding to an FQDN of the object data the client device can refer to the DNS cache without having to transmit the request through a gateway or proxy to the DNS server . In some embodiments if the mapping data cannot be extracted and stored in the DNS cache the DNS cache can be communicatively coupled to the DNS server so that the DNS cache can retrieve the particular mapping data from the DNS server .

Additionally the response monitor can process the response object list by storing a predicted response data and predicted request data identifying the predicted response data in the predicted response cache . Regarding the predicted response data once a request monitor receives a subsequent request from a user agent the request monitor can query the predicted response cache for any predicted response data that corresponds to the subsequent request and forward the predicted response data to the user agent without having to query the content server with the subsequent request data. The processing of the response object list can be the exemplary processing method illustrated in as now explained. The response monitor can determine whether the response object data e.g. embedded URLs of the requested URL etc. is currently being downloaded per a user agent request or due to another client object prediction by contacting the request monitor. The request monitor can determine which response object data is outstanding because all request data is transmitted through it. In some embodiments request monitor check the predicted response cache to determine whether any predicted response data has been downloaded. If so the response monitor can skip this response object data and process the next response object data within the response object list.

If not the response monitor can communicate with the data cache of the user agent to determine if the data cache has a fresh entry of stored object data that corresponds to the response object data. If the object data is stored in the data cache and the stored object data is fresh the response monitor can skip this response object data and process the next object data. The user agent can then retrieve the stored object data from the data cache . If the stored object data corresponding to the response object data is stored in the data cache but is stale response monitor can retrieve freshness data from the freshness cache not shown about how stale the response object data is to be used later. If the stored object data corresponding to the response object data is not located at the data cache the response monitor can continue processing the response object data. Consequently at this time response monitor has determined whether the response object data has been downloaded or if fresh stored object data corresponding to the response object data has been located in the data cache of the user agent . If the response monitor has determined that the response object data has been downloaded or fresh object data has been stored at the data cache the processing of the object data on the response object list can end.

Otherwise if the response object data has not been downloaded the object data stored in the data cache is stale or the object data corresponding to the response object data is not stored in the data cache response monitor can query cookie cache for any existing cookie data associated with the response object data. Further the response monitor can request the DNS cache for any existing mapping data associated with the particular response object data.

Response monitor forwards the response object data e.g. embedded URLs within the response object list that have yet to be downloaded from content server along with any existing cookie and mapping data associated with the response object data to request generator . Request generator uses the response object data along with any existing cookie and mapping data associated with the response object data to mimic an HTTP request from the user agent. Further the request generator can generate a user agent string and other HTTP request headers to mimic as closely as possible what the user agent expects to issue when it transmits request data to the content server . Furthermore the HTTP request is flagged as predicted request data for OS .

Request generator can forward the predicted request data through OS to content server . Content server transmits predicted response data e.g. response data of the embedded URLs that were located in the response object list to OS .

After the OS receives the predicted response data from the content servers scheduler can determine the scheduling method to give preferences to some data over others. For example the scheduler may give preferences to response data associated with the request data from user agent over predicted response data from request generator . Another example may include scheduler giving preferences to response object data appearing earlier in the response data over response object data appearing later in the response data. The scheduler can forward the predicted response data to response monitor . Response monitor can transmit the predicted response data e.g. response data of the embedded URLs alone or in combination with cookie data and mapping data to the predicted response cache which stores the predicted response data for a configurable amount of time.

Consequently for example when the user agent transmits subsequent request data request monitor can intercept the request data. Request monitor can request the predicted response cache for any predicted response data that corresponds to the request data. Request monitor s request can be based on a matching algorithm that can include the request object data e.g. URLs the cookie data associated with the request object data the cache parameters the user agent that is doing the requesting etc. The predicted response cache can forward any matched data to request monitor . If the request data matches any predicted response data request monitor can forward the predicted response data to user agent through request monitor . Otherwise if the request data does not match any predicted response data the request monitor can forward the request data through OS to content server in a similar manner described above.

After the client device has received the request data e.g. HTTP request of the URL the request monitor queries the data cache of the user agent . In some embodiments request monitor does not query the data cache because user agent has provided the embedded request object data along with the request data. Based on the query the request monitor generates a request object list that identifies embedded request object data within the request data. In some embodiments request monitor can further query data cache and cookie cache for any freshness data and cookie data associated with the request object data. The freshness and cookie data can be provided in the request object list. The identification of the request object data can be dependent on the client device and the user agent . For example while some user agents display all request object data of a web page other user agents try to intelligently render the web page onto a small screen. This intelligent rendering may only download a subset of embedded request object data within the webpage. Consequently the parsing performed may consider these intelligent rendering techniques for each client device and each user agent.

Request monitor queries the predicted response cache to determine if the request object data that is to be downloaded matches any stored predicted request data that identifies the predicted response data. For example the request monitor can send to the predicted response cache among other things URL data cookie data cache parameter data and user agent data. If any stored predicted request data matches this sent data the predicted response cache can transmit back to the request monitor the predicted response data that has been identified by the matched stored predicted request data.

Additionally the request monitor can query the freshness cache for any freshness data concerning stale request object data to determine if any stale object data listed on the request object list is in fact fresh stale object data. For example request monitor has a URL listed as being stale and forwards at least the URL data to the freshness cache and the freshness data provides to the request monitor any updated freshness data for that particular URL. If the predicted response cache or the freshness cache provides any predicted response data or updated freshness data the request object list can be updated with this data and the response monitor can forward the predicted response data and or updated freshness data to the data cache of the user agent . The data cache can be updated with the updated freshness data and or the predicted response data.

If the request object list includes any request object data marked to be downloaded the request monitor can forward the request data to the OS . The request data may include the request object list from the request monitor .

OS monitoring device of the OS receives the request data from the client device analyzes the request data and determines whether the request data has been transmitted from either a user agent e.g. user agent or a client device e.g. client device that contains the client hardware software having the necessary capabilities. Furthermore if the request object list has been appended to the request data OS monitoring device can extract the request object list from the response data and forward the request object list to comparator . OS monitoring device can forward the request data without the appended data to the appropriate content server . Consequently the content server provides response data associated with the request data to the generator of the OS .

After generator has received the response data generator analyzes the response data to determine if the response data includes references to embedded response object data that the rendering engine would have to download. For example a GIF image might be compressible by the proxy but it does not contain references to other object data that a web browser would have to download while a markup language can have references to other object data that the web browser would have to download. The generator can parse through the response data and can create a response object list identifying the request object data and the FQDN of the request object data. In some embodiments the identification of the embedded object data can be dependent upon the capabilities of the user agent and or client device .

When the response object data is a URL generator can analyze the URL to determine if the URL includes an FQDN different from the FQDN associated with the URL provided in the request object list. The FQDN associated with the URL of the request object list is copied by the OS and provided to generator prior to transmitting the request data to content server . In this exemplary embodiment the FQDN is different and consequently the generator queries the DNS server . Generator transmits the different FQDN to DNS server and DNS server returns the corresponding mapping data to generator . The mapping data maps the different FQDN to the IP address associated with the different FQDN.

After the generator has received any existing mapping data generator can forward the response data the mapping data and the response object list to the comparator . Comparator compares each request object data on the request object list with each response object data on the response object list. If the response object data matches the request object data and the matched request object data is fresh the comparator can delete the response object data from the response object list because the response object data is not to be downloaded. Alternatively in some embodiments the response object data from the response object list can be marked as not being downloaded instead of being deleted from the response object list. If the response object data does not have a corresponding match in the request object list comparator can update the response object list to include information that this particular response object data is to be downloaded. If the response object data matches the request object data and the matched request object data is stale the comparator can determine if the request object data is truly stale by requesting the content server to verify the freshness of the request object data. The response data from content server has the ability to inform comparator if the content is stale by either responding with new object data or by informing the comparator that the current version is fresh. Comparator transmits the request for verification along with the current timestamp of the object data to content server so that the content server can compare the timestamp information. If the content server verifies that the request object data is stale comparator can update the response object list to include information that this particular response object data is to be downloaded. If the content server verifies that the alleged stale request object data is indeed fresh fresh stale object data comparator can update the response object list to include information that this particular response data object is not to be downloaded. Comparator updates the response object list based on each request object data.

After the comparator has updated the response object list comparator can query the content server by providing the response object data and receiving response data of the response object data that is to be downloaded to user agent . The comparator forwards optimized data to the client device . In this exemplary embodiment the optimized data can include among other things the response data from content server the response object list the mapping data the response data associated with the response object data to be downloaded to user agent and the freshness data of the fresh stale content data. In some embodiments comparator can transmit each group separately.

The response monitor of the client device receives the optimized data separates the optimized data and processes the separated data accordingly. The optimized data is separated into the response data the response object list the mapping data the response data associated with the response object data to be downloaded to user agent and the freshness data of the fresh stale content data.

After the optimized data has been separated the response monitor transmits the response data to the user agent which can store the response data and or upload the response data into rendering engine . Further the response monitor transmits the mapping data to DNS cache which stores the mapping data for a configurable amount of time. When user agent requests an FQDN client device or the user agent itself can refer to the DNS cache without having to transmit the request through a gateway or proxy to the DNS server . In some embodiments if the mapping data cannot be extracted and stored in the DNS cache the DNS cache can be communicatively coupled to the DNS server so that the DNS cache can retrieve the particular mapping data from the DNS server . Furthermore the response monitor forwards the response data corresponding to the request object data to predicted response cache so that this response data can be stored for a configurable amount of time. When the user agent determines that additional embedded data corresponding to the URL response is needed from content server to complete the web page at user agent user agent can transmit a subsequent request requesting response data corresponding to the request object data. Because the client device has this response data corresponding to the request object data predicted response data the client device can provide the predicted response data to the user agent without having to access the content server for this subsequent request. Also the response monitor processes the freshness data of the fresh stale object data by forwarding the freshness data to freshness cache . Alternatively in some embodiments the freshness data can be forwarded to data cache of the user agent to instruct the data cache that the stale object data of the content data is indeed fresh.

Additionally the response monitor can process the response object list. Regarding the predicted response data once a client device receives a subsequent request from a user agent the client device can query the predicted response cache for any predicted response data that corresponds to the subsequent request and forwards the predicted response data to the user agent without having to query the content server with the subsequent request data. The processing of the response object list can be the processing method illustrated in . The response monitor can determine whether the response object data e.g. URL etc. is currently being downloaded per a user agent request or due to another client object prediction by contacting the request monitor. The request monitor can determine which response object data is outstanding because all request data is transmitted through it. In some embodiments request monitor checks the predicted response cache to determine whether any predicted response data has been downloaded. If so the response monitor can skip this response object data and process the next response object data within the response object list.

If not the response monitor can communicate with the data cache of the user agent to determine if the data cache has a fresh entry of stored object data that corresponds to the response object data. If the object data is stored in the data cache and the stored object data is fresh the response monitor can skip this response object data and process the next object data. The user agent can then retrieve the stored object data from the data cache . If the stored object data corresponding to the response object data is stored in the data cache but is stale response monitor can retrieve freshness data from the freshness cache about how stale the response object data is to be used later. If the stored object data corresponding to the response object data is not located at the data cache the response monitor can continue processing the response object data. Consequently at this time response monitor has determined whether the response object data has been downloaded or if fresh stored object data corresponding to the response object data has been located in the data cache of the user agent . If the response monitor has determined that the response object data has been downloaded or fresh object data has been stored at the data cache the processing of the object data on the response object list can end.

Otherwise if the response object data has not been downloaded the object data stored in the data cache is stale or the object data corresponding to the response object data is not stored in the data cache response monitor can query cookie cache for any existing cookie data associated with the response object data. Further the response monitor can request the DNS cache for any existing mapping data associated with the particular response object data.

Response monitor forwards the response object data along with any existing cookie and mapping data associated with the response object data as well as freshness data to request generator . Request generator uses the response object data along with any existing cookie and mapping data associated with the response object data to mimic an HTTP request from the user agent. Further the request generator can generate a user agent string and other HTTP request headers to mimic as closely as possible what the user agent expects to issue when it transmits request data to the content server . Furthermore the HTTP request is flagged as predicted request data for OS .

Request generator can forward the predicted request data through OS to content server . Content server transmits predicted response data e.g. response data of the embedded URLs that were located in the response object list to OS .

After the OS receives the predicted response data from the content servers scheduler can determine the scheduling method to give preferences to some data over others. For example the scheduler may give preferences to response data associated with the request data from user agent over predicted response data from request generator . Another example may include scheduler giving preferences to response object data appearing earlier in the response data over response object data appearing later in the response data. The scheduler can forward the predicted response data to response monitor . Response monitor can transmit the predicted response data e.g. response data of the embedded URLs alone or in combination with cookie data and mapping data to the predicted response cache which stores the predicted response data for a configurable amount of time.

Consequently for example when the user agent transmits subsequent request data request monitor can intercept the request data. Request monitor can request the predicted response cache for any predicted response data that corresponds to the request data. Request monitor s request can be based on a matching algorithm that can include the request object data e.g. URLs the cookie data associated with the request object data the cache parameters the user agent that is doing the requesting etc. The predicted response cache can forward any matched data to request monitor . If the request data matches any predicted response data request monitor can forward the predicted response data to user agent through request monitor . Otherwise if the request data does not match any predicted response data the request monitor can forward the request data through OS to content server in a similar manner described above.

Once the OS has identified the URLs the OS can determine whether each URL includes an FQDN different from an FQDN associated with the URL of a request data. If the OS determines that the FQDN is the same the OS transmits optimized data to the client device and the method can proceed to connector . On the other hand if the OS determines that at least one response URL has an FQDN different from the FQDN of the requested URL OS performs a DNS lookup from a DNS server. OS provides the FQDN data to the DNS server and the DNS server provides an IP address associated with the provided FQDN to the OS based on the FQDN data thereby creating mapping data that maps the FQDN to the IP address. In some embodiments performing step is controlled by the capabilities of a client device or the user agent. For example the capabilities of the client device can be explicitly relayed to the OS via communication from the client device or implicitly relayed to the OS via a user agent string.

After the OS has performed the DNS lookup the OS transmits optimized data which includes the mapping data to the client device. In some embodiments the mapping data can be transmitted separately from the optimized data. Once the client device receives the optimized data the client device can extract the mapping data and insert the mapping data into a DNS cache and the method can proceed to connector . The DNS cache can be located in the user agent or the client device.

The method proceeds from connector to the client device processing the response object list which includes one or more URLs. When processing a URL on the response object list the client device can request the DNS cache for any mapping data associated with an FQDN of the particular URL. As a result the DNS cache determines whether the mapping data e.g. IP address exists for the FQDN of the particular URL. If the mapping data does not exist the method proceeds to connector . If the mapping data exists the DNS cache provides mapping data to either the user agent or the client device and the method proceeds to connector .

The method proceeds from connector to the client device constructing a predicted request data where the construction includes among other things URLs and any existing mapping data which correspond to the URLs provided by the DNS cache. In some embodiments the construction can also include cookie data associated with the URLs from a cookie cache of the user agent. After the constructing step the method can end .

After the web page has been requested the user agent determines whether the content data of the request is stored in a data cache located at the user agent. For example the content data can be markup language content data of a requested web page wherein the markup language can be HyperText Markup Language HTML Extensible HTML XHTML Wireless Markup Language WML etc. If the content data is not stored the user agent can forward the request data e.g. HTTP request of the URL which includes the requested content data to the content server and then proceed to connector . In some embodiments the client device intercepts the request data and then forwards the request data to the content servers. On the other hand if the content data is stored the user agent determines whether all content data is fresh or stale. If the content data is fresh the user agent provides the fresh content data to the rendering engine and the method proceeds to connector . If some of the content data is stale the client device can identify embedded request object data e.g. embedded URLs within the HTTP request of URL associated with the content data and place all identified object data on a request object list. For example the object data can include one or more URLs.

After the identification the client device can query the data cache by providing the request object data and receiving any freshness data of the object data stored at the data cache of the user agent. The user agent can determine whether the stored object data is fresh. If the stored object data is fresh the corresponding request object data on the request object list is marked as being fresh and the method proceeds to connector . On the other hand if the stored object data is stale or not present at the data cache the client device retrieves any relevant data related to this object data. For example the relevant data may include any cookie data or any freshness data associated with the object data only if the content data is in the data cache and is stale. After the retrieval of any relevant data the corresponding request object data on the request object list is marked accordingly. The request object data is marked stale if the corresponding stored object data is found to be stale or is marked to be downloaded if the stored object does not exist. After the marking the method can proceed to connector .

The client device can then determine whether there is any additional embedded request object data. If so the method proceeds to connector . Otherwise the method proceeds to determine whether the request object data that is marked as being stale or to be downloaded on the request object list matches stored predicted request data in a predicted response cache. For example the match can occur when the request object data the cookie data of the request object data the data cache parameters and the user agent are similar or the same between the request object data and the stored predicted request data. If not the method proceeds to connector . Otherwise if a match occurs the client device updates the request object list by marking this request object data to not be downloaded. Further the client device provides to the user agent the predicted response data that has been identified by the matched stored predicted request data. In some embodiments the stored predicted response data can include freshness and mapping data. The user agent can store this stored predicted response data in the data cache or provide it to the web browser. The method then proceeds to connector .

Client device can then forward the request data which can include the request object list to the OS. The method can proceed to connector and then end .

Referring to it will be readily appreciated by one of ordinary skill in the art that the illustrated procedure can be altered to delete steps or further include additional steps. While the exemplary method provided in is tailored towards a client device it is readily appreciable that the exemplary method can be performed in part or exclusively by a user agent. After initial start step the client device receives optimized data from an OS. The optimized data can include among other things response data associated with a request data response object list identifying request object data any mapping data any freshness data of a fresh stale object data and response data corresponding to a stale request object data.

After the client device has received the optimized data the client device can separate the optimized data based on the type of data included within. For example the optimized data can be separated based on whether the data is response data provided by the content server a response object list any mapping data any freshness data of the fresh stale object data and response data corresponding to the stale request object data.

The client device can transmit to the user agent the response data that has been provided by the content server. Further the client device can determine whether the separated optimized data includes any mapping data. If not the method proceeds to connector . Otherwise if the separated optimized data includes mapping data the client device stores the mapping data at a DNS cache within a client device for future referencing. If the user agent requests a DNS query a client device could look up the mapping data in the DNS cache without having to query a remote DNS server. In some embodiments determining step storing step and connector can be moved to any point on the flowchart as long as they are after separating step .

Furthermore the client device can determine whether the separated optimized data includes any freshness data. If not the method proceeds to connector . Otherwise if the separated optimized data includes freshness data the client device processes the freshness data of a fresh stale object data by storing this freshness data in a freshness cache for future referencing. For example if a user agent requests object data that it has determined to be stale the client device can perform a freshness lookup at the freshness cache and if any freshness data corresponds to the stale request object data the client device can inform the user agent that the stale object data is indeed fresh. In some embodiments instead of the client device having a freshness cache the client device can notify the user agent that the request object data is indeed fresh and the user agent can update its data cache to show that the stored object data is fresh. In some embodiments determining step processing step and connector can be moved to any point on the flowchart as long as they are after separating step .

Additionally the client device can determine whether the separated optimized data includes any response data that was downloaded because the object data was determined to be stale stale response data . If not the method proceeds to connector . Otherwise if the separated optimized data includes any stale response data the client device stores the stale response data in a predicted response cache for future referencing. This stale response data For example if a user agent requests object data that it has determined to be stale the client device can perform a request data lookup at the predicted response cache by providing requested object data and if any stored predicted request data matches the provided request object data the predicted response cache provides predicted response data stored stale response data which cross references to the stored predicted request data to the user agent. The user agent can display this stale response data at the web browser or store this stale response data in its data cache. In some embodiments determining step storing step and connector can be moved to any point on the flowchart as long as they are after separating step .

Also the client device can determine whether the separated optimized data includes a response object list. If not the method can proceed to connector and the method can end . Otherwise if the separated optimized data includes a response object list the client device can process the response object list such as the exemplary processing method shown below in . In some embodiments determining step processing step and connector can be moved to any point on the flowchart as long as they are after separating step . The method can then proceed to end .

For example provides an exemplary method for processing the response object list. It will be readily appreciated by one of ordinary skill in the art that the illustrated procedure can be altered to delete steps or further include additional steps. While the exemplary method provided in is tailored towards a client device it is readily appreciable that the exemplary method can be performed in part or exclusively by a user agent. After initial start step the client device determines whether the current response object data from response object list is currently being downloaded by a user agent request or another client prediction. For example the response object list may include object data such as URLs and data relating to the object data such as freshness data and whether the object data needs to be downloaded. If the current response object data has been downloaded the method proceeds to connector . Otherwise the client determines whether the response object data is located in a user agent and is marked in the user agent as being fresh. If so the method proceeds to connector .

Otherwise if the response object data is neither located in the user agent nor is marked in the user agent as being fresh client device queries a cookie cache for any cookie data associated with the response object data. Further the client device queries the DNS cache for any mapping data associated with the response object data. Consequently the client device can store any cookie or mapping data associated with the response object data.

After the client device has stored the cookie or mapping data the client device determines whether there is any additional response object data to be processed. If so the method proceeds to connector . Otherwise if there is no additional response object data to be processed for the response object list the client device can construct the predicted request data that includes response object data and any cookie and mapping data related to the response object data. To try to predict a future request by a user agent the client device tries to mimic the request as much as possible by using cookie data and mapping data. Further the construction of the request may include mimicking a user agent string and other request header data and or flagging the request data as being a predicted request and not an actual request. Once the predicted request data has been constructed the client device transmits the predicted request data to a content server.

After the client device has transmitted the predicted response data the content server forwards the response data that is associated with the predicted request data predicted response data and the client device receives the predicted response data. Once the predicted response data has been received the client device stores the predicted response data in a predicted response cache at the client device for a configurable amount of time. If the user agent requests data that is the same or is similar to the object data within the predicted response cache the client device can return the predicted response data to the user agent in some cases without having to access the content servers thereby reducing bandwidth and latency. After the predicted response data has been stored the method can end .

After the OS receives the request data the OS can determine whether the request data includes a request object list. For example the request object list may include request object data such as URLs and data relating to the request object data such as freshness data FQDN of the request object data and whether the request object data is to be downloaded. If the request data does not include the request object list the method can proceed to connector . Otherwise if the request data does include the request object list the OS can extract the request object list from the request data and provide the request object list to other hardware devices or software programs within the OS. For example the provided request object list can correspond to the request object list determined to be provided in step in . The method can then proceed to connector .

The OS can then forward the request data without the request object list to one or more contents servers. After the forwarding step the method can end .

Referring to it will be readily appreciated by one of ordinary skill in the art that the illustrated procedure can be altered to delete steps or further include additional steps. After initial start step an OS can receive response data from one or more content servers. For example the response data can be the response data associated to the request data sent to the content server in step of .

After receiving the response data from the one or more content servers the OS can generate a response object list based on the response data. The OS generates the response object list by analyzing the response data and parsing through the response data to identify the embedded response object data within the response data. For example the response object data can include one or more URLS and the response data can be markup language content data of a requested web page wherein the markup language can be HyperText Markup Language HTML Extensible HTML XHTML Wireless Markup Language WML etc. For example the response object list may include response object data such as URLs and data relating to the response object data such as freshness data FQDN of the object data and whether the response object data is to be downloaded.

After the generation the OS can determine whether the response object data includes an FQDN different from an FQDN of the request object data provided. If the FQDN of the response object data is the same or similar to the FQDN of the request object data the method can proceed to connector . On the other hand if the FQDN of the response object data is different from the FQDN of the request object data the OS can query a DNS server by providing the FQDN and the DNS server can provide mapping data e.g. an IP address thereby providing the OS with mapping data that maps the FQDN to the IP address. The method can then proceed to connector .

OS can determine whether the extracted request object list was provided. For example the request object list may include request object data such as URLs and data relating to the request object data such as freshness data FQDN of the request object data and whether the object data is to be downloaded. If the extracted request object list was not provided the method can proceed to connector . Otherwise if the extracted request object list was provided the OS can compare the request object data within the request object list with the response object data within the response object list.

After the comparison the OS determines whether a particular response object data matches any request object data. If there is not a match the OS can mark the response object list that the particular response object data is to be downloaded and the method can proceed to connector . On the other hand if there is a match the OS can determine whether the request object data that matches the response object data is fresh or stale. If the request object data is fresh the OS can delete the matching response object data from the response object list and the method can proceed to connector . Alternatively in some embodiments the OS can mark the response object list that the particular server object is not to be downloaded. If the request object data is stale the OS can request the content server to verify the freshness of the request object data.

The OS can then determine whether the content server verified that the request object data was either fresh or stale. If the content server verified that the request object data was stale the OS can mark the response object list that the particular response object data is to be downloaded and the method can proceed to connector . Otherwise if the content server verified that the request object data was fresh the OS can mark the response object list that the particular response object data is not to be downloaded and the method can proceed to connector .

Once the method has proceeded to connector the OS can determine whether there is any additional response object data that should be compared with any request object data. If so the method proceeds to connector . Otherwise the method proceeds to connector and the OS can query the content server for any response data associated with the request object data that is to be downloaded to user agent. The OS provides the request object data that is to be downloaded to the user agent if any exists and the content server provides the corresponding response data. For example this response data can be stored at the client device as predicted response data. After the querying the OS can transmit optimized data to a client device or a user agent. The optimized data can include among other things the response data received from the content server and or the response object list. In some embodiments the optimized data can include any mapping data any freshness data for the fresh stale object data and or response data corresponding to the request object data that is to be downloaded to the user agent. After transmitting the optimized data the method can end .

Servers and clients as described herein may comprise any device capable of processing information and sending and receiving information including without limitation a personal computer notebook computer personal digital assistant cellular telephone pager a standalone computer server a blade server a rack mounted server or a group of any types of said servers.

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. the Crusoe and Efficeon lines of processors manufactured by Transmeta Corporation of Santa Clara Calif. the lines of processors manufactured by International Business Machines of White Plains N.Y. or the lines of processors manufactured by Advanced Micro Devices of Sunnyvale Calif.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computer system in which the processor communicates directly with main memory via a memory port. For example in the main memory may be DRDRAM.

In the embodiment shown in the processor communicates with various I O devices via a local system bus . Various busses may be used to connect the central processing unit to the I O devices including a VESA VL bus an ISA bus an EISA bus a MicroChannel Architecture MCA bus a PCI bus a PCI X bus a PCI Express bus or a NuBus. For embodiments in which the I O device is a video display the processor may use an Advanced Graphics Port AGP to communicate with the display. depicts an embodiment of a computer system in which the main processor communicates directly with I O device via HyperTransport Rapid I O or InfiniBand. also depicts an embodiment in which local busses and direct communication are mixed the processor communicates with I O device using a local interconnect bus while communicating with I O device directly.

A wide variety of I O devices may be present in the computer system . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. An I O device may also provide mass storage for the computer system such as a hard disk drive a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats and USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 132 serial connection a SCSI bus a FireWire bus a FireWire 800 bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCl LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

General purpose computers of the sort depicted in and typically operate under the control of operating systems which control scheduling of tasks and access to system resources. Typical operating systems include MICROSOFT WINDOWS manufactured by Microsoft Corp. of Redmond Wash. MacOS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah among others.

For embodiments comprising mobile devices the device may be a JAVA enabled cellular telephone such as the i55sr i58sr i85s or the i88s all of which are manufactured by Motorola Corp. of Schaumburg Ill. the 6035 or the 7135 manufactured by Kyocera of Kyoto Japan or the i300 or i330 manufactured by Samsung Electronics Co. Ltd. of Seoul Korea. In other embodiments comprising mobile devices a mobile device may be a personal digital assistant PDA operating under control of the PalmOS operating system such as the Tungsten W the VII the VIIx the i705 all of which are manufactured by palmOne Inc. of Milpitas Calif. In further embodiments the client may be a personal digital assistant PDA operating under control of the PocketPC operating system such as the iPAQ 4155 iPAQ 5555 iPAQ 1945 iPAQ 2215 and iPAQ 4255 all of which manufactured by Hewlett Packard Corporation of Palo Alto Calif. the ViewSonic V36 manufactured by ViewSonic of Walnut Calif. or the Toshiba PocketPC e405 manufactured by Toshiba America Inc. of New York N.Y. In still other embodiments the mobile device is a combination PDA telephone device such as the Treo 180 Treo 270 Treo 600 Treo 650 Treo 700 or the Treo 700w all of which are manufactured by palmOne Inc. of Milpitas Calif. In still further embodiments the mobile device is a cellular telephone that operates under control of the PocketPC operating system such as the MPx200 manufactured by Motorola Corp. A typical mobile device may comprise many of the elements described above in including the processor and the main memory .

For example the network appliance may be or include any implementations of the optimization server or gateway described in connection with at least . The network appliance may include any of the following of the optimization server OS monitoring device generator comparator and scheduler . The client may be or include any implementations of the client device described at least in connections with Figured . As previously described the client may include a user agent data cache rendering engine and or cookie cache . The client may include a request monitor request generator freshness cache predicted response cache response monitor and DNS cache . The servers may be or include any implementations of the servers or gateway described in connection with at least .

Still referring to in greater detail a network appliance connected via a network to a number of servers is shown. In the embodiment shown the servers may comprise any device capable of processing information and sending and receiving information including a standalone computer server a blade server a rack mounted server or a group of any types of said servers. The servers may further comprise databases file servers web servers application servers or any other type of server. In embodiments involving multiple servers the servers may be identical servers or may differ in make model type content performance availability or any other aspect. The network appliance may perform any function related to providing services to clients including without limitation firewall services SSL pooling and acceleration TCP pooling and acceleration data compression connection monitoring application logging application acceleration application delivery load balancing caching virtualization translation redirection connection pooling proxy services reverse proxy services authentication and session management. The network appliance may perform the functionality of any implementations of the optimization server described in connection with at least .

In some embodiments the network appliance may reside on the same physical machine as the servers . In some embodiments the network appliance may share processors disk space RAM or any other computing resource with the servers .

In the embodiment shown the network appliance is connected to networks . The networks may comprise the Internet local networks web servers file servers routers databases computers servers network appliances or any other computing devices capable of sending and receiving information. The networks may comprise computing devices connected via cables IR ports wireless signals or any other means of connecting multiple computing devices. The networks and any devices connected to the networks may communicate via any communication protocol used to communicate among or within computing devices including without limitation SSL HTML XML RDP ICA FTP HTTP TCP IP UDP IPX SPX NetBIOS NetBEUI SMB SMTP Ethernet ARCNET Fiber Distributed Data Interface FDDI RS232 IEEE 802.11 IEEE 802.11a IEE 802.11b IEEE 802.11g and direct asynchronous connections or any combination thereof. The networks may comprise mobile telephone networks utilizing any protocol or protocols used to communicate among mobile devices including AMPS TDMA CDMA GSM GPRS or UMTS. The networks may comprise physically distinct networks or the networks may comprise the same network and may be connected in any manner. In some embodiments the devices communicating via network may use a specialized or different protocol than devices communicating via network .

In embodiments comprising a TCP IP based communications among any of the above devices any TCP IP based protocol may be used including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. Any type and form of transport control protocol may also be used such as a modified transport control protocol for example a Transaction TCP T TCP TCP with selection acknowledgements TCPSACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol. In other embodiments any type and form of user datagram protocol UDP such as UDP over IP may be used.

Referring now to one embodiment of a method for creating an efficient update to a previously stored file is shown. Although depicts the method in the context of being performed by a network appliance and a client the method may be performed by any of the computing devices discussed herein either alone or in any combination. In brief overview the method comprises receiving a first file comprising a first plurality of sequences of data step transmitting the first file to a client step receiving a second file comprising a second plurality of sequences of data step creating a hash table having a plurality of entries each of the plurality of entries corresponding to a respective one of the first plurality of sequences and wherein at least two of said entries correspond to overlapping sequences of data step computing hash values for said second plurality of sequences of data step comparing each of the second plurality of sequences of data with sequences from the first plurality of sequences having the same hash value to determine sequences of data present in both files step storing representations of lengths and locations of said sequences of data present in both the first and second files step creating a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files step and transmitting the third file to a client step .

Still referring to and now in greater detail the network appliance receives a first file comprising a first plurality of sequences of data step . In some embodiments the first file may be received from a network from a server from a database or from any combination thereof. In some embodiments the first file may be read from a disk or other storage medium retrieved from a cache or accessed from RAM. In other embodiments the first file may be received from an application or process executing on the network appliance .

The first file may comprise sequences of data corresponding to sequences of bits or bytes comprising the file. The first file may comprise any file protocol including without limitation HTML XML WML SVG other document protocols image file protocols sound file protocols video file protocols and binary file protocols. In some embodiments the file comprises a web page or a portion of a web page. In some embodiments the file comprises any web page that is updated with some frequency including without limitation a news page a web application page a chat room a bulletin board a sports page an e mail page a directory listing a tracking page and a webcam page. After receiving the first file the network appliance may store or cache the first file to permit later retrieval. In some embodiments the network appliance may modify said first file in accordance with any of the network appliance functions described herein.

In some embodiments after receiving the first file step the network appliance transmits the first file to a client step . The network appliance may transmit the first file via any of the networks or protocols described herein and to any of the clients described herein. The network appliance may modify the first file in accordance with any of the functions performed by the network appliance including compression acceleration and encryption. Although depicts the network appliance transmitting the first file immediately after step in other embodiments said transmittal could occur after any of the steps steps occurring after the network appliance receives the first file step .

In some embodiments the network appliance may store a record of said transmission. Said record may be stored in any memory element including a data base or cache. In one embodiment the network appliance may access said cache to determine whether a given file has been previously transmitted to a client. In one embodiment said records may be set to expire after a set amount of time. For example if a network appliance has information indicating that a given client deletes all files from its cache at the end of each day the network appliance may set all records of files transmitted to the client to expire at the end of each day.

In the embodiment shown after the network appliance transmits the first file to the client step the client may then receive the first file step display the first file step and store the first file step . The client may perform these steps in accordance with any of the embodiments described herein.

In the embodiment shown after the network appliance transmits the first file to the client step the network appliance receives a second file comprising a second plurality of sequences of data step . In other embodiments the network appliance may receive the second file step before or during the transmission of the first file to the client step . The second file may comprise any of the file types protocols web pages and portions of web pages discussed herein. After receiving the second file the network appliance may store or cache the second file to permit later retrieval. In some embodiments the network appliance may modify said second file in accordance with any of the network appliance functions described herein.

After receiving the second file comprising a second plurality of sequences of data step the network appliance may create a hash table having a plurality of entries each of the plurality of entries corresponding to a respective one of the first plurality of sequences and wherein at least two of said entries correspond to overlapping sequences of data step . Said hash table may be created according to any known hash table algorithm which provides functionality to store sequences of data or references to sequences of data as entries and then efficiently search said table for entries matching a given sequence. In other embodiments the network appliance may create the hash table step before or during receiving the second file step .

In some embodiments the entries in the hash table may correspond to sequences of data from the first file comprising sequences of bytes. The sequences of bytes may be of any length. In one embodiment the sequences are four byte sequences.

In the embodiment shown at least two of the hash table entries correspond to overlapping sequences of data. Overlapping sequences may have any number of bytes in common. For example if the file comprised the sequence abcdefghijklmnop examples of overlapping four byte sequences include cdef and defg in addition to cdef and fghi. In one embodiment the hash table entries correspond to successive overlapping byte sequences. For example if the file comprised the sequence abcdefg a hash table comprising at least two successive overlapping four byte sequences may include entries corresponding to the sequences abed bcde cdef and defg .

In some embodiments the hash table entries at a given time may only correspond to sequences of data from a given portion or window of the first file. This allows the size of the hash table to be smaller than the hash table might be if the entire file was hashed at once. In some embodiments only the first X bytes of the first file are hashed and then upon occurrence of some conditions Y entries are removed from the table followed by Y more entries being added to the table. In one embodiment a window size of 64 kilobytes is used and upon occurrence of certain conditions the window is moved by 32 kilobytes. In this embodiment the sequences from the first 64 kilobytes of the first file are hashed and then upon occurrence of certain conditions the entries corresponding sequences from the first 32 kilobytes of the file are removed and entries corresponding to sequences from the next 32 kilobytes of the file are added.

The conditions upon which the hash window are moved may be any conditions which improve the execution time performance or compression of the hashing algorithm. In one embodiment the window is moved when matches have been found for more than 85 of the sequences in a given half of the window. In another embodiment the window is moved when a given percentage of the second file has been compared with the existing hash entries. In one embodiment the window is moved when hash values have been computed and compared for a proportionate portion of the second file compared to the first file. For example if the first file is 100 kilobytes and the second file is 80 kilobytes the hash window may be moved when 80 100 64 kilobytes of the second file has been compared to sequences in the hash table.

After the network appliance creates a hash table step the network appliance may then compute hash values for said second plurality of sequences of data step . Said hash values may be computed according to the same method used to compute hash values for the first plurality of sequences. The network appliance may choose sequences of data from the second file in the same manner in which the network appliance chose sequences of data from the first file. For example if the network appliance created hash table entries corresponding to successive overlapping four byte sequences from the first file the network appliance may choose to compute hash values for successive overlapping four byte sequences from the second file.

After computing hash values for some or all of the second plurality of sequences of data step the network appliance may compare each of the second plurality of sequences of data with sequences from the first plurality of sequences having the same hash value to determine sequences of data present in both files step . The network appliance may perform this step in accordance with any hashing algorithm presently available. Said comparisons may comprise a comparison of subsequent bytes of matched sequences to determine longer matches. For example the first file may comprise the sequence abcdefghijklmno and the second file may comprise the sequence zyxwvutcdefghituv. If the hashing is done on successive four byte sequences the network appliance may determine that the sequence cdef is present in both files. The network appliance may then compare subsequent bytes of the matched sequences to determine that the sequence cdefghi is present in both files. Thus in some embodiments the lengths of the sequences determined to be present in both files may vary from the lengths of the sequences for which hash values are computed. In some embodiments a minimum and maximum length on matching sequences may be set.

After determining sequences of data present in both files step the network appliance may store representations of lengths and locations of said sequences of data present in both the first and second files step . The network appliance may store said representations in any storage medium including a cache RAM a disk or tape. In some embodiments the network appliance may store said representations on the network appliance itself. In other embodiments the network appliance may store said representations on another computing device . In some embodiments lengths and locations of a sequences of data may be stored while the network appliance is comparing each of the second plurality of sequences of data with sequences from the first plurality of sequences having the same hash value step . In other embodiments a minimum length may be required for the length and location of a given sequence to be stored. In one embodiment the minimum length may be specified to be four bytes.

The representations of lengths and locations of said sequences present in both files may comprise any representation which identifies a length and location of a sequence. In some embodiments the locations of said sequences are stored as absolute locations within a file. In other embodiments the locations of said sequences are stored as locations relative to a given reference pointer within said first file. In one embodiment said reference pointer may be fixed in another embodiment said reference pointer may move according to a rule set.

In one embodiment the reference pointer may be initially set to point to the beginning of the first file. The pointer may then be incremented every time a matching sequence of longer than 5 bytes is found. The pointer may then be incremented to point to the last byte plus one of the matching sequence in the first file. In this embodiment locations of said sequences present in both files are stored as a given number bytes positive or negative from the position of the reference pointer.

In some embodiments the lengths and locations of the matched sequences are stored as fixed length integers. In one embodiment the length of a matched sequence is stored as a 1 byte integer wherein the integer represents a length of between 4 to 1027 bytes. In this embodiment byte lengths of matched sequences are restricted to multiples of 4. In other embodiments any other bit or byte length integers may be used to store said sequence lengths. In still other embodiments any other restrictions may be imposed on byte lengths of matched sequences including minimum and maximum lengths and limiting byte lengths to given multiples. In still other embodiments lengths of matched sequences may be stored as variable length integers. In some embodiments locations of matched sequences may be stored as variable length integers. In other embodiments locations of matched sequences are stored as fixed length integers of a given byte or bit length.

After the network appliance stores representations of lengths and locations of said sequences of data present in both the first and second files step the network appliance may create a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files. Said creation step may occur after all the lengths and locations of matched sequences are stored or said creation may occur contemporaneously as matched sequences are found. The third file may contain representations of lengths and locations in any format discussed herein. In some embodiments lengths and locations of shared sequences may be preceded by special byte or bit sequences.

For example if a first file comprised the string abcdefghijklmnop and the second file comprised the string xxxxxxxdefghijkxxxxxxcdefxxx the third file may comprise the sequence xxxxxxx3 8xxxxxx2 4xxx . In this example 3 8 is used to indicate a representation indicating the sequence from the first file starting at byte 3 and 8 bytes long in some embodiments this representation could be two fixed length binary integers . Likewise 2 4 indicates that a representation indicating the sequence from the first file starting at byte 2 and 4 bytes long.

As another example if the first file comprised the string abcdefghijklmnop and the second file comprised the string xxxxxxxdefghijkxxxxxxcdefxxx the third file may comprise the sequence xxxxxxx3 8xxxxxx 9 4xxx . In this example locations of shared sequences are stored as relative distances from a reference pointer incremented according to the method described above. In this example the network appliance indicates the first matched sequence in the same manner as the previous example since the reference pointer initially points to the beginning of the first file. The reference pointer would then be incremented to point to location of the last byte plus one of the matching sequence in the first file. Thus the second matched sequence is indicated with 9.4 which indicates that the second matched sequence occurs nine bytes prior to the byte following the previous matched sequence in the first file.

In one embodiment the third file may be encoded in a byte protocol such as ASCII. In one embodiment each group of 7 bytes of binary data may be encoded as 8 bytes of ASCII characters. This conversion may be done by any known conversion method. The ASCII characters may correspond to any existing character set definition including ISO 8859 1. In some embodiments the third file may comprise an HTML file. In one embodiment the third file may comprise a Javascript variable comprising said sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files. In one embodiment the third file may also comprise a Javascript function comprising functionality for assembling said second file by processing said Javascript variable. In another embodiment the third file may contain a reference to a Javascript function comprising said functionality.

In the above example an HTML file comprises a Javascript variable named updateFile. Said variable may comprise sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files. The example above also comprises a call to a Javascript function named createPage. Said function which may either be included with the HTML file or stored on the client may comprise functionality for assembling said second file using the data from the Javascript variable updateFile. In the example above a standard HTML browser would execute the createPage function upon loading the HTML page. The createPage function may also comprise functionality for altering the HTML page to display said second file once the second file is assembled.

After creating a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files step and the network appliance may transmit the third file to a client step . Said transmission may occur via any of the networks and methods discussed herein. The network appliance may modify the third file in accordance with any function performed by the network appliance including compression acceleration and encryption.

After transmitting the third file to a client step the client may receive the third file step execute a Javascript function to recreate the second file comprising sequences of data from the second file and sequences in the first file indicated by the third file step and display the second file step . The client may perform these steps in accordance with any of the embodiments described herein.

Referring now to a flow diagram depicting another embodiment of a method for creating efficient updates to a previously stored file is shown. In brief overview the method comprises creating a hash table with entries corresponding to overlapping sequences of data in a first file step setting a reference pointer to the beginning of said first file step computing a hash value for a sequence of data in a second file step and determining whether said sequence is present in both files step . The method may then comprise either moving to the next sequence in the second file step or determining a total length for the matching sequence step and determining whether said length exceeds a minimum threshold step . The method may then comprise either moving to the next sequence in the second file step or storing the length and location of the matching sequence relative to reference pointer step . The method may then comprise setting the reference pointer to the last byte plus one of the matching sequence in the first file step and then moving to the next sequence in the second file step . In the embodiment shown the method may be performed by a network appliance .

Still referring to now in greater detail a network appliance creates a hash table with entries corresponding to overlapping sequences of data in a first file step . This step may be performed in accordance with any of the methods for creating a hash table described herein.

After creating a hash table with entries corresponding to overlapping sequences of data in a first file step the network appliance may set a reference pointer to the beginning of said first file step . The reference pointer may comprise any type of pointer.

After setting a reference pointer to the beginning of said first file step the network appliance may compute a hash value for a sequence of data in a second file step . This step may be performed in accordance with any of the methods for computing a hash value described herein.

After computing a hash value for a sequence of data in a second file step the network appliance may determine whether said sequence is present in both files step . This step may be performed in accordance with any of the methods described herein.

If a sequence is not present in both files the network appliance may move to the next sequence of the second file . Said next sequence may comprise any sequence occurring after the given sequence in the second file. In one embodiment the next sequence may be the sequence starting one byte after the previous sequence. In another embodiment the next sequence may be the sequence starting any other number of bytes after the previous sequence. In some embodiments moving to the next sequence of the second file step may be accompanied by moving a hash window as described previously herein. If no next sequence exists the method may terminate.

If a sequence is present in both files the network appliance may determine a total length of a matching sequence by comparing subsequent bytes of the matched sequences step . The total length may be determined in accordance with any of the methods described herein.

The network appliance may then determine if the total length of the matching sequence exceeds a given threshold step . This determination may be made in accordance with any of the methods described herein. If the length of the matching sequence does not exceed the minimum threshold the network appliance may move to the next sequence of the second file.

If the length does exceed the minimum threshold the network appliance may then store the length and location of the matching sequence relative to the given reference pointer in accordance with any of the methods discussed herein. The network appliance may then increment the reference pointer according to any of the methods described herein step . The network appliance may then move to the next sequence of the second file step .

Now referring to one embodiment of a method for efficiently receiving updates to previously stored files is depicted. In brief overview said method comprises receiving an assembly function step receiving a first file comprising sequences of data step displaying said first file storing said first file step receiving a third file comprising sequences of data and representations of locations and lengths of sequences in the first file step executing a Javascript function to create a second file comprising sequences of data from the second file and sequences in the first file indicated by the third file step and displaying said second file step .

Still referring to now in greater detail a network appliance may transmit an assembly function. Said assembly function may comprise any computer readable program means for assembling a second file using a file comprising sequences of data from a second file and representations of locations and lengths of said sequences of data present in both a first and second files. Said assembly function may comprise any programming or scripting language including Javascript or Java. In some embodiments the assembly function may be transmitted in accordance with any of the other network appliance functions described herein. In one embodiment the assembly function may be included in a program providing other client side acceleration functionality.

In the embodiment shown after the network appliance transmits an assembly function step a client receives the assembly function step . The client may receive said assembly function via any of the networks protocols or computing devices described herein. In some embodiments the client receives the assembly function from a network appliance . In one embodiment the assembly function may be included as part of a client side acceleration program. In other embodiments the assembly function may be installed on the client via any means of transferring software including via a disk or other portable storage device.

In the embodiment shown after receiving a assembly function step the client receives a first file comprising sequences of data. In the embodiment shown the client receives the first file from a network appliance . In other embodiments the client may receive the first file from any computing device. Said file may comprise any file type or protocol discussed herein.

After a client receives a first file comprising sequences of data step the client may display said first file step . The file may be displayed in any manner appropriate for the given file. In some embodiments the file may be displayed in a web browser. In other embodiments the file may be displayed in a business application such as a word processor or a spreadsheet. In still other embodiments the file may comprise a standalone application and be displayed as such. In some embodiments the file may correspond to an application running in a virtual computing environment. In one embodiment the file may correspond to a remotely executing application. In another embodiment the file may correspond to a streaming application.

After a client displays said first file step the client may store said first file step . The client may store the first file in any storage element including storing in a cache disk flash memory or RAM. In some embodiments the client may compress the file for storage. In other embodiments the client may store only portions of the file. In some embodiments the client may store said first file step before or during the display of said first file step .

After a client stores said first file step the client may receive a third file step . In the embodiment shown the client receives the third file from a network appliance . In other embodiments the client may receive the third file from any computing device. Said file may comprise any file type or protocol discussed herein. In some embodiments the file may comprise ASCII characters. In other embodiments the file may comprise binary data.

After a client receives said third file step the client may execute a Javascript function to assemble a second file step . In some embodiments the Javascript function may be included in said third file. In other embodiments the Javascript function may be already stored on the client . In some embodiments the Javascript function may be provided in a client side acceleration program. In some embodiments the third file may comprise a link to a location where the client may download the Javascript function.

The Javascript function may perform any technique or the reverse of any technique described herein to assemble said second file. In some embodiments the Javascript function may comprise the assembly function received in step . In other embodiments the Javascript function may comprise a reference to said assembly function. In still other embodiments said Javascript function may comprise means for downloading said assembly function.

After executing a Javascript function to assemble said second file step the client may display said second file step . The file may be displayed in accordance with any of the methods described herein for displaying a file.

Referring now to one embodiment of a method for assembling a second file from a previously stored first file and a third file comprising sequences of data from the second file and representations of locations and lengths of sequences of data present in both a first and second files is shown. In brief overview the method comprises reading a set of data from a third file step and determining whether said set of data corresponds to a locations and length of said sequences of data present in both the first and second files step . The method then may comprise reading the specified length of bytes at the specified location in said first file step adding said bytes to the second file step incrementing the reference pointer to the location of the last byte plus one of the bytes read from the first file step and moving to the next set of data from said third file step . In one embodiment said method may be performed by a client . In another embodiment said method may be performed by an assembly function as described in .

Still referring to now in greater detail a client may set a reference pointer to the beginning of the first file. This may be performed in accordance with any of the methods described herein.

After setting the reference pointer step a client may read a set of data from a third file step . Said set of data may comprise any number of bits or bytes of said third file. In one embodiment said set of data is then stored in a memory element or cache.

After reading said set of data step a client may determine whether said set of data corresponds to a length and location of a sequence in the first file. In one embodiment a client may determine whether said set of data comprises a special character or bit sequence.

If said set of data does not correspond to a length and location of a sequence in the first file the client may add said set of data to the second file step . Said addition may comprise appending said set of data to the end of the second file. The client may then move to the next set of data from the third file step .

If said data does correspond to a length and location of a sequence in the first file the client may then read the specified length of bytes at the specified location in the first file step . The client may determine the length and location specified by recognizing any of the representations of lengths and locations described herein. In one embodiment the client may then store said specified bytes in a memory element or cache.

After reading the specified length of bytes at the specified location in the first file step the client may then add said bytes to the second file step . Said addition may comprise appending said bytes to the end of the second file.

The client may then increment the reference pointer to the location of the last byte plus one of the bytes read from said first file step . This may be performed in accordance with any of the methods described herein. The client may then move to the next set of data from said third file. step .

Referring now to one embodiment of a method for determining a file transmission method is shown. Said method may be performed by any of the machines or combinations of machines described above although the embodiment below describes the method being performed by a network appliance . In brief overview the method comprises receiving a request from a client for a resource step sending a request for said client s capabilities step receiving information conveying said client s capabilities step and determining a file transmission method step .

Still referring to now in greater detail the network appliance receives a request from a client step . In one embodiment receiving a request from a client step comprises receiving a request directly from a client. In other embodiments the request from a client may be received from any of the networks connections and appliances previously discussed. Said request may comprise any of the protocols previously discussed. In some embodiments the request may comprise the request exactly as transmitted from the client . In other embodiments the request may comprise a modification of an original request from a client . Said modifications may comprise modifications in the course of providing any of the network appliance services discussed above and any other modifications to the content format protocol addressing headers or other portions of the request. request from a client or a new request. A request may comprise a resource directly requested by a client and it may comprise a resource requested in the course of performing any service for the client .

After receiving a request from a client step the network appliance sends a request for said client s capabilities step . In one embodiment said request may be sent to the client . In another embodiment request may be sent to a collection agent as described in U.S. patent application Ser. No. 10 956 832 A METHOD AND APPARATUS FOR ASSIGNING ACCESS CONTROL LEVELS IN PROVIDING ACCESS TO NETWORKED CONTENT FILES whose contents are expressly incorporated herein by reference. Said collection agent may reside on the same physical machine as the network appliance sending the request or they may reside on different physical machines. Said request may also be sent to a file a cache a database a server an executing application or any other source of information concerning the client .

After sending a request for the client s capabilities step the network appliance receives information conveying said clients capabilities step . Said information may be received from a client a collection agent a file a cache a database a server an executing application or any other source of information concerning the client . Said information may comprise without limitation machine ID of a client node operating system type existence of a patch to an operating system MAC addresses of installed network cards a digital watermark on the client device membership in an Active Directory existence of a virus scanner existence of a personal firewall an HTTP header browser type device type network connection information authorization credentials and any of the other capabilities or preferences discussed above. In some embodiments the network appliance may store or cache said information for later retrieval.

After receiving information conveying said clients capabilities step the network appliance may determine a file transmission method corresponding to said client step . Said determination may be made on the basis of any of the information received.

In some embodiments the network appliance may determine in response to information received in step to transmit files in accordance with the method for creating efficient updates to a previously stored file described in . In one embodiment said determination may be made in response to information corresponding to the client s memory size connection speed connection bandwidth processor speed or the prior existence of a stored file.

In some embodiments the network appliance may determine in response to information received in step to transmit an assembly function to the client . For example the network appliance may transmit an assembly function to a client if the network appliance receives information that the client does not possess the assembly function and the information indicates the client has the capability to execute a assembly function. In some embodiments said assembly function may be transmitted along with any other files including requested content files or other files transmitted in accordance with the functions of the network appliance . In some embodiments a network appliance may possess a plurality of assembly functions. For example a network appliance may possess a number of assembly functions optimized for different computing environments operating systems and hardware configurations. The network appliance may then determine in response to the information received in step which assembly function to transmit to a client .

As one skilled in the art appreciates and understands in view of the embodiments of the client network appliance gateway and servers described herein any of these embodiments of the client network appliance gateway and servers may be configured and implemented to perform any combination of the methods described herein. For example any of the embodiments of the methods described in connection with may work in conjunction with integrated with or be performed concurrently with any of the embodiments of the methods described in connection with .

The methods disclosed herein may be implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

In the preceding specification the invention has been described with reference to specific exemplary embodiments. It will however be evident that various modifications and changes may be made without departing from the broader spirit and scope of the invention as set forth in the claims that follow. The specification and drawings are accordingly to be regarded as illustrative rather than restrictive sense. Other embodiments of the invention may be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein.

