---

title: Secure processing systems and methods
abstract: This disclosure relates to systems and methods for enabling the use of secret digital or electronic information without exposing the sensitive information to unsecured applications. In certain embodiments, the methods may include invoking, by a client application executing in an open processing domain, a secure abstraction layer configured to interface with secret data protected by a secure processing domain. Secure operations may be securely performed on the secret data by the secure abstraction layer in the secure processing domain based on an invocation from a client application running in the open processing domain.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09369280&OS=09369280&RS=09369280
owner: Intertrust Technologies Corporation
number: 09369280
owner_city: Sunnyvale
owner_country: US
publication_date: 20141008
---
This application is a continuation of U.S. patent application Ser. No. 13 163 244 filed Jun. 17 2011 which is based upon and claims priority under 35 U.S.C. 119 e to U.S. Provisional Patent Application No. 61 356 524 filed Jun. 18 2010 and entitled SECURE PROCESSING SYSTEMS AND METHODS both of which are hereby incorporated by reference in their entireties.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present disclosure relates generally to systems and methods for the secure processing of digital or electronic information. More specifically the present disclosure relates to systems and methods for enabling the use of secret digital or electronic information without exposing the sensitive information to unsecured applications.

Computer systems are commonly used to store and process digital information that a user may wish to keep secret or secure. For example a user may wish to prevent secret information related to their identity financial accounts passwords and the like from being accessed by and or exposed to potential attackers who may desire to exploit such secret information. Further information e.g. cryptographic keys certificates licenses control programs etc. utilized in digital rights management DRM implementations designed to prevent unauthorized access and or use to secure and or proprietary content may also need to be kept secret to maintain the integrity of the DRM implementation. Accordingly systems and methods to manage the processing of secret information by a computer system in a secure manner are desirable.

To prevent unauthorized access to and or exposure of secret or secure information a processing environment may be established on a computer system having a plurality of processing domains with different levels of security. For example a secure processing domain may be established where secret information is securely processed and protected from exposure to applications executing outside the secure processing domain. An open processing domain may be established where less sensitive and or less secure operations and applications may be performed and or executed. Potential attackers may gain access to the open processing domain by virtue of its less secure nature but will be substantially impeded from accessing the secret or secure information processed within the secure processing domain given its higher level of security.

In some circumstances applications running in the open processing domain may need to use secret information protected within the secure processing domain. Consistent with embodiments disclosed herein a secure programmatic abstraction layer may operate as a boundary between the secure processing domain and the open processing domain allowing applications running in the open processing domain to utilize secret information protected within the secure processing domain without compromising the security of the secret information. The secure programmatic abstraction layer may be invoked by the application running in the open processing domain and used to perform required operations on the secret information in a secure environment.

Secure operations performed on and or using secret information consistent with embodiments disclosed herein may initiate when a client application executing in an open processing domain of a system invokes a secure abstraction layer. The secure abstraction layer may be configured to interface with secret data protected by a secure processing domain of the system. In some embodiments the secure processing domain may include a secure processor unit having integrated support for symmetric and asymmetric cryptographic algorithms Further in certain embodiments before invoking the secure abstraction layer the system may determine that the secure abstraction layer is trusted. Determining that the secure abstraction layer is trusted may be based on for example a successful signature verification operation.

Once invoked the secure abstraction layer may perform one or more secure operations on the secret information based on an invocation from a client application. The secure operations may include for example loading a cryptographically wrapped key into the secure abstraction layer performing encryption decryption operations utilizing the secret information performing cryptographic signing and or signature verification utilizing the secret information encrypting secret fields within a larger piece of data utilizing the secret information and or performing digest calculations. By performing secure operations in the secure processing domain the secret information may not be exposed to the less secure client application running the open processing domain.

In certain embodiments secret information may be exported and or persisted from the secure processing domain in a secure manner. To export or persist secret information the secret information may first be encrypted using a persistent e.g. permanent encryption key. In certain embodiments the persistent encryption key may be associated with hardware components of the secure processing domain and be configured to persist between system reboots. The secret information may in addition or alternatively be encrypted using a cycling encryption key that may not be configured to persist between system reboots. Once encrypted by the persistent and or cycling encryption key the secret information may then be exported from the secure abstraction layer to the client application running in the open processing domain.

A detailed description of the systems and methods consistent with embodiments of the present disclosure is provided below. While several embodiments are described it should be understood that disclosure is not limited to any one embodiment but instead encompasses numerous alternatives modifications and equivalents. In addition while numerous specific details are set forth in the following description in order to provide a thorough understanding of the embodiments disclosed herein some embodiments can be practiced without some or all of these details. Moreover for the purpose of clarity certain technical material that is known in the related art has not been described in detail in order to avoid unnecessarily obscuring the disclosure.

Systems and methods are presented for facilitating the secure processing of secret proprietary and or other information e.g. secure electronic content . In certain embodiments the systems and methods described herein can for example be used in connection with digital rights management DRM technologies such as that described in commonly assigned co pending U.S. patent application No. 11 583 693 filed Oct. 18 2006 the 693 application and or service orchestration technologies such as those described in commonly assigned U.S. patent application Ser. No. 10 863 551 the 551 application the contents of both the 693 application and the 551 application hereby being incorporated by reference in their entireties as well as in other contexts. It will be appreciated that these systems and methods are novel as are many of the components systems and methods employed therein.

DRM engines e.g. such as those described in the 693 application and other software can benefit from leveraging the security and or media acceleration functionality of certain system on a chip SoC based devices. Leveraging integral secure components of a SoC can simplify and optimize the development process especially with respect to achieving compliance with security and robustness rules of a particular content protection implementation.

Embodiments of the systems and methods described herein can be used to provide a minimal programmatic abstraction layer that confines the handling of secret information e.g. cryptographic keys to a relatively small and verifiable secure code module. Depending on the system architecture this secure code module may directly interact with a secure processor integrated on the SoC operating in a secure processing domain. With this level of integration cryptographic keys and other secret information can be isolated from applications running on a general purpose CPU integrated on the SoC operating in an open processing domain and be protected from exposure to potential attackers by the security processor. Secret information e.g. cryptographic keys may only be exposed within the protected memory space of the security processor i.e. within the secure processing domain and encryption decryption signing and verification functions may be executed on the security processor. By preventing the secret information from being exposed to the general purpose CPU and or the open processing domain the security of the secret information may be maintained.

Device makers may benefit from this approach by limiting their porting effort to mapping the native security functionality of their platform under this abstraction layer. This may allow the port to be completed with only minimal knowledge of the content protection system being deployed. In the case of SoC based systems that include an integral secure processor the effort needed to harden the system so as to comply with desired or mandated robustness requirements may be simplified.

To implement a secure and robust DRM system e.g. embodiments of the DRM system described in the 693 application and or other content protection systems only basic and commonly supported security capabilities may be required. From these basic primitives higher level functions can be implemented that may provide consistent behavior across different underlying hardware architectures. For example in some embodiments the basic security capabilities of the underlying platform might include a secret device key e.g. a symmetric or asymmetric secret device key basic cryptographic primitives and or an integrity protected bootstrap.

In certain embodiments an application programming interface API is provided an abstraction of which may be an SKB configured to operate as a secure programmatic abstraction layer. The SKB may be realized by the presence of a secured secret device key or keys that in certain embodiments may be referred to as a Master Key. In some embodiments the Master Key may be securely embedded in a hardware security element e.g. One Time Programmable OTP memory such as a SoC or Trusted Platform Module TPM . In some embodiments the Master Key may comprise a white box cipher key or other type of key that is sufficiently protected so as to act as a root of trust used to enable the secure marshalling of other keys and credentials into the Secure Key Box.

In one embodiment when a device boots or prior to loading a DRM and or other relevant software application the SKB software code module may be verified to determine if it is trusted. The mechanism by which this is accomplished can be a platform specific function. In certain embodiments verification of whether the SKB software code module is trusted may be performed through signature verification of the SKB software module. In certain embodiments having a Master Key embedded within a hardware security module e.g. SoC or TPM enables this verification step to be very robust.

In some embodiments the Master Key can be used directly to verify the integrity of the code while in other embodiments a more flexible approach can be employed in which the Masker Key can be used to marshal an integrity protected trust anchor or a confidentiality protected symmetric key from a secondary storage e.g. non volatile random access memory NVRAM . This technique of storing secrets and trusted information may be referred to as a Vault. Once this trust anchor or key has been securely loaded from secondary storage it can then be used by a integrity protected bootstrap to verify the signature over the SKB code module.

Other than the secure storage of the Master Key some embodiments of an SKB need no additional secure storage and may rely on a Vault to securely store any trusted data that may be necessary in secondary storage. That is in such embodiments secret and trusted information may be stored in secondary storage so long as the information at rest is protected by the Master Key or some other key that is confidentiality protected by the Master Key.

In certain embodiments an SKB can be used to enable an application executing in an open processing domain to use cryptographic keys without directly exposing the value of the cipher key to the application i.e. keeping the value of the cipher from being exposed in the clear or the open processing environment . The SKB API may provide a mechanism to load cryptographically wrapped keys e.g. keys encrypted with another key into the SKB and then to use the loaded key in cryptographic operations. The first key loaded into the SKB may be unwrapped with the Master Key and other keys can be then loaded and unwrapped accordingly.

In some embodiments the SKB API may expose common cryptographic methods to encrypt decrypt sign verify and digest buffers that may possibly include secret data to applications executing in the open processing domain. In some embodiments the SKB implementation may support one or more cryptographic algorithms. For example the SKB implementation may support one or more of the following cryptographic algorithms 

The SKB API may implement additional cipher modes of operation such as cipher block chaining CBC and counter CTR . In certain embodiments given their inherent security these cipher modes could be safely implemented outside of the SKB in an open processing domain. It will be appreciated that the aforementioned algorithms are just examples and that any suitable algorithm s could be supported.

The system architecture may further include media processing blocks that may incorporate a central processing unit CPU a graphics processing unit GPU decoder and input output I O functionality. An operating system OS may also be included to manage and coordinate in part system hardware resources and provide for common services for execution of various applications.

Firmware may be included that can supply the SoC specific interfaces to the media and security processing components. In certain embodiments this firmware may be trusted. In some embodiments the SoC boot sequence may verify the integrity and authenticity of the firmware . The security and media processing components may be exposed to applications e.g. media application by the operating system as devices. Drivers that may be trusted can be configured to interface with these devices. Additional trusted software components included in the system architecture may include an SKB and a DRM client binary. In certain embodiments mechanisms may be included to verify the integrity and trustworthiness of these components. In some embodiments the system architecture integrates some degree of sandboxing that may ensure that unauthorized applications cannot access secure resources including for example system memory or a media processing pipeline.

As discussed above a secure programmatic abstraction layer may function as an SKB API . Consistent with some embodiments the SKB API may provide a simple programmatic interface to enable the use of cryptographic keys without exposing this sensitive information to a calling application operating in an open processing domain e.g. media application . For example in one embodiment the SKB API supports common cryptographic functions such as unwrapping a key inside the SKB and then using this key to decrypt bulk data within the secure environment of the SKB.

An SKB Engine object may be initialized via an SKB API that represents an instance of a secure processor engine that can manage and operate on secret data e.g. cryptographic keys and the like . In certain embodiments the secret data may not otherwise be accessed by a calling application. A client application may execute a calling operation to obtain an SKB Engine and a releasing operation to release the SKB Engine. In some embodiments an SKB Engine may provide at least the following categories of functionality 

In some embodiments the abstractions exposed by the SKB API may include SKB SecureData SKB Transform and SKB Cipher objects. Exemplary SKB Engine methods relating to these abstractions may include 

An SKB SecureData object may allow a calling application to refer to and operate on data ensconced secured and protected within the SKB that may not otherwise by accessed by the calling application e.g. cipher keys or arbitrary byte sequences . In one embodiment SKB Secure Data objects may be named so that a calling application can locate a specific secret within the SKB. For example an application can query the SKB for the Master Key by its name e.g. OTPKey0 so that it can load and unwrap cryptographic key material that may be stored external to the SoC.

In some embodiments an SKB SecureData object can be created for each secret data to be operated on by the SKB. In certain embodiments to create an SKB SecureData object an appropriate SKB Engine method may be called. For example calling SKB Engine CreateDataFromWrapped may create an SKB SecureData object that represents secret data created from unwrapping i.e. decrypting specified cryptographically wrapped data.

As described above an SKB SecureData object may be used to represent secret data having values that are not exposed to client applications executing in an open processing environment but can be operated on by the SKB API implementation 130. Client applications may ask for data characteristics of secret data referenced by an SKB SecureData object such as its size in bites and its type and can call the SKB API to operate on the secret data. Client applications may further reference secret data within the SKB via an SKB SecureData object. Methods relating to SKB SecureData objects may include 

In some embodiments SKB SecureData can be persisted. For example if a client application needs some secret data to be persistent so that it is available across reboots and or resets or if the client application wishes the secret data to be available outside the secure processing domain the client application may ask the SKB API for a protected form of the secret data that can be exported or persistently stored since client applications may not obtain the secret data bytes in the clear. When the persisted data is needed later the client application may request to have the exported or persisted data imported e.g. unencrypted and in certain embodiments referenced by a new SKB SecureData object.

In certain embodiments persisting SKB SecureData across reboots and or resets returns a serialized form of the SKB SecureData object encrypted using a permanent key e.g. Master Key or a derivative thereof . In some embodiments this persisted serialized form will be an encrypted representation of the secret data. Using a built in permanent key e.g. the Master Key or a derivative thereof that the SKB API implementation supports the persisted encrypted representation can be unwrapped upon a restart.

In some embodiments upon boot or the first time an SKB Engine is created after a boot the SKB API may generate a random number called a transient export key. When the SKB API is called by a client application to export data outside the secure processing domain that does not need to be persistent across reboot a serialized form of the SKB SecureData may be created. For example data to be exported along with information regarding the data type size and the like may be exported after encryption by the transient export key. Later when the client application requests that the exported data be imported back into the SKB the transient export key may be used to decrypt the exported data.

An SKB Cipher object may encapsulate attributes and parameters used to perform cryptographic operations on SKB SecureData objects. Particularly SKB Cipher objects may be called by client applications through the SKB API to encrypt or decrypt data. In some embodiments an SKB Cipher object may be created by calling an appropriate SKB Engine. Methods relating to SKB Cipher objects may include 

When an SKB Engine is called to create an SKB Cipher object the calling application may indicate whether the cipher operation is an encryption or a decryption operation the relevant encryption decryption algorithm any flags indicating cipher usage any parameters required by the algorithm the SKB SecureData holding the encryption or decryption key used by the SKB Cipher method and or the address of a pointer that the method will set to refer to the SKB Cipher object that is created.

An SKB Transform object may be called by a client application through the SKB API to perform operations on secret data included in a secure processing domain such as calculating a digest signing data or verifying a signature and returning a result to a client application. Methods relating to SKB Transform objects may include 

The SKB Transform object may encapsulate attributes and parameters to perform cryptographic operations on and with SKB SecureData objects. In one embodiment the SKB Transform supports any of the cryptographic operations described above. Using the SKB Transform and SKB SecureData objects the underlying SKB API implementation may operate on secret data as desired using the integral security functions of the secure processor and or the secure processing domain.

The SKB API may support cloaking fields within an SKB SecureData object. In some embodiments SKB Data Cloak methods may provide mechanisms to process encrypted data that ensconces other secrets. The cloaking mechanism may ensure that secrets continue to be protected by the SKB while enabling a client application operating in the open processing domain to process the decrypted e.g. encapsulating data structure. For example an application may need to process encrypted complex XML content that contains keys or other secrets within child elements. However merely decrypting the encrypted XML and returning the plaintext to the application would expose these encapsulated secrets.

In some embodiments cloaked data represents secret data that appears inside a data structure that is cloaked in place before the data structure is returned to a calling client application executing in an open processing domain. This enables the caller to parse the public part of the data structure and extract the cloaked fields from it in order to feed them back to the SKB API for performing secure operations. In this manner the value of the cloaked or secret fields in the data structure may not be revealed to the calling application operating and the security of the secret data contained in these fields is preserved.

The client application can now have the SKB perform any operations and transformations on the decrypted data structure that require use of the cloaked secret data.

The exemplary system may comprise a general purpose computing device such as a personal computer or a network server or a specialized computing device such as a cellular telephone personal digital assistance portable audio or video player television set top box kiosk gaming system other embedded device or the like. As illustrated in the system may include a processing unit system memory which may include high speed random access memory RAM non volatile memory ROM and or one or more bulk non volatile computer readable storage mediums e.g. a hard disk flash memory etc. for storing programs and other data for use and execution by the processing unit a port for interfacing with removable memory that may include one or more diskettes optical storage mediums flash memory thumb drives USB dongles compact discs DVDs etc and or other computer readable storage mediums a network interface for communicating with other systems via a network such as for example the Internet a local area network a virtual private network and the like using one or more communication technologies e.g. wireless Ethernet and or the like a user interface that may include a display and or one or more input devices such as for example a touchscreen a keyboard a mouse a track pad and the like and one or more busses for communicatively coupling the elements of the system .

In some embodiments the system may alternatively or in addition include a secure processing unit SPU that is protected from tampering by a user of system or other entities by utilizing secure physical and or virtual security techniques. An SPU can help enhance the security of sensitive operations such as key management signature verification and other aspects of the digital rights management process. In certain embodiments the SPU may operate in a logically secure processing domain and be configured to protect and operate on secret information as described herein. In some embodiments the SPU may include internal memory storing executable instructions or programs configured to enable to the SPU to perform secure operations as described herein.

The operation of the system may be generally controlled by a processing unit and or operating by executing software instructions and programs stored in the system memory and or other computer readable media such as removable memory . The system memory may store a variety of executable programs or modules for controlling the operation of the system . For example the system memory may include an OS that may manage and coordinate in part system hardware resources and provide for common services for execution of various applications and a DRM engine for implementing DRM functionality. The system memory may further include communication software configured to enable in part communication within and by the system applications e.g. media applications and data and or content .

The systems and methods disclosed herein are not inherently related to any particular computer or other apparatus and may be implemented by a suitable combination of hardware software and or firmware. Software implementations may include one or more computer programs comprising executable code instructions that when executed by a processor may cause the processor to perform a method defined at least in part by the executable instructions. The computer program can be written in any form of programming language including compiled or interpreted languages and can be deployed in any form including as a standalone program or as a module component subroutine or other unit suitable for use in a computing environment. Further a computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network. Software embodiments may be implemented as a computer program product that comprises a non transitory storage medium configured to store computer programs and instructions that when executed by a processor are configured to cause the processor to perform a method according to the instructions. In certain embodiments the non transitory storage medium may take any form capable of storing processor readable instructions on a non transitory storage medium. A non transitory storage medium may be embodied by a compact disk digital video disk a magnetic tape a Bernoulli drive a magnetic disk a punch card flash memory integrated circuits or any other non transitory digital processing apparatus memory device.

Although the foregoing has been described in some detail for purposes of clarity it will be apparent that certain changes and modifications may be made without departing from the principles thereof. It should be noted that there are many alternative ways of implementing both the processes and apparatuses described herein. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

An illustrative example of code implementing an SKB API consistent with embodiments of the present disclosure is provided below 

