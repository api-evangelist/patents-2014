---

title: Platform for providing customizable brand experiences
abstract: A computer-implemented method provides customizable brand experiences. The method includes providing a server coupled to a storage system and coupled to a network. The storage system stores end-user data, associated with a first plurality of brands, and a second plurality of end-users. Additionally the method includes operating the sever to run a plurality of modules, each module associated with at least one of the brands and customized to provide an outcome message as an output, conditioned on a change in end-user data from one state to another state, wherein the change from the one state to the other state is further conditioned on receipt by the server of a programmable pattern of a set of trigger messages. Finally, the method includes making the outcome message available over the network to an outcome destination client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09218609&OS=09218609&RS=09218609
owner: Xperiel, Inc.
number: 09218609
owner_city: Sunnyvale
owner_country: US
publication_date: 20140415
---
The present invention relates to the area of server based software services and more particularly to computer implemented methods for providing customizable brand experiences in relation to usage of computer devices such as mobile smart phones.

Since the presently described invention touches on several fields it is useful to discuss prior art in these separate areas.

MIT has produced an educational programming language called Scratch which is meant to make it easier to program computers so that children can understand it.

Google and other companies have built mapping services which are based on a combination of tile servers as well as vector graphics. Google has integrated its mapping services with its Street View fleet of cars with cameras on the roofs in order to create a further ground level view of the world s streets.

There are several advertising networks which specialize in mobile advertising including AdMob iAd InMobi and others. Their strategy is to advertise in existing apps and on mobile web pages using technology such as banners and interstitials.

Pebbling is an advanced topic in computer science and an overview can be found in the Ph.D. theses of the inventors. For example see Applications of Games to Propositional Proof Complexity. A. Hertel University of Toronto 2008 or Clause Learning Resolution Space Pebbling. P. Hertel University of Toronto 2008.

In a first embodiment of the invention there is provided a computer implemented method of providing customizable brand experiences. In this embodiment the method includes providing a server the server coupled to a storage system and coupled to a network wherein the storage system stores end user data associated with a first plurality of brands and a second plurality of end users. Additionally the embodiment includes operating the sever to run a plurality of modules each module associated with at least one of the brands and customized to provide an outcome message as an output conditioned on a change in end user data pertinent to a given one of the end users with respect to the at least one of the brands from one state to another state wherein the change from the one state to the other state is further conditioned on receipt by the server of a programmable pattern of a set of trigger messages. Finally the embodiment includes making the outcome message available over the network to an outcome destination client.

In a related embodiment the set of trigger messages includes at least one trigger message received over the network or as an interprocess communication within the server in the group consisting of i a game event message from an electronically monitored game ii a message received from an application programming interface or via HTTP POST pertinent to the at least one of the brands iii a message pertaining to purchase of an item that is distinct from the outcome message itself and iv a message received from a device of the given one of the end users pursuant to an application running on the device associated with the at least one of the brands.

In yet another related embodiment the programmable pattern is established by stored configuration data and wherein the configuration data is modifiable by a representative of the at least one of the brands via a graphical user interface. Optionally the stored configuration data associated with a given one of the modules includes source code for the given one of the modules. Alternatively or in addition at least a portion of the stored configuration data associated with a given one of the modules is an input to the given one of the modules.

Optionally the method includes receiving by the server updated configuration data for a given one of the modules from a client computer coupled to the server such data obtained by graphical manipulation by a representative of the at least one of the brands wherein distinct graphical elements represent triggers states and the output and manipulation of the graphical elements in relation to one another defines the programmable pattern.

In a further related embodiment using what we have called our Pebbling Language the programmable pattern is defined by i a set of icons that graphically represent nodes wherein each node is a potential state and a transition from one potential state to another potential state is indicated by a directed edge between two node icons ii a set of pebbles wherein a pebble placed on a selected node icon indicates a change in state of the node corresponding to the selected node icon and wherein the set of deployed pebbles collectively represents a machine state of the given one of the modules and iii a set of trigger receivers each trigger receiver representing a distinct trigger message wherein a given trigger receiver associated with a given directed edge between two node icons causes a pebble to move in the direction of the given directed edge from a first one of the two node icons to a second one of the two node icons on receipt of the trigger message associated with the given trigger receiver.

Optionally each node is configurable to have 0 or more types and each distinct type of node performs a distinct action when such node changes state as indicated by placement of a pebble thereon. Also optionally a plurality of node icons may be arranged graphically in a group and the group of nodes is deemed to be pebbled when a designated threshold number of node icons have been pebbled.

In a further related embodiment the method includes receiving by the server over the network a stream of sourced trigger messages from a server of a partnering brand and relaying the stream of sourced trigger messages to an account of a subscribing brand for use by the subscribing brand with respect to at least one of the modules.

In another related embodiment the method further includes in connection with a trigger monitorable activity storing by the server a selection of a sponsoring brand applicable to a participating end user responsive to the stored sponsor selection receiving by the server an activity trigger stream pertinent to the trigger monitorable activity and relaying the received activity trigger stream to the account of the sponsoring brand.

Optionally the method includes before storing by the server the selection of a sponsoring brand applicable to the participating end user receiving the selection by the server over a network from a device of the participating end user. Also optionally the method further includes before storing by the server the selection of a sponsoring brand applicable to the participating end user making the selection by the server. As a further option making the selection by the server includes evaluating by the server data characterizing bids received from an auction.

In another related embodiment the activity trigger stream is defined by a default set of triggers applicable to the trigger monitorable activity.

In another embodiment the invention provides a computer implemented method of providing customizable brand experiences. The method of this embodiment includes 

providing a server the server coupled to a storage system and coupled to the Internet wherein the storage system stores end user data associated with a first plurality of brands and a second plurality of end users 

wherein the server receives trigger messages over the Internet from heterogeneous sources and transmits them to a Logic Engine operating on the server that executes a plurality of modules each module associated with at least one of the brands and customized to provide an outcome message as an output conditioned on a change in end user data pertinent to a given one of the end users with respect to the at least one of the brands from one state to another state wherein the change from the one state to the other state is further conditioned on receipt by the server of a programmable pattern of the trigger messages 

so that the server acting as a cloud based operating system which executes the modules implements a universal Internet event bus that receives the trigger messages and responsive to them and to the modules provides outcome messages.

In another embodiment the invention provides a computer implemented method of providing brand sponsorship opportunities and the method includes in connection with a trigger monitorable activity storing a selection of a sponsoring brand applicable to a participating end user. The method additionally includes responsive to the stored sponsor selection receiving by the server an activity trigger stream pertinent to the trigger monitorable activity and relaying the received activity trigger stream to the account of the sponsoring brand. Optionally the method further includes before storing by the server the selection of a sponsoring brand applicable to the participating end user receiving the selection by the server over a network from a device of the participating end user. Also optionally the method further includes before storing by the server the selection of a sponsoring brand applicable to the participating end user making the selection by the server. Optionally making the selection by the server includes evaluating by the server data characterizing bids received from an auction.

In another embodiment the invention provides a computer implemented method of providing an exchange for consumers having brand loyalty accounts that store brand loyalty points. In this embodiment the method includes storing in an exchange store a set of current exchange rates for transfer of points from one brand loyalty account to another brand loyalty account. Additionally the method includes receiving over a network by a server from a client computer of a consumer a transfer request to transfer a selected number of points from a first selected brand loyalty account to a second selected brand loyalty account. The embodiment includes in a verification computer process verifying that i the consumer is authorized to perform the transfer and ii the first account has stored a sufficient amount of points to enable the transfer to be effectuated. Additionally the embodiment includes retrieving from the exchange store a current rate for transfer of points from the first selected brand loyalty account to the second selected brand loyalty account in an exchange calculation computer process using the retrieved exchange rate for transfer of points determining the number of debit points to be debited from the first brand loyalty account and the number of credit points to credited to the second brand loyalty account and in a transfer computer process transmitting over the network a debit post message causing the first brand loyalty account to be debited by the debit points number and a credit post message causing the second brand loyalty account to be credited by the credit points number.

Optionally the exchange calculation computer process also includes calculating an exchange commission that is debited from at least one of the first brand loyalty account and the second brand loyalty account.

In yet another embodiment the invention provides a computer implemented method of generating source code for a module that when executed on a computer provides an output conditioned on a change in end user data pertinent to a given end user from one state to a another state wherein the change from the one state to the other state is further conditioned on receipt by the computer of a programmable pattern of a set of inputs. The method of this embodiment includes providing a graphical user interface wherein distinct graphical elements represent the inputs states and the output and manipulation of the graphical elements in relation to one another defines the programmable pattern and using the graphical user interface to define graphically the programmable pattern of the set of inputs upon which the change from the one state to the other state is further conditioned.

In a further related embodiment the programmable pattern is defined by i a set of icons that graphically represent nodes wherein each node is a potential state and a transition from one potential state to another potential state is indicated by a directed edge between two node icons ii a set of pebbles wherein a pebble placed on a selected node icon indicates a change in state of the node corresponding to the selected node icon and wherein the set of deployed pebbles collectively represents a machine state of the module and iii a set of trigger receivers each trigger receiver representing a distinct trigger message wherein a given trigger receiver associated with a given directed edge between two node icons causes a pebble to move in the direction of the given directed edge from a first one of the two node icons to a second one of the two node icons on receipt of the trigger message associated with the given trigger receiver.

Optionally each node is configurable to have 0 or more types and each distinct type of node performs a distinct action when such node changes state as indicated by placement of a pebble thereon. Also optionally a plurality of node icons may be arranged graphically in a group and the group of nodes is deemed to be pebbled when a designated threshold number of node icons have been pebbled.

As used in this description and the accompanying claims the following terms shall have the meanings indicated unless the context otherwise requires 

A server includes a hardware implemented server a cluster of computers configured to operate as a hardware implemented server and a set of logical processes configured to perform functions associated with a hardware implemented server.

An affinity group is a grouping of individuals having a shared interest which may for example be 1 an interest in goods or services from a particular source which in turn may be identified by a trademark 2 an interest in celebrating the birthday of a particular child or 3 an interest in a program of a school in rewarding performance or participation by students in some activity such as a spelling bee an athletic competition academic achievement etc.

A module is a program created using the embodiment of the present system that provides a customized user brand experience. Specifically a module when deployed runs on the server and portions of the module run on a device of a user have the customized brand experience. Contrast this definition with that of the definition for application .

 Source code for a program is human readable code that when compiled or interpreted can be executed by a device source code therefore includes a module written in our Pebbling Language.

An end user is a consumer using any device which is running a module created with the embodiment of the present system by a brand.

A trigger message is a message that encodes and communicates the occurrence of an event previously defined and stored by a brand in the Logic Engine as a trigger event. The message is transmitted either 1 over a network from an Internet connected device or server to the Universal Event Bus of and thereafter to the Logic Engine of or 2 from within the Logic Engine as an inter process message to another part of the Logic Engine . Although a first brand typically has possession of its own trigger messages a second brand may subscribe to the first brand s trigger messages in which case the resulting stream of trigger messages is said to be sourced . See definition of trigger .

A trigger is a configuration of an apparatus to cause generation and sending of a trigger message on the occurrence of a trigger event. See trigger message . A trigger is typically configured by a brand in connection with development of at least one module by the brand. However once a brand has configured a set of triggers the resulting stream of trigger messages may be made available to another brand by subscription in which case the resulting stream of trigger messages is termed a stream of sourced trigger messages . 

A trigger monitorable activity is an activity wherein events in the course of the activity can be monitored according to machine state of a relevant set of monitoring devices so that among the events a trigger may be associated with each type of event. One such trigger monitorable activity is a web based electronic game. Another is wherein an individual has traveled to a specific geolocation and confirmed the geolocation with the individual s mobile device. Yet another includes participation in a virtual reality or augmented reality experience in which certain actions cause triggers to be fired. In effect trigger monitorable activities are any type of activity for which participation can be measured by creating a trigger that if fired by an end user would imply that he she is indeed participating in that activity. As such any type of trigger can be used to monitor an activity and additional trigger monitorable activities are discussed below.

A programmable pattern is a pattern of trigger messages that form a condition for the generation of an outcome message. A programmable pattern may be determined when the module is itself programmed or otherwise built into the Logic Engine alternatively the programmable pattern may be defined separately from programming of the module or of the Logic Engine.

An outcome message is a message provided as an output of a module made available to an outcome destination client wherein the output is conditioned on a change in end user data pertinent to a given one of the end users with respect to at least one brand.

An outcome destination client is a device coupled over a network to the Logic Engine and configured to receive outcome messages.

 End user data is data providing for each of n end users a value of each of a set of attributes but the data for any given user may lack values for some of the attributes.

A brand representative is an individual acting on behalf of a brand in configuring a customized module to provide to a set of end users an outcome message in connection with the brand.

A module template is the definition of a module which is not associated with any particular end user. By contrast a module instance is the product of instantiating a module template for a particular end user so there can be only one template but many instances of it.

The act of minting a module or other digital object is the process of instantiating an instance of that module s template.

An application is a program that is written for deployment on a device running in its regular native mode.

A device is a machine or product containing a CPU and memory that can execute programs. A mobile device is a device that is readily portable.

A computer process is the performance of a described function in a computer using computer hardware such as a processor field programmable gate array or other electronic combinatorial logic or similar device which may be operating under control of software or firmware or a combination of any of these or operating outside control of any of the foregoing. All or part of the described function may be performed by active or passive electronic components such as transistors or resistors. In using the term computer process we do not necessarily require a schedulable entity or operation of a computer program or a part thereof although in some embodiments a computer process may be implemented by such a schedulable entity or operation of a computer program or a part thereof. Furthermore unless the context otherwise requires a process may be implemented using more than one processor or more than one single or multi processor computer.

A splice is a utility program that can be incorporated using an API into a stand alone application which runs on a user device in order to configure the stand alone application to provide a brand experience to the user.

This ecosystem creation platform is in many ways much more powerful than any previously envisioned compiler or integrated development environment IDE . It can be used by brands companies stores or even individuals to create simple but compelling applications programs i.e. modules and games which can be deployed via a wide variety of devices including but not limited to smart phones tablet computers laptops desktop computers smart watches optical head mounted displays and other wearable computers onboard vehicle computers gaming platforms and so forth. However unlike typical IDEs which are only capable of creating software applications the embodiment of the presently described platform also creates the ecosystems in which they will operate.

For instance present system can be used to create or augment a mobile app as well as creating and deploying a broad set of heterogeneous real world triggers with which that app will interact. In that sense this embodiment of the presently described invention is a universal Internet event bus and programming platform but can also be viewed as a marketing platform which is capable of tying together all existing advertising channels. For instance by creating and deploying triggers to a wide variety of standard advertising channels such as print television bus stops billboards radio and digital mediums the embodiment of this invention upgrades all traditional advertising to become digital and interactive in effect creating a rich ecosystem in which the user of a brand s app can interact with that brand s sophisticated marketing campaign that spans both cyberspace as well as the real world.

The embodiment of the presently described programming platform differs radically from previous and existing programming environments and IDEs in several respects described immediately below and then in much greater detail later in this exposition 

1. IDE vs. Ecosystem Creation Platform One key difference between traditional IDEs and this embodiment of the presently described invention is that the former consist almost entirely of compilers or interpreters with peripheral services such as Eclipse s Android simulator and Microsoft Visual Studio s Azure cloud deployment functionality. These are used mostly to create debug test and deploy software applications. By contrast the embodiment of the present invention has all of this standard functionality for creating modules but also has the ability to create the ecosystem in which these software modules will be used. For instance in one embodiment the presently described platform provides a web based programming environment which can be used through any web browser. It not only provides tools for the creation deployment and hosting of applications as well as their support services but also for building the components of the real world ecosystem i.e. triggers in which those applications will function. In addition once a module has been deployed and is operating the platform provides the analytics tools for reporting both vital and subtle usage details through charts graphs heat maps and so on. It exposes all of these powers and functionality within one unified and integrated service in which the parts are joined seamlessly and efficiently. Although a portion of the present invention can also be implemented as a stand alone application like Microsoft Visual Studio or Eclipse the preferred embodiment is for it to be implemented as a cloud based service providing further differentiation from existing means of creating programs.

Traditional programming environments and IDEs typically allow for the creation and manipulation of applications whose inputs reside on devices such as desktop computers and end users typically interact with these applications while indoors most often seated in front of these devices. More recently the same programming environments have made it possible to create mobile applications which are instead deployed to devices such as smart phones allowing end users to run these applications outdoors. However the predominant input mode on mobile devices is still largely identical to that of laptops and desktop computers in that in all of these cases end users input their wishes and commands into a screen. The means of input e.g. keyboard vs. mouse vs. touch screen may vary greatly but the paradigm of inputting commands directly into a graphical user interface remains the same.

By contrast the presently described programming platform enables the creation and manipulation of modules which in addition to having standard graphical user interfaces also have an additional new set of possible inputs called triggers. These input interaction points are also created and hosted using the embodiment of the presently described platform and they can be situated in the physical real world although they can also exist on servers or in cyberspace. Previous IDEs of course also make it possible to access a device s sensors but what they do not do and what is unique to the embodiment of the presently described platform is the high level ability to easily create and deploy an entire network of heterogeneous triggers so that programmers don t have to write low level code every time they want to create a real world interaction. In that sense previous attempts to adapt traditional programming languages compilers and methodologies to the new mobile world have completely failed to recognize the importance of a mobile device s multitude of sensors in order to greatly extend the input signals available to applications. They make it possible to access and use a device s sensors but they fail to bring them to the forefront where it becomes easy to create and use them.

The embodiment of the present invention therefore creates a new paradigm of ecosystem centric computing. Rather than depending on inputs being located mostly within the software and hardware user elements of a device the embodiment of the present system is characterized by also easily exposing and providing many more inputs triggers many of which can be located in the physical world. In order to get inputs from the triggers in the physical world the end user interacts with them using a computing device so that rather than end user inputs being initiated internally from within the device they exist outside of it and are triggered externally using the device s sensors. In addition other types of triggers can be located in software or in cyberspace rather than in the real world. This creates a universe in which modules running on a variety of devices have vastly more and vastly richer opportunities for interaction.

2. User Friendliness In one embodiment the system s most unexpected characteristic which differentiates it from existing programming environments is its user friendliness. This is achieved by a surprising and radical departure from the core feature of traditional programming languages in that ours does not have a grammar or syntax. Standard programming languages such as Java C C C etc. each have a syntax defined by a context free grammar that can be captured using Backus Naur form which means that these are all text based programming languages. By contrast the embodiment of the presently described new programming language is entirely visual and not text based at all. Rather than being based on syntax and grammar the presently described language at its core is based on an entirely different concept from unrelated area of computer science Pebbling Games. An interested reader is referred to the Ph.D. theses of the inventors. For example see Applications of Games to Propositional Proof Complexity. A. Hertel University of Toronto 2008 or Clause Learning Resolution Space Pebbling. P. Hertel University of Toronto 2008. Unlike programming languages which comprise their own distinct area of computer science pebbling games are an advanced topic which come from the areas of graph theory and computational complexity. They are simple one player games that are typically used to prove logical results in these areas and are of interest to us because they have two very useful properties The first is that they are games which are so simple that even a child can quickly understand and master the rules. The second is that pebbling is immensely powerful from a computational complexity point of view and is particularly good at capturing the notion of state. This contrast is important because it goes against the typical trend in nature that power and flexibility usually come at the expense of simplicity but in this case we find them entwined together and are able to exploit this remarkable fact by using pebbling as the basis for building a unique graphical programming language which is Turing Complete.

In one embodiment of the presently described graphical programming language the programmer uses the embodiment s web based interface to build graphical diagrams that encode the workings of a computer module. The key characteristic of this new way of programming is that it is extremely visual intuitive and requires little or no prior training in computer science. This stands in stark contrast with traditional syntax grammar based programming languages which require a great deal of expertise education and experience before programmers are able to achieve proficiency. In other words using the embodiment of the presently described Pebbling based Programming Language even people without technical backgrounds can use it to create sophisticated and compelling modules. This Pebbling Language is only one embodiment and of course it is possible to use a more traditional language such as Java or any other programming language instead.

3. Additional Components In addition to the core functionality and characteristics described above the embodiment of the present system also contains several additions to this core functionality which are deeply integrated and will also be described in greater detail below. In brief they are 

Sponsorship Junctions Since the embodiment of the present system can been used to build rich ecosystems of applications and triggers the question then becomes how to construct the most efficient ecosystems to achieve certain goals. For instance brands might build a trigger based ecosystem in order to create more compelling interactive experiences for customers using their apps. Similar ecosystems could be built in order to allow brands to sponsor people for doing normal everyday activities such as playing video games or visiting theme parks. In this type of relationship an experience provider such as a video game maker or theme park owner may wish to create a Sponsorship Junction in which this owner defines a number of triggers and then invites various brands with their apps to sponsor that event. These brands define logic that makes use of the incoming triggers from the game to offer sponsorship benefits in the form of rewards and in app state changes to end users who are participating in the experience. The end user then selects his her favorite sponsor from those who have signed up and receives rewards from that sponsor as he she plays the video game or goes on rides at the theme park. Part of the Sponsorship Junction s role is to facilitate the mechanics of sponsorships and rewards linking the event s triggers to events in a brand s app but the other main function is to simplify the required business development so that rather than having say every game developer have to make a separate deal with every sponsor each entity only makes one deal with the Sponsorship Junction thereby drastically reducing the business complexities involved. The overall embodiment of the presently described system includes these Sponsorship Junctions and their functionalities as a sub component.

Loyalty Points Exchange One standard type of loyalty program involves brands awarding loyalty points to customers and since the presently described programming language is Turing Complete it can easily implement this type of program for many brands all within the same system. Because of this and unlike current brand loyalty points systems which are siloed from each other the embodiment can enable new functionality in the form of a Loyalty Points Exchange. This is a service which acts something like a currency exchange except for loyalty points. For instance an end user might have accounts and loyalty points with both Brand and Brand within the embodiment of the present system and wants to redeem points from Brand in order to receive some kind of reward but doesn t quite have the required number of points. This end user can then convert points from Brand to those of Brand according to the system s current exchange rate in order to then be able to afford the reward. The system does this in a way such that both brands as well as the end user end up profiting from the transaction. The overall embodiment of the present invention includes a Loyalty Points Exchange and its functionality as a sub component.

Trigger Streams In the same way that Twitter allows individual users to broadcast messages there is value in the ability for individuals or entities to broadcast triggers and the embodiment of the present invention contains a sub component enabling this functionality which we call Trigger Streams . For instance a company or information provider can use the embodiment of the present system to broadcast a stream of triggers to which brands or other information consumers using the embodiment can subscribe and then react to some or all of the triggers in that stream.

The system s Logic Engine is the nerve center of the embodiment of the present invention and includes database tables containing account data for one or more partners brands companies individuals etc. who use this system. This embodiment is used to define a module template which in turn is then used to instantiate an instance of the module for an individual user. This allows different end users modules to be in different states. Each account contains the logic and data for one or more modules as well as end user data for each of their end users in the context of each module. This feature saves the system s partners from having to host and manage all of their own end user data and will also help them to decrease latency. Note that every end user does not necessarily have an account with every partner and within each partner each user does not necessarily have data associated with every module since every end user might not even have each of the modules.

The system s Logic Engine is connected via the Internet to various partner servers which are running software allowing data to be shared with the present system such that individual partner servers and are associated with their corresponding account data within the Logic Engine. This allows partners who for privacy or other reasons require that the end user data be stored on their own systems to work with us.

The system Logic Engine is also connected to its Trigger Network . Much like module and end user data trigger definitions are stored with a partner s account data in the system s Logic Engine. Triggers are heterogeneous in that there are many diverse types which can work in various different ways. More information on these different trigger types will be given later in this exposition but their commonality is that they all define a data message which can be sent from various different sources to the system s Logic Engine where one or more modules are registered to listen for them and in turn change state or react to that message. Some trigger types consist largely of data and exist in the Logic Engine with a low tech representation such as a QR code in the real world. When the end user interacts with that representation the module being run on the end user s device causes the logical aspect of that trigger to be found and fired. In that sense the visual call to action associated with triggers does not necessarily have a technological hardware component. However in some cases they do and in other cases they can exist as software on third party servers . In many cases triggers are user initiated but in some they are not. One aspect that they all share is that they help to create the ecosystem in which a module has many interaction points. Triggers can contain metadata such as the geolocation or IP address from where they originated. They can also have restrictions on them indicating that they cannot be fired from certain locations or under certain circumstances such as outside of specific time windows.

The system s Logic Engine is also connected by way of the Internet to individual end user devices . These devices run applications created by the system s partners and these applications can be partially programmed by them using traditional IDEs but can also be entirely defined using the embodiment of the present system. In the hybrid case we make an API available to them which can be spliced into their native applications in order to run the modules which they created in the system s Logic Engine and to the end user this will all seamlessly appear as native code. In this manner of creating sophisticated modules using the system and then splicing them into their native applications even partners without strong technical expertise can very easily add the system s powerful functionality to their apps.

Finally the system s Logic Engine is connected via the Internet to a user friendly graphical interface running in a web browser on an ordinary computer . This user interface has different access levels and is used to control all aspects of the system s Logic Engine. For instance it is used to define modules as well as triggers launch them provide analytics data regarding their usage and so on.

The system s Pebbling based Programming Language is best described together with its user interface. is a representation of a display presenting a main user interface menu for use by a brand representative with an embodiment such as that of of the present invention. In various embodiments the main user interface is accessible through any standard web browser but is readily implemented by other means such as a stand alone application. The system of this embodiment contains standard user account management and login facilities which implement common functionality and therefore don t require further exposition.

In one embodiment the system uses an extreme version of object oriented programming in which a programmer creates self contained atomic objects such as Modules Triggers and Variables which are respectively shown as squares hexagons and circles in this view. The system also supports many other types of objects which are not shown such as but not limited to receivers. The system has facilities for defining the scope and visibility of each object.

Each of these objects performs a different function and objects of similar type are grouped together arranged in horizontal bands. In order to create one of these objects the programmer clicks on a creation button located in the appropriate band at which point a wizard walks that programmer through steps appropriate to the creation of the object for that band requesting information when necessary.

Although these objects are created independently and are self encapsulated they act as building blocks which can be combined and used by other objects. For instance as has already been described in previous sections Triggers form the ecosystem of inputs through which the final modules s created within an account using the embodiment of this system will interact. First they are created independently and then they are referenced by the modules s . Similarly Variables act very much like variables in typical programming languages and have types such as integers Booleans strings dates and so on. Much like Triggers Variables are first created independently and then referenced by the modules s . Receivers can similarly be created independently and then be referenced by modules. The purpose of receivers is to allow a module to register to listen for specific triggers.

Modules are the most important and complicated objects in the system and as already mentioned they are the system s equivalent of programs. They are created within the present embodiment of the system and then deployed to user devices such as smart phones tablets web pages and so on. Modules are the entities within the system that are programmed using the system s Pebbling Language or some other equivalently expressive programming language. In order to program a module using the system s Pebbling Language a programmer clicks on the square icon of a module and opens the Module Editor. The system s Pebbling Language is based on state diagrams and pebbles are placed on these diagrams in order to record which state the modules written using this language are in.

The Module Editor is a mouse driven graphical user interface which implements an editor for creating pebbling state diagrams. It contains a gridded canvas on which the programmer places different components in order to create a state diagram. The canvas has standard controls on the lower left corner such as a zoom slider and a full screen mode toggle .

In order to create pebbling state diagram components the programmer uses the controls in floating edit menu . These controls include standard tools such as a grabber which is used to grab and scroll the canvas using the mouse as well as a selection tool which is used to select an existing component. This menu also includes an undo tool for undoing the last action performed and a redo tool for undoing an undo.

Below those tools we find the tools for creating the components of the pebbling state diagram. The node creation tool is used to place a generic pebbling node anywhere on the canvas. It has a dropdown menu which allows the programmer to first select a specific rather than a generic type of node to place. Next we find an edge creation tool which is used to create a standard edge between two or more nodes. Its dropdown menu acts similarly to the one previously mentioned and allows the programmer to create a specific type of edge rather than a generic one. Finally below this we have a group creation tool which is used to create a default group out of two or more nodes. It also has a dropdown menu allowing the programmer to select a specific type of group to be created.

These three types of components nodes edges and groups constitute the main building blocks of a pebbling state diagram and after they are created their properties can be changed by using the edit tool . How these components function together in order to create a module will be described in greater detail below in .

The final tool in the edit menu is a template selector tool which allows the programmer to quickly and easily create useful common pebble state diagram patterns in order to save time.

The Module Editor s floating view menu is used to change the view of the pebbling state diagram. For instance is the component list view and clicking on it will open a dialog box which provides an interactive list of all of the existing components. Below that we have the grid view controls which allow the programmer to toggle the grid on and off change grid spacing toggle snap to grid functionality and so on. Next we find the layer tool which is used to create and select layers in the editor so that the programmer can better organize the components being created. Each component has a z order field which can also be used for the purpose of hiding components within the layer tool s controls. Finally we have the image toggle tool which is used to toggle Image Nodes to show and hide the images that they contain.

Edges constitute the second major class of components which make up pebbling state diagrams and they form the paths along which pebbles may move from node to node. Edges always lead to at least one node and their point of origin may be a node or a group. Edges may lead to more than one node as is the case with edge which splits into three. The split is based on a probability which is illustrated by the icon at its split point. When a pebble moves down this edge it has a certain probability of taking any one of the three paths. In addition to probability edges the system also has other types of split edges which will be described later.

Edges may have receivers associated with them. Receivers capture the messages which are sent by triggers and they contain icons indicating the type of trigger to which they are bound. A receiver capturing a message from a trigger is the impetus which causes a pebble to move across the edge with which it is associated. Receivers on edges are therefore the mechanism that ties the Pebbling Programming Language to the system s external triggers out in the real as well as virtual world and they are what cause pebbles to move and to change in state. An edge may also have no receivers on it in which case a pebble will simply move across that edge as soon as it arrives at the node constituting the edge s start point. Edges may also have variable conditions associated with them. These allow the programmer to define additional conditions based on previously created variables which must be satisfied before a pebble can move along that edge. So for instance it is possible for a receiver on an edge to capture a message from a trigger but for the pebble at its start point not to move because the variable condition on that edge has not yet been met. Similarly it is possible for a pebble to arrive at an edge without a receiver on it but not cross it since its variable condition has not yet been met.

The final type of component in this embodiment of the system s Pebbling Programming Language is a group . Groups contain two or more nodes and can have two conditions on them. The first is the group condition which defines how many nodes in the group must have pebbles on them in order for the group to be satisfied. In this case the group condition is an AND which means that the group is satisfied only when all nodes in the group have pebbles on them. Other types of group conditions include OR which means that the group is satisfied when any one of the nodes in the group has a pebble on it and yet another type of group condition is a threshold in which say any two out of the three nodes would have to have pebbles on them in order to be satisfied. Other types of group conditions are described later. In addition to group conditions groups can also have variable conditions on them which perform the same function as variable conditions on edges as well as edges leaving them .

Located at the bottom of the Pebbling State Editor screen is a button which starts the system s Simulator.

The Simulator s purpose is to provide the programmer with a means of running and testing a module that was created using the Pebbling Language. is a representation of a display presenting a user interface here in blank in accordance with an embodiment of the present invention for a simulator for testing and running a module created using the editor of . In many ways the Simulator resembles the Pebbling State Editor from and is divided into three panes. The center pane contains the same gridded canvas as well as all pebbling state diagram components on that canvas in precisely the same configuration that they were arranged in the editor. It similarly contains zoom and full screen controls.

The Simulator screen additionally contains two other panes. On the left is the Triggers pane which provides an interactive list of all triggers which are associated with any receivers within the pebbling state diagram. The right hand pane contains the actual Simulator screen and controls. At the top are Simulator options which allow the programmer to select a fake test user for this simulation and to perform all relevant actions on that end user such as resetting the user s data create another fake user and so on. In the center of the Simulator pane we find the preview area which is dedicated to providing a graphical software simulation of a device such as a mobile smart phone or tablet . This simulated screen will show the running module and preview exactly what an end user with a real device would see if the module were deployed in earnest. Below this we find a menu for selecting from many different devices and screen resolutions so that the module can be tested exhaustively on all hardware that is relevant to the market at that time. Next we find the actual Simulator controls which allow the programmer to proceed through the computational steps of the module by resetting stepping through or stepping over the sequence of pebble movements relevant to the execution of the module as is common in standard compilers. In addition the Simulator allows the programmer to drag and drop pebbles to set up the state diagram in any desired configuration. Finally the button in the bottom right hand corner of the screen lets the programmer end the simulation and return to the editor.

The results of this action are shown in . Pebble has moved to node I thereby causing check mark to appear on the game board. The remaining components of the module are tested in a similar manner with the programmer clicking on triggers which in turn gives nodes the impetus to move. The programmer then views the Simulator to make sure that the desired result has occurred therefore verify that it will also occur in the end user s application.

Ultimately embodiments of the present invention with their triggers and Pebbling Language have one main purpose To create applications that can be deployed to the devices of end users. These may be stand alone applications or they can come in the form of utility programs that can be spliced into existing stand alone applications using an API. We refer to these utility programs as Splices .

We have already seen the system s Simulator which allows programmers to test and debug their modules written using the system s Pebbling Language. In addition to the Simulator the system provides another tool for debugging called the Sandbox App . The Sandbox App is a native application which can run on an end user s device. It is meant for debugging or demonstrating a module written using the system s Pebbling Language in the same type of environment that an end user will use the application. Whereas the Simulator is a virtual device and has virtual triggers which are clicked using a mouse the Sandbox App operates on a real device interacting with real triggers. For instance the Sandbox App can run on a smart phone and allow the end user to interact with physical real world triggers. The system can therefore deploy modules written with its Pebbling Language to physical devices in three different ways 1 Being run by the native Sandbox App 2 as a stand alone application and 3 as a splice in an existing application.

In all of these cases the application contains functionality for interacting with triggers and this ability is shown in which is a diagram illustrating high level communication architecture of an embodiment of the present invention for use with an embodiment such as shown in including a non exhaustive list of the system s trigger types. The end user s device running an application created using the system interacts with triggers from trigger set using a user interface and that interaction is sent to the system s Logic Engine via its event bus. This message contains all of the relevant information required to uniquely identify the trigger with which the end user interacted. The Logic Engine receives this message and determines which module is listening for it. Once a relevant module has been identified the Logic Engine determines which edge or edges should receive it and then causes the appropriate pebbles to move and module state to change. There are many different types of triggers several of which are low tech and have no Internet connectivity or ability to communicate directly with the Logic Engine. In these cases the successful trigger interaction is reported back to the Logic Engine directly from the app using channel which is often over the Internet. In other cases the trigger itself is sophisticated enough and has its own ability to report an interaction directly to the Logic Engine over channel also often over the Internet. In this description the end user s app has been running on a mobile device but this example is not meant to be limiting as this could just as easily have been a different device such as a desktop computer.

An important point of note is that the system is able to deploy an immensely diverse range of triggers. It is useful for all triggers to have some visual similarity to each other and in this case they are shown as hexagons although this is not strictly necessary.

Some of the triggers can be deployed in the real world. These Physical Triggers include but are not limited to a Vision triggers which are recognized using a device s camera b Geo triggers which are recognized using a device s GPS c NFC triggers which are recognized by a device s near field communications sensors d Codeword triggers which are recognized when an end user types a certain string into the device e Peer To Peer triggers which are recognized when an end user interacts with another end user s device f Sound Recognition triggers which are recognized by a device s microphone and g Proximity triggers which activate when an end user comes within a specific range of a location person or other object. Triggers need not contain any high technology such as a CPU and in some cases they are as simple as ink on paper.

The system can also deploy several Third Party Triggers which make it possible to integrate with existing social media platforms. These include but are not limited to a YouTube triggers which are recognized when an end user watches a particular YouTube video b Facebook triggers which are recognized when an end user likes or follows a particular person brand or other entity on Facebook c Google Plus triggers which are recognized when an end user 1s follows or adds a particular person brand or other entity to a circle on the Google Plus platform d Twitter triggers which are recognized when an end user tweets a particular message or follows a particular person brand or other entity on Twitter and e Custom API triggers . These are a particularly powerful type of trigger which consist of code that can be run anywhere such as a server making it possible for any business to start sending trigger events to the system s Logic Engine. The system also supports an additional implementation of the system s custom triggers without the use of an API in that any Internet connected device can send a trigger event to the present system using an HTTP POST message which encodes trigger information which uniquely identifies it along with its data and parameters.

Finally the Logic Engine also contains several internal System Triggers which make it possible to send trigger events that are not a direct result of an end user interaction. For example these include but are not limited to a Variable Change triggers which fire when the value of one or more variables change or reach specific thresholds b Pebble Initiated triggers which fire when a pebble lands on a specific node and c Timer triggers which fire at a specific time. One type of system trigger that is a response to an end user interaction is the In App Click Trigger which fires when an end user interacts with a UI element in the app such as a button.

The trigger system is completely flexible and extensible so that any future triggers can be easily added without a great deal of effort. For instance it would be a trivial matter to include virtual reality or augmented reality triggers in which an end user s avatar or the end user him herself could walk into a graphical representation of a trigger in a virtual world or augmented reality scene and thereby cause it to fire. In one sense because of their immense flexibility the Custom API triggers can be used to implement any future trigger although the system can also be upgraded to contain specific new types.

All of these diverse triggers create a universe around the Logic Engine. The Logic Engine is used to create and deploy modules as well as triggers and then the triggers create the ecosystem in which those modules will be used. Because the triggers are heterogeneous this is very powerful because they can be deployed in all genres of advertising. All types of triggers may have metadata associated with them indicating the geolocation or IP address from where they originated information about the identity of the person or entity that fired the trigger the time at which they were fired and so on. When defining triggers it is also possible to place restrictions upon them such as geographic areas in which they can or can t be fired time windows inside or outside of which they can or can t be fired and so on. These restrictions are useful for entities such as national brands who only want triggers to be usable in a particular state or country or during certain hours to render them inoperable outside of those regions or times. The system can also have many other types of metadata and restrictions imposed on its triggers and these examples are not meant to be limiting.

Because they are heterogeneous the various triggers require different end user interface configurations and actions on the part of the user 

The next group of triggers is important because they allow the present system to be integrated with existing social media channels. We shall use YouTube Facebook Google Plus and Twitter as examples but these by no means constitute an exhaustive list of compatible third parties. The purpose of these triggers is for them to be fired when an end user interacts with these third party services in the regular way. The end user experience for interacting with these third parties is illustrated in and and the pattern in all cases is very similar. is a diagram including a representation of a display presenting a mobile user interface for use by an end user in accordance with an embodiment of the present invention for interacting with a YouTube trigger. is a diagram including a representation of a display presenting a mobile user interface for use by an end user in accordance with an embodiment of the present invention for interacting with a Facebook trigger. is a diagram including a representation of a display presenting a mobile user interface for use by an end user in accordance with an embodiment of the present invention for interacting with a Google trigger and is a diagram including a representation of a display presenting a mobile user interface for use by an end user in accordance with an embodiment of the present invention for interacting with a Twitter trigger. For instance an end user may see an advertisement in the real world online or in an app which contains a third party trigger together with a call to action that explains to the end user what the advertiser would like him her to do. In the case of YouTube this might be to get the end user to watch an online video. For Facebook this might be to get the end user to Like or follow the advertiser on that platform. For Google Plus this might be to get the end user to 1 follow or add the advertiser to a circle. Finally for Twitter this might be to get the end user to follow the advertiser or tweet a message containing a specific phrase or hashtag. In all of these cases the end user uses his her mobile device to interact with the relevant social media platform which can happen in two major ways. The first way is through the advertiser s app which contains the present system s API and functionality. The end user performs the required action in this app which fires the corresponding third party trigger sending an appropriate event along the system s event bus to its Logic Engine which responds as before.

Alternatively this action can be performed in the relevant social media company s app or website in which case the present system must know that a specific end user performed that specific action and then make sure that the correct end user receives the benefit of the ensuing trigger event. The system can identify the end user in question because the end user has previously entered his her identifying information or credentials from the relevant social media platform into his her instance of the advertiser s application. The system then learns that the end user has performed the desired action and this can be done in three ways 1 By implementing an API from the social media platform which specifically performs this service 2 By working with the social media platform to implement an API from the present system on their end which performs this service or 3 When appropriate by using other means such as monitoring social media channels or otherwise scraping Internet data and firing the appropriate event when the desired end user has performed the desired action.

However trigger interfaces are only one type of screen that the system can create and deploy to different devices. Another important type of screen that can be created and deployed is the pebbling module screen. A pebbling module screen s purpose is to allow an end user to interact with a module created using the system s Pebbling Language within an application that has been deployed to the end user s device. is a diagram including representations of displays presenting mobile user interfaces for use by an end user but showing such representations as a result of running the module of in a sandbox application as a stand alone application or as a splice in accordance with an embodiment of the present invention wherein the module s output display is identical to that from the Simulator. At the start of the interaction in the game board does not have a check mark on square . The end user then interacts with codeword trigger types in the code ABC123 and hits the Send button. This is analogous to clicking on corresponding trigger in except that in this case the trigger event is real and not in the Simulator. This trigger event causes the relevant pebbles to move within the Logic Engine and in we see that the check mark has appeared just as in the Simulator of . Note that even when the module has been deployed to a real hardware device as in this case the programmer can still watch the pebbles moving in the system s Simulator in real time as the device s end users interact with triggers.

In addition to trigger interface and pebbling module screens which themselves can be easily skinned and otherwise customized the system also provides facilities such as user interfaces and wizards for easily creating many other types of customizable application screens thereby greatly reducing the amount of time and effort required to create a useful application. These application screens are grouped together and comprise an application by defining them as well as how to navigate between them in the system s web based editors. This allows a programmer to create a fully functional application or several screens to be inserted as a splice into a fully functional application without any advanced formal programming skills and almost entirely using the present system. Once an application is thus defined it can be deployed to the Simulator the Sandbox App as a splice or as a stand alone application. These steps are shown in which is a diagram illustrating testing and development options available to a brand representative in accordance with an embodiment of the present invention. The programmer uses the system s web based or stand alone graphical user interface to create objects that are stored and processed by the system s Logic Engine . As we saw in this includes modules triggers and variables and in we expand this list to include app screens and applications. The system has many pre defined screens each with an editor and or wizard to aid in its creation. The programmer uses these editors to respectively create app screens and then uses another editor wizard to combine them into an app. App screen editors can be used to create trigger interfaces pebbling module screens and many other types of custom screens which can be customized with different colors background graphics text fonts and so on. With this system it is possible to create applications that don t contain a module written in the system s Pebbling Language or any other language serving the same purpose but the most powerful and useful applications that it builds will almost certainly contain pebbling module screens so as to surface these powerful custom programs to end users.

Once an application has been created it can be deployed along one of three paths 1 Along path to the system s Simulator which will allow the programmer to access and debug the module s screens and triggers 2 Along path to the system s Sandbox App which will allow the programmer to access debug and demonstrate the module s screens on a real hardware device and interact with real triggers and 3 Along path as a stand alone application or application splice which has been included in a 3party app via the system s splice API this is the system s way of launching a module in earnest once it is ready for production. Note that modules created using the Logic Engine s Pebbling Language editor are simply software that can be deployed to any device or Simulator that can run them.

These different ways of debugging testing demonstrating and deploying an application built using its interface forms a natural development pipeline and is shown in which is a flow diagram illustrating a typical order of testing and development through which a brand representative develops a module for use in an embodiment of the present invention. First an application is created in Logic Engine . Once it is ready to be tested the user deploys it to the Simulator where it is tested and debugged. Once it is ready to be tested on real hardware with real triggers it is deployed to the Sandbox App . Finally after its programmers and testers are confident that it is ready for production it is launched as a stand alone application or as a splice in a 3party app .

Edges connect one node to one or more nodes and constitute the paths over which pebbles may move. In this case the edge is a split edge which leads to nodes and . Alternatively instead of starting at a node an edge s start point may be a group. If an edge leads to more than one node it can have a type which is located at the split point and shown as an icon in a circle. These edge types are described in more detail below and shown in which is a diagram showing a non exhaustive compilation of the Pebbling Language s edge types in accordance with an embodiment of the present invention. In this case it is a probability edge with the chances of the node traveling along any one fork in the edge shown as probabilities . In addition edges can have trigger receivers and can also have variable conditions on them both of which are round. The trigger receivers have icons in them indicating the type of trigger with which they are associated. An edge does not need to have a receiver nor a variable condition on it. If both are present then the variable condition must be satisfied when a trigger is received in order for a pebble to move. If the variable condition is not satisfied and the trigger is received then the pebble on node does not move but rather must wait for another trigger to be received. If both the receiver and variable condition are absent then any pebble which arrives on node will immediately move. If only the receiver is present then the pebble will move as soon as a trigger is received and finally if only the variable condition is present then the pebble will move as soon as that condition is satisfied.

Groups contain two or more nodes . Like edges groups have types as well as variable conditions which are both also shown as circles. Like edges the variable condition on a group is optional. A group s purpose is to create a group of nodes in which one or more must be pebbled according to the group s type in order for that group to be satisfied. A group s possible types are illustrated in and described below. A group has one or more edges leaving it and when a group is satisfied then the pebble s in the group are ready to move along these edges to their destination nodes. In that sense groups act very much like nodes. Any edge leaving a group may have a receiver and or variable condition on it but the group itself may also have a variable condition on it adding further constraints and a group is not satisfied until both its main type condition as well as its variable condition are satisfied. If either of these is not the case then pebbles will not move from the group.

Both nodes as well as groups can be set to retain their pebbles or not. If they retain their pebbles then instead of moving any pebble on them is first duplicated and the duplicate is then moved. Otherwise the pebbles themselves move without duplication leaving the nodes that they came from empty without pebbles on them.

By contrast variable change nodes act very differently by changing the value of a variable when a pebble arrives on it. Once the variable has been changed the pebble can be deleted. Variables are one mechanism by which programs modules can communicate with each other since many programs modules depending on scope can access the same variables. Images and respectively depict foreign state change senders and receiver nodes and comprise another mechanism for programs modules being able to communicate with each other. For instance a foreign state change sender node may be placed in module A and a foreign state change receiver may be placed in module B after which they are paired. These act as pebble teleporters in the following way When a pebble arrives on the foreign state change sender node in module A it is immediately teleported to the corresponding foreign state change receiver node in B.

Images and respectively depict prize and Minting Nodes and these can be used to issue awards to an end user. When a pebble arrives on a Prize Node it creates an award such as a coupon digital song game or other digital entity which is issued to the end user whereas Minting Nodes create a new module for the end user. Pebbles on these nodes can be deleted once they have performed their actions.

Animation nodes play an animation when pebbles arrive on them after which these pebbles can be deleted.

System trigger nodes fire an internal system trigger when pebbles arrive on them after which these pebbles can be deleted.

HTTP POST nodes send an HTTP POST message with desired parameters to an external source such as a server or other Internet connected device when pebbles arrive on them and again these pebbles can be deleted after this message has been sent. This type of node provides the system with the ability to perform general output communications and send instructions or data to any device on the Internet and is therefore very powerful.

Finally Multi Attribute Nodes are nodes which combine the powers of two or more of the previous nodes.

These node types are just examples of possible types that can be included in the system s Pebbling Language and are not meant to constitute a complete list.

In order to support the previously mentioned details and user interfaces the embodiment of as a system requires certain underlying technical functionality to be implemented and this section describes one possible architectural embodiment.

One of the most basic functions of the system is its ability to create and manipulate the various entities such as modules triggers variables and so on and this functionality is illustrated in which is a diagram of the embodiment of showing system architecture and information flow for creating and maintaining various types of entities used in the embodiment. As previously mentioned and shown in a programmer accesses the system s Logic Engine through System User Interface which might be a stand alone application or hosted in a web browser. This interface exposes the various entities in the system such as Campaigns Modules Triggers the Website Sandbox Variables and so on. These entities are stored in client memory in JSON Javascript Object Notation or some similar format.

The system s Logic Engine has one or more servers which implement the basic functionality of conveying information from the system s database and its user interface . This is performed through C.R.U.D. Create Read Update and Delete requests from the user interface in response to programmer actions. These requests are sent to the Logic Engine where they are received and processed by the Service Back End . It relays the appropriate C.R.U.D. commands to the database containing entries which performs the appropriate action by either reading writing deleting etc. the relevant data. When information needs to be updated or displayed in the programmer s interface the service back end sends a request to the Logic Engine s push notification service which in turn sends a push notification over channel back to the programmer s user interface which then updates the programmer s view.

As already mentioned the programming language used by the present system need not necessarily be based on pebbling but rather can be a traditional language such as Java C C Python or any other popular Programming Language. All of these as well as the system s Pebbling Language are expressive enough to allow programmers to create customized modules which change state based on trigger inputs. is a block diagram illustrating the progressive flow of events pertaining to changes in state of a module for the embodiment of as applied to a specific user instance in response to specific triggers. It shows the changes in a module s state in response to trigger inputs that would occur regardless of which computer programming language the embodiment of the present system implements. This figure shows a series of trigger events being progressively received for a specific end user s module by the system at times t t t . . . t. For each of these trigger events the system then reacts according to the logic of the module being run. For instance at time t the module is in state when the system receives trigger . At time tthe system evaluates trigger in the context of state and as a result at time tthe module changes from state to state as shown by . Finally at time tthe module evaluates and stores state as per . At this point several more state changes could occur. In other words it is not just triggers which can change a module s state. Its internal workings can also change the state. In the case of a pebbling module a state is a unique pebbling configuration and the difference of one pebble or variable value constitutes a separate state. Pebbles can move multiple times in a cascading manner in response to a single trigger moving through many states and the same can happen in a module written using a more traditional language such as Java but for the sake of simplicity we are assuming that each of the triggers in this example changes only one state.

Next at time t the module responds to the system s reception of trigger . It evaluates trigger in the context of state changes to state and then evaluates and stores state . Similar sequences happen at times t t etc. until at time t the module reaches an output state as follows At time t it receives trigger n . At time t the system evaluates trigger n in the context of the module being in state n . At time t the module changes from state n to state n 1 . State n 1 is evaluated and stored at time t. At this point the system s evaluation of the module leads to time tat which point the module generates an output reward message which is then transmitted at time t. After this the module does not necessarily terminate but rather can be ready to receive and react to more triggers.

Within the Logic Engine incoming trigger data is received and processed by web server . This data is then relayed to the system s context loader . The context loader s role is to fetch and prepare all of the information or context which will be required to process a module s response to the incoming trigger. Context includes information such as the module s current state for the relevant end user s as well as the module s logic or rules for responding to triggers. In the case of this embodiment of the system s Pebbling Language this includes the program s module s state diagram trigger data pebble locations variable values etc. The context loader fetches this information by sending the trigger data to the system s database which replies with the relevant context data . If the module is unlocked then a lock is placed on the relevant module so that it can be edited by at most one Module Processor at once and this context data is then relayed by the context loader to the Module Processor . If the module is locked then the trigger is placed into a first in first out queue within the context loader and this will be processed when the module becomes unlocked.

The system s Module Processor is responsible for carrying out the computation resulting as a response to the trigger. In the case of this embodiment of the system s Pebbling Language the Module Processor loads the module s state diagram applies the trigger and updates the module by moving all relevant pebbles if any to their new locations. Some edges have no receivers on them in which case pebbles can continue to move in a cascading fashion. The Module Processor moves all triggered and cascaded pebbles until they have come to a resting state and no more pebble movement is possible. In the meantime pebbles which are moving can cause many different events to happen. For instance among others they can change the value of a variable cause pebble initiated trigger to fire or cause an HTTP POST to be sent to an arbitrary server. These events are placed into an output queue in a first in first out manner which can be overridden by programmer flagged priority events that can jump to the front of the queue. Once the pebbles have come to rest the Module Processor begins the task of dispatching the items in the queue one by one. There are two different types of items in this output queue 1 Those which will initiate external outputs and 2 Those which will initiate internal outputs. External outputs such as HTTP POSTS are sent from the Logic Engine using channel . By contrast internal outputs such as variable changes or internal triggers feed back into the Logic Engine. Variable change events are sent via channel to the system s database which performs the relevant update. When variables are changed the system must check to see if any variable conditions have just become satisfied and if so move the appropriate pebbles. This can be done by adding variable changes to the Context Loader s trigger queue as if it were a trigger. By contrast internal triggers are sent via to the internal trigger processor and from there via channel to the context loader which will treat this as any incoming trigger by fetching the relevant context checking to see if the corresponding module is locked and proceeding as before. Once the Module Processor s output queue is empty the module is unlocked and any triggers waiting for it in the context loader s trigger queue are allowed to proceed in order.

The most complicated part of the system shown in is the Module Processor and this component of the Logic Engine bears further explanation. are block diagrams collectively showing the order of operations performed by the Module Processor of . Although this diagram spans three figures these are meant to be viewed together. flows into which in turn flows into . The Module Processor s main task is to apply a trigger to the relevant context data move any relevant pebbles and place any outputs on the output queue which are then dispatched. Since the output queue and dispatching output queue items has already been described we will now focus on how the Module Processor applies a trigger to context data in order to perform a computation and possibly change state.

Context data includes several pieces of information and is processed in a series of seven steps. In we illustrate these steps as being applied to a series of examples. These figures can be viewed as a large table in which these steps are the rows and the examples are the columns. Example 1 described by column shows a path of three nodes whose first edge has a receiver on it whereas the second edge does not. Example 2 described by column shows a group containing two nodes with an edge leaving that group and leading to a final node. Both the group and the edge contain variable conditions and the edge also has a receiver on it. Example 3 described by column shows a group containing four nodes with an edge leaving the group and leading to a final node. This group has variable conditions and the edge has a receiver on it. Example 4 described by column contains a node with a split edge leaving it and connecting it to two nodes. This edge contains a receiver as well as variable conditions and has a 50 chance of sending a pebble to either one of the destinations. Example 5 described by column contains a single edge with a receiver between two nodes. Finally Example 6 is described by column and contains a group with three nodes in it and an edge with a receiver leaving that group to a final node.

Column illustrates the steps which the Module Processor is applying to the context data. It is important to note that the context data does not change but rather remains static during all steps. In the first step the context data is used to construct and load the state diagram . This is done by inspecting the module s template within the context data. A module s template encodes the structure of the state diagram and is common across all end users who are running that module. Diagrams respectively illustrate the templates of Examples 1 6 being loaded and depict their state diagrams.

In the second step the context data is used to load module data which is specific to an end user . This is called a module s instance and it contains specifics such as where a specific end user s pebbles are placed as well as the values of variables. Diagrams respectively illustrate the module instance data from Examples 1 6 being loaded and show where pebbles have been placed on nodes.

Step three makes use of the module template and instance data within context data in order to evaluate groups to make sure that they are satisfied. In all of the present examples the groups are of the ALL type which means that every node in the group must be pebbled in order for the group to be satisfied. In Examples 2 and 3 i.e. diagrams and respectively this is the case and both of these groups are satisfied. By contrast the group in Example 6 label is missing a pebble and therefore is not satisfied so we can stop evaluating this example.

Moving on to in step four the module template and receiver data within context data are used to evaluate receivers . For the purposes of this exposition we will assume that all receivers match the trigger to which the Module Processor is ultimately responding. In the cases of Examples 1 4 respectively labels all of the nodes or groups at the start points of the edges containing the receivers have been satisfied so these computations are allowed to proceed. However the node in Example 5 label is not pebbled and therefore isn t satisfied which means that the receiver also isn t satisfied terminating the computation for this example.

In step five the module instance receiver parameters and variable values within context data are used by the Module Processor to evaluate edge parameters and variable conditions . Although not necessary triggers can contain additional parameter data and conditions based on this data can be added to edges receivers. This allows an even greater level of control in that a receiver may be in all other ways satisfied but then fail because the edge trigger parameters failed. Similarly the variable conditions on an edge similarly allow for a greater level of control in that a receiver may be in all other ways satisfied but then fail because the variable conditions failed. In Examples 1 and 3 respectively labels and the edge parameters are satisfied and there are no variable conditions so they are vacuously satisfied allowing these computations to proceed. Similarly in Example 2 label the variable condition is satisfied allowing this computation to proceed. By contrast in Example 4 label the edge variable is not satisfied and the computation terminates. If this variable condition had been satisfied the pebble would have moved along the edge and chosen a random fork to end up on one of the two destination nodes.

In step six the module instance and variable values within context data are used to evaluate group conditions and variables . Example 1 label has no groups and therefore vacuously proceeds. In Example 2 label the group s variable condition is satisfied allowing its computation to also proceed. Finally Example 3 s group variable condition fails label and this example s computation terminates .

Step seven is the final stage of the Module Processor s computation and it uses the module instance information within the context data to move pebbles and process the consequences by placing them on the output queue as previously discussed. In Example 2 label the two pebbles from the group merge into one and move along the edge to the destination node thereby changing the module s state. Merging occurs because nodes cannot have more than one pebble on them. In Example 1 label the pebble moves from the Start Node to the middle node and because the next edge contains no receiver or variable conditions it is unobstructed and continues to move to the final node .

As previously mentioned this system forms an operating system in the cloud in two major ways. The first is that it is capable of executing arbitrary computer modules and the second is that it creates a Universal Event Bus and exposes this functionality to programmers in order to simplify the management and access of an extremely rich variety of input and output devices and signals. This Universal Event Bus can be used in extremely general ways and this major functionality is illustrated in which is a logical flow diagram illustrating how the embodiment of can be considered as a Universal Event Bus. As can be seen the system forms something of a bow tie with maximum flexibility on inputs maximum computational expressiveness Turing Completeness in the center and maximum flexibility on the outputs. The system s Logic Engine forms a nexus which can connect any device capable of sending a trigger on the left to any Internet connected device on the right. Devices capable of sending trigger messages include but are not limited to modern cars with built in computers smart televisions game consoles mobile devices such as smart phones or tablet computers smart eyewear or other wearable devices laptop or desktop computers any external Internet connected server and so on. Triggers from these myriad devices arrive at the Logic Engine where they are processed according to a module written using the system s Pebbling Language or some other means of encoding computer processing instructions. This module reacts to the trigger being received and performs an appropriate action which can range from changing the state and graphics of a module to sending a message to an arbitrary Internet connected device. In all of these cases the list of output devices on which the output is displayed or the output device to which this message is sent is again extremely flexible and diverse and is shown on the right hand side of the bow tie . Since the present system allows for a message to be sent from any device processed arbitrarily and then relayed to any other arbitrary device it is appropriate to refer to the system as a cloud based operating system together with a Universal Event Bus.

One powerful application of this event bus is to the realm of digital marketing. Advertising networks are currently siloed from each other and come in many genres such as radio television print out of home digital and so on. In order for a brand to launch a marketing campaign it must create and launch an ad campaign on several of these different types of ad networks. In that sense a marketing campaign is simply the union of several ad campaigns but in today s world with current technologies or lack thereof the connections between these ad campaigns is largely thematic rather than technological. Since the presently described embodiment of this system forms a Universal Event Bus and has so many different types of heterogeneous triggers they can be deployed across the world s heterogeneous ad networks in order to create the world s first marketing network . Together with the system s ability to easily create modules and splice them into existing applications using an embodiment of the system s visual Pebbling Programming Language this is a potent combination because it allows brands as well as their agencies to take charge and control the orchestration of a digital marketing campaign across many ad networks. Because the system s Pebbling Language is so simple and visual it can be mastered by creative individuals who have no technical backgrounds or experience thereby empowering them to control the entire execution pipeline of a campaign without having to rely on technical vendors to build apps thereby saving time money and the risk of ideas being lost in translation.

However embodiments of this invention have applications that clearly go far beyond the realm of marketing. There has been much talk about the so called Internet of Things in which the whole world will become connected to the Internet. Everything from watches to microwaves to cars our clothing our homes and much more will all have IP addresses or some other way of being referenced located or connected to the Internet even if only in a semantic rather than a technological sense. That new world will require key tools and infrastructure to help connect devices with each other together with the ability to easily set up and perform intermediate computations. We therefore see this embodiment of the present invention as being a key technology to help create and manage the new Internet of Things.

With the addition of another component to the system we can enable some powerful functionality that can be built on top of previously described system abilities. This component is not necessarily dependent on the rest of the system and could be integrated with any similar platform. This component is called the system s Sponsorship Junction Controller and it enables Sponsorship Junctions which provide the system with the ability for end users to be sponsored by brands for doing things that they already do but for which they are currently not receiving any rewards. Sponsorship Junctions bring together the creators of experiences with brands sponsors in a seamless way.

Sponsorship junctions can be created for any trigger monitorable activity that is any type of activity for which participation can be measured by creating a trigger that if fired by an end user would imply that he she is indeed participating in that activity. These experiences can include almost any activity such as people playing video games visiting a theme park or running a marathon and the purpose of a Sponsorship Junction is to make it easy for the creators of the video games the owners of theme parks and the organizers of marathons to invite brands to respectively sponsor game players theme park visitors and marathon runners for participating. For each activity genre such as video games theme parks and marathons there is a separate Sponsorship Junction.

So for instance with the video game Sponsorship Junction let us assume that 100 different game developers connect their games to the junction and then another 100 different brands connect to the junction as sponsors. Normally this would require every game developer to make a separate deal with every sponsor so that would require an astronomical 10 000 business deals to be struck. However Sponsorship Junctions are designed to considerably decrease this burden and instead of requiring 10 000 deals the present system requires that each game developer and sponsor only make one deal with the Sponsorship Junction thereby reducing the required business development from a quadratic 10 000 to a linear 200. This is achieved by setting up a standard set of default triggers for each Sponsorship Junction so that each game implements these triggers as does every sponsor. This set of default triggers is highly specific to the genre of the Sponsorship Junction so for instance in the case of video games the set would include triggers for common events that happen in video games such as completing a level killing a boss leveling up winning the game and so on. By contrast a theme park might have a completely different set of default triggers for events such as visiting the park going on a ride eating at the concession going on five rides in a day a fifth visit to the park and so on. For each experience genre there is a separate Sponsorship Junction and each one has a different set of default triggers which is highly customized for that genre. Each experience creator need not necessarily implement every default trigger but they must implement some minimum number of them and the same goes for sponsors although it is in their best interests to implement as many as possible.

An end user s experience of participating in a Sponsorship Junction is shown in B and C which are representations of Sponsorship Junction end user experiences including display screens respectively associated with sponsor selection results of game play and user outcome messaging. We shall use the Sponsorship Junction for video games as an example in which an end user is playing a game on a controller based game console such as an Xbox Playstation Nintendo and so on although this example should not be construed as limiting. The first stage of the process is shown in and involves the end user s starting the relevant game on his her game console and selecting a sponsor on the television . The Sponsor Selector Interface lists a series of brands and the end user moves a selector over the brand that he she wishes to sponsor this session of the video game and selects it. This list of brands is populated only with brands for which the end user has applications. This is determined by matching the end user s credentials from the video game console with on his her mobile device credentials from all brand accounts from the total list of sponsors. For those apps which the end user has but for which matches are not found for example if the end user used different credentials to log into the app from those used to log into the game console the end user is given the opportunity to manually enter his her credentials into that brand s representation in the game console s sponsorship list. illustrates the next step of the process. Once the sponsor has been selected the end user plays the sponsored game on the console and television and if he she achieves a result in the game for which there is a trigger then a congratulatory message is displayed which may or may not contain specific information from the selected sponsor. Meanwhile and as shown in the end user s smart phone buzzes and if he she chooses to check it the phone contains a notification message from the selected brand informing the end user of his her reward. This type of Sponsorship Junction represents a compelling way for brands to advertise within video games something that has not been popular or even possible and to do so in a way that does not offend or annoy the end user because he she is being rewarded by a brand that he she selected and also because the advertising happens entirely on a second screen and therefore does not divert the end user s attention from the enjoyment of his her activity as is currently the case with in game mobile advertising with banner ads which cause a full page redirect to occur when they are clicked thereby frustrating end users. Sponsorship Junctions for other genres work similarly.

Sponsorship Junctions are an additional component within the present system s architecture and their relationship to the rest of the system is shown in which is a block diagram illustrating how handling of Sponsorship Junctions is accomplished in the overall architecture of the embodiment of in accordance with an embodiment of the present invention. The system can host an arbitrary number of Sponsorship Junctions etc. which themselves are managed by a Sponsorship Junction Controller . This controller in turn resides within the system s Logic Engine . Sponsorship Junctions make use of previously described system components and functionality such as triggers receivers etc. so we won t repeat those components here. Their main purpose is to connect end users of experiences with sponsors. To that end the system provides a Sponsor Selector Interface in the form of an API which can be included on any device such as a game console or mobile smart phone. The end user selects his her sponsor using this interface which communicates over channels through the Internet with the Sponsorship Junction Controller thereby connecting a specific end user participating in a specific experience with a specific sponsor. Of course Sponsorship Junctions will also require several user interfaces to help with their management including a user interface for them to be set up this includes the creation of their default triggers as well as user interfaces for Experience Creators and sponsors to join a junction. These user interfaces communicate through channels over the Internet .

The inner structure of Sponsorship Junctions is shown in which is a block diagram showing the inner logical structure of Sponsorship Junctions. This diagram shows two different Sponsorship Junctions Sponsorship Junction A and Sponsorship Junction B . Let us assume that Junction A is for video game sponsorship and that Junction B s purpose is to provide a means of sponsoring people for visiting theme parks. Junction A contains Default Trigger Set A which itself contains several default triggers etc. that were created using interface in . These triggers are highly specific to video games. Sponsorship Junction A includes several Experience Creators which in this case are video games . The programmers of these video games have implemented the triggers from Default Trigger Set A in their games. In addition they can optionally create custom triggers above and beyond those in the default set which are stored in their own accounts rather than with the default triggers. These video games as well as any custom triggers are registered with Junction A using user interface from . At the same time Junction A also includes several sponsors which in this case are brands that have their own mobile applications running modules from the present system. These modules are labeled and in them their creators have implemented receivers for the triggers in Default Trigger Set A as well as any previously mentioned custom triggers from the video game programmers. The main role of the Sponsorship Junction is to connect a specific experience in this case a video game with a specific sponsor in this case the sponsor s app and that is the purpose of the Selector . In addition to implementing triggers the video game creators also implemented a graphical Sponsor Selector Interface in each of their games. Gamers use this interface after they have started the game in order to select a brand as shown in . This act connects the game that they are already in with the sponsor that they have chosen . The selector then routes triggers which are fired in the game being played to the sponsor s module via dynamic channel .

In the case of Sponsorship Junction B the experience might be quite different from video games since its purpose is to sponsor customers of theme parks for doing the normal things that they do at theme parks but the underlying technology is robust enough to connect the Experience Creators in this case mobile applications belonging to theme parks such as Disneyland Six Flags Universal Studios Sea World Legoland etc. with brand sponsors apps modules. The end user of a theme park app starts it and via selects a sponsor . The end user then visits the theme park goes on rides eats at the concession etc. and uses the theme park app to interact with various triggers from Default Trigger Set B which have been implemented in the app. Junction B s selector routes these triggers to the receivers of the end user s app from the selected sponsor which buzzes or notifies the end user whenever he she has earned points or other rewards for typical theme park activities captured by the triggers.

In an alternate embodiment sponsor selection within a Sponsorship Junction is not performed explicitly by the end user but rather by automated or algorithmic means. For instance instead of providing a user interface the Sponsor Selector consists of code in the system which runs a real time auction which can measure several inputs such as the nature of the experience the end user s profile potential sponsors profiles as well as bids from potential sponsors. It then uses standard auction algorithms such as those used by current online advertisers such as Google to match the best sponsor with the right end user while maximizing profit. Similarly in another embodiment sponsors are chosen algorithmically according to a schedule with different sponsors being chosen at different times or according to different geographies. Yet another embodiment uses a hybrid approach using algorithmic means such as an auction in order to rank the order of the sponsors at which point the end user selects the sponsor as before.

In addition to the Sponsorship Junctions the system can be augmented with another component called the Loyalty Points Exchange . As with Sponsorship Junctions the Loyalty Points Exchange is not necessarily dependent on the rest of the system and could be integrated with any similar system. In the case of Sponsorship Junctions the underlying system required certain basic functionality but in the case of the Loyalty Points Exchange the underlying system need only have a facility for maintaining user accounts with loyalty points.

The purpose of the Loyalty Points Exchange is to make it possible for users to easily accrue points from various brands and to then conveniently convert points from one brand to those of another in a way which is similar to how currency exchanges work to convert say U.S. Dollars to British Pounds. Every brand declares how much one of their points is worth in relation to some currency such as U.S. Dollars and this implicitly creates an exchange rate so for instance Brand may declare one of its points to be worth 0.01 whereas Brand may declare one of its points to be worth 0.02. An end user who wishes to convert 10 points from Brand would receive 5 Brand points for them.

This transaction is beneficial to the end user who may need the extra loyalty points in order to trade them in for something valuable but the system requires a way in order to incentivize the three remaining parties Brand Brand and the Loyalty Points Exchange itself. This is achieved through a commission which is charged on the transaction and then split among these three parties. The commission may be split equally between the three or according to some other arbitrary splitting. Furthermore this commission may be fixed or dynamic calculated by the system in response to conditions such as supply demand desired profit and so on. This commission can be shown to the end user explicitly or it can remain opaque by including it in the exchange rate.

For example let us assume that Brand and Brand have both declared the value of their loyalty points as described before and that an end user has 100 in points from Brand as well as 100 in points from Brand . This is equivalent to each brand owing 100 to the end user. The end user wishes to convert 50 of points from Brand over to points from Brand the exact number of points that this corresponds to isn t important for this example and initiates this trade. Brand sends 50 to Brand and simultaneously discharges 50 worth of Brand points debt that it owed to the end user so Brand s total balance has not changed. Brand is now up by 50 but then issues another 50 in Brand points to the end user bringing his her total debt to 150 so Brand s total balance also has not changed. For the sake of argument let us assume that the total commission is 6 of which each of Brand Brand and the Points Exchange shall receive one third or 2. This commission is taken from the end user s Brand points. This is done by discharging an additional 6 worth of Brand point debt from the end user. Brand then sends 2 to Brand an additional 2 to the Points exchange and then pockets the remaining 2. The end user is therefore charged 56 worth of Brand points for the transaction and has 44 in Brand points remaining and each of the remaining three entities has made a profit of 2. The end user has paid this commission using Brand points but also received the benefit of increasing his her Brand points presumably to receive the instant gratification of trading them in for something valuable so all four parties to this transaction have benefitted in a material manner. The structure of this transaction forms the basis of how the Loyalty Points Exchange works and explains the motivation for all four participants.

The end user s experience during a Loyalty Points Exchange transaction is shown in which are diagrams including representations of displays presenting a mobile user interface for use by an end user in accordance with an embodiment of the present invention for utilizing a Loyalty Points Exchange in accordance with an embodiment of the present invention. In this example the end user has points with four Brands called A B C and D and is using Brand A s app on his her mobile device . The end user wishes to spend 50 000 points from Brand A to purchase an item called XYZ as shown by screen . The end user presses the Trade button which takes the process to the next step in which he she is informed that he she has only 40 000 points and requires 10 000 more points to complete the transaction. The application informs the end user that he she can trade points from a different brand in order to acquire the required 10 000 Brand A points by hitting button . This button takes the end user to the points exchange where he she is prompted to select a brand from which to trade for the desired 10 000 Brand A points. The end user is shown several buttons one corresponding with each brand with which he she has a sufficient number of points to complete the transaction including commission. In this example the end user can receive 10 000 Brand A points by choosing to click on button to trade 20 000 points from Brand B on button to trade 5000 points from brand C or on button to trade 2500 points from brand D. The system automatically calculates the required points for each Brand as a function of the desired number of points and the value of each Brand s points relative to the U.S. dollar as declared by the brands themselves. These values also implicitly include the commission that the end user will pay although this could be shown explicitly. Of course other niceties such as cancel buttons and indicating the total points that the end user has with each brand on the trading screen could also be shown. In our example the end user chooses to change points from Brand B by clicking on button taking us to the next step in the process which is shown in . On the transaction screen the end user is shown how many points they are trading what the exchange rate will be and how many points from Brand A he or she will receive. The end user can then choose to cancel or proceed with the exchange . The end user hits the Exchange button causing the system to automatically carry out the transaction including the commission payments. The new balance of Brand A points is shown and now that he she has 50 000 Brand A points the end user can optionally be taken back to the original transaction for buying item XYZ. The end user clicks on the Yes button which takes him her to the final results screen indicating that the purchase has been completed and that the new points balance is zero.

In an alternate embodiment the system is additionally used to send loyalty points in a peer to peer fashion between end users in the same way that individuals can currently send electronic payments to each other using standard financial infrastructure and functionality. This process can be initiated either from the sender by selecting a brand a number of points and a recipient or by the recipient by again selecting the brand and points quantity and then sending a request which is analogous to an invoice to another user. In all cases the system is able to charge a commission similar in manner to that previously described. This commission can be charged to the sender the recipient or split in some manner between the two.

The manner in which the Loyalty Points Exchange is integrated with the rest of the system is shown in which is a block diagram illustrating how handling of the Loyalty Points Exchange of is accomplished in the overall architecture of the embodiment of in accordance with an embodiment of the present invention. This integration closely resembles the manner in which Sponsorship Junctions can be integrated with the system in that they are both components that make use of the underlying system but could just as easily be integrated with other similar systems. The main component of the Loyalty Points Exchange resides in the system s Logic Engine . An end user s loyalty points may be stored locally in the Loyalty Points Exchange or externally on a Brand s server with which the system can communicate using channel over the Internet . The Loyalty Points Exchange is connected via channel through the Internet to the system s user interface in which each brand declares the value of its loyalty points in U.S. dollars sets information linking to its bank accounts for transferring money for commissions and so on. In addition the system s user interface provides facilities for the managers of the Loyalty Points Exchange to set its major parameters such as whether commissions are charged algorithmically or whether it s a flat rate or percentage as well as which percentage of the commission each of the three parties the two brands and the exchange will receive. The system also provides a user interface for the exchange which was illustrated in so that it can be included on any end user devices such as mobile smart phones tablets laptops wearable computers and so on. This interface is connected via channels over the Internet to the Logic Engine and Loyalty Points Exchange .

Because money is at stake one of the most important implementation details for the Loyalty Points Exchange is to make sure that fraud is not possible. For instance if implemented naively it might be possible for an end user to load the trading interface twice once on each of two separate devices and then simultaneously execute two exchanges from one Brand s points to those of two other Brands effectively doubling his her cash equivalent in points by using the same points twice. This is easily handled by implementing a lock on loyalty points as soon as a trade is initiated regardless of whether the points are stored locally or on a Brand s server .

Another embodiment of a sub component which can be integrated with the system in a manner similar to that of Sponsorship Junctions and the Loyalty Points Exchange is called Trigger Streams and as with all of these embodiments of sub components can be viewed as an independent invention which can stand alone or be integrated into a similar system. That being said Trigger Streams similarly add value power and functionality to the embodiment of the overall system so we will describe them in this context. The purpose of Trigger Streams is to provide a means of broadcasting a stream of triggers as well as a means of subscribing to these streams and then reacting to them via receivers as per norm. In one sense Trigger Streams are similar to a form of machine readable Twitter only instead of individuals broadcasting a stream of short human readable messages to which other people can subscribe Trigger Streams allow any individual entity or piece of Internet connected technology to broadcast a stream of machine readable triggers to which other entities such as brands can subscribe all using the present system.

For instance illustrates one example of an end user s experience of receiving an event from the system s Trigger Stream and includes a representation of a display presenting a mobile user interface for that purpose in accordance with an embodiment of the present invention that may be implemented in the embodiment of using a Trigger Stream system. In this example a weather information service called the Weather Hotline has become a Trigger Stream provider with the present system. Whenever the weather changes anywhere it broadcasts a trigger to that effect along with geolocation data describing where that weather change happened. In this example it has broadcast a trigger indicating that it has started to rain in the vicinity of San Jose Calif. Meanwhile a store called XYZ has used the embodiment of the present system to add functionality to its mobile app which can respond to weather change events. XYZ has used the present system to subscribe to the Weather Hotline s Trigger Stream and to send discounts for umbrellas to its end users if it starts to rain. One such end user who has XYZ s app installed on his mobile phone happens to be in San Jose and the system therefore routs the rain announcement trigger to his app via a push notification. His phone buzzes letting him know that a new message has been received. XYZ s app received the notification so he opens it and sees a message jointly coming from the Weather Hotline as well as XYZ informing him that it is about to rain and that he has received a coupon for an umbrella which he can redeem at one of XYZ s nearby stores. He clicks on the related action button to accept the coupon.

Of course this is a very specific example and as such it should not be interpreted as limiting since the Trigger Stream producers subscribers and consumers could come from the nearly infinite list of sources that are compatible with the embodiment of the present system.

Inside the Trigger Stream Nexus each brand or other entity has its own stream selector. In our example Brand has stream selector Brand has stream selector and Brand has stream selector . This of course scales to any arbitrary number of brands or entities but again for illustrative purposes three will suffice. As previously described each brand previously used the system s user interface in to subscribe to one or more incoming Trigger Streams. In this example Brand has subscribed to streams and so its stream selector picks the triggers from streams and as they come into the system and via copies them into a new stream which is a union of those two streams with the black hexagonal triggers coming from stream and the white hexagonal triggers coming from stream in the order that they were received by Brand s stream selector. Similarly Brand is only subscribed to Trigger Stream so its stream selector only picks out the white hexagonal triggers from stream via to create the new stream . Finally Brand is subscribed to streams and so its stream selector picks out and copies the grey hexagonal triggers from stream and the white hexagonal triggers from stream merging them via into stream .

Each of these streams is then sent to the brand distribution filters whose job it is to select which triggers should be sent to which end users modules. The reason for this is that it would be inefficient for the system to simply send every trigger to every module even after we have culled the total population of triggers to only the brands subscribed streams. In our example Brand s unified stream is sent via to its distribution filters which sorts the triggers according to their data and metadata and then relays the filtered triggers via to Brand s modules which have receivers for those triggers but only if the individual end users meet all of the filter criteria. For instance in our example from the Weather Hotline sent out a stream of weather triggers and store XYZ subscribed to this stream. This stream of triggers is therefore relevant to anyone who has the XYZ app installed. However the weather triggers are dependent on geolocation and if XYZ is a national brand then the weather in say New York might be very different than in San Jose. XYZ s distribution filter is therefore responsible for not only sending weather change triggers to anyone who has a relevant module but it must also filter for geolocation so that it doesn t send weather triggers from the New York area to end users in San Jose or vice versa. This additional filtering isn t done based only on geolocation but could be performed based on any metadata associated with the trigger. For instance Major League Baseball may broadcast a Trigger Stream for every time a player hits a home run in one of its games but different teams might have their own fan apps so although all of these fan apps might subscribe to this Trigger Stream only a small subset of them namely the ones associated with their own team might be relevant to their own apps. So for example the Distribution Filter for team X may filter out home run triggers from team Y so as not to waste the bandwidth of team X s end users.

The Trigger Streams for Brands and are processed in a manner similar to that of Brand . In the case of Brand stream is sent via to Brand s distribution filters which filter and distribute those triggers via to Brand s end users modules . Similarly in the case of Brand stream is sent via to Brand s distribution filters which filter and distribute those triggers via to Brand s end users modules . Of course the distribution filters are not strictly necessary for the system to function so they can be omitted but they do make it more efficient so it is probably worth including them.

The triggers which make it through the filtering process arrive at the relevant modules and are processed just as any triggers would by the system s Module Processor within its Logic Engine as previously described in .

The present invention may be embodied in many different forms including but in no way limited to computer program logic for use with a processor e.g. a microprocessor microcontroller digital signal processor or general purpose computer programmable logic for use with a programmable logic device e.g. a Field Programmable Gate Array FPGA or other PLD discrete components integrated circuitry e.g. an Application Specific Integrated Circuit ASIC or any other means including any combination thereof.

Computer program logic implementing all or part of the functionality previously described herein may be embodied in various forms including but in no way limited to a source code form a computer executable form and various intermediate forms e.g. forms generated by an assembler compiler networker or locator. Source code may include a series of computer program instructions implemented in any of various programming languages e.g. an object code an assembly language or a high level language such as Fortran C C JAVA or HTML for use with various operating systems or operating environments. The source code may define and use various data structures and communication messages. The source code may be in a computer executable form e.g. via an interpreter or the source code may be converted e.g. via a translator assembler or compiler into a computer executable form.

The computer program may be fixed in any form e.g. source code form computer executable form or an intermediate form either permanently or transitorily in a tangible storage medium such as a semiconductor memory device e.g. a RAM ROM PROM EEPROM or Flash Programmable RAM a magnetic memory device e.g. a diskette or fixed disk an optical memory device e.g. a CD ROM a PC card e.g. PCMCIA card or other memory device. The computer program may be fixed in any form in a signal that is transmittable to a computer using any of various communication technologies including but in no way limited to analog technologies digital technologies optical technologies wireless technologies networking technologies and internetworking technologies. The computer program may be distributed in any form as a removable storage medium with accompanying printed or electronic documentation e.g. shrink wrapped software or a magnetic tape preloaded with a computer system e.g. on system ROM or fixed disk or distributed from a server or electronic bulletin board over the communication system e.g. the Internet or World Wide Web. 

Hardware logic including programmable logic for use with a programmable logic device implementing all or part of the functionality previously described herein may be designed using traditional manual methods or may be designed captured simulated or documented electronically using various tools such as Computer Aided Design CAD a hardware description language e.g. VHDL or AHDL or a PLD programming language e.g. PALASM ABEL or CUPL. 

While the invention has been particularly shown and described with reference to specific embodiments it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the appended clauses. As will be apparent to those skilled in the art techniques described above for panoramas may be applied to images that have been captured as non panoramic images and vice versa.

Embodiments of the present invention may be described without limitation by the following clauses. While these embodiments have been described in the clauses by process steps an apparatus comprising a computer with associated display capable of executing the process steps in the clauses below is also included in the present invention. Likewise a computer program product including computer executable instructions for executing the process steps in the clauses below and stored on a computer readable medium is included within the present invention.

The embodiments of the invention described above are intended to be merely exemplary numerous variations and modifications will be apparent to those skilled in the art. All such variations and modifications are intended to be within the scope of the present invention as defined in any appended claims.

