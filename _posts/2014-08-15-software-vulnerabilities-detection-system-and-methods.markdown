---

title: Software vulnerabilities detection system and methods
abstract: This invention teaches a system and methods of detecting software vulnerabilities in a computer program by analyzing the compiled code and optionally the source code of the computer program. The invention models compiled software to examine both control flow and dataflow properties of the target program. A comprehensive instruction model is used for each instruction of the compiled code, and is complemented by a control flow graph that includes all potential control flow paths of the instruction. A data flow model is used to record the flow of unsafe data during the execution of the program. The system analyzes the data flow model and creates a security finding corresponding to each instruction that calls an unsafe function on unsafe data. These security findings are aggregated in a security report along with the corresponding debug information, any ancillary information, remediation recommendations and the optional source code information for each instruction that triggered the security finding.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454659&OS=09454659&RS=09454659
owner: SECURISEA, INC.
number: 09454659
owner_city: Atlanta
owner_country: US
publication_date: 20140815
---
This invention was made with government support under the CyberFastTrack program documented in DARPA PA 11 53 dated Jan. 31 2013 awarded by Defense Advanced Research Projects Agency DARPA .

This invention relates generally to ensuring software security and in particular to exposing software vulnerabilities by performing static and dynamic analysis of compiled software.

Software security and vulnerability checking is an active field of academic and industrial pursuit. With the news of exploitation of software vulnerabilities by hackers a commonplace occurrence it is unsurprising to see many academic and professional institutions focusing their efforts to develop tools and practices that aim to make software more secure against exploitative attacks from global hackers and adversaries.

There are many ways of detecting and addressing vulnerabilities in software in the prior art. U.S. Pat. No. 8 499 353 discloses security assessment and vulnerability testing of software applications based in part on application metadata in order to determine an appropriate assurance level and associated test plan that includes multiple types of analysis. Steps from each test are combined into a custom or application specific workflow and the results of each test then correlated with other results to identify potential vulnerabilities.

U.S. Pat. No. 8 365 155 describes a software analysis framework utilizing a decompilation method and system for parsing executable code identifying and recursively modeling data flows identifying and recursively modeling control flow and iteratively refining these models to provide a complete model at the nanocode level. The nanocode decompiler may be used to determine flaws security vulnerabilities or general quality issues that may exist in the code.

U.S. Pat. No. 8 739 280 describes a context sensitive taint analysis system. Taint processing applied to a tainted value of an application is identified and an output context of the application associated with output of the tainted value is determined. It is determined whether the taint processing is effective in mitigating a security vulnerability caused by the tainted value for the output context.

U.S. Pat. No. 8 347 392 describes an apparatus and method for analyzing and supplementing a program to provide security. A computer readable storage medium has executable instructions to perform an automated analysis of program instructions. The automated analysis includes at least two analyses selected from an automated analysis of injection vulnerabilities an automated analysis of potential repetitive attacks an automated analysis of sensitive information and automated analysis of specific HTTP attributes. Protective instructions are inserted into the program instructions. The protective instructions are utilized to detect and respond to attacks during execution of the program instructions.

Non Patent reference Dynamic Taint Analysis for Automatic Detection Analysis by James Newsome and Dawn Song of Carnegie Mellon University proposes a dynamic taint analysis solution for automatic detection of overwrite attacks. The approach does not need source code or special compilation for the monitored program and hence works on commodity software. To demonstrate this idea they implemented TaintCheck a mechanism that can perform dynamic taint analysis by performing binary rewriting at run time.

Non Patent reference gFuzz An instrumented web application fuzzing environment by Ezequiel D. Gutesman of Core Security Technologies Argentina introduces a fuzzing solution for PHP web applications that improves the detection accuracy and enriches the information provided in vulnerability reports. They use dynamic character grained taint analysis and grammar based analysis in order to analyze the anatomy of each executed SQL query and determine which resulted in successful attacks. A vulnerability report is then accompanied by the offending lines of source code and the fuzz vector with attacker controlled characters individualized .

One shortcoming of prior art teachings is that they suffer from poor accuracy while also at times requiring source code for analysis as opposed to just bytecode assembly code or they attempt to simplify the bytecode assembly code before analysis. Other prior art work teaches running both dynamic and static analysis components in an independent or serial fashion. Furthermore earlier approaches attempt to exhaustively map all data flows in a decompiled or intermediate representation of a software system which impairs performance and slows the overall process. Relatedly prior art teachings do not provide for advantages afforded by concurrent multi core or multi CPU processing infrastructure that is commonplace these days to allow for distributed analysis of very large target software systems with high precision.

In view of the shortcomings of the prior art it is an object of the present invention to provide for high precision software analysis system and methods that do not require the source code of the analyzed program.

It is another object of the invention to not require an exhaustive processing of all dataflows in a program but rather than the ones that include unsafe data.

It is yet another object of the invention to allow for distributed processing of the analysis framework taught by the invention by taking advantage of a multi CPU or multi core processing environment consequently allowing for analysis of very large target software systems with efficiency and high precision.

Still other objects and advantages of the invention will become apparent upon reading the detailed description in conjunction with the drawing figures.

The objects and advantages of the invention are secured by a system and methods of detecting software vulnerabilities in a computer program by analyzing the compiled code of that computer program. The invention optionally uses the source code of the computer program in conjunction with the compiled code but having the source code is not a requirement of the invention. The invention teaches utilizing an instruction model for each instruction of the compiled code. The instruction model for a given instruction includes the instruction location debug information instruction type operands existing memory state requirements bytecode metadata potential security attributes basic block membership and function method membership if applicable of that instruction.

The invention further uses a control flow graph for each instruction that complements the instruction model of that instruction and includes all potential control flow paths and a bidirectional list of predecessor instructions of that instruction. Preferably the compiled code is instrumented at random and critical points in the code. There is a data flow model to record the flow of unsafe data during the execution of the program. The system has the means to analyze the data flow model and to create a security finding corresponding to each instruction that calls an unsafe function on unsafe data. These security findings are aggregated in a security report along with the corresponding debug information and the optional source code information for each instruction that triggered the security finding.

In the preferred embodiment of the invention the instruction model also includes placeholders for additional attributes. These additional attributes may include information for pointer aliases or unsafe dataflow. The pointer alias information may include an aliasing map containing pointers that have the same address values given a subset of or all possible control flows of the instructions of the compiled code.

In another embodiment the instruction model also contains attributes that are deduced from other attributes of the instruction model. These derived attributes may include values for memory locations processor registers and variable types associated with the given instruction of the instruction model. In another preferred embodiment the flow of unsafe data is recorded in a data flow file that utilizes a common file format such as XML based on which the data flow model is at least partially populated. In an advantageous embodiment of the invention an analyzer module is used to analyze the instruction model control flow graph and the data flow model to detect software vulnerabilities in the compiled code.

In a highly advantageous embodiment of the invention a set of concurrent worker threads are spawned that take advantage of a multi core or multi node or multi machine or multi CPU processing platform to analyze instructions where an unknown or unsafe external input or taint data is provided to the program and an unsafe function or method is called upon it. In another preferred embodiment of the system the security findings in the security report also contain a full trace of the unsafe data at the instruction that triggered the security finding along with the line numbers of the source file if available a human readable description of the finding a risk rating and optionally one or more recommendations to address the security finding.

The methods of the invention further provide the steps required to carry out the operation of the system. The invention teaches the steps required to detect software vulnerabilities of a computer program by taking as input the compiled code of the program and optionally its source code. It then creates an instruction model and a control flow graph for each instruction in the compiled code. If further creates a data flow model to record the flow of unsafe data during the execution of the compiled code. The compiled code is instrumented at random and critical control flow points of the program.

For a given instruction the instruction model includes the location debug information instruction type operands existing memory state requirements bytecode metadata potential security attributes basic block membership function method membership if applicable and class membership of the given instruction. The instruction model also includes placeholders for additional attributes including pointer aliasing information unsafe data flow information and attributes that are deduced from other attributes including values of memory locations values of processor registers and variable types for the given instruction.

For each instruction the control flow graph is populated with all potential control flow paths and a bidirectional list of predecessor instructions. Finally for each instruction the data flow model is populated by running the compiled code with the instrumentation at least once and recording the flow of unsafe data for each run. In another preferred embodiment this recording of unsafe data flow is first done in a data flow file in a common file format such as XML and the population of the data flow model is based on the data flow file.

The compiled code is scanned according to the methods provided by the invention to find each instruction where an external input is supplied to the program denoting unknown unsafe data. If that instruction calls an unsafe function on the unsafe data this triggers the creation of a security finding. As the analysis is performed all security findings are aggregated in a security report.

In the preferred embodiment each security finding in the security report includes the debug information for the instruction that triggered the finding along with the line numbers of the source code if available a trace of the unsafe data from its origin to termination identifier values of any processor registers or variables containing the unsafe data a description of the security finding a risk rating and optionally one or more recommendations to address remedy the security finding. Appropriate highlighting of these elements in the security report is also performed to make the report visually presentable readable and easy to consume.

In another advantageous embodiment three lists are created for each instruction. These lists are Unsafe1 Unsafe2 and Unsafe3. All instructions that are determined to be unsafe i.e. they use unsafe data by calling an unsafe function are added to a list called Worklist. A set of concurrent worker threads are spawned each thread selecting and processing an instruction at random from Worklist. Based on the control flow graph and data flow model earlier created for each instruction in Worklist Unsafe1 list is populated with incoming unsafe data at that instruction Unsafe2 list with unsafe data currently being processed by that instruction and Unsafe3 list with unsafe data that has been fully processed by that instruction. As the worker threads process the instructions the contents of the three lists for each instruction are updated based on the control flow graph of that instruction as data flows from its Unsafe1 list to Unsafe2 list to Unsafe3 list and into the Unsafe1 list of the downstream instruction. If new unsafe data is added to the Unsafe1 list of an instruction that calls an unsafe function it is re added to the Worklist and a security finding is generated and the above process is repeated. Ultimately the spawning of worker threads is concluded when there are no more unsafe instructions left in Worklist or a predetermined timeout period has elapsed during the above processing.

Concurrency locks are provided for each of the three lists Unsafe1 Unsafe2 and Unsafe3 above and at each step of the above processing these locks are used to ensure the integrity of the contents of these lists. When a list is no longer being used its concurrency lock is released unlocked .

In a highly advantageous embodiment worker threads are distributed across a multi core or multi processor or multi CPU processing environment to improve the performance of the analysis and to allow processing of very large target software programs. In a similarly advantageous embodiment the traversal of the control flow graph by the worker threads is performed according to custom unsafe data propagation rules provided by the user. In another advantageous embodiment the security findings are created by an analyzer module.

Clearly the system and methods of the invention find many advantageous embodiments. The details of the invention including its preferred embodiments are presented in the below detailed description with reference to the appended drawing figures.

The figures and the following description relate to preferred embodiments of the present invention by way of illustration only. It should be noted that from the following discussion alternative embodiments of the structures and methods disclosed herein will be readily recognized as viable alternatives that may be employed without departing from the principles of the claimed invention.

Reference will now be made in detail to several embodiments of the present invention s examples of which are illustrated in the accompanying figures. It is noted that wherever practicable similar or like reference numbers may be used in the figures and may indicate similar or like functionality. The figures depict embodiments of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.

The present invention will be best understood by first reviewing the software vulnerabilities detection system according to the current invention as illustrated in . Vulnerabilities detection system comprises computer program in the form of its compiled code and optionally source code that resulted in its compiled code . Computer program is the target program to be analyzed by system for software vulnerabilities. Having source code is desirable but not required by software vulnerabilities detection system according to the invention. Vulnerabilities detected by system in computer program may allow exploitative attacks by potential adversaries or hackers. Such attacks include but are not limited to denial of service attacks code injection attacks and 2order attacks such as cross site scripting XSS attacks.

Software vulnerabilities detection system comprises instruction model control flow graph and data flow model . Based on instruction model control flow graph and data flow model software vulnerabilities detection system performs analysis to produce security report comprising the security findings discovered during analysis .

Readers with average skill in the art will understand that compiled code can be executable binary code machine code or object code that can run directly on a hardware platform such as x86 Sparc Mac HP IBM Mainframe etc. or it can be an intermediate bytecode or portable code that can run in a given runtime environment such as Java Virtual Machine JVM . Source code can be in any programming language such as C C Java Assembly Cobol SQL etc. Furthermore source code can be in any 2 3 4or higher generation programming language without departing from the principles of the invention. A highly advantageous feature of the current invention is that source code is desirable but not required to achieve the objects of the invention. Not requiring the presence of source code overcomes many practical limitations of the prior art.

Instruction model is a programming construct used by the invention to model each instruction of compiled code . This programming construct comprises all the necessary and desirable attributes required by system to model each instruction of compiled code . These attributes include the location e.g. base address and relative memory location of the instruction debug information if available e.g. variable name annotations and or source code line annotations type of the instruction e.g. mov add sub its operands e.g. eax register an integer immediate value operand stack reference local value reference its potential security attributes.

These attributes further include existing memory state requirements of the instruction e.g. basic block derived invariant conditions basic block membership e.g. start and end references for all basic blocks encompassing an instruction function method membership e.g. what functions methods the instructions belongs to and or class membership e.g. which object classes the instruction belongs to if applicable. Those with average skill in the art will find these attributes familiar from the fundamentals of software engineering and computer programming. provides a conceptual representation of instruction model using a familiar notation for data structures and member associations in computer programming.

Referring to during the execution of compiled code user input may be provided by the operator or user of computer program whose vulnerabilities are to be detected. Those familiar with the art will understand that user input represents a potential security risk for computer program as it may intentionally or otherwise violate the bounds of a program variable which may affect the integrity of computer program or the data it is operating on. Thus user input represents taint or unsafe data as will be understood by skilled people of the art. User input can be provided in many different ways for example via a web form and keyboard a file an input output buffer or stream a pipe screen redirect etc.

Compiled code according to the invention is preferably instrumented at random and critical control flow points of the program. Those familiar with the art will understand that instrumentation may refer to code instructions and metadata augmented to the computer program that allow monitoring of its behavior performance and operation more closely than during normal execution and may generate additional logging and debug output to the screen or files as desired. As provided by the invention computer program is preferably instrumented at random points within the program. Instead of or in addition to that the program is also preferably instrumented at points where there is a critical control flow transition in the program.

Those familiar with the art will understand that there are many ways to determine these points where instrumentation may be provided in computer program . In a preferred embodiment instructions in compiled code can be randomly selected for instrumentation. Alternatively or in addition a pre processor can be used to determine the critical control flow points in program prior to its execution and then instrumentation can be added at those points in program . Indeed it is allowed by the invention to instrument entire or none of computer program without departing from the principles of the invention. The instrumentation of program allows observing and modification of unsafe data as it flows through program according to the teachings of the invention.

The invention further uses control flow graph for each instruction that complements instruction model of that instruction. Control flow graph for a given instruction of compiled code is populated with all potential control flow paths of that instruction assuming there is no overwriting of the underlying instructions. Control flow graph for a given instruction also contains a bidirectional list of its predecessor instructions. represents control flow graph for an instruction I according to the teachings of the invention. In each instruction is represented by a circle. Instruction I has 4 predecessor instructions P and successor instructions S representing all possible control flow paths for I as shown in the figure. All P instructions will be contained in a bidirectional list in control flow graph for instruction I as represented by the dashed line in .

Referring back to the invention further comprises data flow model . During the execution of program the movement of unsafe data is recorded in data flow model . The movement of unsafe data as a result of successive instructions is recorded in data flow model according to the teachings of the invention. represents an example data flow model populated according to the teachings of the invention.

In variable V contains unsafe data that may have been previously supplied by user input as taught earlier see . Tainted data V is then moved to processor register AX in the next instruction of one control flow path and then copied to variable V. The subsequent instruction then calls an unsafe function on variable V representing a potential security risk in the computer program. also illustrates additional control flow paths in data flow model where the unsafe function call is performed on the tainted data contained in variable V. Those familiar with the art will know the various types of unsafe function calls that may result in a potential security flaw in the code that can be exploited by an adversary. For example in C C char strcpy char dest const char src function on tainted data is an unsafe function call because it can allow a security condition called buffer overflow to happen and damage the integrity of computer program of or its data or worse allow a malicious adversary to inject harmful code or virus into the computer program.

According to the teachings of the current invention as explained above data flow model only records the flow of unsafe data during the execution of the program as opposed to attempting to include and record all potential data flows. This significantly reduces the performance overhead and memory requirements of software vulnerabilities detection system allowing it to analyze large target software systems more comprehensively than possible through the teachings of prior art. This also allows the current invention to not require decompilation of compiled code as required by some prior art teachings.

According to the main embodiment of the invention based on instruction model control flow graph and data flow model all instructions in computer program that call an unsafe function on unsafe data trigger a security finding which is recorded in security report as represented in . Each such security finding contains debug information of the instruction that triggered the security finding along with its source code information if available. Security report exposes the vulnerabilities in computer program that can be appropriately remediated to prevent exploitative attacks by amateur and professional adversaries according to the teachings of the invention.

As represented in instruction model further includes placeholders for additional attributes or deduced attributes that may not be immediately known at the time of the initial creation of instruction model . These additional attributes may include pointer aliases. Pointer aliases represent pointers that point to or contain the same memory address for multiple control flow paths of computer program .

In addition instruction model for a given instruction I may include information related to its predecessor instructions P as represented in and any additional information or metadata as deemed necessary to facilitate recording of the flow of unsafe data as represented in . Furthermore instruction model may also include information deduced from other attributes. Examples of such derived attributes include memory locations or addresses processor registers and variable type information for the given instruction based on its type debug information and bytecode metadata.

According to an additional embodiment of the invention analysis in may be performed by an analyzer module. Analyzer module may be a part of system or may be external to it. If it is external to system appropriate remote invocation calls or function calls or remote procedure calls RPC may be implemented to call the external module as will be obvious to those skilled in the art. Indeed it is possible that the analyzer module is a 3party software with its own application programming interface API without departing from the principles of the invention. Similarly in a highly advantageous embodiment analysis is performed by worker threads that are spawned specifically for that purpose. These worker threads may then be distributed across a cluster of computing nodes processors or cores in a multi CPU or multi core parallel processing environment.

Further embodiments provide security report of to include an execution trace of unsafe data corresponding to each security finding populated in the report. The execution trace may contain the origin and termination information for the unsafe data that ultimately caused the security finding to be triggered. For example if unsafe data was provided as a user input in function or instruction I and it traversed through several intervening functions or instructions I . . . I before being discarded or reset in instruction I then execution trace for the corresponding security finding in security report may contain the entire lifecycle or trace of that data along with the names of functions or instructions I . . . I.

In addition security report may contain a human friendly description of the security finding and a risk rating or risk factor assigned to the security finding by system . Depending on the severity of the vulnerability associated with each finding vulnerabilities detection system may assign a risk rating from 1 to 10 or as a percentage or use some other suitable rating system. Security report may also contain one or more recommendations on how to address the security finding or provide a fix for the problem. Such recommendations and risk assignments may be based on a knowledgebase not shown derived from subject matter expertise in detecting and correcting such software vulnerabilities.

The methods of the invention describe the steps required to operate software vulnerabilities detection system of . In the preferred embodiment computer program is executed at least once and the flow of unsafe data through the program is first recorded in a data flow file as shown in . Based on the contents of data flow file data flow model is populated. The format of data flow file can be any suitable file format such as XML plain text any other markup format or a binary or compiled format without departing from the principles of the invention.

In the preferred embodiment three lists Unsafe1 Unsafe2 Unsafe3 are created for each instruction. Persons with average skill in the art will understand that these lists can be linked lists arrays or any other appropriate data structures of computer software without departing from the principles of the invention. Compiled code is scanned to find each instruction where an external input is supplied to the program denoting unknown unsafe or taint data. If that instruction calls an unsafe function on the unsafe data that instruction is added to another list Worklist. Persons skilled in the art will again understand that Worklist can be a linked list an array or any other suitable data structure. List Worklist Unsafe1 list Unsafe2 list and Unsafe3 list are shown in along with the other elements of the invention as taught earlier.

Next a set of concurrent worker threads are spawned each thread selecting and processing an instruction at random from Worklist of . Based on instruction model control flow graph and data flow model for each instruction in Worklist Unsafe1 list is populated with incoming unsafe data at that instruction Unsafe2 list with unsafe data currently being processed by that instruction and Unsafe3 list with unsafe data that has been fully processed by that instruction. As the worker threads process the instructions of compiled code the contents of Unsafe1 list Unsafe2 list Unsafe3 list for each instruction are updated based on control flow graph of that instruction as data flows from its Unsafe1 list to Unsafe2 list to Unsafe3 list and into Unsafe1 list of the successor instruction.

If new unsafe data is added to Unsafe1 list of an instruction that calls an unsafe function a new security finding is created and added to security report as represented in and that instruction is re added to Worklist and the above process is repeated. Ultimately the spawning of worker threads is concluded when there are no more unsafe instructions left in Worklist or a predetermined timeout period has elapsed during the above processing. shows the above algorithm in a flowchart format where an unsafe instruction denotes an instruction that calls an unsafe function on unsafe data as explained above and the label instr is used to abbreviate the term instruction.

Referring to concurrency locks are provided for each of Unsafe1 list Unsafe2 list and Unsafe3 list respectively and at each step of the above processing these locks are used to ensure the integrity of the contents of these lists. When a list is no longer being used its concurrency lock is released unlocked . Those skilled in the art will understand how the contents of Unsafe1 list Unsafe2 list and Unsafe3 list will be updated as explained above.

Further explained when a worker thread selects an instruction to process from Worklist it locks its Unsafe2 list and Unsafe3 list and also temporarily locks its Unsafe1 list while it imports data from its Unsafe1 list to Unsafe2 list . The worker thread then statically analyzes the currently selected instruction to determine from its incoming unsafe data in Unsafe1 list currently processed data in Unsafe2 list and fully processed data in Unsafe3 list what other instructions that unsafe data may propagate to. This determination is based on the attributes of the current instruction as contained in its instruction model and any other custom unsafe data propagation rules pre defined or provided by the user.

Examples of custom unsafe data propagation rules include specifying that a function or method e.g. execSqlStatement String query should never receive unsafe or taint user input in its first and only parameter. Such a rule could be expressed as an XML file defining regular expressions to identify the specific class and method for this call along with a numeric value identifying that the first parameter should never be tainted or uncontrolled along with security information defining the security impact of such a condition. Another example would be a rule which identifies that the subString Integer from call will propagate the value of its object instance to its return value which could be similarly expressed in an xml file and identifying the return value. Still other examples of custom rules include source rules which define the insertion of uncontrolled or tainted data into a program and cleanse rules which define methods that are known to control data such that the data can afterwards be considered safe in one or more ways.

Referring back to and preceding teachings based on control flow graph of the current instruction the current worker thread aggregates all possible control flow destinations of the current instruction in a list Next Instructions not shown . Subsequently for each instruction in Next Instructions list the current worker thread locks its Unsafe1 list and adds outgoing processed unsafe data contained in its Unsafe3 list to the incoming unsafe data contained in Unsafe1 list of the instruction selected from Next Instructions list. As explained above if unsafe data is added to Unsafe1 list of an instruction that calls an unsafe function a security finding is added to security report and that instruction is re added to Worklist . The above process continues until there are no more instructions left to process in Worklist or a timeout period has elapsed.

In a highly advantageous embodiment worker threads are distributed across a multi core or multi CPU or multi machine or multi node processing environment to improve the performance of the analysis and to allow processing of very large target software programs. In a similarly advantageous embodiment the traversal of the control flow graph by the worker threads is performed according to custom unsafe data propagation rules provided by the user. In another advantageous embodiment the security findings are created by an analyzer module.

In another advantageous embodiment security report as shown in contains a full execution trace of unsafe data corresponding to each security finding populated in security report . The execution trace may contain the origin and termination information for the unsafe data that ultimately caused security finding to be triggered. As an example consider that unsafe data was provided as a user input in function or instruction I and it traversed through several intervening functions or instructions I . . . I before being discarded or reset in instruction I. Then execution trace for corresponding security finding in security report may contain the entire lifecycle or trace of that data along with the names labels of instructions I . . . I and filename s and corresponding line numbers in the source files from source code if available or obtained from debug information or assembly instructions.

If source code if available. If source code is available each source file corresponding to the above trace is parsed into an abstract syntax tree or trees and the line numbers and offsets for non keyword identifier tokens is generated. Persons skilled in the art will understand that these non keyword identifier tokens will represent user or custom variables as opposed to keywords belonging to the grammar of the programming language itself. Using the abstract syntax tree or trees above corresponding to each instruction in the trace the identifier names and values of any variables or processor registers that contained the unsafe data is obtained using the debug information and then added to the trace information.

In addition security report of may be properly formatted to be visually appealing with proper highlighting of important pieces of information for each security finding and contain a human friendly description of the finding along with a risk rating or risk factor assigned to the finding by system . Depending on the severity of the vulnerability associated with each security finding vulnerabilities detection system may assign a risk rating from 1 to 10 or as a percentage or use some other suitable rating system. Security report may also contain one or more recommendations on how to address security finding or fix the problem. Such recommendations and risk assignments may be based on a knowledgebase not shown derived from subject matter expertise in detecting and correcting such software vulnerabilities. The knowledgebase may be further designed to continuously augment its content either automatically or with human assistance or by a combination of both automatic and manual means as vulnerabilities detection system operates over time.

In view of the above teaching a person skilled in the art will recognize that the apparatus and method of invention can be embodied in many different ways in addition to those described without departing from the principles of the invention. Therefore the scope of the invention should be judged in view of the appended claims and their legal equivalents.

