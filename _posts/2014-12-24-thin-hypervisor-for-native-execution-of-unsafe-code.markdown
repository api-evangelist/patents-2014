---

title: Thin hypervisor for native execution of unsafe code
abstract: A system, method and computer program product for implementing a thin hypervisor. The thin hypervisor does not have any association with a VM. The thin hypervisor serves as a wrapper over hardware capabilities of a processor. The processor has privileged low-level capabilities EPT VTX, AMD V and the ARM has virtualization technology. In order to use processor hardware capabilities and receiving root privileges, the system operates in a “super user” mode. The VM operates in a VM environment with kernel privileges in a user mode. A super user space is created in a safe mode. A user space application (or a process) is created. A user space virtualization framework library is used. These entities are separated by a user space and a kernel space. A thin hypervisor is implemented in the user space.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274823&OS=09274823&RS=09274823
owner: Parallels IP Holdings GmbH
number: 09274823
owner_city: Schaffhausen
owner_country: CH
publication_date: 20141224
---
The present invention relates to virtualization technology and more particularly to a thin hypervisor for native execution of an unsafe code.

With Virtual Machine VM technology a user can create and run multiple operating environments on a Host server at the same time. Each Virtual Machine requires its own guest operating system GOS and can run applications independently.

Each VM acts as a separate execution environment which reduces the risk and allows developers to quickly re create different operating system OS configurations or compare versions of applications designed for different OS s for as long as the integrity of data used by each of the VMs is provided. Generally a Virtual Machine is an environment that is launched on a particular processor a host that is running a host operating system HOS and the VM runs the Guest OS.

A hypervisor provides a layer between the computing storage and networking hardware and the software that runs on it. Using hypervisor assisted virtualization requires a privileged hypervisor kernel module running on a protected mode ring 0 managing root mode and handling virtual machine control structures VMCS for VMs. However applications sold through Mac App Store App Store Google Play Windows Market are not allowed to have protected mode ring 0 and root privileges and to use personal drivers. These limitations prevent publishing of virtualization applications.

Many users would like to have products that support virtualization to have the benefit of multiple guest OSs running in parallel on the same host computer. The processor privileges for entering into root mode required for hardware assisted virtualization are not allowed by software distribution rules. Applications deployed from online stores such Mac App Store App Store Google Play Windows Market run in an isolated environment so called sandbox having very limited system functions access. System API calls are controlled by a host operating system. Only limited standardized API functions calls frameworks which are explicitly declared as compatible with sandboxed environment are allowed in applications deployed from the stores. The applications must be registered and distributed without the drivers and using ring 0 and root privileges.

Accordingly there is a need in the art for special standardized thin hypervisor for using hardware virtualization capabilities of modern processors with Mac App Store App Store Google Play Windows Market and similar products.

The present invention is directed to virtualization technology and more particularly to a system and method for a thin hypervisor for native execution of an unsafe code that substantially obviates one or several of the disadvantages of the related art.

In one aspect there is provided a system method and computer program product for implementing a thin hypervisor. The thin hypervisor does not have any association with a VM. The thin hypervisor serves as a wrapper over hardware capabilities of a processor. The processor has privileged low level capabilities Intel VT X including EPT and unrestricted guests extensions AMD V including RVI and the ARM has virtualization technology. Only kernel space code can use processor virtualization capabilities. Applications running in a sandboxed environment cannot have kernel modules. Such applications can access privileged functionality including kernel space functions of OS by using formalized and documented API only. Therefore processor virtualization capabilities are unavailable for using from downloaded applications.

In order to use processor hardware capabilities and receive root privileges the system operates in a super user mode. The VM operates in a VM environment with kernel privileges in a user mode. A super user space is created in a safe mode.

According to the exemplary embodiment a user space application or a process is started. A user space virtualization framework library is used. These entities are separated by a user space and a kernel space. A thin hypervisor is implemented in the kernel space. The virtual execution environment VEE is a non root environment i.e. a special mode of processor operation that allows unsafe code execution in an isolated environment and gets so called VMExits on unsafe operations but the isolation is guaranteed within the VM.

Hardware virtualization technology contains virtual machine control structure VMCS managing non root mode for VEE execution and declaring unsafe operations VMExit conditions. A properly created VEE environment is fully isolated environment that code running inside non root mode cannot access any data and hardware of host OS.

An important aspect is implementing a very small piece of code that is enough to create proper VEE environment to isolate non trusted guest code. This small piece of kernel level code virtualizes almost nothing and only performs pass through all non trusted guest environment read write set up requests from user space and returns all VMExits to user space without any processing in kernel space. Thus user space application can create and manipulate guest registers and code state without harming host operating system. A thin hypervisor is intermediate management layer accessed by using simple VEE state read write user space standardized API. At the same time the thin hypervisor allows full functioning VMCS and guest registers state access that user space application may prepare any kind of non trusted guest code and launch it in isolated non root environment.

Additional features and advantages of the invention will be set forth in the description that follows. Yet further features and advantages will be apparent to a person skilled in the art based on the description set forth herein or may be learned by practice of the invention. The advantages of the invention will be realized and attained by the structure particularly pointed out in the written description and claims hereof as well as the appended drawings.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are intended to provide further explanation of the invention as claimed.

Reference will now be made in detail to the embodiments of the present invention examples of which are illustrated in the accompanying drawings.

VEE Virtual Execution Environment a type of environment that supports program code execution where at least a part of the real hardware and software required for running program code are presented as their virtual analogs. From the point of view of the user the code in VEE runs as if it were running on the real computing system. An example of VEE is a Virtual Machine VM .

VE Virtual Environment for example a Virtual Private Server VPS is one type of a Virtual Execution Environment VEE running on the same hardware system with a shared OS kernel and most of the system resources where isolation of Virtual Execution Environments is implemented on the namespace level.

VM Virtual Machine a type of an isolated Virtual Execution Environments running on the same physical machine simultaneously. Each Virtual Machine instance executes its own OS kernel. Support of Virtual Machines is implemented using a Virtual Machine Monitor and or a Hypervisor.

Hypervisor controls software while having the highest privilege level for administrating hardware computer resources and Virtual Machines.

A VEE according to an exemplary embodiment can be any of a Virtual Private Server a Virtual Machine a Hypervisor based Virtual Machine a session of Terminal Server Windows 2003 or older and a session of Citrix Presentation Server VMM based VMs or hypervisor based VMs.

Each VM can have several execution contexts with the events that need to be logged. The contexts can be Virtual Machines VMs and various applications.

According to the exemplary embodiment a system method and computer program product for implementing a thin hypervisor are provided. The thin hypervisor does not need any association with a particular VM. The thin hypervisor serves as a wrapper over hardware capabilities of a processor to provide simple access for user space applications and to filter harmful state modifications of hardware structures e.g. VMCS . According to the exemplary embodiment a user space application or a process is started. A thin hypervisor is implemented in the kernel space. These entities are separated by a user space and a kernel space. A user space virtualization framework library is used to provide standardized API to hardware virtualization capabilities managed in thin hypervisor. The user space application uses virtualization framework API to manage hardware assisted virtualization environments. The virtual execution environment is a non root environment i.e. a special mode of processor operation that allows a user to perform unsafe operations but the isolation is guaranteed within the VM.

Virtual Machine Control Structure VMCS and Virtual Machine Control Procedure VMCB form the unsafe operation exception map when the process needs to exit the isolated non root mode execution context. Then VMEXITs are generated. However the exemplary embodiment can provide a mode where exits from the VM are not executed and the harmful code is forced to be executed inside the VM or the execution context ignores the code trying to exit a VM.

The VMCS is divided into three parts a control part a host part and a guest part. The thin hypervisor prohibits access to the host part and doesn t provide any interfaces for manipulation of the host part to the user space process. Access to the control part is filtered and reads and writes to the guest part are allowed. The host part describes a real processor state when it gets the VMEXIT and determines location of the VMEXIT handler. The user space application can create and configure the environments for execution of the unsafe applications and so called guest operating systems. The unsafe code is executed then under protection of the thin hypervisor in a completely isolated context. There are no limitations on executed code and context running in non root mode Real Mode Protected Mode with its privileged levels divided to user and supervisor system levels . If an executed instruction is allowed by the VMCS control part it works natively in isolated environment. Otherwise the execution fails with the VMEXIT the unsafe code is interrupted the thin hypervisor processes nothing and simply push exit to the user space for further handling and or virtualization and or emulation. Note that the use of hardware capabilities provides for the most native code execution. If an instruction is not allowed in a virtual execution environment the VMEXIT is generated. Generally the thin hypervisor does not know about how the VMEXIT should be processed and simply passes it to user space application because all cases that are prohibited for native execution are handled there. Also only subscribed applications know how to handle VMEXITs. Thus keeping host protection the thin hypervisor provides a way to execute any kind of code in hardware assisted isolated non root mode natively without harming the host OS. The thin hypervisor is very small but it is enough to pass control between user space application handling all unsafe cases and non root mode running safe code natively. Parts of the thin hypervisor can be also implemented as microcode without any overhead analogous to a hardware implementation of VMEXIT directly to user space handler. The configurations can be implemented by VMCS. If installation of kernel space drivers is prohibited e.g. on some Smartphones the thin hypervisor allows for extended functionality. For example the phone is placed into a hibernating state or the phone is turned off inside the VM. The reactivation of the phone can be triggered from the host OS for example in a safe mode and either keeping or losing the VM .

In one embodiment the host context is safe but only allows for loading a certain number of applications. The exemplary embodiment can provide a safe context for an extended variety of applications. VMEXITs create considerable overhead. According to the exemplary embodiment each context has a certain set of functions allowed in this context including exiting the context . Thus exit from the context is always safe and the process switches to a safe context. The context prohibits operations with unsafe registers or reading data from other contexts.

According to another embodiment the thin hypervisor can provide means for reading and analyzing data within the context for using anti virus capabilities. Meanwhile the thin hypervisor prohibits saving data upon exiting the context. In other words two events are generated virus present and no virus detected. Then the presence of a virus can be analyzed by the system at the address of exception generation.

According to the exemplary embodiment isolated environments for drivers of new devices are created. For example an isolated environment can be created for isolation of ranges of address spaces allocated for devices. In order to provide safety super user rights can be granted. This is implemented by a system procedure of the thin hypervisor for using all system components in a safe mode.

According to yet another exemplary embodiment the memory can be virtualized using nested paging such as Intel EPT AMD RVI which provides translation of the guest physical addresses into host physical addresses. The set of address translation tables of virtual environments with re mapping of addresses is used. Thus the contexts can be isolated without physical isolation. In one embodiment a safe tunnel or a thin hypervisor can be defined by a context identifier or by a table containing available address ranges and allowed operations for certain address ranges and allowed argument values that can be written into registers and at the context addresses. The thin hypervisor can have synchronous and asynchronous interfaces. The virtual environment context can be launched by passing a request for launching unsafe code from user space context to the hypervisor.

According to the exemplary embodiment the access to processor hardware functions can be implemented by the same API using different values. For example different hardware components are mapped at different physical addresses. A hardware access function can be called from a user space application. The driver can pass the function to the kernel space. However the system checks the argument value or a range of arguments for being allowed. For example a read write buffers and a device control buffer can be located in a particular address range. A user may only have permission for the read buffer. Calls for other addresses are declined after a check. This structure advantageously simplifies translation of calls and increases performance. Additionally it protects hardware from intrusions.

According to the exemplary embodiment a software development kit can use the drivers or part of the OS kernel providing access to hardware assisted virtualization capabilities. A developer can check for the compatibility of a driver to see if the driver is sufficient to accommodate system functionality. If the use of system calls is not allowed the functions can be replaced by the ones compatible with the driver or another driver can be used. Distributed applications can have a procedure that determines the installation platform environment and calls an appropriate driver. Thus a virtualized SDK framework can use different drivers for different platforms.

According to one exemplary embodiment a set of safe tunnels from the user space to the kernel space is implemented on the system kernel. Each of the tunnels is safe for the system and can be used only by a single user. Shared use of the tunnels is prohibited. A set of rules may be taken into consideration before tuning of the tunnels.

Unsafe code running in an isolated non root mode requires memory access. A responsibility of user space application is to prepare set of memory page regions and to associate them with ranges of unsafe code physical pages by using the thin hypervisor API. The thin hypervisor tracks the ranges and creates nested paging EPT RVI entries to map the registered regions. Thus unsafe code accesses memory pages only within the boundaries of mapped regions.

To be mapped user space memory pages have to be locked or wired by using correspondent host operating system kernel API. Locking pages reserves real physical pages under user space buffer until an unlock operation is performed. The thin hypervisor creates nested paging tables and write physical page addresses to correspondent nested paging table entries. The thin hypervisor can do mapping on demand when unsafe code tries access correspondent page or it can create full non root guest memory mapping right after user space memory region registration. These behaviors are only examples of how thin hypervisor can do the nested paging structures preparation. Other combined methods are also possible.

Many types of user space virtual address space buffers are allowed. The only requirement is the host OS kernel can make locking operations and get physical pages for the buffer. Pages allocated in pool memory mapped files and anonymous mappings can be used as unsafe code memory pages storage.

No implementation of mmap is required it is required for correct remapping of the guest memory non anonymous plain mappings can be supported but do not need to be supported they are used by VMMs for performance reasons on Linux platforms.

Local storage suffers from automatic cloud syncing and sudden out of space removal. The cloud syncing should be disabled for VM files since transferring memory images over network is not required and will degrade performance. The ability to disable the out of space killer for VM files should be available.

Out of memory killer should call subscriber callback so that VMM has the ability to reclaim memory from the guest OS and return to Chrome OS instead of being killed.

AF INET type sockets are the only ones that need to be supported. As a result no VPN connections outside the guest OS are allowed. For full support of the guest network raw socket support is required.

No API to hook USB device connections needs to be provided no USB device interception and binding to the Virtual Machine is allowed. Support for USB device recognition and passing into VM is required to implement USB support.

Inter process communication between NaCl processes is difficult only sockets are supported as a universal communication method.

Shared memory does not need to be supported. It is required to share video memory between the GUI component and the VMM itself as well as for quick inter process communications.

No CPUID support NaCl verifier does not allow the CPUID instruction but a VM requires it to verify supported features.

The safe tunnels can be used for example by AV modules for isolation of harmful applications in a virtual context and for launching of the drivers in an isolated virtual environment.

The virtualization requires a kernel driver or OS kernel part for applications supporting virtual contexts to launch unsafe code natively. However the kernel driver cannot translate all application calls to the system level because some combinations of the system calls can be unsafe for system operation and can compromise the integrity of a protected data. In order to solve this problem the drivers supporting hardware virtualization that cannot be included into an application are placed into the kernel. The drivers can have configuration settings or several drivers can be used so each driver translates only a certain set of instructions. The thin hypervisor can be implemented conceptually as a driver or it can be implemented as part of the host OS i.e. works at kernel space level with 0 ring privileges for IA 32 IA 32e or super user for ARM etc. .

In one embodiment the drivers control a table of virtualization instructions. Such tables have fields that can be modified only at a privileged access level. The driver is implemented at the OS level. The driver supports operations with the table regardless of the context executed by the processor. The context does not have any direct access to the table. The driver determines the fields of the table that can be used from the application. Since the application does not have access to the fields the driver provides an API and read write access to the virtualization table field. For example a set of safe fields can be pre determined. An additional field makes the set unsafe.

Basic processor unsafe instruction execution in non root mode is controlled by Virtual Machine Control Structure VMCS in case of Intel VT x and by Virtual Machine Control Block VMCB for in case of AMD AMD V and by Virtualization Extensions in case of ARM architecture compliant processors. The control structure contains three parts host guest and control part. Through the thin hypervisor API a user of virtualization framework has complete access to the guest part and limited access to the control part. The user operates with a low level hardware state of guest registers located in VMCS. The thin hypervisor filters user calls to the low level state in order to limit access to unsafe fields i.e. host state control structure .

A user or a special procedure can decide which privileges are granted to the application based on the selected context and the API. A certain set of privileges can produce a higher level of isolation of application or prohibit the use of other non virtualized system functions. The truncated API interfaces into user space via the thin hypervisor through a driver . The thin hypervisor provides the user space with an access interface to the hardware virtualization capabilities via ioctl syscall or VMCALL in case of a host OS working in unprivileged environment . On OS X the thin hypervisor is called by using Mac OS X IOKit IOConnectCallXXX IOConnectTrapXXX or system call mechanism.

Those skilled in the art will appreciate that very small amount of code API is used in the kernel driver. This code is safe and can filter the unsafe fields. This API does not compromise safety of the entire host. The user does not have access to states which can harm the host or host OS state. Instead the safe driver hypervisor performs the access. Accordingly the application is given hardware virtualization capabilities and unsafe code or system guest code can be executed inside the virtual context. The unsafe guest code can be a virus application or another application that requires system privileges or a complex guest operating system running in isolated non root mode under thin hypervisor control.

The OS has kernel control structures VMCS VMCB. The objects of this structure reside in the OS kernel and have the instructions that affect safety. Thus a user cannot be given an ultimate control over these instructions. The thin hypervisor configures the host fields and does not allow for modifying them. In one embodiment each application or a set of applications can be provided with different virtual machines using hardware virtualization. Thus the application can call its own VM but not the other VMs. In other words the applications run in isolated contexts and the operating system schedules applications run times. Meanwhile the virtualization is controlled by user applications independently in a mutually safe mode. The applications do not know who uses what VM and cannot enter into another context because the host portion of the fields in the driver is controlled by the driver. The driver determines VMEXIT handler entry point determine processor state when returns back from non root guest code mode to root thin hypervisor mode. The host writes these addresses and states into correspondent fields of host part of VMCS VMCB but hypervisor settings do not allow access to the fields by the applications.

The registers of the processor are controlled in the same way. Also the user application cannot use several VMs which can be possible without an isolated application. In one embodiment some fields can be modified in bits. Some fields can be filled with system data but in an isolated context. For example a user can do whatever he wants inside the context but without exiting the context. In one embodiment the user is given a driver for modifying the system context inside the context because the Mac App Store does not give such privileges to applications sold through it. In other words a user is given an API for the system configuration but without an access to the kernel space. The thin hypervisor performs translation into the kernel space based on pre set safety rules.

VMEXIT is an operation switching processor from a non root mode into a root mode which may have additional arguments indicating a cause of switching to the thin hypervisor from the guest code. The argument may be implemented in form of comments or as an additional argument otherwise unused or in some other form for example nested vmx vmexit vcpu to vmx vcpu exit reason vmcs read32 VM EXIT INTR INFO vmcs read1 EXIT QUALIFICATION The VMEXIT arguments corresponding to the exit code are read into the thin hypervisor without exiting into the user space. The guest state can be pre fetched based on previous states or empirically in order to optimize a number of switches to the user space. According to the exemplary embodiment special configuration fields for exit events from the root mode and from the VM are allocated.

A guest non root state is reflected by values of a segment and control registers including states of the registers before and after exiting into the virtual context. Each context can have a limited set of hardware functions that are allowed to be accessed. For example the context for multi media applications can provide access to reading the disk at a block level for optimizing read speed. Also the context can provide access to hardware decoding of the context. Meanwhile another safe context is responsible for populating the disk in order to protect the file system.

According to the exemplary embodiment the thin hypervisor supports a minimal required interface for access and control of hardware acceleration. Most of the control is based on one to one access correspondence to the guest state stored in VMCS access to registers state that are not a part of the VMCS i.e. GPRs FPU XMM YMM MSRs etc. . Since the nested paging EPT and RVI control mapping of guest physical addresses into real physical addresses at the physical page level the virtual memory portions guest memory need to be locked in the OS kernel upon being placed into hardware structures of the nested paging.

The thin hypervisor manages correspondence of the virtual user space areas and the guest physical areas and locks the guest pages in a lazy mode as they are being accessed in the guest memory. The basic thin hypervisor does not deal with virtualization of any devices except for CPU and memory. However the extended version of the hypervisor can have virtual local Advance Programmable Interrupt Controller APIC .

According to the exemplary embodiment nested paging is in order to simplify translation of the guest addresses into the real physical addresses. Intersection of the real address spaces is prohibited and a context dependent swapping can be implemented in a safe mode. The EPT tables can be used accordingly a user is given access to a system address space but user access to other contexts is limited. This allows for using a minimal amount of code and provides for better virtualization.

The exemplary embodiment can be used with devices when user applications have limited access to the kernel space and to the physical resources but the usability of the application can be improved significantly. For example it can be used when implementing a hardware support of executable functions such as audio coding decoding data compression image processing etc.

If an application does not work without hardware support and the hardware support can only be turned on upon exiting the application the application selects a special driver which provides for safety and turns on the hardware support for required functionality. Meanwhile the other drivers and unsafe functions become inaccessible. In one embodiment each driver can have a set of incompatible drivers that cannot be activated together for the same context. The system can work in one directional mode when an application with a driver are moved into the context and reside there for a long time until it crashes .

According to the exemplary embodiment non root contexts created by the thin hypervisor can be used not only for full virtualization of a computer system i.e. CPU memory devices but also for isolation of potentially unsafe applications and drivers. An execution context is created for the unsafe applications and drivers where any calls outside the context cause VMEXITS and the control is switched to control user space module. An exemplary code used in the thin hypervisor is provided in Appendix i.

As discussed above using hardware assisted virtualization requires a privileged hypervisor module running on a ring 0 and handling virtual machine control structures VMCS for VMs. The privileged thin hypervisor can be implemented as a part of the OS kernel or as a separate kernel module driver i.e. for example in case of Chrome OS it is a Linux kernel module . There are no other ways to get privileged ring 0 permissions. To provide an effective and controlled access to hardware assisted processor capabilities the exemplary embodiment employs a simple user space native client NaCl virtualization library and a thin hypervisor kernel module which provides controlled limited access to VMX capabilities privileged guest OS registers and guest OS memory regions for the sandboxed user space virtualization solution.

The virtualization library calls the thin hypervisor kernel module handling and filtering accesses to privileged capabilities and allowing manipulations with the guest OS non root mode state only. Thus the virtualization library is the only way to access the non root mode which is secure from the root mode and the privileged mode perspective. The kernel module is a thin intermediate privileged level module used to launch the non root code prepared in the user space by the proposed virtualization application.

The thin hypervisor simply bypasses the user space requests to modify VMCS fields but filters and controls the requests if there is a chance that they will affect or corrupt the host state. Besides the virtualization of CPU s the VMs come with a virtual platform guest hardware virtualization e.g. a virtual network adopter a virtual USB port etc. . Guest hardware virtualization is implemented in the user space Virtual Machine Monitor running in the context of the virtualization application. Because of the sandboxed environment the guest devices virtualization can be very limited. Extending the OS API Chrome Apple etc. helps to overcome the limitations and makes it similar to VMX capabilities access.

A typical virtualization solution uses a multi process approach and consists of at least two processes 

2. User space virtualization library to be called from the user space native client NaCl code. The virtualization library is the only way to manipulate the guest OS state in the non root mode.

3. User space application emulating and virtualizing the guest OS platform behavior and using the virtualization library to execute the guest code natively in the non root mode.

The thin hypervisor kernel module and the virtualization library can be integrated with the host OS i.e. Chrome OS MAC OS etc. to provide a common virtualization interface for the sandboxed user space virtualization solution.

The exemplary embodiment provides a secure kernel module for hardware assisted virtualization. The proposed solution consists of a privileged thin hypervisor and a user space virtualization library to access virtualization functions. The privileged part must be as small and secure as possible. This means that most of the platform virtualization code including the hardware assisted virtualization structure logical management is implemented as a user space code. When the native guest code execution is required the user space virtualization application uses the virtualization API of the virtualization library by making a call to a corresponding private interface of the thin hypervisor kernel module.

For security reasons the kernel module restricts access to a number of critical resources such as the physical memory or the host part of VMCS. All critical functionality is implemented inside the kernel module. The module does not obtain any real physical memory addresses from the user space it gets the guest physical memory addresses only . The module configures the needed VMCS registers.

According to the exemplary embodiment the user space virtualization application consists of GUI and VM controller processes user space VMM . The GUI module displays the guest OS desktop content to the user gets the keyboard and mouse input from the user starts the VMs and communicates with corresponding VM controller processes via the inter process communication mechanisms or over the network.

The proposed solution contains a special virtualization library. The library provides an interface to the virtualization capabilities to be used by the NaCl based code. The interface acts as an intermediate and caching level between the virtualization application and the thin hypervisor. An exemplary VM lifecycle is depicted in .

Most of the virtualization library calls are simply forwarded to the kernel module. To reduce a number of user to kernel switches the virtualization library has an internal cache of the virtual CPU states. Writes to VMCS fields or guest CPU registers can be delayed until the real guest code execution begins. The library can also pre fetch some values before returning back to the caller.

The above listed functions are sufficient to execute the guest OS code by using the thin hypervisor. The VM controller process is the user space virtual machine monitor supporting the virtualization and platform emulation in the user space and calling an API when necessary. One of the APIs that the user space monitor uses is the proposed virtualization library that provides a way to launch the guest OS code natively by using the hardware assisted virtualization implemented in the thin hypervisor kernel module. A user space VMM is a part of the virtualization application. It can be implemented as a native client NaCl executable binary linked with glibc.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a host computer or the like including a processing unit single core or multi core a system memory and a system bus that couples various system components including the system memory to the processing unit .

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help transfer information between elements within the computer such as during start up is stored in ROM .

The computer server may further include a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD ROM or other optical media.

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the computer .

Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media that can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system . The computer includes a file system associated with or included within the operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like.

These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers.

The computer may operate in a networked environment using logical connections to one or more remote computers . The remote computer or computers may be another computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated. The logical connections include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks Intranets and the Internet.

When used in a LAN networking environment the computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface .

In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Having thus described a preferred embodiment it should be apparent to those skilled in the art that certain advantages of the described method and apparatus have been achieved.

It should also be appreciated that various modifications adaptations and alternative embodiments thereof may be made within the scope and spirit of the present invention. The invention is further defined by the following claims.

