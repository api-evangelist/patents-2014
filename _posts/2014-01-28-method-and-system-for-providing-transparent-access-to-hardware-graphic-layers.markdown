---

title: Method and system for providing transparent access to hardware graphic layers
abstract: The present invention relates generally to computer graphics, and more specifically to methods of, and systems for, configuring, controlling and accessing multiple hardware graphics layers that are used to compose a single video display. One aspect of the invention is broadly defined as follows: in a computer environment including a software application and an operating system running on a computer, the computer including a graphics card and a video display, the graphics card being operable to render images to the video display. The operating system is operable to: receive draw events; and respond to draw requests from the software application by rendering the draw requests selectively to any of the available hardware layers on the graphics card; whereby the computer environment allows software applications to exploit available hardware layers on the graphics card.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274677&OS=09274677&RS=09274677
owner: 2236008 Ontario Inc.
number: 09274677
owner_city: Waterloo, Ontario
owner_country: unknown
publication_date: 20140128
---
This application is a continuation of U.S. patent application Ser. No. 13 858 506 filed Apr. 8 2013 issued as U.S. Pat. No. 8 648 852 on Feb. 11 2014 which is incorporated herein by reference and which is a continuation of U.S. patent application Ser. No. 13 326 008 filed Dec. 14 2011 issued as U.S. Pat. No. 8 416 235 on Apr. 9 2013 which is incorporated herein by reference and which is a continuation of U.S. patent application Ser. No. 12 940 162 filed Nov. 5 2010 issued as U.S. Pat. No. 8 098 246 on Jan. 17 2012 which is incorporated herein by reference and which is a continuation of U.S. patent application Ser. No. 10 928 698 filed Aug. 30 2004 issued as U.S. Pat. No. 7 830 372 on Sep. 11 2010 which is incorporated herein by reference.

The present invention relates generally to computer graphics and more specifically to methods of and systems for configuring controlling and accessing multiple hardware graphics layers that are used to compose a single video display.

Windows type operating systems allow users and developers to interact with software applications via a consistent graphical user interface GUI while at the same time providing them with the ability to interact with multiple software applications simultaneously. Ideally an operating system should provide access to as much of the underlying graphical hardware s capabilities as possible while maintaining a consistent API application program interface . An operating system API is the set of routines protocols and tools that make up the interface between the operating system and the software applications that access it. Any interaction between a software application and the operating environment i.e. video display hard drive keyboard etc. is done through the operating system API.

Additionally the operating system should support a degree of feature transparency. That is a software application should be able to benefit from a system feature without requiring the software application to be aware of every detail of the system feature. For example a software application designed on a system with a 16 bit colour depth display should run as intended on a system with a 32 bit colour depth display. The software application should not need to know the supported colour depth of the video display it is running on. The greater the degree of feature transparency provided by an operating system the greater the ease of developing software applications that can run in a variety of environments and the greater the selection of software applications available to use with any given platform.

Personal computers and other computing devices generally include a circuit board referred to as a graphics card video card or video board which allows the personal computer to drive a physical display such as an LCD liquid crystal display or a CRT cathode ray tube monitor. These graphics cards typically contain their own video memory so that the computer s RAM random access memory is not needed for storing video display data. Many graphics cards also have their own on board microprocessor so that the processing required to render graphics can be performed very quickly and without being a burden to the main microprocessor of the computer.

Graphics cards typically have much more video memory than needed to store the contents of a single display screen. The contents of the video memory is partitioned into chunks which can be dynamically defined and redefined each chunk having a specific width height and other characteristics. Each chunk is referred to as a video surface one of these video surfaces being treated as the primary display. Drawing to the video surface associated with the primary display will yield visible graphics on the physical display. Drawing to video surfaces other than the primary display will not be visible unless the contents of those surfaces are blitted to the primary display s video surface.

 Layers hardware allows a graphics card to have one or more video surfaces as part of the primary display. The way the various video surfaces are combined and or blended to create the primary display is configurable via the layers hardware on the graphics card. The layers hardware combines all the surfaces targeted at the primary display non destructively. That is the contents of the various video surfaces are not affected by the layering hardware only the end result visible on the display device is affected. This makes graphics cards with layering hardware ideal for low performance platforms that require sophisticated graphics composition such as automotive telematics systems where for example it might be desirable to display the settings of ventilation systems over a road map or video programming while it continues to play.

 Automotive telematics systems refers to the technology of computerized control systems to manage environmental and entertainment systems in automobiles. These systems are also referred to as automobile infotainment or infotronic systems or by other similar names. Some of the functionality that such systems may manage includes 

In one system a software application draws images vectors and characters using an API of the operating system which directly manipulates the memory and registers of the graphics card to affect a display. The software application uses the operating system API but the software application itself acts as a graphics driver directly manipulating the hardware. In such a system only one software application has access to the graphics card at one time due to hardware contention issues.

In the other system the software application draws using an API of the operating system which packages and sends out the draw requests. If the packaged draw requests are delivered to a software application that is using an API of the operating system to manipulate the memory and registers of the graphics card to affect a display those draw requests are rendered to the graphics card and may affect the visible display. In this configuration the drawing applications and the graphics drivers are separate software processes allowing multiple applications to draw using a single graphics card. The mechanism for delivering the packaged draw requests varies within windowing systems known in the art.

If the software application has special knowledge of the API of the graphics card and the rest of the system allows it then the software application can pass messages directly to and from the graphics card to manipulate the memory and registers of the graphics card this is the first method described above . Alternatively if the operating system has a graphics driver with special knowledge of the API of the graphics card and the rest of the system allows it then the graphics driver in the operating system could manipulate the layers capabilities of the graphics card this is the second method described above .

APIs to access and control video hardware layers were first provided by graphics card manufacturers who were producing graphics cards with layers support. However there were at least two major problems with these early APIs 

More recently an operating system API became available which presented a consistent but limited interface to hardware layering capabilities although it was still necessary for a software application to use this specific operating system API to be able to render to the layers supported by the hardware. This limitation made the integration of third party software into a layer enabled system impossible. In other words this new operating system API still requires that third party software applications know that the new operating system API has access to the hardware layers and know how to use it. Typically third party software applications do not have this knowledge so this is not a transparent solution.

One such API is DirectFB an API which provides generic access to video layers capabilities in a limited fashion. DirectFB is limited to exclusive use of surfaces with the ability to share the primary display surface to a degree.

Existing operating system APIs that allow a software application to have direct access to a graphics hardware layer generally preclude that layer from being shared by multiple software applications due to hardware contention issues.

Demand has grown in the automotive medical instrumentation consumer and industrial automation markets for a graphics solution which allows the use of third party software applications legacy applications and new software applications that were targeted at more than one project to be able to leverage the layering capabilities of the chosen graphics hardware.

There is therefore a need for an integrated approach to configure control and access render to graphical hardware layers which addresses the problems outlined above. The approach chosen must take into account the needs of the target markets 

This design must also be provided with consideration for speed of execution reliability complexity and scalability.

It is therefore an object of the invention to provide a novel method and system of computer file management which obviates or mitigates at least one of the disadvantages of the prior art.

One aspect of the invention is broadly defined as in a computer environment including a software application and an operating system running on a computer said computer including a graphics card and a video display said graphics card being operable to render images to said video display the improvement comprising said operating system including a universal application programming interface API which supports hardware layers on graphics cards said operating system being operable to receive draw events via said universal API determine what hardware layers are available on said graphics card and what their parameters are and respond to draw requests from said software application by rendering said draw requests selectively to any of said available hardware layers on said graphics card whereby said computer environment allows software applications to exploit available hardware layers on said graphics card.

In the preferred embodiment of the invention a mechanism is provided which allows the windowing environment and layers hardware to be configured such that software applications that do not know about video layers can in fact render to layers. That is software applications can render to layers without using the video layers APIs at all and not using any special draw commands. This mechanism allows the use of unmodified legacy applications in a layered environment.

Generally speaking the invention addresses the problems in the art by providing an operating system which 

The block diagram of may be contrasted to that of . In the case of when a software application wishes to draw an image character or vector to the display screen it may or may not have knowledge of the layers support available. Thus the system supports two different types of draw requests to the API of the operating system requests which include hardware layer information and those which do not .

The operating system of the invention has an API which supports targetting draw requests to video surfaces which can be associated to layers but also supports non targetted draws. In order to support legacy third party software applications the operating system must handle non layers type requests in the traditional manner. Alternatively two classes of draw API could be defined the traditional API which would provide a non targetted and thereby non layer capable API and a surface or layer draw API which would provide direct access to video surfaces and thus layers.

The operating system also has some means of determining what layers are available on the graphics card . This knowledge could be transferred from the graphics card to the operating system in various ways for example on each boot up as part of the system installation or via hard coding. Operating systems are typically designed to include software drivers which are specific to output devices such as graphics cards. When a user installs a new graphics card part of the installation procedure will include the loading of the graphics cards driver onto the system. These drivers are generally specific to the particular operating system and make and model of graphics card. Drivers are often distributed with the graphics cards on CD Roms but are also generally available online.

Note that the invention does not require any changes to the graphics card and display as described with respect to . The software application may also be the same as the software application if it does not have knowledge of the available layers and the capability to request that certain video hardware layers be used.

On receipt of a draw request the operating system processes the request and sends appropriate instructions to the graphics card via the API of the operating system and the API of the graphics card . Unlike the system of where the operating system has no knowledge of the hardware layers in the graphics card the operating system in the case of the invention does have knowledge of the hardware layers and also has a driver within the API which is complementary to that of the graphics card . Thus draw requests are directed to the layer determined by the operating system in some cases this video hardware layer will be determined by the software application wishing to draw an image character or vector but in other cases the determination will be made by the operating system itself using the geometry of the emitted events the geometry of draw sensitive regions and the priority of the data. This allows the control of what elements are delivered to which regions positionally.

A typical example would for example have alert renderings occurring positionally under a region associated with a layer that has priority over other video surfaces ensuring the alerts are visible over all other content climate data or a movie being shown in the composited display.

These layers of images are all stored separately on the graphics card and are composed non destructively into a single composite image. The composite video image is then sent by the graphics card to the display screen for presentation.

The system of the invention allows graphics card hardware layers to be exploited by any third party applications software regardless of whether it has knowledge of the underlying hardware layers. It also provides a uniform interface so that software applications do not have to be aware of the specifics of a particular graphics card. Other advantages of the invention will be clear from the more detailed description of the invention which follows.

The preferred embodiment of the invention will be described with respect to the Photon Windowing System running over the QNX RTOS real time operating system though the invention could be implemented on virtually any operating system. Variations necessary to apply the invention to other operating systems would be clear to one skilled in the art from the description herein.

A symbolic visualization of the Photon event space and the QNX operating system environment in an embodiment of the invention is presented in .

The QNX operating system is a message passing operating system . This means that all of the software including software applications the operating system itself and windows GUI graphic user interface software run as separate software processes on the system. These software processes are depicted as blocks in section of . Message passing is the fundamental means of interprocess communication IPC between these software processes. A message is a packet of bytes passed from one process to another with no special meaning attached to the content of the message. The data in a message has meaning for the sender of the message and for its receiver but generally for no one else.

The Photon environment provides a three dimensional virtual Event Space where the user can be imagined to be outside of this space looking in. The Photon environment confines itself only to managing Regions owned by application programs and performing the clipping and steering of various Events as they flow through the Regions in this Event Space . Software applications can place regions into this Event Space which are sensitive opaque or both to various types of events which may be passed through.

Software applications can exert an influence on the Photon environment through one or more of these rectangular Regions which are owned by the respective software processes themselves. For example a particular Photon application may generate a Region . Regions can also emit and collect objects called Events. These Events can travel in either direction through the Event Space i.e. either toward or away from the user . As Events move through the Event Space they interact with other Regions this is how software applications interact with each other. Regions are stationary while Events move through the Event Space .

As an Event flows through the Event Space its rectangle set intersects with Regions placed in the Event Space by other software processes. As this occurs the operating system adjusts the Event s rectangle set according to the attributes of the Regions with which the Event intersected.

Events come in various classes and have various attributes. An Event is defined by an originating Region a type a direction an attached list of rectangles and optionally some Event specific data. Events are used to represent the following 

The normal operation of a graphics driver is to create a region in Photon s event space with the same dimensions as the physical display device and sensitivity to draw events. Any software application that emits a draw event for example output event from the area underneath the graphics driver s region will have its events intersect with the graphics driver s region and the event s data will be delivered to the graphics driver. The graphics driver uses the data from the draw event photon draw stream to render the desired graphics to the video hardware and on to the physical display device .

A Region has two attributes which control how Events are to be treated when they intersect with a Region Sensitivity and Opacity. If a Region is sensitive to a particular type of Event then the Region s owner collects a copy of any Event of that type which intersects with the Region. The sensitivity attribute neither modifies the rectangle set of an Event nor does it affect the Event s ability to continue flowing through the Event Space. Regions which are opaque to a specific Event type block portions of that type of Event s rectangle set from travelling further in the Event Space. If a Region is opaque to an Event type any Event of that type which intersects with the Region has its rectangle set adjusted to clip out the intersecting area. If the Event is entirely clipped by the intersection of an Opaque Region the draw Event will cease to exist.

The following table summarizes how a Region s attributes affect Events that intersect with that Region 

By placing a Region across the entire Event Space a process can intercept and modify any Event passing through that Region. If a Region is Sensitive and Opaque it can choose to re emit a modified version of the Event.

A special Region called the root Region is always the Region furthest away from the user . All other Regions descend in some way from the root Region . Once an Event travelling away from the user reaches the root Region it ceases to exist.

The current invention extends this concept to allow software applications to render to off screen contexts or video surfaces that do not have physical representation in Photon s event space. To achieve this an identifier provided by the graphics driver at the time the video surface was created is inserted into the draw stream that uniquely identifies that video surface. The graphics driver can then render draw requests directly into the video surface identified.

In other words a software application can launch a software process which emits an output event in the Photon event space . This output event can include an identifier which indicates which video layer the output event is to be directed to. The graphics driver responds to the existence of the identifier by generating the requested video surface including the video surface identifier in order to render into that surface.

The events containing draw streams to be targeted at specific video surfaces may be emitted directly to the graphics driver s region. In other words the draw stream targeted at a particular video surface could be given directly to the graphics driver without traveling through the Photon event space eliminating the possibility of a region blocking some or all of the draw event s rectangles.

By providing an API and supporting driver that allows software applications to query the number of available hardware layers determine what capabilities each hardware layer supports create off screen contexts video surfaces which match any restrictions imposed by the hardware layers request that a driver region be created in Photon space targeting that surface and finally associate the surface to a facet of the layering hardware and configuring the layering hardware s capabilities any software application can be given access to a layer without having to modify the software application in any way and without the software application even knowing the video hardware layers exist.

A configuring application sets up the video surfaces driver regions surface to layer associations and layer attributes. Once done any software application that is positioned under the driver regions the configuring application requested will render to the surface targeted by that driver region and subsequently to the primary display through the layering hardware.

Multiple driver regions can be put into Photon s event space by a single driver which targets video surfaces other than the one associated with the primary display. This in effect causes any software application below that region to render to the video surface the driver region is associated with without the software application knowing where the draws are ultimately going.

If such a region is targeting a video surface that is associated with a layer the draw commands from the software applications below the driver region will be rendered to the video surface and composited by the layer.

So software applications do not explicitly render to a layer they render either through Photon space to whomever catches the draws or to a specific video surface. The fact that a video surface has been associated with a layer does not effect the commands API that a software application uses when drawing.

In software application APP is drawing through Photon event space . Its draws happen to intersect with a driver region that is targeting the video surface associated with the primary display the top hardware layer on the graphics card . That is any draw events that the video driver receives from region will be rendered to surface .

Software application APP is drawing the same way that APP is but its draws intersect a driver region that is targeting or associated with video surface . This video surface is associated with another layer on the graphics card.

Software application APP draws using the same drawing API as applications APP and APP but APP has intentionally set its draw target to be video surface . The mechanism employed has APP s draw stream sent directly to the primary surface region. The draw stream has an identifier informing the collector of the event the graphics driver that the draw stream should be rendered to video surface in this case. In video surface is associated with the third layer.

Note again that the software applications are rendering to video surfaces not specifically to layers on the graphics card. Video surfaces and could just as easily have had no layer association at all. For the contents of those surfaces to be seen in that case they would have to be blitted to the layer associated with video surface .

The layer hardware on the graphics card manipulates the video surfaces and pulls them into the graphics pipeline to generate a composite display that is seen on the physical display device . The video surfaces are simply defined regions in the video memory of the video hardware as known in the art.

Draw instructions generated by the software processes of third party software applications can thus be positioned in any of these video surfaces and processed accordingly.

In the preferred embodiment of the invention the configuration of the video layers and graphic driver regions in the Photon Event Space shown in is generated by a separate software process called a configuring application . This configuring application could for example perform the steps presented in the flow chart of to set up this environment.

At step the configuring application queries the graphics driver for a particular physical display device for the number of available hardware layers. The graphics driver is dedicated to the particular graphics card but all Photon drivers that have layers support have the same interface for query and control of the layers hardware.

The configuring application then queries the graphics driver at step for the capabilities of each video layer. This information will contain such parameters as the dimensions of each video layer the number of colours dimensions resolution scale factors virtual dimension limits chroma key alpha blending capabilities and other parameters per the specific environment.

Armed with this information from the graphics driver the configuring application then generates the required number of video surfaces called off screen contexts in Photon at step and configures the corresponding layers based on the number of and capabilities of the available hardware layers at step .

The configuring application then optionally places those driver regions into the Photon Event Space at step . This step is optional because it may not be desirable to place all of the driver regions in the Photon Event Space the lack of a driver region within the photon space for a video surface prevents software applications that do not have specific intent to render to that surface from doing so inadvertently . As noted above it may be desirable to send some draw requests directly to a particular video layer without having to pass through the Photon Event Space avoiding the possibility that certain draw requests might be modified or blocked by other Regions.

It might be desirable for example to configure a layer to present alarm conditions to the user. This layer could be set up outside the Photon Event Space to guarantee that these alarm conditions will be presented to the user regardless.

At this point the system is now configured to exploit the hardware layers capabilities of the graphics card.

The configuring application can then terminate leaving the Photon system configured as above. Any third party software applications that are positioned under the graphic driver regions targeted at a video surface associated with a layer will in effect render to that layer. The third party software applications do not need any knowledge that the layers even exist so need no modifications whatsoever to render in a multi layered system.

At this point any application which renders from below a driver region which is connected to a video surface associated with a layer will be rendering into that layer and the hardware will composite the result of the rendering into the final display based on the configuration of the layer s attributes.

It should be noted that any software application which renders from below a driver region which is connected to a video surface will be rendering into that video surface. It is not necessary that the video surface also be connected to layering hardware. For example a screensaver could request a driver region be created at 1024 768 to 2047 1535 and associate that region to a video surface that it will manipulate and display at 0 0. The result would be the screensaver using content from software applications on console assuming a resolution of 1024 768 to generate its display.

The default window manager layout in the Photon event space is shown in . The display framework consists of consoles where console is one console to the right and one down from console .

Once the system has been configured draw requests can be processed in the manner presented in the flow chart of . This flow chart has been simplified to demonstrate the process flow as opposed to being representative of how the actual software code would be structured. For example a real implementation of an operating system would generally not include a no loop as shown with respect to step . Operating systems generally respond to the arrival of interrupts the issuance of function calls or the response to a periodic poll rather than sitting in a processing loop waiting for a response. However the actual software code implementation of the invention would be clear to one skilled in the art from the description of the invention in this simplistic manner.

When a draw event is received at step or similarly any request to render an image vector or character to a physical display is received control passes to step . At step the routine determines whether the draw request is flagged for a specific video hardware layer. If it is not then the draw event is sent through the Photon Event Space per step . Such events are then delivered to regions within the Photon Event Space at step . The determination of which regions a draw event will be assigned to is determined by the geometry of the source of the draw event. As noted above it may be desirable for example to send alarm displays to regions which have higher priority than video images. In fact it is necessary to be able to control to which surfaces layers draw events end up affecting in order to implement a general layered interface.

If the draw event is identified at step is to be directed to a specific video surface then it is passed directly to a graphic region without having to travel through Photon space from the emitter region. As noted above with respect to step of it may be desirable to pass some draw requests directly to a particular hardware layer thus avoiding the possibility of the draw request being blocked or modified by another Region. If the draw request is intended for the Photon Event Space then control passes to step while if the draw request is intended to go directly to a hardware layer control passes to step .

At step the entire Photon Event Space is processed as described with respect to . This results in the draw event being processed within the Photon Event Space and possibly being projected onto one or more graphic driver regions.

These graphic driver regions are associated with particular video hardware layers and accordingly are rendered onto those video hardware layers at step . If the draw event had been passed to step then it would simply be emitted directly to the driver region in Photon Event Space bypassing all intervening regions between the source of the draw and the driver region and without regard to the geometry of the draw source or the receiving driver region. The draws are then rendered to the desired hardware layer .

At step the video hardware layers are then processed by the graphics card and presented on the physical display screen. Control then returns to step to await the arrival of further draw events.

A system arranged in such a manner allows third party software applications to exploit video hardware layers support in graphics cards without even being aware that such hardware layers exist. Such a system could allow for example a television display to supports a computer display or email in a pip picture in picture window. The email feature could be a standard email application that the television displays on a separate layer to allow user configurable transparency control of the email application so as not to too badly obscure the scores during a sporting event . Similarly a stand alone mapping application could be put on one layer and automotive info trip computer info hvac settings etc could be displayed over the map with a minimum of impact on the microprocessor of the system.

While particular embodiments of the present invention have been shown and described it is clear that changes and modifications may be made to such embodiments without departing from the true scope and spirit of the invention.

The method steps of the invention may be embodiment in sets of executable machine code stored in a variety of formats such as object code or source code. Such code is described generically herein as programming code or software code for simplification. Clearly the executable machine code may be integrated with the code of other programs implemented as subroutines by external program calls or by other techniques as known in the art.

The embodiments of the invention may be executed by a computer processor or similar device programmed in the manner of method steps or may be executed by an electronic system which is provided with means for executing these steps. Microprocessors digital signal processors DSPs microcontrollers and application specific integrated circuits ASICs are typical examples of devices which are capable of such execution. Similarly electronic memory media such computer diskettes CD Roms Random Access Memory RAM Read Only Memory ROM or similar computer software storage media known in the art may be used to store the software code required to perform the methods of the invention. As well electronic signals representing these method steps may also be transmitted via a communication network.

