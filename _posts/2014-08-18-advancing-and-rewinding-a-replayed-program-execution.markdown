---

title: Advancing and rewinding a replayed program execution
abstract: In an embodiment, a data processing system comprises a storage system coupled to a unit under test comprising a heap memory, a static memory and a stack; second logic operable to perform: detecting one or more changes in a first state of the heap memory and the static memory; storing, in the storage system, as a state point of the unit under test, the one or more changes in the first state of the heap memory and the static memory; third logic operable to perform: receiving a request to change the memory under test to a particular state point; in response to the request, loading the particular state point from the storage system and applying the particular state point to the heap memory and the static memory to result in changing the heap memory and the static memory to a second state that is substantially equivalent to the first state.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09122601&OS=09122601&RS=09122601
owner: CA, Inc.
number: 09122601
owner_city: New York
owner_country: US
publication_date: 20140818
---
This application is a continuation of U.S. patent application Ser. No. 13 314 036 filed Dec. 7 2011 now U.S. Pat. No. 8 832 660 which is a continuation of U.S. patent application Ser. No. 11 943 889 filed Nov. 21 2007 now U.S. Pat. No. 8 079 019. The entire content of U.S. patent application Ser. Nos. 13 314 036 and 11 943 889 are hereby incorporated by reference. This application is related to application Ser. No. 11 449 156 filed Jun. 7 2006 now U.S. Pat. No. 7 958 497 the entire content of which is incorporated by reference as if fully set forth herein. The Applicants hereby rescind any disclaimer of claim scope in the parent application s or the prosecution history thereof and advise the USPTO that the claims in this application may be broader than any claim in the parent application s .

The present disclosure relates to debugging computer programs. The disclosure relates more specifically to storing and using state data relating to an execution path of a computer program.

The approaches described in this section could be pursued but are not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Computer software development often involves several progressive phases such as definition coding quality assurance QA and testing error removal or debugging and maintenance. In commercial software development testing and debugging often consumes considerable time and may account for the largest time component in a development project. Traditional bug fixing requires detailed communication between testers and developers. Time is often wasted going back and forth between testers and developers trying to reproduce and isolate problems. Verifying that a bug has been fixed is error prone and time consuming. Therefore software developers are continually looking for ways to reduce the amount of time spent on testing and debugging.

One approach is to outsource QA and testing to test personnel in another location even another country. However outsourcing can involve language barriers and communication barriers when a developer prepares and sends written bug reports in a local language to QA personnel in another country who speak another language. Distance barriers and complications arising from having developers and testers in different physical locations or even different time zones also can exist. Developers would like to have a software testing solution that facilitates communication in an outsourced environment.

Scheduling QA testing within the software development cycle can be difficult. Finding and fixing bugs is unpredictable at best. Delays in QA testing can lead to late releases missed market windows and lost revenue. These issues may be acute in the fast paced environment involved in developing computer games for platforms such as the PC Microsoft XBOX family Sony Playstation family Nintendo etc.

To address these issues several types of program execution recording systems have been developed. Generally program recording systems record information about a program under test as the program executes and provide reports about that information. However consistently reproducing bugs is a serious problem in software development and achieving it typically involves expending significant resources. Some systems facilitate replaying program execution on a repeated basis. Using these systems debugging is improved because bugs are reproducible by replaying a particular program execution session.

Types of program recording systems include external I O recorders source code instrumenters and binary patching systems. Generally external I O recorders create and store recordings of network I O operations user input and graphics or display 3 D D3D information. External I O recorders may be use to simulate such external input to a program. External I O recorders do not require any modifications to program code are robust in response to code and asset changes and can be used for cross platform testing and demos. However external I O recorders may not produce accurate program replays due to timing issues such as irregular network delays or race conditions. Further external I O recorders may be unusable with some platforms for security reasons. External I O recorders do not account for non determinism in programs associated with thread context switching. External I O recorders are sometimes termed macro recorders. A commercial example is Mercury Interactive s WinRunner.

Source code instrumenters usually provide proxy API libraries and modules a developer must include the libraries or modules in source code for testing purposes. Source code instrumenters are somewhat reusable can be easily expanded and tuned and recordings may be portable across platforms. However source code instrumenters are applicable only to modules for which program source code is available they cannot be used to debug programs for which only executable machine code is available. Source code instrumenters typically require the use of a specialized API for certain calls by the developer or a code parsing module. Thus the developer shoulders the burden of inserting the correct API calls in the source code of the program under test. Further source code instrumenters provide no support for third party modules such as dynamic linked libraries DLLs or linked executables because such modules will not contain the required API calls at the time of testing. Source code instrumenters may not provide 100 accurate replays due to the effect of external events that are not trapped and recorded.

Binary patching systems operate by adding specialized recording code to the binary machine code of a program under test after compilation. A commercial example is Rational Purify. Binary patching systems are highly reusable and can produce accurate recordings by capturing detailed operational data. Binary patching systems do not require source code modifications and can be applied to any executable library or DLL. When disabled binary patching systems do not affect program execution or size. Binary patching systems can capture low level program calls e.g. calls to hardware elements.

However binary patching systems can be fragile when code or assets change. A recording of a program of a first version may be incompatible for replay when the program is modified to a later version. Binary patching systems may require special support for certain APIs such as those relating to networking Binary patching systems typically require special support for different processors having different machine instruction sets and for different binary file formats e.g. PE XBE ELF . Binary patching systems do not readily produce recordings that are portable across platforms. Further cross module inlining of code e.g. using Link Time Code Generation LTCG can distort function boundaries and make patching inaccurate.

In addition known binary patching systems are not capable of recording all sources of non determinism that may exist in an application.

Prior approaches have not provided efficient or convenient approaches for skipping ahead or backward to different points in execution of a program. One prior approach involves stack walking. Another prior approach which is used for example in implementing hibernate functions of conventional personal computers involves storing a copy of all values stored in memory that is the entire contents of memory and elated state data on disk and restoring the stored values when hibernation ends. While this approach captures the entire state of a system at a particular point in time this approach is extremely inefficient because of the amount of data that needs to be stored and typically requires at least several seconds to accomplish a restore operation. Therefore this approach is not practical for use when the state of the system needs to be stored frequently and restored rapidly. Further the hibernation approach does not permit reverting or rewinding to a previous state of the system.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

In an embodiment a data processing system comprises a storage system first logic coupled to the storage system and to a unit under test comprising a heap memory a static memory and a stack and the first logic when executed is operable to interface to the heap memory and static memory second logic which when executed is operable to perform detecting one or more changes in a first state of the heap memory and the static memory storing in the storage system as a state point of the unit under test the one or more changes in the first state of the heap memory and the static memory third logic which when executed is operable to perform receiving a request to change the memory under test to a particular state point in response to the request loading the particular state point from the storage system and applying the particular state point to the heap memory and the static memory to result in changing the heap memory and the static memory to a second state that is substantially equivalent to the first state.

In one feature the second logic is operable to perform receiving a copy of the stack and to store the copy of the stack memory as part of the state point. In another feature the second logic is operable to perform storing data about one or more threads and contexts associated with the first state as part of the state point and storing data about one or more system resources associated with the first state as part of the state point.

In another feature the third logic is further operable to perform restoring one or more threads and contexts that are associated with the first state restoring one or more system resources that are associated with the first state.

In a further feature the second logic is operable to perform causing the unit under test to write protect all pages of the heap memory and the static memory installing in the unit under test a first exception handler responsive to a first write exception of the heap memory and a second exception handler responsive to a second exception of the static memory and the exception handlers are configured to respond to a particular write exception of a particular page by storing a copy of the particular page making the particular page writable and restoring execution of the unit under test comparing the copy of the particular page to the particular page creating and storing the one or more changes based on the comparing.

In yet another feature the second logic is operable to perform the comparing and the creating and storing in response to any of a timer and a programmatic call.

In still another feature the third logic is operable to perform receiving a request to change the memory under test to a particular state point and the particular state point is later than a current point of execution of the unit under test setting the unit under test to a second state point that is earlier than the particular state point by retrieving stored pages of the heap memory and the static memory associated with the second state point and copying the retrieved stored pages of the heap memory and the static memory associated with the second state point to the heap memory and the static memory of the unit under test applying all changes associated with the particular state point to the heap memory and the static memory of the unit under test.

In another feature the third logic when executed is operable to perform at a particular point in execution of the unit under test receiving data about a write exception to a particular page determining whether the storage system includes data about the write exception determining that a replay synchronization error has occurred when the storage system does not include data about the write exception and response thereto setting the unit under test to a second state point that is earlier than the particular point in execution by retrieving stored pages of the heap memory and the static memory associated with the second state point and copying the retrieved stored pages of the heap memory and the static memory associated with the second state point to the heap memory and the static memory of the unit under test applying to the heap memory and the static memory of the unit under test all changes associated with the next state point stored in the storage system after the second state point repeating the applying step until reaching another state point that is closest in time to the particular point in execution.

In another feature the second logic is operable to perform the detecting and storing for a marker state point automatically just before the unit under test executes any of a plurality of specified operations of an operating system of the unit under test. In another feature the specified operations comprise windowing operations and thread operations.

In a further feature the third logic is operable to perform fast forward replay of execution of the unit under test by performing changing the unit under test to a state represented by a particular marker point causing the unit under test to execute one of the specified operations changing the unit under test to a state represented by a next state point in the storage system.

In other embodiments the invention encompasses a computer readable storage medium encoded with instructions which when executed may cause one or more processors to perform the functions of the system described in this section and a system comprising means for performing the functions of the system described in this section and a method which may be computer implemented comprising steps corresponding to the functions of the system described in this section.

In this description the terms application program under test and binary file refer interchangeably to a user software program that executes instructions. The term operating system or system refers to the low level software program that a software application interacts with and which isolates an application from directly interfacing computer hardware in most cases. The term replay system refers to a software program that interacts with both the application and the system and acts an intermediary between the two. It has two modes record and replay. During record it captures data from nondeterministic function outputs. During replay it writes the previous data back into nondeterministic function outputs.

In step Record execution of the program under test is recorded to identify one or more bugs. For example the program under test is started and a user interacts with the program according to the normal manner of using the program. Depending on the goals of the user the user provides input or otherwise manipulates the program until a bug is found by observation of program performance. For example the program may crash provide unexpected output etc.

Recording execution of a program involves programmatically capturing and storing information identifying all sources of non determinism that may affect the program. Replay stream information is stored in persistent storage and identifies non deterministic events. Specific approaches for performing recording of non deterministic events are described further below. Test personnel can attach the stored replay stream information for a portion of a program that contains a bug results to a bug report and send the bug report to a developer.

Many mechanisms may provide non deterministic input to a program. For example some known sources of non determinism include user input programmatic timers asynchronous callbacks thread context switching direct memory access DMA timing shared memory access and interrupts. In an embodiment information identifying all the foregoing non deterministic sources is recorded and stored as a program executes and replayed in at Replay step .

A source of non determinism in the form of user input may include input from a keyboard mouse joystick or other device which varies in timing and in value across different sessions of use of a program.

Non deterministic input from programmatic timers includes any query to a system clock that a program performs. In the context of game software development for example timer queries are commonly used to support simulations of physical movement changes in on screen character position in networked games based on timer interpolation or dead reckoning etc. Further game code may operate on different execution paths depending on the amount of time that has passed between actions.

Asynchronous callbacks are considered non deterministic because it is not possible to predict when callbacks will arrive for tasks that a program has handed off to an operating system routine or to another program. For example the operating system may require a different amount of time to perform such tasks depending on network conditions resource conditions etc.

Thread context switching is non deterministic because the time at which a CPU switches from executing one thread to another is not readily predictable so that the order of operations performed by multiple threads may vary and therefore the path of execution in code may vary among execution sessions. DMA timing is non deterministic because the state of system main memory can change between successive program accesses to the memory if system hardware performs intervening DMA accesses. Shared memory access is a source of non determinism because multiple threads may set values in shared memory at different times without informing the application under test. Interrupt routines are potential sources of non determinism and therefore interrupt routines are trapped and replayed.

In step Replay execution of the program is replayed by running the program and substituting information from the stored replay stream for all non deterministic events that are associated with a recorded execution. Specific approaches for performing replay are described further below. The Replay step can be performed by a developer who has received a bug report that contains an attached replay stream recording. Thus the approaches herein enable the developer to immediately reproduce the bug by replaying the recorded replay stream.

Typically Replay at step concludes at a point in program execution at which a bug occurs. In step Debug a debugger program is started and loaded with the program binary. A user can set breakpoints in the debugger at points in the binary that may be close to code containing a bug modify machine instructions in an attempt to remove the bug etc. or otherwise use the debugger to solve problems associated with one or more bugs. Step Fix represents applying such fixes using a debugger or modifying program source code and recompiling the source code into a new binary executable file. Typically steps are also performed by a developer who has received a bug report with a stored replay stream.

In step Verify the program is executed again using the replay stream to verify that the bug does not occur or has been eliminated. Typically step is performed by test personnel after receiving communication from developers that a bug has been removed.

The approach of facilitates an efficient fast method of detecting and eliminating bugs in computer programs. Redundant cycles in the bug fix workflow are eliminated. There is no need for back and forth communication between the tester and the developer to collect additional bug information. The recorded replay stream provides all information that the developer needs to reproduce a bug found by a tester. Verifying removal of a bug is as simple as replaying the recording of the bug to verify that program operation meets expectations.

Operating system also includes one or more sources of non determinism that affect execution of an application program that the operating system supervises. In one embodiment sources of non determinism may include a network I O module file I O module multi threading module timers user input interrupts shared memory access and context switching events .

A replay system runs on operating system . The replay system is configured to programmatically capture and store information identifying all sources of non determinism that may affect the program create and store replay stream information in persistent storage and that identifies non deterministic events and to replay a program under test while supplying the replay information.

In the example of game binary is a program under test and represents a binary executable version of a game computer program. Game binary comprises game code representing machine code for a game and one or more static libraries or DLLs . Replay system is shown logically between game binary and operating system because during the Instrument step of the recording system modifies the game binary in a way that logically inserts the recording system between the game binary and the operating system. Further the Record step of during execution of game binary replay system intercepts all requests of the game code to use services of operating system such as services of modules and the recording system services all such requests instead. In the Replay step of replay system provides all information that the services of modules actually provided during the first execution and recording.

Replay system also includes replay core and wrapper functions which are described further below with respect to .

In this section 3.0 the term program binary refers to a binary file containing machine code and libraries for a computer program undergoing test debugging or other evaluation.

According to one embodiment asynchronous callbacks are recorded and replayed. Callbacks are function calls that the system may make into the application space. In conventional practice program developers are required to provide a callback handler routine in a program binary for each asynchronous callback that an operating system might send to the program binary. In such cases the application registers a callback handler with the operating system and specifies an entry the system may use. Example usages of callbacks are system events or notifications which can be nondeterministic. For example Microsoft Windows messages and user input events might generate callbacks to the application such as mouse or keyboard events.

Generally an approach for recording and replaying asynchronous callbacks involves tracking when a callback or exception is made while executing a system call. To perform such tracking the replay system first intercepts the function calls that register callback handlers. The replay system installs a proxy callback routine so that the system will notify the replay system when a callback occurs and not the application directly. This approach isolates the application from any nondeterministic interaction that can be generated from the system.

The proxy callback handlers perform asynchronous callback handling on behalf of the game callback handlers . For example system may call the proxy callback handlers with callback or exception events. The replay system intercepts such calls records callback information as needed and then calls the game callback handlers with the same callback and exception events.

The recorded information includes a sync point so that a callback can be replayed at the same point in execution that the callback occurred at the time of recording. Sync points represent an order at which a callback occurred but not necessarily the absolute time at which a callback occurred. In an embodiment integer values termed sync index values represent sync points. Index values are described further herein with respect to .

Upon re execution of the program and playback of a replay stream asynchronous callback events are queued in the proxy callback handlers for delivery to the game binary . The callback events are delivered from the queues at the appropriate recorded sync point. This approach may result in the replay system blocking delivery of events until an appropriate point during execution however the use of callback delivery queues guarantees that program replay accurately reproduces an earlier recorded execution session. The callback events are delivered from the proxy callback handlers to the game callback handlers in the game binary . Thus during replay simulated callback events are delivered to the game binary at specific recorded points. This approach can be applied to message callbacks sound system callbacks or any other asynchronous input output.

As an application makes a system function call the replay system monitors whether the system makes a callback or multiple callbacks during the function call. The replay system records all nondeterministic data that is passed in during each callback to the application. After the data is recorded the replay system allows the original callback to be received by the application through the original registered callback handler. This approach allows the application to receive the callbacks as it would do normally without replay.

In step an operating system executes a system call. At step the replay system checks system callback handlers to determine if one or more callbacks occurred. If a callback did not occur as tested at step then control returns to the replay system for other processing at step .

If a callback occurred and the replay system is in record mode as tested at step then in step all callback information is recorded in a replay stream. If the replay system is not in record mode then the replay system is in replay mode and in step the process tests whether the callback is a recorded callback. If so then in step the replay system allows the callback to pass through to the application. If not then at step the replay system generates the missing callback and delivers associated output to the application.

As indicated in during replay proxy callbacks are substituted. However the replay system blocks all callbacks from the system that do not occur at the same time that they occurred during recording. Only callbacks that exactly match the recording are allowed to pass through to the application. For callbacks that do not occur at the same time the replay system simulates a callback using the recorded non deterministic. This approach allows the application to receive the exact same callbacks as when recorded.

Notably replay system can determine whether an asynchronous callback from the system has occurred only when the application calls a non deterministic system API call such that the replay system acquires control of execution and can make the appropriate decision. When the application is executing instructions other than non deterministic system calls the replay system does not affect application execution.

Exceptions are another form of flow control that an operating system may send to an application when a function call is made. Exceptions can be nondeterministic. According to an embodiment replay system processes exceptions in a similar manner as callbacks. In one embodiment replay system installs an exception handler for each application function that the replay system intercepts and that makes a function call into the operating system. The exception handler monitors whether an exception is thrown. In record mode any exception is recorded and multiple exceptions may be recorded. Once the nondeterministic data is recorded which often includes all the exception information the exception is passed on to allow the application to handle the exception normally.

At step a test is performed to determine if the replay system is in record mode. If so then at step a test is performed to determine if an exception occurred during execution of the system call at step . If not then control returns at step . If an exception occurred then all exception information is recorded in the replay stream at step and control returns at step .

If the replay system is in replay mode then control passes from step to step in which a test is performed to determine if an exception occurred during execution of the system call at step . If the exception occurred during replay but was not recorded as tested at step then in step the missing exception is generated and delivered to the application.

If an exception did occur at step and if the one or more exceptions have been recorded as tested at step then in step the replay system allows the exceptions to pass through to the application. If an exception occurred at step but no exception is recorded at that point as tested at step then in step the replay system filters out the extraneous exception and does not pass the exception through.

Thus during replay the replay system monitors if the same exact exception is thrown during a function call. If an exception is not thrown then the replay system can generate a simulated exception using the recorded data from earlier. If an exception is thrown during replay when an exception did not occur on record the extraneous exception is filtered out and not allowed to pass to the application. Using these techniques the application will receive the same exception behavior as it did on record.

In one embodiment some data that the replay system must generate during replay originally contained contextual data during record that was relevant to the application when it was recorded but will be out of context during replay. For example exception information may contain memory addresses or window handles that will be different during replay. For these cases replay system substitutes the original data that was contextual with data that is relevant to the application during replay. To perform such substitution replay system maps certain memory addresses window handles and pointers to other data from what they were during record to what they are during replay. For example during record an application may create a window and the operating system assigns the window a window handle of value 0x5. However during replay when the application creates the window the OS may assign a window handle of value 0x8. Therefore replay system stores the values and changes 0x5 to 0x8 when appropriate during replay.

According to one embodiment thread context switches occurring during program execution are recorded and replayed. In this description thread context switch refers to an operation of a data processor when the processor changes attention from one executing program thread to another thread. The order of thread context switching can be important for example when data is exchanged between threads. In one embodiment only thread context switches associated with data exchanges are recorded and replayed. This constraint has been found appropriate because recording all thread context switches would consume an impractical amount of memory.

One embodiment involves identifying methods that are called to share data between threads and recording only information about the called methods and the sync point at which such calls occurred. Methods that are called to exchange data between threads are termed thread sync points herein. Thread sync points have been found to occur only when an application calls an operating system function that performs resource locking. Thus examples of thread sync points include methods that result in an operating system locking certain resources such as Lock TryLock and Release methods methods associated with waiting on or signaling program events such as Event Wait EventSignal WaitForMultipleEvents WaitForSingleObject and methods that signal entering or exiting critical sections of executable code such as EnterCriticalSection and LeaveCriticalSection.

Recording such method calls and associated thread sync points ensures that such methods are called in the same order upon replay. Therefore an embodiment can ensure that a program binary processes data in the same way upon replay as the data was processed at the time of recording. In particular the program binary has access to the same resource at the same sequence point and therefore in the same resource state at replay as upon recording.

The second thread issues a resource request and obtains a lock or control of resource at a first sync point which replay system records. First thread then issues a resource request to acquire a lock for the same resource. Although resource request may require a processor to switch context from second thread to first thread any such switch is necessarily temporary because the processor cannot give control of the resource to the first thread when the second thread is holding control. The processor places the first thread in a queue identifying threads that want the resource. Therefore replay system does not record a context switch at the time of request .

Second thread then issues a resource release for the shared resource allowing the processor to dequeue first thread and give the first thread control. Therefore replay system records a second sync point reflecting a change in control of the resource . Second thread later issues a resource request for the resource but the processor cannot grant control of the resource to the second thread. Therefore recording system does not record a context switch at that point.

First thread issues a resource release and in response the replay system records a context switch at a third sync point because second thread gains control of the resource. Second thread issues a resource release at a fourth sync point which is recorded.

In one embodiment during replay the replay system monitors application execution and intercepts each application call to an operating system function that involves resource locking or release. is a flow diagram of a method of processing program calls that relate to thread context switching. In step a program binary attempts to execute a resource locking or other call at a sync point. Replay system intercepts the call. If recording is occurring as tested at step then in step the current sync point is recorded and at step the replay system makes the operating system API call on behalf of the program binary. If recording is not occurring then control transfers to step which tests whether the next sync point that occurred during recording has arrived. If the next sync point has arrived then in step the OS API call is made. If not then in step a loop is entered that blocks the current thread while allowing other threads to execute until the next recorded sync point occurs.

Thus replay system determines the then current sync point at which such a call occurred and compares the current sync point to a replay sync point for the next call represented in the recorded replay stream data. If a match occurs then the replay system allows the call to pass through to the operating system. If no match occurs replay system blocks the call and enqueues the call in a waiting queue until the correct sync point arrives. A call is allowed to proceed only at the correct sequence point. This approach ensures that a particular thread only receives a lock on a resource at the same order in execution on replay that the thread received the lock when execution was recorded.

Notably replay system can determine whether a resource lock or release should occur only when the application calls a non deterministic system API call such that the replay system acquires control of execution and can make the appropriate decision. When the application is executing instructions other than non deterministic system calls the replay system does not affect application execution.

Thus the approach herein focuses on recording a sequence of resource locks that occur for a shared resource rather than the particular time at which locks and releases occurred. By recording information about lock methods and releases and the sequential sync points at which locks and releases occurred replay system can accurately replay the order of program execution.

According to one embodiment accesses of application processes to shared memory are monitored using a recording system API. Thus developers who are preparing source code of programs under test include calls to an API associated with replay system whenever access to shared memory is needed. Adding the API calls to program source enables replay system to monitor shared memory accesses at runtime when a program binary based on the program source is compiled and run.

In one embodiment replay system includes mechanisms for accurately replicating the contents of main memory of a hardware system on which the program binary runs when execution is recorded and replayed. Accurate memory replication provides accurate reproduction of memory leaks for example if memory leaks exist as a result of program operation. Accessing un initialized memory may result in very non deterministic behavior from an application. The application may crash or make logic decisions based on bad data. Reproducing this behavior is difficult because the state of un initialized memory is non deterministic. Further in the context of developing game systems accurate memory replication enables replay system to reproduce any code that has data sorted by pointers. Typically in game systems a game engine s main loop involves iterating over game objects that are sorted by their memory address.

In an embodiment replay system establishes a private controlled memory heap that is used to satisfy all requests for memory allocation that the program binary issues. Replay system intercepts all memory requests that the program binary issues to the operating system and redirects such requests to the private memory heap. Examples of memory request operations include HeapAlloc VirtualAlloc etc. The foregoing approach isolates memory requests and prevents non deterministic system calls from making memory allocations under the hood or without informing the program binary.

Further in an embodiment replay system tracks all memory allocation requests that an operating system or hardware platform requests a program binary to issue during execution. For example in the context of game development certain game console systems may request a program binary to provide and manage memory. A specific example is the XMemAlloc call on the Microsoft XBOX platform. Replay system records information identifying all such requests as part of a replay stream and upon replay the recording system simulates such requests. The requests are satisfied using a dummy memory heap but processing such requests insures that the game heap is preserved.

In one embodiment replay system implements mechanisms providing efficient storage of replay data representing an execution session of a program binary. According to a first mechanism only non deterministic function calls are recorded. Most function calls that a program binary issues are deterministic in nature and there is no need to record them because issuing the same calls at replay time necessarily causes the same result in program output or state change.

According to another mechanism program binaries that issue a rapid succession of clock sampling calls are subject to sample throttling upon recording. In sample throttling replay system records only a specified maximum number of clock sampling calls within a particular time interval rather than the actual number of such calls that the application issues. This approach appropriately reduces the number of clock sampling calls in a replay recording based on the recognition that there is often no need for a program binary to access a time value more than a few times per second or in the context of game development each time the video buffer is drawn to the screen e.g. each frame . Additionally or alternatively sample throttling is activated only in response to specified user input or in response to a configuration command. Therefore for certain purposes sample throttling can be turned off High performance profiling is an example application in which turning off sample throttling may be beneficial.

As another efficiency mechanism in an embodiment replay system buffers replay data as the data recorded using a replay data buffer and flushes the replay data buffer to persistent storage only when necessary. Replay data buffer is maintained in main memory of the platform that is running the program binary and persistent storage is any non volatile storage media such as disk flash memory etc.

In one embodiment replay system buffers replay data in replay data buffer and flushes the replay data buffer to persistent storage in response to expiration of a periodic timer or in response to a critical event. For example exceptions or an exit of the program binary may trigger flushing replay data to persistent storage. In an embodiment the instrumentation step of involves installing one or more exception handlers or filters of replay system that intercept exceptions and exit events into the program binary. Thus when a program crash bug or other exception arises replay system is notified and can respond by flushing the contents of a replay data buffer to disk. This approach ensures that replay data is stored when the replay system is used to test an unstable application.

A replay system that implements such efficiency approaches has been found to generate replay data of about 300 kilobytes per minute of program binary execution for a game program. Network based game programs with simultaneous players may generate more storage. The amount of replay data generated and stored may vary from program to program.

Because replay data is generated efficiently and the resulting replay data files are small after recording replay data may be stored using a document control system or code control system that requires checking data in and out as a control measure replay data can be stored in such a system with a bug report for the purpose of communicating bugs among developers and quality assurance personnel.

The approaches herein recognize that a recording of program execution is associated with a hardware configuration of a platform that is running a program under test and that replaying the recording on different hardware may cause inaccurate replay or errors. For example a recording that includes non deterministic input from a particular hardware device may be non reproducible when a user attempts to play back the recording on another system that does not have that hardware device. Therefore the approaches herein provide a way to account for hardware configuration differences when a recording is replayed on a different machine. The approaches herein also provide ways for synchronizing information describing hardware assets and source code versions in a dynamic ongoing development environment.

In step proxy functions are created in the replay system . Each of the proxy functions is associated with a program method that accesses or queries a particular specialized hardware feature not found in the baseline platform. For example one proxy function might intercept program accesses to a graphics processing unit or to a sound processor that is not part of the baseline configuration.

Upon playback the proxy function supplies a graceful response to a query to that hardware feature. Thus in step when a recording is replayed the program under test is forced to use the baseline hardware configuration that was established in step by interacting with the proxy functions rather than the actual hardware elements that are not available in the baseline hardware configuration. Therefore a program execution session that was recorded on one machine can be replayed on another different machine having a different hardware configuration.

In an embodiment step is optional and is activated in response to a user activating a specified configuration option.

In another embodiment when a program execution session is recorded the recording is stored with information identifying changeable assets that the session accessed and version information for the program and for the assets. Examples of changeable assets include data files configuration files graphics files sound files and other elements that a user or program could modify independent of modifying the program binary.

In an embodiment the instrumentation step of installs one or more file I O proxy functions that intercept and record accesses to the file assets record what file was accessed record a version value associated with the file etc. Using this approach a complete audit trail is maintained of changeable assets that were used in generating a particular recording.

When the same recording is replayed later the changeable assets or code are loaded into memory so that they are available for interaction with the program execution session as it is replayed. If a particular asset is not available not the same version or otherwise changed at the time of replay as compared to the state of the asset at recording then replay system issues a warning message or throws an error so that the user is informed that replay execution may not accurately reproduce the same execution session as at recording. In an embodiment an asset that was accessed from local disk at the time of recording can be accessed from a network location at replay time.

The preceding approach may be implemented using a storage and retrieval module that is integrated into or accessible to replay system . Information about accessed assets may be stored on a local machine local network storage remote storage etc.

In an alternative embodiment a copy of the actual changeable assets is recorded in association with a replay data stream. However this alternative requires considerably more storage. This alternative may be implemented by receiving user input specifying an execution option for replay system such as in a configuration file with which a user may specify one or more content files or other assets that are actually recorded as part of the replay data stream.

In an embodiment upon replay any program execution function that does not affect the internal state of a program binary can be skipped for example in response to user input requesting a skip function or in response to selection of a particular user input device. Examples of program execution functions that do not affect state include any function that provides only output. In the context of a program binary that provides a game the operation of video screen drawing functions can be skipped. Thus a user can elect to skip program execution that only involves drawing a complicated video image or series of images. This may enable the user to save a substantial amount of time in replaying a long execution recording.

In an embodiment a user can skip ahead to a particular point in an execution session by providing user input indicating a request to skip ahead. For example in one embodiment replay system periodically stores state point data representing values of all program state values at a particular instant in time and all system state values at the same instant. The state point data essentially represents a snapshot of application state at a particular point in time and is stored in the replay data stream with information indicating the sync point or time associated with the state. State information may be stored as part of a replay stream or independently. In an embodiment such periodic storage of state points occurs at regular specified intervals in a recording session e.g. every five 5 seconds. Any specified interval period may be used.

In one embodiment the state point data is created and stored after a complete application execution session has been recorded and replay stream data has been stored. Thus replay system may replay scan or review an existing set of replay stream data and create and store state point data based on determining how values change upon replay. This approach has the advantage of not interrupting application recording to perform the time consuming step of creating and storing the state point data. Alternatively replay system can create and store state point data during recording a program execution session.

Thereafter at the time of replaying a recording a user can provide user input indicating a request to skip to the next state point. In response replay system determines which state point is next loads all state values for the program binary and the hardware system sets the state values in the program binary and hardware system under test and commences continued program execution. In a game system the user experiences a sudden jump ahead in program execution and the appearance of the video display.

Functions for capturing application state and moving to a particular application sync point or time may be implemented an API that an application can access. State point data may be stored in a replay state file comprising a plurality of type value pairs that represent program or system variable types and associated values.

When an application initiates operation the state of main memory is often unknown. For example unless the application or an operating system implements some form of memory initialization that sets all memory locations to a particular value the application cannot assume that memory contains any particular value. According to an embodiment replay system can replay data values that are accessed from memory having an unknown state at program startup.

Generally an application must request an allocation of memory that it needs to read or write from a system kernel that implements protected memory. The amount of memory may be large spanning gigabytes or beyond terabytes. Therefore recording the contents of such data as the contents existed at the time of an application execution session is impractical. In an embodiment replay system intercepts all such requests. Each time a new address space is first requested the replay system initializes values in the address space to deterministic values using pseudo random value generation before allowing the application access to the memory. Later upon playback before responding to an address space request the replay system initializes the requested memory with the same values.

In another embodiment replay system can simulate a startup system state in which memory contains random non initialized data. Such simulation is useful to prevent the replay system from introducing changes in system condition that could affect program execution or performance. Thus such simulation prevents the replay system from masking problems that may exist when the replay system is not installed or used. Further the amount of data required to generate the same memory pattern is small so that recorded replay stream files remain small. Having to record a gigabyte of data from non initialized memory to replay a requested gigabyte of data is not considered practical in many cases.

According to an embodiment replay system uses a random seed value and pseudo random function at step of to generate an unlimited amount of reproducible simulated memory values. Common program values such as all unset and set on integer values are simulated in this approach and other random values may be simulated. For example a 32 bit random seed may be generated and recorded as part of the replay stream file. At replay time the recorded random seed value is retrieved and fed as input to a deterministic pseudo random function.

The function may be used to generate gigabytes of pseudo random data that is consistently reproducible whenever the replay stream file is replayed. Because the pseudo random function is deterministic the output data is consistent from record to replay. Further the output data also provides a good approximation of a set of non initialized data. Moreover the recorded replay stream file needs to contain only the seed value not the entire set of generated data as a result the technique herein is highly efficient in terms of storage.

In one embodiment the pseudo random number generator as defined in a standard operating system library is used to select a random sequence of values that are weighted appropriately.

In another embodiment each address value is initialized only once. If an application requests the same address value and then later frees and requests it again the replay system does not have to reinitialize the address value since the application will have left the address in a deterministic state.

In one approach two variables in the replay system track the lowest and highest address values that the application has requested. Each time the application issues a request that is less than the lowest value or greater than the highest value the variables are updated accordingly. When a memory request is made for an address that lies completely inside the two variables no new initialization is needed and the replay system performs no further interaction with the requested memory.

In an embodiment index elements A B C etc. and flush marker elements are fixed size. Each of the data elements A B C etc. is variable in size. Each of the index elements A B C relates to the sequence of nondeterministic data that is recorded in the stream. Each data element A B C has a unique index A B C associated with it. Index elements A B C typically are sequenced and carry values that increment by one linearly for each data element A B C that is recorded. The index elements A B C are used during replay mode for verification that an application is executing in the same fashion as it did during Record mode.

Each data element A B C relates to a nondeterministic event that occurred during recording. During record mode data in a data element is collected and written to the replay data stream with an index value. During replay mode a data element is read from the replay data stream and the data element provides the output of a nondeterministic event back to an application. The flush marker element indicates a point at which information was written to the replay data stream . The flush marker element is used for verification that program execution is the same during replay mode as it was during record mode.

Generally applying instrumentation code to a program binary involves changing instructions in the program binary by moving the instructions or redirecting certain instructions to other locations. Some instrumentation may involve modifying relocation tables or segment headers. Instructions are disassembled and instructions associated with non deterministic input or events are recognized and modified.

Techniques for replacing assembly instructions in place within an application are now described. In general replacing assembly instructions as party instrumentation involves how to replace a specific binary instruction while preserving the position and order of all the code surrounding the replaced instruction.

Binary files prepared for different hardware and software platforms may conform to different binary file formats. The description herein assumes that the file format of a particular binary file is known and that a developer has available a software tool that locates and identifies the sections in the binary that contain executable code rather than data. When the executable code has been identified two passes can be used to introduce redirections in the code that are used as part of the replay system.

Step to step inclusive represent a first pass that iterates over each assembly instruction looking for instructions that jump into different areas of other code. On a binary file containing instructions conforming to the Intel x86 instruction set pertinent jump instructions include unconditional jumps and conditional jumps. Each address that is jumped to is stored in a lookup map which will be used later during a second pass.

In step assembly instructions are scanned. In step the process identifies instructions that jump elsewhere in the code such as conditional or unconditional jumps. In step each address that is jumped to is stored in a lookup table for later use. In step the process repeats steps for all other assembly instructions that are found in the binary file.

Step to step inclusive represent a second pass over the binary file. In step each assembly instruction in the binary file is scanned. In step the process locates an instruction that needs redirection instructions that do not need redirection are skipped. In one embodiment instructions that have nondeterministic outputs are selected for redirection into the replay system so that the replay system can record the outputs in record mode and set the outputs in replay mode. As a specific example the RDTSC instruction on the x86 processor sets the EAX and EDX registers to nondeterministic values. The replay system can record the values of the EAX and EDX registers and replay the values of the registers when appropriate.

In step the process locates an atomic block of instructions that the replay system can replay with two jump instructions. In this context an atomic block of instructions is a linear set of instructions that are always executed together in the same order. No other instructions jump into the middle of atomic block or jump out of an atomic block. An atomic block can be moved to a different address space without causing execution problems or side effects that may change the nature of the program. When looking for a candidate atomic block the jump lookup table that was constructed in the first pass e.g. step is used to ensure that no other instructions are jumping into the atomic block.

In step the atomic block is moved to a new location so that redirection code can be substituted in the binary file at the original location of the atomic block. In an embodiment an atomic block must be reachable by a small jump statement having a size equal to or less than the size of the instruction that needs to be replaced and redirected.

For example if the instruction to be replaced and redirected is a two byte instruction then that instruction can be moved a maximum of 128 bytes forward or backwards in the code. In that case at step the process scans the code in both directions and finds the first available atomic block that is reachable and large enough to hold two large jump statements. Two large jump statements are needed to jump into a proxy space associated with the redirection system because the proxy space may be much further away in the instruction space than 128 bytes. A small jump instruction cannot be used since there might not be enough room to add proxy code.

At step additional jump instructions are introduced into the code as needed to reach new code in a proxy space and to reach the atomic block that was moved at step . At step new code is added in the proxy space to redirect non deterministic functions or output to the replay system.

The new code at location ends at a jump instruction of location that jumps to instruction P3. Instructions P1 and P3 have been inserted in space formerly occupied by atomic block which has been relocated to location . Thus when the proxy space code is executed control transfers to a location after the original position of the replaced instruction. This approach allows the replay system to execute the new replaced instructions.

When location is reached instructions Instr 5 Instr 6 Instr 7 of the atomic block are executed. The atomic block terminates at a new jump instruction that transfers control back to the end of the original code at location . Execution continues at that point. This approach preserves the original instructions that were displaced from the atomic block. Atomic blocks of instructions may be moved to a different location and new instructions are inserted to be executed in place of the atomic blocks. The foregoing approach can redirect any instruction of any length which is important for processor instruction sets that include variable length instructions. Further the approach can configure the code to execute any amount of new code upon redirection to the proxy space. The foregoing approach also maintains the integrity of all original instructions of an application.

At step the process adds core replay code and wrapper functions to the binary file. The core replay code and wrapper functions implement record and replay functions of the replay system.

Replay proxy space includes instructions such as the instructions of locations of that save processor register states call wrapper functions in the replay core and restore register states. As described above for an instrumentation process modifies an application binary file to redirect all nondeterministic calls and instructions first into the appended proxy space . The proxy space is used to preserve any state that is specific to the calling code. Such state may consist of registers that must be saved. The proxy call then makes a call into the corresponding function wrapper inside the replay core .

Wrapper functions in replay core call system functions on behalf of an application. When the replay system is operating in record mode replay wrapper functions record all non deterministic output of the application. Thus in record mode the wrapper functions are responsible for recording any nondeterministic data that will be returned by the function inside a replay stream. Further the wrapper functions implement proxy code for each non deterministic system method or call that an application may use.

In replay mode wrapper functions replay non deterministic output. Wrapper functions also handle asynchronous data updates and return replayed information to instructions in the proxy space that called the wrapper functions. Thus in replay mode the wrapper functions are responsible for writing the same data that was recorded into the output data. The wrapper functions then returns control to the proxy space which restores any state that was saved before entering the wrapper functions. In many cases the proxy call may be skipped and the function call can be redirected directly into a wrapper function residing in the replay core . This approach is appropriate if no state needs to be preserved or restored based on the nature of the call.

The replay core also implements miscellaneous functions to support the function wrappers. For example code in replay core creates and prepares a permanent storage area to save the replay data. In an embodiment the storage area is accessed using a streaming mechanism. When the storage area is ready the replay core moves nondeterministic data that is recorded from the function wrappers and writes the data to the streams. The streams may interact with a file system on a hard disk or other medium or interface with a remote network server on a LAN WAN or the Internet. Replay core also implements callback managers and other logic to support recording and replaying asynchronous function calls using the approaches described above. Replay core also implements logic for performing thread context switching interrupt trapping and other recording and replay functions previously described.

Replay core also implements state recording functions that store type value pairs for program variables or system variables that represent program state or system state in association with sync point values representing the time at which a state change occurred. State values are stored only when a state change occurs rather than all state values associated with all method calls of an application. In effect this approach imposes a throttling effect that reduces the amount of stored data associated with capturing repeated application calls to functions that do not result in any state change.

In replay mode replay core is configured to open a specified replay data storage file and then read in the requested nondeterministic data from the stream for the function wrapper. The replay core also is responsible for checking that the application binary is compatible with the selected replay stream.

In an embodiment the replay system is implemented in a set of program and data files that a developer uses to develop test or debug applications. In one particular embodiment described in this section the replay system is used to develop game applications. This section describes an example installation and user interface mechanism for using an implementation of the replay system with the Microsoft XBOX platform other embodiments may be implemented installed and used in a different manner for different platforms. Thus this section merely presents one example and is not intended to limit the scope of all possible embodiments.

A set of distribution files comprising replay system is normally placed in a build tree with other third party tools or APIs that a developer may be using with an XBOX title. For example the replay system distribution may be stored in a folder named C MyTitle 3rdParty Replay. A user extracts or installs distribution files of replay system to this directory. The user may add the Lib directory to a lib path and the Include directory to the include path so that the user s compiler can find replay system libraries and include files. Alternatively the user can use full paths when referencing the libraries and header files.

To record and playback sessions it is necessary to install replay system on a game title that is under development. In an embodiment installation comprises adding binary instrumentation to an executable of the game title so that no source code changes are required. In an embodiment installation comprises disassembling the binary executables such as EXE and DLL files identifying the points in the binary files that require patching and making small modifications to the binary files to alter the code in order to allow the instrumentation to capture record and ultimately replay data.

In one embodiment the ReplayInstrumenter program of the replay system provides user options for modifying its operation. Generally ReplayInstrumenter can be run from any directory. The command syntax is ReplayInstrumenter out platform force . The ReplayInstrumenter has the command line options shown in Table 1B 

The ReplayInstrumenter must be able to locate the PDB file associated with the target EXE. If the ReplayInstrumenter cannot locate the PDB file it will display an error indicating where the PDB file should be. Therefore developers should put the PDB file in the directory indicated by the error message and run the instrumenter again.

By default replay system records whenever a developer runs a title. Everything is recorded as the game is played and written to the utility drive. A developer can disable auto recording by modifying the default record setting in replay xbox.ini . If the default recording option is OFF set to 0 a user can start a recording session by holding down both triggers and pressing the BLACK button on the controller. This will reboot the XBOX and run the title in recording mode.

Data relating to a session is placed in the ReplaySessions directory located on the Utility Drive. For example Z ReplaySessions 

Replay system saves the last five sessions for each application that is recorded in this directory. Each session is placed in its own directory named 1 through 5 . The most recent session is under a directory named 1 . For example Z ReplaySessions 1

As each new session is recorded the session number is incremented. 1 will become 2 2 will become 3 etc. The oldest session usually 5 will be removed.

To replay a recorded session from the XBOX the user presses both triggers down while pressing the BACK button. This will replay the most recently recorded session. To replay a recorded session from a debugger e.g. MSVC the title is run with the replay command line option. This will replay the most recently recorded session from the debugger. To replay a specific session the path to the session is specified on the command line with the replaySession option. For example myTitle.xbe replaySession Z ReplaySessions 4

While in replay mode the replay can be controlled using the XBOX controller with the controls shown in Table 2 

A user may perform debugging during replay. The replay system does not affect the ability to step through source code in any way. The user can set breakpoints inspect data and perform any normal debugging functions. Using Visual Studio the PDB files are valid with replay system installed on the application. At any point during the replaying of a session a user can attach a debugger such as Visual Studio and step through the source code associated with the application.

A user can save a session by copying or moving the session data from the Z ReplaySessions directory. The directories listed herein e.g. Z ReplaySessions 1 each contain a replay session.

Replay sessions can be replayed from the command line or the debugger using the following command line parameters. To replay the most recent recorded session xbreboot replay

To play any recording on the XBOX utility drive specify it as xbreboot xe myTitle myTitle.xbe replaySession Z ReplaySessions 4

The approaches herein provide numerous benefits to users. Bugs may be corrected far more rapidly than in prior approaches. The approaches herein also facilitate communicating bugs from one unit of an enterprise to another such as from a QA team to a development team. One unit can transmit using e mail for example a copy of a replay stream to another unit for replay at that other unit s location.

In step the developer reproduces the bug by replaying the recorded replay stream. Step presumes that the developer also runs the replay system to produce an instrumented application binary file that is equivalent to an instrumented binary file that the tester used when the bug was found at step . However by playing the replay stream received with the bug report the developer can reproduce the bug immediately without having to manipulate the application in a special way or provide particular input.

At step the developer fixes the bug resulting in creating fixed application code. The developer verifies that the bug is fixed by replaying the recorded replay stream using the fixed code. The developer also may communicate a copy of the fixed application code to the QA manager or tester.

At step the tester verifies that the bug is fixed by replaying the previously recorded replay stream using the fixed code. If the bug is fixed then replaying the recorded replay stream does not produce the bug. At step the QA manager closes the bug report.

The approaches herein enable performing memory and performance profiling. Because the approaches provide a consistently reproducible run through of a program the program can be tested on different platforms that may affect performance and the approaches help isolate non deterministic events or platform components that affect performance. For example developers can repeatedly replay the same execution session while modifying application methods functions or parameters and can observe the effect of such changes.

The approaches herein can be used to create foolproof demonstrations of computer programs. A user can record a demonstration session with a program at one point in time and replay the demo later with assurance that the integrity of the demo cannot be affected by variances in input or by human error in running the demo.

The recording system provided herein has little performance impact on a program under test when the program is executing. Performance impact is important for example for development of game programs in which a large amount of video information is generated and smooth fast refreshing of the video display is essential for a good user experience. An embodiment has been found to result in no noticeable drop in the output frame rate of a typical game program.

No change in the software development workflow process is required for example developers do not need to use APIs in developing source code of applications.

Memory usage of embodiments is low. For example an embodiment implemented on the Microsoft Xbox has been measured to require about 500K to 700K of main memory for execution. Data output of embodiments is also relatively small. For example an embodiment has been found to generate about 1 MB of replay stream data per minute of program execution. The small efficiently generated replay stream data files associated with embodiments enable users to conveniently transport replay stream data files to others.

Computer programs are increasingly developed for use on computer hardware platforms that use multiple processors or processors with multiple cores. Examples include computer game platforms such as PCs XBox360 and PS3. In these systems and other systems certain memory write operations may represent non deterministic state changes that can be recorded and replayed to provide an accurate picture of program execution behavior. Certain memory write operations also may be associated with programmatic race conditions in which two or more program execution threads access the same memory location at close to the same time and one or more of the threads is writing the location.

Accurately replaying a recording of execution of an application program involves ensuring that the application execution path is preserved upon replay precisely and with few exceptions. Detecting the source of an execution path that diverges upon replay from a path followed upon recording can be tedious and time consuming. There may be thousands of sources of such divergence and the application program may be embedded in a host system such that source code is not available.

In one approach detecting divergence includes observing the application program making different application function calls or system calls at the time of recording and the time of replay. When a divergence point is identified a long manual process is typically used to locate the condition s that caused a different execution path. However these conditions may have occurred millions of instructions earlier in execution and tracing the divergence path backward to the original location may take an insurmountable amount of backward detection or simulation.

Alternatively the source of divergence is identified at the earliest possible point by detecting when any state of the application program becomes different. Only different state can cause an application program to execute differently upon replay and recording. Therefore identifying an initial state difference is an efficient means of detecting divergence because divergence is detected at the source rather than observing the after effects of divergence. The state of all application memory is a part of application state.

In an embodiment these issues are addressed by a replay write exception process that can detect memory write operations that cause state changes and can assist in identifying race conditions that may be indicated by memory operations of multiple threads occurring close in time.

In step an exception handler for processor memory operations is created. The exception handler is installed at step . At some point thereafter an application program under development test debugging or other observation executes and program execution is recorded at step using the techniques described herein in sections and .

At step a portion of main memory of the computer platform that is under development test debugging or other observation is set to read only access. One technique for setting memory to read only access is provided in .

At step a processor executing an application program attempts a memory write operation. The effect of setting memory to read only access is that when an application program attempts to perform a write operation on the memory the computer platform throws a hardware exception at step that invokes the exception handler that was installed at step . In various embodiments the approaches of can be used to implement an exception handler and perform state synchronization or race condition detection operations. At step the exception handler returns control. Control transfers to step at which continued program execution recording occurs at step .

At step the operating system is requested to perform a memory allocation operation. The memory allocation operation specifies a requested size or amount of memory to be allocated. For example an allocation operation could request 1 MB of memory. In an embodiment recording system executes a memory allocation instruction on processor on behalf of the application program. The processor performs the memory allocation instruction and allocates memory returning a starting address and a size of the memory that was allocated. Thus in step a start address and size of allocated memory is received.

In step the operating system is requested to set the allocated memory to read only access. In an embodiment recording system invokes functions of operating system that set permissions on the allocated memory to read only access. In step the process returns control to a calling process. Step may include returning the start address and size of memory that was allocated. Thus in an embodiment the allocated addresses received at step are returned to the application program so that memory allocation instruction originally attempted by the application program appears to have been performed normally.

In an alternative approach to upon startup recording system scans all virtual address space that is available to the application program on computer system . Scanning the virtual address space may be performed using virtual query methods such as the method VirtualQuery under Microsoft Windows. For each virtual memory segment that is associated with a code module the virtual pages are made read only so that writing the pages will generate an exception.

In the alternative approach after startup system calls of the application to load in new code segments and static memory are intercepted. When a new module is loaded into application virtual memory recording system scans each virtual segment and sets the virtual protection permissions to read only.

The general approach described above can be applied to ensure that memory state upon replaying the execution of an application program is synchronized to the memory state that existed when execution of the application program was recorded. is a flow diagram of an example exception handler process for use in state synchronization. and are flow diagrams of an example state synchronization process as performed when recording execution of an application program.

In an embodiment for performing state synchronization the general approach of is used and at step the exception handler of is invoked. Thus in one embodiment an application program such as game binary executes on computer system and recording system monitors execution and records information about the execution in persistent store . When the application program attempts a memory allocation operation recording system uses the process of to set the allocated memory to read only access. When the application program attempts to write the allocated memory processor or OS throws an exception and the exception handler of is invoked.

Referring now to in step the exception handler process receives an exception type and address of memory subject to an attempted write operation. The exception type enables the exception handler to filter out other exceptions that are unrelated to attempted memory write operations. The address indicates what memory location the application program attempted to access.

In step a memory page that contains the address is located. In an embodiment to facilitate efficient memory read and copy operations under typical processor instruction sets and computer system architectures the process operates on memory pages rather than individual addresses. A typical page size is 4 kilobytes. However alternate embodiments may use individual addresses or memory blocks or segments other than pages when an instruction set or architecture supports reading and writing memory other than pages.

In step a copy of the located memory page is stored in a queue of pages. Thus before an attempted memory write operation is allowed to be performed the state of a page that will be affected by the write operation is saved. Saving the page before the write operation facilitates later evaluation to determine whether the write operation resulted in a non deterministic state change during program execution. The page may be saved in a queue list or any other form of organized data storage. The queue may be referenced as a queue of pages that are known to be altered or dirty following the save operation and the write operation. As an alternative to storing a copy of the page step may store a representation of the page or an identifier for the page. Examples of a representation or identifier include a checksum hash message authentication code or other unique identifier.

In step the affected memory page is reset to read write access so that the requested write operation can be performed without causing another exception. In an embodiment recording system invokes a function of OS to reset the page to read write access. In step the memory write operation is executed and in step control returns to the calling process.

In an embodiment once a block of memory is allocated and pages are stored in the foregoing manner multiple write operations are allowed on the allocated memory.

Once a set of saved pages is created other processes may be used during recording and replaying an application program to synchronize the state of memory when the program is replayed to match the state of memory that existed upon recording. In an embodiment state synchronization processing is performed before and after system callbacks or function calls that occur during recording execution of an application program. Such callbacks usually cause changes in memory state and such state changes should be synchronized between recording and replaying application program execution. In other embodiments state synchronization is performed at other times according to a configuration that a user establishes.

Referring now to in step a test determines whether additional pages are present in a queue of pages that are now dirty. If so then in step the next page is selected. Thus step represents iterating through all pages that were previously stored in the process of and performing the successive steps in each iteration for each stored page.

In step all data that is currently in memory in the same page is examined. Thus step involves comparing all data in the saved copy of a page to all data in that same page as it currently exists in memory typically after one or more write operations have altered the page. Step forms groups of data bytes that were changed as a result of the write operations. The groups of bytes formed at step may consist of a list of addresses offsets and sizes. In a system that uses 32 bit addressing the groups of bytes may comprise 4 byte chunks.

In step the address offset and size of changed groups of bytes are stored in a data file or other persistent storage of a recording system such as in persistent store . The address offset and size values may be stored in serialized form to facilitate transfer of the information across a network or to other computer systems or applications. In an embodiment for compactness the actual data bytes are not stored but only reference information is stored such as address offset and size. As a result recording system acquires a record of exactly which parts of memory were altered during program execution at the time that the program execution was recorded. In an alternate embodiment the actual modified bytes could be stored.

In step the saved page copy is deleted because it is no longer needed. In step the page of the running computer system is again set to read only access. Resetting the page to read only access enables the recording system to capture subsequent changes to the same page by repeating the processes of .

The process of is performed when the execution of an application is replayed to determine whether the state of memory upon replay matches the state of memory that existed when the execution of the application was earlier recorded.

Steps correspond to and are performed in the same manner described above. However after a change is detected and represented in the form of groups of bytes at step in step and step the process of searches the storage of the recording system to determine whether matching groups of bytes are represented in the storage. Generally steps involve determining whether the address offset and size of a group of changed bytes that is recognized during replay matches stored values that were captured during earlier recording of the application program.

If a matching group is found then the state of memory at the time of replay is synchronized to the state of memory at the time of previous recording. In response in step the saved page copy is deleted since it is no longer needed for comparison purposes and the page is reset to read only access to permit evaluation of subsequent changes.

If no matching group is found in storage then the state of memory at the time of replay is different than the state of memory at the time of previous recording. In response in step a state synchronization error is processed.

In an embodiment step involves invoking a debugger for debugging the application program and setting a debugger breakpoint at the location in program execution at which step was invoked. For this purpose step or another step may involve saving an instruction location at which is invoked. Typically the breakpoint is set at or near an invocation of a callback or API function call.

A user can then search the program instructions to identify callbacks or function calls that caused the state synchronization error. Normally the search will be limited to a relatively small range of program instructions. Thus in the approach herein a user is placed within the debugger at a location of the application program far closer to a likely source of a synchronization problem than in prior approaches. The approach herein allows detection of application program bugs far closer in the execution flow to a place where a bug actually exists for example at an API call rather than thousands or millions of instructions later.

The embodiments described above address state changes in static memory and application heap memory. Additionally or alternatively state changes in stack memory may be detected. In an embodiment when a system call is entered the recording system moves down the arguments of a function to the next memory page. The entire stack space above the new page is protected in the manner described above. As a result changes in stack state can be detected during system calls which is when loss of state synchronization is likely to occur.

In a further alternative or enhancement to the foregoing approaches stack space addresses are preserved. In an embodiment precise state synchronization is achieved by maintaining stack addresses on all threads between recording and replaying. As a result execution decisions that are based on the stack addresses will proceed during replay exactly as they did during recording.

In an embodiment recording system upon recording and replaying gives the same deterministic stack space for all threads that an application program creates to execute within. In an embodiment operating system provides this feature as a core function. Alternatively recording system uses a deterministic memory allocating function to generate addresses at recording and replaying time.

In an embodiment when a new thread is about to execute recording system allocates memory space and moves the stack pointer to the top address of the new memory. Moving the stack pointer to the top address is performed on platforms such as Microsoft Windows PCs in which stack addresses grow downward in other platforms the stack pointer may be moved to the bottom address or a first address. Special thread local variables that correspond to the old stack address are adjusted. Examples include variables that point to the current frame exception handler and minimum and maximum thread pointers.

When a thread has completed execution recording system detects the completion but does not allow the thread to immediately exit normally. Recording system restores the stack pointer and all special thread local variables to their original values. Recording system then allows the thread exit to occur.

In an embodiment a computer system can record and replay the execution of an application program or other element of a unit under test. Recording and replaying facilitates for example performing debugging of the application program. Recording includes identifying and storing information about all non deterministic inputs used by the program under test during execution and replaying includes providing identical non deterministic inputs in order to restore the state of the program and memory accurately. As a result a user can replay a program under test repeatedly assured of the same execution path and output facilitating debugging and other analysis. During replay of the execution embodiments permit skipping ahead to different points in execution of the program under test or rewinding to prior points in execution of the program under test.

Embodiments facilitate the skip ahead or fast forward and rewind functions by creating and recording state point data during the recording phase. State point data captures the state of memory values associated with a program under test at a specified point in time during program execution. In an embodiment a user can jump to any state point at any time. Similarly any State Point can be rewound to by restoring the original memory state.

Moving to a different state point is accomplished by skipping code execution and restoring the recorded results of that execution to memory. In this way embodiments provide techniques for creating and storing snapshots of data relating to the state of a system under test for use in restoring the system to the same state at a future point in time to support a skip ahead or fast forward function when execution of the program is replayed and to support a rewind function during replay of execution.

The capability of embodiments described herein enables a user to skip if desired problems occurring during replay. As a result a user can selectively debug a program so that the user is not required to fix each problem of a program in sequential order of execution or occurrence of the problems. Further in the event that the recording phase improperly captured a source of program non determinism so that replay does not occur correctly or becomes non synchronized with other program data the user can skip past that point in execution. For example in an embodiment the testing system during the replay phase will detect non synchronization and report an error to the user in response in an embodiment the user can elect to skip the program code that caused an error in synchronization.

In an embodiment an initialization approach captures an initial state of memory of a unit under test and the state points comprise data representing changes to the state of memory as program execution occurs. The initial state may comprise a snapshot of the stack only if the program is at its first instruction or an image of all of heap memory and static memory if the program is at a later state. In an embodiment a rolling window of state point data is created. A first state point for the rolling window can be recorded at any point during execution and previous data occurring earlier than that point can be discarded as execution continues. Further problems occurring during replay can be skipped.

In an embodiment heap memory and static memory are organized in units of data termed pages. For example in certain embodiments a page of memory in heap memory or static memory comprises 4096 bytes. However other embodiments may use other forms of memory organization and different operating systems may use different units. Therefore in this description the term page refers broadly to any unit of memory that can be protected copied or otherwise manipulated using an operating system including bytes words blocks segments or other organizational units depending on the architecture of the operating system application or unit under test or its processor s .

In an embodiment system under test is a computer game system such as a Nintendo system Microsoft XBox system Sony Playstation or PC game system and application is a computer game program. Other embodiments may be implemented using any other system under test and any other kind of application program including but not limited to business applications enterprise software applications networking applications scientific applications medical applications financial applications etc.

The system under test further comprises one or more execution handlers for use in detecting changes to values in heap memory and static memory . The use of exception handlers is further described in other parts of this disclosure.

The system under test is coupled to a testing system . In various embodiments testing system is integrated into the system under test or runs on the same hardware platform. In an embodiment testing system comprises a storage system interface logic execution recording logic and execution replay logic .

In an embodiment storage system comprises a mass data storage system such as a disk system. Any other form of non volatile mass data storage may be used in other embodiments.

The interface logic execution recording logic and execution replay logic may be implemented separately or collectively as one or more computer programs other software elements or a combination of software and firmware. Interface logic may be coupled to the storage system and to the system under test . Interface logic when executed is operable to interface to the heap memory and static memory.

In an embodiment the execution recording logic records state points relating to application of the system under test . In an embodiment the execution recording logic when executed is operable to perform detecting one or more changes in a first state of the heap memory and the static memory and storing in the storage system as a state point of the unit under test the one or more changes in the first state of the heap memory and the static memory.

In an embodiment execution replay logic when executed is operable to perform receiving a request to change the memory under test to a particular state point and in response to the request loading the particular state point from the storage system and applying the particular state point to the heap memory and the static memory to result in changing the heap memory and the static memory to a second state that is equivalent to the first state as represented in the state point.

In various embodiments the interface logic execution recording logic and execution replay logic are configured to perform other logical functions as further described in this disclosure.

In an embodiment testing system stores in storage system data about the state of memory stack system resources threads and their contexts and other data associated with each of the state points as the application executes. Thereafter the testing system can replay the identical execution path of application and can change the point of execution to any of the state points in any order. Thus testing system can implement fast forward and rewind functions in the course of replaying the execution of application . These functions enable a user to perform debugging or other analysis of application or other aspects of the system under test .

Arrow and the execution path of application also may include one or more calls to application programming interface API functions of the operating system that the testing system cannot skip when execution of the application is replayed. Such API calls are termed non skip API calls and are represented by non skip API call . The replaying of non skip API calls is further described in other sections of this disclosure.

Heap memory and static memory may be large and may comprise gigabytes of data capacity. In an embodiment each state point comprises an efficient and compact set of data about the state of application at a particular point in time. In an embodiment each state point comprises a list of changes in heap memory also termed list a list of changes in static memory also termed list a copy of the stack register values thread data system resource data and a replay data stream index value .

In this embodiment list comprises a list of addresses and data values that reflect changes that the application made to heap memory during execution. List comprises a list of changes in static memory that the application made. Stack copy stores all values that were on the stack at the particular point in time. Register values comprises all values that were stored in registers of a CPU of the system under test at the particular point in time. Thread data comprises information about all program threads that were active in the system under test at the particular point in time and the contexts of such threads. Thread contexts comprise values of registers associated with threads program counters etc. System resource data comprises values such as operating system file pointers window pointers and window handles that the operating system has created during execution of the application .

The replay data stream index value is a datum that uniquely represents a position of the state point in the execution path of the application . For example index value may comprise a unique integer. In an embodiment index values increase sequentially as execution of the application proceeds.

Steps to represent a record phase in which the testing system records or stores data for one or more state points during execution of the application . In an embodiment a user may initiate recording at any desired point in time. For example the user can allow the program under test to execute for a first period of time and then signal the testing system to begin recording state points and then signal the system to stop recording state points but continue with program execution. The foregoing operations may be performed in any other order according to a preference of the user.

In step the process interfaces to the unit under test. Step represents establishing any form of data communication or connection between the testing system and the unit under test so that the testing system can receive data values from memory of the unit under test.

In step the initial state of the system under test is stored for example using storage system . Step may comprise storing a copy of the entire heap memory and entire stack memory in storage system if such an initial state is stored only occasionally then it will not adversely affect performance or storage requirements. Alternatively if the program under test is starting at its first instruction then step may comprise storing a first state point having zero values or specified values. Thereafter the testing system can store state points that include only lists of changes from the initial state. The initialization step enables the testing system to accurately reproduce execution of the application at a later time by starting at the known state and applying successive changes represented in state points until a desired point in execution is reached.

Initialization at step does not necessarily require starting program execution at a first instruction of the program under test. For example referring again to if the testing system has recorded state points and the user is no longer interested in performing debugging of program operation between those state points then the user can request the testing system to set state point as the initial state and record state point data thereafter. In this approach the testing system can delete data associated with state points and reclaim storage associated with those state points. Therefore the storage system is used efficiently.

In step the testing system detects one or more changes in a state of the system under test based on memory write exceptions. As part of step the testing system determines when the system under test is writing data to heap memory or static memory. Particular processes for detecting changes using write exceptions are further described in other sections of this disclosure.

In step the testing system stores information about the changes in memory as part of a state point. The testing system may store state points at any specified point in time and the storage of state points may be triggered in several different ways. For example creating a state point may occur in response to a command line command received from a user. Alternatively the testing system may enable a user to schedule creating state points at periodic intervals e.g. every minute or at any other useful time interval. Storing changes at step may involve analyzing changes to all pages for which changes were detected in step . Step also may involve storing a copy of stack memory thread data thread contexts system resources and other values that represent program state at a particular point in time.

Steps to represent a replay phase in which a path of execution of the application is replayed to aid analysis of the application or other aspects of the system under test . The replay phase may occur at any time after one or more state points have been recorded.

In step a selection of a particular state point is received. For example a user of the testing system may signal the testing system to replay the execution of application starting at a particular state point using any form of user input to the testing system. The user input may represent a request to fast forward or rewind.

In an embodiment testing system generates a graphical user interface that is displayed on a display that is coupled to the testing system . The user instructs the testing system to start replaying execution of application by selecting a state point from a list graphical display widget or other user interface element. In other embodiments input may be received programmatically from another program or system.

In various embodiments the user may instruct the testing system to replay execution of the application at a state point that is later in time than a current point of execution or earlier in time. Thus upon receiving appropriate user input the testing system can play fast forward or rewind execution of the application to facilitate debugging or other analysis.

In step the heap memory static memory and stack of the system under test are restored to values associated with the particular state point. For example testing system retrieves a particular state point from the storage system and copies all data values of the state point to corresponding memory structures registers or other addresses of the system under test .

In step the testing system restores all threads and context data of the system under test . For example the testing system copies thread data and context data of the state point to corresponding locations in the system under test .

In step the testing system restores all system resources of the system under test . For example the testing system copies system resource data associated with the particular state point to corresponding locations in the system under test .

In step execution of the system under test resumes. For example testing system instructs the system under test to resume execution by providing the CPU of the system under test with an appropriate instruction.

In step one or more exception handlers are installed in the system under test. An exception handler is a computer program segment that an operating system executes in response to detecting a particular kind of exception during execution of an application program system program or operating system operation. In an embodiment step comprises the testing system installing an exception handler for memory write operations in the system under test . The exception handler is called when the application attempts to write data to a write protected portion of the heap memory or static memory . Functional steps of the exception handler are shown in steps and are discussed in other sections of this disclosure.

In step execution of the unit under test is started. For example the testing system instructs the system under test to start execution after initialization as previously described.

In step all pages of the heap memory and all pages of the static memory are write protected. For example the testing system instructs the operating system to implement write protection for all pages of the heap memory and the static memory . In this description write protection may comprise any operation of the unit under test such that writing to a protected page causes an exception or interrupt to occur.

In step a write exception is thrown. Step occurs when the application program attempts to write a page of the heap memory or static memory that was write protected in step . The operating system throws the write exception triggering execution of the installed exception handler . In effect step occurs in response to any attempt by the application to change memory of the system under test .

Execution of the exception handler involves steps . In step the exception handler stores a copy of the particular page for which the exception was thrown that is the page in memory that the application attempted to change. For example exception handler stores a copy of a page in heap memory in storage system .

In step the particular page is made writable. For example exception handler requests the operating system to remove write protection from the particular page that the application attempted to write. As a result the application will be able to successfully write the page in the future.

In step execution of the system under test resumes. For example exception handler returns control to the operating system.

In step the system under test writes to the particular page. For example application writes changed data to the page that it attempted to change at step . Thus steps involve detecting an attempt to write a page in memory saving an unchanged copy of the page in storage for future reference and to capture the state of the system under test at the time of the change and then allowing the system under test to successfully write the page. Steps can occur transparent to the system under test and without interrupting its execution for more than a few milliseconds.

In step a synchronization point is reached during execution of the system under test. A synchronization point is a point in program execution that the system uses to ensure that a state of program execution upon replay is synchronized with the corresponding state at the time of recording program execution.

In step the process compares the data in the copy of each particular memory page which was stored at step to the current data of the same page location. In an embodiment all memory pages for which changes were detected are subjected to a comparison operation at step . Memcompare operations of the operating system may be used.

In step the process creates and stores a list of changes that occurred in the particular page between the time at which the copy was stored at step and the current time. The list of changes is based on results of the comparison operations of step . The list of changes covers all changes to all memory pages for which changes were detected. The list of changes may be stored as part of a state point using the organizational arrangement of . The terms deltas or differences may be used to refer to the changes. Using a list of changes captures memory state efficiently and without storing a copy of the entire memory which could comprise gigabytes. Consequently many state points can be stored to permit moving among many points of program execution.

Step also may involve storing as part of the same state point a copy of stack memory thread data thread contexts system resources and other values that represent program state at a particular point in time. Step also may involve storing as part of a state point one or more sync index values into the replay data stream. Storing a sync index value with a state point enables the testing system to replay program execution correctly by capturing a value representing a discrete point in program execution.

In step a selection of a particular state point is received. For example step involves receiving user input requesting to move the current point of execution of application ahead in time with respect to a prior recording of the execution. Thus step may involve receiving user input indicating a request to skip ahead by one state point or to move to the next point. Alternatively step may comprise receiving a programmatic call to a Next State Point function which implies that the caller wishes to advance to the next state point available.

In step all data for the specified state point is loaded. For example step involves reading all the data associated with the specified state point from the storage system and temporarily storing the data in system memory of the testing system .

In step all data for the specified state point is written to the system under test. For example step involves writing all the state point data from system memory to corresponding locations in the system under test. As a result the state of the system under test changes to correspond to the stored state point. Certain system resources for example internal system pointers such as file pointers window pointers handles When all data shown in is stored in a state point and restored at step the state of an application program the system under test will have the same state as it had when the state point was originally recorded except for non deterministic behavior changes that may arise from operation of the operating system of the system under test. That is only operating system resources owned by the application are assured to be in the same state but not the operating system itself.

In step the process causes the system under test to resume execution. For example the process requests the operating system to resume executing the application .

In step a selection of a specified state point is received. The specified state point is earlier in time in relation to a path of execution of a previous recording of execution of the application than the current time.

Before step and during all times during replay of a program the steps described above for are performed for the original state point and the specified state point as a check to verify that the replay phase remains in synchronization with the recorded program execution. Thus for example during replay write protection is enabled on all pages of heap memory and static memory write exceptions are thrown when the application under test performs a write to a protected memory page copies of modified pages are maintained changes are computed etc. as in . This approach enables the system to perform a rewind function during replay by using information created and stored during recording of program execution while maintaining state synchronization.

In step the process rewinds the execution point to a previous state point based on restoring the system to a first available state point and then applying changes of successive state points until the specified state point is received. In an embodiment step comprises first changing the state of the system under test to the known state of initialization that existed when the application initiated execution. In other words the system is restored to its initial state not to an immediately earlier state point. Alternatively the system is restored to its state at a first state point that was recorded after program execution began.

For example referring to if program replay currently is ahead of state point and the user requests rewinding to state point then the process of first restores the system under test to the first state point then applies changes associated with state point to reach state point resulting in effectively rewinding from state point to state point .

Rewinding includes retrieving original unmodified pages that the system stored in accordance with at the time that changes occurred to memory usually at the first state point that was recorded. Thus the system is capable of retrieving the original versions of all pages as they existed at the first state point. Then the system under test is restored to successive state points one by one by retrieving each recorded state point in order from the storage system and applying changes indicated in the lists . Other state point data such as stack copy register values thread data and system resource data is restored to corresponding locations in the system under test. The sub steps of step are repeated until the state of execution reaches one state point prior to the requested or specified state point.

In step data for the requested or specified state point is loaded and all changes represented in the lists are applied to the system under test. In step the contents of the stack and threads are restored to the system under test based on the data stored for the state point. In step system resources are restored based on the data stored for the state point. At the completion of step the system under test has reached the requested state point. From the standpoint of the user execution of the application has been rewound to the prior state point.

In an embodiment execution replay logic includes logic for detecting replay synchronization errors. In one embodiment the execution replay logic is configured to receive at a particular point in execution of the unit under test data about a write exception to a particular page determining whether the storage system includes data about the write exception determining that a replay synchronization error has occurred when the storage system does not include data about the write exception and response thereto setting the unit under test to a second state point that is earlier than the particular point in execution by retrieving stored pages of the heap memory and the static memory associated with the second state point and copying the retrieved stored pages of the heap memory and the static memory associated with the second state point to the heap memory and the static memory of the unit under test applying to the heap memory and the static memory of the unit under test all changes associated with the next state point stored in the storage system after the second state point and repeating the applying step until reaching another state point that is closest in time to the particular point in execution.

The use of page exceptions as described above for facilitates detecting synchronization errors. In particular list of changes in heap memory can be used to identify all pages in heap memory that were changed and list of changes in static memory can be used to identify all pages in static memory that were changed. When a write exception occurs during the replay phase the execution replay logic examines the stored lists to determine whether the same page was written during the recording phase. If not then a synchronization error has occurred.

To recover from the error the stored copy of the original page is restored. The Next State Point operation described above can be called to recover. System resources threads and thread contexts stack contents and other data relating to a state point are also recovered.

In an embodiment execution replay logic comprises logic configured to restore system resources including threads and selected operating system resources that programs address using API calls. In a typical operating system hundreds of types of system resources are available and a typical application program might use several dozen resources. An example system resource is a call to a function that creates a window in a particular location of the display screen. To restore all such resources to the correct state during the replay phase custom code would be needed. As an alternative to such a brute force approach the present disclosure focuses on addressing selected API calls such as those relating to windows and threads these selected functions are termed non skip APIs as represented by non skip API call of .

To ensure that non skip APIs are not skipped upon replay in an embodiment the execution recording logic automatically creates marker state points just before each non skip API call. Thus regardless of any other trigger mechanism that the user has established for creating state points marker state points are always created at non skip API calls. This approach assures that state transitions relating to the calls are captured and that the calls will be executed upon replay. In one embodiment the execution recording logic is configured to perform the detecting and storing for a marker state point automatically just before the unit under test executes any of a plurality of specified operations of an operating system of the unit under test. In one embodiment the specified operations comprise windowing operations and thread operations.

On replay a user is not permitted to fast forward or jump among state points if a non skip API call would be skipped in the transition. Further whenever a user or program attempts to skip from one state point to another state point and a non skip API is between the two state points the execution replay logic requires program execution to move to the marker state point just before the non skip API call the non skip API wait for the API call to return and then skip ahead to the next state point. This approach assures that each non skip API call is actually called on replay and assures that resulting state values remain in synch. Accordingly in an embodiment the execution replay logic is configured to perform fast forward replay of execution of the unit under test by automatically changing the unit under test to a state represented by a particular marker point causing the unit under test to execute one of the specified operations and changing the unit under test to a state represented by a next state point in the storage system.

API calls relating to threads and thread context data are examples of non skip APIs. However in performing movement among state points not all thread data is required to be restored. As an example is a time diagram showing points of creating and destroying thread data during an execution of a unit under test. Assume that state points SP1 SP2 SP3 have been recorded and stored during execution of application . Assume further that a thread was created at point after state point SP1 and before state point SP2. Assume that the same thread was destroyed at point after state point SP2 and before state point SP3. Finally assume that the user wishes to change the state of execution from SP1 to SP3. In this scenario there is no need to restore data for the thread because the thread was both created and destroyed by the time of SP3 and therefore after SP3 the thread can have no effect on program execution.

The preceding sections describe detecting when an application program performs a memory read operation or memory write operation using memory protection and exception handling techniques. In alternative embodiments detecting memory operations may be performed in other ways. For example in one embodiment recording system detects kernel calls that relate to memory read operations or memory write operations and determines whether state synchronization exists or race conditions are present using processing other than exception handling. Thus the broad approach herein involves detecting memory read operations or memory write operations and performing responsive processing to detect state synchronization or race conditions but the use of memory protection and exception handlers is not required.

In one approach a software module that resides in kernel space as opposed to user space has the ability to monitor memory accesses made by one or more applications running in user space. This approach may be used with any operating system such as Linux for which the kernel is open source and accessible. Alternatively the approach may be used with virtual machines such as Java or .NET. By monitoring access to the kernel memory manager all memory accesses made by one or more applications can be tracked and analyzed.

In another approach a customized replacement memory management component is installed at the kernel level and is responsible for all memory creation and destruction and allows control of memory accesses. The custom memory management component may act as a layer between the standard kernel memory manager and user space that provides an opportunity to exercise control over memory access. This system would control all memory accesses made by one or more applications.

In another approach a hardware module such as a customized memory management processor can send notifications when memory access occurs. The module sends data including the memory address accessed the type of access and which hardware thread is accessing the memory. The data may also include the contents of the access in the case of a write or the scope of the access in the case of a read or execute. The module would provide all data necessary to detect race conditions as well as perform other recording and playback functions. The hardware module can be implemented using modified standard memory management processors.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse trackball stylus or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for recording and replaying computer programs. According to one embodiment of the invention recording and replaying computer programs is provided by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infrared data communications.

Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infrared transmitter to convert the data to an infrared signal. An infrared detector can receive the data carried in the infrared signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the worldwide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface . In accordance with the invention one such downloaded application provides for recording and replaying computer programs as described herein.

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

