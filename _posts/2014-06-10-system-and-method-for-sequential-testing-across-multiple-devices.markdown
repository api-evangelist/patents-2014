---

title: System and method for sequential testing across multiple devices
abstract: Disclosed herein are systems and methods for sequential testing across multiple devices. In one implementation, the method includes analyzing test device requirements, received from a plurality of user devices, to generate automation scripts for test automation. Further, the method includes allocating testing devices, from among the plurality of user devices, for the sequential testing based on availability of the plurality of user devices and the test device requirements. Further, the method includes determining a sequential schedule based on at least one of a waiting time for the testing devices, a priority assigned to the testing devices and the automation scripts, intermediate data, an execution status, and a device status.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09482683&OS=09482683&RS=09482683
owner: Wipro Limited
number: 09482683
owner_city: Bangalore
owner_country: IN
publication_date: 20140610
---
This application claims the benefit of Indian Patent Application Filing Number 2043 CHE 2014 filed on Apr. 22 2014 which is hereby incorporated by reference in its entirety.

The present subject matter is related in general to automation testing devices and in particular but not exclusively to methods and systems for sequential testing across multiple devices.

Automated testing is generally performed to identify if there is any bugs in source codes and to check whether a software application installed on a device is functioning properly or not. In automated testing test scripts are written to check whether results of the automated testing are in accordance to expected outputs. Further any bugs in the source code or software application identified during automated testing are reported to concerned stakeholders such as a test engineer so that they can be eliminated from the source code. The test scripts can be run recursively to test the functioning of software. The automated testing may comprise various tasks such as checking the syntax of the source codes checking outputs of the software application and checking behavior of the software application for predefined inputs.

Nowadays organizations are using wide ranges of devices having various platforms to meet their requirements. In such cases automated testing is typically carried out for each of the devices independently to check whether the device and or an application installed on the device is working properly.

Disclosed herein are systems and methods for sequential testing across multiple devices. In one example the system for sequential testing across multiple devices comprises a processor a memory communicatively coupled to the processor wherein the memory stores processor executable instructions which on execution cause the processor to analyze test device requirements received from a plurality of user devices to generate automation scripts for test automation. The processor executable instructions on execution further cause the processor to allocate testing devices from among the plurality of user devices for the sequential testing based on availability of the plurality of user devices and the test device requirements. The processor executable instructions on execution further cause the processor to determining a sequential schedule based on at least one of a waiting time for the testing devices a priority assigned to the testing devices and the automation scripts intermediate data an execution status and a device status.

In an aspect of the invention the method for sequential testing across multiple devices comprises analyzing test device requirements received from a plurality of user devices to generate automation scripts for test automation. Further the method comprises allocating testing devices from among the plurality of user devices for the sequential testing based on availability of the plurality of user devices and the test device requirements. Further the method comprises determining a sequential schedule based on at least one of a waiting time for the testing devices a priority assigned to the testing devices and the automation scripts intermediate data an execution status and a device status.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention as claimed.

It should be appreciated by those skilled in the art that any block diagrams herein represent conceptual views of illustrative systems embodying the principles of the present subject matter. Similarly it will be appreciated that any flow charts flow diagrams state transition diagrams pseudo code and the like represent various processes which may be substantially represented in computer readable medium and executed by a computer or processor whether or not such computer or processor is explicitly shown.

In the present document the word exemplary is used herein to mean serving as an example instance or illustration. Any embodiment or implementation of the present subject matter described herein as exemplary is not necessarily to be construed as preferred or advantageous over other embodiments.

Systems and methods for sequential testing across multiple devices are described herein. The systems and methods may be implemented in a variety of computing systems. The computing systems that can implement the described method s include but are not limited to a server a desktop personal computer a notebook or a portable computer a mainframe computer and in a mobile computing environment. Although the description herein is with reference to certain computing systems the systems and methods may be implemented in other computing systems albeit with a few variations as will be understood by a person skilled in the art.

Generally in an organization s network different types of computing devices such as mobile phones laptops desktop computers and tablets are present. These computing devices may have different platforms installed on them along with various software applications which allow a user to perform certain tasks. In one scenario a software application may be installed on the computing devices such as a laptop a mobile phone a desktop application or any portable device. To test consistency of the software application across different computing devices automation tools performs the testing for each of the computing device individually. In another scenario a cloud storage application can be accessed using different computing device. In such cases a user may sync a file in cloud and then may want to check file availability in all the devices. So generally when test automation has to be done to check the file availability the user has to automate separately in the each of the devices.

Typically conventional automation testing tools work in an isolated manner. For example a web automation tool does not interact with an iPhone automation tool and an iPhone automation tool doesn t interact with a PC automation tool. Further during automation testing across the devices it is possible that a software application may need data from other applications to function. This requirement of the data from other software applications creates a dependency between the two applications. So if test automation has to be done on the software applications which are dependent on other software applications then the user need to get the data manually from the other software applications before starting the automation testing of the software application. The conventional automation test tools generally do not co ordinate the execution of a task across multiple devices which have dependency on each other.

In an example say a user purchased a product online using a web browser on desktop computer. The user now wants to check its status in a native app of the online store on his smart phone. If test automation has to be done on above example a test engineer may first need to automate the web browser and then the smart phone separately with manual exchange of data for example an order ID between these two devices. Hence the conventional automation testing tools lead to tedious as well as sub optimal test automation system development.

The present subject matter discloses systems and methods for sequential testing across multiple devices. The present subject matter performs the sequential test automation along with automatic exchange of intermediate data. In one implementation to perform the sequential test automation test device requirements such as test scripts test data and configuration data are received from a plurality of user devices. In an example the user may provide the test device requirements through the plurality of user devices. The configuration data is generally used to configure testing environment and comprises database connection profile such as database DB name DB host DB username and DB password for connecting to a database to obtain the test data. The configuration data may further comprise priority of devices and test scripts and a waiting time for a particular device. The waiting time may indicate approximate time after which a device is available for execution.

Once the test device requirements are obtained automation scripts may be generated for testing devices. The testing devices are the devices allocated from amongst the plurality of user devices for sequential testing. In an example the testing devices are allocated based on availability of the user devices and the configuration data. Thereafter the automation scripts generated for the testing devices are assembled and assigned a namespace. In an example for the same test device requirements different version of automation scripts with the help of a version manager. This may help in performing the test automation for the plurality of user devices having different platforms installed on them.

These automation scripts under a same namespace are then assigned a job identifier ID and sent to run queue. In run queue the automation scripts are stored on registers and executed based on the configuration data. The collection of automation scripts under a same job ID for execution is also referred to as a job. Subsequently jobs sent to the run queue are assigned an inactive mode and allocation of testing devices is performed. Then devices from amongst the plurality of user devices that are available for job execution are selected. Hereinafter the devices selected from amongst the plurality of user devices are referred to as testing devices. In an example the devices which meet the test device requirements received from the user and are available for execution are selected for the job execution.

Once the testing devices are allocated for the job execution the automation scripts are sent to the testing devices. In case one of the testing devices allotted for execution is not available or execution is dependent on intermediate data the automation scripts may be kept on hold for a certain time. In case the test devices are available for the execution the execution process is started by switching a job mode from inactive to active. Upon identifying that the job mode is active parameters such as device id start time end time current mode and data required are initialized.

Further since test automation is to be performed simultaneously across multiple devices the automation scripts are scheduled for execution. In an example the automations scripts are executed as per a sequential schedule. The sequential schedule may be determined based on parameters such as a waiting time for the testing devices a priority assigned to the testing devices and the automation scripts intermediate data an execution status and a device status. Once the sequential schedule for the execution is determined an execution mode is assigned to each of the testing device. The execution mode may be one of a run mode a wait mode a complete mode and a failed mode.

Thereafter the testing devices in the run mode are instructed to execute the automation scripts based on the sequential schedule. Further the execution mode of the testing devices which need intermediate data for execution is changed to the wait mode. Once the intermediate data for the execution is available the wait mode is again changed to the run mode and execution of the automation scripts is completed. In this manner coordination between the testing devices and test automation is performed across multiple devices simultaneously.

Further in case there is a failed execution due to a fault in the testing device or an error in the automation scripts a failure recovery is performed. During the failure recovery execution activities under the same job ID are reconstructed in a newly allocated device. Once the execution reaches to an instance where it had failed the execution is synchronized with the executions running in other testing devices. Upon synchronization the executions are carried out by the testing devices till the job is completed.

Thus the present subject matter performs a sequential testing across the multiple devices simultaneously with automatic exchange of data. Further requirement of manual exchange of the intermediate data is eliminated by the present subject matter. Also the present subject matter provides a failure recovery in case of any failed execution. Further the present subject matter allows the automation testing of the devices even if the devices have different platforms installed on them.

The working of the systems and methods for sequential testing across multiple devices is described in greater detail in conjunction with . It should be noted that the description and drawings merely illustrate the principles of the present subject matter. It will thus be appreciated that those skilled in the art will be able to devise various arrangements that although not explicitly described or shown herein embody the principles of the present subject matter and are included within its spirit and scope. Furthermore all examples recited herein are principally intended expressly to be only for pedagogical purposes to aid the reader in understanding the principles of the present subject matter and are to be construed as being without limitation to such specifically recited examples and conditions. Moreover all statements herein reciting principles aspects and embodiments of the present subject matter as well as specific examples thereof are intended to encompass equivalents thereof. While aspects of the systems and methods can be implemented in any number of different computing systems environments and or configurations the embodiments are described in the context of the following exemplary system architecture s .

The system may be implemented in a variety of computing systems such as a laptop computer a desktop computer a notebook a workstation a mainframe computer a server a network server and the like. It will be understood that the system may be accessed by users through a plurality of user devices N collectively referred to as user devices and individually referred to as user device . Examples of the user devices include but are not limited to a desktop computer a portable computer a mobile phone a handheld device a workstation. The user devices may be used by various stakeholders or end users of the organization such as project managers database administrator developers and test engineers. As shown in the figure such user devices are communicatively coupled to the system through a network for facilitating one or more end users to access and or operate the system .

The network may be a wireless network wired network or a combination thereof. The network can be implemented as one of the different types of networks such as intranet local area network LAN wide area network WAN the internet and such. The network may either be a dedicated network or a shared network which represents an association of the different types of networks that use a variety of protocols for example Hypertext Transfer Protocol HTTP Transmission Control Protocol Internet Protocol TCP IP Wireless Application Protocol WAP etc. to communicate with each other. Further the network may include a variety of network devices including routers bridges servers computing devices storage devices etc.

In one implementation the system includes a processor a memory coupled to the processor and interfaces . The processor may be implemented as one or more microprocessors microcomputers microcontrollers digital signal processors central processing units state machines logic circuitries and or any devices that manipulate signals based on operational instructions. Among other capabilities the processor is configured to fetch and execute computer readable instructions stored in the memory . The memory can include any non transitory computer readable medium known in the art including for example volatile memory e.g. RAM and or non volatile memory e.g. EPROM flash memory etc. .

The interface s may include a variety of software and hardware interfaces for example a web interface a graphical user interface etc. allowing the system to interact with the user devices . Further the interface s may enable the system respectively to communicate with other computing devices. The interface s can facilitate multiple communications within a wide variety of networks and protocol types including wired networks for example LAN cable etc. and wireless networks such as WLAN cellular or satellite. The interface s may include one or more ports for connecting a number of devices to each other or to another server.

In one example the system includes modules and data . In one embodiment the modules and the data may be stored within the memory . In one example the modules amongst other things include routines programs objects components and data structures which perform particular tasks or implement particular abstract data types. The modules and may also be implemented as signal processor s state machine s logic circuitries and or any other device or component that manipulate signals based on operational instructions. Further the modules can be implemented by one or more hardware components by computer readable instructions executed by a processing unit or by a combination thereof.

In one implementation the modules further include an input module a device module a master module an output module and other modules . The other modules may perform various miscellaneous functionalities of the system . It will be appreciated that such aforementioned modules may be represented as a single module or a combination of different modules.

In one example the data serves amongst other things as a repository for storing data fetched processed received and generated by one or more of the modules . In one implementation the data may include for example requirement data execution data and other data . In one embodiment the data may be stored in the memory in the form of various data structures. Additionally the aforementioned data can be organized using data models such as relational or hierarchical data models. The other data may be used to store data including temporary data and temporary files generated by the modules for performing the various functions of the system .

In operation the input module receives test device requirements from the plurality of user devices . The test device requirements may include test data test scripts and configuration data. The input module uses the configuration data to configure a testing environment. In an example the configuration module may comprise database connection profiles waiting time of testing devices and priority assigned to the testing devices and scripts. In one implementation the input module may store the test device requirements in requirement data for further usage.

Upon receiving the test device requirements the input module analyzes the test device requirements to generate automation scripts for test automation. In one implementation the input module may obtain the test scripts present in the test device requirements to construct the automation scripts. The input module also considers software version so that version specific automation scripts are generated and test automation can be performed on different version of software installed on the plurality of user devices . Also with the help of the version manager the input module may generate the automation scripts that can be used for the test automation of the plurality of user devices having different platforms installed on them. Further the input module assembles the automation scripts of a particular test case under a same namespace and assigns a job ID. The automation scripts for execution under the same job id are referred to as a job. Further various components and functioning of the input module are discussed in conjunction with .

Once the automation scripts are ready for execution the device module allocates testing devices from amongst the plurality of user devices based on availability of the plurality of user devices and the test device requirements. In an example the plurality of user devices may have same platform installed on them. In another example the plurality of user devices may have different platforms on them. In one implementation the device module monitors connection with the plurality of user devices and identifies the devices that are available for the test automation. The device module keeps the master module updated about the availability of the devices. In an example the device module allocates the available devices for testing which satisfies requirements for testing specified in the test device requirements. Further various components and functioning of the device module are discussed in conjunction with .

Subsequently the master module determines a sequential schedule based on sequence parameters such as a waiting time for the testing devices a priority assigned to the testing devices and the automation scripts intermediate data an execution status and a device status. The intermediate data may be understood as data resulted from execution of the automation scripts which may be used by one or more testing devices in order to complete execution of the test automation scripts on them. The execution status may indicate running and or completion status of executions and comprise predefined rules for execution. In an example the predefined rules may specify that execution of the automation scripts by a second testing device D should start once a first testing device D has finished its execution. In another example the predefined rules may specify that execution should start on D after 15 minutes execution of the automation scripts on D. Further the device status indicates availability user devices for execution.

In an example the sequence parameters may be obtained from the configuration data provided by the user and execution data maintained by an execution tracker. Once the sequential schedule is determined the master module assigns an execution mode to each of the testing devices based on the sequential schedule. The execution mode may be one of a run mode a wait mode a complete mode and a failed mode. Thereafter the jobs are executed as per the sequential schedule and the execution mode assigned to the testing device. During execution the master module maintains a track of executions and changes in the execution mode assigned to the testing devices. In case the master module identifies that the execution mode is changes from the run mode to the wait mode and the intermediate data is needed for the execution the master module provides the intermediate data to the testing device put on the wait mode. Further if the intermediate data is not available with the master module the master module may wait for the intermediate data created from other executions. Upon obtaining the intermediate the master module may then send the data to the intended testing device for execution. Thus a coordinated and optimized sequential testing is performed across multiple user devices .

In one implementation the master module performs a failure recovery whenever a failed execution is identified. The execution may fail due to some problem in the script or a faulty device. In such case the master module may assign another testing device for the sequential testing which is available for the execution. Thereafter the master module may generate a reconstruction phase for the failed execution. In the reconstruction phase other testing devices are assigned the wait mode and the failed execution is reconstructed. Once the reconstruction of failed execution reached a point where it failed the executions put on wait are synchronized and then the testing devices are instructed to execute the job assigned to them. Further various components and functioning of the master module are discussed in conjunction with .

The system further comprises an output module . The output module acts as an interface of the system and provides responses received from the modules to the user.

Further the configuration module obtains configuration data from the user devices . The configuration data helps in configuring a testing environment. The configuration data may include database connection profiles priority of devices and test scripts and waiting time for devices. For example the configuration data may include database DB name DB Host DB username and DB Password for connecting to a database and obtaining test data from the databases. The priority of the test devices and test scripts allows the master module to determine sequence in which the test execution is to be performed. Also the waiting time for the test devices is used by the master module to ascertain the devices that are available for execution of test scripts. In an example the master module analyzes the configuration data and keeps the automation scripts on hold for a time predefined time determined based on the waiting time. In one implementation the configuration data may be then stored in the requirement data so that the configuration data is accessible to all the modules present in the system . Further any change in the configuration data is reflected across all the modules. It may be noted that setups in the configuration module can also be overwritten programmatically allowing the user to take complete control over the automation test execution process.

Thereafter integration module receives the test scripts based on version provided in the configuration data. As shown in the integration module comprises a code build module and a code ready module . The code build module constructs the automation script that is executable in the testing devices. The code build module is scalable for each of the specific computing device and operates independently to generate the automation script. Also the code build module may allow the flexibility of adding any new sub module specific to a new device without affecting the existing design with minimal changes. Further a version manager may also be used along with the code build module to generate version specific test execution script which allows the user to test on different versions of the software and on different platforms installed in the plurality of devices.

Upon generation of the automation script the code ready module may assemble all the automation scripts of a given test case under a namespace to ensure that the scripts generated by the code build module are execution ready. Once the automation scripts are assembled and assigned a namespace the automation scripts are sent to the job module .

The job module replaces the namespace with a Job ID. The Job ID is unique for each test case and all testing activities are controlled and tracked based on the Job ID. The Job ID generally remains the same till all the executions have been finished.

Further the test cases with the Job ID are stored by the run queue in its registers. Based on the configuration data the job execution is done as per the instruction provided by the user i.e. to start running immediately or to be kept on hold for a certain time.

The gateway module converts the instruction received from the master module so that a destination device can understand the instructions.

The instructions module maintains device specific instructions that are understandable by the destination computing device.

The response module receives response from the user devices . The response may comprise metadata such as a device id from which the response is coming and a unique id of intermediate data.

The computing module comprises details about the different computing devices available for testing using this system . The computing module further comprises three sub modules a registration module a listener module and a status module . The registration module comprises details of all the devices which can be used for automation activities by this system . The listener module monitors the connection with all the computing devices. A signal is received from the computing device to ensure that the connection between the device module and the computing device is normal and operational. Any issue detected in the connection by the listener module is reported to the Status module . The listener module may keep monitoring the signal continuously in background

The status module gets updates from the listener module and keeps the latest record of the device status. The status module provides details about execution to the master module . The details may include number of devices running available or have been kept in waiting.

All test scripts under a job will be executed in different testing devices the sequence of execution and co ordination between these devices are maintained by the sequential scheduler. In one implementation the sequence scheduler determines the sequence of execution based on at least one sequence parameter. The sequence parameters may include time priority intermediate data execution status and device Status. The sequence parameters are obtained from the configuration module the execution tracker the intermediate data module and the device module . Once the sequence of the execution is ready the sequence scheduler assigns an execution mode to each of the testing devices. The execution mode may be one of run wait complete and failed.

Subsequently the driver module sends the execution mode to the target testing device. In case where the intermediate data is needed for execution and is available for the execution the driver module sends the intermediate test data along with the execution mode to the target testing device through the device module . The intermediate data module obtains intermediate data from device response and stores in the execution data till the data belonging to the job is completed. The intermediate data can be transferred to other computing device doing the same job. The intermediate data module facilitates exchange of data between different computing platforms.

To keep track of all the executions that are taking place in the target testing devices the execution tracker stores details such as registrations Id job Id script name device Id execution start time execution end time and waiting time. The execution tracker also stores time and execution status of a script which are used for calculating sequence of execution of a job.

The job tracker maintains track of job execution status. The job tracker module does the tracking of jobs that are running stopped and failed or in a reconstruction phase.

Further it may be possible that an execution process may fail. In such cases the failure recovery facilitates to recover from failure. The failure may be due to the device or due to the execution script. The recovery module reconstructs all the execution activities in a newly allocated device under the same job ID. Once the failed execution reaches to the instance where it had failed it synchronizes with the other devices of the job and continues executing till the job is completed.

Thus the system performs the sequential testing across multiple devices along with automatic exchange of the intermediate data between the testing devices. Further the system coordinates between the executions running in different testing devices. The system also provides the failure recovery in case a failed execution is detected.

The methods and may be described in the general context of computer executable instructions. Generally computer executable instructions can include routines programs objects components data structures procedures modules and functions which perform particular functions or implement particular abstract data types. The methods and may also be practiced in a distributed computing environment where functions are performed by remote processing devices that are linked through a communication network. In a distributed computing environment computer executable instructions may be located in both local and remote computer storage media including memory storage devices.

The order in which the methods and are described is not intended to be construed as a limitation and any number of the described method blocks can be combined in any order to implement the methods and or alternative methods. Additionally individual blocks may be deleted from the methods and without departing from the spirit and scope of the subject matter described herein. Furthermore the methods and can be implemented in any suitable hardware software firmware or combination thereof.

With reference to method as depicted in as shown in block test device requirements received from the plurality of user devices are analyzed to generate an automation script for each of the testing device. In one example the plurality of user devices may have different platforms installed on them. In another example the plurality of user devices may have same platforms installed on them. The test device requirements may comprise test scripts test data and configuration data provided by the user. Once the test device requirements are received the automation scripts are generated. In one implementation the integration module may generate the automation scripts for the plurality of user devices having same or different platforms using the same test parameters with the help of the version manager . Further the automation scripts are assembled under a namespace and assigned a job ID. The job ID is a unique identifier throughout the test execution process which allows the system to track and control the automation process. Subsequently the job i.e. the automation scripts under a job ID is sent to the run queue .

At block testing devices from amongst the plurality of user devices are allocated for automated sequential testing based on the test device requirements and availability of the plurality of user devices . In one implementation the master module makes a request to the device module with all the device requirements and waits for the response. In case the device module has availability of the testing devices the device module allocates the testing devices for the job and returns a device ID to the Job tracker . If the devices are not available the master module receives a notification indicating unavailability of the testing devices. Once the testing devices are allocated by the device module the master module dispatches the automation scripts to the testing devices through the devices module.

At block a sequential schedule is determined based on at least one of a waiting time for the testing devices a priority assigned to the testing devices and the automation scripts intermediate data an execution status and a device status. In one implementation the sequential scheduler of the master module receives the device IDs of a job from execution tracker and uses parameters such as a priority of a script a time intermediate data a device status and execution status to schedule the mode and order of the testing devices. Further the sequence scheduler keeps track of the testing devices for example which all are kept in wait and the reason for their waiting. In an example the testing device may wait for the intermediate data to proceed further. If the intermediate data is available the master module retrieves the intermediate data from the Intermediate module and dispatches to the testing devices.

At block an execution mode is assigned to each of the device based on the sequential schedule. The execution mode is one of a wait mode a run mode a complete mode and a failed mode. In an example the testing devices available for the test automation are assigned the run mode. In another example the testing devices waiting for the intermediate data are assigned the wait mode. Once the intermediate data is available with the testing device for execution the execution mode of the testing device is changes from the wait mode to the run mode. In this manner co ordination between different testing devices is achieved.

At block the automation script is executed upon identifying that the run mode is assigned to the testing devices to perform the automated sequential testing. In one implementation the testing devices in the run mode executes the automation scripts if the intermediate data needed for the execution is available

With reference to method as depicted in as shown in block a failed execution is detected. The failed execution may occur due to a faulty device or an error in the automation script. In one implementation if a job fails due to the failure of device or due an error in the automation script the job tracker decides based on the configuration data whether or not to reconstruct a failed execution. In case the failed execution is to be reconstructed the job tracker makes a request to the device module to allocate another testing device. On successful allocation the automation scripts are sent to the execution tracker for registration and initialization.

At block a reconstruction phase is generated for the failed execution. In one implementation the recovery module generates the reconstruction phase in which the failed execution is reconstructed. In an example when the testing device fails and in a phase of reconstruction the testing device takes less time using logs than the execution of original script because there is no waiting time for the intermediate data as the data are already present with the intermediate module.

At block the failed execution is reconstructed while keeping the other devices in wait mode during reconstruction phase. In one implementation in the reconstruction phase all the other testing devices of the job are kept in the wait mode till the recovery reaches to the instance where it had failed.

At block executions are synchronized upon identifying that the reconstructed script is executed till a failure point. In one implementation once the reconstruction is done the recovery module synchronizes the new testing device with the other devices. Further the testing devices are instructed to continue executing the jobs assigned to them. In this manner a failure recover mechanism is implemented in the present subject matter.

Processor may be disposed in communication with one or more input output I O devices via I O interface . The I O interface may employ communication protocols methods such as without limitation audio analog digital monaural RCA stereo IEEE 1394 serial bus universal serial bus USB infrared PS 2 BNC coaxial component composite digital visual interface DVI high definition multimedia interface HDMI RF antennas S Video VGA IEEE 802.n b g n x Bluetooth cellular e.g. code division multiple access CDMA high speed packet access HSPA global system for mobile communications GSM long term evolution LTE WiMax or the like etc.

Using the I O interface the computer system may communicate with one or more I O devices. For example the input device may be an antenna keyboard mouse joystick infrared remote control camera card reader fax machine dongle biometric reader microphone touch screen touchpad trackball sensor e.g. accelerometer light sensor GPS gyroscope proximity sensor or the like stylus scanner storage device transceiver video device source visors etc. Output device may be a printer fax machine video display e.g. cathode ray tube CRT liquid crystal display LCD light emitting diode LED plasma or the like audio speaker etc. In some embodiments a transceiver may be disposed in connection with the processor . The transceiver may facilitate various types of wireless transmission or reception. For example the transceiver may include an antenna operatively connected to a transceiver chip e.g. Texas Instruments WiLink WL1283 Broadcom BCM4750IUB8 Infineon Technologies X Gold 318 PMB9800 or the like providing IEEE 802.11a b g n Bluetooth FM global positioning system GPS 2G 3G HSDPA HSUPA communications etc.

In some embodiments the processor may be disposed in communication with a communication network via a network interface . The network interface may communicate with the communication network . The network interface may employ connection protocols including without limitation direct connect Ethernet e.g. twisted pair 10 100 1000 Base T transmission control protocol internet protocol TCP IP token ring IEEE 802.11a b g n x etc. The communication network may include without limitation a direct interconnection local area network LAN wide area network WAN wireless network e.g. using Wireless Application Protocol the Internet etc. Using the network interface and the communication network the computer system may communicate with devices and . These devices may include without limitation personal computer s server s fax machines printers scanners various mobile devices such as cellular telephones smartphones e.g. Apple iPhone Blackberry Android based phones etc. tablet computers eBook readers Amazon Kindle Nook etc. laptop computers notebooks gaming consoles Microsoft Xbox Nintendo DS Sony PlayStation etc. or the like. In some embodiments the computer system may itself embody one or more of these devices.

In some embodiments the processor may be disposed in communication with one or more memory devices e.g. RAM ROM etc. via a storage interface . The storage interface may connect to memory devices including without limitation memory drives removable disc drives etc. employing connection protocols such as serial advanced technology attachment SATA integrated drive electronics IDE IEEE 1394 universal serial bus USB fiber channel small computer systems interface SCSI etc. The memory drives may further include a drum magnetic disc drive magneto optical drive optical drive redundant array of independent discs RAID solid state memory devices solid state drives etc.

The memory devices may store a collection of program or database components including without limitation an operating system user interface application web browser mail server mail client user application data e.g. any data variables or data records discussed in this disclosure etc. The operating system may facilitate resource management and operation of the computer system . Examples of operating systems include without limitation Apple Macintosh OS X UNIX Unix like system distributions e.g. Berkeley Software Distribution BSD FreeBSD NetBSD OpenBSD etc. Linux distributions e.g. Red Hat Ubuntu Kubuntu etc. IBM OS 2 Microsoft Windows XP Vista 7 8 etc. Apple iOS Google Android Blackberry OS or the like. User interface may facilitate display execution interaction manipulation or operation of program components through textual or graphical facilities. For example user interfaces may provide computer interaction interface elements on a display system operatively connected to the computer system such as cursors icons check boxes menus scrollers windows widgets etc. Graphical user interfaces GUIs may be employed including without limitation Apple Macintosh operating systems Aqua IBM OS 2 Microsoft Windows e.g. Aero Metro etc. Unix X Windows web interface libraries e.g. ActiveX Java Javascript AJAX HTML Adobe Flash etc. or the like.

In some embodiments the computer system may implement a web browser stored program component. The web browser may be a hypertext viewing application such as Microsoft Internet Explorer Google Chrome Mozilla Firefox Apple Safari etc. Secure web browsing may be provided using HTTPS secure hypertext transport protocol secure sockets layer SSL Transport Layer Security TLS etc. Web browsers may utilize facilities such as AJAX DHTML Adobe Flash JavaScript Java application programming interfaces APIs etc. In some embodiments the computer system may implement a mail server stored program component. The mail server may be an Internet mail server such as Microsoft Exchange or the like. The mail server may utilize facilities such as ASP ActiveX ANSI C C Microsoft .NET CGI scripts Java JavaScript PERL PHP Python WebObjects etc. The mail server may utilize communication protocols such as internet message access protocol IMAP messaging application programming interface MAPI Microsoft Exchange post office protocol POP simple mail transfer protocol SMTP or the like. In some embodiments the computer system may implement a mail client stored program component. The mail client may be a mail viewing application such as Apple Mail Microsoft Entourage Microsoft Outlook Mozilla Thunderbird etc.

In some embodiments computer system may store user application data such as the data variables records etc. as described in this disclosure. Such databases may be implemented as fault tolerant relational scalable secure databases such as Oracle or Sybase. Alternatively such databases may be implemented using standardized data structures such as an array hash linked list struct structured text file e.g. XML table or as object oriented databases e.g. using ObjectStore Poet Zope etc. . Such databases may be consolidated or distributed sometimes among the various computer systems discussed above in this disclosure. It is to be understood that the structure and operation of the any computer or database component may be combined consolidated or distributed in any working combination.

The specification has described a method and a system for sequential testing across a plurality of devices. The illustrated steps are set out to explain the exemplary embodiments shown and it should be anticipated that ongoing technological development will change the manner in which particular functions are performed. These examples are presented herein for purposes of illustration and not limitation. Further the boundaries of the functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternative boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed. Alternatives including equivalents extensions variations deviations etc. of those described herein will be apparent to persons skilled in the relevant art s based on the teachings contained herein. Such alternatives fall within the scope and spirit of the disclosed embodiments. Also the words comprising having containing and including and other similar forms are intended to be equivalent in meaning and be open ended in that an item or items following any one of these words is not meant to be an exhaustive listing of such item or items or meant to be limited to only the listed item or items. It must also be noted that as used herein and in the appended claims the singular forms a an and the include plural references unless the context clearly dictates otherwise.

Furthermore one or more computer readable storage media may be utilized in implementing embodiments consistent with the present disclosure. A computer readable storage medium refers to any type of physical memory on which information or data readable by a processor may be stored. Thus a computer readable storage medium may store instructions for execution by one or more processors including instructions for causing the processor s to perform steps or stages consistent with the embodiments described herein. The term computer readable medium should be understood to include tangible items and exclude carrier waves and transient signals i.e. be non transitory. Examples include random access memory RAM read only memory ROM volatile memory nonvolatile memory hard drives CD ROMs DVDs flash drives disks and any other known physical storage media.

It is intended that the disclosure and examples be considered as exemplary only with a true scope and spirit of disclosed embodiments being indicated by the following claims.

