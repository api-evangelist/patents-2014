---

title: Method for executing an application in a restricted operating environment
abstract: A user is presented with one or more user-level permissions in a human understandable language, where the one or more user-level permissions represent one or more application-level permissions requested from an application for accessing one or more resources. A security profile is generated having one or more operating system (OS)-level permissions based on at least one of the user-level permissions authorized by the user. The security profile is enforced to restrict the application to accessing the one or more resources based on the OS-level permissions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09390241&OS=09390241&RS=09390241
owner: APPLE INC.
number: 09390241
owner_city: Cupertino
owner_country: US
publication_date: 20140102
---
This application is a continuation of U.S. patent application Ser. No. 13 183 820 filed Jul. 15 2011 which is a non provisional of U.S. Provisional Patent Application No. 61 493 271 filed Jun. 3 2011 all of which are incorporated by reference herein in their entirety.

Embodiments of the present invention relate generally to the field of secure computing. More particularly embodiments of the invention relate to configuring an application to be executed in a restricted operating environment.

Security concerns for all types of processor based electronic devices and particularly for computing devices have become a significant concern. While some concerns may relate to detrimental actions which may be undertaken by defective code implemented by such devices the greater concerns relate to the ramifications of various types of attacks made upon such devices through malicious code including code conventionally known in the field by a number of names including viruses worms Trojan horses spyware adware and others. Such malicious code can have effects ranging from relatively benign such as displaying messages on a screen or taking control of limited functions of a device to highly destructive such as taking complete control of a device running processes transmitting and or deleting files etc. Virtually any type of imaginable action on a processor based device has been the subject of attacks by malicious code.

Many of these attacks are directed at computing devices such as workstations servers desktop computers notebook and handheld computers and other similar devices. Many of these computing devices can run one or more application programs which a user may operate to perform a set of desired functions. However such attacks are not limited to such computing devices. A broader group of various types of devices such as cell phones personal digital assistants PDA s music and video players network routers switches or bridges and other devices utilizing a microprocessor microcontroller or a digital signal processor to execute coded instructions have been the subjects of attacks by malicious code.

A number of methodologies have been used in an attempt to reduce or eliminate both the attacks and influence of malicious or defective code. Generally these methodologies include detection prevention and mitigation. Specifically these methodologies range from attempts to scan identify isolate and possibly delete malicious code before it is introduced to the system or before it does harm such as is the objective of anti virus software and the like to restricting or containing the actions which may be taken by processes affected by malicious or defective code.

When an application is to be executed a user may be prompted whether the execution of the application should be allowed or denied entirely. There is a lack of efficient way to configure in a finer grained fashion whether a particular action to be performed by the application is allowed. In addition a permission to allow an application to perform a particular action is typically configured at a low level such as an operating system OS level that is not human understandable. There has been a lack of mechanism to convey permission information to a user at a higher level that is human understandable.

Various embodiments and aspects of the inventions will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However in certain instances well known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

According to some embodiments a mechanism is provided to help a user to conveniently select what permissions the user wishes to grant to executable code such as an application an applet or an application plugin. Permissions requested by an application also referred to as application level permissions are translated into higher level human understandable user level permissions. The user level permissions are presented to the user as one or more permission blocks where a permission block is a high level concept which enables a user comprehensible function such as the ability to print a document open a document etc. Permission blocks are made up of OS level permissions that are needed to provide the user functionality e.g. read access on a directory on a file etc. 

When the application is to be launched or a plug in is to be loaded a request for permissions is made by the appropriate loader and the user is notified of user level permissions representing the requested application level permissions. In response to user inputs representing authorization to grant or deny some or all of the presented user level permissions OS level permissions are generated based on the granted user level permissions. A security profile is generated based on the granted OS level permissions and the security profile is enforced during execution of the application to restrict the application accessing resources permitted by the OS level permissions of the security profile. As a result the user is presented with useful and understandable information concerning what permissions have been granted to the application without having to understand the application level and or OS level permissions.

API may be implemented as a system API to allow any of client applications such as application to communicate with security framework . Application can be any kind of application such as a standalone application. Alternatively application may be a plug in application or applet that is hosted within another application. For example application may be a Java applet embedded within a Web page hosted or processed by a browser application where the Web page may be downloaded from a variety of information or service provider servers such as Web servers. In this example a Java applet communicates with the browser application via a corresponding agent or plug in e.g. Java plug in where the browser application communicates with security framework via a system API e.g. API . Some applets may include photo uploaders and picture takers interactive maps that show a user s real time location or collaborative document editors.

In one embodiment application includes information describing one or more permissions requested and or required by application referred to herein as application level permissions . Application level permissions refer to the permissions requested by application for accessing one or more resources of system during execution of application . Application level permissions may be specified by a developer or administrator of application . Application level permissions are typically specified in a format that is compatible with the API in a programming language of application . Application level permissions may or may not be described in a human understandable manner.

In one embodiment application level permissions include a first portion of one or more permissions that are required by application and a second portion of one or more permissions that are optionally required by application during execution of application . That is the required permissions represent the permissions an application needs in order to perform its basic functions. An example of such a required permission for an application such as a photo editor application includes a permission to access files in the user s home directory on the file system. The optional permissions represent those permissions the application would benefit from having but whose absence will still allow the application to perform its basic functions. An example of such an optional permission is a permission to print a picture. As another example an instant messaging application would require access to connect over a network to an instant messaging server but would optionally request access to the system s microphone and camera.

In one embodiment application level permissions may be embedded within the source code of an application or as metadata of the application. is an example of a hypertext mark up language HTML script representing a Web based application such as a Java applet. Script includes a security tab having zero or more required permissions and zero or more optional permissions requested by application . Permissions may be specified or programmed by a developer of application . Note that the format as shown in is described in view of an HTML application. The formats may be different for other types of programming languages.

Referring back to according to one embodiment when application is to be loaded an application loader that is responsible for loading application not shown is configured to extract metadata representing application level permissions from application including determining the required application level permissions and optional application level permissions requested by application . As described above application can be a standalone application which may be loaded by an application loader of an operating system. Alternatively application can be an applet e.g. Java applet hosted by a hosting application e.g. browser . In this situation a plug in of the hosting application is responsible for loading application .

In one embodiment prior to loading application the application loader is configured to determine whether the requested permissions are to be granted by the system. Application may only be loaded if at least the required application level permissions are granted. In one embodiment in response to a request to load application the application loader is configured to extract and transmit application level permissions to security framework via API . Based on application level permissions permission mapping module is configured to map the application level permissions to user level permissions using permission mapping table . The mapped user level permissions are then presented to a user via user interface including zero or more required user level permissions and zero or more optional user level permissions . In one embodiment the user level permissions are described in human or user understandable language images iconography or other representation such that when presented to a user the user can easily understand what permissions are being sought by the application without having to understand the low level application level permissions and or OS level permissions used by the application developers or the operating system.

As can be shown user level permissions are described using certain user understandable terms language or other expression while OS level permissions may be described in lower level terms e.g. machine or OS understandable terms that an ordinary user would have a hard time understanding. Application level permissions may be specified in a manner dependent upon the specific API and application programming languages. Thus the formats or terms used in application level permissions may be different for different APIs and programming languages. In one embodiment different APIs or programming languages may use different permission mapping tables or data structures.

Referring back to according to one embodiment based on application level permissions requested by application permission mapping module is configured to convert the application level permissions to user level permissions using permission mapping table and present the user level permissions to a user via user interface for user authorization. The presented user level permissions include required user level permissions and optional user level permissions . From user interface a user can grant or deny some or all of the requested permissions.

Note that permissions are optional permissions and that without them the application can still perform its basic functions. A user can optionally grant or deny any of permissions via the associated checkboxes and the application can still function with or without the optional features or functions permitted by optional permissions . However if the user denies required permission for example by clicking the cancel button the application may not function and may be prevented from loading.

According to one embodiment once the permissions have been configured and the user positively confirms the granting of the permissions for example by clicking the OK button a security profile is dynamically generated. The security profile includes at least the granted permissions listed in OS level permissions which are translated or converted from user level permissions . The security profile may also include permissions implicitly granted by the operating system or security manager. The security profile is then used by the OS or a security manager e.g. sandbox manager to enforce the permissions set forth in the security profile to limit the associated application operating in a restricted operating environment.

The security profile may be loaded in a system memory e.g. random access memory or RAM and used by the OS. Thus the security is generated and temporarily loaded for the current instance of the application. Once the application is unloaded the security profile may be unloaded or erased from the memory. When the same application is loaded again at a future time the above processes may be performed again and a new profile may be generated for the new instance of the application.

According to one embodiment an option is provided to allow a user to specify whether the security profile should be saved to a persistent storage location such as a hard drive of the system. The security profile may be stored in an encrypted form or be invisible to the user. If the user enables the option the security profile is stored in a persistent storage location. In this situation the security framework also maintains a database or table indicating which profile is associated with each application. An application may be identified based on a variety of identifiers or indicators.

Subsequently when an application is about to be loaded an identifier of the application is used to determine whether a security profile has been previously created and stored in a persistent storage. Several mechanisms can be used to identify the application including its name a programmatic identifier inside it s binary or bundle a code signing certificate chain used to sign the application or other criteria. If a previous security profile has been identified permissions currently requested by the application and the permissions previously granted are compared to determine whether the same or greater requested permissions have been previously granted to the same application. Note that a security profile may include information identifying the permissions previously requested and permissions previously granted.

If the currently requested permissions are different than the previously requested permissions according to one embodiment a GUI page such as the one as shown in may be displayed requesting a user to confirm the authorization of the new permissions requested. In addition according to one embodiment if certain optional permissions were previously requested the GUI page may still be displayed to confirm whether the user wishes to grant the optional permissions this time around. In some situations a user may have granted an optional permission during a previous execution of the application but the user may not want to grant the same optional permission in a subsequent execution of the application. The new settings may be updated in the security profile dependent upon whether the user indicates that the new settings should be saved in a persistent security profile. Furthermore the security profile may be removed or erased from the persistent storage if the user denies all the permissions requested.

If the request permissions have been previously granted based on the security profile at block the same permissions are enforced based on the security profile during execution of the current instance of the application without a need to prompt a user for authorizing the requested permissions. If the requested permissions have not been previously granted e.g. the currently requested permission s are not listed in the security profile or listed but not granted in the security profile at block the requested permissions are presented to a user for authorization for example using a permission mapping module such as that illustrated in block in and GUI similar to the one as shown in . At block a new security profile is generated based on the user input. Alternatively an existing security profile may be updated based on the user input. At block the security profile is enforced.

As shown in the computer system which is a form of a data processing system includes a bus or interconnect which is coupled to one or more microprocessors and a ROM a volatile RAM and a non volatile memory . The microprocessor is coupled to cache memory . The bus interconnects these various components together and also interconnects these components and to a display controller and display device as well as to input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art.

Typically the input output devices are coupled to the system through input output controllers . The volatile RAM is typically implemented as dynamic RAM DRAM which requires power continuously in order to refresh or maintain the data in the memory. The non volatile memory is typically a magnetic hard drive a magnetic optical drive an optical drive or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically the non volatile memory will also be a random access memory although this is not required.

While shows that the non volatile memory is a local device coupled directly to the rest of the components in the data processing system the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art. In one embodiment the I O controller includes a USB Universal Serial Bus adapter for controlling USB peripherals. Alternatively I O controller may include an IEEE 1394 adapter also known as FireWire adapter for controlling FireWire devices.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as those set forth in the claims below refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the invention also relate to an apparatus for performing the operations herein. Such a computer program is stored in a non transitory computer readable medium. A machine readable medium includes any mechanism for storing information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices .

The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software e.g. embodied on a non transitory computer readable medium or a combination of both. Although the processes or methods are described above in terms of some sequential operations it should be appreciated that some of the operations described may be performed in a different order. Moreover some operations may be performed in parallel rather than sequentially.

Embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

