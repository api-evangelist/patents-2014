---

title: Distributed tasks for retrieving supplemental job information
abstract: A method to assist with processing distributed jobs by retrieving and/or synchronizing supplemental job data. The method includes receiving a request to perform a job and opening a long-lived connection and a short-lived connection between a primary machine and a secondary machine, and transmitting by the primary machine a request pertaining to the job to the secondary machine using the short-lived connection, the job to be performed by the secondary machine. The method also includes receiving by the primary machine using the long-lived connection a task request for supplemental information pertaining to the job, transmitting by the primary machine a task response including the supplemental information to the secondary machine, and receiving a job result for the job using the short-lived connection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09128779&OS=09128779&RS=09128779
owner: SPLUNK INC.
number: 09128779
owner_city: San Francisco
owner_country: US
publication_date: 20140731
---
The present disclosure relates to distributed jobs and more particularly to retrieving or synchronizing supplemental job information between multiple machines to enable the performance of the job.

Modern data centers often comprise thousands of hosts that operate collectively to service requests. During operation some hosts may fragment a request into multiple jobs and distribute the jobs to other hosts to be processed. In some situations the processing host may require additional data to complete the job. The additional data may be inaccessible to the processing host for example it may exist on a different host or require an interaction with a user. In this situation an error is often produced and the job may need to be resubmitted.

The present disclosure relates to a method of retrieving and synchronizing information between multiple machines to assist with processing distributed jobs. The method may involve a primary machine that distributes jobs to one or more secondary machines to be processed. The jobs may be search jobs that include search queries that when executed generate search results. Prior to the completion of a job the secondary machine may determine that supplemental job data may be useful to complete the job. The supplemental data may exist on another machine or may require an interaction with a user.

The primary machine and secondary machines may exchange the supplemental job data by utilizing distributed tasks in the form of task requests and their respective task responses. The task requests may be transmitted from the secondary machine to the primary machine and may pertain to specific items of information or specific entries in a data store e.g. table or database . The primary machine may fulfill these requests and transmit the supplemental information within task responses. The secondary machine may use the supplemental information to complete the job and may also store it locally to be reused for other jobs. In one example the task requests and task responses may be utilized to synchronize a data store e.g. a table a database a file etc. that includes supplemental information across multiple machines.

The primary and secondary machines may be interconnected using multiple connections for example the machines may be connected by short lived connections and long lived connections. A short lived connection may refer to a connection that exists for the duration of a dispatched job and is terminated when the dispatched job is completed whereas a long lived connection refers to a connection that may persist for more than one job. In one example the long lived connection may be a persistent connection that endures for the duration of all jobs performed between a set of machines and if the long lived connection were interrupted the machines would recreate it.

The short lived and long lived connections may handle different types of data in different quantities and formats. For example a short lived connection may handle transmitting job requests and their respective job results whereas the long lived connections may be dedicated to transmitting task requests for supplemental job information. Separating the types of information that traverse a connection may allow the system to have a receiver that is optimized to parse the specified format or to prioritize the transmission of certain information. For example if a job begins producing a data set which is being streamed over the short lived connection it may be more efficient to send a task request for additional information necessary to complete the job over a long lived connection which may be less utilized or may be prioritized to result in a faster turnaround time.

In one example the primary machine may be a search head configured to distribute search jobs to a plurality of indexer machines that function as secondary machines. A search head may refer to a component that is responsible for a reduce phase of a map reduce search and indexers may refer to components that are responsible for a map phase of the map reduce search as further described below. The primary machines may be interconnected with the secondary machines in a manner that restricts the secondary machines from initiating connections with the primary machine for example to enhance security privacy and or performance. Despite this the primary machine may be capable of initiating connections with the secondary machines. The connections may include short lived Hyper Text Transfer Protocol HTTP connections and long lived HTTP connections that utilize Representational State Transfer REST calls for transmitting data. The long lived connection may be configured without a timeout or may be kept alive or recreated if it is interrupted similar to an HTTP persistent connection. The job requests and responses as well as their associated task requests and responses may be transmitted over these connections in a JSON format.

In another example the primary machine and the secondary machines may be part of a data aggregation and analysis system that can aggregate heterogeneous machine generated data received from various sources including servers databases applications networks etc. The system can be configured to perform real time indexing of the source data and to execute real time scheduled or historic searches on the source data. The heterogeneous machine generated data that is being searched can include for example logs that track login attempts that end users make when logging into various applications e.g. email application customer relationship management CRM application human capital management HCM application etc. . A user may wish to receive for instance up to date information indicating how many attempts have failed and can initiate a search query to obtain results indicating the attempts that may have failed. The indexer may search the source data using the search query and return a list of users that have failed to access an application.

In another instance the heterogeneous machine generated data may not have all the information necessary to fulfill a search query and the secondary machine may contact the primary machine to retrieve supplemental lookup information. For example a user may request to receive up to date information indicating which employees have accessed which websites. The heterogeneous machine generated data may include a web traffic log which may include source IP addresses destination IP addresses and the destination web site names. In order to fulfill the user request the secondary machine may need additional data that resolves the source IP addresses to employees. This translation information may exist in a data store on the primary server and may be obtained by the secondary machine using distributed tasks. Once this information is obtained the secondary machine may use this information to translate e.g. map link correlate associate the source IP addresses in the web log to employees and determine which employees accessed which web sites in order to fulfill the user s request.

As discussed above the secondary machine may use the distributed tasks to fetch information from a remote data store. In addition the secondary machine may store the retrieved information in a local data store to keep the remote and local data stores synchronized. In one example there may be a remote lookup data store on the primary machine and a local lookup data store on the secondary machine. As time elapses entries may be added to the remote data store without being added to the local data store. When a job references the additional entries the secondary machine may determine these entries are not in the local lookup data store and send a task request to retrieve the information from the remote data store. When the secondary machine receives the task response with the information it may store the information in the local data store and thus keep the local data store in partial synchronization with the remote data store.

Frequently in this disclosure examples directed to jobs and or tasks in a JSON format or transmitted using REST architecture over HTTP connections are presented. This is done for ease of explanation of some of the features described herein. However embodiments with other formats and using other architectures are also within the scope of this disclosure regardless of whether specific examples of such are provided herein.

Connections A N and may be communication channels that couple the primary machine with secondary machine . Connections A N may be short lived connections which may exist for the duration of a dispatched job. The short lived connection may handle transmitting job requests and their respective job results. Each short lived connection may be initiated by its respective job manager module A N to transmit a job from the primary machine to the secondary machine . Once the secondary machine finishes performing a job the job result may be transmitted back over the same short lived connection and the connection may be subsequently closed. In one example job manager A may initiate the connection by sending an HTTP POST request.

Connection may be a long lived connection that persists for a duration of time that is substantially longer than a short lived connection. In one example the connection may persist for the duration of time that the two machines are configured to function together to process distributed jobs. This may extend beyond a connection interruption e.g. machine failure or reboot in which case once the machines are operational the connection may be re established. In one example primary machine may initiate connection with secondary machine by making a REST GET call to management module .

Primary machine may function as a central machine or distribution machine and may dispatch jobs to secondary machines . In one example the primary machine may be a search head e.g. in a SPLUNK architecture discussed below and may process a user search request by distributing the search across multiple indexer machines.

User interface module may receive user information requests and present results to the user for example user interface module may be a web module configured to provide a web interface or user interface document to the user. The user interface module may be communicably coupled with distribution module and may transmit user requests to the distribution module . In one example the user interface module may communicate with the distribution module by invoking REST endpoints to send a search query.

Distribution module may receive user requests from the user interface module and may segment the request into multiple jobs. Distribution module may then initiate one or more job managers A N to manage the jobs. In one example distribution module may spawn job managers A N as separate child processes on the same machine e.g. primary machine and subsequently distribute the jobs to them. Distribution module may also monitor the returned job results and set up dispatch directories e.g. folders data stores files to store and aggregate the results.

Distribution module may also handle receiving and resolving task requests for supplemental job information. This may include initiating long lived connection between primary machine and secondary machine to receive the task requests. The task requests may be received individually or they may be batched together and transmitted as a continuous stream of task requests. In one example a new long running connection may be created when distribution module makes an HTTP GET call. As a result of the GET call the distribution module may receive a list of task requests. The list of tasks may be read entry by entry wherein each entry is a separate task associated with the same job executor or associated with a different job executors e.g. A N .

Job managers A N may be responsible for transmitting jobs received from distribution module to secondary machines for processing. Job managers A N may initiate short lived communication channel A N with secondary machines . Each short lived connection may exist for the duration of time the job is being processed. For example the short lived connection may be created to send over a job and once the job results are received the job manager may close the connection.

Each job manager A N may be capable of setting up the job and processing the job results. Setting up the job may include breaking the job into separate smaller jobs e.g. job fragments job segments job portions which may be processed independently from one another. Each smaller job may involve accessing different data sources and or each smaller job may run on different secondary machines. The job manager may create the new job locally and then transmit the job to create the job on the remote machine for example job manager A N may send an HTTP POST request to secondary machine to create the job. The job manager may also process the job results as they are streamed back from the secondary machine. In one example each job may result in a separate pipeline streamed over a short lived connection.

As shown in each job manager has a single short lived connection with secondary machine however in another example each job manager A N may have a short lived connection with a different secondary machine. In addition a single job manager may have multiple connections each with a different secondary machines to which it sends a portion of the job.

Secondary machine may function as a distribution node or processing node and may receive jobs from primary machine and return the job results. Secondary machine may include a management module one or more job executors A N and data store . In one example the secondary machine may be a search indexer in a SPLUNK architecture.

Management module may manage the secondary machine s interactions with primary machine . This may include managing network connections tasks e.g. requests and responses and job processing. Managing network connection may include receiving a request from the primary machine to initiate a network connection and subsequently establishing e.g. opening creating a connection e.g. HTTP TCP or UDP . Managing job processing may include receiving incoming job requests and creating one or more job executors A N to process the job. In one example management module may spawn job executors A N as separate child processes on the same machine and subsequently transmit the jobs to them to be executed.

Managing tasks may include organizing and processing the task requests and task responses. The task requests may be received from one or more job executors A N. The task requests may then be organized by management module into a list queue array or other similar data structure. This list may include information e.g. GUID Globally Unique Identifier or other similar identifier that allows the management module to identify each task and determine which job the task is associated with for example the list may include an ID of the task request and an ID of the Job. After generating the list management module may determine the appropriate primary machine s to receive the task requests. This determination may be based on which primary machine sent the corresponding job. It may also depend on the primary machine s ability to access the target data location e.g. data store which may be inferred based on the failure or success of previous task responses e.g. analysis of error messages .

In one example management module may send the same task request to multiple primary machines in an attempt to decrease the fulfillment time. The management module may then process the results from the primary machine that responded first and either inform the other machines to abort or ignore their subsequent task response.

Job executors A N may function to perform the job and return the results to the management module . In one example performing a job includes executing the search by querying an index for index entries and returning the search results in the form of a data pipeline e.g. stdout or HTTP out .

Data stores and may be communicatively coupled to some or all of the modules on their respective machines and may be used to store supplemental information pertaining to the distributed jobs. The data store may be a single file CSV file or combination of multiple files or it may be a database e.g. relational database . In one example primary data store may store lookup information that may be accessed by the job executor to assist with processing the jobs.

Data stores and may be remotely accessed or synchronized using distributed tasks e.g. task requests and task responses . The synchronization may be either one way or two way i.e. duplex and it may be based on a pull mechanism push mechanism or hybrid of both. One way synchronization may occur for example when data store information is transmitted from a master e.g. primary data store to a replica e.g. secondary data store without data store information being transmitted from the replica to the master. Two way synchronization may result in data store information being transmitted from the replica to master and master to replica. A pull mechanism may exist when the replica requests information from the master whereas a push mechanism may have the master send the data to the replica at a time chosen by the master. In one example synchronizing data stores and may comprise a pull based one way synchronization for example the data store on the secondary machine may utilize task request to pull supplemental information from the primary machine without sending supplemental information from the secondary store to the primary store.

Primary machine and secondary machine may be separate computing devices or they may be hosted on the same computing device. In one example primary machine may be a first virtual machine and secondary machine may be a second virtual machine and both the first and second virtual machines may be run on the same host or different hosts.

In one example primary machine may utilize a REST GET endpoint to initiate long lived connection with secondary machine . The GET call may result in the secondary machine transmitting all of its unresolved tasks for example those included on the task list stored by the management module . In addition each time a new task is created on the secondary machine it may be transmitted and sent over long lived connection .

To avoid excessive or irrelevant task requests the machines may include a task filtering component. The task filtering component may be included within distribution module of the primary machine and or within the management module of the secondary machine. The task filtering component may function to parse out or filter out the task requests and or task responses that are irrelevant to the receiving machine. This may be useful when a machine is connected to multiple machines because it may reduce the quantity of task requests and task responses to only those the machine is responsible for processing.

As seen in after the machines have been configured the primary machine may receive a user request e.g. search query from a user. The distribution module then may create e.g. spawn job manager A to process the user s request. Job manager A may then initiate short lived connection A and transmit job to the management module e.g. splunk daemon of secondary machine . The management module may then create job executor A to perform the job. In one example job may be a search job in a JSON format and it may be transmitted to the secondary machine using an HTTP POST request.

As seen in job executor A may begin processing job as shown by circular arrow and may determine it requires supplemental job information in order to complete the execution of job . Job executor A may then create a new distributed task and send it to management module . The task request may include a task identifier e.g. GUID and may identify a specific object e.g. IP address machine user for which supplemental information is being retrieved. This information may be in computer readable or human readable format such as for example JSON XML HTML ASCII or Unicode.

In one example job executor A may create task request by making an HTTP POST call to the management module on the same machine. This POST call may avoid creating an additional HTTP connection since the destination is on the same machine and instead it may stream data to HTTP out which may be received by the management module. HTTP out may be a stream similar to a standard stream e.g. standard out stdout standard in stdin or standard error stderr which may allow processes on a machine to communicate with other processes running on the same machine without initiating a connection with the receiving process. The POST call may include JSON data in the following format receiver foo.com type state store lookup data 192.168.0.101 wherein foo.com is the name of a primary machine and 192.168.0.101 is the lookup key value. The lookup key value may match the key of an entry in a table or database on the remote machine e.g. primary machine . Job executor A may then block this connection with the management module so that it remains open until the task response is received by the job executor A at which point it may close the connection.

Management module may compile and store a list of unresolved distributed tasks which may include task request as well as task requests from other job executors. Management module may transmit distributed task request along with the other task requests in the list over long lived connection . In one example the task requests may be transmitted as a streamed response to the HTTP GET request that was used to initiate the long lived connection during the setup procedure.

Distribution module may receive the task requests and may include a parsing component for distinguishing separate and independent tasks. Separate tasks may be tasks that can be resolved independently of one another yet may be affiliated with the same job job executor or job manager. Independent tasks are tasks that are not affiliated with the same job and may originate from a different job executors or job manager. The parsing component may distinguish tasks by detecting for example the end of a JSON structure or a specific control character used to indicate the beginning or end of a task request e.g. carriage return newline line feed . In addition the parsing component may detect whether the tasks are affiliated with the same job by analyzing identification information which may be included within the task request. e.g. the GUID of the job . In one example the distribution module may receive a task list as a continuous stream of task requests and may use the parsing component to read the task requests entry by entry and each entry may be for a separate and independent task.

The distribution module on primary machine may then resolve each task request by fetching the supplemental job information from for example data store or from any other accessible storage location. Alternatively primary machine may determine that the supplemental job information is not accessible to the primary machine. In this case it may either communicate with another machine e.g. primary or secondary machine or it may notify the user that the supplemental job information is needed for example via user interface module .

Once the supplemental job information has been fetched the distribution module may package and transmit the information to secondary machine within task response . If the supplemental job information is not available the distribution module may still respond and resolve e.g. complete the task request however the task request may be resolved with an error or fail result. The task response may be transmitted to the management module over connection which may be a short lived connection similar to connection A. As an alternative the task response may be transmitted over the same long lived connection that transmitted the task request e.g. connection . In one example the primary machine may resolve each task request by sending task result as an HTTP POST request with supplemental job information or error message within the body of the response.

Management module may then transmit the task result received from the distribution module to the appropriate job executor in this case job executor A. This may allow job executor A to obtain the supplemental job information and complete the execution of job . In addition management module or job executor A may store the supplemental information in secondary data store to be accessed by other job executors.

In addition to providing supplemental information system may use the distributed tasks e.g. task requests and task responses to perform data store synchronization across multiple machines. In one example synchronizing data stores and may comprise a pull based one way synchronization for example the data store on the secondary machine may utilize task request to pull supplemental information from the primary machine without sending supplemental information from the secondary store to the primary store. An example of a pull synchronization is one in which the secondary data store e.g. replica requests that the primary data store e.g. master send missing or updated data store information.

As seen in job result may be transmitted from secondary machine to primary machine over short lived connection A. The job result may include information e.g. events gathered by job executor A and streamed via stdout to management module . Management module may then stream the results as an HTTP response to the initial HTTP POST that created the job. As shown in the job and its job results may be transmitted over the same connection however in another example the job results may be sent over a different short lived connection.

Primary machine and secondary machine may be capable of processing multiple jobs concurrently. As shown in distribution module may spawn a second job manager B which may process a second job. Job manager B may initiate a second short lived connection B to transmit a job to secondary machine . Management module may receive the job and initiate a second job executor B. Although the second job may be different than job and executed by a different job executor it may require the same supplemental job information. As discussed above the supplemental information may have been stored in data store when job executor A requested it and may be accessible to job executor B thus avoiding the transmission of additional task requests.

System may be scaled up to include multiple primary machines and multiple secondary machines for increased performance and or fault tolerance. Each primary machine may be configured to dispatch jobs to multiple secondary machines . In this case the primary machine may have a long lived connection to each secondary machine for example if the primary machine dispatches its jobs to 10 separate machines the primary machine may have 10 long lived connections. In addition each secondary machine may be configured to receive dispatched jobs from one or more primary machines. As such the secondary machine may have a long lived connection with each primary machine for example if the secondary machine receives jobs from 3 different primary machines it may have three long lived connections one with each of the three primary machines. In one example although a machine may have multiple long lived connections it may only have a single long lived connection with a specific machine and as such there may only be one long lived connection between any and all pairs of machines.

When a primary machine has connections with multiple secondary machines the job managers A B on the primary machine may each manage a job on a different secondary machine. In one example job manager A may dispatch a job to secondary machine whereas job manager B may dispatch its job to a different secondary machine. Likewise job executors A B on the secondary machine may execute jobs that have been dispatched by different primary machines for example job executor A may process a job from primary machine as shown in however job executor B may process a job from another primary machine.

At block the computing machine e.g. primary machine or search head opens long lived connection with secondary machine long lived connection being dedicated to task requests. Long lived connection may be an HTTP connection transmitting data in accordance with a REST architecture and opening the long lived connection may involve initiating an HTTP GET call and establishing a persistent HTTP connection. The data received over the long lived connection may be a stream of separate task requests in a Java Script Object Notation JSON format.

Next at block the computing machine may open a short lived connection A N with secondary machine . The short lived connection may be an HTTP connection transmitting data in accordance with a REST architecture. In one example secondary machine may be prevented from initiating a connection with primary machine for example the network infrastructure e.g. switches routers proxy servers connecting machines and or software running on the machines e.g. firewall may restrict the type of connections based on the protocols ports or IP addresses used for the connection. As a result both the short lived and long lived connection may be initiated by the primary machine instead of the secondary machine. The long lived connection may be opened before the short lived connection and may persist beyond the closing of the short lived connection.

At block the computing machine may use short lived connection A N to transmit job to secondary machine and secondary machine may perform the job. The job may for example include a search query and produce search results including a dataset derived using a late binding schema.

Then at block the computing machine may receive over long lived connection a task request for supplemental job information pertaining to job . The task requests may be received only over long lived connection without being received over any other connection. Long lived connection may be a one way connection in that it is dedicated to receiving tasks from the secondary machine without transmitting tasks to the secondary machine.

At block the computing machine may transmit a task response which includes the supplemental information to secondary machine . In one example the computing machine may transmit task response over a third connection. This may be done by opening the third connection with secondary machine and then transmitting task response over the third connection. It may then close the third connection as if it was a short lived connection.

The computing machine may include a lookup table having entries that map IP addresses to users and one or more of these entries may be included as supplemental information within a response to the task. The computing machine may also include a primary data store and secondary machine may include secondary data store and the computing machine may use the task responses for synchronizing a portion of primary data store with secondary data store .

At block the computing machine may receive over the short lived connection a job result and may then format the results and present e.g. display them to the user. The computing machine may also close the short lived connection but may maintain the long lived connection for potential task requests associated with other jobs.

At block the computing machine e.g. secondary machine or indexer establishes long lived connection with primary machine . The establishment of a connection may not be the same as initiating a connection rather it may comprise responding to a connection request to create the connection e.g. three way handshake .

Next at block the computing machine may establish a short lived connection A N with primary machine . The short lived connection may be an HTTP connection transmitting data in accordance with a REST architecture.

At block the computing machine may receive job over short lived connection A N and may perform the job. The job may for example include a search query and produce search results derived using a late binding schema.

Then at block the computing machine may transmit over long lived connection a task request for supplemental job information pertaining to job . The task requests may be transmitted only over long lived connection without being transmitted over any other connection. Long lived connection may be a one way connection dedicated to transmitting tasks to the primary machine without receiving tasks from the primary machine.

At block the computing machine may receive a task response which includes the supplemental information from primary machine . In one example the computing machine may receive task response from the primary machine over a third connection. In another example the computing machine may receive task response over the long lived connection.

At block the computing machine may transmit over the short lived connection a job result in response to the job. The computing machine may also close the short lived connection but maintain the long lived connection for potential task requests associated with other jobs.

Aspects of the above examples may be used in combination with the SPLUNK architecture discussed below to enhance functionality and performance without reducing security and or privacy. For example the secondary machines may be able to execute jobs that may have failed in the past due to missing information and this may be accomplished without reducing security e.g. without allowing the secondary machines to initiate connections with the primary machines .

Modern data centers often comprise thousands of host computer systems that operate collectively to service requests from even larger numbers of remote clients. During operation these data centers generate significant volumes of performance data and diagnostic information that can be analyzed to quickly diagnose performance problems. In order to reduce the size of this performance data the data is typically pre processed prior to being stored based on anticipated data analysis needs. For example pre specified data items can be extracted from the performance data and stored in a database to facilitate efficient retrieval and analysis at search time. However the rest of the performance data is not saved and is essentially discarded during pre processing. As storage capacity becomes progressively cheaper and more plentiful there are fewer incentives to discard this performance data and many reasons to keep it.

This plentiful storage capacity is presently making it feasible to store massive quantities of minimally processed performance data at ingestion time for later retrieval and analysis at search time. Note that performing the analysis operations at search time provides greater flexibility because it enables an analyst to search all of the performance data instead of searching pre specified data items that were stored at ingestion time. This enables the analyst to investigate different aspects of the performance data instead of being confined to the pre specified set of data items that were selected at ingestion time.

However analyzing massive quantities of heterogeneous performance data at search time can be a challenging task. A data center may generate heterogeneous performance data from thousands of different components which can collectively generate tremendous volumes of performance data that can be time consuming to analyze. For example this performance data can include data from system logs network packet data sensor data and data generated by various applications. Also the unstructured nature of much of this performance data can pose additional challenges because of the difficulty of applying semantic meaning to unstructured data and the difficulty of indexing and querying unstructured data using traditional database systems.

These challenges can be addressed by using an event based system such as the SPLUNK ENTERPRISE system produced by Splunk Inc. of San Francisco Calif. to store and process performance data. The SPLUNK ENTERPRISE system is the leading platform for providing real time operational intelligence that enables organizations to collect index and harness machine generated data from various websites applications servers networks and mobile devices that power their businesses. The SPLUNK ENTERPRISE system is particularly useful for analyzing unstructured performance data which is commonly found in system log files. Although many of the techniques described herein are explained with reference to the SPLUNK ENTERPRISE system the techniques are also applicable to other types of data server systems.

In the SPLUNK ENTERPRISE system performance data is stored as events wherein each event comprises a collection of performance data and or diagnostic information that is generated by a computer system and is correlated with a specific point in time. Events can be derived from time series data wherein time series data comprises a sequence of data points e.g. performance measurements from a computer system that are associated with successive points in time and are typically spaced at uniform time intervals. Events can also be derived from structured or unstructured data. Structured data has a predefined format wherein specific data items with specific data formats reside at predefined locations in the data. For example structured data can include data items stored in fields in a database table. In contrast unstructured data does not have a predefined format. This means that unstructured data can comprise various data items having different data types that can reside at different locations. For example when the data source is an operating system log an event can include one or more lines from the operating system log containing raw data that includes different types of performance and diagnostic information associated with a specific point in time. Examples of data sources from which an event may be derived include but are not limited to web servers application servers databases firewalls routers operating systems and software applications that execute on computer systems mobile devices and sensors. The data generated by such data sources can be produced in various forms including for example and without limitation server log files activity log files configuration files messages network packet data performance measurements and sensor measurements. An event typically includes a timestamp that may be derived from the raw data in the event or may be determined through interpolation between temporally proximate events having known timestamps.

The SPLUNK ENTERPRISE system also facilitates using a flexible schema to specify how to extract information from the event data wherein the flexible schema may be developed and redefined as needed. Note that a flexible schema may be applied to event data on the fly when it is needed e.g. at search time rather than at ingestion time of the data as in traditional database systems. Because the schema is not applied to event data until it is needed e.g. at search time it is referred to as a late binding schema. 

During operation the SPLUNK ENTERPRISE system starts with raw data which can include unstructured data machine data performance measurements or other time series data such as data obtained from weblogs syslogs or sensor readings. It divides this raw data into portions and optionally transforms the data to produce timestamped events. The system stores the timestamped events in a data store and enables a user to run queries against the data store to retrieve events that meet specified criteria such as containing certain keywords or having specific values in defined fields. Note that the term field refers to a location in the event data containing a value for a specific data item.

As noted above the SPLUNK ENTERPRISE system facilitates using a late binding schema while performing queries on events. A late binding schema specifies extraction rules that are applied to data in the events to extract values for specific fields. More specifically the extraction rules for a field can include one or more instructions that specify how to extract a value for the field from the event data. An extraction rule can generally include any type of instruction for extracting values from data in events. In some cases an extraction rule comprises a regular expression in which case the rule is referred to as a regex rule. 

In contrast to a conventional schema for a database system a late binding schema is not defined at data ingestion time. Instead the late binding schema can be developed on an ongoing basis until the time a query is actually executed. This means that extraction rules for the fields in a query may be provided in the query itself or may be located during execution of the query. Hence as an analyst learns more about the data in the events the analyst can continue to refine the late binding schema by adding new fields deleting fields or changing the field extraction rules until the next time the schema is used by a query. Because the SPLUNK ENTERPRISE system maintains the underlying raw data and provides a late binding schema for searching the raw data it enables an analyst to investigate questions that arise as the analyst learns more about the events.

In the SPLUNK ENTERPRISE system a field extractor may be configured to automatically generate extraction rules for certain fields in the events when the events are being created indexed or stored or possibly at a later time. Alternatively a user may manually define extraction rules for fields using a variety of techniques.

Also a number of default fields that specify metadata about the events rather than data in the events themselves can be created automatically. For example such default fields can specify a timestamp for the event data a host from which the event data originated a source of the event data and a source type for the event data. These default fields may be determined automatically when the events are created indexed or stored.

In some embodiments a common field name may be used to reference two or more fields containing equivalent data items even though the fields may be associated with different types of events that possibly have different data formats and different extraction rules. By enabling a common field name to be used to identify equivalent fields from different types of events generated by different data sources the system facilitates use of a common information model CIM across the different data sources.

During operation the forwarders identify which indexers will receive the collected data and then forward the data to the identified indexers. Forwarders can also perform operations to strip out extraneous data and detect timestamps in the data. The forwarders next determine which indexers will receive each data item and then forward the data items to the determined indexers .

Note that distributing data across different indexers facilitates parallel processing. This parallel processing can take place at data ingestion time because multiple indexers can process the incoming data in parallel. The parallel processing can also take place at search time because multiple indexers can search through the data in parallel.

System and the processes described below with respect to are further described in Exploring Splunk Search Processing Language SPL Primer and Cookbook by David Carasso CITO Research 2012 and in Optimizing Data Analysis With a Semi Structured Time Series Database by Ledion Bitincka Archana Ganapathi Stephen Sorkin and Steve Zhang SLAML 2010 each of which is hereby incorporated herein by reference in its entirety for all purposes.

Next the indexer determines a timestamp for each event at block . As mentioned above these timestamps can be determined by extracting the time directly from data in the event or by interpolating the time based on timestamps from temporally proximate events. In some cases a timestamp can be determined based on the time the data was received or generated. The indexer subsequently associates the determined timestamp with each event at block for example by storing the timestamp as metadata for each event.

Then the system can apply transformations to data to be included in events at block . For log data such transformations can include removing a portion of an event e.g. a portion used to define event boundaries extraneous text characters etc. or removing redundant portions of an event. Note that a user can specify portions to be removed using a regular expression or any other possible technique.

Next a keyword index can optionally be generated to facilitate fast keyword searching for events. To build a keyword index the indexer first identifies a set of keywords in block . Then at block the indexer includes the identified keywords in an index which associates each stored keyword with references to events containing that keyword or to locations within events where that keyword is located . When an indexer subsequently receives a keyword based query the indexer can access the keyword index to quickly identify events containing the keyword.

In some embodiments the keyword index may include entries for name value pairs found in events wherein a name value pair can include a pair of keywords connected by a symbol such as an equals sign or colon. In this way events containing these name value pairs can be quickly located. In some embodiments fields can automatically be generated for some or all of the name value pairs at the time of indexing. For example if the string dest 10.0.1.2 is found in an event a field named dest may be created for the event and assigned a value of 10.0.1.2. 

Finally the indexer stores the events in a data store at block wherein a timestamp can be stored with each event to facilitate searching for events based on a time range. In some cases the stored events are organized into a plurality of buckets wherein each bucket stores events associated with a specific time range. This not only improves time based searches but it also allows events with recent timestamps that may have a higher likelihood of being accessed to be stored in faster memory to facilitate faster retrieval. For example a bucket containing the most recent events can be stored as flash memory instead of on hard disk.

Each indexer is responsible for storing and searching a subset of the events contained in a corresponding data store . By distributing events among the indexers and data stores the indexers can analyze events for a query in parallel for example using map reduce techniques wherein each indexer returns partial responses for a subset of events to a search head that combines the results to produce an answer for the query. By storing events in buckets for specific time ranges an indexer may further optimize searching by looking only in buckets for time ranges that are relevant to a query.

Moreover events and buckets can also be replicated across different indexers and data stores to facilitate high availability and disaster recovery as is described in U.S. patent application Ser. No. 14 266 812 filed on 30 Apr. 2014 and in U.S. Application patent Ser. No. 14 266 817 also filed on 30 Apr. 2014.

Then at block the indexers to which the query was distributed search their data stores for events that are responsive to the query. To determine which events are responsive to the query the indexer searches for events that match the criteria specified in the query. This criteria can include matching keywords or specific values for certain fields. In a query that uses a late binding schema the searching operations in block may involve using the late binding scheme to extract values for specified fields from events at the time the query is processed. Next the indexers can either send the relevant events back to the search head or use the events to calculate a partial result and send the partial result back to the search head.

Finally at block the search head combines the partial results and or events received from the indexers to produce a final result for the query. This final result can comprise different types of data depending upon what the query is asking for. For example the final results can include a listing of matching events returned by the query or some type of visualization of data from the returned events. In another example the final result can include one or more calculated values derived from the matching events.

Moreover the results generated by system can be returned to a client using different techniques. For example one technique streams results back to a client in real time as they are identified. Another technique waits to report results to the client until a complete set of results is ready to return to the client. Yet another technique streams interim results back to the client in real time until a complete set of results is ready and then returns the complete set of results to the client. In another technique certain results are stored as search jobs and the client may subsequently retrieve the results by referencing the search jobs.

The search head can also perform various operations to make the search more efficient. For example before the search head starts executing a query the search head can determine a time range for the query and a set of common keywords that all matching events must include. Next the search head can use these parameters to query the indexers to obtain a superset of the eventual results. Then during a filtering stage the search head can perform field extraction operations on the superset to produce a reduced set of search results.

Upon receiving search query query processor sees that search query includes two fields IP and target. Query processor also determines that the values for the IP and target fields have not already been extracted from events in data store and consequently determines that query processor needs to use extraction rules to extract values for the fields. Hence query processor performs a lookup for the extraction rules in a rule base wherein rule base maps field names to corresponding extraction rules and obtains extraction rules wherein extraction rule specifies how to extract a value for the IP field from an event and extraction rule specifies how to extract a value for the target field from an event. As is illustrated in extraction rules can comprise regular expressions that specify how to extract values for the relevant fields. Such regular expression based extraction rules are also referred to as regex rules. In addition to specifying how to extract field values the extraction rules may also include instructions for deriving a field value by performing a function on a character string or value retrieved by the extraction rule. For example a transformation rule may truncate a character string or convert the character string into a different data format. In some cases the query itself can specify one or more extraction rules.

Next query processor sends extraction rules to a field extractor which applies extraction rules to events in a data store . Note that data store can include one or more data stores and extraction rules can be applied to large numbers of events in data store and are not meant to be limited to the three events illustrated in . Moreover the query processor can instruct field extractor to apply the extraction rules to all the events in a data store or to a subset of the events that have been filtered based on some criteria.

Next field extractor applies extraction rule for the first command Search IP 10 to events in data store including events . Extraction rule is used to extract values for the IP address field from events in data store by looking for a pattern of one or more digits followed by a period followed again by one or more digits followed by another period followed again by one or more digits followed by another period and followed again by one or more digits. Next field extractor returns field values to query processor which uses the criterion IP 10 to look for IP addresses that start with 10 . Note that events and match this criterion but event does not so the result set for the first command is events .

Query processor then sends events to the next command stats count target. To process this command query processor causes field extractor to apply extraction rule to events . Extraction rule is used to extract values for the target field for events by skipping the first four commas in events and then extracting all of the following characters until a comma or period is reached. Next field extractor returns field values to query processor which executes the command stats count target to count the number of unique values contained in the target fields which in this example produces the value 2 that is returned as a final result for the query.

Note that query results can be returned to a client a search head or any other system component for further processing. In general query results may include a set of one or more events a set of one or more values obtained from the events a subset of the values statistics calculated based on the values a report containing the values or a visualization such as a graph or chart generated from the values.

After the search is executed the search screen can display the results through search results tabs wherein search results tabs includes an events tab that displays various information about events returned by the search a statistics tab that displays statistics about the search results and a visualization tab that displays various visualizations of the search results. The events tab illustrated in displays a timeline graph that graphically illustrates the number of events that occurred in one hour intervals over the selected time range. It also displays an events list that enables a user to view the raw data in each of the returned events. It additionally displays a fields sidebar that includes statistics about occurrences of specific fields in the returned events including selected fields that are pre selected by the user and interesting fields that are automatically selected by the system based on pre specified criteria.

The above described system provides significant flexibility by enabling a user to analyze massive quantities of minimally processed performance data on the fly at search time instead of storing pre specified portions of the performance data in a database at ingestion time. This flexibility enables a user to see correlations in the performance data and perform subsequent queries to examine interesting aspects of the performance data that may not have been apparent at ingestion time.

However performing extraction and analysis operations at search time can involve a large amount of data and require a large number of computational operations which can cause considerable delays while processing the queries. Fortunately a number of acceleration techniques have been developed to speed up analysis operations performed at search time. These techniques include 1 performing search operations in parallel by formulating a search as a map reduce computation 2 using a keyword index 3 using a high performance analytics store and 4 accelerating the process of generating reports. These techniques are described in more detail below.

To facilitate faster query processing a query can be structured as a map reduce computation wherein the map operations are delegated to the indexers while the corresponding reduce operations are performed locally at the search head. For example illustrates how a search query received from a client at search head can split into two phases including 1 a map phase comprising subtasks e.g. data retrieval or simple filtering that may be performed in parallel and are mapped to indexers for execution and 2 a reduce phase comprising a merging operation to be executed by the search head when the results are ultimately collected from the indexers.

During operation upon receiving search query search head modifies search query by substituting stats with prestats to produce search query and then distributes search query to one or more distributed indexers which are also referred to as search peers. Note that search queries may generally specify search criteria or operations to be performed on events that meet the search criteria. Search queries may also specify field names as well as search criteria for the values in the fields or operations to be performed on the values in the fields. Moreover the search head may distribute the full search query to the search peers as is illustrated in or may alternatively distribute a modified version e.g. a more restricted version of the search query to the search peers. In this example the indexers are responsible for producing the results and sending them to the search head. After the indexers return the results to the search head the search head performs the merging operations on the results. Note that by executing the computation in this way the system effectively distributes the computational operations while minimizing data transfers.

As described above with reference to the flow charts in event processing system can construct and maintain one or more keyword indices to facilitate rapidly identifying events containing specific keywords. This can greatly speed up the processing of queries involving specific keywords. As mentioned above to build a keyword index an indexer first identifies a set of keywords. Then the indexer includes the identified keywords in an index which associates each stored keyword with references to events containing that keyword or to locations within events where that keyword is located. When an indexer subsequently receives a keyword based query the indexer can access the keyword index to quickly identify events containing the keyword.

To speed up certain types of queries some embodiments of system make use of a high performance analytics store which is referred to as a summarization table that contains entries for specific field value pairs. Each of these entries keeps track of instances of a specific value in a specific field in the event data and includes references to events containing the specific value in the specific field. For example an exemplary entry in a summarization table can keep track of occurrences of the value 94107 in a ZIP code field of a set of events wherein the entry includes references to all of the events that contain the value 94107 in the ZIP code field. This enables the system to quickly process queries that seek to determine how many events have a particular value for a particular field because the system can examine the entry in the summarization table to count instances of the specific value in the field without having to go through the individual events or do extractions at search time. Also if the system needs to process all events that have a specific field value combination the system can use the references in the summarization table entry to directly access the events to extract further information without having to search all of the events to find the specific field value combination at search time.

In some embodiments the system maintains a separate summarization table for each of the above described time specific buckets that stores events for a specific time range wherein a bucket specific summarization table includes entries for specific field value combinations that occur in events in the specific bucket. Alternatively the system can maintain a separate summarization table for each indexer wherein the indexer specific summarization table only includes entries for the events in a data store that is managed by the specific indexer.

The summarization table can be populated by running a collection query that scans a set of events to find instances of a specific field value combination or alternatively instances of all field value combinations for a specific field. A collection query can be initiated by a user or can be scheduled to occur automatically at specific time intervals. A collection query can also be automatically launched in response to a query that asks for a specific field value combination.

In some cases the summarization tables may not cover all of the events that are relevant to a query. In this case the system can use the summarization tables to obtain partial results for the events that are covered by summarization tables but may also have to search through other events that are not covered by the summarization tables to produce additional results. These additional results can then be combined with the partial results to produce a final set of results for the query. This summarization table and associated techniques are described in more detail in U.S. Pat. No. 8 682 925 issued on Mar. 25 2014.

In some embodiments a data server system such as the SPLUNK ENTERPRISE system can accelerate the process of periodically generating updated reports based on query results. To accelerate this process a summarization engine automatically examines the query to determine whether generation of updated reports can be accelerated by creating intermediate summaries. This is possible if results from preceding time periods can be computed separately and combined to generate an updated report. In some cases it is not possible to combine such incremental results for example where a value in the report depends on relationships between events from different time periods. If reports can be accelerated the summarization engine periodically generates a summary covering data obtained during a latest non overlapping time period. For example where the query seeks events meeting a specified criteria a summary for the time period includes only events within the time period that meet the specified criteria. Similarly if the query seeks statistics calculated from the events such as the number of events that match the specified criteria then the summary for the time period includes the number of events in the period that match the specified criteria.

In parallel with the creation of the summaries the summarization engine schedules the periodic updating of the report associated with the query. During each scheduled report update the query engine determines whether intermediate summaries have been generated covering portions of the time period covered by the report update. If so then the report is generated based on the information contained in the summaries. Also if additional event data has been received and has not yet been summarized and is required to generate the complete report the query can be run on this additional event data. Then the results returned by this query on the additional event data along with the partial results obtained from the intermediate summaries can be combined to generate the updated report. This process is repeated each time the report is updated. Alternatively if the system stores events in buckets covering specific time ranges then the summaries can be generated on a bucket by bucket basis. Note that producing intermediate summaries can save the work involved in re running the query for previous time periods so only the newer event data needs to be processed while generating an updated report. These report acceleration techniques are described in more detail in U.S. Pat. No. 8 589 403 issued on Nov. 19 2013 and U.S. Pat. No. 8 412 696 issued on Apr. 2 2011.

The SPLUNK ENTERPRISE platform provides various schemas dashboards and visualizations that make it easy for developers to create applications to provide additional capabilities. One such application is the SPLUNK APP FOR ENTERPRISE SECURITY which performs monitoring and alerting operations and includes analytics to facilitate identifying both known and unknown security threats based on large volumes of data stored by the SPLUNK ENTERPRISE system. This differs significantly from conventional Security Information and Event Management SIEM systems that lack the infrastructure to effectively store and analyze large volumes of security related event data. Traditional SIEM systems typically use fixed schemas to extract data from pre defined security related fields at data ingestion time wherein the extracted data is typically stored in a relational database. This data extraction process and associated reduction in data size that occurs at data ingestion time inevitably hampers future incident investigations when all of the original data may be needed to determine the root cause of a security issue or to detect the tiny fingerprints of an impending security threat.

In contrast the SPLUNK APP FOR ENTERPRISE SECURITY system stores large volumes of minimally processed security related data at ingestion time for later retrieval and analysis at search time when a live security threat is being investigated. To facilitate this data retrieval process the SPLUNK APP FOR ENTERPRISE SECURITY provides pre specified schemas for extracting relevant values from the different types of security related event data and also enables a user to define such schemas.

The SPLUNK APP FOR ENTERPRISE SECURITY can process many types of security related information. In general this security related information can include any information that can be used to identify security threats. For example the security related information can include network related information such as IP addresses domain names asset identifiers network traffic volume uniform resource locator strings and source addresses. The process of detecting security threats for network related information is further described in U.S. patent application Ser. Nos. 13 956 252 and 13 956 262. Security related information can also include endpoint information such as malware infection data and system configuration information as well as access control information such as login logout information and access failure notifications. The security related information can originate from various sources within a data center such as hosts virtual machines storage devices and sensors. The security related information can also originate from various sources in a network such as routers switches email servers proxy servers gateways firewalls and intrusion detection systems.

During operation the SPLUNK APP FOR ENTERPRISE SECURITY facilitates detecting so called notable events that are likely to indicate a security threat. These notable events can be detected in a number of ways 1 an analyst can notice a correlation in the data and can manually identify a corresponding group of one or more events as notable or 2 an analyst can define a correlation search specifying criteria for a notable event and every time one or more events satisfy the criteria the application can indicate that the one or more events are notable. An analyst can alternatively select a pre defined correlation search provided by the application. Note that correlation searches can be run continuously or at regular intervals e.g. every hour to search for notable events. Upon detection notable events can be stored in a dedicated notable events index which can be subsequently accessed to generate various visualizations containing security related information. Also alerts can be generated to notify system operators when important notable events are discovered.

The SPLUNK APP FOR ENTERPRISE SECURITY provides various visualizations to aid in discovering security threats such as a key indicators view that enables a user to view security metrics of interest such as counts of different types of notable events. For example illustrates an exemplary key indicators view that comprises a dashboard which can display a value for various security related metrics such as malware infections . It can also display a change in a metric value which indicates that the number of malware infections increased by 63 during the preceding interval. Key indicators view additionally displays a histogram panel that displays a histogram of notable events organized by urgency values and a histogram of notable events organized by time intervals. This key indicators view is described in further detail in pending U.S. patent application Ser. No. 13 956 338 filed Jul. 31 2013.

These visualizations can also include an incident review dashboard that enables a user to view and act on notable events. These notable events can include 1 a single event of high importance such as any activity from a known web attacker or 2 multiple events that collectively warrant review such as a large number of authentication failures on a host followed by a successful authentication. For example illustrates an exemplary incident review dashboard that includes a set of incident attribute fields that for example enables a user to specify a time range field for the displayed events. It also includes a timeline that graphically illustrates the number of incidents that occurred in one hour time intervals over the selected time range. It additionally displays an events list that enables a user to view a list of all of the notable events that match the criteria in the incident attributes fields . To facilitate identifying patterns among the notable events each notable event can be associated with an urgency value e.g. low medium high critical which is indicated in the incident review dashboard. The urgency value for a detected event can be determined based on the severity of the event and the priority of the system component associated with the event. The incident review dashboard is described further in http docs.splunk.com Documentation PCI 2.1.1 User IncidentReviewdashboard. 

As mentioned above the SPLUNK ENTERPRISE platform provides various features that make it easy for developers to create various applications. One such application is the SPLUNK APP FOR VMWARE which performs monitoring operations and includes analytics to facilitate diagnosing the root cause of performance problems in a data center based on large volumes of data stored by the SPLUNK ENTERPRISE system.

This differs from conventional data center monitoring systems that lack the infrastructure to effectively store and analyze large volumes of performance information and log data obtained from the data center. In conventional data center monitoring systems this performance data is typically pre processed prior to being stored for example by extracting pre specified data items from the performance data and storing them in a database to facilitate subsequent retrieval and analysis at search time. However the rest of the performance data is not saved and is essentially discarded during pre processing. In contrast the SPLUNK APP FOR VMWARE stores large volumes of minimally processed performance information and log data at ingestion time for later retrieval and analysis at search time when a live performance issue is being investigated.

The SPLUNK APP FOR VMWARE can process many types of performance related information. In general this performance related information can include any type of performance related data and log data produced by virtual machines and host computer systems in a data center. In addition to data obtained from various log files this performance related information can include values for performance metrics obtained through an application programming interface API provided as part of the vSphere Hypervisor system distributed by VMware Inc. of Palo Alto Calif. For example these performance metrics can include 1 CPU related performance metrics 2 disk related performance metrics 3 memory related performance metrics 4 network related performance metrics 5 energy usage statistics 6 data traffic related performance metrics 7 overall system availability performance metrics 8 cluster related performance metrics and 9 virtual machine performance statistics. For more details about such performance metrics please see U.S. patent Ser. No. 14 167 316 filed 29 Jan. 2014 which is hereby incorporated herein by reference. Also see vSphere Monitoring and Performance Update 1 vSphere 5.5 EN 001357 00 http pubs.vmware.com vsphere 55 topic com.vmware.ICbase PDF vsphere esxi vcenter server 551 monitoring performance guide.pdf.

To facilitate retrieving information of interest from performance data and log files the SPLUNK APP FOR VMWARE provides pre specified schemas for extracting relevant values from different types of performance related event data and also enables a user to define such schemas.

The SPLUNK APP FOR VMWARE additionally provides various visualizations to facilitate detecting and diagnosing the root cause of performance problems. For example one such visualization is a proactive monitoring tree that enables a user to easily view and understand relationships among various factors that affect the performance of a hierarchically structured computing system. This proactive monitoring tree enables a user to easily navigate the hierarchy by selectively expanding nodes representing various entities e.g. virtual centers or computing clusters to view performance information for lower level nodes associated with lower level entities e.g. virtual machines or host systems . Exemplary node expansion operations are illustrated in wherein nodes and are selectively expanded. Note that nodes can be displayed using different patterns or colors to represent different performance states such as a critical state a warning state a normal state or an unknown offline state. The ease of navigation provided by selective expansion in combination with the associated performance state information enables a user to quickly diagnose the root cause of a performance problem. The proactive monitoring tree is described in further detail in U.S. patent application Ser. No. 14 235 490 filed on 15 Apr. 2014 which is hereby incorporated herein by reference for all possible purposes.

The SPLUNK APP FOR VMWARE also provides a user interface that enables a user to select a specific time range and then view heterogeneous data comprising events log data and associated performance metrics for the selected time range. For example the screen illustrated in displays a listing of recent tasks and events and a listing of recent log entries for a selected time range above a performance metric graph for average CPU core utilization for the selected time range. Note that a user is able to operate pull down menus to selectively display different performance metric graphs for the selected time range. This enables the user to correlate trends in the performance metric graph with corresponding event and log data to quickly determine the root cause of a performance problem. This user interface is described in more detail in U.S. patent application Ser. No. 14 167 316 filed on 29 Jan. 2014 which is hereby incorporated herein by reference for all possible purposes.

The example computer system includes a processing device processor a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM double data rate DDR SDRAM or DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus .

Processor processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor or a processor implementing other instruction sets or processors implementing a combination of instruction sets. The processor may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processor is configured to execute instructions for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an input device e.g. a keyboard and alphanumeric keyboard a motion sensing input device touch screen a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device can include a computer readable storage medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The instructions can also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting computer readable storage media. The instructions may further be transmitted or received over a network via the network interface device .

In one implementation the instructions include instructions for a primary machine module e.g. module and of and or a software library containing methods that call the correlation search wizard module. In one implementation the instructions include instructions for a secondary machine module e.g. module and of and or a software library containing methods that call the correlation search module. While the computer readable storage medium machine readable storage medium is shown in an exemplary implementation to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present disclosure. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories optical media and magnetic media.

In the foregoing description numerous details are set forth. It will be apparent however to one of ordinary skill in the art having the benefit of this disclosure that the present disclosure may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present disclosure.

Some portions of the detailed description have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as providing causing receiving obtaining associating or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical e.g. electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

For simplicity of explanation the methods are depicted and described herein as a series of acts. However acts in accordance with this disclosure can occur in various orders and or concurrently and with other acts not presented and described herein. Furthermore not all illustrated acts may be required to implement the methods in accordance with the disclosed subject matter. In addition those skilled in the art will understand and appreciate that the methods could alternatively be represented as a series of interrelated states via a state diagram or events. Additionally it should be appreciated that the methods disclosed in this specification are capable of being stored on an article of manufacture to facilitate transporting and transferring such methods to computing devices. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device or storage media.

Certain implementations of the present disclosure also relate to an apparatus for performing the operations herein. This apparatus may be constructed for the intended purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions.

Reference throughout this specification to one implementation or an implementation means that a particular feature structure or characteristic described in connection with the implementation is included in at least one implementation. Thus the appearances of the phrase in one implementation or in an implementation in various places throughout this specification are not necessarily all referring to the same implementation. In addition the term or is intended to mean an inclusive or rather than an exclusive or. Moreover the words example or exemplary are used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather use of the words example or exemplary is intended to present concepts in a concrete fashion.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other implementations will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the disclosure should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

